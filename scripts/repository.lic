=begin

  This script allows you to connect to the Lich server to upload and download scripts,
  and the map database.

  ;repository help

        author: elanthia-online
 maintained by: Tillmen, EO team, SpiffyJr
          game: any
          tags: core
      required: Lich > 5.0.1
       version: 2.56

  changelog:
    2.56 (2024-06-21):
      Update help output to show new --search=TEXT option
    2.55 (2024-06-05):
      Use cert Tillmen issued. Thanks Tillmen!
    2.54 (2024-06-04):
      SSL cert expired, just ignore it I guess
    2.53 (2024-05-15):
      convert global vars to Lich5 constants
      add default save location for yaml/json to DATA_DIR
      remove code for upload-lich5/download-lich5 commands
    2.52 (2024-05-05):
      update default updatable scripts for new installs to mirror scripts bundled with Lich5 releases
    2.51 (2024-04-05):
      bugfix for UI sorting
    2.50 (2024-03-23):
      updated UI to allow keyword searches and downloads
      added --search CLI option to search all name, tags, comments
    2.49 (2024-01-04):
      change effect-list.xml to be updatable on fresh installs by default as required for core functionality
    2.48 (2023-09-11):
      add new mapdb-check option to show last mapdb upload date, author, and if mapdb is up-to-date
    2.47 (2023-09-03):
      update show-updatable output to list author & game for scripts
    2.46 (2023-09-01):
      fix for infomon/waggle/xnarost download help
    2.45 (2023-06-04):
      bugfix for script/Script scope
    2.44 (2023-06-04):
      Set GST to default update mapdb if not set to false/true already
      replace script.vars with Script.current.vars
    2.43 (2023-05-17):
      Add ability to refresh spell data with new effect-list.xml
      rubocop cleanup
    2.42 (2023-01-23):
      Update for Ruby v3 compatibility
    2.41 (2022-10-06):
      remove reference to $SAFE
    2.40 (2022-10-06):
      remove lich update function ability
      remove ability to overwrite Lich5 version of infomon/waggle/xnarost
    2.39 (2022-05-29):
      change default list of updateable scripts
    2.38 (2022-04-03):
      add data folder support for .ui files
    2.37 (2022-03-13):
      changed updatables
=end

begin
  require 'terminal-table' unless defined?(Terminal::Table)
rescue LoadError
  respond "You need to have the 'terminal-table' gem installed"
  respond "Please install it with the following command: gem install terminal-table"
  respond "Via your computer's local terminal/shell"
  exit
end

unless defined?(LICH_VERSION) # Lich < 4.5
  LICH_VERSION = $version
end

if Settings['updatable'].nil?
  Settings['updatable'] = Hash.new
  Settings['updatable'][:scripts] = Array.new
  Settings['updatable'][:scripts].push(:filename => 'alias.lic', :game => 'gs', :author => 'elanthia-online')
  Settings['updatable'][:scripts].push(:filename => 'autostart.lic', :game => 'gs', :author => 'elanthia-online')
  Settings['updatable'][:scripts].push(:filename => 'jinx.lic', :game => 'gs', :author => 'elanthia-online')
  Settings['updatable'][:scripts].push(:filename => 'map.lic', :game => 'gs', :author => 'elanthia-online')
  Settings['updatable'][:scripts].push(:filename => 'repository.lic', :game => 'gs', :author => 'elanthia-online')
  Settings['updatable'][:scripts].push(:filename => 'vars.lic', :game => 'gs', :author => 'elanthia-online')
  Settings['updatable'][:scripts].push(:filename => 'version.lic', :game => 'gs', :author => 'elanthia-online')
  if XMLData.game =~ /^GS/
    # GemstoneIV specific updatable scripts here
    Settings['updatable'][:scripts].push(:filename => 'effect-list.xml', :game => 'gs', :author => 'elanthia-online')
    Settings['updatable'][:scripts].push(:filename => 'gameobj-data.xml', :game => 'gs', :author => 'elanthia-online')
    Settings['updatable'][:scripts].push(:filename => 'go2.lic', :game => 'gs', :author => 'elanthia-online')
    Settings['updatable'][:scripts].push(:filename => 'ewaggle.lic', :game => 'gs', :author => 'elanthia-online')
    Settings['updatable'][:scripts].push(:filename => 'log.lic', :game => 'gs', :author => 'elanthia-online')
  elsif XMLData.game =~ /^DR/
    # DragonRealms specific updatable scripts here
  end
  Settings['updatable'][:mapdb] = Hash.new
  Settings['updatable'][:mapdb][XMLData.game] = true
  Settings['updatable'][:mapdb]['GSIV'] = true
  Settings['updatable'][:mapdb]['GSF'] = true
  Settings['updatable'][:mapdb]['GSPlat'] = true
  Settings['updatable'][:lich] = false
end

Settings['updatable'][:mapdb]['GST'] = true if Settings['updatable'][:mapdb]['GST'].nil?
if (s = Settings['updatable'][:scripts].find { |script_updatable| script_updatable[:filename] == 'gameobj-data.xml' && script_updatable[:author] == 'Tillmen' })
  echo "updating ownership of #{s[:filename]} from Tillmen to elanthia-online"
  s[:author] = 'elanthia-online'
end
if (s = Settings['updatable'][:scripts].find { |script_updatable| script_updatable[:filename] =~ /^(?:repository|lnet|alias|vars|go2|autostart).lic$/ && script_updatable[:author] == 'Tillmen' })
  echo "updating ownership of #{s[:filename]} from Tillmen to elanthia-online"
  s[:author] = 'elanthia-online'
  s[:game] = 'gs'
end

require 'openssl'
require 'digest/md5'

hostname           = 'repo.lichproject.org'
port               = 7157
ca_cert            = OpenSSL::X509::Certificate.new("-----BEGIN CERTIFICATE-----\nMIIDoDCCAoigAwIBAgIUYwhIyTlqWaEd5mYGXoQQoC+ndKcwDQYJKoZIhvcNAQEL\nBQAwYTELMAkGA1UEBhMCVVMxETAPBgNVBAgMCElsbGlub2lzMRIwEAYDVQQKDAlN\nYXR0IExvd2UxDzANBgNVBAMMBlJvb3RDQTEaMBgGCSqGSIb3DQEJARYLbWF0dEBp\nbzQudXMwHhcNMjQwNjA1MTM1NzUxWhcNNDQwNTMxMTM1NzUxWjBhMQswCQYDVQQG\nEwJVUzERMA8GA1UECAwISWxsaW5vaXMxEjAQBgNVBAoMCU1hdHQgTG93ZTEPMA0G\nA1UEAwwGUm9vdENBMRowGAYJKoZIhvcNAQkBFgttYXR0QGlvNC51czCCASIwDQYJ\nKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJwhGfQgwI1h4vlqAqaR152AlewjJMlL\nyoqtjoS9Cyri23SY7c6v0rwhoOXuoV1D2d9InmmE2CgLL3Bn2sNa/kWFjkyedUca\nvd8JrtGQzEkVH83CIPiKFCWLE5SXLvqCVx7Jz/pBBL1s173p69kOy0REYAV/OAdj\nioCXK6tHqYG70xvLIJGiTrExGeOttMw2S+86y4bSxj2i35IscaBTepPv7BWH8JtZ\nyN4Xv9DBr/99sWSarlzUW6+FTcNqdJLP5W5a508VLJnevmlisswlazKiYNriCQvZ\nsnmPJrYFYMxe9JIKl1CA8MiUKUx8AUt39KzxkgZrq40VxIrpdxrnUKUCAwEAAaNQ\nME4wHQYDVR0OBBYEFJxuCVGIbPP3LO6GAHAViOCKZ4HIMB8GA1UdIwQYMBaAFJxu\nCVGIbPP3LO6GAHAViOCKZ4HIMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQELBQAD\nggEBAGKn0vYx9Ta5+/X1WRUuADuie6JuNMHUxzYtxwEba/m5lA4nE5f2yoO6Y/Y3\nLZDX2Y9kWt+7pGQ2SKOT79gNcnOSc3SGYWkX48J6C1hihhjD3AfD0hb1mgvlJuij\nzNnZ7vczOF8AcvBeu8ww5eIrkN6TTshjICg71/deVo9HvjhiCGK0XvL+WL6EQwLe\n6/nVVFrPfd0sRZZ5OTJR5nM1kA71oChUw9mHCyrAc3zYyW37k+p8ADRFfON8th8M\n1Blel1SpgqlQ22WpYoHbUCSjGt6JKC/HrSHdKBezTuRahOSfqwncAE77Dz4FJaQ5\nWD2mk3SZbB2ytAHUDEy3xr697EI=\n-----END CERTIFICATE-----")
client_version     = '2.38'
mapdb_reloaded     = false
cmd                = Array.new
cmd_author         = nil
cmd_password       = nil
cmd_tags           = nil
cmd_show_tags      = nil
cmd_sort           = nil
cmd_reverse        = nil
cmd_limit          = nil
cmd_force          = nil
cmd_name           = nil
cmd_search         = nil
cmd_game           = nil
cmd_age            = nil
cmd_size           = nil
cmd_downloads      = nil
cmd_rating         = nil
cmd_version        = nil
no_more_options    = nil
cmd_show_tags      = nil
cmd_hide_age       = nil
cmd_hide_size      = nil
cmd_hide_author    = nil
cmd_hide_downloads = nil
cmd_hide_rating    = nil

get_comments_from_data = proc { |data|
  begin
    if data =~ /^=begin\r?\n?(.+?)^=end/m
      $1.split("\n")
    else
      comments = Array.new
      data.split("\n").each { |line| if line =~ /^[\t\s]*#/; comments.push(line); elsif line !~ /^[\t\s]*$/; break; end }
      comments
    end
  rescue
    Array.new
  end
}

get_author_from_comments = proc { |comments|
  author = nil
  for line in comments
    if line =~ /^[\s\t#]*author:[\s\t]*([\w,\s\.\d]+)/i
      author = $1.sub(/\s\(.*?\)/, '').strip
      break
    end
  end
  author
}

get_game_from_comments = proc { |comments|
  game = nil
  for line in comments
    if line =~ /^[\s\t#]*game:[\s\t]*([\w,\s\.\d]+)/i
      game = $1.strip
      break
    end
  end
  if game =~ /^Gemstone$/i
    'GS'
  elsif game =~ /^Dragon\s*Realms$/i
    'DR'
  else
    game
  end
}

get_tags_from_comments = proc { |comments|
  tags = nil
  for line in comments
    if line =~ /^[\s\t#]*tags:[\s\t]*([\w,\s\.\d]+)/i
      tags = $1.strip
      break
    end
  end
  tags
}

unmet_lich_requirement = proc { |comments|
  requirement = nil
  current_version = LICH_VERSION.split('.').collect { |num| num.rjust(5, '0') }.join('.')
  for line in comments
    if line =~ /^[\s\t#]*required:[\s\t]*(.+)/i
      $1.split(',').each { |req|
        if req.strip =~ /^[\s\t]*Lich[\s\t]*(>|<|=|>=|<=)[\s\t]*([0-9\.]+)/i
          op = $1
          version = $2
          needed_version = version.split('.').collect { |num| num.rjust(5, '0') }.join('.')
          if op == '<'
            if current_version >= needed_version
              requirement = "< #{version}"
              break
            end
          elsif op == '>'
            if current_version <= needed_version
              requirement = "> #{version}"
              break
            end
          elsif op == '='
            if current_version != needed_version
              requirement = "= #{version}"
              break
            end
          elsif op == '>='
            if current_version < needed_version
              requirement = ">= #{version}"
              break
            end
          elsif op == '<='
            if current_version > needed_version
              requirement = "<= #{version}"
              break
            end
          end
        end
      }
    end
    break if requirement
  end
  requirement
}

connect = proc {
  begin
    if ca_cert.not_before > Time.now
      respond "repository warning: SSL cert reports it is not valid yet. Setting verify mode to NONE."
      verify_mode = OpenSSL::SSL::VERIFY_NONE
    elsif ca_cert.not_after < Time.now
      respond "repository warning: SSL cert is expired. Setting verify mode to NONE."
      verify_mode = OpenSSL::SSL::VERIFY_NONE
    else
      verify_mode = OpenSSL::SSL::VERIFY_PEER
    end
    cert_store = OpenSSL::X509::Store.new
    cert_store.add_cert(ca_cert)
    ssl_context             = OpenSSL::SSL::SSLContext.new
    ssl_context.options     = (OpenSSL::SSL::OP_NO_SSLv2 + OpenSSL::SSL::OP_NO_SSLv3)
    ssl_context.cert_store  = cert_store
    if OpenSSL::SSL::VERIFY_PEER == OpenSSL::SSL::VERIFY_NONE
      # the plat_updater script redefines OpenSSL::SSL::VERIFY_PEER, disabling it for everyone
      ssl_context.verify_mode = 1 # probably right
    else
      ssl_context.verify_mode = verify_mode
    end
    socket                  = TCPSocket.new(hostname, port)
    ssl_socket              = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)
    ssl_socket.connect
    if (ssl_socket.peer_cert.subject.to_a.find { |n| n[0] == 'CN' }[1] != 'lichproject.org') and (ssl_socket.peer_cert.subject.to_a.find { |n| n[0] == 'CN' }[1] != 'Lich Repository')
      if cmd_force
        echo "warning: server certificate hostname mismatch"
      else
        echo "error: server certificate hostname mismatch"
        ssl_socket.close rescue nil
        socket.close rescue nil
        exit
      end
    end
    def ssl_socket.geth
      hash = Hash.new
      gets.scan(/[^\t]+\t[^\t]+(?:\t|\n)/).each { |s| s = s.chomp.split("\t"); hash[s[0].downcase] = s[1] }
      return hash
    end

    def ssl_socket.puth(h)
      puts h.to_a.flatten.join("\t")
    end
  rescue
    echo "error connecting to server: #{$!}"
    ssl_socket.close rescue nil
    socket.close rescue nil
    exit
  end
  [ssl_socket, socket]
}

get_list = proc {
  request = { 'action' => 'list', 'supported compressions' => 'gzip', 'client' => client_version }
  request['current-md5sum'] = Digest::MD5.new.update(Settings['cached-list']).to_s if Settings['cached-list']
  begin
    ssl_socket, socket = connect.call
    ssl_socket.puth(request)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      if response['error'] == 'already up-to-date'
        echo 'list up-to-date' if $repository_debug
        nil
      else
        echo "error: server says: #{response['error']}"
        exit
      end
    else
      if response['size'].nil? or (response['size'] !~ /^[0-9]+$/) or not response['server time']
        echo "error: unrecognized response from server: #{response.inspect}"
        exit
      elsif response['compression'] and response['compression'] != 'gzip'
        echo "error: unsupported compression method: #{response['compression']}"
        exit
      end
      data = ssl_socket.read(response['size'].to_i)
      if response['compression'] == 'gzip'
        data_gz = data
        echo "list data_gz: #{data_gz.length}" if $repository_debug
        StringIO.open(data_gz) { |data_gz_io|
          begin
            gz_reader = Zlib::GzipReader.new(data_gz_io)
            data = gz_reader.read
          ensure
            gz_reader.close
          end
        }
        # data_gz = nil # rubocop useless assignment to variable
      end
      Settings['cached-list'] = data
      Settings['cached-list-offset'] = Time.now.to_i - response['server time'].to_i
    end
    echo "list data: #{Settings['cached-list'].length}" if $repository_debug
    list = Array.new
    Settings['cached-list'].split("\n").each { |d| list.push(d.split("\t", -1)) }
    headers = list.shift
    if (lui = headers.index('last update'))
      list.each { |row| row[lui] = row[lui].to_i + Settings['cached-list-offset'] }
    end
    list.unshift(headers)
    list
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
  end
}

add_comments_to_list = proc { |list|
  request = { 'action' => 'list-comments', 'supported compressions' => 'gzip', 'client' => client_version }
  request['current-md5sum'] = Digest::MD5.new.update(Settings['cached-list-comments']).to_s if Settings['cached-list-comments']
  begin
    ssl_socket, socket = connect.call
    ssl_socket.puth(request)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      if response['error'] == 'already up-to-date'
        echo 'comments up-to-date' if $repository_debug
        nil
      else
        echo "error: server says: #{response['error']}"
        exit
      end
    else
      if response['size'].nil? or (response['size'] !~ /^[0-9]+$/) or not response['server time']
        echo "error: unrecognized response from server: #{response.inspect}"
        exit
      elsif response['compression'] and response['compression'] != 'gzip'
        echo "error: unsupported compression method: #{response['compression']}"
        exit
      end
      data = ssl_socket.read(response['size'].to_i)
      if response['compression'] == 'gzip'
        data_gz = data
        echo "comments data_gz: #{data_gz.length}" if $repository_debug
        StringIO.open(data_gz) { |data_gz_io|
          begin
            gz_reader = Zlib::GzipReader.new(data_gz_io)
            data = gz_reader.read
          ensure
            gz_reader.close
          end
        }
        # data_gz = nil # rubocop useless assignment to variable
      end
      Settings['cached-list-comments'] = data
    end
    echo "comments data: #{Settings['cached-list-comments'].length}" if $repository_debug
    headers = list.shift
    fi = headers.index('file')
    gi = headers.index('game')
    ci = headers.length
    headers[ci] = 'comments'
    foist = true
    headers2 = fi2 = gi2 = ci2 = nil
    Settings['cached-list-comments'].split("\n").each { |d|
      if foist
        foist = false
        headers2 = d.split("\t", -1)
        fi2 = headers2.index('file')
        gi2 = headers2.index('game')
        ci2 = headers2.index('comments')
      else
        row2 = d.split("\t", -1)
        if (row = list.find { |r| (r[fi] == row2[fi2]) and (r[gi] == row2[gi2]) })
          row[ci] = row2[ci2].gsub("\x14", "\t").gsub("\x12", "\n")
        end
      end
    }
    list.unshift(headers)
    list
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
  end
}

filter_list = proc { |list|
  headers = list.shift
  if cmd_search
    for search in cmd_search
      list.delete_if { |item|
        !item.any? { |column| column.to_s.downcase.include?(search) }
      }
    end
  else
    if cmd_name and (fi = headers.index('file'))
      for name in cmd_name
        list.delete_if { |row| row[fi] !~ /#{name.split(',').collect { |n| Regexp.escape(n) }.join('|')}/i }
      end
    end
    if (gi = headers.index('game'))
      if cmd_game
        games = cmd_game.split(',').collect { |g| g.downcase.strip }
      elsif XMLData.game =~ /^GS/
        games = ['gs', 'any']
      elsif XMLData.game =~ /^DR/
        games = ['dr', 'any']
      else
        games = ['other', 'any']
      end
      list.delete_if { |row| not games.include?(row[gi]) }
    end
    if cmd_size and (si = headers.index('size'))
      for op, bytes in cmd_size
        if op == '>'
          list.delete_if { |row| row[si].to_i <= bytes }
        elsif op == '<'
          list.delete_if { |row| row[si].to_i >= bytes }
        elsif op == '='
          list.delete_if { |row| row[si].to_i != bytes }
        end
      end
    end
    if cmd_age and (lui = headers.index('last update'))
      now = Time.now.to_i
      for op, seconds in cmd_age
        if op == '>'
          list.delete_if { |row| (now - row[lui].to_i) <= seconds }
        elsif op == '<'
          list.delete_if { |row| (now - row[lui].to_i) >= seconds }
        end
      end
    end
    if cmd_author and (ai = headers.index('author'))
      authors = cmd_author.split(',').collect { |a| a.downcase.gsub(/[^a-z]+/, '') }
      list.delete_if { |row| not authors.include?(row[ai].downcase.gsub(/[^a-z]+/, '')) }
    end
    if cmd_downloads and (di = headers.index('downloads'))
      for op, dc in cmd_downloads
        if op == '>'
          list.delete_if { |row| row[di].to_i <= dc }
        elsif op == '<'
          list.delete_if { |row| row[di].to_i >= dc }
        elsif op == '='
          list.delete_if { |row| row[di].to_i != dc }
        end
      end
    end
    if cmd_rating and (rti = headers.index('rating total')) and (rci = headers.index('rating count'))
      list.delete_if { |row| row[rci].to_i.zero? }
      for op, rate in cmd_rating
        list.delete_if { |row| (row[rti] !~ /^[0-9]+$/) or (row[rci] !~ /^[0-9]+$/) or ((op == '>') and ((row[rti].to_f / row[rci].to_f) <= rate)) or ((op == '<') and ((row[rti].to_f / row[rci].to_f) >= rate)) or ((op == '=') and ((row[rti].to_f / row[rci].to_f).abs != rate)) }
      end
    end
    if cmd_tags and (ti = headers.index('tags'))
      for tags in cmd_tags
        tags = tags.split(',').collect { |t| t.downcase.gsub(/[^a-z]+/, '') }
        list.delete_if { |row| (tags & (row[ti].split(',').collect { |t| t.downcase.gsub(/[^a-z]+/, '') })).empty? }
      end
    end
  end
  list.unshift(headers)
  list
}

format_list = proc { |list|
  headers = list.shift
  if (rti = headers.index('rating total')) and (rci = headers.index('rating count'))
    list.each_index { |ri|
      if (list[ri][rti] =~ /^[0-9]+$/) and (list[ri][rci].to_i > 0)
        #       list[ri][rti] = "#{(list[ri][rti].to_f / list[ri][rci].to_f).to_s.slice(/^[0-9]+(?:\.[0-9])?/)} (#{list[ri][rti]}/#{list[ri][rci]})"
        list[ri][rti] = "#{(list[ri][rti].to_f / list[ri][rci].to_f).to_s.slice(/^[0-9]+(?:\.[0-9])?/)} (#{list[ri][rci]})"
      else
        list[ri][rti] = String.new
      end
    }
    headers[rti] = 'rating'
    headers.delete_at(rci)
    list.each { |row| row.delete_at(rci) }
  end
  if cmd_sort
    if cmd_sort == 'name'
      cmd_sort = 'file'
    elsif cmd_sort =~ /^(?:last\-?)?updated?$|^age$|^date$/
      cmd_sort = 'last update'
    end
    if (i = headers.index(cmd_sort))
      if cmd_sort =~ /^(?:size|updated|age|downloads)$/
        list.sort! { |a, b| a[i].to_i <=> b[i].to_i }
      elsif cmd_sort == 'rating'
        list.sort! { |a, b| a[i].to_s.slice(/[0-9\.]+/).to_f <=> b[i].to_s.slice(/[0-9\.]+/).to_f }
      else
        list.sort! { |a, b| a[i] <=> b[i] }
      end
    else
      echo "warning: couldn't find a header named #{cmd_sort} in the list"
    end
  end
  if cmd_reverse
    list.reverse!
  end
  if (lui = headers.index('last update'))
    list.each_index { |ri|
      list[ri][lui] = "#{Time.at(list[ri][lui].to_i).strftime("%Y-%m-%d %I:%M%p").downcase.gsub(/\s0/, '  ')}"
    }
  end
  if (si = headers.index('size'))
    list.each_index { |ri|
      list[ri][si] = "#{(list[ri][si].to_f / 1024).to_s.slice(/^[0-9]+(?:\.[0-9])?/)}k"
    }
  end
  if (c = headers.index('game')) and (f = headers.index('file'))
    f_list = list.collect { |r| r[f] }.uniq
    g_list = list.collect { |r| r[c] }.uniq
    g_list.delete('any')
    unless (f_list.length < list.length) or (g_list.length > 1)
      headers.delete_at(c)
      list.each { |r| r.delete_at(c) }
    end
  end
  if (di = headers.index('downloads'))
    headers[di] = 'DLs'
  end
  if cmd_tags.nil? and not cmd_show_tags and (ti = headers.index('tags'))
    list.each_index { |ri| list[ri].delete_at(ti) }
    headers.delete_at(ti)
  else
    if (ti = headers.index('tags'))
      list.each_index { |ri|
        if list[ri][ti].length > 20
          list[ri][ti] = "#{list[ri][ti][0, 19]}>"
        end
      }
    end
  end
  if cmd_hide_rating and (i = headers.index('rating'))
    list.each_index { |ri| list[ri].delete_at(i) }
    headers.delete_at(i)
  end
  if cmd_hide_downloads and (di = headers.index('DLs'))
    list.each_index { |ri| list[ri].delete_at(di) }
    headers.delete_at(di)
  end
  if cmd_hide_author and (ai = headers.index('author'))
    list.each_index { |ri| list[ri].delete_at(ai) }
    headers.delete_at(ai)
  end
  if cmd_hide_size and (si = headers.index('size'))
    list.each_index { |ri| list[ri].delete_at(si) }
    headers.delete_at(si)
  end
  if cmd_hide_age and (lui = headers.index('last update'))
    list.each_index { |ri| list[ri].delete_at(lui) }
    headers.delete_at(lui)
  end
  if (co = headers.index('comments'))
    list.each_index { |ri| list[ri].delete_at(co) }
    headers.delete_at(co)
  end

  list.unshift headers
  column_width = Array.new
  list[0].each_index { |list_i|
    list.each { |r|
      column_width[list_i] = [column_width[list_i].to_i, r[list_i].to_s.length].max
    }
  }
  headers = list.shift
  if cmd_limit
    if cmd_limit =~ /^([0-9]+),([0-9]+)$/
      list = list[($1.to_i), ($2.to_i)]
    elsif cmd_limit =~ /^[0-9]+$/
      list = list[0, (cmd_limit.to_i)]
    end
  end
  ti = headers.index('tags') || -1
  list.unshift(column_width.collect { |column_c| ''.rjust(column_c, '-') })
  list.unshift headers
  list.each { |row|
    row.each_index { |row_i|
      if row_i == ti
        row[row_i] = row[row_i].ljust(column_width[row_i])
      else
        row[row_i] = row[row_i].rjust(column_width[row_i])
      end
    }
  }
  list.collect { |row| row.join('   ') }.join("\n")
}

download_mapdb = proc {
  unless defined?(Map.save_json)
    echo 'error: Your version of Lich is too old to download the map database.'
  else
    failed = true
    downloaded = false
    if XMLData.game =~ /^GS/i
      if XMLData.game =~ /^GSF$|^GSPlat$/i
        game = XMLData.game.downcase
      else
        game = 'gsiv'
      end
    elsif XMLData.game =~ /^DR/i
      if XMLData.game =~ /^DRF$|^DRX$/i
        game = XMLData.game.downcase
      else
        game = 'dr'
      end
    else
      game = XMLData.game.downcase
    end
    request = { 'action' => 'download-mapdb', 'game' => game, 'supported compressions' => 'gzip', 'client' => client_version }
    if (current_map = Dir.entries(File.join(DATA_DIR, XMLData.game)).find_all { |fn| fn =~ /^map\-[0-9]+\.(?:dat|xml|json)$/i }.sort[-1])
      request['current-md5sum'] = Digest::MD5.file(File.join(DATA_DIR, XMLData.game, "#{current_map}")).to_s
    end
    begin
      ssl_socket, socket = connect.call
      ssl_socket.puth(request)
      response = ssl_socket.geth
      if response['warning']
        echo "warning: server says: #{response['warning']}"
      end
      if response['error']
        if response['error'] == 'already up-to-date'
          if response['timestamp'] and response['uploaded by']
            echo "map database is up-to-date; last updated by #{response['uploaded by']} at #{Time.at(response['timestamp'].to_i)}"
          else
            echo 'map database is up-to-date'
          end
          failed = false
        else
          echo "error: server says: #{response['error']}"
        end
      elsif response['compression'] and response['compression'] != 'gzip'
        echo "error: unsupported compression method: #{response['compression']}"
      else
        response['size'] = response['size'].to_i
        newfilename = File.join(DATA_DIR, XMLData.game, "map-#{response['timestamp']}.json")
        tempfilename = File.join(TEMP_DIR, "#{rand(100000000)}.repo")
        if response['timestamp'] and response['uploaded by']
          echo "downloading map database... (uploaded by #{response['uploaded by']} at #{Time.at(response['timestamp'].to_i)})"
        else
          echo 'downloading map database...'
        end
        File.open(tempfilename, 'wb') { |f|
          (response['size'] / 1_000_000).times { f.write(ssl_socket.read(1_000_000)) }
          f.write(ssl_socket.read(response['size'] % 1_000_000)) unless (response['size'] % 1_000_000) == 0
        }
        if response['compression'] == 'gzip'
          ungzipname = File.join(TEMP_DIR, "#{rand(100000000)}")
          File.open(ungzipname, 'wb') { |f|
            Zlib::GzipReader.open(tempfilename) { |f_gz|
              while (data = f_gz.read(1_000_000))
                f.write(data)
              end
              # data = nil # rubocop useless assignment to variable
            }
          }
          begin
            File.rename(ungzipname, tempfilename)
          rescue
            if $!.to_s =~ /Invalid cross-device link/
              File.open(ungzipname, 'rb') { |r| File.open(tempfilename, 'wb') { |w| w.write(r.read) } }
              File.delete(ungzipname)
            else
              raise $!
            end
          end
        end
        md5sum_mismatch = (Digest::MD5.file(tempfilename).to_s != response['md5sum'])
        if md5sum_mismatch and not cmd_force
          echo "error: md5sum mismatch: file likely corrupted in transit"
          File.delete(tempfilename)
        else
          if md5sum_mismatch
            echo "warning: md5sum mismatch: file likely corrupted in transit"
          end
          begin
            File.rename(tempfilename, newfilename)
          rescue
            if $!.to_s =~ /Invalid cross-device link/
              File.open(tempfilename, 'rb') { |r| File.open(newfilename, 'wb') { |w| w.write(r.read) } }
              File.delete(tempfilename)
            else
              raise $!
            end
          end
          failed = false
          downloaded = true
        end
      end
    ensure
      ssl_socket.close rescue nil
      socket.close rescue nil
    end
    unless failed
      if downloaded
        old_maps = Dir.entries(File.join(DATA_DIR, XMLData.game)).find_all { |fn| (fn =~ /^map\-([0-9]+)\.(?:dat|xml|json)$/i) and ($1 != response['timestamp']) }[0...-3]
        unless old_maps.empty?
          echo "deleting old map databases..."
          begin
            old_maps.each { |fn| File.delete(File.join(DATA_DIR, XMLData.game, "#{fn}")) }
          rescue
            echo "error: #{$!}"
          end
          # old_maps = nil # rubocop useless assignment to variable
        end
        # rename map files with a higher timestamp than the just downloaded map, because the user probably wants to use the map they just downloaded
        Dir.entries(File.join(DATA_DIR, XMLData.game)).each { |fn|
          if (fn =~ /^map\-([0-9]+)\.(?:dat|xml|json)$/i) and ($1.to_i > response['timestamp'].to_i)
            begin
              File.rename(File.join(DATA_DIR, XMLData.game, "#{fn}"), File.join(DATA_DIR, XMLData.game, "#{fn}.bak"))
            rescue
              if $!.to_s =~ /Invalid cross-device link/
                File.open(File.join(DATA_DIR, XMLData.game, "#{fn}"), 'rb') { |r| File.open(File.join(DATA_DIR, XMLData.game, "#{fn}.bak"), 'wb') { |w| w.write(r.read) } }
                File.delete(File.join(DATA_DIR, XMLData.game, "#{fn}"))
              else
                raise $!
              end
            end
          end
        }
        echo 'loading map database...'
        Map.reload
        mapdb_reloaded = true
      end
      image_filenames = Array.new
      Map.list.each { |room| image_filenames.push(room.image) if room.image and not image_filenames.include?(room.image) }
      Dir.mkdir(MAP_DIR) unless File.exist?(MAP_DIR)
      image_filenames.delete_if { |fn| File.exist?(File.join(MAP_DIR, "#{fn}")) }
      unless image_filenames.empty?
        echo 'downloading missing map images...'
        begin
          ssl_socket, socket = connect.call
          ssl_socket.puth('action' => 'download-mapdb-images', 'files' => image_filenames.join('/'), 'client' => client_version)
          loop {
            response = ssl_socket.geth
            if response['warning']
              echo "warning: server says: #{response['warning']}"
            end
            if response['error']
              echo "error: server says: #{response['error']}"
              break
            elsif response['success']
              break
            elsif not response['file'] or not response['size'] or not response['md5sum']
              echo "error: unrecognized response from server: #{response.inspect}"
              break
            end
            response['size'] = response['size'].to_i
            tempfilename = File.join(TEMP_DIR, "#{rand(100000000)}.repo")
            echo "downloading #{response['file']}..."
            File.open(tempfilename, 'wb') { |f|
              (response['size'] / 1_000_000).times { f.write(ssl_socket.read(1_000_000)) }
              f.write(ssl_socket.read(response['size'] % 1_000_000)) unless (response['size'] % 1_000_000) == 0
            }
            md5sum_mismatch = (Digest::MD5.file(tempfilename).to_s != response['md5sum'])
            if md5sum_mismatch and not cmd_force
              echo "error: md5sum mismatch: file likely corrupted in transit"
              File.delete(tempfilename)
            else
              if md5sum_mismatch
                echo "warning: md5sum mismatch: file likely corrupted in transit"
              end
              begin
                File.rename(tempfilename, File.join(MAP_DIR, "#{response['file']}"))
              rescue
                if $!.to_s =~ /Invalid cross-device link/
                  File.open(tempfilename, 'rb') { |r| File.open(File.join(MAP_DIR, "#{response['file']}"), 'wb') { |w| w.write(r.read) } }
                  File.delete(tempfilename)
                else
                  raise $!
                end
              end
            end
          }
        ensure
          ssl_socket.close rescue nil
          socket.close rescue nil
        end
      end
      echo 'done'
    end
  end
}

mapdb_check = proc {
  if XMLData.game =~ /^GS/i
    if XMLData.game =~ /^GSF$|^GSPlat$/i
      game = XMLData.game.downcase
    else
      game = 'gsiv'
    end
  elsif XMLData.game =~ /^DR/i
    if XMLData.game =~ /^DRF$|^DRX$/i
      game = XMLData.game.downcase
    else
      game = 'dr'
    end
  else
    game = XMLData.game.downcase
  end
  request = { 'action' => 'download-mapdb', 'game' => game, 'supported compressions' => 'gzip', 'client' => client_version }
  if (current_map = Dir.entries(File.join(DATA_DIR, XMLData.game)).find_all { |fn| fn =~ /^map\-[0-9]+\.(?:dat|xml|json)$/i }.sort[-1])
    request['current-md5sum'] = Digest::MD5.file(File.join(DATA_DIR, XMLData.game, "#{current_map}")).to_s
  end
  begin
    ssl_socket, socket = connect.call
    ssl_socket.puth(request)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error'] == 'already up-to-date'
      echo "map database is currently up to date."
    else
      echo "map database is not currently up to date."
    end
    echo "map database last updated by #{response['uploaded by']} at #{Time.at(response['timestamp'].to_i)}"
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
  end
}

download_file = proc { |file, game, version|
  begin
    ssl_socket, socket = connect.call
    request = { 'action' => 'download', 'file' => file, 'game' => game, 'supported compressions' => 'gzip', 'client' => client_version }
    request['version'] = version unless version.nil?
    ssl_socket.puth(request)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      echo "error: server says: #{response['error']}"
      false
    elsif (response['file'] != file) or (response['size'] !~ /^[0-9]+$/)
      echo 'error: out of cheese 6'
      false
    elsif response['compression'] and response['compression'] != 'gzip'
      echo "error: unsupported compression method: #{response['compression']}"
      false
    else
      response['size'] = response['size'].to_i
      if (file =~ /\.(?:ui|xml|json|yaml|yml)$/i) and (LICH_VERSION.split('.').collect { |num| num.rjust(5, '0') }.join('.') >= '00004.00006.00000')
        newfilename = File.join(DATA_DIR, "#{file}")
      else
        newfilename = File.join(SCRIPT_DIR, "#{file}")
      end
      tempfilename = File.join(TEMP_DIR, "#{rand(100000000)}.repo")
      File.open(tempfilename, 'wb') { |f|
        (response['size'] / 1_000_000).times { f.write(ssl_socket.read(1_000_000)) }
        f.write(ssl_socket.read(response['size'] % 1_000_000)) unless (response['size'] % 1_000_000) == 0
      }
      if response['compression'] == 'gzip'
        ungzipname = File.join(TEMP_DIR, "#{rand(100000000)}")
        File.open(ungzipname, 'wb') { |f|
          Zlib::GzipReader.open(tempfilename) { |f_gz|
            while (data = f_gz.read(1_000_000))
              f.write(data)
            end
            # data = nil # rubocop useless assignment to variable
          }
        }
        begin
          File.rename(ungzipname, tempfilename)
        rescue
          if $!.to_s =~ /Invalid cross-device link/
            File.open(ungzipname, 'rb') { |r| File.open(tempfilename, 'wb') { |w| w.write(r.read) } }
            File.delete(ungzipname)
          else
            raise $!
          end
        end
      end
      md5sum_mismatch = (Digest::MD5.file(tempfilename).to_s != response['md5sum'])
      if md5sum_mismatch and not cmd_force
        echo "error: md5sum mismatch: file likely corrupted in transit"
        File.delete(tempfilename)
        false
      else
        if md5sum_mismatch
          echo "warning: md5sum mismatch: file likely corrupted in transit"
        end
        failed_requirement = unmet_lich_requirement.call(File.open(tempfilename, 'rb') { |f| get_comments_from_data.call(f.read(20_000)) })
        if failed_requirement and not cmd_force
          echo "error: #{file} requires Lich version #{failed_requirement}; your current Lich version is #{LICH_VERSION}"
          File.delete(tempfilename)
          false
        else
          if failed_requirement
            echo "warning: #{file} requires Lich version #{failed_requirement}; your current Lich version is #{LICH_VERSION}"
          end
          begin
            File.rename(tempfilename, newfilename)
          rescue
            if $!.to_s =~ /Invalid cross-device link/
              File.open(tempfilename, 'rb') { |r| File.open(newfilename, 'wb') { |w| w.write(r.read) } }
              File.delete(tempfilename)
            else
              raise $!
            end
          end
          if XMLData.game =~ /^GS/
            if file == 'spell-list.xml' || file == 'effect-list.xml'
              Spell.load
            elsif file == 'gameobj-data.xml'
              GameObj.load_data
            end
          end
          true
        end
      end
    end
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
  end
}

for var in script.vars[1..-1]
  if no_more_options
    cmd.push(var)
  elsif var == '--'
    no_more_options = true
  elsif var =~ /^--/
    if var =~ /^--author/i
      if var =~ /^--author\s*=\s*(.+)/i
        cmd_author = $1
      else
        echo 'error: --author option not complete; e.g. --author=Bob'
        exit
      end
    elsif var =~ /^--password/i
      if var =~ /^--password\s*=\s*(.+)/i
        cmd_password = $1
      else
        echo 'error: --password option not complete; e.g. --password=12345'
        exit
      end
    elsif var =~ /^--sort/i
      if var =~ /^--sort\s*=\s*(.+)/i
        cmd_sort = $1
      else
        echo 'error: --sort option not complete; e.g. --sort=age'
        exit
      end
    elsif var =~ /^--reverse$/i
      cmd_reverse = true
    elsif var =~ /^--limit/i
      if var =~ /^--limit\s*=\s*(.+)/i
        cmd_limit = $1
      else
        echo 'error: --limit option not complete; e.g. --limit=10'
        exit
      end
    elsif var =~ /^--force$/i
      cmd_force = true
    elsif var =~ /^--game/i
      if var =~ /^--game\s*=\s*(.+)/i
        cmd_game = $1
      else
        echo 'error: --game option not complete; e.g. --game=gs'
        exit
      end
    elsif var =~ /^--name/i
      if var =~ /^--name\s*=\s*(.+)/i
        cmd_name ||= Array.new
        cmd_name.push($1)
      else
        echo 'error: --name option not complete; e.g. --name=loot'
        exit
      end
    elsif var =~ /^--search/i
      if var =~ /^--search\s*=\s*(.+)/i
        cmd_search ||= Array.new
        cmd_search.push($1)
      else
        echo 'error: --search option not complete; e.g. --search=loot'
        exit
      end
    elsif var =~ /^--show-?tags$/i
      cmd_show_tags = true
    elsif var =~ /^--hide-?(?:age|date|updated|last-update)$/i
      cmd_hide_age = true
    elsif var =~ /^--hide-?size$/i
      cmd_hide_size = true
    elsif var =~ /^--hide-?author$/i
      cmd_hide_author = true
    elsif var =~ /^--hide-?downloads?$/i
      cmd_hide_downloads = true
    elsif var =~ /^--hide-?rating$/i
      cmd_hide_rating = true
    elsif var =~ /^--tags/i
      if var =~ /^--tags?\s*=\s*(.+)/i
        cmd_tags ||= Array.new
        cmd_tags.push($1)
      else
        echo 'error: --tags option not complete; e.g. --tags=core'
        exit
      end
    elsif var =~ /^--size/i
      if var =~ /^--size\s*(>|<|=)\s*([0-9\.]+)(k|m|g)?b?/i
        cmd_size ||= Array.new
        if $3 == 'g'
          cmd_size.push [$1, ($2.to_f * 1073741824).to_i]
        elsif $3 == 'm'
          cmd_size.push [$1, ($2.to_f * 1048576).to_i]
        elsif $3 == 'k'
          cmd_size.push [$1, ($2.to_f * 1024).to_i]
        else
          cmd_size.push [$1, $2.to_i]
        end
      else
        echo 'error: --size option not complete; e.g. --size>15k'
        exit
      end
    elsif var =~ /^--age/i
      if var =~ /^--age\s*(>|<)\s*([0-9\.]+)(m|h|d|w|y)?$/i
        cmd_age ||= Array.new
        if $3 == 'y'
          cmd_age.push [$1, ($2.to_f * 60 * 60 * 24 * 365).to_i]
        elsif $3 == 'w'
          cmd_age.push [$1, ($2.to_f * 60 * 60 * 24 * 7).to_i]
        elsif $3 == 'd'
          cmd_age.push [$1, ($2.to_f * 60 * 60 * 24).to_i]
        elsif $3 == 'h'
          cmd_age.push [$1, ($2.to_f * 60 * 60).to_i]
        elsif $3 == 'm'
          cmd_age.push [$1, ($2.to_f * 60).to_i]
        else
          cmd_age.push [$1, $2.to_i]
        end
      else
        echo 'error: --age option not complete; e.g. --age<24h'
        exit
      end
    elsif var =~ /^--downloads/i
      if var =~ /^--downloads?\s*(>|<|=)\s*([0-9]+)/i
        cmd_downloads ||= Array.new
        cmd_downloads.push [$1, $2.to_i]
      else
        echo 'error: --downloads option not complete; e.g. --downloads>50'
        exit
      end
    elsif var =~ /^--rating/i
      if var =~ /^--rating\s*(>|<|=)\s*([0-9\.]+)/i
        cmd_rating ||= Array.new
        cmd_rating.push [$1, $2.to_f]
      else
        echo 'error: --rating option not complete; e.g. --rating>8.5'
        exit
      end
    elsif var =~ /^--version/i
      if var =~ /^--version\s*=\s*([0-9\.]+)/i
        cmd_version = $1
      else
        echo 'error: --version option not complete; e.g. --version=1.2'
        exit
      end
    else
      echo "error: unknown option: #{var}"
      exit
    end
  else
    cmd.push(var)
  end
end

#
# GUI
#
if defined?(Gtk)
  class RepositoryGUI
    class Setup < Gtk::Builder
      # Set GTK debug variables in the environment
      @@categories = {
        general: {
          repository: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |item|
                votes = item[7].to_i.positive? ? item[7] : ''
                rating = item[7].to_i.positive? ? "#{(item[6].to_f / item[7].to_f).to_s.slice(/^[0-9]+(?:\.[0-9])?/)}" : ''
                downloads = item[5].dup.to_i > 999 ? item[5].dup.reverse!.gsub!(/(\d{3})(?=\d)/, '\\1,').reverse! : item[5]

                iter = store.append
                iter[0] = item[0] # filename
                iter[1] = item[1] # game
                iter[2] = "#{(item[2].to_f / 1024).to_s.slice(/^[0-9]+(?:\.[0-9])?/)}k" # size_show
                iter[3] = item[2].to_i # size_sort
                iter[4] = Time.at(item[3].to_i).strftime("%Y-%m-%d") # last_updated
                iter[5] = item[4] # author
                iter[6] = downloads # DLs_show
                iter[7] = item[5].to_i # DLs_sort
                iter[8] = rating # ratings_show
                iter[9] = rating.to_f # ratings_sort
                iter[10] = votes # votes_show
                iter[11] = votes.to_i # votes_sort
                iter[12] = item[8] # tags
                iter[13] = item[9] # comments
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          search_entry: { default: '' },
          download_link: { default: '' },
          link_data: { default: '' },
        }
      }

      def self.get_category(key)
        @@categories.each { |category, data| return category unless data[key].nil? }
        nil
      end

      def self.get_setting(key)
        cat = Setup.get_category(key)
        return nil if cat.nil?

        @@categories[cat].each { |setting, data| return data if setting == key }
        nil
      end

      def initialize(add_comments_to_list, get_list)
        return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

        super()

        @running = true

        @repo_list = add_comments_to_list.call(get_list.call)

        # Remove the first element (header)
        @data_without_header = @repo_list[1..-1]

        # Sort the array by the first element of each subarray
        @data_without_header = @data_without_header.sort_by { |subarray| subarray.first.downcase }

        Gtk.queue do
          # add_from_file("#{$data_dir}repository.ui")
          add_from_string(Setup.repository_ui)

          load_settings

          self['main'].show_all
          self['main'].keep_above = true
          self['main'].set_title "Repository Search "

          # connect signals after settings are loaded to a bunch of handlers don't trigger
          connect_signals { |handler| method(handler) }

          # Access the GtkSearchEntry widget
          search_entry = self['search_entry']

          # Connect signal to handle search entry text changes
          search_entry.signal_connect('changed') do
            search_text = search_entry.text
            filter_data(search_text)
          end

          # Connect signal to handle search activation (e.g., pressing Enter)
          search_entry.signal_connect('activate') do
            search_text = search_entry.text
            filter_data(search_text)
          end
        end

        wait_while { @running }
      end

      def load_settings(connect = true)
        Gtk.queue do
          # load up the generic settings which are just matching by name of the widget
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)

            key = obj.builder_name.to_sym

            next if (setting = Setup.get_setting(key)).nil?

            if obj.class == Gtk::Label
              if key == :link_data
                self[key].visible = false
              end
            elsif obj.class == Gtk::Button
              if key == :download_link
                self[key].signal_connect("clicked") {
                  Script.run('repository', self['link_data'].text, :force => true) unless self['link_data'].text == 'label'
                }
              end
            elsif obj.class == Gtk::Entry
              obj.text = @settings[key].strip
              obj.signal_connect('changed') { on_update(obj) } if connect
            elsif obj.class == Gtk::TreeView
              if (store = self["#{key}_store"]).nil?
                respond "** failed to find store for treeview #{key}"
                next
              elsif setting[:load].nil?
                respond "** no :load defined #{key}"
                next
              end

              setting[:load].call(store, @data_without_header)

              self[key].signal_connect('row-activated') do |_, path, _|
                # Retrieve the selected iter
                iter = self["#{key}_store"].get_iter(path)
                # Extract the data from the iter and add it to the comment area
                self['comments'].text = iter[13]
                self['download_link'].label = iter[0]
                self['link_data'].text = "download #{iter[0]} --author=#{iter[5]} --game=#{iter[1]}"
              end
            end
          end
        end
      end

      def filter_data(search_text)
        # Filter data based on search text
        search_text.downcase!
        filtered_data = @data_without_header.select do |item|
          item.any? { |column| column.to_s.downcase.include?(search_text) }
        end

        # Reset comments box and download button
        self['comments'].text = ''
        self['download_link'].label = 'Download selected script'
        self['link_data'].text = 'label'

        # refresh the GtkTreeView using the load proc
        @@categories[:general][:repository][:load].call(self[:repository_store], filtered_data)
      end

      def on_close_clicked
        self['main'].destroy
      end

      def on_destroy
        Gtk.queue { @running = false }
      end

      def self.repository_ui
        '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkListStore" id="repository_store"><columns><!-- column-name filename --><column type="gchararray"/><!-- column-name game --><column type="gchararray"/><!-- column-name size --><column type="gchararray"/><!-- column-name size_int --><column type="gint"/><!-- column-name last_updated --><column type="gchararray"/><!-- column-name author --><column type="gchararray"/><!-- column-name downloads --><column type="gchararray"/><!-- column-name downloads_int --><column type="gint"/><!-- column-name ratings --><column type="gchararray"/><!-- column-name ratings_float --><column type="gfloat"/><!-- column-name votes --><column type="gchararray"/><!-- column-name votes_int --><column type="gint"/><!-- column-name tags --><column type="gchararray"/><!-- column-name comments --><column type="gchararray"/>
        </columns></object><object class="GtkWindow" id="main"><property name="can-focus">False</property><property name="default-width">1200</property><property name="default-height">650</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><property name="show-tabs">False</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkScrolledWindow"><property name="width-request">800</property><property name="height-request">500</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkTreeView" id="repository"><property name="visible">True</property><property name="can-focus">True</property><property name="model">repository_store</property><property name="enable-search">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><property name="enable-grid-lines">both</property><property name="activate-on-single-click">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">File Name</property><property name="sort-column-id">0</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Game</property><property name="clickable">True</property><property name="sort-column-id">1</property><child><object class="GtkCellRendererText"><property name="xalign">0.5099999904632568</property>
        </object><attributes><attribute name="text">1</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Size</property><property name="clickable">True</property><property name="sort-column-id">3</property><child><object class="GtkCellRendererText"><property name="xalign">1</property></object><attributes><attribute name="text">2</attribute></attributes>
        </child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Last Updated</property><property name="clickable">True</property><property name="sort-column-id">4</property><child><object class="GtkCellRendererText"><property name="xalign">0.5099999904632568</property></object><attributes><attribute name="text">4</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Author</property><property name="clickable">True</property><property name="sort-column-id">5</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">5</attribute>
        </attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">DLs</property><property name="clickable">True</property><property name="sort-column-id">7</property><child><object class="GtkCellRendererText"><property name="xalign">1</property></object><attributes><attribute name="text">6</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Rating</property><property name="clickable">True</property><property name="sort-column-id">9</property><child><object class="GtkCellRendererText"><property name="xalign">1</property>
        </object><attributes><attribute name="text">8</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Votes</property><property name="clickable">True</property><property name="sort-column-id">11</property><child><object class="GtkCellRendererText"><property name="xalign">1</property></object><attributes><attribute name="text">10</attribute></attributes>
        </child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Tags</property><property name="clickable">True</property><property name="sort-column-id">12</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">12</attribute></attributes></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel" id="comments"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="label" translatable="yes">Comments from selected script (if any)
        will be shown here</property><property name="wrap">True</property>
        </object></child></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkSearchEntry" id="search_entry"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="primary-icon-name">edit-find-symbolic</property><property name="primary-icon-activatable">False</property><property name="primary-icon-sensitive">False</property><property name="placeholder-text" translatable="yes">Keyword Search</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property></packing></child><child><object class="GtkLabel" id="link_data"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">label</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><placeholder/></child><child><placeholder/>
        </child><child><placeholder/></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="height">2</property></packing></child><child><object class="GtkButton" id="download_link"><property name="label" translatable="yes">Download selected script</property><property name="width-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">10</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><placeholder/></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes"> Profiles </property></object><packing><property name="tab-fill">False</property><property name="reorderable">True</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><placeholder/></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
        </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
      end
    end
  end
end
#
# list
#
if cmd[0] =~ /^list$/i
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  respond "\n#{format_list.call(filter_list.call(add_comments_to_list.call(get_list.call)))}\n\n"

#
# list-updates
#
elsif cmd[0] =~ /^list-?update[sd]$/i
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  list = filter_list.call(get_list.call)
  headers = list.shift
  unless (lui = headers.index('last update')) and (fi = headers.index('file'))
    echo 'error: list is missing headers'
    exit
  end
  list.delete_if { |row|
    if (row[fi] =~ /\.(?:ui|xml|json|yaml|yml)$/i) and (LICH_VERSION.split('.').collect { |n| n.rjust(5, '0') }.join('.') >= '00004.00006.00000')
      not File.exist?(File.join(DATA_DIR, "#{row[fi]}")) or ((File.mtime(File.join(DATA_DIR, "#{row[fi]}")).to_i + 15) > row[lui].to_i)
    else
      not File.exist?(File.join(SCRIPT_DIR, "#{row[fi]}")) or ((File.mtime(File.join(SCRIPT_DIR, "#{row[fi]}")).to_i + 15) > row[lui].to_i)
    end
  }
  list.unshift(headers)
  respond "\n#{format_list.call(list)}\n\n"

#
# list-new
#
elsif cmd[0] =~ /^list-?new$/i
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  list = filter_list.call(get_list.call)
  headers = list.shift
  unless (fi = headers.index('file'))
    echo 'error: list is missing headers'
    exit
  end
  list.delete_if { |row|
    if (row[fi] =~ /\.(?:ui|xml|json|yaml|yml)$/i) and (LICH_VERSION.split('.').collect { |num| num.rjust(5, '0') }.join('.') >= '00004.00006.00000')
      File.exist?(File.join(DATA_DIR, "#{row[fi]}"))
    else
      File.exist?(File.join(SCRIPT_DIR, "#{row[fi]}"))
    end
  }
  list.unshift(headers)
  respond "\n#{format_list.call(list)}\n\n"

#
# list-tags
#
elsif cmd[0] =~ /^list-?tags?$/i
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  list = filter_list.call(get_list.call)
  headers = list.shift
  unless (ti = headers.index('tags'))
    echo 'error: list is missing headers'
    exit
  end
  tags = Hash.new
  list.each { |row| row[ti].split(',').each { |t| tags[t.downcase.gsub(/[^a-z]+/, '')] = t } }
  if tags.empty?
    respond "\ntags: (none)\n\n"
  else
    respond "\ntags: #{tags.values.join(', ')}\n\n"
  end

#
# info
#
elsif (cmd[0] =~ /^info$/i)
  unless cmd[1]
    echo 'error: missing script name on command line'
    exit
  end
  if cmd[2]
    echo "error: extra words on command line: #{cmd[2..-1].join(' ')}"
    exit
  end
  list = filter_list.call(get_list.call)
  headers = list.shift
  unless (fi = headers.index('file')) and (gi = headers.index('game'))
    echo 'error: list is missing headers'
    exit
  end
  exact_name_list = list.find_all { |row| row[fi].downcase == cmd[1].downcase }
  if exact_name_list.length > 0
    list = exact_name_list
  else
    list.delete_if { |row| row[fi] !~ /^#{cmd[1]}/i }
  end
  if list.empty?
    echo "error: file not found"
  elsif list.length > 1
    list.unshift(headers)
    respond "\nMultiple files match: be more specific\n\n#{format_list.call(list)}\n\n"
  else
    file = list[0][fi]
    game = list[0][gi]
    list.unshift(headers)
    begin
      ssl_socket, socket = connect.call
      ssl_socket.puth('action' => 'inspect', 'file' => file, 'game' => game, 'client' => client_version)
      response = ssl_socket.geth
      if response['warning']
        echo "warning: server says: #{response['warning']}"
      end
      if response['error']
        echo "error: server says: #{response['error']}"
        exit
      elsif (response['size'] !~ /^[0-9]+$/)
        echo 'error: out of cheese 4'
        exit
      end
      data = ssl_socket.read(response['size'].to_i)
    ensure
      ssl_socket.close rescue nil
      socket.close rescue nil
    end
    output = "\n#{format_list.call(list)}\n\n"
    if response['versions']
      sorted_versions = response['versions'].split(';').collect { |v| v.split('.') }.sort { |a, b|
        i = r = 0
        loop {
          if (r != 0) or not (a[i] or b[i])
            break
          elsif b[i] and not a[i]
            r = -1
          elsif a[i] and not b[i]
            r = 1
          else
            r = (a[i].to_i <=> b[i].to_i)
          end

          i += 1
        }
        r
      }.collect { |v| v.join('.') }.join(', ')
      output.concat "available versions: #{sorted_versions}\n\n"
    end
    output.concat "#{data}\n\n"
    respond output
  end

#
# download
#
elsif (cmd[0] =~ /^download$/i)
  unless cmd[1]
    echo 'error: missing script name on command line'
    exit
  end
  if cmd[2]
    echo "error: extra words on command line: #{cmd[2..-1].join(' ')}"
    exit
  end
  list = filter_list.call(get_list.call)
  headers = list.shift
  unless (fi = headers.index('file')) and (gi = headers.index('game'))
    echo 'error: list is missing headers'
    exit
  end
  exact_name_list = list.find_all { |row| row[fi].downcase == cmd[1].downcase }
  if exact_name_list.length > 0
    list = exact_name_list
  else
    list.delete_if { |row| row[fi] !~ /^#{cmd[1]}/i }
  end
  if list.empty?
    echo "error: file not found"
  elsif list.length > 1
    list.unshift(headers)
    respond "\nMultiple files match: be more specific\n\n#{format_list.call(list)}\n\n"
  else
    echo "downloading #{list[0][fi]} in 3 seconds... (;k #{script.name} to cancel)"
    sleep 3 unless list[0][fi] =~ /^(infomon|waggle|x?narost)\.lic$/i
    if list[0][fi] =~ /^(infomon|waggle|x?narost)\.lic$/i
      echo "#{list[0][fi]} no longer updatable via ;repository."
      case list[0][fi]
      when /infomon/
        echo "Please use ;lich5-update --script=infomon.lic"
      when /waggle/
        echo "Please use ;repository download ewaggle.lic --game=gs"
      when /narost/
        echo "Please use ;repository download map.lic --game=gs"
      end
    elsif download_file.call(list[0][fi], list[0][gi], cmd_version)
      echo 'done'
    end
  end

#
# download-updates
#
elsif (cmd[0] =~ /^download-?update[ds]$/i)
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  if Settings['updatable'].nil?
    echo "error: download-updates has not been set up; look for set-updatable and unset-updatable commands in ;#{script.name} help"
    exit
  end
  Settings['updatable'][:scripts] ||= Array.new
  Settings['updatable'][:mapdb] ||= Hash.new
  if Settings['updatable'][:lich]
    # download_lich.call
  end
  if Settings['updatable'][:mapdb][XMLData.game]
    download_mapdb.call
  end
  unless Settings['updatable']['scripts'].empty?
    list = get_list.call
    headers = list.shift
    unless (fi = headers.index('file')) and (gi = headers.index('game')) and (lui = headers.index('last update')) and (ai = headers.index('author'))
      echo 'error: list is missing headers'
    else
      no_updates = true
      for local_info in (Settings['updatable'][:scripts])
        next if (LICH_VERSION =~ /^4\.4/) and (local_info[:filename] =~ /^(alias|vars|autostart|infomon)\.lic$/i)

        # bypass auto update of following scripts if on Lich5.
        next if (LICH_VERSION =~ /^5\./) and (local_info[:filename] =~ /^(infomon|waggle|xnarost)\.lic$/i)
        if (remote_info = list.find { |rinfo| (rinfo[fi] == local_info[:filename]) and (rinfo[gi] == local_info[:game]) })
          if (local_info[:filename] =~ /\.(?:xml|json|yaml|yml)$/i) and (LICH_VERSION.split('.').collect { |n| n.rjust(5, '0') }.join('.') >= '00004.00006.00000')
            updated = !File.exist?(File.join(DATA_DIR, "#{local_info[:filename]}")) || (File.mtime(File.join(DATA_DIR, "#{local_info[:filename]}")).to_i < remote_info[lui].to_i)
          else
            updated = !File.exist?(File.join(SCRIPT_DIR, "#{local_info[:filename]}")) || (File.mtime(File.join(SCRIPT_DIR, "#{local_info[:filename]}")).to_i < remote_info[lui].to_i)
          end
          if updated
            if (remote_info[ai] != local_info[:author]) and not cmd_force
              echo "warning: author of #{local_info[:filename]} changed from #{local_info[:author]} to #{remote_info[ai]}: skipping"
            else
              if remote_info[ai] != local_info[:author]
                echo "warning: author of #{local_info[:filename]} changed from #{local_info[:author]} to #{remote_info[ai]}: downloading anyway"
              end
              echo "downloading #{local_info[:filename].sub(/\.lic$/, '')}..."
              start = Time.now.to_f
              download_file.call(local_info[:filename], local_info[:game], nil)
              sleep [(1.5 - Time.now.to_f + start), 0].max
              no_updates = false
            end
          end
        else
          # file is not in the repository
        end
      end
      if no_updates
        echo 'scripts are up-to-date'
      else
        echo 'done'
      end
    end
  end

#
# settings for download-updates
#
elsif (cmd[0] =~ /^show-?updat(?:e|able)$/i)
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  Settings['updatable'] ||= Hash.new
  Settings['updatable'][:scripts] ||= Array.new
  Settings['updatable'][:mapdb] ||= Hash.new
  table_rows = []
  table_rows.push([{ :value => " Lich: #{Settings['updatable'][:lich] ? 'on' : 'off'}", :colspan => 3 }])
  table_rows.push([{ :value => "mapdb: #{Settings['updatable'][:mapdb][XMLData.game] ? 'on' : 'off'}", :colspan => 3 }])
  table_rows.push(:separator)
  table_rows.push(['Script/File', 'Author', 'Game'])
  table_rows.push(:separator)
  if Settings['updatable'][:scripts].empty?
    table_rows.push([{ :value => "No Scripts Updatable", :colspan => 3 }])
  else
    Settings['updatable'][:scripts].sort_by { |script| script[:filename] }.each { |script_updatable|
      table_rows.push([script_updatable[:filename], script_updatable[:author], script_updatable[:game]])
    }
  end
  table = Terminal::Table.new(
    rows: table_rows
  )
  if $frontend =~ /^(?:stormfront|wrayth|genie)$/i
    _respond "<output class=\"mono\"/>\n" + table.to_s + "\n<output class=\"\"/>"
  else
    _respond table.to_s.split("\n")
  end
elsif (cmd[0] =~ /^set-?updat(?:e|able)$/i)
  unless cmd[1]
    echo 'error: missing script name on command line'
    exit
  end
  if cmd[2]
    echo "error: extra words on command line: #{cmd[2..-1].join(' ')}"
    exit
  end
  list = filter_list.call(get_list.call)
  headers = list.shift
  unless (fi = headers.index('file')) and (gi = headers.index('game')) and (ai = headers.index('author'))
    echo 'error: list is missing headers'
    exit
  end
  exact_name_list = list.find_all { |row| row[fi].downcase == cmd[1].downcase }
  if exact_name_list.length > 0
    list = exact_name_list
  else
    list.delete_if { |row| row[fi] !~ /^#{cmd[1]}/i }
  end
  if list.empty?
    echo "error: file not found"
  elsif list.length > 1
    list.unshift(headers)
    respond "\nMultiple files match: be more specific\n\n#{format_list.call(list)}\n\n"
  else
    info = { :filename => list[0][fi], :game => list[0][gi], :author => list[0][ai] }
    Settings['updatable'] ||= Hash.new
    Settings['updatable'][:scripts] ||= Array.new
    if Settings['updatable'][:scripts].include?(info)
      echo "#{info[:filename]} is already set as updatable"
    else
      Settings['updatable'][:scripts].push(info)
      echo "the download-updates command will download #{info[:filename]} when there's an update"
    end
  end
elsif (cmd[0] =~ /^unset-?updat(?:e|able)$/i)
  unless cmd[1]
    echo 'error: missing script name on command line'
    exit
  end
  if cmd[2]
    echo "error: extra words on command line: #{cmd[2..-1].join(' ')}"
    exit
  end
  Settings['updatable'] ||= Hash.new
  Settings['updatable'][:scripts] ||= Array.new
  if (info = (Settings['updatable'][:scripts].find { |i| i[:filename] == cmd[1] } || Settings['updatable'][:scripts].find { |i| i[:filename] =~ /^#{cmd[1]}/i }))
    echo "the download-updates command will ignore updates for #{info[:filename]}"
    Settings['updatable'][:scripts].delete(info)
  else
    echo "could not find #{cmd[1]} in the updatable list"
  end
elsif (cmd[0] =~ /^set-?map(?:db)?-?updat(?:e|able)$|^set-?updat(?:e|able)-?map(?:db)?$/i)
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  Settings['updatable'] ||= Hash.new
  Settings['updatable'][:mapdb] ||= Hash.new
  Settings['updatable'][:mapdb][XMLData.game] = true
  echo "the download-updates command will download the #{XMLData.game} map database when there's an update"
elsif (cmd[0] =~ /^unset-?map(?:db)?-?updat(?:e|able)$|^unset-?updat(?:e|able)-?map(?:db)?$/i)
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  Settings['updatable'] ||= Hash.new
  Settings['updatable'][:mapdb] ||= Hash.new
  Settings['updatable'][:mapdb][XMLData.game] = false
  echo "the download-updates command will ignore updates for the #{XMLData.game} map database"

#
# upload
#
elsif (cmd[0] =~ /^upload$/i)
  unless cmd[1]
    echo 'error: missing script name on command line'
    exit
  end
  if cmd[2]
    echo "error: extra words on command line: #{cmd[2..-1].join(' ')}"
    exit
  end
  if File.exist?(File.join(SCRIPT_DIR, "#{cmd[1]}"))
    file = cmd[1]
    filename = File.join(SCRIPT_DIR, "#{cmd[1]}")
  elsif File.exist?(File.join(SCRIPT_DIR, "#{cmd[1]}.lic"))
    file = "#{cmd[1]}.lic"
    filename = File.join(SCRIPT_DIR, "#{cmd[1]}.lic")
  elsif (cmd[1] =~ /\.(?:ui|xml|json|yaml|yml)$/i) and (LICH_VERSION.split('.').collect { |num| num.rjust(5, '0') }.join('.') >= '00004.00006.00000') and File.exist?(File.join(DATA_DIR, "#{cmd[1]}"))
    file = "#{cmd[1]}"
    filename = File.join(DATA_DIR, "#{cmd[1]}")
  else
    echo "error: could not find #{cmd[1]}"
    exit
  end
  _filename = filename
  md5sum    = Digest::MD5.file(filename).to_s
  comments  = File.open(filename, 'rb') { |f| get_comments_from_data.call(f.read(20_000)) }
  author    = (cmd_author || get_author_from_comments.call(comments) || Char.name)
  game      = (cmd_game || get_game_from_comments.call(comments) || (if XMLData.game =~ /^GS/; 'GS'; elsif XMLData.game =~ /^DR/; 'DR'; else; 'other'; end))
  password  = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
  if password.nil?
    if (author == 'nobody') or (file =~ /^playershops\.xml$/i)
      password = 'nothing'
    else
      echo "error: no password is saved for author #{author}"
      echo "If that's not the author name you want for this script, specify a different name by adding \"author: NAME\" to the comments at the top of your script, or add \"--author=NAME\" to the upload command."
      echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the upload command."
      exit
    end
  end
  tags     = (cmd_tags.join(',') || get_tags_from_comments.call(comments))
  size     = File.stat(filename).size
  request  = { 'action' => 'upload', 'file' => file, 'game' => game, 'size' => size, 'author' => author, 'password' => password, 'md5sum' => md5sum, 'tags' => tags, 'client' => client_version }
  delete_filename = false
  if size > 5000
    tempfilename = File.join(TEMP_DIR, "#{rand(100000000)}.repo")
    File.open(filename, 'rb') { |f|
      Zlib::GzipWriter.open(tempfilename) { |f_gz|
        while (data = f.read(1_000_000))
          f_gz.write(data)
        end
        data = nil
      }
    }
    filename = tempfilename
    delete_filename = true
    size = File.stat(filename).size
    request['size'] = size
    request['compression'] = 'gzip'
  end
  begin
    ssl_socket, socket = connect.call
    ssl_socket.puth(request)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      echo "error: server says: #{response['error']}"
      exit
    elsif not response['continue']
      echo "error: unrecognized response from server: #{response.inspect}"
      exit
    end
    if cmd_password
      Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
      echo "password saved for author #{author}"
    end
    File.open(filename, 'rb') { |f|
      (size / 1_000_000).times { ssl_socket.write(f.read(1_000_000)) }
      ssl_socket.write(f.read(size % 1_000_000)) unless (size % 1_000_000) == 0
    }
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      echo "error: server says: #{response['error']}"
    elsif response['success']
      echo 'upload complete'
    else
      echo "error: unrecognized response from server: #{response.inspect}"
    end
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
    File.delete(filename) if delete_filename
  end

#
# delete
#
elsif (cmd[0] =~ /^delete$/i)
  unless cmd[1]
    echo 'error: missing script name on command line'
    exit
  end
  if cmd[2]
    echo "error: extra words on command line: #{cmd[2..-1].join(' ')}"
    exit
  end
  list = filter_list.call(get_list.call)
  headers = list.shift
  unless (fi = headers.index('file')) and (gi = headers.index('game')) and (ai = headers.index('author'))
    echo 'error: list is missing headers'
    exit
  end
  exact_name_list = list.find_all { |row| row[fi].downcase == cmd[1].downcase }
  if exact_name_list.length > 0
    list = exact_name_list
  else
    list.delete_if { |row| row[fi] !~ /^#{cmd[1]}/i }
  end
  if list.empty?
    echo "error: file not found"
  elsif list.length > 1
    list.unshift(headers)
    respond "\nMultiple files match: be more specific\n\n#{format_list.call(list)}\n\n"
  else
    file = list[0][fi]
    game = list[0][gi]
    author = list[0][ai]
    password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
    if password.nil?
      if author == 'nobody'
        password = 'nothing'
      else
        echo "error: no password is saved for author #{author}; specify a password by adding \"--password=PASSWORD\" to the delete command"
        exit
      end
    end
    echo "deleting #{file} in 5 seconds... (;k #{script.name} to cancel)"
    sleep 5
    begin
      ssl_socket, socket = connect.call
      ssl_socket.puth('action' => 'delete', 'file' => file, 'game' => game, 'author' => author, 'password' => password, 'client' => client_version)
      response = ssl_socket.geth
      if response['warning']
        echo "warning: server says: #{response['warning']}"
      end
      if response['error']
        echo "error: server says: #{response['error']}"
      elsif response['success']
        if cmd_password
          Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
          echo "password saved for author #{author}"
        end
        echo 'done'
      else
        echo "error: unrecognized response from server: #{response.inspect}"
      end
    ensure
      ssl_socket.close rescue nil
      socket.close rescue nil
    end
  end

#
# rate
#
elsif (cmd[0] =~ /^rate$/i)
  unless cmd[1]
    echo 'error: missing script name on command line'
    exit
  end
  unless cmd[2]
    echo 'error: missing rating on command line'
    exit
  end
  unless cmd[2] =~ /^(?:[1-9]|10)$/
    echo 'error: rating needs to be 1-10'
    exit
  end
  if cmd[3]
    echo "error: extra words on command line: #{cmd[3..-1].join(' ')}"
    exit
  end
  list = filter_list.call(get_list.call)
  headers = list.shift
  unless (fi = headers.index('file')) and (gi = headers.index('game'))
    echo 'error: list is missing headers'
    exit
  end
  exact_name_list = list.find_all { |row| row[fi].downcase == cmd[1].downcase }
  if exact_name_list.length > 0
    list = exact_name_list
  else
    list.delete_if { |row| row[fi] !~ /^#{cmd[1]}/i }
  end
  if list.empty?
    echo "error: file not found"
  elsif list.length > 1
    list.unshift(headers)
    respond "\nMultiple files match: be more specific\n\n#{format_list.call(list)}\n\n"
  else
    file = list[0][fi]
    game = list[0][gi]
    begin
      ssl_socket, socket = connect.call
      ssl_socket.puth('action' => 'rate', 'file' => file, 'game' => game, 'rating' => cmd[2], 'client' => client_version)
      response = ssl_socket.geth
      if response['warning']
        echo "warning: server says: #{response['warning']}"
      end
      if response['error']
        echo "error: server says: #{response['error']}"
        exit
      elsif response['success']
        echo 'Thank you for rating this script.'
        exit
      end
    ensure
      ssl_socket.close rescue nil
      socket.close rescue nil
    end
  end

#
# change password
#
elsif cmd[0] =~ /^(?:new|change)-?password$/i
  unless cmd[1]
    echo 'error: missing new password on command line'
    exit
  end
  if cmd[2]
    echo "error: extra words on command line: #{cmd[2..-1].join(' ')}"
    exit
  end
  author = (cmd_author || Char.name)
  password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
  if password.nil?
    echo "error: no password is saved for author #{author}; specify a password by adding \"--password=OLDPASSWORD\" to the change-password command (or if this author name has not been used before, the initial password must be set with an upload command)"
    exit
  end
  begin
    ssl_socket, socket = connect.call
    ssl_socket.puth('action' => 'change password', 'author' => author, 'password' => password, 'new password' => cmd[1], 'client' => client_version)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      echo "error: server says: #{response['error']}"
    elsif response['success']
      echo 'your password has been changed on the server'
      Settings["password:#{author.gsub(/[^a-z]/, '').downcase}"] = cmd[1]
      echo "password saved for author #{author}"
    end
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
  end

#
# checkout-mapdb
#
elsif (cmd[0] =~ /^checkout-?map(?:db)?$/i)
  unless defined?(Map.save_json)
    echo 'error: Your version of Lich is too old to checkout the map database.'
    exit
  end
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  if XMLData.game =~ /^GSF$|^GSPlat$|^GSIV$|^DR$|^DRF$|^DRX$/i
    game = XMLData.game.downcase
  else
    echo 'error: unknown game'
    exit
  end
  author = (cmd_author || Char.name)
  password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
  if password.nil?
    echo "error: no password is saved for author #{author}"
    echo "If that's not the author name you want to use, specify a different name by adding \"--author=NAME\" to the command."
    echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the command."
    exit
  end
  begin
    ssl_socket, socket = connect.call
    ssl_socket.puth('action' => 'checkout-mapdb', 'author' => author, 'password' => password, 'game' => game, 'client' => client_version)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      echo "error: server says: #{response['error']}"
    elsif response['success']
      if cmd_password
        Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
        echo "password saved for author #{author}"
      end
      echo 'success;  running download-mapdb now...'
      download_mapdb.call
      Map.reload unless mapdb_reloaded # mapdb on disk may have been updated by another character, leaving the in memory mapdb on this character out of date
      echo "edit your map database and     ;#{script.name} upload-mapdb     within 12 hours."
    end
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
  end

#
# relase-mapdb
#
elsif (cmd[0] =~ /^release-?map(?:db)?$/i)
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  author = (cmd_author || Char.name)
  password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
  if password.nil?
    echo "error: no password is saved for author #{author}"
    echo "If that's not the author name you want to use, specify a different name by adding \"--author=NAME\" to the command."
    echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the command."
    exit
  end
  begin
    ssl_socket, socket = connect.call
    ssl_socket.puth('action' => 'release-mapdb', 'author' => author, 'password' => password, 'game' => XMLData.game.downcase, 'client' => client_version)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      echo "error: server says: #{response['error']}"
    elsif response['success']
      if cmd_password
        Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
        echo "password saved for author #{author}"
      end
      echo 'success: other people can work on the map database now'
    end
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
  end

#
# approve-mapdb
#
elsif (cmd[0] =~ /^approve-?map(?:db)?$/i)
  unless cmd[1] and cmd[2]
    echo 'error: missing game and timestamp on command line'
    exit
  end
  if cmd[3]
    echo "error: extra words on command line: #{cmd[3..-1].join(' ')}"
    exit
  end
  author = (cmd_author || Char.name)
  password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
  unless (game = cmd[1]) and (timestamp = cmd[2])
    echo "You're doing it wrong."
    exit
  end
  if password.nil?
    echo "error: no password is saved for author #{author}"
    echo "If that's not the author name you want to use, specify a different name by adding \"--author=NAME\" to the command."
    echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the command."
    exit
  end
  begin
    ssl_socket, socket = connect.call
    ssl_socket.puth('action' => 'approve-mapdb', 'author' => author, 'password' => password, 'game' => game, 'timestamp' => timestamp, 'client' => client_version)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      echo "error: server says: #{response['error']}"
    elsif response['success']
      if cmd_password
        Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
        echo "password saved for author #{author}"
      end
      echo 'success'
    end
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
  end

#
# upload-mapdb
#
elsif (cmd[0] =~ /^upload-?map(?:db)?$/i)
  unless defined?(Map.save_json)
    echo 'error: Your version of Lich is too old to upload the map database.'
    exit
  end
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  if XMLData.game =~ /^GSF$|^GSPlat$|^GSIV$|^DR$|^DRF$|^DRX$/i
    game = XMLData.game.downcase
  else
    echo 'error: unknown game'
    exit
  end
  echo 'saving map database...'
  Map.save_json
  filename = Dir.entries(File.join(DATA_DIR, XMLData.game)).find_all { |fn| fn =~ /^map\-[0-9]+\.json$/i }.collect { |fn| File.join(DATA_DIR, XMLData.game, "#{fn}") }.sort[-1]
  unless File.exist?(filename)
    echo 'error'
    exit
  end
  md5sum   = Digest::MD5.file(filename).to_s
  author   = (cmd_author || Char.name)
  password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
  if password.nil?
    echo "error: no password is saved for author #{author}"
    echo "If that's not the author name you want, specify a different name by adding \"--author=NAME\" to the command."
    echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the upload command."
    exit
  end
  size     = File.stat(filename).size
  request  = { 'action' => 'upload-mapdb', 'game' => game, 'author' => author, 'password' => password, 'md5sum' => md5sum, 'client' => client_version }

  echo 'compressing map database...'
  tempfilename = File.join(TEMP_DIR, "#{rand(100000000)}.repo")
  File.open(filename, 'rb') { |f|
    Zlib::GzipWriter.open(tempfilename) { |f_gz|
      while (data = f.read(1_000_000))
        f_gz.write(data)
      end
      data = nil
    }
  }
  size = File.stat(tempfilename).size
  request['size'] = size
  request['compression'] = 'gzip'

  begin
    ssl_socket, socket = connect.call
    ssl_socket.puth(request)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      echo "error: server says: #{response['error']}"
      exit
    elsif not response['continue']
      echo "error: unrecognized response from server: #{response.inspect}"
      exit
    end
    if cmd_password
      Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
      echo "password saved for author #{author}"
    end
    echo 'uploading map database...'
    start_time = Time.now.to_f
    progress = 0
    progress_time = Time.now.to_i
    chunk_size = 16384
    File.open(tempfilename, 'rb') { |f|
      (size / chunk_size).times {
        ssl_socket.write(f.read(chunk_size))
        progress += chunk_size
        if ((Time.now.to_i - progress_time) > 9)
          progress_time = Time.now.to_i
          echo "still uploading (#{((progress * 100) / size).round}%, #{(((progress / 1024.0) / (Time.now.to_f - start_time)) * 10).round / 10.0} KB/s)..."
        end
      }
      ssl_socket.write(f.read(size % chunk_size)) unless (size % chunk_size) == 0
    }
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      echo "error: server says: #{response['error']}"
    elsif response['success']
      echo 'upload complete'
    else
      echo "error: unrecognized response from server: #{response.inspect}"
    end
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
    File.delete(tempfilename)
  end

  image_filenames = Array.new
  Map.list.each { |room| image_filenames.push(room.image) if room.image and not image_filenames.include?(room.image) }
  image_filenames.each { |fn|
    unless fn =~ /\.(?:png|jpg|gif)$/i
      echo "warning: ignoring #{fn} (map images should have a .png or .jpg file extension)"
    end
    unless File.exist?(File.join(MAP_DIR, "#{fn}"))
      echo "warning: ignoring #{fn} (file not found in #{MAP_DIR})"
    end
  }
  image_filenames.delete_if { |fn| (fn !~ /\.(?:png|jpg|gif)$/i) or not File.exist?(File.join(MAP_DIR, "#{fn}")) }
  image_filenames = image_filenames.join('/')

  begin
    ssl_socket, socket = connect.call
    ssl_socket.puth('action' => 'upload-mapdb-images', 'files' => image_filenames, 'client' => client_version)
    response = ssl_socket.geth
    if response['warning']
      echo "warning: server says: #{response['warning']}"
    end
    if response['error']
      echo "error: server says: #{response['error']}"
    elsif response['need-images']
      for filename in response['need-images'].split('/')
        echo "uploading #{filename}..."
        size = File.stat(File.join(MAP_DIR, "#{filename}")).size
        ssl_socket.puth('file' => filename, 'size' => size, 'md5sum' => Digest::MD5.file(File.join(MAP_DIR, "#{filename}")).to_s, 'client' => client_version)
        response = ssl_socket.geth
        if response['warning']
          echo "warning: server says: #{response['warning']}"
        end
        if response['error']
          echo "error: server says: #{response['error']}"
          break
        elsif not response['continue']
          echo "error: unrecognized response from server: #{response.inspect}"
          break
        end
        File.open(File.join(MAP_DIR, "#{filename}"), 'rb') { |f|
          (size / 1_000_000).times { ssl_socket.write(f.read(1_000_000)) }
          ssl_socket.write(f.read(size % 1_000_000)) unless (size % 1_000_000) == 0
        }
        response = ssl_socket.geth
        if response['warning']
          echo "warning: server says: #{response['warning']}"
        end
        if response['error']
          echo "error: server says: #{response['error']}"
        elsif not response['success']
          echo "error: unrecognized response from server: #{response.inspect}"
        end
      end
      echo 'done'
    elsif response['success']
      nil
    else
      echo "error: unrecognized response from server: #{response.inspect}"
    end
  ensure
    ssl_socket.close rescue nil
    socket.close rescue nil
  end

#
# download-mapdb
#
elsif (cmd[0] =~ /^download-?map(?:db)?$/i)
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  download_mapdb.call

#
# show mapdb last updated by
#
elsif (cmd[0] =~ /^mapdb-check$/i)
  if cmd[1]
    echo "error: extra words on command line: #{cmd[1..-1].join(' ')}"
    exit
  end
  mapdb_check.call

#
# download-lich
#
elsif (cmd[0] =~ /^download-?lich$/i)
  echo "Lich is no longer updatable via ;repository"
  echo "Please see ;lich5-update --help"
  echo "For info on updating Lich5"
  exit

#
# gui
#
elsif cmd[0] =~ /^gui$/i
  unless defined?(Gtk)
    echo "error: no gtk"
    exit
  else
    RepositoryGUI::Setup.new(add_comments_to_list, get_list)
  end

#
# help
#
elsif cmd[0] =~ /^help$/i
  output = "\n"
  output.concat "usage:\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} gui\n" if defined?(Gtk)
  output.concat "   #{$clean_lich_char}#{script.name} COMMAND OPTIONS\n"
  output.concat "\n"
  output.concat "commands:\n"
  output.concat "\n"
  output.concat "   list                      show files you can download\n"
  output.concat "   list-updates              show files that you have and there's an update for\n"
  output.concat "   list-new                  show files that you don't have\n"
  output.concat "   list-tags                 show all the tags currently in use\n"
  output.concat "   info FILENAME             show information about a file\n"
  output.concat "   download FILENAME         download a file\n"
  output.concat "   rate FILENAME NUMBER      rate a file\n"
  output.concat "   upload FILENAME           upload a file to the server\n"
  output.concat "   delete FILENAME           delete a file from the server\n"
  output.concat "   change-password NEWPASS   change your repository password\n"
  #    output.concat "   download-lich             download the latest version of Lich\n"
  output.concat "   download-mapdb            download the latest map database\n"
  output.concat "   mapdb-check               check whether your current mapdb is current or not.\n"
  output.concat "                             shows last upload date and user that uploaded.\n"
  output.concat "   checkout-mapdb            must be done before editing the map database\n"
  output.concat "   release-mapdb             if you checkout-mapdb and change your mind\n"
  output.concat "   upload-mapdb              upload your changes to the map database\n"
  output.concat "   download-updates          downloads any available updates to scriptsmapdb\n"
  output.concat "                             if set as updatable with the set-updatable commands\n"
  output.concat "   show-updatable            shows your current settings for download-updates\n"
  output.concat "   set-updatable FILENAME    download updates for FILENAME (when using download-updates)\n"
  #    output.concat "   set-lich-updatable        download updates for Lich (download-updates)\n"
  output.concat "   set-mapdb-updatable       download updates for the map database (download-updates)\n"
  output.concat "   unset-updatable FILENAME  ignore updates to FILENAME\n"
  #    output.concat "   unset-lich-updatable      ignore updates to Lich\n"
  output.concat "   unset-mapdb-updatable     ignore updates to the map database\n"
  output.concat "\n"
  output.concat "options:\n"
  output.concat "\n"
  output.concat "   --name=TEXT[,TEXT]        only list files whose name contain TEXT\n"
  output.concat "   --game=CODE[,CODE]        complicated\n"
  output.concat "   --search=TEXT             search list by TEXT given\n"
  output.concat "   --sort=TEXT               sort list by name,age,size,downloads,rating\n"
  output.concat "   --reverse                 show the list in reverse order\n"
  output.concat "   --limit=NUMBER            show at most NUMBER files in the list\n"
  output.concat "   --limit=OFFSET,NUMBER     show at most NUMBER files after skipping OFFSET files\n"
  output.concat "   --author=TEXT             specify the author of the file for uploading or listing\n"
  output.concat "   --password=TEXT           specify the password for the author for uploading\n"
  output.concat "   --size>NUMBER[k|m|g]      only list files larger than NUMBER bytes (or specified unit)\n"
  output.concat "   --size<NUMBER[k|m|g]      only list files smaller than NUMBER bytes (or specified unit)\n"
  output.concat "   --age>NUMBER[m|h|d|w|y]   only list files updated less than NUMBER seconds (or specified unit) ago\n"
  output.concat "   --age<NUMBER[m|h|d|w|y]   only list files updated more than NUMBER seconds (or specified unit) ago\n"
  output.concat "   --downloads>NUMBER        only list files with more than NUMBER downloads\n"
  output.concat "   --downloads<NUMBER        only list files with less than NUMBER downloads\n"
  output.concat "   --downloads=NUMBER        only list files with exactly NUMBER downloads\n"
  output.concat "   --rating>NUMBER           only list files with a rating higher than NUMBER\n"
  output.concat "   --rating<NUMBER           only list files with a rating lower than NUMBER\n"
  output.concat "   --rating=NUMBER           only list files with a rating equal to NUMBER\n"
  output.concat "   --tags=TEXT[,TEXT]        only list files with the specified tags\n"
  output.concat "   --version=<version>       download a specific version\n"
  output.concat "   --force                   ignore md5sum checks and script requirements\n"
  output.concat "\n"
  output.concat "   --show-tags               show tags in the list\n"
  output.concat "   --hide-last-update        hide last update in the list\n"
  output.concat "   --hide-size               hide file size in the list\n"
  output.concat "   --hide-author             hide author in the list\n"
  output.concat "   --hide-downloads          hide downloads in the list\n"
  output.concat "   --hide-rating             hide rating in the list\n"
  output.concat "\n"
  respond output

#
# everything else
#
else
  echo "error: unrecognized command.  Try #{$clean_lich_char}#{script.name} help"

end
