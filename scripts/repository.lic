=begin

  This script allows you to connect to the Lich server to upload and download scripts,
  and the map database.

  ;repository help

        author: elanthia-online
 maintained by: Tillmen, EO team, SpiffyJr
          game: any
          tags: core
      required: Lich > 5.0.1
       version: 2.69

  changelog:
    2.69 (2025-12-05):
      Major refactoring to proper module/class architecture
      Removed proc usage in favor of instance methods
      Improved code organization and maintainability
      Show JINX commands for repository outage failure
    2.68 (2025-11-26):
      Bugfix in author change array lookups
    2.67 (2025-11-05):
      Remove showing Lich in show-updatable
      Show all current mapdb updatables for current game type DR/GS logged into
      Allow setting specific mapdb to be updatable from other instances

=end

begin
  require 'terminal-table' unless defined?(Terminal::Table)
rescue LoadError
  respond "You need to have the 'terminal-table' gem installed"
  respond "Please install it with the following command: gem install terminal-table"
  respond "Via your computer's local terminal/shell"
  exit
end

require 'openssl'
require 'digest/md5'

module RepositoryTillmen
  # Method to extract version from script header comments
  def self.get_script_version
    data = Script.list.find { |x| x.name == Script.current.name }.inspect
    return data[/version: ([\d\.]+)/i, 1]
  end

  # Class variables instead of constants to avoid redefinition warnings
  @client_version = get_script_version
  @hostname = 'repo.lichproject.org'
  @port = 7157

  @ca_cert = OpenSSL::X509::Certificate.new(
    "-----BEGIN CERTIFICATE-----\n" \
    "MIIDoDCCAoigAwIBAgIUYwhIyTlqWaEd5mYGXoQQoC+ndKcwDQYJKoZIhvcNAQEL\n" \
    "BQAwYTELMAkGA1UEBhMCVVMxETAPBgNVBAgMCElsbGlub2lzMRIwEAYDVQQKDAlN\n" \
    "YXR0IExvd2UxDzANBgNVBAMMBlJvb3RDQTEaMBgGCSqGSIb3DQEJARYLbWF0dEBp\n" \
    "bzQudXMwHhcNMjQwNjA1MTM1NzUxWhcNNDQwNTMxMTM1NzUxWjBhMQswCQYDVQQG\n" \
    "EwJVUzERMA8GA1UECAwISWxsaW5vaXMxEjAQBgNVBAoMCU1hdHQgTG93ZTEPMA0G\n" \
    "A1UEAwwGUm9vdENBMRowGAYJKoZIhvcNAQkBFgttYXR0QGlvNC51czCCASIwDQYJ\n" \
    "KoZIhvcNAQEBBQADggEPADCCAQoCggEBAJwhGfQgwI1h4vlqAqaR152AlewjJMlL\n" \
    "yoqtjoS9Cyri23SY7c6v0rwhoOXuoV1D2d9InmmE2CgLL3Bn2sNa/kWFjkyedUca\n" \
    "vd8JrtGQzEkVH83CIPiKFCWLE5SXLvqCVx7Jz/pBBL1s173p69kOy0REYAV/OAdj\n" \
    "ioCXK6tHqYG70xvLIJGiTrExGeOttMw2S+86y4bSxj2i35IscaBTepPv7BWH8JtZ\n" \
    "yN4Xv9DBr/99sWSarlzUW6+FTcNqdJLP5W5a508VLJnevmlisswlazKiYNriCQvZ\n" \
    "snmPJrYFYMxe9JIKl1CA8MiUKUx8AUt39KzxkgZrq40VxIrpdxrnUKUCAwEAAaNQ\n" \
    "ME4wHQYDVR0OBBYEFJxuCVGIbPP3LO6GAHAViOCKZ4HIMB8GA1UdIwQYMBaAFJxu\n" \
    "CVGIbPP3LO6GAHAViOCKZ4HIMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQELBQAD\n" \
    "ggEBAGKn0vYx9Ta5+/X1WRUuADuie6JuNMHUxzYtxwEba/m5lA4nE5f2yoO6Y/Y3\n" \
    "LZDX2Y9kWt+7pGQ2SKOT79gNcnOSc3SGYWkX48J6C1hihhjD3AfD0hb1mgvlJuij\n" \
    "zNnZ7vczOF8AcvBeu8ww5eIrkN6TTshjICg71/deVo9HvjhiCGK0XvL+WL6EQwLe\n" \
    "6/nVVFrPfd0sRZZ5OTJR5nM1kA71oChUw9mHCyrAc3zYyW37k+p8ADRFfON8th8M\n" \
    "1Blel1SpgqlQ22WpYoHbUCSjGt6JKC/HrSHdKBezTuRahOSfqwncAE77Dz4FJaQ5\n" \
    "WD2mk3SZbB2ytAHUDEy3xr697EI=\n" \
    "-----END CERTIFICATE-----"
  )

  class << self
    attr_reader :client_version, :hostname, :port, :ca_cert
  end

  # Command line parser
  class CommandParser
    attr_reader :command, :arguments, :options

    def initialize(args)
      @command = nil
      @arguments = []
      @options = Options.new
      @no_more_options = false

      parse_args(args)
    end

    private

    def parse_args(args)
      args.each do |arg|
        if @no_more_options
          @arguments << arg
        elsif arg == '--'
          @no_more_options = true
        elsif arg =~ /^--/
          parse_option(arg)
        else
          if @command.nil?
            @command = arg
          else
            @arguments << arg
          end
        end
      end
    end

    def parse_option(arg)
      case arg
      when /^--author\s*=\s*(.+)/i
        @options.author = $1
      when /^--password\s*=\s*(.+)/i
        @options.password = $1
      when /^--sort\s*=\s*(.+)/i
        @options.sort = $1
      when /^--reverse$/i
        @options.reverse = true
      when /^--limit\s*=\s*(.+)/i
        @options.limit = $1
      when /^--force$/i
        @options.force = true
      when /^--game\s*=\s*(.+)/i
        @options.game = $1
      when /^--name\s*=\s*(.+)/i
        @options.name ||= []
        @options.name << $1
      when /^--search\s*=\s*(.+)/i
        @options.search ||= []
        @options.search << $1
      when /^--show-?tags$/i
        @options.show_tags = true
      when /^--hide-?(?:age|date|updated|last-update)$/i
        @options.hide_age = true
      when /^--hide-?size$/i
        @options.hide_size = true
      when /^--hide-?author$/i
        @options.hide_author = true
      when /^--hide-?downloads?$/i
        @options.hide_downloads = true
      when /^--hide-?rating$/i
        @options.hide_rating = true
      when /^--tags?\s*=\s*(.+)/i
        @options.tags ||= []
        @options.tags << $1
      when /^--size\s*(>|<|=)\s*([0-9\.]+)(k|m|g)?b?/i
        @options.size ||= []
        @options.size << parse_size_filter($1, $2, $3)
      when /^--age\s*(>|<)\s*([0-9\.]+)(m|h|d|w|y)?$/i
        @options.age ||= []
        @options.age << parse_age_filter($1, $2, $3)
      when /^--downloads?\s*(>|<|=)\s*([0-9]+)/i
        @options.downloads ||= []
        @options.downloads << [$1, $2.to_i]
      when /^--rating\s*(>|<|=)\s*([0-9\.]+)/i
        @options.rating ||= []
        @options.rating << [$1, $2.to_f]
      when /^--version\s*=\s*([0-9\.]+)/i
        @options.version = $1
      else
        echo "error: unknown option: #{arg}"
        exit
      end
    end

    def parse_size_filter(operator, value, unit)
      multiplier = case unit
                   when 'g' then 1073741824
                   when 'm' then 1048576
                   when 'k' then 1024
                   else 1
                   end
      [operator, (value.to_f * multiplier).to_i]
    end

    def parse_age_filter(operator, value, unit)
      multiplier = case unit
                   when 'y' then 60 * 60 * 24 * 365
                   when 'w' then 60 * 60 * 24 * 7
                   when 'd' then 60 * 60 * 24
                   when 'h' then 60 * 60
                   when 'm' then 60
                   else 1
                   end
      [operator, (value.to_f * multiplier).to_i]
    end
  end

  # Options container
  class Options
    attr_accessor :author, :password, :sort, :reverse, :limit, :force, :game,
                  :name, :search, :show_tags, :hide_age, :hide_author,
                  :hide_downloads, :hide_rating, :hide_size, :tags, :size,
                  :age, :downloads, :rating, :version

    def initialize
      @reverse = false
      @force = false
      @show_tags = false
      @hide_age = false
      @hide_author = false
      @hide_downloads = false
      @hide_rating = false
      @hide_size = false
    end
  end

  # Network connection handler
  class Connection
    @jinx_context = {}

    class << self
      attr_accessor :jinx_context
    end

    def self.connect(force: false)
      verify_mode = if RepositoryTillmen.ca_cert.not_before > Time.now
                      respond "repository warning: SSL cert reports it is not valid yet. Setting verify mode to NONE."
                      OpenSSL::SSL::VERIFY_NONE
                    elsif RepositoryTillmen.ca_cert.not_after < Time.now
                      respond "repository warning: SSL cert is expired. Setting verify mode to NONE."
                      OpenSSL::SSL::VERIFY_NONE
                    else
                      OpenSSL::SSL::VERIFY_PEER
                    end

      cert_store = OpenSSL::X509::Store.new
      cert_store.add_cert(RepositoryTillmen.ca_cert)

      ssl_context = OpenSSL::SSL::SSLContext.new
      ssl_context.options = (OpenSSL::SSL::OP_NO_SSLv2 + OpenSSL::SSL::OP_NO_SSLv3)
      ssl_context.cert_store = cert_store

      if OpenSSL::SSL::VERIFY_PEER == OpenSSL::SSL::VERIFY_NONE
        ssl_context.verify_mode = 1
      else
        ssl_context.verify_mode = verify_mode
      end

      socket = TCPSocket.new(RepositoryTillmen.hostname, RepositoryTillmen.port)
      ssl_socket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)
      ssl_socket.connect

      cert_cn = ssl_socket.peer_cert.subject.to_a.find { |n| n[0] == 'CN' }[1]
      unless ['lichproject.org', 'Lich Repository'].include?(cert_cn)
        if force
          echo "warning: server certificate hostname mismatch"
        else
          echo "error: server certificate hostname mismatch"
          ssl_socket.close rescue nil
          socket.close rescue nil
          exit
        end
      end

      ssl_socket.define_singleton_method(:geth) do
        hash = {}
        gets.scan(/[^\t]+\t[^\t]+(?:\t|\n)/).each do |s|
          parts = s.chomp.split("\t")
          hash[parts[0].downcase] = parts[1]
        end
        hash
      end

      ssl_socket.define_singleton_method(:puth) do |h|
        puts h.to_a.flatten.join("\t")
      end

      [ssl_socket, socket]
    rescue => e
      echo "error connecting to server: #{e}"

      if @jinx_context[:show_alternative] && @jinx_context[:command] && @jinx_context[:filename]
        echo "Alternatively: You can use JINX while REPOSITORY is currently unavailable"
        echo "Syntax: #{$clean_lich_char}jinx #{@jinx_context[:command]} #{@jinx_context[:filename]}"
      end

      ssl_socket.close rescue nil
      socket.close rescue nil
      exit
    end

    def self.set_jinx_context(command: nil, filename: nil)
      @jinx_context = {
        show_alternative: !command.nil? && !filename.nil?,
        command: command,
        filename: filename
      }
    end

    def self.clear_jinx_context
      @jinx_context = {}
    end
  end

  # Comment parser for script files
  class CommentParser
    def self.extract_comments(data)
      if data =~ /^=begin\r?\n?(.+?)^=end/m
        $1.split("\n")
      else
        comments = []
        data.split("\n").each do |line|
          if line =~ /^[\t\s]*#/
            comments << line
          elsif line !~ /^[\t\s]*$/
            break
          end
        end
        comments
      end
    rescue
      []
    end

    def self.extract_author(comments)
      comments.each do |line|
        if line =~ /^[\s\t#]*author:[\s\t]*([\w,\s\.\d]+)/i
          return $1.sub(/\s\(.*?\)/, '').strip
        end
      end
      nil
    end

    def self.extract_game(comments)
      comments.each do |line|
        if line =~ /^[\s\t#]*game:[\s\t]*([\w,\s\.\d]+)/i
          game = $1.strip
          return 'gs' if game =~ /^Gemstone$/i
          return 'dr' if game =~ /^Dragon\s*Realms$/i
          return game
        end
      end
      nil
    end

    def self.extract_tags(comments)
      comments.each do |line|
        if line =~ /^[\s\t#]*tags:[\s\t]*([\w,\s\.\d]+)/i
          return $1.strip
        end
      end
      nil
    end

    def self.check_lich_requirement(comments)
      current_version = Gem::Version.new(LICH_VERSION)

      comments.each do |line|
        next unless line =~ /^[\s\t#]*require(?:s|d):[\s\t]*(.+)/i

        $1.split(',').each do |req|
          if req.strip =~ /^[\s\t]*Lich[\s\t]*(>|<|=|>=|<=)[\s\t]*([\-\w\.]+)/i
            op = $1
            version = $2
            needed_version = Gem::Version.new(version)

            case op
            when '<'
              return "< #{version}" if current_version >= needed_version
            when '>'
              return "> #{version}" if current_version <= needed_version
            when '='
              return "= #{version}" if current_version != needed_version
            when '>='
              return ">= #{version}" if current_version < needed_version
            when '<='
              return "<= #{version}" if current_version > needed_version
            end
          end
        end
      end
      nil
    end
  end

  # Repository list manager
  class RepositoryList
    attr_reader :cached_list, :cached_list_offset, :cached_list_comments

    def initialize
      @cached_list = nil
      @cached_list_offset = nil
      @cached_list_comments = nil
    end

    def fetch_list
      request = {
        'action'                 => 'list',
        'supported compressions' => 'gzip',
        'client'                 => RepositoryTillmen.client_version
      }
      request['current-md5sum'] = Digest::MD5.new.update(@cached_list).to_s if @cached_list

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth(request)
        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          if response['error'] == 'already up-to-date'
            echo 'list up-to-date' if $repository_debug
            return nil
          else
            echo "error: server says: #{response['error']}"
            exit
          end
        end

        validate_response(response)
        data = read_response_data(ssl_socket, response)

        @cached_list = data
        @cached_list_offset = Time.now.to_i - response['server time'].to_i

        parse_list(data)
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    def add_comments_to_list(list)
      request = {
        'action'                 => 'list-comments',
        'supported compressions' => 'gzip',
        'client'                 => RepositoryTillmen.client_version
      }
      request['current-md5sum'] = Digest::MD5.new.update(@cached_list_comments).to_s if @cached_list_comments

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth(request)
        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          if response['error'] == 'already up-to-date'
            echo 'comments up-to-date' if $repository_debug
            return list
          else
            echo "error: server says: #{response['error']}"
            exit
          end
        end

        validate_response(response)
        data = read_response_data(ssl_socket, response)

        @cached_list_comments = data

        merge_comments_into_list(list, data)
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    private

    def validate_response(response)
      if response['size'].nil? || response['size'] !~ /^[0-9]+$/ || !response['server time']
        echo "error: unrecognized response from server: #{response.inspect}"
        exit
      elsif response['compression'] && response['compression'] != 'gzip'
        echo "error: unsupported compression method: #{response['compression']}"
        exit
      end
    end

    def read_response_data(ssl_socket, response)
      data = ssl_socket.read(response['size'].to_i)

      if response['compression'] == 'gzip'
        data = decompress_gzip(data)
      end

      data
    end

    def decompress_gzip(data)
      StringIO.open(data) do |io|
        gz_reader = Zlib::GzipReader.new(io)
        decompressed = gz_reader.read
        gz_reader.close
        decompressed
      end
    end

    def parse_list(data)
      list = data.split("\n").map { |d| d.split("\t", -1) }
      headers = list.shift

      if (lui = headers.index('last update'))
        list.each { |row| row[lui] = row[lui].to_i + @cached_list_offset }
      end

      list.unshift(headers)
      list
    end

    def merge_comments_into_list(list, comments_data)
      headers = list.shift
      fi = headers.index('file')
      gi = headers.index('game')
      ci = headers.length
      headers[ci] = 'comments'

      first_line = true
      headers2 = fi2 = gi2 = ci2 = nil

      comments_data.split("\n").each do |line|
        if first_line
          first_line = false
          headers2 = line.split("\t", -1)
          fi2 = headers2.index('file')
          gi2 = headers2.index('game')
          ci2 = headers2.index('comments')
        else
          row2 = line.split("\t", -1)
          row = list.find { |r| (r[fi] == row2[fi2]) && (r[gi] == row2[gi2]) }
          if row
            row[ci] = row2[ci2].gsub("\x14", "\t").gsub("\x12", "\n")
          end
        end
      end

      list.unshift(headers)
      list
    end
  end

  # List filtering and formatting
  class ListProcessor
    def initialize(options)
      @options = options
    end

    def filter_list(list)
      headers = list.shift

      if @options.search
        @options.search.each do |search|
          list.delete_if do |item|
            !item.any? { |column| column.to_s.downcase.include?(search) }
          end
        end
      else
        apply_filters(list, headers)
      end

      list.unshift(headers)
      list
    end

    def format_list(list)
      headers = list.shift

      format_ratings(list, headers)
      apply_sorting(list, headers)
      list.reverse! if @options.reverse
      format_timestamps(list, headers)
      format_sizes(list, headers)
      clean_game_column(list, headers)
      shorten_column_names(list, headers)
      handle_tags_column(list, headers)
      hide_columns(list, headers)
      apply_limit(list)

      format_as_table(list, headers)
    end

    private

    def apply_filters(list, headers)
      filter_by_name(list, headers)
      filter_by_game(list, headers)
      filter_by_size(list, headers)
      filter_by_age(list, headers)
      filter_by_author(list, headers)
      filter_by_downloads(list, headers)
      filter_by_rating(list, headers)
      filter_by_tags(list, headers)
    end

    def filter_by_name(list, headers)
      return unless @options.name && (fi = headers.index('file'))

      @options.name.each do |name|
        pattern = /#{name.split(',').map { |n| Regexp.escape(n) }.join('|')}/i
        list.delete_if { |row| row[fi] !~ pattern }
      end
    end

    def filter_by_game(list, headers)
      return unless (gi = headers.index('game'))

      games = if @options.game
                @options.game.split(',').map { |g| g.downcase.strip }
              elsif XMLData.game =~ /^GS/
                ['gs', 'any']
              elsif XMLData.game =~ /^DR/
                ['dr', 'any']
              else
                ['other', 'any']
              end

      list.delete_if { |row| !games.include?(row[gi]) }
    end

    def filter_by_size(list, headers)
      return unless @options.size && (si = headers.index('size'))

      @options.size.each do |op, bytes|
        case op
        when '>'
          list.delete_if { |row| row[si].to_i <= bytes }
        when '<'
          list.delete_if { |row| row[si].to_i >= bytes }
        when '='
          list.delete_if { |row| row[si].to_i != bytes }
        end
      end
    end

    def filter_by_age(list, headers)
      return unless @options.age && (lui = headers.index('last update'))

      now = Time.now.to_i
      @options.age.each do |op, seconds|
        case op
        when '>'
          list.delete_if { |row| (now - row[lui].to_i) <= seconds }
        when '<'
          list.delete_if { |row| (now - row[lui].to_i) >= seconds }
        end
      end
    end

    def filter_by_author(list, headers)
      return unless @options.author && (ai = headers.index('author'))

      authors = @options.author.split(',').map { |a| a.downcase.gsub(/[^a-z]+/, '') }
      list.delete_if { |row| !authors.include?(row[ai].downcase.gsub(/[^a-z]+/, '')) }
    end

    def filter_by_downloads(list, headers)
      return unless @options.downloads && (di = headers.index('downloads'))

      @options.downloads.each do |op, dc|
        case op
        when '>'
          list.delete_if { |row| row[di].to_i <= dc }
        when '<'
          list.delete_if { |row| row[di].to_i >= dc }
        when '='
          list.delete_if { |row| row[di].to_i != dc }
        end
      end
    end

    def filter_by_rating(list, headers)
      return unless @options.rating && (rti = headers.index('rating total')) && (rci = headers.index('rating count'))

      list.delete_if { |row| row[rci].to_i.zero? }

      @options.rating.each do |op, rate|
        list.delete_if do |row|
          next true unless row[rti] =~ /^[0-9]+$/ && row[rci] =~ /^[0-9]+$/

          avg = row[rti].to_f / row[rci].to_f
          case op
          when '>' then avg <= rate
          when '<' then avg >= rate
          when '=' then avg.abs != rate
          else false
          end
        end
      end
    end

    def filter_by_tags(list, headers)
      return unless @options.tags && (ti = headers.index('tags'))

      @options.tags.each do |tags|
        search_tags = tags.split(',').map { |t| t.downcase.gsub(/[^a-z]+/, '') }
        list.delete_if do |row|
          row_tags = row[ti].split(',').map { |t| t.downcase.gsub(/[^a-z]+/, '') }
          (search_tags & row_tags).empty?
        end
      end
    end

    def format_ratings(list, headers)
      rti = headers.index('rating total')
      rci = headers.index('rating count')
      return unless rti && rci

      list.each_index do |ri|
        if list[ri][rti] =~ /^[0-9]+$/ && list[ri][rci].to_i > 0
          avg = (list[ri][rti].to_f / list[ri][rci].to_f).to_s.slice(/^[0-9]+(?:\.[0-9])?/)
          list[ri][rti] = "#{avg} (#{list[ri][rci]})"
        else
          list[ri][rti] = ''
        end
      end

      headers[rti] = 'rating'
      headers.delete_at(rci)
      list.each { |row| row.delete_at(rci) }
    end

    def apply_sorting(list, headers)
      return unless @options.sort

      sort_key = case @options.sort
                 when 'name' then 'file'
                 when /^(?:last\-?)?updated?$|^age$|^date$/ then 'last update'
                 else @options.sort
                 end

      return unless (i = headers.index(sort_key))

      list.sort! do |a, b|
        if sort_key =~ /^(?:size|updated|age|downloads)$/
          a[i].to_i <=> b[i].to_i
        elsif sort_key == 'rating'
          a[i].to_s.slice(/[0-9\.]+/).to_f <=> b[i].to_s.slice(/[0-9\.]+/).to_f
        else
          a[i] <=> b[i]
        end
      end
    end

    def format_timestamps(list, headers)
      return unless (lui = headers.index('last update'))

      list.each_index do |ri|
        list[ri][lui] = Time.at(list[ri][lui].to_i)
                            .strftime("%Y-%m-%d %I:%M%p")
                            .downcase
                            .gsub(/\s0/, '  ')
      end
    end

    def format_sizes(list, headers)
      return unless (si = headers.index('size'))

      list.each_index do |ri|
        list[ri][si] = "#{(list[ri][si].to_f / 1024).to_s.slice(/^[0-9]+(?:\.[0-9])?/)}k"
      end
    end

    def clean_game_column(list, headers)
      c = headers.index('game')
      f = headers.index('file')
      return unless c && f

      f_list = list.map { |r| r[f] }.uniq
      g_list = list.map { |r| r[c] }.uniq
      g_list.delete('any')

      if f_list.length >= list.length || g_list.length <= 1
        headers.delete_at(c)
        list.each { |r| r.delete_at(c) }
      end
    end

    def shorten_column_names(_list, headers)
      if (di = headers.index('downloads'))
        headers[di] = 'DLs'
      end
    end

    def handle_tags_column(list, headers)
      ti = headers.index('tags')
      return unless ti

      if @options.tags.nil? && !@options.show_tags
        list.each_index { |ri| list[ri].delete_at(ti) }
        headers.delete_at(ti)
      else
        list.each_index do |ri|
          if list[ri][ti].length > 20
            list[ri][ti] = "#{list[ri][ti][0, 19]}>"
          end
        end
      end
    end

    def hide_columns(list, headers)
      # Build list of columns to hide with their indices
      columns_to_hide = []
      columns_to_hide << headers.index('comments') if headers.index('comments')
      columns_to_hide << headers.index('last update') if @options.hide_age && headers.index('last update')
      columns_to_hide << headers.index('size') if @options.hide_size && headers.index('size')
      columns_to_hide << headers.index('author') if @options.hide_author && headers.index('author')
      columns_to_hide << headers.index('DLs') if @options.hide_downloads && headers.index('DLs')
      columns_to_hide << headers.index('rating') if @options.hide_rating && headers.index('rating')

      # Sort indices in descending order to delete from right to left
      columns_to_hide.compact.sort.reverse.each do |i|
        list.each_index { |ri| list[ri].delete_at(i) }
        headers.delete_at(i)
      end
    end

    def apply_limit(list)
      return unless @options.limit

      if @options.limit =~ /^([0-9]+),([0-9]+)$/
        list.slice!($1.to_i, $2.to_i)
      elsif @options.limit =~ /^[0-9]+$/
        list.slice!(0, @options.limit.to_i)
      end
    end

    def format_as_table(list, headers)
      column_widths = Array.new(headers.length, 0)

      headers.each_with_index do |header, i|
        column_widths[i] = header.length
      end

      list.each do |row|
        row.each_with_index do |cell, i|
          column_widths[i] = [column_widths[i], cell.to_s.length].max
        end
      end

      ti = headers.index('tags') || -1

      separator = column_widths.map { |width| ''.rjust(width, '-') }
      list.unshift(separator)
      list.unshift(headers)

      list.map do |row|
        row.each_with_index do |cell, i|
          row[i] = if i == ti
                     cell.ljust(column_widths[i])
                   else
                     cell.rjust(column_widths[i])
                   end
        end
        row.join('   ')
      end.join("\n")
    end
  end

  # GUI implementation
  if defined?(Gtk)
    class RepositoryGUI
      class Setup < Gtk::Builder
        CATEGORIES = {} unless defined?(CATEGORIES)
        CATEGORIES.merge!({
          general: {
            repository: {
              default: [],
              load: proc do |store, setting|
                store.clear
                setting.each do |item|
                  votes = item[7].to_i.positive? ? item[7] : ''
                  rating = item[7].to_i.positive? ? "#{(item[6].to_f / item[7].to_f).to_s.slice(/^[0-9]+(?:\.[0-9])?/)}" : ''
                  downloads = item[5].dup.to_i > 999 ? item[5].dup.reverse!.gsub!(/(\d{3})(?=\d)/, '\\1,').reverse! : item[5]

                  iter = store.append
                  iter[0] = item[0] # filename
                  iter[1] = item[1] # game
                  iter[2] = "#{(item[2].to_f / 1024).to_s.slice(/^[0-9]+(?:\.[0-9])?/)}k" # size_show
                  iter[3] = item[2].to_i # size_sort
                  iter[4] = Time.at(item[3].to_i).strftime("%Y-%m-%d") # last_updated
                  iter[5] = item[4] # author
                  iter[6] = downloads # DLs_show
                  iter[7] = item[5].to_i # DLs_sort
                  iter[8] = rating # ratings_show
                  iter[9] = rating.to_f # ratings_sort
                  iter[10] = votes # votes_show
                  iter[11] = votes.to_i # votes_sort
                  iter[12] = item[8] # tags
                  iter[13] = item[9] # comments
                end
              end
            },
            search_entry: { default: '' },
            download_link: { default: '' },
            link_data: { default: '' }
          }
        })

        def self.get_category(key)
          CATEGORIES.each { |category, data| return category unless data[key].nil? }
          nil
        end

        def self.get_setting(key)
          cat = get_category(key)
          return nil if cat.nil?

          CATEGORIES[cat].each { |setting, data| return data if setting == key }
          nil
        end

        def initialize(repo_list)
          return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

          super()

          @running = true
          @repo_list = repo_list

          # Remove the first element (header)
          @data_without_header = @repo_list[1..-1]

          # Sort the array by the first element of each subarray
          @data_without_header = @data_without_header.sort_by { |subarray| subarray.first.downcase }

          Gtk.queue do
            add_from_string(self.class.repository_ui)
            load_settings

            self['main'].show_all
            self['main'].keep_above = true
            self['main'].set_title "Repository Search"

            connect_signals { |handler| method(handler) }

            # Access the GtkSearchEntry widget
            search_entry = self['search_entry']

            # Connect signal to handle search entry text changes
            search_entry.signal_connect('changed') do
              search_text = search_entry.text
              filter_data(search_text)
            end

            # Connect signal to handle search activation (e.g., pressing Enter)
            search_entry.signal_connect('activate') do
              search_text = search_entry.text
              filter_data(search_text)
            end
          end

          wait_while { @running }
        end

        def load_settings
          Gtk.queue do
            objects.each do |obj|
              next unless obj.methods.include?(:builder_name)

              key = obj.builder_name.to_sym
              setting = self.class.get_setting(key)
              next if setting.nil?

              case obj
              when Gtk::Label
                self[key].visible = false if key == :link_data
              when Gtk::Button
                if key == :download_link
                  self[key].signal_connect("clicked") do
                    Script.run('repository', self['link_data'].text, force: true) unless self['link_data'].text == 'label'
                  end
                end
              when Gtk::Entry
                obj.text = ''
              when Gtk::TreeView
                store = self["#{key}_store"]
                if store.nil?
                  respond "** failed to find store for treeview #{key}"
                  next
                elsif setting[:load].nil?
                  respond "** no :load defined #{key}"
                  next
                end

                setting[:load].call(store, @data_without_header)

                self[key].signal_connect('row-activated') do |_, path, _|
                  iter = self["#{key}_store"].get_iter(path)
                  self['comments'].text = iter[13]
                  self['download_link'].label = iter[0]
                  self['link_data'].text = "download #{iter[0]} --author=#{iter[5]} --game=#{iter[1]}"
                end
              end
            end
          end
        end

        def filter_data(search_text)
          search_text.downcase!
          filtered_data = @data_without_header.select do |item|
            item.any? { |column| column.to_s.downcase.include?(search_text) }
          end

          # Reset comments box and download button
          self['comments'].text = ''
          self['download_link'].label = 'Download selected script'
          self['link_data'].text = 'label'

          # refresh the GtkTreeView using the load proc
          CATEGORIES[:general][:repository][:load].call(self[:repository_store], filtered_data)
        end

        def on_close_clicked
          self['main'].destroy
        end

        def on_destroy
          Gtk.queue { @running = false }
        end

        def self.repository_ui
          '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkListStore" id="repository_store"><columns><!-- column-name filename --><column type="gchararray"/><!-- column-name game --><column type="gchararray"/><!-- column-name size --><column type="gchararray"/><!-- column-name size_int --><column type="gint"/><!-- column-name last_updated --><column type="gchararray"/><!-- column-name author --><column type="gchararray"/><!-- column-name downloads --><column type="gchararray"/><!-- column-name downloads_int --><column type="gint"/><!-- column-name ratings --><column type="gchararray"/><!-- column-name ratings_float --><column type="gfloat"/><!-- column-name votes --><column type="gchararray"/><!-- column-name votes_int --><column type="gint"/><!-- column-name tags --><column type="gchararray"/><!-- column-name comments --><column type="gchararray"/></columns></object><object class="GtkWindow" id="main"><property name="can-focus">False</property><property name="default-width">1200</property><property name="default-height">650</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><property name="show-tabs">False</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkScrolledWindow"><property name="width-request">800</property><property name="height-request">500</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkTreeView" id="repository"><property name="visible">True</property><property name="can-focus">True</property><property name="model">repository_store</property><property name="enable-search">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><property name="enable-grid-lines">both</property><property name="activate-on-single-click">True</property><child internal-child="selection"><object class="GtkTreeSelection"/></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">File Name</property><property name="sort-column-id">0</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Game</property><property name="clickable">True</property><property name="sort-column-id">1</property><child><object class="GtkCellRendererText"><property name="xalign">0.5099999904632568</property></object><attributes><attribute name="text">1</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Size</property><property name="clickable">True</property><property name="sort-column-id">3</property><child><object class="GtkCellRendererText"><property name="xalign">1</property></object><attributes><attribute name="text">2</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Last Updated</property><property name="clickable">True</property><property name="sort-column-id">4</property><child><object class="GtkCellRendererText"><property name="xalign">0.5099999904632568</property></object><attributes><attribute name="text">4</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Author</property><property name="clickable">True</property><property name="sort-column-id">5</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">5</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">DLs</property><property name="clickable">True</property><property name="sort-column-id">7</property><child><object class="GtkCellRendererText"><property name="xalign">1</property></object><attributes><attribute name="text">6</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Rating</property><property name="clickable">True</property><property name="sort-column-id">9</property><child><object class="GtkCellRendererText"><property name="xalign">1</property></object><attributes><attribute name="text">8</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Votes</property><property name="clickable">True</property><property name="sort-column-id">11</property><child><object class="GtkCellRendererText"><property name="xalign">1</property></object><attributes><attribute name="text">10</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="resizable">True</property><property name="sizing">fixed</property><property name="title" translatable="yes">Tags</property><property name="clickable">True</property><property name="sort-column-id">12</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">12</attribute></attributes></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel" id="comments"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="label" translatable="yes">Comments from selected script (if any) will be shown here</property><property name="wrap">True</property></object></child></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkSearchEntry" id="search_entry"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="primary-icon-name">edit-find-symbolic</property><property name="primary-icon-activatable">False</property><property name="primary-icon-sensitive">False</property><property name="placeholder-text" translatable="yes">Keyword Search</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property></packing></child><child><object class="GtkLabel" id="link_data"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">label</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="height">2</property></packing></child><child><object class="GtkButton" id="download_link"><property name="label" translatable="yes">Download selected script</property><property name="width-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><placeholder/></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes"> Profiles </property></object><packing><property name="tab-fill">False</property><property name="reorderable">True</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><placeholder/></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
        end
      end
    end
  end

  # File uploader
  class FileUploader
    def initialize(options)
      @options = options
    end

    def upload_file(file)
      filename, file_path = find_file(file)
      return false unless filename && file_path

      md5sum = Digest::MD5.file(file_path).to_s
      comments = File.open(file_path, 'rb') { |f| CommentParser.extract_comments(f.read(20_000)) }

      author = @options.author || CommentParser.extract_author(comments) || Char.name
      game = @options.game || CommentParser.extract_game(comments) || determine_default_game
      password = @options.password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"]

      if password.nil? && author != 'nobody' && file !~ /^playershops\.xml$/i
        echo "error: no password is saved for author #{author}"
        echo "If that's not the author name you want for this script, specify a different name by adding \"author: NAME\" to the comments at the top of your script, or add \"--author=NAME\" to the upload command."
        echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the upload command."
        return false
      end

      password ||= 'nothing'
      tags = @options.tags&.join(',') || CommentParser.extract_tags(comments)
      size = File.stat(file_path).size

      perform_upload(filename, file_path, game, author, password, tags, size, md5sum)
    end

    def upload_mapdb
      unless defined?(Map.save_json)
        echo 'error: Your version of Lich is too old to upload the map database.'
        return false
      end

      game = determine_mapdb_game
      return false unless game

      echo 'saving map database...'
      Map.save_json

      filename = find_latest_map_file
      unless filename && File.exist?(filename)
        echo 'error: could not find map database'
        return false
      end

      author = @options.author || Char.name
      password = @options.password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"]

      if password.nil?
        echo "error: no password is saved for author #{author}"
        echo "If that's not the author name you want, specify a different name by adding \"--author=NAME\" to the command."
        echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the upload command."
        return false
      end

      perform_mapdb_upload(filename, game, author, password)
    end

    def checkout_mapdb
      unless defined?(Map.save_json)
        echo 'error: Your version of Lich is too old to checkout the map database.'
        return false
      end

      game = determine_mapdb_game
      return false unless game

      author = @options.author || Char.name
      password = @options.password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"]

      if password.nil?
        echo "error: no password is saved for author #{author}"
        echo "If that's not the author name you want to use, specify a different name by adding \"--author=NAME\" to the command."
        echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the command."
        return false
      end

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth({
          'action'   => 'checkout-mapdb',
          'author'   => author,
          'password' => password,
          'game'     => game,
          'client'   => RepositoryTillmen.client_version
        })

        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          return false
        elsif response['success']
          if @options.password
            Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = @options.password
            echo "password saved for author #{author}"
          end
          echo 'success; running download-mapdb now...'
          true
        else
          false
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    def release_mapdb
      game = determine_mapdb_game
      return false unless game

      author = @options.author || Char.name
      password = @options.password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"]

      if password.nil?
        echo "error: no password is saved for author #{author}"
        echo "If that's not the author name you want to use, specify a different name by adding \"--author=NAME\" to the command."
        echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the command."
        return false
      end

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth({
          'action'   => 'release-mapdb',
          'author'   => author,
          'password' => password,
          'game'     => game,
          'client'   => RepositoryTillmen.client_version
        })

        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          return false
        elsif response['success']
          if @options.password
            Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = @options.password
            echo "password saved for author #{author}"
          end
          echo 'success: other people can work on the map database now'
          true
        else
          false
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    def approve_mapdb(game_arg, timestamp)
      author = @options.author || Char.name
      password = @options.password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"]

      if password.nil?
        echo "error: no password is saved for author #{author}"
        echo "If that's not the author name you want to use, specify a different name by adding \"--author=NAME\" to the command."
        echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the command."
        return false
      end

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth({
          'action'    => 'approve-mapdb',
          'author'    => author,
          'password'  => password,
          'game'      => game_arg,
          'timestamp' => timestamp,
          'client'    => RepositoryTillmen.client_version
        })

        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          return false
        elsif response['success']
          if @options.password
            Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = @options.password
            echo "password saved for author #{author}"
          end
          echo 'success'
          true
        else
          false
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    private

    def find_file(file)
      if File.exist?(File.join(SCRIPT_DIR, file))
        [file, File.join(SCRIPT_DIR, file)]
      elsif File.exist?(File.join(SCRIPT_DIR, "#{file}.lic"))
        ["#{file}.lic", File.join(SCRIPT_DIR, "#{file}.lic")]
      elsif file =~ /\.(?:ui|xml|json|yaml|yml)$/i &&
            LICH_VERSION.split('.').map { |n| n.rjust(5, '0') }.join('.') >= '00004.00006.00000' &&
            File.exist?(File.join(DATA_DIR, file))
        [file, File.join(DATA_DIR, file)]
      else
        echo "error: could not find #{file}"
        nil
      end
    end

    def determine_default_game
      if XMLData.game =~ /^GS/
        'gs'
      elsif XMLData.game =~ /^DR/
        'dr'
      else
        'other'
      end
    end

    def determine_mapdb_game
      if XMLData.game =~ /^GS/i
        XMLData.game =~ /^GSF$|^GSPlat$/i ? XMLData.game.downcase : 'gsiv'
      elsif XMLData.game =~ /^DR/i
        XMLData.game =~ /^DRF$|^DRX$/i ? XMLData.game.downcase : 'dr'
      elsif XMLData.game =~ /^GST$/
        'GSIV'.downcase
      else
        echo 'error: unknown game'
        nil
      end
    end

    def find_latest_map_file
      maps = Dir.entries(File.join(DATA_DIR, XMLData.game))
                .select { |fn| fn =~ /^map\-[0-9]+\.json$/i }
                .map { |fn| File.join(DATA_DIR, XMLData.game, fn) }
                .sort
      maps[-1]
    end

    def perform_upload(filename, file_path, game, author, password, tags, size, md5sum)
      request = {
        'action'   => 'upload',
        'file'     => filename,
        'game'     => game,
        'size'     => size,
        'author'   => author,
        'password' => password,
        'md5sum'   => md5sum,
        'tags'     => tags,
        'client'   => RepositoryTillmen.client_version
      }

      upload_path = file_path
      delete_temp = false

      if size > 5000
        temp_file = File.join(TEMP_DIR, "#{rand(100000000)}.repo")
        File.open(file_path, 'rb') do |f|
          Zlib::GzipWriter.open(temp_file) do |gz|
            while (data = f.read(1_000_000))
              gz.write(data)
            end
          end
        end
        upload_path = temp_file
        delete_temp = true
        size = File.stat(upload_path).size
        request['size'] = size
        request['compression'] = 'gzip'
      end

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth(request)
        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          return false
        elsif !response['continue']
          echo "error: unrecognized response from server: #{response.inspect}"
          return false
        end

        if @options.password
          Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = @options.password
          echo "password saved for author #{author}"
        end

        File.open(upload_path, 'rb') do |f|
          (size / 1_000_000).times { ssl_socket.write(f.read(1_000_000)) }
          remainder = size % 1_000_000
          ssl_socket.write(f.read(remainder)) unless remainder == 0
        end

        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          false
        elsif response['success']
          echo 'upload complete'
          true
        else
          echo "error: unrecognized response from server: #{response.inspect}"
          false
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
        File.delete(upload_path) if delete_temp
      end
    end

    def perform_mapdb_upload(filename, game, author, password)
      md5sum = Digest::MD5.file(filename).to_s
      request = {
        'action'   => 'upload-mapdb',
        'game'     => game,
        'author'   => author,
        'password' => password,
        'md5sum'   => md5sum,
        'client'   => RepositoryTillmen.client_version
      }

      echo 'compressing map database...'
      temp_file = File.join(TEMP_DIR, "#{rand(100000000)}.repo")

      File.open(filename, 'rb') do |f|
        Zlib::GzipWriter.open(temp_file) do |gz|
          while (data = f.read(1_000_000))
            gz.write(data)
          end
        end
      end

      size = File.stat(temp_file).size
      request['size'] = size
      request['compression'] = 'gzip'

      ssl_socket, socket = Connection.connect(force: @options.force)

      begin
        ssl_socket.puth(request)
        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          return false
        elsif !response['continue']
          echo "error: unrecognized response from server: #{response.inspect}"
          return false
        end

        if @options.password
          Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = @options.password
          echo "password saved for author #{author}"
        end

        echo 'uploading map database...'
        start_time = Time.now.to_f
        progress = 0
        progress_time = Time.now.to_i
        chunk_size = 16384

        File.open(temp_file, 'rb') do |f|
          (size / chunk_size).times do
            ssl_socket.write(f.read(chunk_size))
            progress += chunk_size

            if (Time.now.to_i - progress_time) > 9
              progress_time = Time.now.to_i
              rate = ((progress / 1024.0) / (Time.now.to_f - start_time) * 10).round / 10.0
              echo "still uploading (#{((progress * 100) / size).round}%, #{rate} KB/s)..."
            end
          end

          remainder = size % chunk_size
          ssl_socket.write(f.read(remainder)) unless remainder == 0
        end

        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          false
        elsif response['success']
          echo 'upload complete'
          upload_map_images(ssl_socket, socket)
          true
        else
          echo "error: unrecognized response from server: #{response.inspect}"
          false
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
        File.delete(temp_file)
      end
    end

    def upload_map_images(_ssl_socket, _socket)
      image_filenames = Map.list.map(&:image).compact.uniq

      image_filenames.each do |fn|
        unless fn =~ /\.(?:png|jpg|gif)$/i
          echo "warning: ignoring #{fn} (map images should have a .png or .jpg file extension)"
        end
        unless File.exist?(File.join(MAP_DIR, fn))
          echo "warning: ignoring #{fn} (file not found in #{MAP_DIR})"
        end
      end

      image_filenames.delete_if { |fn| fn !~ /\.(?:png|jpg|gif)$/i || !File.exist?(File.join(MAP_DIR, fn)) }
      return if image_filenames.empty?

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth({
          'action' => 'upload-mapdb-images',
          'files'  => image_filenames.join('/'),
          'client' => RepositoryTillmen.client_version
        })

        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          return
        elsif response['need-images']
          response['need-images'].split('/').each do |filename|
            upload_single_map_image(ssl_socket, filename)
          end
          echo 'done'
        elsif response['success']
          # All images already uploaded
        else
          echo "error: unrecognized response from server: #{response.inspect}"
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    def upload_single_map_image(ssl_socket, filename)
      file_path = File.join(MAP_DIR, filename)
      size = File.stat(file_path).size

      echo "uploading #{filename}..."

      ssl_socket.puth({
        'file'   => filename,
        'size'   => size,
        'md5sum' => Digest::MD5.file(file_path).to_s,
        'client' => RepositoryTillmen.client_version
      })

      response = ssl_socket.geth

      echo "warning: server says: #{response['warning']}" if response['warning']

      if response['error']
        echo "error: server says: #{response['error']}"
        return
      elsif !response['continue']
        echo "error: unrecognized response from server: #{response.inspect}"
        return
      end

      File.open(file_path, 'rb') do |f|
        (size / 1_000_000).times { ssl_socket.write(f.read(1_000_000)) }
        remainder = size % 1_000_000
        ssl_socket.write(f.read(remainder)) unless remainder == 0
      end

      response = ssl_socket.geth

      echo "warning: server says: #{response['warning']}" if response['warning']

      unless response['success']
        echo "error: server says: #{response['error']}" if response['error']
        echo "error: unrecognized response from server: #{response.inspect}" unless response['error']
      end
    end
  end

  # File deletion and rating
  class FileManager
    def initialize(options)
      @options = options
    end

    def delete_file(file_name, list_processor, repo_list)
      list = find_matching_file(file_name, list_processor, repo_list)
      headers = list.shift

      fi = headers.index('file')
      gi = headers.index('game')
      ai = headers.index('author')

      file = list[0][fi]
      game = list[0][gi]
      author = list[0][ai]

      password = @options.password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"]

      if password.nil? && author != 'nobody'
        echo "error: no password is saved for author #{author}; specify a password by adding \"--password=PASSWORD\" to the delete command"
        return false
      end

      password ||= 'nothing'

      echo "deleting #{file} in 5 seconds... (;k repository to cancel)"
      sleep 5

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth({
          'action'   => 'delete',
          'file'     => file,
          'game'     => game,
          'author'   => author,
          'password' => password,
          'client'   => RepositoryTillmen.client_version
        })

        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          false
        elsif response['success']
          if @options.password
            Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = @options.password
            echo "password saved for author #{author}"
          end
          echo 'done'
          true
        else
          echo "error: unrecognized response from server: #{response.inspect}"
          false
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    def rate_file(file_name, rating, list_processor, repo_list)
      unless rating =~ /^(?:[1-9]|10)$/
        echo 'error: rating needs to be 1-10'
        return false
      end

      list = find_matching_file(file_name, list_processor, repo_list)
      headers = list.shift

      fi = headers.index('file')
      gi = headers.index('game')

      file = list[0][fi]
      game = list[0][gi]

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth({
          'action' => 'rate',
          'file'   => file,
          'game'   => game,
          'rating' => rating,
          'client' => RepositoryTillmen.client_version
        })

        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          false
        elsif response['success']
          echo 'Thank you for rating this script.'
          true
        else
          echo "error: unrecognized response from server: #{response.inspect}"
          false
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    def change_password(new_password)
      author = @options.author || Char.name
      password = @options.password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"]

      if password.nil?
        echo "error: no password is saved for author #{author}; specify a password by adding \"--password=OLDPASSWORD\" to the change-password command (or if this author name has not been used before, the initial password must be set with an upload command)"
        return false
      end

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth({
          'action'       => 'change password',
          'author'       => author,
          'password'     => password,
          'new password' => new_password,
          'client'       => RepositoryTillmen.client_version
        })

        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          false
        elsif response['success']
          echo 'your password has been changed on the server'
          Settings["password:#{author.gsub(/[^a-z]/, '').downcase}"] = new_password
          echo "password saved for author #{author}"
          true
        else
          echo "error: unrecognized response from server: #{response.inspect}"
          false
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    private

    def find_matching_file(name, list_processor, repo_list)
      list = list_processor.filter_list(repo_list.fetch_list)
      headers = list.shift

      unless (fi = headers.index('file')) && (headers.index('game'))
        echo 'error: list is missing headers'
        exit
      end

      exact_matches = list.select { |row| row[fi].downcase == name.downcase }
      list = exact_matches.empty? ? list.select { |row| row[fi] =~ /^#{name}/i } : exact_matches

      if list.empty?
        echo "error: file not found"
        exit
      elsif list.length > 1
        list.unshift(headers)
        respond "\nMultiple files match: be more specific\n\n#{list_processor.format_list(list)}\n\n"
        exit
      end

      list.unshift(headers)
      list
    end
  end

  # File downloader
  class FileDownloader
    def initialize(options)
      @options = options
    end

    def download_file(file, game, version = nil)
      ssl_socket, socket = Connection.connect(force: @options.force)

      begin
        request = {
          'action'                 => 'download',
          'file'                   => file,
          'game'                   => game,
          'supported compressions' => 'gzip',
          'client'                 => RepositoryTillmen.client_version
        }
        request['version'] = version if version

        ssl_socket.puth(request)
        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          return false
        end

        unless response['file'] == file && response['size'] =~ /^[0-9]+$/
          echo 'error: out of cheese 6'
          return false
        end

        if response['compression'] && response['compression'] != 'gzip'
          echo "error: unsupported compression method: #{response['compression']}"
          return false
        end

        download_and_save_file(ssl_socket, response, file)
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    def download_mapdb
      unless defined?(Map.save_json)
        echo 'error: Your version of Lich is too old to download the map database.'
        return
      end

      game = determine_mapdb_game
      request = {
        'action'                 => 'download-mapdb',
        'game'                   => game,
        'supported compressions' => 'gzip',
        'client'                 => RepositoryTillmen.client_version
      }

      current_map = find_current_map
      if current_map
        request['current-md5sum'] = Digest::MD5.file(current_map).to_s
      end

      Connection.set_jinx_context(command: 'update', filename: 'mapdb.json')

      ssl_socket, socket = Connection.connect(force: @options.force)

      begin
        ssl_socket.puth(request)
        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          handle_mapdb_error(response)
          return false
        end

        if response['compression'] && response['compression'] != 'gzip'
          echo "error: unsupported compression method: #{response['compression']}"
          return false
        end

        download_and_install_mapdb(ssl_socket, response)
        download_map_images(ssl_socket, socket)

        echo 'done'
        true
      ensure
        Connection.clear_jinx_context
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    def check_mapdb
      game = determine_mapdb_game
      request = {
        'action'                 => 'download-mapdb',
        'game'                   => game,
        'supported compressions' => 'gzip',
        'client'                 => RepositoryTillmen.client_version
      }

      current_map = find_current_map
      if current_map
        request['current-md5sum'] = Digest::MD5.file(current_map).to_s
      end

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth(request)
        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error'] == 'already up-to-date'
          echo "map database is currently up to date."
        else
          echo "map database is not currently up to date."
        end

        if response['uploaded by'] && response['timestamp']
          echo "map database last updated by #{response['uploaded by']} at #{Time.at(response['timestamp'].to_i)}"
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    private

    def determine_mapdb_game
      if XMLData.game =~ /^GS/i
        XMLData.game =~ /^GSF$|^GSPlat$/i ? XMLData.game.downcase : 'gsiv'
      elsif XMLData.game =~ /^DR/i
        XMLData.game =~ /^DRF$|^DRX$/i ? XMLData.game.downcase : 'dr'
      else
        XMLData.game.downcase
      end
    end

    def find_current_map
      maps = Dir.entries(File.join(DATA_DIR, XMLData.game))
                .select { |fn| fn =~ /^map\-[0-9]+\.(?:dat|xml|json)$/i }
                .sort
      return nil if maps.empty?

      File.join(DATA_DIR, XMLData.game, maps[-1])
    end

    def handle_mapdb_error(response)
      if response['error'] == 'already up-to-date'
        if response['timestamp'] && response['uploaded by']
          echo "map database is up-to-date; last updated by #{response['uploaded by']} at #{Time.at(response['timestamp'].to_i)}"
        else
          echo 'map database is up-to-date'
        end
      else
        echo "error: server says: #{response['error']}"
      end
    end

    def download_and_save_file(ssl_socket, response, file)
      response['size'] = response['size'].to_i

      target_dir = if file =~ /\.(?:ui|xml|json|yaml|yml)$/i &&
                      LICH_VERSION.split('.').map { |n| n.rjust(5, '0') }.join('.') >= '00004.00006.00000'
                     DATA_DIR
                   else
                     SCRIPT_DIR
                   end

      new_filename = File.join(target_dir, file)
      temp_filename = File.join(TEMP_DIR, "#{rand(100000000)}.repo")

      # Download to temp file
      File.open(temp_filename, 'wb') do |f|
        (response['size'] / 1_000_000).times { f.write(ssl_socket.read(1_000_000)) }
        remainder = response['size'] % 1_000_000
        f.write(ssl_socket.read(remainder)) unless remainder == 0
      end

      # Decompress if needed
      if response['compression'] == 'gzip'
        temp_filename = decompress_file(temp_filename)
      end

      # Verify MD5
      if Digest::MD5.file(temp_filename).to_s != response['md5sum']
        if @options.force
          echo "warning: md5sum mismatch: file likely corrupted in transit"
        else
          echo "error: md5sum mismatch: file likely corrupted in transit"
          File.delete(temp_filename)
          return false
        end
      end

      # Check requirements
      requirement = check_file_requirements(temp_filename)
      if requirement && !@options.force
        echo "error: #{file} requires Lich version #{requirement}; your current Lich version is #{LICH_VERSION}"
        File.delete(temp_filename)
        return false
      elsif requirement
        echo "warning: #{file} requires Lich version #{requirement}; your current Lich version is #{LICH_VERSION}"
      end

      # Move to final location
      move_file(temp_filename, new_filename)

      # Reload if necessary
      reload_file_if_needed(file)

      true
    end

    def decompress_file(filename)
      ungzip_name = File.join(TEMP_DIR, "#{rand(100000000)}")
      File.open(ungzip_name, 'wb') do |f|
        Zlib::GzipReader.open(filename) do |gz|
          while (data = gz.read(1_000_000))
            f.write(data)
          end
        end
      end

      move_file(ungzip_name, filename)
      filename
    end

    def check_file_requirements(filename)
      comments = File.open(filename, 'rb') { |f| CommentParser.extract_comments(f.read(20_000)) }
      CommentParser.check_lich_requirement(comments)
    end

    def reload_file_if_needed(file)
      return unless XMLData.game =~ /^GS/

      case file
      when 'spell-list.xml', 'effect-list.xml'
        Spell.load
      when 'gameobj-data.xml'
        GameObj.load_data
      end
    end

    def move_file(source, destination)
      File.rename(source, destination)
    rescue => e
      if e.to_s =~ /Invalid cross-device link/
        File.open(source, 'rb') { |r| File.open(destination, 'wb') { |w| w.write(r.read) } }
        File.delete(source)
      else
        raise
      end
    end

    def download_and_install_mapdb(ssl_socket, response)
      response['size'] = response['size'].to_i
      new_filename = File.join(DATA_DIR, XMLData.game, "map-#{response['timestamp']}.json")
      temp_filename = File.join(TEMP_DIR, "#{rand(100000000)}.repo")

      if response['timestamp'] && response['uploaded by']
        echo "downloading map database... (uploaded by #{response['uploaded by']} at #{Time.at(response['timestamp'].to_i)})"
      else
        echo 'downloading map database...'
      end

      File.open(temp_filename, 'wb') do |f|
        (response['size'] / 1_000_000).times { f.write(ssl_socket.read(1_000_000)) }
        remainder = response['size'] % 1_000_000
        f.write(ssl_socket.read(remainder)) unless remainder == 0
      end

      if response['compression'] == 'gzip'
        temp_filename = decompress_file(temp_filename)
      end

      if Digest::MD5.file(temp_filename).to_s != response['md5sum']
        if @options.force
          echo "warning: md5sum mismatch: file likely corrupted in transit"
        else
          echo "error: md5sum mismatch: file likely corrupted in transit"
          File.delete(temp_filename)
          return false
        end
      end

      move_file(temp_filename, new_filename)
      cleanup_old_maps(response['timestamp'])
      backup_newer_maps(response['timestamp'])

      echo 'loading map database...'
      Map.reload
      true
    end

    def cleanup_old_maps(timestamp)
      map_dir = File.join(DATA_DIR, XMLData.game)
      old_maps = Dir.entries(map_dir)
                    .select { |fn| fn =~ /^map\-([0-9]+)\.(?:dat|xml|json)$/i && $1 != timestamp }
                    .sort[0...-3]

      return if old_maps.empty?

      echo "deleting old map databases..."
      old_maps.each { |fn| File.delete(File.join(map_dir, fn)) rescue nil }
    end

    def backup_newer_maps(timestamp)
      map_dir = File.join(DATA_DIR, XMLData.game)
      Dir.entries(map_dir).each do |fn|
        next unless fn =~ /^map\-([0-9]+)\.(?:dat|xml|json)$/i && $1.to_i > timestamp.to_i

        source = File.join(map_dir, fn)
        destination = File.join(map_dir, "#{fn}.bak")
        move_file(source, destination)
      end
    end

    def download_map_images(_ssl_socket, _socket)
      image_filenames = Map.list.map(&:image).compact.uniq
      Dir.mkdir(MAP_DIR) unless File.exist?(MAP_DIR)
      image_filenames.delete_if { |fn| File.exist?(File.join(MAP_DIR, fn)) }

      return if image_filenames.empty?

      echo 'downloading missing map images...'

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth({
          'action' => 'download-mapdb-images',
          'files'  => image_filenames.join('/'),
          'client' => RepositoryTillmen.client_version
        })

        loop do
          response = ssl_socket.geth

          echo "warning: server says: #{response['warning']}" if response['warning']

          break if response['error'] || response['success']

          unless response['file'] && response['size'] && response['md5sum']
            echo "error: unrecognized response from server: #{response.inspect}"
            break
          end

          download_map_image(ssl_socket, response)
        end
      ensure
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    def download_map_image(ssl_socket, response)
      response['size'] = response['size'].to_i
      temp_filename = File.join(TEMP_DIR, "#{rand(100000000)}.repo")

      echo "downloading #{response['file']}..."

      File.open(temp_filename, 'wb') do |f|
        (response['size'] / 1_000_000).times { f.write(ssl_socket.read(1_000_000)) }
        remainder = response['size'] % 1_000_000
        f.write(ssl_socket.read(remainder)) unless remainder == 0
      end

      if Digest::MD5.file(temp_filename).to_s != response['md5sum']
        if @options.force
          echo "warning: md5sum mismatch: file likely corrupted in transit"
        else
          echo "error: md5sum mismatch: file likely corrupted in transit"
          File.delete(temp_filename)
          return
        end
      end

      move_file(temp_filename, File.join(MAP_DIR, response['file']))
    end
  end

  # Settings manager for updatable scripts/mapdb
  class SettingsManager
    def self.initialize_settings
      Settings['updatable'] ||= {}
      Settings['updatable'][:scripts] ||= []
      Settings['updatable'][:mapdb] ||= {}

      return unless Settings['updatable'][:mapdb].empty?

      setup_default_settings
      migrate_old_settings
      ensure_required_scripts
    end

    def self.setup_default_settings
      Settings['updatable'][:mapdb][XMLData.game] = true
      Settings['updatable'][:lich] = false

      # Common scripts to DR and GS
      add_default_script('alias.lic', 'gs', 'elanthia-online')
      add_default_script('autostart.lic', 'gs', 'elanthia-online')
      add_default_script('go2.lic', 'gs', 'elanthia-online')
      add_default_script('jinx.lic', 'gs', 'elanthia-online')
      add_default_script('log.lic', 'gs', 'elanthia-online')
      add_default_script('logxml.lic', 'gs', 'elanthia-online')
      add_default_script('map.lic', 'gs', 'elanthia-online')
      add_default_script('repository.lic', 'gs', 'elanthia-online')
      add_default_script('vars.lic', 'gs', 'elanthia-online')
      add_default_script('version.lic', 'gs', 'elanthia-online')

      if XMLData.game =~ /^GS/
        setup_gemstone_defaults
      elsif XMLData.game =~ /^DR/
        setup_dragonrealms_defaults
      end
    end

    def self.setup_gemstone_defaults
      Settings['updatable'][:mapdb]['GSIV'] = true
      Settings['updatable'][:mapdb]['GSF'] = true
      Settings['updatable'][:mapdb]['GSPlat'] = true

      add_default_script('ewaggle.lic', 'gs', 'elanthia-online')
      add_default_script('effect-list.xml', 'gs', 'elanthia-online')
      add_default_script('gameobj-data.xml', 'gs', 'elanthia-online')
    end

    def self.setup_dragonrealms_defaults
      Settings['updatable'][:mapdb]['DR'] = true
      Settings['updatable'][:mapdb]['DRF'] = false
      Settings['updatable'][:mapdb]['DRX'] = false

      add_default_script('dependency.lic', 'dr', 'elanthia-online')
    end

    def self.add_default_script(filename, game, author)
      Settings['updatable'][:scripts].push(
        filename: filename,
        game: game,
        author: author
      )
    end

    def self.migrate_old_settings
      # Update GST mapdb setting
      if XMLData.game =~ /^GS/ && Settings['updatable'][:mapdb]['GST'].nil?
        Settings['updatable'][:mapdb]['GST'] = true
      end

      # Update gameobj-data.xml ownership
      update_script_author('gameobj-data.xml', 'Tillmen', 'elanthia-online')

      # Update core script ownership
      %w[repository.lic lnet.lic alias.lic vars.lic go2.lic autostart.lic log.lic logxml.lic].each do |script_name|
        idx = Settings['updatable'][:scripts].find_index do |s|
          s[:filename] == script_name && s[:author] != 'elanthia-online'
        end

        if idx
          echo "updating ownership of #{Settings['updatable'][:scripts][idx][:filename]} to elanthia-online"
          Settings['updatable'][:scripts][idx][:author] = 'elanthia-online'
          Settings['updatable'][:scripts][idx][:game] = 'gs'
        end
      end

      # Add effect-list.xml if using Lich 5.7+ and spell-list.xml is updatable
      if XMLData.game =~ /^GS/ &&
         Gem::Version.new(LICH_VERSION) >= Gem::Version.new("5.7.0") &&
         !Settings['updatable'][:scripts].any? { |s| s[:filename] == 'effect-list.xml' } &&
         Settings['updatable'][:scripts].any? { |s| s[:filename] == 'spell-list.xml' }

        echo "adding effect-list.xml to updatable list as spell-list.xml no longer used by Lich 5.7+"
        add_default_script('effect-list.xml', 'gs', 'elanthia-online')
      end
    end

    def self.ensure_required_scripts
      # Ensure dependency.lic is always updatable for DR instances
      update_script_author('dependency.lic', nil, 'elanthia-online', game: 'dr')

      if XMLData.game =~ /^DR/ &&
         !Settings['updatable'][:scripts].any? { |s| s[:filename] == 'dependency.lic' }

        echo "adding dependency.lic to updatable list"
        add_default_script('dependency.lic', 'dr', 'elanthia-online')
      end
    end

    def self.update_script_author(filename, old_author, new_author, game: nil)
      idx = Settings['updatable'][:scripts].find_index do |s|
        s[:filename] == filename && (old_author.nil? || s[:author] != new_author)
      end

      return unless idx

      echo "updating ownership of #{Settings['updatable'][:scripts][idx][:filename]} to #{new_author}"
      Settings['updatable'][:scripts][idx][:author] = new_author
      Settings['updatable'][:scripts][idx][:game] = game if game
    end

    def self.show_updatable
      table_rows = []

      Settings['updatable'][:mapdb].each do |game, value|
        next if XMLData.game =~ /^DR/ && game =~ /^GS/
        next if XMLData.game =~ /^GS/ && game =~ /^DR/

        table_rows << [{ value: "mapdb #{game}: #{value ? 'on' : 'off'}", colspan: 3 }]
      end

      table_rows << :separator
      table_rows << ['Script/File', 'Author', 'Game']
      table_rows << :separator

      if Settings['updatable'][:scripts].empty?
        table_rows << [{ value: "No Scripts Updatable", colspan: 3 }]
      else
        Settings['updatable'][:scripts].sort_by { |s| s[:filename] }.each do |script|
          table_rows << [script[:filename], script[:author], script[:game]]
        end
      end

      table = Terminal::Table.new(rows: table_rows)

      if $frontend =~ /^(?:stormfront|wrayth|genie)$/i
        _respond "<output class=\"mono\"/>\n#{table}\n<output class=\"\"/>"
      else
        _respond table.to_s.split("\n")
      end
    end

    def self.cleanup_cached_settings
      Settings["cached-list-comments"] = nil if Settings["cached-list-comments"]
      Settings["cached-list"] = nil if Settings["cached-list"]
      Settings["cached-list-offset"] = nil if Settings["cached-list-offset"]
    end
  end

  # Command executor
  class CommandExecutor
    def initialize(parser)
      @parser = parser
      @options = parser.options
      @mapdb_reloaded = false
      # Lazy initialization - only create these when needed
      @repo_list = nil
      @list_processor = nil
      @downloader = nil
    end

    def repo_list
      @repo_list ||= RepositoryList.new
    end

    def list_processor
      @list_processor ||= ListProcessor.new(@options)
    end

    def downloader
      @downloader ||= FileDownloader.new(@options)
    end

    def execute
      case @parser.command
      when /^list$/i
        execute_list
      when /^list-?update[sd]$/i
        execute_list_updates
      when /^list-?new$/i
        execute_list_new
      when /^list-?tags?$/i
        execute_list_tags
      when /^info$/i
        execute_info
      when /^download$/i
        execute_download
      when /^download-?update[ds]$/i
        execute_download_updates
      when /^show-?updat(?:e|able)$/i
        SettingsManager.show_updatable
      when /^set-?updat(?:e|able)$/i
        execute_set_updatable
      when /^unset-?updat(?:e|able)$/i
        execute_unset_updatable
      when /^set-?map(?:db)?-?updat(?:e|able)$|^set-?updat(?:e|able)-?map(?:db)?$/i
        execute_set_mapdb_updatable
      when /^unset-?map(?:db)?-?updat(?:e|able)$|^unset-?updat(?:e|able)-?map(?:db)?$/i
        execute_unset_mapdb_updatable
      when /^upload$/i
        execute_upload
      when /^delete$/i
        execute_delete
      when /^rate$/i
        execute_rate
      when /^(?:new|change)-?password$/i
        execute_change_password
      when /^checkout-?map(?:db)?$/i
        execute_checkout_mapdb
      when /^release-?map(?:db)?$/i
        execute_release_mapdb
      when /^approve-?map(?:db)?$/i
        execute_approve_mapdb
      when /^upload-?map(?:db)?$/i
        execute_upload_mapdb
      when /^download-?map(?:db)?$/i
        downloader.download_mapdb
      when /^mapdb-check$/i
        downloader.check_mapdb
      when /^download-?lich$/i
        echo "Lich is no longer updatable via ;repository"
        echo "Please see ;lich5-update --help"
        echo "For info on updating Lich5"
      when /^gui$/i
        execute_gui
      when /^reset-update-settings$/i
        execute_reset_settings
      when /^help$/i
        show_help
      else
        echo "error: unrecognized command. Try #{$clean_lich_char}repository help"
      end
    end

    private

    def execute_list
      check_no_arguments
      list = repo_list.fetch_list
      list = repo_list.add_comments_to_list(list)
      list = list_processor.filter_list(list)
      respond "\n#{list_processor.format_list(list)}\n\n"
    end

    def execute_list_updates
      check_no_arguments
      list = list_processor.filter_list(repo_list.fetch_list)
      headers = list.shift

      unless (lui = headers.index('last update')) && (fi = headers.index('file'))
        echo 'error: list is missing headers'
        exit
      end

      list.delete_if do |row|
        file_path = if row[fi] =~ /\.(?:ui|xml|json|yaml|yml)$/i &&
                       LICH_VERSION.split('.').map { |n| n.rjust(5, '0') }.join('.') >= '00004.00006.00000'
                      File.join(DATA_DIR, row[fi])
                    else
                      File.join(SCRIPT_DIR, row[fi])
                    end

        !File.exist?(file_path) || (File.mtime(file_path).to_i + 15) > row[lui].to_i
      end

      list.unshift(headers)
      respond "\n#{list_processor.format_list(list)}\n\n"
    end

    def execute_list_new
      check_no_arguments
      list = list_processor.filter_list(repo_list.fetch_list)
      headers = list.shift

      unless (fi = headers.index('file'))
        echo 'error: list is missing headers'
        exit
      end

      list.delete_if do |row|
        file_path = if row[fi] =~ /\.(?:ui|xml|json|yaml|yml)$/i &&
                       LICH_VERSION.split('.').map { |n| n.rjust(5, '0') }.join('.') >= '00004.00006.00000'
                      File.join(DATA_DIR, row[fi])
                    else
                      File.join(SCRIPT_DIR, row[fi])
                    end

        File.exist?(file_path)
      end

      list.unshift(headers)
      respond "\n#{list_processor.format_list(list)}\n\n"
    end

    def execute_list_tags
      check_no_arguments
      list = list_processor.filter_list(repo_list.fetch_list)
      headers = list.shift

      unless (ti = headers.index('tags'))
        echo 'error: list is missing headers'
        exit
      end

      tags = {}
      list.each do |row|
        row[ti].split(',').each do |t|
          normalized = t.downcase.gsub(/[^a-z]+/, '')
          tags[normalized] = t
        end
      end

      if tags.empty?
        respond "\ntags: (none)\n\n"
      else
        respond "\ntags: #{tags.values.join(', ')}\n\n"
      end
    end

    def execute_info
      unless @parser.arguments[0]
        echo 'error: missing script name on command line'
        exit
      end

      check_single_argument

      # Set JINX context early, before any connection attempts
      # We'll update with the actual filename after we find the match
      Connection.set_jinx_context(command: 'info', filename: @parser.arguments[0])

      list = find_matching_files(@parser.arguments[0])
      original_headers = list.shift
      fi = original_headers.index('file')
      gi = original_headers.index('game')

      file = list[0][fi]
      game = list[0][gi]

      # Update with actual resolved filename
      Connection.set_jinx_context(command: 'info', filename: file)

      ssl_socket, socket = Connection.connect

      begin
        ssl_socket.puth({
          'action' => 'inspect',
          'file'   => file,
          'game'   => game,
          'client' => RepositoryTillmen.client_version
        })

        response = ssl_socket.geth

        echo "warning: server says: #{response['warning']}" if response['warning']

        if response['error']
          echo "error: server says: #{response['error']}"
          exit
        end

        unless response['size'] =~ /^[0-9]+$/
          echo 'error: out of cheese 4'
          exit
        end

        data = ssl_socket.read(response['size'].to_i)

        list.unshift(original_headers)
        output = "\n#{list_processor.format_list(list)}\n\n"

        if response['versions']
          sorted_versions = sort_versions(response['versions'])
          output << "available versions: #{sorted_versions}\n\n"
        end

        output << "#{data}\n\n"
        respond output
      ensure
        Connection.clear_jinx_context
        ssl_socket.close rescue nil
        socket.close rescue nil
      end
    end

    def execute_download
      unless @parser.arguments[0]
        echo 'error: missing script name on command line'
        exit
      end

      check_single_argument

      # Set JINX context early, before any connection attempts
      Connection.set_jinx_context(command: 'download', filename: @parser.arguments[0])

      list = find_matching_files(@parser.arguments[0])
      headers = list.shift
      fi = headers.index('file')
      gi = headers.index('game')
      file = list[0][fi]
      game = list[0][gi]

      if file =~ /^(infomon|waggle|x?narost)\.lic$/i
        Connection.clear_jinx_context
        echo "#{file} no longer updatable via ;repository."
        case file
        when /infomon/
          echo "Please use ;lich5-update --script=infomon.lic"
        when /waggle/
          echo "Please use ;repository download ewaggle.lic --game=gs"
        when /narost/
          echo "Please use ;repository download map.lic --game=gs"
        end
        return
      end

      # Update with actual resolved filename
      Connection.set_jinx_context(command: 'download', filename: file)

      echo "downloading #{file} in 3 seconds... (;k repository to cancel)"
      sleep 3

      begin
        if downloader.download_file(file, game, @options.version)
          echo 'done'
        end
      ensure
        Connection.clear_jinx_context
      end
    end

    def execute_download_updates
      check_no_arguments

      if Settings['updatable'].nil?
        echo "error: download-updates has not been set up; look for set-updatable and unset-updatable commands"
        exit
      end

      Settings['updatable'][:scripts] ||= []
      Settings['updatable'][:mapdb] ||= {}

      if Settings['updatable'][:mapdb][XMLData.game]
        downloader.download_mapdb
      end

      return if Settings['updatable'][:scripts].empty?

      list = repo_list.fetch_list
      headers = list.shift

      unless (fi = headers.index('file')) && (gi = headers.index('game')) &&
             (lui = headers.index('last update')) && (ai = headers.index('author'))
        echo 'error: list is missing headers'
        return
      end

      no_updates = true

      Settings['updatable'][:scripts].each do |local_info|
        next if should_skip_update?(local_info[:filename])

        remote_info = list.find { |r| r[fi] == local_info[:filename] && r[gi] == local_info[:game] }
        next unless remote_info

        if file_needs_update?(local_info[:filename], remote_info[lui])
          if remote_info[ai] != local_info[:author] && !@options.force
            echo "warning: author of #{local_info[:filename]} changed from #{local_info[:author]} to #{remote_info[ai]}: skipping"
          else
            if remote_info[ai] != local_info[:author]
              echo "warning: author of #{local_info[:filename]} changed from #{local_info[:author]} to #{remote_info[ai]}: downloading anyway"
            end

            echo "downloading #{local_info[:filename].sub(/\.lic$/, '')}..."
            start = Time.now.to_f
            downloader.download_file(local_info[:filename], local_info[:game], nil)
            sleep [[1.5 - (Time.now.to_f - start), 0].max, 0].max
            no_updates = false
          end
        end
      end

      echo no_updates ? 'scripts are up-to-date' : 'done'
    end

    def execute_set_updatable
      unless @parser.arguments[0]
        echo 'error: missing script name on command line'
        exit
      end

      check_single_argument

      list = find_matching_files(@parser.arguments[0])
      headers = list.shift
      fi = headers.index('file')
      gi = headers.index('game')
      ai = headers.index('author')

      info = {
        filename: list[0][fi],
        game: list[0][gi],
        author: list[0][ai]
      }

      Settings['updatable'] ||= {}
      Settings['updatable'][:scripts] ||= []

      if Settings['updatable'][:scripts].include?(info)
        echo "#{info[:filename]} is already set as updatable"
      else
        Settings['updatable'][:scripts].push(info)
        echo "the download-updates command will download #{info[:filename]} when there's an update"
      end
    end

    def execute_unset_updatable
      unless @parser.arguments[0]
        echo 'error: missing script name on command line'
        exit
      end

      check_single_argument

      Settings['updatable'] ||= {}
      Settings['updatable'][:scripts] ||= []

      info = Settings['updatable'][:scripts].find do |i|
        i[:filename] == @parser.arguments[0] || i[:filename] =~ /^#{@parser.arguments[0]}/i
      end

      if info
        echo "the download-updates command will ignore updates for #{info[:filename]}"
        Settings['updatable'][:scripts].delete(info)
      else
        echo "could not find #{@parser.arguments[0]} in the updatable list"
      end
    end

    def execute_set_mapdb_updatable
      game = determine_game_from_args || XMLData.game

      Settings['updatable'] ||= {}
      Settings['updatable'][:mapdb] ||= {}
      Settings['updatable'][:mapdb][game] = true

      echo "the download-updates command will download the #{game} map database when there's an update"
    end

    def execute_unset_mapdb_updatable
      game = determine_game_from_args || XMLData.game

      Settings['updatable'] ||= {}
      Settings['updatable'][:mapdb] ||= {}
      Settings['updatable'][:mapdb][game] = false

      echo "the download-updates command will ignore updates for the #{game} map database"
    end

    def execute_gui
      unless defined?(Gtk)
        echo "error: no gtk"
        exit
      end

      list = repo_list.fetch_list
      list = repo_list.add_comments_to_list(list)
      RepositoryGUI::Setup.new(list)
    end

    def execute_upload
      unless @parser.arguments[0]
        echo 'error: missing script name on command line'
        exit
      end

      check_single_argument

      uploader = FileUploader.new(@options)
      uploader.upload_file(@parser.arguments[0])
    end

    def execute_delete
      unless @parser.arguments[0]
        echo 'error: missing script name on command line'
        exit
      end

      check_single_argument

      file_manager = FileManager.new(@options)
      file_manager.delete_file(@parser.arguments[0], @list_processor, @repo_list)
    end

    def execute_rate
      unless @parser.arguments[0]
        echo 'error: missing script name on command line'
        exit
      end

      unless @parser.arguments[1]
        echo 'error: missing rating on command line'
        exit
      end

      if @parser.arguments[2]
        echo "error: extra words on command line: #{@parser.arguments[2..-1].join(' ')}"
        exit
      end

      file_manager = FileManager.new(@options)
      file_manager.rate_file(@parser.arguments[0], @parser.arguments[1], @list_processor, @repo_list)
    end

    def execute_change_password
      unless @parser.arguments[0]
        echo 'error: missing new password on command line'
        exit
      end

      check_single_argument

      file_manager = FileManager.new(@options)
      file_manager.change_password(@parser.arguments[0])
    end

    def execute_checkout_mapdb
      check_no_arguments

      uploader = FileUploader.new(@options)
      if uploader.checkout_mapdb
        downloader.download_mapdb
        Map.reload unless @mapdb_reloaded
        echo "edit your map database and ;repository upload-mapdb within 12 hours."
      end
    end

    def execute_release_mapdb
      check_no_arguments

      uploader = FileUploader.new(@options)
      uploader.release_mapdb
    end

    def execute_approve_mapdb
      unless @parser.arguments[0] && @parser.arguments[1]
        echo 'error: missing game and timestamp on command line'
        exit
      end

      if @parser.arguments[2]
        echo "error: extra words on command line: #{@parser.arguments[2..-1].join(' ')}"
        exit
      end

      uploader = FileUploader.new(@options)
      uploader.approve_mapdb(@parser.arguments[0], @parser.arguments[1])
    end

    def execute_upload_mapdb
      check_no_arguments

      uploader = FileUploader.new(@options)
      uploader.upload_mapdb
    end

    def execute_reset_settings
      Settings['updatable'] = nil
      Settings.save
      echo "Update settings have been reset"
    end

    def check_no_arguments
      return if @parser.arguments.empty?

      echo "error: extra words on command line: #{@parser.arguments.join(' ')}"
      exit
    end

    def check_single_argument
      return if @parser.arguments.length == 1

      echo "error: extra words on command line: #{@parser.arguments[1..-1].join(' ')}"
      exit
    end

    def find_matching_files(name)
      list = list_processor.filter_list(repo_list.fetch_list)
      headers = list.shift

      unless (fi = headers.index('file')) && (headers.index('game'))
        echo 'error: list is missing headers'
        exit
      end

      exact_matches = list.select { |row| row[fi].downcase == name.downcase }
      list = exact_matches.empty? ? list.select { |row| row[fi] =~ /^#{name}/i } : exact_matches

      if list.empty?
        echo "error: file not found"
        exit
      elsif list.length > 1
        list.unshift(headers)
        respond "\nMultiple files match: be more specific\n\n#{list_processor.format_list(list)}\n\n"
        exit
      end

      list.unshift(headers)
      list
    end

    def sort_versions(versions_string)
      versions_string.split(';')
                     .sort_by { |v| Gem::Version.new(v) }
                     .join(', ')
    end

    def should_skip_update?(filename)
      (LICH_VERSION =~ /^4\.4/ && filename =~ /^(alias|vars|autostart|infomon)\.lic$/i) ||
        (LICH_VERSION =~ /^5\./ && filename =~ /^(infomon|waggle|xnarost)\.lic$/i)
    end

    def file_needs_update?(filename, remote_timestamp)
      file_path = if filename =~ /\.(?:xml|json|yaml|yml)$/i &&
                     LICH_VERSION.split('.').map { |n| n.rjust(5, '0') }.join('.') >= '00004.00006.00000'
                    File.join(DATA_DIR, filename)
                  else
                    File.join(SCRIPT_DIR, filename)
                  end

      !File.exist?(file_path) || File.mtime(file_path).to_i < remote_timestamp.to_i
    end

    def determine_game_from_args
      return nil unless @parser.arguments[0]

      game = @parser.arguments[0].upcase
      case game
      when "DR", "DRX", "DRT", "DRF", "GSIV", "GSF", "GST"
        game
      when "GSPLAT"
        "GSPlat"
      else
        echo "error: invalid game: #{@parser.arguments[0]}"
        exit
      end
    end

    def show_help
      script_name = Script.current.name
      output = <<~HELP

        usage:

           #{$clean_lich_char}#{script_name} gui
           #{$clean_lich_char}#{script_name} COMMAND OPTIONS

        commands:

           list                      show files you can download
           list-updates              show files that you have and there's an update for
           list-new                  show files that you don't have
           list-tags                 show all the tags currently in use
           info FILENAME             show information about a file
           download FILENAME         download a file
           rate FILENAME NUMBER      rate a file (1-10)
           upload FILENAME           upload a file to the server
           delete FILENAME           delete a file from the server
           change-password NEWPASS   change your repository password
           download-mapdb            download the latest map database
           mapdb-check               check whether your current mapdb is current or not
                                     shows last upload date and user that uploaded
           checkout-mapdb            must be done before editing the map database
           release-mapdb             if you checkout-mapdb and change your mind
           upload-mapdb              upload your changes to the map database
           approve-mapdb GAME TIME   approve a map database upload (admin only)
           download-updates          downloads any available updates to scripts/mapdb
                                     if set as updatable with the set-updatable commands
           show-updatable            shows your current settings for download-updates
           set-updatable FILENAME    download updates for FILENAME (when using download-updates)
           set-mapdb-updatable       download updates for the map database (download-updates)
                                     takes optional game instance (ex: GST or DRT)
           unset-updatable FILENAME  ignore updates to FILENAME
           unset-mapdb-updatable     ignore updates to the map database
                                     takes optional game instance (ex: GST or DRT)
           reset-update-settings     reset script and map update settings

        options:

           --name=TEXT[,TEXT]        only list files whose name contain TEXT
           --game=CODE[,CODE]        filter by game code
           --search=TEXT             search list by TEXT given
           --sort=TEXT               sort list by name,age,size,downloads,rating
           --reverse                 show the list in reverse order
           --limit=NUMBER            show at most NUMBER files in the list
           --limit=OFFSET,NUMBER     show at most NUMBER files after skipping OFFSET files
           --author=TEXT             specify the author of the file for uploading or listing
           --password=TEXT           specify the password for the author for uploading
           --size>NUMBER[k|m|g]      only list files larger than NUMBER bytes (or specified unit)
           --size<NUMBER[k|m|g]      only list files smaller than NUMBER bytes (or specified unit)
           --age>NUMBER[m|h|d|w|y]   only list files updated less than NUMBER seconds (or specified unit) ago
           --age<NUMBER[m|h|d|w|y]   only list files updated more than NUMBER seconds (or specified unit) ago
           --downloads>NUMBER        only list files with more than NUMBER downloads
           --downloads<NUMBER        only list files with less than NUMBER downloads
           --downloads=NUMBER        only list files with exactly NUMBER downloads
           --rating>NUMBER           only list files with a rating higher than NUMBER
           --rating<NUMBER           only list files with a rating lower than NUMBER
           --rating=NUMBER           only list files with a rating equal to NUMBER
           --tags=TEXT[,TEXT]        only list files with the specified tags
           --version=<version>       download a specific version
           --force                   ignore md5sum checks and script requirements

           --show-tags               show tags in the list
           --hide-last-update        hide last update in the list
           --hide-size               hide file size in the list
           --hide-author             hide author in the list
           --hide-downloads          hide downloads in the list
           --hide-rating             hide rating in the list

      HELP

      respond output
    end
  end
end

# Main execution
before_dying do
  RepositoryTillmen::SettingsManager.cleanup_cached_settings
  Settings["updatable"]
end

RepositoryTillmen::SettingsManager.initialize_settings

tillmen_repository_parser = RepositoryTillmen::CommandParser.new(script.vars[1..-1])
tillmen_repository_executor = RepositoryTillmen::CommandExecutor.new(tillmen_repository_parser)
tillmen_repository_executor.execute
