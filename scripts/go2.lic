=begin

   attempts to find the shortest route between any two rooms in the game
   requires a map database (;repository download-mapdb)

   ;go2 help

            author: Tillmen (tillmen@lichproject.org)
   original author: Shaelun
      contributors: Deysh, Doug, Gildaren, Sarvatt, Tysong, Xanlin
              game: any
              tags: core, movement
           version: 2.0.2
          required: Lich >= 4.6.14 
              note: Lich >= 5.4.1 for ;go2 setup and menu functions

   changelog:
      2.0.2 (2022-10-20): Xanlin:
        adjusted wait before exiting 
      2.0.1 (2022-10-08)
        bug fix for non-Gtk users
        backward compatibility for Lich4
      2.0 (2022-10-08): Deysh:
        added setup gui
        added color options to help output
      1.37 (2022-10-07): Xanlin:
        added option to hide room descriptions for travel
        added option to hide room titles for travel
        added option to echo input
        added fallback for check_silvers that uses wealth quiet instead
        wrap in module
        travel time now calculated to a higher precision.
        targets town name now based on location.
        targets won't include towns tagged closed.
      1.36.0 (2022-06-16):
        fix for urchins runners not recognized as command option
        add sos caravan options.
=end
=begin
      1.35 (2022-05-12):
        exit if get-silvers fails to get enough silver from bank.
      1.34 (2022-03-31):
        For DR: add support for yaml-based map stringproc overrides
      1.33 (2022-03-31):
        set UserVars.mapdb_urchins_expire to 0 when expired to fix comparison with nil
      1.32 (2022-03-31):
        Added setting --use-portmasters for UserVars.mapdb_use_portmasters
        Added setting --use-urchins for UserVars.mapdb_use_urchins
        Added location and uid to output list for multiple matched destinations
      1.31 (2022-03-10):
        Merged in DR changes from v1.22f by Sarvatt
      1.30 (2022-03-03):
        Added Util.silver_count to replace check_silvers
        Added support for uid input by prefixing 'u' on a uid number
      1.29 (2022-02-27):
        Added tags for collectibles
      1.28 (2022-01-23):
        Added tags for postoffice and mail
      1.27 (2021-10-29):
        Fix lag check after COMBATANT verb was updated
      1.26 (2020-10-08):
        Fix silver check broken by Commageddon
      1.25 (2019-05-11):
        Fix DragonRealms auto drag feature (Sarvatt)
      1.24 (2019-03-03):
         Updated formatting for ";go2 list" in GSPlat and GSF
      1.23 (2019-03-03):
         add setting for using GSPlat old portal system
      1.22 (2019-02-10):
         add settings for using Chronomage day passes
      1.21 (2017-10-07):
         don't try to stand before swimming movements
      1.20 (2017-09-17):
         add confluence-hot and confluence-cold targets
      1.19 (2016-09-24):
         fix DragonRealms auto drag feature some more
      1.18 (2016-09-24):
         fix DragonRealms auto drag feature somewhat
      1.17 (2016-09-12):
         change portal settings to be saved using UserVars
      1.16 (2016-08-19):
         add fwi-trinket setting
      1.15 (2016-04-01):
         added experimental setting to auto drag in DragonRealms
      1.14 (2015-07-09):
         change ice mode setting to be saved using UserVars
      1.13 (2015-07-09):
         don't search for the confluence if you're already there
      1.12 (2015-07-08):
         don't do a GS lag check in DR
      1.11 (2015-04-13):
         add --instability option
         fix going to a specific room inside the confluence from outside
      1.10 (2015-04-13):
         add confluence and instability targets
      1.9 (2015-02-08):
         stop using Map.tags
      1.8 (2015-01-16):
         fix ";go2 save" bug
      1.7 (2014-12-11):
         added stop-for-dead to the help message
      1.6 (2014-12-10):
         added stop-for-dead option
         add settings to list command
      1.5 (2014-12-04):
         remove a debug message
      1.4 (2014-12-04):
         added delay setting
         fixed bug with finding silver cost of a path
      1.3 (2014-11-09):
         changed typeahead setting to be different for each character
      1.2 (2014-10-16):
         don't use typeaheads for first move: makes it easier to find problems
      1.1 (2014-10-07):
         only automatically reduce typeahead setting if there's a typeahead message in the buffer

=end

# fixme: don't do puzzles option


module Go2
  Go2_version = '2.1'
  
  @@data ||= nil

  def self.data
    @@data
  end

  def self.color(color, msg)
    if defined?(Lich::Messaging)
      Lich::Messaging.msg_format(color, msg) 
    else
      msg
    end
  end

  def self.wealth_quiet();
    wealth_pattern = /^You have (no silver|[,\d]+|but one) coins?/;
    wealth = dothistimeout 'wealth quiet', 3, wealth_pattern;
    coins = 0;
    if wealth.gsub('but one','1') =~ wealth_pattern;
      coins = $1.gsub(',','').to_i;
    end;
    return coins;
  end;

  def self.go2_check_silver;
    if LICH_VERSION.split('.')[0].to_i < 5 or !defined?(Lich::Util.silver_count)
      return self.wealth_quiet
    else
      return Lich::Util.silver_count
    end
  end

  def self.load_go2_settings()
    
    if UserVars.mapdb_buy_day_pass == true
      buy_pass = "on"
    elsif UserVars.mapdb_buy_day_pass == false
      buy_pass = "off"
    else
      buy_pass = UserVars.mapdb_buy_day_pass
    end
      
    settings_hash = {
      :mapdb_car_to_sos      =>UserVars.mapdb_car_to_sos,
      :mapdb_car_from_sos    =>UserVars.mapdb_car_from_sos,
      :mapdb_use_portals     =>UserVars.mapdb_use_portals,
      :mapdb_use_old_portals =>UserVars.mapdb_use_old_portals,
      :mapdb_use_urchins     =>UserVars.mapdb_use_urchins,
      :mapdb_use_portmasters =>UserVars.mapdb_use_portmasters,
      :mapdb_use_day_pass    =>UserVars.mapdb_use_day_pass,
      :mapdb_buy_day_pass    =>buy_pass,
      :mapdb_day_pass_sack   =>UserVars.day_pass_sack,
      :mapdb_ice_mode        =>UserVars.mapdb_ice_mode,
      :mapdb_fwi_trinket     =>UserVars.mapdb_fwi_trinket,
      :rogue_password        =>UserVars.rogue_password,
      :delay                 =>CharSettings['delay'],
      :typeahead             =>CharSettings['typeahead'],
      :stop_for_dead         =>CharSettings['stop for dead'],
      :get_silvers           =>CharSettings['get silvers'],
      :get_return_silvers    =>CharSettings['get return trip silvers'],
      :use_vaalor_shortcut   =>CharSettings['vaalor shortcut'],
      :use_seeking           =>CharSettings['use seeking'],
      :echo_input            =>CharSettings['echo_input'],
      :hide_room_desc        =>CharSettings['hide_room_descriptions'],
      :hide_room_titles      =>CharSettings['hide_room_titles'],
    }
    settings_hash
  end

  def self.load(settings)
    @@data = settings
  end

  def self.save_go2_settings(settings)
   
    UserVars.mapdb_car_to_sos               = settings[:mapdb_car_to_sos]
    UserVars.mapdb_car_from_sos             = settings[:mapdb_car_from_sos]
    UserVars.mapdb_use_portals              = settings[:mapdb_use_portals]
    UserVars.mapdb_use_old_portals          = settings[:mapdb_use_old_portals]
    UserVars.mapdb_use_urchins              = settings[:mapdb_use_urchins]
    UserVars.mapdb_use_portmasters          = settings[:mapdb_use_portmasters]
    UserVars.mapdb_use_day_pass             = settings[:mapdb_use_day_pass]
    UserVars.day_pass_sack                  = settings[:mapdb_day_pass_sack]
    UserVars.mapdb_ice_mode                 = settings[:mapdb_ice_mode]
     
    if settings[:mapdb_buy_day_pass].empty? || settings[:mapdb_buy_day_pass] =~ /off|no|false/
      UserVars.mapdb_buy_day_pass = nil
    elsif settings[:mapdb_buy_day_pass] =~ /on|true|yes/
      UserVars.mapdb_buy_day_pass = true
    else
      settings[:mapdb_buy_day_pass].split(';').each { |location|
        if location !~ /^\s*(?:wl,imt|imt,wl|wl,sol|sol,wl|imt,sol|ill,val|val,ill|ill,cys|cys,ill|val,cys|cys,val)\s*$/i
           echo "warning: Location #{location} is invalid.  Using it anyway."
        end
      }
    
      UserVars.mapdb_buy_day_pass = settings[:mapdb_buy_day_pass]
    end
    
    if settings[:mapdb_fwi_trinket].empty? || UserVars.mapdb_fwi_trinket =~ /^off$/i
      UserVars.mapdb_fwi_trinket = nil
    else
      UserVars.mapdb_fwi_trinket = settings[:mapdb_fwi_trinket]
    end
    
    UserVars.rogue_password                 = settings[:rogue_password]
    CharSettings['delay']                   = settings[:delay]
    CharSettings['typeahead']               = settings[:typeahead]
    CharSettings['stop for dead']           = settings[:stop_for_dead]
    CharSettings['get silvers']             = settings[:get_silvers]
    CharSettings['get return trip silvers'] = settings[:get_return_silvers]
    CharSettings['vaalor shortcut']         = settings[:use_vaalor_shortcut]
    CharSettings['use seeking']             = settings[:use_seeking]
    CharSettings['echo_input']              = settings[:echo_input]
    CharSettings['hide_room_descriptions']  = settings[:hide_room_desc]
    CharSettings['hide_room_titles']        = settings[:hide_room_titles]
  end

  
  if defined?(Gtk)
  # Setup is an extension of Gtk::Builder for Gtk setup
    class Setup < Gtk::Builder

      attr_accessor :settings

      @@categories = {
        general: {
          mapdb_car_to_sos:       { default: false },
          mapdb_car_from_sos:     { default: false },
          mapdb_ice_mode:         { default: false },
          mapdb_use_urchins:      { default: false },
          mapdb_use_portmasters:  { default: false },
          mapdb_use_day_pass:     { default: false },
          mapdb_buy_day_pass:     { default: '' },
          mapdb_day_pass_sack:    { default: '' },
          mapdb_fwi_trinket:      { default: '' },
          mapdb_use_portals:      { default: false },
          mapdb_use_old_portals:  { default: false },
          typeahead:              { default: 0 },
          delay:                  { default: 0 },
          use_vaalor_shortcut:    { default: false },
          get_silvers:            { default: false },
          get_return_silvers:     { default: false },
          hide_room_desc:         { default: false },
          hide_room_titles:       { default: false },
          echo_input:             { default: true },
          use_seeking:            { default: false },
          stop_for_dead:          { default: false },
          rogue_password:         { default: '' },
        }
      }

      def self.get_category(key)
        @@categories.each { |category, data| return category unless data[key].nil? }
        nil
      end

      def self.get_setting(key)
        cat = Setup.get_category(key)
        return nil if cat.nil?
        @@categories[cat].each { |setting, data| return data if setting == key }
        nil
      end

      def initialize(settings)
        super()
        @settings = settings
        # set default values if they don't exist
        @@categories.each do |_, data|
          data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
        end
        # remove settings that doesn't exist
        @settings.delete_if { |key, _| next Setup.get_category(key).nil? }
        # use a GTK Builder to setup all the basics of the window then expand on that base
        return unless defined?(Gtk) && Gtk::Version::MAJOR == 3
        Gtk.queue do
         # add_from_file("#{$data_dir}go2.ui")
          add_from_string(Setup.go2_ui)
          load_settings
          self['main'].keep_above = true
          self['main'].set_title "Go2 Setup v#{Go2_version}"
          # connect signals after settings are loaded to a bunch of handlers don't trigger
          connect_signals { |handler| method(handler) }
        end
      end

      def self.go2_ui
        ui_string = '<?xml version="1.0" encoding="UTF-8"?><interface><requires lib="gtk+" version="3.20"/><object class="GtkAdjustment" id="delay_adjustment"><property name="upper">600</property>
        <property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="type_ahead_adjustment"><property name="upper">100</property>
        <property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkWindow" id="main"><property name="width-request">840</property>
        <property name="height-request">550</property><property name="can-focus">False</property><property name="title" translatable="yes">Go2 Setup</property>
        <signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property>
        <property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property>
        <property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><placeholder/></child><child type="tab"><placeholder/>
        </child><child><placeholder/></child><child type="tab"><placeholder/></child><child><placeholder/></child><child type="tab"><placeholder/></child>
        <child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property>
        <child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property>
        <property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property>
        <property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=5 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property>
        <property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property>
        <child><object class="GtkCheckButton" id="use_seeking"><property name="label" translatable="yes">Use Seeking</property><property name="visible">True</property><property name="can-focus">True</property>
        <property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">6</property><property name="draw-indicator">True</property></object>
        <packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        <property name="halign">end</property><property name="label" translatable="yes">Type Ahead </property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child>
        <child><object class="GtkSpinButton" id="typeahead"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="adjustment">type_ahead_adjustment</property>
        <property name="numeric">True</property><property name="value">-0.021999999999999999</property></object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child>
        <child><object class="GtkCheckButton" id="mapdb_use_urchins"><property name="label" translatable="yes">Use Urchins</property><property name="visible">True</property><property name="can-focus">True</property>
        <property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkSpinButton" id="delay"><property name="visible">True</property>
        <property name="can-focus">True</property><property name="halign">start</property><property name="text" translatable="yes">0</property><property name="adjustment">delay_adjustment</property><property name="numeric">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property>
        <property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Delay</property></object><packing><property name="left-attach">3</property>
        <property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="mapdb_use_portmasters"><property name="label" translatable="yes">Use Portmasters</property>
        <property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property>
        <property name="margin-bottom">7</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child>
        <child><object class="GtkCheckButton" id="get_silvers"><property name="label" translatable="yes">Get Silvers</property><property name="visible">True</property><property name="can-focus">True</property>
        <property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property></object>
        <packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="get_return_silvers"><property name="label" translatable="yes">Get Return Silvers</property>
        <property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property>
        <property name="margin-bottom">7</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child>
        <child><object class="GtkCheckButton" id="hide_room_desc"><property name="label" translatable="yes">Hide Room Desc</property><property name="visible">True</property><property name="can-focus">True</property>
        <property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="hide_room_titles"><property name="label" translatable="yes">Hide Room Titles</property>
        <property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property>
        <property name="margin-bottom">7</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child>
        <child><object class="GtkCheckButton" id="stop_for_dead"><property name="label" translatable="yes">Stop for Dead</property><property name="visible">True</property><property name="can-focus">True</property>
        <property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">6</property><property name="draw-indicator">True</property></object>
        <packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_vaalor_shortcut"><property name="label" translatable="yes">Use Vaalor Shortcut</property>
        <property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property>
        <property name="margin-bottom">6</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child>
        <child><object class="GtkCheckButton" id="echo_input"><property name="label" translatable="yes">Echo Input</property><property name="visible">True</property><property name="can-focus">True</property>
        <property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">6</property><property name="draw-indicator">True</property></object>
        <packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        <property name="halign">end</property><property name="label" translatable="yes">Ice Mode</property></object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child>
        <child><object class="GtkComboBoxText" id="mapdb_ice_mode"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="active">0</property>
        <property name="has-entry">True</property><items><item id="1" translatable="yes">Auto</item><item id="2" translatable="yes">On</item><item id="3" translatable="yes">Off</item></items>
        <child internal-child="entry"><object class="GtkEntry"><property name="can-focus">False</property></object></child></object><packing><property name="left-attach">4</property><property name="top-attach">2</property></packing></child>
        <child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Rogue Password</property></object>
        <packing><property name="left-attach">3</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="rogue_password"><property name="visible">True</property><property name="can-focus">True</property>
        <property name="halign">start</property><property name="width-chars">47</property><property name="placeholder-text" translatable="yes">pull, push,tap...whatever. There should be 7 actions</property></object>
        <packing><property name="left-attach">4</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="mapdb_car_from_sos"><property name="label" translatable="yes">Caravan from SoS</property>
        <property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property>
        <property name="margin-bottom">7</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child>
        <child><object class="GtkCheckButton" id="mapdb_car_to_sos"><property name="label" translatable="yes">Caravan to SoS</property><property name="visible">True</property><property name="can-focus">True</property>
        <property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property></object>
        <packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property>
        <property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property>
        <property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property>
        <property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property>
        <property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        <property name="halign">end</property><property name="margin-start">13</property><property name="label" translatable="yes">FWI Trinket</property></object><packing><property name="left-attach">0</property>
        <property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="mapdb_fwi_trinket"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property>
        <property name="width-chars">47</property><property name="placeholder-text" translatable="yes">name of FWI trinket or \'off\' to stop using it</property></object><packing><property name="left-attach">1</property>
        <property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="mapdb_use_portals"><property name="label" translatable="yes">Use Portals (Plat and Shattered Only)</property>
        <property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property>
        <property name="margin-bottom">7</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property></packing></child>
        <child><object class="GtkCheckButton" id="mapdb_use_old_portals"><property name="label" translatable="yes">Use Old Portals (Plat Only)</property><property name="visible">True</property><property name="can-focus">True</property>
        <property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property></object>
        <packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="mapdb_use_day_pass"><property name="label" translatable="yes">Use Day Pass</property>
        <property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">15</property>
        <property name="margin-bottom">7</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="width">2</property></packing></child>
        <child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">19</property>
        <property name="label" translatable="yes">Day Pass Sack</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child>
        <child><object class="GtkEntry" id="mapdb_day_pass_sack"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="width-chars">47</property></object>
        <packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        <property name="halign">end</property><property name="margin-start">19</property><property name="label" translatable="yes">Buy Day Pass</property></object><packing><property name="left-attach">2</property>
        <property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="mapdb_buy_day_pass"><property name="visible">True</property><property name="can-focus">True</property>
        <property name="tooltip-text" translatable="yes">Buy a Chronomage day pass if you don\'t have an unexpired one. Get Silvers will also need to be turned on if you want to buy one without gold ring credits.  If you only want to buy passes for certain locations, specify the locations like so: wl,imt;imt,wl;imt,sol;ill,val;ill,cys</property>
        <property name="halign">start</property><property name="width-chars">47</property><property name="placeholder-text" translatable="yes">&lt;on|off|locations&gt;</property></object><packing><property name="left-attach">3</property>
        <property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        <property name="label" translatable="yes">Portals and Passes</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child>
        <child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property>
        <child><!-- n-columns=1 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property>
        <property name="row-spacing">10</property><property name="column-spacing">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        <property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property>
        <property name="label" translatable="yes">Custom Targets cannot be done from the UI. Please use the command line</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child>
        <child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property>
        <property name="margin-bottom">5</property><property name="label" translatable="yes">Command line still functions for all options. See help for details.</property></object><packing><property name="left-attach">0</property>
        <property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        <property name="label" translatable="yes">Notes</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property></packing></child></object></child></object></child></object>
        <packing><property name="position">3</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        <property name="label" translatable="yes">General</property></object><packing><property name="position">3</property><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property>
        <property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property>
        <child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property>
        <property name="label" translatable="yes">Changes are only saved if you use the Close button --&gt;</property><attributes><attribute name="style" value="italic"/></attributes></object><packing><property name="expand">False</property>
        <property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property>
        <property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property>
        <property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/></object><packing><property name="expand">False</property>
        <property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property>
        <property name="position">1</property></packing></child></object></child></object></interface>'
      end

      # This is connected to automatically during load_settings and syncs data back to CharSettings.
      def on_update(obj)
        Gtk.queue do
          key = obj.builder_name.to_sym
          setting = Setup.get_setting(key)
          return if setting.nil?

          if obj.class == Gtk::CheckButton
            @settings[key] = obj.active?
          elsif obj.class == Gtk::Entry
            @settings[key] = obj.text.strip
          elsif obj.class == Gtk::SpinButton
            # update from text entry
            obj.update
            # force int, we don't use floats anywhere
            @settings[key] = obj.adjustment.value.to_i
          elsif obj.class == Gtk::ComboBoxText
            @settings[key] = obj.active_text
          end
        end
      end

      def on_close_clicked
        Go2.load(@settings)
        self['main'].destroy
      end

      def on_destroy
        Gtk.queue {   
          Go2.load(@settings)
          @running = false 
        }
      end

      # iterate all objects and for any that match a setting name directly we set the default
      def load_settings
        Gtk.queue do
          # load up the generic settings which are just matching by name of the widget
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)

            key = obj.builder_name.to_sym
            next if (setting = Setup.get_setting(key)).nil?

            # set the default value
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("mapdb_use_portals")) && XMLData.game !~ /^GSPlat|^GSF/
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("mapdb_use_old_portals")) && XMLData.game !~ /^GSPlat/
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("rogue_password")) && Char.prof != "Rogue"
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("use_seeking")) && Society.member !~ /Order of Voln/ && Society.rank !~ /26/

            if obj.class == Gtk::CheckButton
              obj.active = @settings[key]
              obj.signal_connect('toggled') { on_update(obj) }
            elsif obj.class == Gtk::Entry
              obj.text = @settings[key].strip
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::SpinButton
              obj.value = @settings[key]
              obj.adjustment.value = @settings[key]
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::ComboBoxText
              #Fixme: change to builder_name
              if @settings[key] == "Auto"
                item = 0
              elsif @settings[key] == "On"
                item = 1
              elsif @settings[key] == "Off"
                item = 2
              elsif @settings[key] == "1"
                item = 0
              elsif @settings[key] == "2"
                item = 1
              end

              obj.set_active(item) if item
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::TreeView
              if (store = self["#{key}_store"]).nil?
                respond "** failed to find store for treeview #{key}"
                next
              elsif setting[:load].nil?
                respond "** no :load defined #{key}"
                next
              end

              setting[:load].call(store, @settings[key])

              # setup the signals
              if (add = self["#{key}_add"]).nil?
                respond "** failed to find add for treeview #{key}"
                next
              elsif (delete = self["#{key}_delete"]).nil?
                respond "** failed to find delete for treeview #{key}"
                next
              elsif (entry = self["#{key}_entry"]).nil?
                respond "** failed to find entry for treeview #{key}"
                next
              end

              add.signal_connect('clicked') do
                if setting[:set].nil?
                  respond "** no :set defined for #{key}"
                  next
                elsif entry.text.empty?
                  next
                end
                setting[:set].call(store, entry.text, @settings[key])
                setting[:load].call(store, @settings[key])
              end

              delete.signal_connect('clicked') do
                if setting[:delete].nil?
                  respond "** no :delete defined for #{key}"
                  next
                elsif (selected = obj.selection.selected).nil?
                  next
                end
                setting[:delete].call(store, selected, @settings[key])
                setting[:load].call(store, @settings[key])
              end
            end
          end

          # checkboxes for array storage with id's <setting>:<value>
          # this is primarily used by the loot types
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)
            next unless obj.builder_name =~ /^([^:]+):(.*)$/i
            next unless obj.class == Gtk::CheckButton

            key = Regexp.last_match(1).to_sym
            value = Regexp.last_match(2).to_s
           # echo "key: #{key} value: #{value}"
            next if Setup.get_setting(key).nil?
            #echo @settings[key].include?(value)
            obj.active = @settings[key].include?(value)

            # add in hook
            obj.signal_connect('toggled') do
              @settings[key].delete(value)
              if obj.active?
                @settings[key].push(value)
                @settings[key].uniq!.sort!
              end
            end
          end
        end
      end

      def start
        @running = true
        Gtk.queue { self['main'].show_all }
        wait_while { @running }
      end

      def list(cat_to_list: 'all')
        indent_size = 2
        print_array =
          proc do |key, value, indent|
            _respond("#{' ' * indent_size * indent.to_i}#{key}:")
            value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
          end

        print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

        categories = cat_to_list == 'all' ? %w[general internal] : [cat_to_list]
        if $frontend == 'stormfront'
          output = "<output class=\"mono\"/>\n"
        else
          output = String.new
        end
        categories.each do |opt|
          _respond("#{output}") if !output.empty?
          _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
          @@categories[opt.to_sym].each do |id, _|
            value = @settings[id]
            value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
          end
        end
        if $frontend == 'stormfront'
          output = "<output class=\"\"/>\n"
          _respond("#{output}")
        end
      end

      def self.update_setting(key, value)
        setting = Setup.get_setting(key)
        echo "** Setting #{key.inspect} does not exist" if setting.nil?
        action = nil

        if value =~ /^([+-])(.*)$/
          action = Regexp.last_match(1)
          value = Regexp.last_match(2).strip.downcase
        end

        if value == 'reset'
          @settings.delete(key)
          echo" Reset #{key}"
        elsif @settings[key].class == Array
          if value =~ /\d/ && @settings[key][value.to_i]
            @settings[key].delete_at(value.to_i)
          else
            @settings[key].delete(value)
          end

          if action == '-'
            echo " #{value.inspect} removed from #{key.inspect}"
          else
            @settings[key].push(value)
          echo  " #{value.inspect} added to #{key.inspect}"
          end

        echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
        else
          if @settings[key].class == FalseClass || @settings[key].class == TrueClass
            value = value =~ /^true|1|yes|on/ ? true : false
          elsif @settings[key].class == Integer
            value = value.to_i
          end

          echo "#{key.inspect} has been set to #{value.inspect}"
          @settings[key] = value
        end
      end
    end

  end

  setting_value = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  previous = shortest_distances = nil

  UserVars.mapdb_urchins_expire          =     0 if UserVars.mapdb_urchins_expire.nil?
  UserVars.mapdb_car_to_sos              = false if UserVars.mapdb_car_to_sos.nil?
  UserVars.mapdb_car_from_sos            = false if UserVars.mapdb_car_from_sos.nil?
  UserVars.mapdb_ice_mode                = 'auto' if UserVars.mapdb_ice_mode.nil?
  CharSettings['typeahead']              =     0 if CharSettings['typeahead'].nil?
  CharSettings['vaalor shortcut']        = false if CharSettings['vaalor shortcut'].nil?
  CharSettings['get silvers']            = false if CharSettings['get silvers'].nil?
  CharSettings['delay']                  =     0 if CharSettings['delay'].nil?
  CharSettings['stop for dead']          = false if CharSettings['stop for dead'].nil?
  CharSettings['hide_room_descriptions'] = false if CharSettings['hide_room_descriptions'].nil?
  CharSettings['hide_room_titles']       = false if CharSettings['hide_room_titles'].nil?
  CharSettings['echo_input']             = true  if CharSettings['echo_input'].nil?

  
  show_help = proc {
         
     output = []
     output << "<output class='mono'/>"
     output << ""
     output << "   Recent changes are #{Go2.color("yellow","highlighted")}" if defined?(Lich::Messaging)==true
     output << ""
     output << "   #{$lich_char}#{Script.current.name} <target>               Takes you where you want to go using your saved options."
     output << "   #{$lich_char}#{Script.current.name} <options> <target>     Takes you where you want to go, using the given options"
     output << "   #{' '.rjust($lich_char.length + Script.current.name.length)}                             instead of your saved options."
     output << "   #{$lich_char}#{Script.current.name} <options>              Saves the given options."
     output << "   #{Go2.color("yellow","#{$lich_char}#{Script.current.name} setup")}                  Brings up GUI for Lich5 users with most of the commands below"
     output << ""
     output << "   target: "
     output << "      target may be a room number, a custom target, a built-in target,"
     output << "       or part of a room title or room description."
     output << ""
     output << "   options:"
     output << "     --typeahead=<#>                         Sets the number of typeahead lines to use."
     output << "     --delay=<#>                             Sets the delay in seconds between movements"
     output << "                                              (disables typeahead)."
     if XMLData.game =~ /^GS/
        output << "     --get-silvers=<on|off>                  Sets if #{Script.current.name} has permission to access your bank"
        output << "                                              account."
        output << "     --get-return-trip-silvers=<on|off>      Sets if #{Script.current.name} should withdraw enough silvers to"
        output << "                                              return from your destination room to your starting room."
        output << "     --ice-mode=<auto|wait|run>              Sets how #{Script.current.name} should deal with rooms that make"
        output << "                                              you slip and fall."
        output << "     --stop-for-dead=<on|off>                Pauses the script if you pass a dead person."
        output << "     --shortcut=<on|off>                     Sets if the shortcut to Ta'Vaalor should be used."
        output << "                                              (climbing and/or simming needed)"
        output << "     --use-seeking=<on|off>                  Sets if #{Script.current.name} should use Voln symbol of seeking"
        output << "                                              when it will shorten your trip."
        output << "     --use-urchins=<on|off>                  Sets if #{Script.current.name} should use urchin guides"
        output << "                                              when it will shorten your trip."
        output << "     --use-portmasters=<on|off>              Sets if #{Script.current.name} should use portmasters"
        output << "                                              when it will shorten your trip."
        output << "     --use-day-pass=<on|off>                 Use a Chronomage day pass to travel between towns in the"
        output << "                                              same zone if you have one."
        output << "     --buy-day-pass=<on|off|locations>       Buy a Chronomage day pass if you don't have an unexpired"
        output << "                                              one.  get-silvers will also need to be turned on if you"
        output << "                                             want to buy one without gold ring credits.  If you only"
        output << "                                             want to buy passes for certain locations, specify the"
        output << "                                              locations like so:"
        output << "                                              ;go2 --buy-day-pass=wl,imt;imt,wl;imt,sol;ill,val;ill,cys"
        output << "     #{Go2.color("yellow","--hide_room_descriptions=<on|off>")}       When 'on', turns room descriptions off for traveling"
        output << "     #{Go2.color("yellow","--hide_room_titles=<on|off>")}             When 'on', turns room titles off for traveling"
        output << "     #{Go2.color("yellow","--echo_input=<on|off>")}                   When 'on', echos the script input from when the script was called"
        output << "     --day-pass-container=<container name>   Sets the container where you keep your day passes"
        output << "     --instability=<room number>             Use the instability at the given room number to get into"
        output << "                                              the Elementla Confluence instead of finding an attuned one."
        output << "     --fwi-trinket=<trinket name>            Use a FWI trinket to get to/from FWI"
        output << "     --fwi-trinket=<off>                       Stop using a FWI trinket"
        output << "     --caravan-to-sos=<on|off>                 Use the caravan to travel to the Sanctum of Scales"
        output << "     --caravan-from-sos=<on|off>               Use the caravan to travel back from the Sanctum of Scales"
     elsif XMLData.game =~ /^DR/
        output << "     --drag=<name>                           Attempt to automatically drag someone to your destination"
        output << "                                              (this probably won't work)"
     end
     if XMLData.game =~ /^GSPlat|^GSF/
        output << "     --portals=<on|off>                      Sets if portals should be used."
     end
     if XMLData.game =~ /^GSPlat/
        output << "     --old-portals=<on|off>                  Sets if old (dangerous) portals should be used."
        output << "     --portal-pass=<on|off>                  Turn this on if you have a wearable portal pass and don't"
        output << "                                        need a portal ticket."
     end
     output << ""
     output << "   other commands:"
     output << ""
     output << "      #{$lich_char}#{Script.current.name} save new name=<target>      <Saves> a custom target.  target can be the same"
     output << "      #{''.rjust($lich_char.length + Script.current.name.length)}                                as before, or \"current\" for your current room"
     output << "      #{$lich_char}#{Script.current.name} delete custom target        Deletes a saved custom target."
     output << "      #{$lich_char}#{Script.current.name} list                          Shows your settings and custom targets."
     output << "      #{$lich_char}#{Script.current.name} targets                       Shows the built-in targets."
     output << ""
     output << "<output class=''/>"
     output << ""
     
     
    results = []
    output.each{ |line|
      new_line = line
      
      if $frontend =~ /^(?:wizard)$/
        sf_to_wiz(line)
        items = /<output class='mono'\/>|<output class=''\/>/
        new_line = new_line.gsub(items,"")
        new_line = new_line.gsub(/&lt;/,"<")
        new_line = new_line.gsub(/&gt;/,">")      
      else      
        line.scan(/\<[^\]\<]*[^\/]>/).each{ |item| 
          next if item.include?("preset") || 
          new_line = new_line.gsub(item,item.encode(:xml => :text))     
        }     
      end
       
      results.push(new_line)
    }
     
    _respond results 
    
 
  }

  # For Dragonrealms only
  # A change in behavior from Lich4 to Lich5 caused certain ;go2 map wayto movements to fail.
  # This is because of the way the map stringprocs are structured, and the method used to evaluate
  # certain map moves, which involved an arguably dubious overloading of FalseClass on Lich4.
  # The transition to Lich5 makes it necessary to fix some stringprocs as an interim solution, at
  # least until the map can be divested from current owner control and handled appropriately. This code
  # also allows the flexibility to pull custom map wayto overrides from the standard yaml hierarchy.
  if XMLData.game =~ /^DR/
    # Get yaml settings
    settings = get_settings

    # Get base and personal wayto overrides
    base_wayto_overrides = settings.base_wayto_overrides
    personal_wayto_overrides = settings.personal_wayto_overrides

    # Merge the two hashes into a single hash, favoring personal overrides for duplicate keys.
    wayto_overrides = base_wayto_overrides.merge(personal_wayto_overrides)

    # Iterate through the aggregated map wayto overrides from above and set new stringprocs
    wayto_overrides.each do | key, values |
      Map.list[values['start_room'].to_i].wayto["#{values['end_room']}"] = StringProc.new("#{values['str_proc']}")
    end
  end

  change_map_vaalor_shortcut = proc { |use_shortcut|
     unless Map.list.any? { |room| room.timeto.any? { |adj_id,time| time.class == Proc and time._dump =~ /$go2_use_vaalor_shortcut/ } }
        if use_shortcut
           Room[16745].timeto['16746'] = 15
           Room[16746].timeto['16745'] = 15
        else
           Room[16745].timeto['16746'] = 15000
           Room[16746].timeto['16745'] = 15000
        end
     end
  }

  get_silver_cost = proc { |path|
     cost = 0
     path.each_index { |index|
        Room[path[index]].tags.each { |tag|
           if tag =~ /^silver-cost:#{path[index+1]}:(.*)$/
              cost_string = $1
              if cost_string =~ /^[0-9]+$/
                 cost += cost_string.to_i
              else
                 cost += StringProc.new(cost_string).call.to_i
              end
           end
        }
     }
     cost
  }

  update_urchin_expire = proc {
    if UserVars.mapdb_use_urchins
      urchin_status_expires_pattern = /You will have access to the urchin guides until (?<expires>.*?)\./
      result = dothistimeout 'urchin status',3, /You will have access to the urchin guides|You currently have no access to the urchin guides./
      if m=urchin_status_expires_pattern.match(result)
        UserVars.mapdb_urchins_expire = Time.parse(m[:expires].gsub(/(\d+)\/(\d+)\/(\d+) (\d+:\d+:\d+) (.*?)$/, '\3-\1-\2 \4 \5')).to_i
        echo "Urchin expiration successfully updated."
      else
        UserVars.mapdb_urchins_expire = 0;
      end
      if UserVars.mapdb_use_urchins and (UserVars.mapdb_urchins_expire.nil? or UserVars.mapdb_urchins_expire == 0 or Time.now.to_i > UserVars.mapdb_urchins_expire)
        echo "Current settings indicate to use urchins, but your access has expired or is unable to be parsed."
        echo "Disable this check by running ;go2 --use-urchins=off"
      end
    end
  }
  if UserVars.mapdb_use_urchins and (UserVars.mapdb_urchins_expire.nil? or Time.now.to_i > UserVars.mapdb_urchins_expire)
    before_dying { update_urchin_expire.call }
  end

  #
  # check for general commands
  #
  echo "input: #{Script.current.vars[0]}" if CharSettings['echo_input'] == true;

  if Script.current.vars.empty? or Script.current.vars[0].strip =~ /^help$/i
     show_help.call
     exit
  elsif Script.current.vars[0] =~ /^setup$/i
    Setup.new(Go2.load_go2_settings).start
    Go2.save_go2_settings(Go2.data)
    exit
  elsif Script.current.vars[0] =~ /^targets$/i
     echo 'generating list...'
     dr_interesting_tags = ["alchemist", "armorshop", "bakery", "bank", "barbarian", "bard", "boutique", "cleric", "clericshop", "empath", "exchange", "fletcher", "forge", "furrier", "gemshop", "general store", "herbalist", "inn", "locksmith", "moonmage", "movers ", "necromancer", "npchealer", "paladin", "pawnshop", "ranger", "smokeshop", "stable", "thief", "town", "trader", "warmage", "weaponshop"]
     gs_interesting_tags = [ "advguard", "advguard2", "advguild", "advpickup", "alchemist", "armorshop", "bakery", "bank", "bardguild", "boutique", "chronomage", "clericguild", "clericshop", "collectibles", "consignment", "empathguild", "exchange", "fletcher", "forge", "furrier", "gemshop", "general store", "herbalist", "inn", "locksmith pool", "locksmith", "mail", "movers", "npccleric", "npchealer", "pawnshop", "postoffice", "rangerguild", "smokeshop", "sorcererguild", "sunfist", "town", "voln", "warriorguild", "weaponshop", "wizardguild"  ]
     town_list = Map.list.find_all { |room| room.tags.include?('town') and !room.tags.include?('closed')}
     town_ids = town_list.collect { |room| room.id }
     town_hash = Hash.new
     town_ids.each { |id| town_hash[id] = Array.new }
     interesting_tags = (XMLData.game =~ /^DR/ ? dr_interesting_tags : gs_interesting_tags)
     for tag in interesting_tags
        for room in Map.list.find_all { |room| room.tags.include?(tag) }
           if nearest = Room[room.id].find_nearest(town_ids)
              unless town_hash[nearest].any? { |line| line =~ /^ \- #{tag.ljust(17)} / }
                 town_hash[nearest].push " - #{tag.ljust(17)} #{room.title.first.sub(/^\[/, '').sub(/\]$/, '').ljust(34)} - #{room.id.to_s.rjust(5)}"
              end
           end
        end
     end
     output = []
     town_list.each { |town_room|
        output << "---------------------------------------------------------------"
        output << " - town              #{town_room.location.to_s.sub(/^.*?([A-Z].*?)$/,'\1').ljust(34)} - #{town_room.id.to_s.rjust(5)}"
        output << "---------------------------------------------------------------"
        town_hash[town_room.id].sort.each { |target|
           output << target
        }
        output << ""
     }
     if XMLData.game =~ /^DR/
       output << "---------------------------------------------------------------"
       output << " - Known Nexus Rooms"
       output << "---------------------------------------------------------------"
       Map.list.find_all{ |room| room.tags.include?('nexus') }
                        .each{ |room| output << "#{room.title.first.sub(/^\[/, '').sub(/\]$/, '').ljust(45)} - #{room.id.to_s.rjust(5)}" }
     end
     respond output
     exit
  elsif Script.current.vars[0] =~ /^list$/i
     output = []
     output << "settings:"
     output << ""
     output << "            typeahead: #{CharSettings['typeahead']}"
     if (CharSettings['typeahead'] > 0) and (CharSettings['delay'] > 0)
        output << " (not used because delay > 0)"
     end
     output << ""
     output << "                 delay: #{CharSettings['delay']}"
     output << "           get silvers: #{CharSettings['get silvers'] ? 'on' : 'off'}"
     output << "    get return silvers: #{CharSettings['get return trip silvers'] ? 'on' : 'off'}"
     output << "              ice mode: #{UserVars.mapdb_ice_mode}"
     output << "           use seeking: #{CharSettings['use seeking'] ? 'on' : 'off'}"
     output << "           use urchins: #{UserVars.mapdb_use_urchins ? 'on' : 'off'}"
     output << "       use portmasters: #{UserVars.mapdb_use_portmasters ? 'on' : 'off'}"
     output << "          use day pass: #{UserVars.mapdb_use_day_pass ? 'on' : 'off'}"
     output << "          buy day pass: #{UserVars.mapdb_buy_day_pass ? 'on' : 'off'}"
     output << "    day pass container: #{UserVars.day_pass_sack.nil? ? '(not set)' : UserVars.day_pass_sack}"
     output << "hide room descriptions: #{CharSettings['hide_room_descriptions'] ? 'on' : 'off'}"
     output << "      hide room titles: #{CharSettings['hide_room_titles'] ? 'on' : 'off'}"
     output << "            echo input: #{CharSettings['echo_input'] ? 'on' : 'off'}"
     if XMLData.game =~ /^GS/
        output << "         stop for dead: #{CharSettings['stop for dead'] ? 'on' : 'off'}"
        output << "       vaalor shortcut: #{CharSettings['vaalor shortcut'] ? 'on' : 'off'}"
        output << "           FWI trinket: #{UserVars.mapdb_fwi_trinket ? UserVars.mapdb_fwi_trinket : '(not set)'}"
        output << "        caravan to sos: #{UserVars.mapdb_car_to_sos == true ? 'on' : 'off'}"
        output << "      caravan from sos: #{UserVars.mapdb_car_from_sos == true ? 'on' : 'off'}"
     end
     if XMLData.game =~ /^GSPlat|^GSF/
        output << "           use portals: #{(UserVars.mapdb_use_portals == 'yes') ? 'yes' : 'no'}"
     end
     if XMLData.game =~ /^GSPlat/
        output << "       use old portals: #{(UserVars.mapdb_use_old_portals == 'yes') ? 'yes' : 'no'}"
     end
     if XMLData.game =~ /^GSPlat|^GSF/
        output << "      have portal pass: #{(UserVars.mapdb_have_portal_pass == 'yes') ? 'yes' : 'no'}"
     end
     output << ""
     output << "custom targets:"
     output << ""
     for target_name,target_num in GameSettings['custom targets'].sort
        output << "   #{target_name.ljust(20)} = #{target_num.to_s.rjust(5)}   #{Map[target_num].title.first}"
     end
     output << ""
     respond output
     exit
  elsif Script.current.vars[1] =~ /^save/i
     unless Script.current.vars[0] =~ /^save (.+?)=(.+)$/
        echo "error: You're doing it wrong."
        exit
     end
     target_name = $1.strip
     target = $2.strip
     if target_name =~ /^\d+$/
        echo "error: target name can't be just a number."
        exit
     end
     if target =~ /^current$/i
        unless target_room = Map.current
           echo 'error: your current room was not found in the map database.'
           exit
        end
     else
        unless target =~ /^\d+$/ and (target_room = Map[target.to_i])
           unless target_room = Map[target]
              echo "error: could not identify the target room"
              exit
           end
        end
     end
     custom_targets = (GameSettings['custom targets'] || Hash.new)
     custom_targets[target_name] = target_room.id
     GameSettings['custom targets'] = custom_targets
     echo "custom target saved (#{target_name}->#{target_room.id})"
     exit
  elsif Script.current.vars[1] =~ /^delete$/i
     delkey = Script.current.vars[0].sub(/\s*delete\s*/i, '')
     custom_targets = (GameSettings['custom targets'] || Hash.new)
     if kilkey = custom_targets.keys.find { |key| key =~ /^#{delkey}$/i } or kilkey = custom_targets.keys.find { |key| key =~ /^#{delkey}/i }
        custom_targets.delete(kilkey)
        GameSettings['custom targets'] = custom_targets
        echo "custom target deleted (#{kilkey})"
        exit
     else
        echo "#{delkey} does not appear to be a custom target"
        exit
     end
  elsif Script.current.vars[1] =~ /^reload$/i
     Map.reload
     echo  'map data has been reloaded'
     exit
  end

  #
  # target and/or options
  #

  target_search_array             = Array.new
  setting_typeahead               = nil
  setting_delay                   = nil
  setting_disable_confirm         = false
  setting_use_vaalor_shortcut     = nil
  setting_ice_mode                = nil
  setting_fwi_trinket             = nil
  setting_get_silvers             = nil
  setting_use_seeking             = nil
  setting_use_urchins             = nil
  setting_use_portmasters         = nil
  setting_use_day_pass            = nil
  setting_buy_day_pass            = nil
  setting_day_pass_container      = nil
  setting_stop_for_dead           = nil
  setting_get_return_trip_silvers = nil
  setting_have_portal_pass        = nil
  setting_use_portals             = nil
  setting_use_old_portals         = nil
  setting_instability             = nil
  setting_drag                    = nil
  setting_use_caravan_to_sos      = nil
  setting_use_caravan_from_sos    = nil
  setting_hide_room_descriptions  = nil
  setting_hide_room_titles        = nil
  setting_echo_input              = nil

  for var in Script.current.vars[1..-1]
     if var =~ /^(?:\-\-)?typeahead=([0-9]+)$/i
        setting_typeahead = $1.to_i
     elsif var =~ /^(?:\-\-)?delay=([0-9\.]+)$/i
        setting_delay = $1.to_f
     elsif var =~ /^\-\-instability=([0-9]+)$/i
        setting_instability = $1.to_i
     elsif var =~ /^_disable_confirm_$|^--disable-confirm$/i
        setting_disable_confirm = true
     elsif var =~ /^--stop-for-dead$/i
        setting_stop_for_dead = true
     elsif var =~ /^--stop-for-dead=(on|true|yes|off|false|no)/i
        setting_stop_for_dead = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^GS/) and var =~ /^(?:\-\-)?shortcut=(on|true|yes|off|false|no)$/i
        setting_use_vaalor_shortcut = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^GS/) and (var =~ /^(?:\-\-)?ice\-?mode=(auto|wait|run)$/i)
        setting_ice_mode = $1.downcase
     elsif (XMLData.game =~ /^GS/) and (var =~ /^(?:\-\-)?get[_\-]?(?:silver|coin)s?=(on|true|yes|off|false|no)$/i)
        setting_get_silvers = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^GS/) and (var =~ /^(?:\-\-)?use[_\-]?seeking=(on|true|yes|off|false|no)$/i)
        setting_use_seeking = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^GS/) and (var =~ /^(?:\-\-)?use[_\-]?urchins?=(on|true|yes|off|false|no)$/i)
        setting_use_urchins = setting_value[$1.downcase]
    elsif (XMLData.game =~ /^GS/) and (var =~ /^(?:\-\-)?use[_\-]?portmasters?=(on|true|yes|off|false|no)$/i)
        setting_use_portmasters = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^GS/) and (var =~ /^\-\-use[_\-]?day[_\-]?pass=(on|true|yes|off|false|no)$/i)
        setting_use_day_pass = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^GS/) and (var =~ /^\-\-buy[_\-]?day[_\-]?pass=(.+)$/i)
        if setting_value[$1.downcase] == true
           setting_buy_day_pass = true
        elsif setting_value[$1.downcase] == false
           setting_buy_day_pass = false
        else
           setting_buy_day_pass = $1
           setting_buy_day_pass.split(';').each { |location|
              if location !~ /^\s*(?:wl,imt|imt,wl|wl,sol|sol,wl|imt,sol|ill,val|val,ill|ill,cys|cys,ill|val,cys|cys,val)\s*$/i
                 echo "warning: Location #{location} is invalid.  Using it anyway."
              end
           }
        end
     elsif (XMLData.game =~ /^GS/) and (var =~ /^\-\-day[_\-]?pass[_\-]?(?:container|sack)=(.+)$/i)
        setting_day_pass_container = $1
     elsif (XMLData.game =~ /^GS/) and (var =~ /^(?:\-\-)?get\-return\-trip\-silvers=(on|true|yes|off|false|no)$/i)
        setting_get_return_trip_silvers = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^DR/) and (var =~ /^(?:\-\-)?drag=(.+)$/i)
        setting_drag = $1
     elsif (XMLData.game =~ /^GSF|^GSPlat/) and (var =~ /^(?:\-\-)?portals?=(on|true|yes|off|false|no)$/i)
        setting_use_portals = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^GSPlat/) and (var =~ /^(?:\-\-)?old\-portals?=(on|true|yes|off|false|no)$/i)
        setting_use_old_portals = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^GSPlat/) and (var =~ /^(?:\-\-)?portal\-pass=(on|true|yes|off|false|no)$/i)
        setting_have_portal_pass = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^GS/) and (var =~ /^(?:\-\-)?fwi\-?trinket=(.+)$/i)
        setting_fwi_trinket = $1.downcase
     elsif (XMLData.game =~ /^GS/) and (var =~ /^(?:\-\-)?caravan\-?to\-?sos=(on|true|yes|off|false|no)$/i)
      setting_use_caravan_to_sos = setting_value[$1.downcase]
     elsif (XMLData.game =~ /^GS/) and (var =~ /^(?:\-\-)?caravan\-?from\-?sos=(on|true|yes|off|false|no)$/i)
       setting_use_caravan_from_sos = setting_value[$1.downcase]
     elsif (var =~ /^(?:\-\-)?hide[_\-]?(?:room[_\-]?)?descriptions?=(on|true|yes|off|false|no)$/i)
        setting_hide_room_descriptions = setting_value[$1.downcase]
     elsif (var =~ /^(?:\-\-)?hide[_\-]?(?:room[_\-]?)?titles?=(on|true|yes|off|false|no)$/i)
        setting_hide_room_titles = setting_value[$1.downcase]
     elsif (var =~ /^(?:\-\-)?echo[_\-]?input=(on|true|yes|off|false|no)$/i)
        setting_echo_input = setting_value[$1.downcase]
     else
        target_search_array.push(var)
     end
  end
  target_search_string = target_search_array.join(' ')

  #
  # if only settings were given, save the settings and exit
  #
  if target_search_string.empty?
     unless setting_delay.nil?
        CharSettings['delay'] = setting_delay
        echo "delay setting changed to #{setting_delay} seconds"
     end
     unless setting_typeahead.nil?
        CharSettings['typeahead'] = setting_typeahead
        echo "typeahead setting changed to #{setting_typeahead}"
        if CharSettings['delay'].to_f > 0
           echo "typeahead setting will not be used, because the delay setting is greater than zero"
        end
     end
     if XMLData.game =~ /^GSPlat|^GSF/
        unless setting_use_portals.nil?
           UserVars.mapdb_use_portals = (setting_use_portals ? 'yes' : 'no')
           echo "portals will #{'not ' unless setting_use_portals}be used"
        end
     end
     if XMLData.game =~ /^GSPlat/
        unless setting_use_old_portals.nil?
           UserVars.mapdb_use_old_portals = (setting_use_old_portals ? 'yes' : 'no')
           echo "old portals will #{'not ' unless setting_use_old_portals}be used"
        end
        unless setting_have_portal_pass.nil?
           UserVars.mapdb_have_portal_pass = (setting_have_portal_pass ? 'yes' : 'no')
           echo "the script will #{'not ' if setting_have_portal_pass}try to pull out a portal ticket to use portals"
        end
     end
     if XMLData.game =~ /^GS/
        unless setting_use_vaalor_shortcut.nil?
           CharSettings['vaalor shortcut'] = setting_use_vaalor_shortcut
           $go2_use_vaalor_shortcut = setting_use_vaalor_shortcut
           change_map_vaalor_shortcut.call(setting_use_vaalor_shortcut)
           echo "shortcut between Ta'Vaalor and Ta'Illistim will #{'not ' unless setting_use_vaalor_shortcut}be used"
        end
        unless setting_get_silvers.nil?
           CharSettings['get silvers'] = setting_get_silvers
           echo "go2 #{ if setting_get_silvers then 'may' else 'will not' end } withdraw money from your bank account for travel expenses"
        end
        unless setting_use_seeking.nil?
           CharSettings['use seeking'] = setting_use_seeking
           $go2_use_seeking = setting_use_seeking
           echo "go2 #{ if setting_use_seeking then 'may' else 'will not' end } use symbol of seeking for faster travel"
        end
        unless setting_use_urchins.nil?
           UserVars.mapdb_use_urchins = (setting_use_urchins.to_s =~ /on|true|yes/i ? true : false)
           echo "go2 #{ if setting_use_urchins then 'may' else 'will not' end } use urchin guides for faster travel"
        end
        unless setting_use_portmasters.nil?
           UserVars.mapdb_use_portmasters = (setting_use_portmasters.to_s =~ /on|true|yes/i ? true : false)
           echo "go2 #{ if setting_use_portmasters then 'may' else 'will not' end } use portmasters for faster travel"
        end
        unless setting_use_day_pass.nil?
           UserVars.mapdb_use_day_pass = setting_use_day_pass
           echo "go2 #{ if setting_use_day_pass then 'will' else 'will not' end } use Chronomage day passes for faster travel"
        end
        unless setting_buy_day_pass.nil?
           UserVars.mapdb_buy_day_pass = setting_buy_day_pass
           echo 'setting saved' # fixme: be more descriptive
        end
        unless setting_day_pass_container.nil?
           UserVars.day_pass_sack = setting_day_pass_container
           echo 'setting saved' # fixme: be more descriptive
        end
        unless setting_stop_for_dead.nil?
           CharSettings['stop for dead'] = setting_stop_for_dead
           echo "go2 #{ if setting_stop_for_dead then 'will (probably)' else 'will not' end } stop when it sees dead people"
        end
        unless setting_ice_mode.nil?
          echo "go2 ice mode is #{UserVars.mapdb_ice_mode == setting_ice_mode ? 'already' : 'now'} #{setting_ice_mode.inspect}"
          UserVars.mapdb_ice_mode = setting_ice_mode
        end
        unless setting_fwi_trinket.nil?
           trinket_changed = false;
           if setting_fwi_trinket == 'off'
              trinket_changed = true if !UserVars.mapdb_fwi_trinket.nil?;
              UserVars.mapdb_fwi_trinket = nil
           else
              if UserVars.mapdb_trinket != setting_fwi_trinket
                UserVars.mapdb_fwi_trinket = setting_fwi_trinket
                trinket_changed = true;
              end
           end
           echo "mapdb_fwi_trinket is now #{UserVars.mapdb_fwi_trinket.inspect}" if trinket_changed
           echo "mapdb_fwi_trinket unchanged, value is #{UserVars.mapdb_fwi_trinket.inspect}" if !trinket_changed
        end
        unless setting_use_caravan_to_sos.nil?
          UserVars.mapdb_car_to_sos = setting_use_caravan_to_sos
          echo "go2 #{ if setting_use_caravan_to_sos then 'will' else 'will not' end } use the caravan to travel to the Sanctum of Scales"
        end
        unless setting_use_caravan_from_sos.nil?
          UserVars.mapdb_car_from_sos = setting_use_caravan_from_sos
          echo "go2 #{ if setting_use_caravan_from_sos then 'will' else 'will not' end } use the caravan to travel back from the Sanctum of Scales"
        end
        unless setting_get_return_trip_silvers.nil?
           CharSettings['get return trip silvers'] = setting_get_return_trip_silvers
           echo "silvers will #{'not ' unless setting_get_return_trip_silvers}be withdrawn in advance for return trips"
        end
        unless setting_hide_room_descriptions.nil?
           CharSettings['hide_room_descriptions'] = setting_hide_room_descriptions
           echo "go2 #{(setting_hide_room_descriptions ? 'will' : 'will not')} hide room descriptions during travel and turn them on after."
        end
        unless setting_hide_room_titles.nil?
           CharSettings['hide_room_titles'] = setting_hide_room_titles
           echo "go2 #{(setting_hide_room_titles ? 'will' : 'will not')} hide room titles during travel and turn them on after."
        end
        unless setting_echo_input.nil?
           CharSettings['echo_input'] = setting_echo_input
           echo "go2 #{(setting_echo_input ? 'will' : 'will not')} echo input when the script starts"
        end
     end
     exit
  end

  unless start_room = Room.current
     echo 'error: your current room was not found in the map database'
     exit
  end

  #
  # target was given; use saved settings, override them with command line settings, but don't save them
  #
  if setting_drag
     setting_typeahead = 0
  elsif setting_typeahead.nil?
     setting_typeahead = CharSettings['typeahead']
  end

  if setting_delay.nil?
     setting_delay = CharSettings['delay']
  end

  if setting_get_silvers.nil?
     $go2_get_silvers = CharSettings['get silvers']
  else
     before_dying { $go2_get_silvers = CharSettings['get silvers'] }
     $go2_get_silvers = setting_get_silvers
  end

  if setting_use_seeking.nil?
     $go2_use_seeking = CharSettings['use seeking']
  else
     before_dying { $go2_use_seeking = CharSettings['use seeking'] }
     $go2_use_seeking = setting_use_seeking
  end

  unless setting_use_urchins.nil?
     saved_use_urchins = UserVars.mapdb_use_urchins
     before_dying { UserVars.mapdb_use_urchins = saved_use_urchins }
     UserVars.mapdb_use_urchins = setting_use_urchins
  end

  if setting_use_portmasters
     saved_use_portmasters = UserVars.mapdb_use_portmasters
     before_dying { UserVars.mapdb_use_portmasters = saved_use_portmasters }
     UserVars.mapdb_use_portmasters = setting_use_portmasters
  end

  if setting_use_day_pass
     previous_use_day_pass = UserVars.mapdb_use_day_pass
     before_dying { UserVars.mapdb_use_day_pass = previous_use_day_pass }
     UserVars.mapdb_use_day_pass = setting_use_day_pass
  end

  if setting_buy_day_pass
     previous_buy_day_pass = UserVars.mapdb_buy_day_pass
     before_dying { UserVars.mapdb_buy_day_pass = previous_buy_day_pass }
     UserVars.mapdb_buy_day_pass = setting_buy_day_pass
  end

  if setting_day_pass_container
     previous_day_pass_container = UserVars.day_pass_sack
     before_dying { UserVars.day_pass_sack = previous_day_pass_container }
     UserVars.day_pass_sack = setting_day_pass_container
  end

  if setting_stop_for_dead.nil?
     setting_stop_for_dead = CharSettings['stop for dead']
  end

  if setting_ice_mode
     previous_ice_mode = UserVars.mapdb_ice_mode
     before_dying { UserVars.mapdb_ice_mode = previous_ice_mode }
     UserVars.mapdb_ice_mode = setting_ice_mode
  end

  if setting_fwi_trinket
     previous_fwi_trinket = UserVars.mapdb_fwi_trinket
     before_dying { UserVars.mapdb_fwi_trinket = previous_fwi_trinket }
     if setting_fwi_trinket == 'off'
        UserVars.mapdb_fwi_trinket = nil
     else
        UserVars.mapdb_fwi_trinket = setting_fwi_trinket
     end
  end

  unless setting_use_portals.nil?
     previous_use_portals = UserVars.mapdb_use_portals
     before_dying { UserVars.mapdb_use_portals = previous_use_portals }
     UserVars.mapdb_use_portals = (setting_use_portals ? 'yes' : 'no')
  end

  unless setting_use_old_portals.nil?
     previous_use_old_portals = UserVars.mapdb_use_old_portals
     before_dying { UserVars.mapdb_use_old_portals = previous_use_old_portals }
     UserVars.mapdb_use_old_portals = (setting_use_old_portals ? 'yes' : 'no')
  end

  unless setting_have_portal_pass.nil?
     previous_have_portal_pass = UserVars.mapdb_have_portal_pass
     before_dying { UserVars.mapdb_have_portal_pass = previous_have_portal_pass }
     UserVars.mapdb_have_portal_pass = (setting_have_portal_pass ? 'yes' : 'no')
  end

  if setting_use_vaalor_shortcut.nil?
     setting_use_vaalor_shortcut = CharSettings['vaalor shortcut']
  else
     before_dying { $go2_use_vaalor_shortcut = CharSettings['vaalor shortcut'] }
  end
  $go2_use_vaalor_shortcut = setting_use_vaalor_shortcut

  unless setting_use_caravan_to_sos.nil?
    previous_caravan_to_sos = UserVars.mapdb_car_to_sos
    before_dying { UserVars.mapdb_car_to_sos = previous_caravan_to_sos }
    UserVars.mapdb_car_to_sos = setting_use_caravan_to_sos
  end

  unless setting_use_caravan_from_sos.nil?
    previous_caravan_from_sos = UserVars.mapdb_car_from_sos
    before_dying { UserVars.mapdb_car_from_sos = previous_caravan_from_sos }
    UserVars.mapdb_car_from_sos = setting_use_caravan_from_sos
  end

  if setting_get_return_trip_silvers.nil?
     setting_get_return_trip_silvers = CharSettings['get return trip silvers']
  end

  if XMLData.game =~ /^GS/
     change_map_vaalor_shortcut.call(setting_use_vaalor_shortcut)
  end

  #
  # find target
  #
  if defined?(Map.ids_from_uid)
    uid_pattern = /u(?<uid>\d+)/
    if m = uid_pattern.match(target_search_string)
      uid = m[:uid].to_i
      lookup_id = Map.ids_from_uid(uid)
      if lookup_id.size > 0
         target_search_string = "#{lookup_id[0]}"
       end
    end
  end
  if (target_search_string =~ /^[0-9]+$/) or (XMLData.game =~ /^GS/ and target_search_string =~ /^confluence(?:\-hot|\-cold)?$|^instability$/i)
     if target_search_string =~ /^[0-9]+$/
        unless destination = Map[target_search_string.to_i]
           echo "error: room number (#{target_search_string}) was not found in the map database"
           exit
        end
        confirm = false
     end
     if (target_search_string =~ /^confluence(?:\-hot|\-cold)?$|^instability$/i) or (XMLData.game =~ /^GS/ and destination.title.first == '[Elemental Confluence]' and XMLData.room_title != '[Elemental Confluence]')
        if target_search_string =~ /^confluence$/ and XMLData.room_title == '[Elemental Confluence]'
           echo "you're already here..."
           exit
        end
        town_ids          = [ 228, 2300, 1438, 1005, 188, 1932, 3519, 10855, 3668 ]
        found_instability = false
        if setting_instability
           Script.run('go2', setting_instability.to_s, :force => true)
           if GameObj.loot.any? { |o| o.noun == 'instability' }
              $mapdb_last_instability = Room.current.id
              $mapdb_instability_timeto = Hash.new
              for id in town_ids
                 path = Room[$mapdb_last_instability].path_to(id)
                 if path.nil?
                    $mapdb_instability_timeto[id] = nil
                 else
                    $mapdb_instability_timeto[id] = Map.estimate_time(path)
                 end
              end
              found_instability = true
           end
        else
           if CharSettings['element'].nil?
              r = dothistimeout 'attune', 5, /^\s*You are attuned to the Element of|^\s*ATTUNE SET/
              if r =~ /You are attuned to the Element of (.+)\./
                 CharSettings['element'] = $1.downcase
              elsif r =~ /ATTUNE SET/
                 echo "You're not attuned to an element, so I don't know how to find an instability."
                 exit
              else
                 echo "error: can't get right"
                 exit
              end
           end

           GameSettings['recent-instabilities'] ||= Array.new

           good_room_ids     = Array.new
           bad_room_ids      = Array.new
           got_room_text     = false
           to_element        = { 'gust of wind' => 'air', 'burst of sparks' => 'lightning', 'waft of heat' => 'fire', 'puff of rock dust' => 'earth', 'puff of mist' => 'water', }

           check_instability = proc {
              if GameObj.loot.any? { |o| o.noun == 'instability' }
                 r = dothistimeout 'look instability', 10, /^The air is oddly warped and distorted here, almost as if something unseen was trying to push through from the other side of an invisible barrier\.  Every so often a (?:gust of wind|burst of sparks|waft of heat|puff of rock dust|puff of mist) (?:is|are) emitted from the anomaly, which quickly reseals itself\./
                 if r =~ /(gust of wind|burst of sparks|waft of heat|puff of rock dust|puff of mist)/
                    element = to_element[$1]
                    unless GameSettings['recent-instabilities'].any? { |i| (i[:room_id] == Room.current.id) and i[:element] == element }
                       GameSettings['recent-instabilities'].push(:room_id => Room.current.id, :element => element, :first_seen => Time.now.to_i)
                    end
                    if (element == CharSettings['element'])
                       $mapdb_last_instability = Room.current.id
                       $mapdb_instability_timeto = Hash.new
                       for id in town_ids
                          path = Room[$mapdb_last_instability].path_to(id)
                          if path.nil?
                             $mapdb_instability_timeto[id] = nil
                          else
                             $mapdb_instability_timeto[id] = Map.estimate_time(path)
                          end
                       end
                       found_instability = true
                    end
                 else
                    echo "error: can't get right"
                    exit
                 end
              else
                 GameSettings['recent-instabilities'].delete_if { |i| i[:room_id] == Room.current.id }
                 false
              end
           }

           #
           # go directly to nearby recently seen attuned instabilities
           #
           GameSettings['recent-instabilities'].delete_if { |i| i[:first_seen] < (Time.now.to_i - 21600) }
           GameSettings['recent-instabilities'].find_all { |i| i[:element] == CharSettings['element'] }.each { |i|
              # fixme: would one full dijkstra be faster?
              if (path = Room.current.path_to(i[:room_id])) and (Map.estimate_time(path) <= 10.0)
                 Script.run('go2', i[:room_id].to_s, :force => true)
                 break if check_instability.call
              end
           }

           #
           # get room numbers from attune sense
           #
           unless found_instability
              if (last_roomdesc = $_SERVERBUFFER_.reverse.find { |line| line =~ /<style id="roomDesc"\/>/ }) and (last_roomdesc =~ /<style id="roomDesc"\/></)
                 set_desc = true
              else
                 set_desc = false
              end

              2.times {
                 put 'set description on' if set_desc
                 sense_result = dothistimeout 'attune sense', 5, /^You sense nothing unusual\.|^You sense an unusual fluctuation emanating from .+\.|^You feel your senses being pulled towards a strong fluctuation\.\.\.|^You feel a strong sense of instability surround you!/
                 put 'set description off' if set_desc
                 if sense_result =~ /^You sense an unusual fluctuation emanating from (.+)\./
                    location = $1
                    bad_room_ids = Room.list.find_all { |r| r.location == location }.collect { |r| r.id }
                 elsif sense_result =~ /^You feel your senses being pulled towards a strong fluctuation\.\.\./
                    location = Room.current.location
                    room_text = Array.new
                    3.times { room_text.push(get) }
                    good_room_ids = Room.list.find_all { |r| r.title.include?(room_text[0]) and r.desc.include?(room_text[1]) and r.paths.include?(room_text[2]) and r.location == location }.collect { |r| r.id }
                    if good_room_ids.empty?
                       desc_regex = /#{Regexp.escape(room_text[1]).gsub(/\\\.(?:\\\.\\\.)?/, '|')}/
                       good_room_ids = Room.list.find_all { |r| r.title.include?(room_text[0]) and r.paths.include?(room_text[2]) and r.location == location and r.desc.any? { |d| d =~ desc_regex } }.collect { |r| r.id }
                    end
                    got_room_text = true
                    Room.list.find_all { |r| r.location == location }.each { |r| bad_room_ids.push(r.id) unless good_room_ids.include?(r.id) }
                 elsif sense_result =~ /^You feel a strong sense of instability surround you!/
                    location = Room.current.location
                    good_room_ids = [ Room.current.id ]
                    Room.list.find_all { |r| r.location == location }.each { |r| bad_room_ids.push(r.id) unless good_room_ids.include?(r.id) }
                 elsif sense_result =~ /^You sense nothing unusual\./
                    echo "error: can't get right"
                    exit
                 else
                    echo "error: unrecognized result from \"attune sense\""
                    exit
                 end

                 while (line = get?)
                    if line =~ /^You sense an unusual fluctuation emanating from (.+)\./
                       location = $1
                       Room.list.find_all { |r| r.location == location }.each { |r| bad_room_ids.push(r.id) unless bad_room_ids.include?(r.id) or good_room_ids.include?(r.id) }
                    elsif sense_result =~ /^You feel your senses being pulled towards a strong fluctuation\.\.\./
                       location = Room.current.location
                       room_text = Array.new
                       3.times { room_text.push(get) }
                       gri = Room.list.find_all { |r| r.title.include?(room_text[0]) and r.desc.include?(room_text[1]) and r.paths.include?(room_text[2]) and r.location == location }.collect { |r| r.id }
                       if gri.empty?
                          desc_regex = /#{Regexp.escape(room_text[1]).gsub(/\\\.(?:\\\.\\\.)?/, '|')}/
                          gri = Room.list.find_all { |r| r.title.include?(room_text[0]) and r.paths.include?(room_text[2]) and r.location == location and r.desc.any? { |d| d =~ desc_regex } }.collect { |r| r.id }
                       end
                       gri.each { |i| good_room_ids.push(i) unless good_room_ids.include?(i) }
                       got_room_text = true
                       Room.list.find_all { |r| r.location == location }.each { |r| bad_room_ids.push(r.id) unless bad_room_ids.include?(r.id) or good_room_ids.include?(r.id) }
                    elsif sense_result =~ /^You feel a strong sense of instability surround you!/
                       location = Room.current.location
                       good_room_ids.push(Room.current.id) unless good_room_ids.include?(Room.current.id)
                       Room.list.find_all { |r| r.location == location }.each { |r| bad_room_ids.push(r.id) unless bad_room_ids.include?(r.id) or good_room_ids.include?(r.id) }
                    else
                       break
                    end
                 end
                 waitrt?
                 break if got_room_text or (good_room_ids.count > 0)
                 Script.run('go2', Room.current.find_nearest(bad_room_ids).to_s, :force => true)
              }

              #
              # go to rooms and junk
              #
              loop {
                 next_id = nil
                 next_id = Room.current.find_nearest(good_room_ids) unless good_room_ids.empty?
                 if next_id.nil?
                    next_id_list = bad_room_ids.find_all { |r| GameSettings['recent-instabilities'].any? { |i| (i[:room_id] == r) and (i[:element] == CharSettings['element']) } }
                    next_id = Room.current.find_nearest(next_id_list) unless next_id_list.empty?
                 end
                 if next_id.nil?
                    next_id = (Room.current.wayto.keys.find { |k| bad_room_ids.include?(k) } || Room.current.find_nearest(bad_room_ids))
                 end
                 if next_id.nil?
                    echo 'fail'
                    exit
                 end
                 if Room.current.wayto.keys.include?(next_id.to_s)
                    way = Room.current.wayto[next_id.to_s]
                    if way.class == Proc
                       way.call
                    elsif way.class == String
                       move way
                    else
                       echo "error: map database movement is neither a Proc or a String"
                       exit
                    end
                 else
                    Script.run('go2', next_id.to_s, :force => true)
                 end
                 good_room_ids.delete(next_id)
                 bad_room_ids.delete(next_id)
                 break if check_instability.call
              }
           end
        end
        if found_instability
           if target_search_string == 'instability'
              exit
           elsif target_search_string == 'confluence'
              put 'unhide' if invisible?
              move 'push instability with my soulstone'
              exit
           elsif target_search_string == 'confluence-hot'
              put 'unhide' if invisible?
              move 'push instability with my soulstone'
              exit if Room.current.tags.any? { |t| t =~ /^huge (?:fire|lava|steam|lightning) elemental$/ }
              if hot_id = Room.current.wayto.keys.find { |r| Room[r].tags.any? { |t| t =~ /^huge (?:fire|lava|steam|lightning) elemental$/ } }
                 begin
                    go_thread = Thread.new { Room.current.wayto[hot_id].call }
                    sleep 0.1 until Room.current.tags.any? { |t| t =~ /^huge (?:fire|lava|steam|lightning) elemental$/ }
                 ensure
                    go_thread.kill rescue nil
                 end
              end
              exit
           elsif target_search_string == 'confluence-cold'
              put 'unhide' if invisible?
              move 'push instability with my soulstone'
              exit if Room.current.tags.any? { |t| t =~ /^huge (?:air|earth|ice|water) elemental$/ }
              if cold_id = Room.current.wayto.keys.find { |r| Room[r].tags.any? { |t| t =~ /^huge (?:air|earth|ice|water) elemental$/ } }
                 begin
                    go_thread = Thread.new { Room.current.wayto[cold_id].call }
                    sleep 0.1 until Room.current.tags.any? { |t| t =~ /^huge (?:air|earth|ice|water) elemental$/ }
                 ensure
                    go_thread.kill rescue nil
                 end
              end
              exit
           else
              put 'unhide' if invisible?
              move 'push instability with my soulstone'
              sleep 0.3
              unless start_room = Room.current
                 echo 'error: your current room was not found in the map database'
                 exit
              end
           end
        else
           echo 'error: all hope is lost'
           exit
        end
     end
  elsif (custom_targets = GameSettings['custom targets']) and (target = custom_targets.keys.find { |key| key =~ /^#{target_search_string}$/i }) or (target = custom_targets.keys.find { |key| key =~ /^#{target_search_string}/i })
     destination_id = custom_targets[target]
     unless destination = Map[destination_id]
        echo "error: custom target (#{destination_id}) was not found in the map database"
        exit
     end
     confirm = false
  elsif Map.list.any? { |r| r.tags.include?(target_search_string) }
     target_list = Map.list.find_all { |room| room.tags.include?(target_search_string) }.collect { |room| room.id }
     if target_list.empty?
        echo 'fixme (1)'
        exit
     end
     if target_list.include?(start_room.id)
        echo "you're already here..."
        exit
     end
     previous, shortest_distances = start_room.dijkstra(target_list)
     target_list.delete_if { |room_id| shortest_distances[room_id].nil? }
     if target_list.empty?
        echo 'fixme (2)'
        exit
     end
     target_id = target_list.sort { |a,b| shortest_distances[a] <=> shortest_distances[b] }.first
     unless target_id and (destination = Map[target_id])
        echo 'fixme (3)'
        exit
     end
     if shortest_distances[destination.id] < 20
        confirm = false
     else
        confirm = true
     end
  else
     chkre = /#{target_search_string.sub(/\.$/, '').gsub(/\.(?:\.\.)?/, '|')}/i
     chk = /#{Regexp.escape(target_search_string.strip)}/i
     room_list = Map.list.find_all { |room| room.title.find { |title| title =~ chk } or room.description.find { |desc| desc =~ chk } or room.description.find { |desc| desc =~ chkre } }
     if room_list.nil? or room_list.empty?
        echo 'no matching rooms found'
        exit
     end
     if room_list.length == 1
        destination = room_list.first
        confirm = true
     else
        destination = nil
        first = 1
        show_size = 20
        respond "#{room_list.length} matching rooms found:"
        while first < room_list.length
           respond
           for which in (first)..([(first+show_size-1),room_list.length].min)
              if XMLData.game =~ /^DR/
                 respond "#{(which).to_s.rjust(5)}: #{room_list[which-1].title.first.ljust(37)} (#{room_list[which-1].id})"
              else
                 respond "#{(which).to_s.rjust(5)}: #{room_list[which-1].title.first.ljust(37)} (#{room_list[which-1].id}) #{room_list[which-1].location.to_s.gsub(/(^ *the *)?(town|hamlet|city|village|plains|free port|lowlands|tunnels and caverns|foothills|holdings|southern part|northern slopes|northern reaches|environs|somewhere)?( o[fn] )?|,.*$/i,"")}  %s" % [ room_list[which-1].uid[0..2] ]
              end
           end
           respond
           respond "select a room (;send <#{first}-#{[first+show_size-1,room_list.length].min}>)#{ " or ';send next' for more" if (first+show_size-1) < room_list.length}"
           respond
           clear
           line = nil
           line = get until line.strip =~ /^[0-9]+$|^next$/i
           if line =~ /^next$/
              first += show_size
           else
              destination = room_list[line.to_i-1]
              break
           end
        end
        unless destination
           echo 'no more rooms match'
           exit
        end
        confirm = false
     end
  end

  if setting_stop_for_dead and (setting_typeahead > 0) and (setting_delay <= 0)
     $go2_see_dead_people = false
     exec_string = "
        hide_me
        status_tags
        parent_id = #{Script.self.object_id}
        Thread.new { loop { sleep 3; Script.self.kill unless Script.running.any? { |s| s.object_id == parent_id } or Script.hidden.any? { |s| s.object_id == parent_id } } }
        while (line = get)
           if line =~ /<compDef id='room players'>Also here:.*? the body of </
              $go2_see_dead_people = true
           end
        end
     "
     start_exec_script(exec_string, flags={ :quiet => true })
  end


  #
  # before moving
  #
  look_after = false
  if setting_hide_room_descriptions == true or (setting_hide_room_descriptions.nil? and CharSettings['hide_room_descriptions'] == true)
    put 'flag description off'
    look_after = true
    before_dying { put 'flag description on'}
  end
  if setting_hide_room_titles == true or (setting_hide_room_titles.nil? and CharSettings['hide_room_titles'] == true)
    put 'flag roomnames off'
    look_after = true
    before_dying { put 'flag roomnames on';}
  end
  before_dying { put 'look'} if look_after == true;

  #
  # move
  #
  if start_room.id == destination.id
     echo "you're already here..."
     exit
  end

  start_time   = nil
  error_count  = 0
  $go2_restart = false
  first_move   = true

  loop {

     moves_sent = $room_count

     if $go2_restart
        first_move = true
        break if Room.current.id == destination.id
        echo 'restarting script...'
        if error_count > 1
           if XMLData.game =~ /^GS/
              dothistimeout 'help lag-check', 5, /^No help files matching that entry were found\./
           else
              sleep 5
           end
        end
        unless start_room = Map.current
           echo 'error: your current room was not found in the map database'
           exit
        end
        previous, shortest_distances = Map.dijkstra(start_room.id, destination.id)
     end

     unless previous and shortest_distances
        previous, shortest_distances = Map.dijkstra(start_room.id, destination.id)
     end
     unless previous[destination.id]
        echo "error: failed to find a path between your current room (#{start_room.id}) and destination room (#{destination.id})"
        exit
     end
     path = [ destination.id ]
     path.push(previous[path[-1]]) until previous[path[-1]].nil?
     path.reverse!
     est_time = shortest_distances[destination.id]
     previous = shortest_distances = nil
     if Script.running?('roomnumbers')
       rooms = [Room.current.id] + path
       if rooms.any? { |room| Room[room].tags.first.include?('peer') }
         stop_script('roomnumbers')
         before_dying { start_script('roomnumbers') } unless Room[rooms.last].tags.first.include?('peer')
       end
     end

     if Script.running?('textsubs') && est_time > 5
       stop_script('textsubs')
       before_dying { start_script('textsubs') }
     end

     if XMLData.game =~ /^GS/
        needed_silvers = get_silver_cost.call(path)
        if setting_get_return_trip_silvers
           return_previous, return_shortest_distances = Map.dijkstra(destination.id, start_room.id)
           return_path = [ start_room.id ]
           return_path.push(return_previous[return_path[-1]]) until return_previous[return_path[-1]].nil?
           return_path.reverse!
           return_previous = return_shortest_distances = nil
           needed_silvers += get_silver_cost.call(return_path)
           return_path = nil
        end
        if needed_silvers > 0
           current_silvers = self.go2_check_silver()
           if needed_silvers > current_silvers
              if $go2_get_silvers
                 unless bank_id = Room.current.find_all_nearest_by_tag('bank').find { |room_id| current_silvers >= get_silver_cost.call(Room.current.path_to(room_id)) }
                    echo "error: You're too poor to go to the bank."
                    exit
                 end
                 pr, s = Map.dijkstra(Room.current.id, bank_id)
                 est_time = s[bank_id]
                 pr = s = nil
                 pr, s = Map.dijkstra(bank_id, destination.id)
                 est_time += s[destination.id]
                 pr = s = nil
                 unless setting_disable_confirm or not confirm
                    confirm = false
                    respond "ETA: #{(est_time/60.0).as_time}.  #{path.length-1} (wrong) rooms between this room (#{start_room.id}), the bank (#{bank_id}), and:"
                    respond destination.to_s + "\n\nTo go here, unpause the script.  To abort, kill the script."
                    pause_script
                 end
                 if $go2_started_go2_bank
                    echo "You're too poor to go to the bank."
                    exit
                 end
                 begin
                    $go2_started_go2_bank = true
                    go2_count = Script.running.find_all { |s| s.name == Script.current.name }.length
                    force_start_script Script.current.name, [ bank_id.to_s ]
                    wait_until { Script.running.find_all { |s| s.name == Script.current.name }.length <= go2_count }
                 ensure
                    $go2_started_go2_bank = false
                 end
                 unless start_room = Room.current
                    echo 'error: your current room was not found in the map database'
                    exit
                 end
                 moves_sent = $room_count
                 previous, shortest_distances = Map.dijkstra(start_room.id, destination.id)
                 unless previous[destination.id]
                    echo "error: failed to find a path between your current room (#{start_room.id}) and destination room (#{destination.id})"
                    exit
                 end
                 path = [ destination.id ]
                 path.push(previous[path[-1]]) until previous[path[-1]].nil?
                 path.reverse!
                 est_time = shortest_distances[destination.id]
                 previous = shortest_distances = nil
                 needed_silvers = get_silver_cost.call(path)
                 if setting_get_return_trip_silvers
                    return_previous, return_shortest_distances = Map.dijkstra(destination.id, start_room.id)
                    return_path = [ start_room.id ]
                    return_path.push(return_previous[return_path[-1]]) until return_previous[return_path[-1]].nil?
                    return_path.reverse!
                    return_previous = return_shortest_distances = nil
                    needed_silvers += get_silver_cost.call(return_path)
                    return_path = nil
                 end
                 fput 'unhide' if hidden? or invisible?
                 if XMLData.room_title == '[Pinefar, Depository]'
                    fput "ask banker for #{[(needed_silvers - self.go2_check_silver()), 20].max} silvers"
                 else
                    fput "withdraw #{needed_silvers - self.go2_check_silver()} silvers"
                 end
                 if self.go2_check_silver() < needed_silvers
                    echo "You are too poor to make this trip."
                    echo "Not enough silver in current area's bank."
                    exit
                 end
              else
                 echo "You are too poor to make this trip."
                 echo "To give go2 permission to take your monies, type ;go2 getsilvers=on"
                 echo "Continuing anyway in 10 seconds..."
                 sleep 10
              end
           end
        end
     end

     if setting_disable_confirm or $go2_restart or not confirm
        echo "ETA: #{(est_time/60.0).as_time} (#{path.length-1} rooms to move through)"
     else
        respond "ETA: #{(est_time/60.0).as_time}.  #{path.length-1} rooms between this room (#{start_room.id}) and:"
        respond destination.to_s + "\n\nTo go here, unpause the script.  To abort, kill the script."
        pause_script
     end

     start_time = Time.now unless $go2_restart

     $go2_restart = false

     path.each_index { |idx|
        room = Map[path[idx]]
        next_id = (path[idx + 1] || break).to_s

        exit if dead?
        wait_while { muckled? }
        unless standing? or (room.wayto[next_id].inspect =~ /swim/i)
          waitrt?
          fput 'stand'
          sleep 0.2
          if checkrt > 0
            waitrt?
            sleep 0.5
          end
        end
        waitrt?

        if room.wayto[next_id].class == Proc
           if setting_drag
              echo "error: drag feature can't deal with StringProc movements yet"
              exit
           end
           # echo 'proc: ' + room.id.to_s + ' -> ' + next_id.to_s
           if (setting_typeahead > 0) and (setting_delay <= 0)
              50.times {
                 break if ($room_count >= moves_sent)
                 sleep 0.05
              }
              if setting_stop_for_dead and $go2_see_dead_people
                 $go2_restart = true
                 10.times {
                    break if GameObj.pcs.any? { |pc| pc.status =~ /dead/ }
                    idx -= 1
                    break unless (way = Room.current.wayto[path[idx].to_s])
                    if way.class == Proc
                       way.call
                    else
                       move way
                    end
                 }
                 pause_script
                 $go2_see_dead_people = false
                 break
              end
              unless ($room_count >= moves_sent)
                 if $_SERVERBUFFER_.any? { |line| line =~ /Sorry, you may only type ahead/ }
                    echo 'reducing typeahead setting...'
                    setting_typeahead -= 1
                 end
                 $go2_restart = true
                 break
              end
           end
           begin
              room_id_before_proc = Room.current.id
              room.wayto[next_id].call
              sleep setting_delay
              pause_script if setting_stop_for_dead and GameObj.pcs.any? { |pc| pc.status =~ /dead/ }
              # $go2_restart = true if Room.current.id == room_id_before_proc
              break if $go2_restart
           rescue
              respond "--- error running mini-script: #{room.id} -> #{next_id}"
              respond $!
              exit
           end
           moves_sent = $room_count
        else
           if (setting_typeahead > 0) and (setting_delay <= 0) and not first_move
              time = Time.now + 3
              moves = moves_sent - setting_typeahead
              loop {
                 break if ($room_count >= moves) or (Time.now > time)
                 sleep 0.02
              }
              if setting_stop_for_dead and $go2_see_dead_people
                 $go2_restart = true
                 50.times {
                    break if ($room_count >= moves_sent)
                    sleep 0.05
                 }
                 10.times {
                    break if GameObj.pcs.any? { |pc| pc.status =~ /dead/ }
                    idx -= 1
                    break unless (way = Room.current.wayto[path[idx].to_s])
                    if way.class == Proc
                       way.call
                    else
                       move way
                    end
                 }
                 pause_script
                 $go2_see_dead_people = false
                 break
              end
              unless ($room_count + setting_typeahead) >= moves_sent
                 if $_SERVERBUFFER_.any? { |line| line =~ /Sorry, you may only type ahead/ }
                    echo 'reducing typeahead setting...'
                    setting_typeahead -= 1
                 end
                 $go2_restart = true
                 break
              end
              put room.wayto[next_id]
              moves_sent += 1
           else
              first_move = false
              moves_sent += 1
              if setting_drag
                 way = room.wayto[next_id]
                 if way =~ /^(north|northeast|east|southeast|south|southwest|west|northwest|n|ne|e|se|s|sw|w|nw|up|u|down|d|out)$/i
                    way = "drag #{setting_drag} #{way}"
                    result = move way
                 elsif way =~ /^(?:go|climb) /i
                    way = way.sub(/^(?:go|climb) /i, "drag #{setting_drag} ")
                    result = move way
                 else
                    echo "error: drag feature doesn't know how to deal with this movement: #{way}"
                    exit
                 end
              else
                 result = move room.wayto[next_id]
              end
              sleep setting_delay
              pause_script if setting_stop_for_dead and GameObj.pcs.any? { |pc| pc.status =~ /dead/ }
              unless result
                 error_count += 1
                 if (idx == 0) and (error_count > 2) and (Room.current.id == room.id)
                    echo "changing Room[#{room.id}].timeto['#{next_id}'] to nil"
                    old_room = room
                    old_next_id = next_id
                    old_timeto = room.timeto[next_id]
                    before_dying {
                       echo "reverting Room[#{old_room.id}].timeto['#{old_next_id}'] back to #{old_timeto.inspect}"
                       old_room.timeto[old_next_id] = old_timeto
                    }
                    room.timeto[next_id] = nil
                 end
                 $go2_restart = true
                 break
              end
           end
        end
        waitrt?
        if $go2_cast and Spell[515].active? and (checkprep == Spell[402].name) and Spell[402].affordable?
           Spell[402].cast
        end
     }

     if (setting_typeahead > 0) and (setting_delay <= 0)
        50.times {
           break if ($room_count >= moves_sent)
           sleep 0.05
        }
        unless $room_count >= moves_sent
           $go2_restart = true
        end
     end

     break unless $go2_restart
  }

  timeout = Time.now + 1
  while Room.current.id != destination.id and Time.now < timeout
    sleep 0.05 if Room.current.id != destination.id
  end
  end_time = Time.now
  travel_time = (end_time.to_r - start_time.to_r).to_f / 60
  echo "travel time: #{sprintf("%d:%02d:%06.3f", travel_time.truncate, travel_time.truncate % 60, ((travel_time % 1) * 60).round(3))}"
end
