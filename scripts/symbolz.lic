=begin
  Voln
  Tool Tips will display Mana and Stamina costs to cast

  ;symbolz setup for configuration

  author: Elanthia-Online (GTK updates)
  original author: Ifor Get
  contributing authors: SpiffyJr, Tillmen
  game: Gemstone
  tags: Voln, Symbols, Society
  required: Lich >= 5.9.0
  version: 2.0.0

  changelog:
    2.0.0 (2025-10-13):
      Refactored for proper OOP architecture
      Improved separation of concerns
      Enhanced error handling
      Modernized Ruby idioms
      Convert to module structure with Symbolz namespace
      Replace CharSettings with YAML file storage
    1.1.3 (2025-03-19):
      remove deprecated calls
    1.1.2 (2025-01-22):
      Minor GTK3 code cleanup
    1.1.1 (2023-11-27):
      Rubocop cleanup
    1.1.0 (2021-03-01):
      Updated menu elements to support GTK3 in Lich5
    1.0.0 (2020-03-20:
      Original baseline release
=end

require 'yaml'
require 'fileutils'

module Symbolz
  class << self
    attr_reader :version

    def initialize_version
      @version = extract_version_from_script
    end

    private

    def extract_version_from_script
      script_data = Script.list.find { |x| x.name == Script.current.name }&.inspect
      script_data&.match(/version: (\d+\.\d+\.\d+)/i)&.captures&.first || '2.0.0'
    end
  end

  LICH_REQUIRED_VERSION ||= '5.9.0'

  # Symbol definitions with their properties
  SYMBOLS ||= {
    '9806' => {
      name: 'Protection',
      description: 'Symbol of Protection: +26 to DS and +13 TD',
      tooltip: '31 Favor - Stackable',
      auto_cast: true
    },
    '9805' => {
      name: 'Courage',
      description: 'Symbol of Courage: +26 to AS',
      tooltip: '31 Favor - Stackable',
      auto_cast: true
    },
    '9816' => {
      name: 'Supremacy',
      description: 'Symbol of Supremacy: +13 to AS',
      tooltip: nil,
      auto_cast: true
    },
    '9815' => {
      name: 'Retribution',
      description: 'Symbol of Retribution: Reactive Flares When Hit By Undead',
      tooltip: nil,
      auto_cast: true
    },
    '9813' => {
      name: 'Mana',
      description: 'Symbol of Mana: Gives 50 Mana',
      tooltip: 'Activates at 40% mana - 5 min cooldown',
      auto_cast: false
    },
    '9812' => {
      name: 'Transcendence',
      description: 'Symbol of Transcendence: Makes You Non-Corporeal',
      tooltip: 'Activates when stunned, webbed, or bound - Lasts 30sec, 3min cooldown, 10min if used in Emergency',
      auto_cast: false
    },
    '9819' => {
      name: 'Renewal',
      description: 'Symbol of Renewal: Gives 1 Spirit, Can Use Every 2min',
      tooltip: 'Activates at 70% spirit, uses until spirit is back at 100%',
      auto_cast: false
    }
  }.freeze

  # Spell effect IDs that correspond to symbols
  SPELL_EFFECTS ||= {
    '9813' => '9048', # Mana effect
    '9812' => '9049', # Transcendence effect
    '9819' => '9050'  # Renewal effect
  }.freeze

  FORBIDDEN_ROOMS ||= [
    'The Belly of the Beast',
    'Ooze, Innards',
    'Temporal Rift'
  ].freeze

  class SettingsManager
    attr_reader :settings_file

    def initialize
      @settings_dir = File.join(DATA_DIR, XMLData.game, XMLData.name)
      @settings_file = File.join(@settings_dir, 'symbolz.yaml')
      @settings = {}

      ensure_directory_exists
      load
    end

    def load
      @settings = if File.exist?(@settings_file)
                    YAML.safe_load(File.read(@settings_file), permitted_classes: [Symbol], aliases: true) || default_settings
                  else
                    default_settings.tap { save }
                  end
    rescue StandardError => e
      echo "Error loading settings: #{e.message}"
      @settings = default_settings
    end

    def save
      File.write(@settings_file, @settings.to_yaml)
    rescue StandardError => e
      echo "Error saving settings: #{e.message}"
    end

    def [](key)
      @settings[key]
    end

    def []=(key, value)
      @settings[key] = value
    end

    def each_pair(&block)
      @settings.each_pair(&block)
    end

    def enabled_symbols
      @settings.select { |_key, value| value }.keys
    end

    private

    def ensure_directory_exists
      FileUtils.mkdir_p(@settings_dir) unless File.directory?(@settings_dir)
    rescue StandardError => e
      echo "Error creating settings directory: #{e.message}"
    end

    def default_settings
      SYMBOLS.keys.to_h { |key| [key, false] }
    end
  end

  class SymbolCaster
    MANA_THRESHOLD ||= 40
    SPIRIT_THRESHOLD ||= 80
    SLEEP_DURATION ||= 5

    def initialize(settings)
      @settings = settings
    end

    def cast_if_needed(spell_id)
      return unless should_cast?(spell_id)

      case spell_id
      when '9813' then cast_mana_symbol
      when '9812' then cast_transcendence_symbol
      when '9819' then cast_renewal_symbol
      else cast_standard_symbol(spell_id)
      end
    end

    private

    def should_cast?(spell_id)
      spell = Spell[spell_id]
      @settings[spell_id] && spell.known? && spell.affordable? && !spell.active?
    end

    def wait_for_ready
      waitrt?
      waitcastrt?
    end

    def cast_standard_symbol(spell_id)
      wait_for_ready
      Spell[spell_id].cast
    end

    def cast_mana_symbol
      return if Spell[SPELL_EFFECTS['9813']].active?
      return unless Char.percent_mana <= MANA_THRESHOLD

      wait_for_ready
      Spell['9813'].cast
      sleep SLEEP_DURATION
    end

    def cast_transcendence_symbol
      return if Spell[SPELL_EFFECTS['9812']].active?
      return unless should_use_transcendence?

      wait_for_ready
      Spell['9812'].cast
      sleep SLEEP_DURATION
    end

    def cast_renewal_symbol
      return if Spell[SPELL_EFFECTS['9819']].active?
      return unless Char.percent_spirit < SPIRIT_THRESHOLD

      wait_for_ready
      Spell['9819'].cast
      sleep SLEEP_DURATION
    end

    def should_use_transcendence?
      (stunned? || webbed? || bound?) && !in_forbidden_room?
    end

    def in_forbidden_room?
      FORBIDDEN_ROOMS.any? { |room| checkroom(room) }
    end
  end

  class UserInterface
    def self.show_setup_window(settings)
      window_result = nil
      window = nil

      Gtk.queue do
        window = build_window(-> {
          window_result = :cancel
        })
        checkboxes = build_checkboxes(settings)
        save_button = build_save_button(settings, checkboxes, -> {
          window_result = :save
        })

        window.add(build_layout(checkboxes, save_button))
        window.show_all
      end

      # Wait until user closes window via Save or X
      wait_for_window_action(-> { window_result }, window)
    end

    class << self
      private

      def build_window(on_delete)
        Gtk::Window.new(Gtk::WindowType::TOPLEVEL).tap do |w|
          w.set_title("Symbolz #{Symbolz.version} - Voln Symbol Upkeep")
          w.border_width = 20
          w.resizable = false

          # Handle "X" click cleanly without killing parent process
          w.signal_connect('delete_event') do
            on_delete.call
            # Do not queue destroy; GTK will handle it
            # We return true to indicate we handled the signal
            # and will manually destroy to avoid early teardown
            Gtk.queue { w.destroy unless w.destroyed? }
            true
          end
        end
      end

      def build_checkboxes(settings)
        SYMBOLS.each_with_object({}) do |(spell_id, props), checkboxes|
          checkbox = Gtk::CheckButton.new(props[:description])
          checkbox.active = settings[spell_id]
          checkbox.set_tooltip_text(props[:tooltip]) if props[:tooltip]
          checkboxes[spell_id] = checkbox
        end
      end

      def build_save_button(settings, checkboxes, on_click)
        Gtk::Button.new(label: 'Save and Close').tap do |button|
          button.signal_connect('clicked') do
            Gtk.queue do
              checkboxes.each_pair do |spell_id, checkbox|
                settings[spell_id] = checkbox.active?
              end
              settings.save
              on_click.call

              # Now close the window manually after saving
              parent_window = button.toplevel
              parent_window.destroy if parent_window && !parent_window.destroyed?
            end
          end
        end
      end

      def build_layout(checkboxes, save_button)
        Gtk::Box.new(:vertical, 0).tap do |vbox|
          SYMBOLS.keys.each do |spell_id|
            vbox.pack_start(checkboxes[spell_id], expand: false, fill: true, padding: 0)
          end
          vbox.pack_start(save_button)
        end
      end

      def wait_for_window_action(window_result_proc, window)
        # Wait until user chooses to save or closes window
        wait_while { window_result_proc.call.nil? }

        # Ensure window is truly destroyed before continuing
        Gtk.queue do
          if window && !window.destroyed?
            window.destroy
          end
        end

        # Give GTK a brief tick to complete cleanup
        sleep 0.05
        window_result_proc.call
      end
    end
  end

  class Application
    def initialize
      @settings = SettingsManager.new
      @caster = SymbolCaster.new(@settings)
    end

    def self.check_version_compatibility
      return if Gem::Version.new(LICH_VERSION) >= Gem::Version.new(LICH_REQUIRED_VERSION)

      display_version_error
      exit
    end

    def self.display_version_error
      if %w[stormfront profanity].include?($frontend)
        display_formatted_error
      else
        display_plain_error
      end
    end

    def self.display_formatted_error
      _respond '<preset id="speech">########################################</preset>'
      _respond "<preset id=\"thought\">Script:#{Script.current.name} requires Lich #{LICH_REQUIRED_VERSION}+</preset>"
      _respond '<preset id="thought">Please update to a newer version.</preset>'
      _respond '<preset id="thought"></preset>'
      _respond "<preset id=\"thought\">Current Version: #{LICH_VERSION}</preset>"
      _respond '<preset id="thought">Update help: https://gswiki.play.net/Lich_(software)/Installation</preset>'
      _respond '<preset id="speech">########################################</preset>'
    end

    def self.display_plain_error
      _respond '##########################################################'
      _respond ">Script:#{Script.current.name} requires Lich #{LICH_REQUIRED_VERSION}+"
      _respond '>Please update to a newer version.'
      _respond '>'
      _respond ">Current Version: #{LICH_VERSION}"
      _respond '>Update help: https://gswiki.play.net/Lich_(software)/Installation'
      _respond '##########################################################'
    end

    def self.show_help
      respond
      respond 'Usage:'
      respond "   #{$clean_lich_char}#{Script.current.name} help                     show this message"
      respond "   #{$clean_lich_char}#{Script.current.name} setup                    show setup window"
      respond
    end

    def run_maintenance_loop
      loop do
        exit if checkdead

        if punishment_active?
          echo 'The Grand Poohbah is still mad at you.'
          exit
        end

        cast_enabled_symbols
        sleep 1
      end
    end

    private

    def punishment_active?
      Spell[9012].active?
    end

    def cast_enabled_symbols
      @settings.each_pair do |spell_id, enabled|
        next unless enabled
        @caster.cast_if_needed(spell_id)
      end
    end
  end
end

# Initialize version
Symbolz.initialize_version

# Check Lich version compatibility
Symbolz::Application.check_version_compatibility

# Parse command line arguments
case Script.current.vars[1].to_s.downcase
when 'help'
  Symbolz::Application.show_help
  exit
when 'setup', 'options'
  settings = Symbolz::SettingsManager.new
  Symbolz::UserInterface.show_setup_window(settings)
  exit
else
  # Run main application
  app = Symbolz::Application.new
  app.run_maintenance_loop
end
