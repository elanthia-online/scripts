=begin

   Alchemy Script of Doom!!!1!one

   ;alchemy help

	updated by: Elanthia-online
     original author: Tillmen (tillmen@lichproject.org)
       game: Gemstone
       tags: alchemy, guild
    version: 0.20
   required: alchemy-recipes.lic >= 0.3

   changelog:
	  0.20 (2022-02-08):
		 fix  for new info verb
      0.16 (2020-10-20):
         fix commas in silver check
      0.15 (2018-09-15):
         fix collecting water
      0.14 (2017-11-11):
         fix squelching of gld verb for inactive members

=end
=begin

      0.13 (2017-01-14):
         make grind task work with "set sortedview on"
      0.12 (2015-07-08):
         added support for more scripted containers
      0.11 (2015-07-08):
         fix a bug where the wrong version of a recipe might be used when a specific step is required
      0.10 (2015-04-27):
         add options to clear helper scripts
      0.9 (2014-12-12):
         fix sunlight detection
      0.8 (2014-12-11):
         bugfix for Ruby 1.8
      0.7 (2014-12-10):
         move equivalents and reagent values (not complete) into alchemy-recipes.lic
         add time and value of each item to recipe check summary
         allow containts to be set using the script instead of ;settings/;vars
      0.6 (2014-11-12):
         recognize gld messaging for inactive members
      0.5 (2014-10-09):
         added message for scripted container (You carefully attach)
      0.4 (2014-10-07):
         more Mist Harbor fixes
      0.3 (2014-10-07):
         use Mist Harbor promissory note on Mist Harbor
      0.2 (2014-10-07):
         fix issue with finding recipes for alchemy masters task

=end

# fixme: run outta money
# fixme: full containers
# fixme: jars with unneeded ingredients ;e GameObj['bag'].contents.find_all { |obj| obj.noun == 'jar' }.each { |jar| echo jar.after_name unless jar.after_name.sub(/^containing /, '') =~ /#{UserVars.needed_reagents.gsub('$|^', 's?$|^').gsub('tooth', '(?:tooth|teeth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').gsub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').gsub(' ', 's? ')}/ }
# fixme: forage some mushrooms only certain times of day
# fixme: Khelorof says, "To rise to the top, you must diversify.  You need to learn 2 rank(s) of other skills before I can promote you in this skill again."
# fixme: recast haste on armor hindrance
# fixme: option to use symbol of dreams when waiting for spirit
# fixme: use time verb for sunlight test
# fixme: The surface of the solution in the iron cauldron shimmers in response!
# fixme: The diamond lens shatters!

silence_me unless $alchemy_debug

unless defined?($alchemy_recipes) and ($alchemy_recipes.class == Array) and not $alchemy_recipes.empty?
   unless Script.exists?('alchemy-recipes')
      start_script 'repository', [ 'download', 'alchemy-recipes' ]
      wait_while { running?('repository') }
      unless Script.exists?('alchemy-recipes')
         echo 'failed to download alchemy-recipes.lic'
         exit
      end
   end
   start_script 'alchemy-recipes'
   wait_while { running?('alchemy-recipes') }
   unless defined?($alchemy_recipes)
      echo 'no recipes'
      exit
   end
   unless defined?($alchemy_reagent_op_cost)
      start_script 'repository', [ 'download', 'alchemy-recipes' ]
      wait_while { running?('repository') }
      start_script 'alchemy-recipes'
      wait_while { running?('alchemy-recipes') }
      unless defined?($alchemy_reagent_op_cost)
         echo 'error: failed to download a new enough version of alchemy-recipes'
         exit
      end
   end
end

CharSettings['hide-gld-check']     = true  if CharSettings['hide-gld-check'].nil?
CharSettings['hide-bundle-check']  = true  if CharSettings['hide-bundle-check'].nil?
CharSettings['hide-jar-check']     = true  if CharSettings['hide-jar-check'].nil?
CharSettings['cast-sanctuary']     = true  if CharSettings['cast-sanctuary'].nil?
CharSettings['buy-crap']           = false if CharSettings['buy-crap'].nil?
CharSettings['throw-away-crap']    = false if CharSettings['throw-away-crap'].nil?
CharSettings['sell-crap']          = false if CharSettings['sell-crap'].nil?
CharSettings['max-travel-time']  ||=   90
CharSettings['max-hunt-time']    ||=  300
CharSettings['max-forage-time']  ||=  300
CharSettings['cost-per-second']  ||=   15
CharSettings['favorite-recipes'] ||= Array.new

echo CharSettings['kill time'].inspect if $alchemy_debug

put_regex     = /^You (?:attempt to shield .*? from view as you |discreetly |carefully |absent-mindedly )?(?:put|place|slip|tuck|add|hang|drop|untie your|find an incomplete bundle|wipe off .*? and sheathe)|^A sigh of grateful pleasure can be heard as you feed .*? to your|^As you place|^I could not find what you were referring to\.$|^Your bundle would be too large|^The .+ is too large to be bundled\.|^As you place your|^The .*? is already a bundle|^Your .*? won't fit in .*?\.$|^You can't .+ It's closed!$/
get_regex     = /^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly )?(?:remove|draw|grab|reach|slip|tuck|retrieve|already have|unsheathe|detach)|^Get what\?$|^Why don't you leave some for others\?$|^You need a free hand|^You already have that/
cauldron_noun = /^(?:cauldron|vat|kettle|boiler)$/

elusive_reagent_cost = {
   'cluster of ayanad crystals'        =>   64,
   'ayanad crystal'                    =>  128,
   'crystal core'                      =>  128,
   'elemental core'                    =>  255,
   "cluster of s'ayanad crystals"      =>  255,
   'cracked soulstone'                 =>  300, # fixme
   "s'ayanad crystal"                  =>  510,
   'some essence of air'               =>  510,
   'some essence of earth'             =>  510,
   'some essence of fire'              =>  510,
   'some essence of water'             =>  510,
   "pristine nymph's hair"             =>  510,
   'small troll tooth'                 =>  638,
   'glimmering blue essence shard'     =>  638,
   'some glimmering blue essence dust' =>  765,
   'glimmering blue mote of essence'   =>  765,
   "cluster of t'ayanad crystals"      =>  892,
   'glowing violet essence shard'      => 1275,
   'crystalline globe'                 => 1530,
   "t'ayanad crystal"                  => 1785,
   "pristine sprite's hair"            => 1785,
   'glowing violet mote of essence'    => 2295,
   'some glowing violet essence dust'  => 2295,
   'perfect myklian belly scale'       => 2550,
   'large troll tooth'                 => 2550,
   'vial of farlook vitreous humor'    => 2550,
   'inky necrotic core'                => 2550,
   'tiny golden seed'                  => 2550,
   'radiant crimson essence shard'     => 3825,
   "pristine siren's hair"             => 4080,
   "n'ayanad crystal"                  => 5355,
   'some radiant crimson essence dust' => 6885,
   'radiant crimson mote of essence'   => 6885,
}

if $alchemy_equivalents
   equivalent = $alchemy_equivalents
else
   equivalent = [
      [ 'ayana leaf', 'ayana lichen', 'ayana weed', 'ayana berry', 'ayana root' ],
      [ "ayana'al leaf", "ayana'al lichen", "ayana'al weed", "ayana'al berry", "ayana'al root" ],
      [ 'some ground ayana', 'some ground ayana leaf', 'some ground ayana lichen', 'some ground ayana weed', 'some ground ayana berry', 'some ground ayana root' ],
      [ 'myklian scale', 'orange myklian scale', 'red myklian scale', 'yellow myklian scale', 'green myklian scale' ],
      [ 'white pearl', 'large white pearl', 'medium white pearl', 'small white pearl', 'tiny white pearl' ],
      [ 'black pearl', 'large black pearl', 'medium black pearl', 'small black pearl', 'tiny black pearl' ],
      [ 'pink pearl', 'tiny pink pearl', 'small pink pearl', 'medium pink pearl', 'large pink pearl' ],
      [ 'stick', 'thick stick', 'stained stick', 'slender stick', 'pointed stick', 'twisted stick', 'long stick', 'slim stick', 'charred stick', 'flexible stick', 'sturdy stick', 'dark stick', 'hefty stick', 'cracked stick', 'thin stick', 'small stick', 'bent stick', 'short stick', 'heavy stick' ],
      [ 'vial of concentrated firethorn essence', 'vial concentrated firethorn essence' ],
      [ 'some powdered rhodochrosite stone', 'some powdered pink rhodochrosite stone' ],
      [ 'some powdered chrysoberyl gem', 'some powdered bright chrysoberyl gem' ],
      [ 'some powdered malachite stone', 'some powdered green malachite stone' ],
      [ 'some powdered spessartine garnet', 'some powdered orange spessartine garnet' ],
      [ 'some powdered pink coral', 'some powdered polished pink coral' ],
      [ 'some powdered blue coral', 'some powdered polished blue coral' ],
      [ 'some powdered red coral', 'some powdered polished red coral' ],
      [ 'some powdered water sapphire', 'some powdered pale water sapphire' ],
      [ 'some powdered fire pearl', 'some powdered billiant fire pearl' ],
      [ 'some powdered cowrie shell', 'some powdered snake-head cowrie shell' ],
      [ 'some powdered iridescent mother-of-pearl', 'some powdered iridescent piece of mother-of-pearl' ],
      [ 'some powdered silvery conch shell', 'some powdered sparkling silvery conch shell' ],
      [ 'some powdered imperial topaz', 'some powdered orange imperial topaz' ],
      [ 'some powdered green moonstone', 'some powdered pale green moonstone' ],
      [ 'some powdered pale blue moonstone', 'some powdered blue moonstone' ],
      [ 'some powdered beryl gem', 'some powdered golden beryl gem' ],
      [ 'crystalline globe', 'corked crystalline globe filled with glowing mineral water', ],
      [ 'tkaro root', 'shiny tkaro root' ],
      [ 'tufted hawk-owl ear', 'hawk-owl ear' ],
   ]
end

herb_doses = {
   'some acantha leaf' => 10,
   'some aloeas stem' => 2,
   'some haphip root' => 4,
   'some pothinir grass' => 2,
   'some basal moss' => 4,
   'some ephlox moss' => 4,
   'some ambrominas leaf' => 4,
   'some calamia fruit' => 2,
   'some cactacae spine' => 4,
   'some sovyn clove' => 1,
   'some wolifrew lichen' => 4,
   'some woth flower' => 2,
   'some torban leaf' => 3,
}

sea_water_flask = /^(?:small|small opaque|faceted) crystal flask$|^dark sphene-inset flask$/
sea_water_vial  = /^(?:clouded|warped|chipped|tapered|smoky|thick|slender|clear|blackened) glass vial$|^polished glaes vial$/
bundled_herb    = /^some acantha leaf$|^some cactacae spine$|^some ambrominas leaf$|^some torban leaf$|^some wolifrew lichen$|^some sovyn clove$|^some ephlox moss$|^some pothinir grass$|^some haphip root$|^some calamia fruit$|^some aloeas stem$|^some basal moss$|^some woth flower$/

check_silvers = proc {
   silvers = nil
   action = proc { |server_string|
      if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Ascended \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
         nil
      elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9,]+)/
         silvers = $1.gsub(',','').to_i
         DownstreamHook.remove("#{script.name}_check_silvers")
         nil
      else
         server_string
      end
   }
   DownstreamHook.add("#{script.name}_check_silvers", action)
   silence_me unless undo_silence = silence_me
   put 'info'
   silence_me if undo_silence
   wait_until { silvers }
   silvers
}

wander_room_order = Array.new
wander_room_list = Array.new
wander = proc {
   next_room_options = Room.current.wayto.keys & wander_room_list
   next_room = next_room_options.find_all { |r| not wander_room_order.include?(r) }
   if next_room.empty?
      next_room = wander_room_order.find { |r| next_room_options.include?(r) }
   else
      next_room = next_room[rand(next_room.length)]
   end
   wander_room_order.delete(next_room)
   wander_room_order.push(next_room)
   way = Room.current.wayto[next_room]
   if way.class == String 
      move(way)
   else
      way.call
   end
}

gld_var = nil
gld = proc {
   if gld_var.nil?
      fix_type = { 'General Alchemy' => 'alchemy', 'Alchemic Potions' => 'potions', 'Alchemic Trinkets' => 'trinkets' }
      script.want_downstream = false
      script.want_downstream_xml = true
      gld_var = Hash.new
      type = nil
      if CharSettings['hide-gld-check']
         started = false
         action = proc { |server_string|
            if started
               if server_string =~ /<output/
                  DownstreamHook.remove('hide_gld')
                  server_string
               else
                  nil
               end
            else
               if server_string =~ /^You are (?:a member|an inactive member|Guild Master)/
                  started = true
                  nil
               else
                  server_string
               end
            end
         }
         DownstreamHook.add('hide_gld', action)
      end
      undo_silent = !script.silent
      script.silent = true
      result = dothistimeout 'gld', 15, /^You are (?:a member|an inactive member|Guild Master)|^You have no guild affiliation./
      script.silent = false if undo_silent
      if result =~ /^You have no guild affiliation./
         echo 'join a guild'
         exit
      elsif result.nil?
         echo 'fixme 20983238453'
      end
      while (line = get) and (line !~ /<prompt/)
         if line =~ /^You currently have no ranks in any guild skills./
            for type in fix_type.values
               gld_var[type] = Hash.new
               gld_var[type][:rank] = 0
               gld_var[type][:task] = 'no task'
               gld_var[type][:reps] = 0
            end
         elsif line =~ /^You have ([0-9]+|no) ranks? in the (General Alchemy|Alchemic Potions|Alchemic Trinkets) skill\.$/
            rank = $1
            type = fix_type[$2]
            gld_var[type] = Hash.new
            if rank =~ /^[0-9]+$/
               gld_var[type][:rank] = rank.to_i
            else
               gld_var[type][:rank] = 0
            end
         elsif line =~ /^You are a Master of (General Alchemy|Alchemic Potions|Alchemic Trinkets)\.$/
            type = fix_type[$1]
            gld_var[type] = Hash.new
            gld_var[type][:rank] = 63
         elsif line =~ /^The Training Administrator told you to (.*)\.$/
            gld_var[type][:task] = $1
         elsif line =~ /^You have earned enough training points for your next rank\./
            gld_var[type][:task] = 'promotion'
         elsif line =~ /^You are not currently training in this skill\.$|^You have not yet obtained your first task for this skill rank\.$|^You have not been assigned a current task for this skill\.$/
            gld_var[type][:task] = 'no task'
            gld_var[type][:reps] = 0
         elsif line == 'You have no repetitions remaining for this task.'
            gld_var[type][:reps] = 0
         elsif line =~ /^You have ([0-9]+) repetitions? remaining (?:for|to complete) this task\.$/
            gld_var[type][:reps] = $1.to_i
         end
      end
      script.want_downstream = true
      script.want_downstream_xml = false
   end
   gld_var
}

invalid_gld = proc {
   gld_var = nil
}

gld_suggestions = proc {
   gld.call
   if gld_var.values.any? { |hash| hash[:recipes].nil? }
      for type in gld_var.keys
         if gld_var[type][:task] =~ /(?:with your|that involve) (.*?)(?: ability| mana|ing spells|ing|ing mana|ing spirit)?$/
            required_step = $1
            if gld_var[type][:task] =~ /cauldron workshop/
               gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| recipe[:type].include?(type) and recipe[:rank] and gld_var[type][:rank] >= recipe[:rank].min and gld_var[type][:rank] <= recipe[:rank].max and recipe[:steps].any? { |step| step =~ /^#{required_step}/ } and not recipe[:steps].any? { |step| step =~ /^refract/ } }
            else
               gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| recipe[:type].include?(type) and recipe[:rank] and gld_var[type][:rank] >= recipe[:rank].min and gld_var[type][:rank] <= recipe[:rank].max and recipe[:steps].any? { |step| step =~ /^#{required_step}/ } }
            end
         elsif gld_var[type][:task] =~ /follow some tough recipes and create some items|visit a skilled master for a lesson/
            gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| (recipe[:product] != 'flask of pure water') and recipe[:type].include?(type) and recipe[:rank] and gld_var[type][:rank] >= recipe[:rank].min and gld_var[type][:rank] <= recipe[:rank].max }
         elsif gld_var[type][:task] == 'practice distilling for reagents'
            gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| recipe[:product] == 'flask of pure water' }
         elsif gld_var[type][:task] == 'practice extracting for reagents'
            gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| recipe[:product] == 'handful of sea salt' }
         else
            gld_var[type][:recipes] = Array.new
         end
      end
   end
   gld_var
}

gld_suggestions2 = proc {
   gld.call
   if gld_var.values.any? { |hash| hash[:recipes].nil? }
      for type in gld_var.keys
         gld_var[type][:recipes] = $alchemy_recipes.find_all { |recipe| (recipe[:product] != 'flask of pure water') and recipe[:type].include?(type) and recipe[:rank] and gld_var[type][:rank] >= recipe[:rank].min and gld_var[type][:rank] <= recipe[:rank].max }.collect { |recipe| recipe[:product] }
         gld_var[type][:recipes] = gld_var[type][:recipes] | gld_var[type][:recipes]
      end
   end
   gld_var
}

alchemy_sack_var = nil
close_alchemy_sack_var = false
alchemy_sack = proc {
   if alchemy_sack_var.nil?
      if UserVars.alchemysack.nil? or UserVars.alchemysack.empty? 
         echo 'warning: alchemysack is not set (#{$clean_lich_char}#{script.name} set alchemysack <container name>)'
         sleep 1
      else
         alchemy_sack_var = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.alchemysack.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.alchemysack).sub(' ', ' .*')}/i }
         if alchemy_sack_var.nil?
            echo "warning: failed to find your alchemysack (#{UserVars.alchemysack})"
            sleep 1
         else
            if alchemy_sack_var.contents.nil?
               open_result = dothistimeout "open ##{alchemy_sack_var.id}", 10, /You open|already open/
               close_alchemy_sack_var = true if open_result =~ /You open/
               if alchemy_sack_var.contents.nil?
                  dothistimeout "look in ##{alchemy_sack_var.id}", 10, /In the .* you see/
                  if alchemy_sack_var.contents.nil?
                     echo "warning: failed to find the contents of your alchemysack (#{UserVars.alchemysack})"
                     sleep 1
                  end
               end
            end
         end
      end
   end
   alchemy_sack_var
}

loot_sack_var = nil
close_loot_sack_var = false
loot_sack = proc {
   if loot_sack_var.nil?
      if UserVars.lootsack.nil? or UserVars.lootsack.empty? 
         echo 'warning: lootsack is not set (#{$clean_lich_char}#{script.name} set lootsack <container name>)'
         sleep 1
      else
         loot_sack_var = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.lootsack.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.lootsack).sub(' ', ' .*')}/i }
         if loot_sack_var.nil?
            echo "warning: failed to find your lootsack (#{UserVars.lootsack})"
            sleep 1
         else
            if loot_sack_var.contents.nil?
               open_result = dothistimeout "open ##{loot_sack_var.id}", 10, /You open|already open/
               close_loot_sack_var = true if open_result =~ /You open/
               if loot_sack_var.contents.nil?
                  dothistimeout "look in ##{loot_sack_var.id}", 10, /In the .* you see/
                  if loot_sack_var.contents.nil?
                     echo "warning: failed to find the contents of your lootsack (#{UserVars.lootsack})"
                     sleep 1
                  end
               end
            end
         end
      end
   end
   loot_sack_var
}

herb_sack_var = nil
close_herb_sack_var = false
herb_sack = proc {
   if herb_sack_var.nil?
      if UserVars.herbsack.nil? or UserVars.herbsack.empty? 
         echo 'warning: herbsack is not set (#{$clean_lich_char}#{script.name} set herbsack <container name>)'
         sleep 1
      else
         herb_sack_var = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.herbsack.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.herbsack).sub(' ', ' .*')}/i }
         if herb_sack_var.nil?
            echo "warning: failed to find your herbsack (#{UserVars.herbsack})"
            sleep 1
         else
            if herb_sack_var.contents.nil?
               open_result = dothistimeout "open ##{herb_sack_var.id}", 10, /You open|already open/
               close_herb_sack_var = true if open_result =~ /You open/
               if herb_sack_var.contents.nil?
                  dothistimeout "look in ##{herb_sack_var.id}", 10, /In the .* you see/
                  if herb_sack_var.contents.nil?
                     echo "warning: failed to find the contents of your herbsack (#{UserVars.herbsack})"
                     sleep 1
                  end
               end
            end
         end
      end
   end
   herb_sack_var
}

close_sacks = proc {
   if close_alchemy_sack_var
      fput "close ##{alchemy_sack_var.id}"
      close_alchemy_sack_var = false
   end
   if close_loot_sack_var
      fput "close ##{loot_sack_var.id}"
      close_loot_sack_var = false
   end
   if close_herb_sack_var
      fput "close ##{herb_sack_var.id}"
      close_herb_sack_var = false
   end
}

all_sack_contents = proc {
   (alchemy_sack.call.contents.to_a | loot_sack.call.contents.to_a | herb_sack.call.contents.to_a)
}

cauldron = nil
drop_cauldron = proc {
   error = false
   unless (checkroom == '[A Secluded Corner]') or GameObj.room_desc.find { |obj| obj.noun == 'cauldron' } or GameObj.loot.find { |obj| obj.noun =~ cauldron_noun }
      unless cauldron = all_sack_contents.call.find { |obj| obj.noun =~ cauldron_noun }
         echo 'error: missing cauldron'
         error = true
      end
      dothis "get ##{cauldron.id}", get_regex
      # Upon further reflection, you decide it would be best if you just used the already present training cauldron.
      dothis "drop ##{cauldron.id}", /^You drop/
      put "drag #{cauldron.noun}"
   end
   !error
}

force_drop_cauldron = proc {
   error = false
   unless cauldron = all_sack_contents.call.find { |obj| obj.noun =~ cauldron_noun }
      echo 'error: missing cauldron'
      error = true
   else
      dothis "get ##{cauldron.id}", get_regex
      # Upon further reflection, you decide it would be best if you just used the already present training cauldron.
      dothis "drop ##{cauldron.id}", /^You drop/
      put "drag #{cauldron.noun}"
   end
   !error
}

get_cauldron = proc {
   if cauldron
      dothis "_drag ##{cauldron.id} ##{alchemy_sack.call.id}", put_regex
      fput 'drag stop'
      cauldron = nil
   end
}

where_is_previous_var = nil
where_is_shortest_distances_var = nil
where_is_history = Hash.new
where_is = proc { |place|
   if where_is_history[place]
      where_is_history[place]
   elsif where_is_previous_var.nil?
      if Room.current
         if home_room = Room.current.find_nearest_by_tag("#{Char.prof.downcase} alchemy administrator")
            home_room = Room[home_room]
         else
            echo 'warning: failed to find your guild'
            home_room = Room.current
         end
         if (home_room == Room.current) or Map.estimate_time(Room.current.path_to(home_room)) <= CharSettings['max-travel-time']
            where_is_previous_var, where_is_shortest_distances_var = home_room.dijkstra
         else
            echo 'warning: nearest guild exceeds max travel time'
            where_is_previous_var = false
         end
      else
         echo 'warning: your current room is not in the map database'
         where_is_previous_var = false
      end
   end
   if where_is_previous_var == false
      Array.new
   else
      results = Array.new
      Map.list.each { |room| results.push(room.id) if room.tags.include?(place) }
      if place == 'ayana leaf'
         ["ayana berry", "ayana leaf", "ayana root", "ayana weed", "ayana lichen"].each { |other_place| Map.list.each { |room| results.push(room.id) if room.tags.include?(other_place) and not results.include?(room.id) } }
         #"ayana'al berry", "ayana'al root", "ayana'al lichen"
      end
      results.delete_if { |room_id| where_is_shortest_distances_var[room_id].nil? or where_is_shortest_distances_var[room_id] > CharSettings['max-travel-time'] }
      # ignore the Caravansary
      results.delete_if { |room_id| Room[room_id].title.any? { |t| t =~ /^(?:\['Tain't Much Magic, Emporium\]|\['Tain't Much Magic, Consignment\]|\[Finders-Sellers Pawnshop\]|\[Clenchfist Bros. Banking, Lobby\])$/ } }
      where_is_history[place] = results.sort { |a,b| where_is_shortest_distances_var[a] <=> where_is_shortest_distances_var[b] }
      where_is_history[place]
   end
}

go_empty_workshop = proc {
   room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
   unless room_list.empty? or room_list.include?(Room.current.id)
      get_cauldron.call
      for room_id in room_list
         break if where_is_shortest_distances_var[room_id] > 15
         start_script 'go2', [ room_id.to_s ]
         wait_while { running?('go2') }
         break unless checkpcs
      end
   end
}

is_workshop = proc {
   Room.current.tags.include?("#{Char.prof.downcase} alchemy workshop")
}

tavel_time = proc { |room_id|
   if where_is_shortest_distances_var.nil?
      where_is.call
   end
   where_is_shortest_distances_var[room_id]
}

note_name_var = nil
note_name = proc {
   if note_name_var.nil?
      if (room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first) and (location = Room[room_id].location)
         hash = {
            'the town of Icemule Trace' => 'Icemule promissory note',
            'Icemule Trace' => 'Icemule promissory note',
            'Kharam-Dzu' => 'Borthuum Mining Company scrip',
            "the town of Wehnimer's Landing" => "Wehnimer's promissory note",
            "Wehnimer's Landing" => "Wehnimer's promissory note",
            "the Coastal Cliffs" => "Wehnimer's promissory note",
            "River's Rest" => 'Torren promissory note',
            'Zul Logoth' => 'mining chit',
            "Ta'Illistim" => 'City-States promissory note',
            "Ta'Vaalor" => 'City-States promissory note',
            'the free port of Solhaven' => 'Vornavis promissory note',
            'Solhaven' => 'Vornavis promissory note',
            'Mist Harbor' => 'Mist Harbor promissory note',
         }
         note_name_var = hash[location]
      else
         note_name_var = false
      end
   else
      note_name_var
   end
}

note_name_from_place = proc { |place|
   if place =~ /Icemule/
      'Icemule promissory note'
   elsif place =~ /Ta'Illistim|Ta'Vaalor/
      'City-States promissory note'
   elsif place =~ /River's Rest/
      'Torren promissory note'
   elsif place =~ /Solhaven/
      'Vornavis promissory note'
   elsif place =~ /Kharam-Dzu/
      'Borthuum Mining Company scrip'
   elsif place =~ /Wehnimer's Landing/
      "Wehnimer's promissory note"
   elsif place =~ /Zul Logoth/
      'mining chit'
   elsif place =~ /Mist Harbor/
      'Mist Harbor promissory note'
   else
      nil
   end
}

is_sunlight_cache = nil
is_sunlight = proc {
   # fixme: guessing times for light
   # mid-morning:     11:26 - 11:26
   # afternoon:       12:07 - 14:04 (sunlight)
   # late afternoon:  14:23 - 16:48 (sunlight)
   # evening twilight 16:49 - 17:33 (moonlight)
   # late evening:    18:20 - 23:20
   # after midnight:  00:01 - 04:33
   # May 13-14, 2011
      # late afternoon:       ? - 18:50 (sunlight)
      # evening twilight: 18:51 - 19:20 (moonlight)
      # late evening:     19:21 - 23:59 (moonlight)
      # after midnight:   00:00 - 04:37 (moonlight)
      # morning twilight: 04:38 - 05:07 
      # early morning:    05:08 - 08:33 (sunlight)
      # mid morning:      08:34 - 11:59 (sunlight)
      # afternoon:        12:00 -     ? (sunlight)

   # June 3, 2014
      # late afternoon:   15:37 - 19:13 (sunlight)
      # evening twilight: 19:14 - 19:43 (moonlight)
      # late evening:     19:44 - 23:59 (moonlight)
      # after midnight:    0:00 -  4:14 (moonlight)
      # morning twilight:  4:15 -  4:44 
      # early morning:     4:45 -  8:23 (sunlight)
      # mid morning:       8:24 - 11:59 (sunlight)
      # afternoon:        12:00 - 15:36 (sunlight)

   # fixme: daylight savings time?

   seconds = (XMLData.server_time - (5*60*60)) % (60*60*24) # seconds since midnight, elven time standard
   hours = seconds/(60*60)
   seconds = seconds % (60*60)
   minutes = seconds/60
   seconds = seconds % 60

   if ((hours > 6) or ((hours == 6) and (minutes > 30))) and (hours < 18)
      true
   elsif (hours < 5) or (hours > 20)
      false
   elsif is_sunlight_cache and is_sunlight_cache[0] == "#{Time.now.hour}:#{Time.now.min}"
      is_sunlight_cache[1]
   else
      result = dothis 'time', /^Today is /
      if result =~ /early morning|mid morning|afternoon|late afternoon/
         is_sunlight_cache = [ "#{Time.now.hour}:#{Time.now.min}", true ]
         true
      else
         is_sunlight_cache = [ "#{Time.now.hour}:#{Time.now.min}", false ]
         false
      end
   end
}

is_moonlight = proc { !is_sunlight.call }

set_needed_reagents = proc {
   ingredient_list = Array.new
   check_proc = proc { |recipe|
      for step in recipe[:steps]
         if step =~ /^(?:add|grind|extract|distill|separate)\s+(.*)/
            ingredient_name = $1
            ingredient_list.push(ingredient_name) unless ingredient_list.include?(ingredient_name)
            if equivalent_names = equivalent.find { |list| list.include?(ingredient_name) }
               for equivalent_name in equivalent_names
                  ingredient_list.push(equivalent_name) unless ingredient_list.include?(equivalent_name)
               end
            end
            for sub_recipe in $alchemy_recipes.find_all { |r| r[:product] == ingredient_name }
               check_proc.call(sub_recipe)
            end
         end
      end
   }
   for type in gld.call.keys
      for recipe in $alchemy_recipes.find_all { |recipe| CharSettings['favorite-recipes'].include?(recipe[:product]) or ((recipe[:product] != 'flask of pure water') and recipe[:type].include?(type) and recipe[:rank] and (gld.call[type][:rank] <= 62) and (gld.call[type][:rank] >= recipe[:rank].min) and (gld.call[type][:rank] <= recipe[:rank].max)) }
         check_proc.call(recipe)
      end
   end
   for product in CharSettings['favorite-recipes']
      ingredient_list.push(product) unless ingredient_list.include?(product)
   end
   if ingredient_list.empty?
      UserVars.delete('needed_reagents')
   else
      UserVars.needed_reagents = "^#{ingredient_list.join('$|^')}$"
   end
   nil
}

is_reagent_var = nil
is_reagent = proc { |test_name|
   unless is_reagent_var
      reagent_array = Array.new
      $alchemy_recipes.each { |recipe|
         recipe[:steps].each { |step|
            if step =~ /^(?:add|grind|extract|distill|separate)\s+(.*)/
               item = $1
               equivalent.find { |r| r.include?(item) }.each { |i| reagent_array.push(i) unless reagent_array.include?(i) }
               reagent_array.push(item) unless reagent_array.include?(item)
            end
         }
      }
      is_reagent_var = /^#{reagent_array.collect { |r| r.sub(/^some /, '(?:some )?').sub('faintly ', '(?:faintly )?') }.join('$|^')}$/
   end
   test_name =~ is_reagent_var
}

do_administrator = proc {
   if gld.call.any? { |type,info| (info[:task] =~ /^(?:no task|promotion|gather alchemy ingredients for the guild's supply)$/ or info[:reps] == 0) and ((type == 'alchemy') or (info[:rank] < gld.call['alchemy'][:rank])) }
      general_ranks = gld.call['alchemy'][:rank]
      loop {
         get_cauldron.call
         if room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
            start_script 'go2', [ room_id.to_s ]
            wait_while { running?('go2') }
            did_something = false
            if gld.call['alchemy'].nil?
               dothistimeout "ask #{GameObj.npcs.last.noun} about training alchemy", 10, /^#{GameObj.npcs.last.noun} .*?, "/
               invalid_gld.call
            end
            if gld.call['potions'].nil? and (gld.call['alchemy'][:rank].to_i > 0)
               dothistimeout "ask #{GameObj.npcs.last.noun} about training potions", 10, /^#{GameObj.npcs.last.noun} .*?, "/
               invalid_gld.call
            end
            if gld.call['trinkets'].nil? and (gld.call['alchemy'][:rank].to_i > 0)
               dothistimeout "ask #{GameObj.npcs.last.noun} about training trinkets", 10, /^#{GameObj.npcs.last.noun} .*?, "/
               invalid_gld.call
            end
            for type,info in gld.call
               next if (type =~ /potions|trinkets/) and (info[:rank] == gld.call['alchemy'][:rank])
               if info[:task] == 'no task'
                  result = dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
                  invalid_gld.call
                  unless result =~ /your general alchemy skills are not quite up to snuff/
                     did_something = true
                  end
               elsif (info[:task] == 'promotion')
                  if type != 'alchemy' or info[:rank].to_i != 5 or (gld.call['potions'][:rank].to_i >= 2 and gld.call['trinkets'][:rank].to_i >= 2)
                     if type != 'alchemy' or info[:rank].to_i != 10 or (gld.call['potions'][:rank].to_i >= 3 and gld.call['trinkets'][:rank].to_i >= 3)
                        if room_id = where_is.call("#{Char.prof.downcase} alchemy guildmaster").first
                           start_script 'go2', [ room_id.to_s ]
                           wait_while { running?('go2') }
                           result = dothistimeout "ask #{GameObj.npcs.last.noun} about next #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
                           unless result =~ /you must diversify/
                              did_something = true
                              invalid_gld.call
                              set_needed_reagents.call
                           end
                           room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
                           start_script 'go2', [ room_id.to_s ]
                           wait_while { running?('go2') }
                        else
                           echo 'error: failed to find guildmaster'
                        end
                     end
                  end
               elsif info[:reps] == 0
                  dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
                  dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
                  invalid_gld.call
                  did_something = true
               elsif info[:task] == "gather alchemy ingredients for the guild's supply"
                  invalid_gld.call
                  dothistimeout "ask #{GameObj.npcs.last.noun} about trade #{type}", 10, /^#{GameObj.npcs.last.noun} .*?, "/
                  did_something = true
               end
            end
            break unless did_something
         else
            echo 'error: failed to find training administrator'
            break
         end
      }
   end
}

read_menu = proc {
   status_tags
   clear
   fput 'unhide' if hidden? or invisible?
   fput 'order'
   menu = Hash.new
   while (line = get) and (line !~ /ORDER|BUY/)
      for item in line.scan(/<d.*?cmd=["']order ([0-9]+).*?>(.*?)<\/d>/)
         menu[item[1].sub(/^a /, '')] = item[0]
      end
   end
   status_tags
   clear
   menu
}

add_commas = proc { |num|
   num.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse
}

trading_sell = proc { |silvers|
   if Skills.trading > 6
      (silvers*((((Skills.to_bonus(Skills.trading) + Stats.inf[1])/12)/100.0)+1)).floor
   else
      silvers
   end
}

trading_buy = proc { |silvers|
   if Skills.trading > 6
      silvers - (silvers * (((Skills.to_bonus(Skills.trading) + Stats.inf[1])/12)/100.0)).floor
   else
      silvers
   end
}

check_channel_spirit = proc {
   needed_spirit = 3
   needed_spirit += 1 if Spell[9912].active?
   needed_spirit += 1 if Spell[9913].active?
   needed_spirit += 1 if Spell[9914].active?
   needed_spirit += 3 if Spell[9916].active?
   checkspirit(needed_spirit)
}

ingredient_count = Hash.new
correct_herb_count = Array.new

check_ingredient = proc { |ingredient_name,temp_claimed_ingredients,temp_ingredient_count|
   temp_claimed_ingredients ||= Array.new
   if temp_ingredient_count.nil? or temp_ingredient_count.empty?
      temp_ingredient_count = ingredient_count.dup
   end
   found = false
   equivalent_ingredients = (equivalent.find { |list| list.include?(ingredient_name) } || [ ingredient_name ])
   if ingredient = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name !~ bundled_herb) and not temp_claimed_ingredients.include?(obj.id) }
      temp_claimed_ingredients.push(ingredient.id)
      found = true
   elsif bundle = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name =~ bundled_herb) and (temp_ingredient_count[obj.id].nil? or temp_ingredient_count[obj.id] > 0) }
      if temp_ingredient_count[bundle.id].nil?
         empty_hand
         dothistimeout "get ##{bundle.id}", 10, get_regex
         measure_result = dothistimeout "measure ##{bundle.id}", 10, /^(?:You can't tell exactly, but the|The) .*? (?:has 1 bite|has 2 bites|looks like it has a few bites|looks like it has several bites|seems to have plenty of bites) left\./
         if measure_result =~ /1 bite/
            temp_ingredient_count[bundle.id] = 1
            ingredient_count[bundle.id] = 1
         elsif measure_result =~ /2 bites/
            temp_ingredient_count[bundle.id] = 2
            ingredient_count[bundle.id] = 2
         elsif measure_result =~ /a few bites/
            temp_ingredient_count[bundle.id] = 3
            ingredient_count[bundle.id] = 3
         elsif measure_result =~ /several bites/
            temp_ingredient_count[bundle.id] = 5
            ingredient_count[bundle.id] = 5
         elsif measure_result =~ /plenty of bites/
            temp_ingredient_count[bundle.id] = 11
            ingredient_count[bundle.id] = 11
         else
            temp_ingredient_count[bundle.id] = 1
            ingredient_count[bundle.id] = 1
            echo "error: unmatched measure result: #{measure_result.inspect}"
         end
         dothistimeout "put ##{bundle.id} in ##{herb_sack.call.id}", 10, put_regex
         fill_hand
      end
      temp_ingredient_count[bundle.id] = temp_ingredient_count[bundle.id] - 1
      found = true
   elsif jar = all_sack_contents.call.find { |obj| (obj.after_name =~ /containing (?:#{equivalent_ingredients.collect { |name| name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ') }.join('|')})/) and (temp_ingredient_count[obj.id].nil? or temp_ingredient_count[obj.id] > 0) }
      if temp_ingredient_count[jar.id].nil?
         if CharSettings['hide-jar-check']
            action = proc { |server_string|
               if server_string =~ /^Inside the .*? you see [0-9]+ portions?/
                  DownstreamHook.remove('hide-jar-check')
                  nil
               else
                  server_string
               end
            }
            DownstreamHook.add('hide-jar-check', action)
         end
         look_result = dothistimeout "look in ##{jar.id}", 10, /^Inside .*? you see [0-9]+ portions?/
         temp_ingredient_count[jar.id] = look_result.slice(/[0-9]+/).to_i
         ingredient_count[jar.id] = look_result.slice(/[0-9]+/).to_i
      end
      temp_ingredient_count[jar.id] = temp_ingredient_count[jar.id] - 1
      found = true
   elsif bundle = all_sack_contents.call.find { |obj| (obj.name =~ /^bundle of (?:#{equivalent_ingredients.collect { |name| name.split(' ').join('s? ') }.join('|')})/) and (temp_ingredient_count[obj.id].nil? or temp_ingredient_count[obj.id] > 0) }
      if temp_ingredient_count[bundle.id].nil?
         if CharSettings['hide-bundle-check']
            action = proc { |server_string|
               if server_string =~ /^You.*?total of [0-9]+/
                  DownstreamHook.remove('hide-bundle-check')
                  nil
               else
                  server_string
               end
            }
            DownstreamHook.add('hide-bundle-check', action)
         end
         measure_result = dothis "measure ##{bundle.id}", /^You.*?total of [0-9]+/
         temp_ingredient_count[bundle.id] = measure_result.slice(/[0-9]+/).to_i
         ingredient_count[bundle.id] = measure_result.slice(/[0-9]+/).to_i
      end
      temp_ingredient_count[bundle.id] = temp_ingredient_count[bundle.id] - 1
      found = true
   end
   [ found, temp_claimed_ingredients, temp_ingredient_count ]
}

get_ingredient = proc { |ingredient_name|
   ingredient = nil
   equivalent_ingredients = (equivalent.find { |list| list.include?(ingredient_name) } || [ ingredient_name ])
   if ingredient = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name !~ bundled_herb) }
      dothistimeout "get ##{ingredient.id}", 10, get_regex
   elsif bundle = all_sack_contents.call.find { |obj| equivalent_ingredients.include?(obj.name) and (obj.name =~ bundled_herb) }
      dothistimeout "get ##{bundle.id}", 10, get_regex
      bundle_remove_result = dothistimeout 'bundle remove', 10, /^You (?:carefully )?remove|^Those were the last two|^You only have one/
      if bundle_remove_result =~ /^You only have one/
         correct_herb_count.delete(bundle.id)
         ingredient_count.delete(bundle.id)
         ingredient = bundle
      elsif correct_herb_count.include?(bundle.id)
         ingredient_count[bundle.id] = ingredient_count[bundle.id] - 1
         dothistimeout "put ##{bundle.id} in ##{herb_sack.call.id}", 10, put_regex
         if checkleft
            ingredient = GameObj.left_hand
         else
            echo 'error: left hand unexpectedly empty'
         end
      else
         measure_result = dothistimeout "measure ##{bundle.id}", 10, /^(?:You can't tell exactly, but the|The) .*? (?:has 1 bite|has 2 bites|looks like it has a few bites|looks like it has several bites|seems to have plenty of bites) left\./
         if measure_result =~ /1 bite/
            min_count = 1
            correct_herb_count.push(bundle.id)
         elsif measure_result =~ /2 bites/
            min_count = 2
            correct_herb_count.push(bundle.id)
         elsif measure_result =~ /a few bites/
            min_count = 3
            if ingredient_count[bundle.id].to_i > 4
               correct_herb_count.push(bundle.id)
            end
         elsif measure_result =~ /several bites/
            min_count = 5
            if ingredient_count[bundle.id].to_i > 10
               correct_herb_count.push(bundle.id)
            end
         elsif measure_result =~ /plenty of bites/
            min_count = 11
         else
            min_count = 0
            echo "error: unmatched measure result: #{measure_result.inspect}"
         end
         if ingredient_count[bundle.id].nil?
            ingredient_count[bundle.id] = min_count
         else
            ingredient_count[bundle.id] = [(ingredient_count[bundle.id] - 1), min_count].max
         end
         dothistimeout "put ##{bundle.id} in ##{herb_sack.call.id}", 10, put_regex
         if checkleft
            ingredient = GameObj.left_hand
         else
            echo 'error: left hand unexpectedly empty'
         end
      end
   elsif jar = all_sack_contents.call.find { |obj| obj.after_name =~ /containing (?:#{equivalent_ingredients.collect { |name| name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ') }.join('|')})/ }
      unless ingredient_count[jar.id].nil?
         ingredient_count[jar.id] = ingredient_count[jar.id] - 1
         ingredient_count.delete(jar.id) if ingredient_count[jar.id] < 1
      end
      dothistimeout "get ##{jar.id}", 10, get_regex
      dothistimeout "shake ##{jar.id}", 10, /^You .*shake/
      dothistimeout "put ##{jar.id} in ##{alchemy_sack.call.id}", 10, put_regex
      if checkleft
         ingredient = GameObj.left_hand
      else
         echo 'error: left hand unexpectedly empty'
      end
   elsif bundle = all_sack_contents.call.find { |obj| obj.name =~ /^bundle of (?:#{equivalent_ingredients.collect { |name| name.split(' ').join('s? ') }.join('|')})/ }
      unless ingredient_count[bundle.id].nil?
         ingredient_count[bundle.id] = ingredient_count[bundle.id] - 1
         ingredient_count.delete(bundle.id) if ingredient_count[bundle.id] < 2
      end
      dothistimeout "get ##{bundle.id}", 10, get_regex
      unbundle_result = dothistimeout 'bundle remove', 10, /^You remove|^Those were the last two/
      dothistimeout "put ##{bundle.id} in ##{alchemy_sack.call.id}", 10, put_regex
      if checkleft
         ingredient = GameObj.left_hand
      else
         echo 'error: left hand unexpectedly empty'
      end
   end
   ingredient
}

put_crap_away = proc {
   if (GameObj.right_hand.name =~ /ayanad crystals$/) or (GameObj.left_hand.name =~ /ayanad crystals$/)
      dothis "get crystal from my crystals", /You separate/
      dothis "put ##{GameObj.right_hand.id} in ##{alchemy_sack.call.id}", put_regex
      dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", put_regex
   end
   if checkright
      if is_reagent.call(GameObj.right_hand.name)
         dothis "put ##{GameObj.right_hand.id} in ##{alchemy_sack.call.id}", put_regex
      else
         dothis "put ##{GameObj.right_hand.id} in ##{loot_sack.call.id}", put_regex
      end
   end
   if checkleft
      if is_reagent.call(GameObj.left_hand.name)
         dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", put_regex
      else
         dothis "put ##{GameObj.left_hand.id} in ##{loot_sack.call.id}", put_regex
      end
   end
}

recursive_padding = 0
recursive_check_recipe = proc { |recipe,tracker,top_level|
   recipe_start = Time.now
   respond "#{''.ljust(recursive_padding)}start recipe: #{recipe[:product]}" if $alchemy_debug
   recursive_padding += 3
   recipe[:steps].each { |step|
      step_start = Time.now
      respond "#{''.ljust(recursive_padding)}start step: #{step}" if $alchemy_debug
      recursive_padding += 3
      if step =~ /^(?:add|grind|extract|distill|separate)\s+(.*)/
         ingredient_name = $1
         if step =~ /^grind/
            unless all_sack_contents.call.any? { |obj| obj.noun == 'mortar' }
               tracker[:error]['mortar'] = 1
            end
            if Char.prof == 'Wizard'
               tracker[:time] += 5
            else
               tracker[:time] += 25
            end
         elsif step =~ /^extract/
            tracker[:time] += 40
         elsif step =~ /^distill/
            tracker[:time] += 40
         end
         if tracker[:extra_ingredients].include?(ingredient_name)
            tracker[:extra_ingredients].delete_at(tracker[:extra_ingredients].index(ingredient_name))
         else
            found_this, temp_claimed_ingredients, temp_ingredient_count = check_ingredient.call(ingredient_name, tracker[:claimed_ingredients].dup, tracker[:ingredient_count].dup)
            if found_this
               tracker[:claimed_ingredients] = temp_claimed_ingredients
               tracker[:ingredient_count] = temp_ingredient_count
               tracker[:found][ingredient_name] = tracker[:found][ingredient_name].to_i + 1
               if $alchemy_reagent_op_cost[ingredient_name]
                  tracker[:cost] += trading_sell.call($alchemy_reagent_op_cost[ingredient_name])
               end
            else
               support_recipe_list = $alchemy_recipes.find_all { |r| r[:product] == ingredient_name }
               if support_recipe_list.length > 0
                  tracker_list = Array.new
                  for support_recipe in support_recipe_list
                     temp_tracker = { :error => tracker[:error].dup, :recipe_count => tracker[:recipe_count].dup, :claimed_ingredients => tracker[:claimed_ingredients].dup, :ingredient_count => tracker[:ingredient_count].dup, :extra_ingredients => tracker[:extra_ingredients].dup, :found => tracker[:found].dup, :buy => tracker[:buy].dup, :forage => tracker[:forage].dup, :kill_for => tracker[:kill_for].dup, :steps => tracker[:steps].dup, :prepare_steps => tracker[:prepare_steps].dup, :finish_steps => tracker[:finish_steps].dup, :cost => tracker[:cost], :time => tracker[:time], :itime => tracker[:itime].dup, :icost => tracker[:icost].dup }
                     temp_tracker = recursive_check_recipe.call(support_recipe.dup, temp_tracker, _top_level=false)
                     tracker_list.push(temp_tracker)
                     ingredient_count.each_pair { |ingredient_id,count| tracker[:ingredient_count][ingredient_id] ||= count }
                  end
                  tracker_list.sort! { |a,b| (a[:cost] + (a[:time] * CharSettings['cost-per-second'])) <=> (b[:cost] + (b[:time] * CharSettings['cost-per-second'])) }
                  unless tracker = tracker_list.find { |t| t[:error].empty? }
                     tracker_list.sort! { |a,b|
                        ae = 0
                        a[:error].values.each { |v| ae += v }
                        be = 0
                        b[:error].values.each { |v| be += v }
                        ae <=> be
                     }
                     tracker = tracker_list.first
                  end
               else
                  tracker[:error][ingredient_name] = tracker[:error][ingredient_name].to_i + 1
               end
            end
         end
      elsif step =~ /^buy\s+.*?from\s+(.*)/
         place = $1
         room_list = where_is.call(place)
         if room_list.empty?
            tracker[:error]["#{place} to buy #{recipe[:product]}"] = tracker[:error]["#{place} to buy #{recipe[:product]}"].to_i + 1
         else
            unless tracker[:buy].keys.any? { |key| key =~ /^#{place};/ }
               foo = tavel_time.call(room_list.first) * 2
               tracker[:time] += foo
               tracker[:itime][recipe[:product]] = tracker[:itime][recipe[:product]].to_i + foo
            end
            foo = trading_buy.call(recipe[:cost].to_i)
            tracker[:cost] += foo
            tracker[:icost][recipe[:product]] += foo
            tracker[:buy]["#{place};#{recipe[:product]}"] = tracker[:buy]["#{place};#{recipe[:product]}"].to_i + 1
         end
      elsif step =~ /^forage( in sunlight| in moonlight)?/
         light = $1
         room_list = where_is.call(recipe[:product])
         if room_list.empty?
            tracker[:error][recipe[:product]] = tracker[:error][recipe[:product]].to_i + 1
         elsif (light == ' in sunlight') and is_moonlight.call
            tracker[:error]["sunlight to forage for #{recipe[:product]}"] = tracker[:error]["sunlight to forage for #{recipe[:product]}"].to_i + 1
         elsif (light == ' in moonlight') and is_sunlight.call
            tracker[:error]["moonlight to forage for #{recipe[:product]}"] = tracker[:error]["moonlight to forage for #{recipe[:product]}"].to_i + 1
         else
            if tracker[:forage][recipe[:product]].nil?
               foo = tavel_time.call(room_list.first) * 2
               tracker[:time] += foo
               tracker[:itime][recipe[:product]] = tracker[:itime][recipe[:product]].to_i + foo
            end
            CharSettings['forage time'] ||= Hash.new
            if CharSettings['forage time'][recipe[:product]].nil?
               CharSettings['forage time'][recipe[:product]] = [ 1, 1 ]
            end
            foo = CharSettings['forage time'][recipe[:product]][0] / CharSettings['forage time'][recipe[:product]][1].to_f
            tracker[:time] += foo
            tracker[:itime][recipe[:product]] = tracker[:itime][recipe[:product]].to_i + foo
            tracker[:forage][recipe[:product]] = tracker[:forage][recipe[:product]].to_i + 1
         end
      elsif step =~ /^kill\s+(.*)/
         npc = $1
         room_list = where_is.call(npc)
         if room_list.empty?
            tracker[:error][recipe[:product]] = tracker[:error][recipe[:product]].to_i + 1
            # tracker[:error][npc] = tracker[:error][npc].to_i + 1
         else
            if CharSettings['attack-script']
               tracker[:kill_for][npc] ||= Hash.new
               if tracker[:kill_for][npc].empty?
                  foo = tavel_time.call(room_list.first) * 2
                  tracker[:time] += foo
                  tracker[:itime][recipe[:product]] = tracker[:itime][recipe[:product]].to_i + foo
               end
               CharSettings['kill time'] ||= Hash.new
               CharSettings['kill time'][npc] ||= Hash.new
               if CharSettings['kill time'][npc][recipe[:product]].nil?
                  CharSettings['kill time'][npc][recipe[:product]] = [ 1, 1 ]
               end
               foo = CharSettings['kill time'][npc][recipe[:product]][0] / CharSettings['kill time'][npc][recipe[:product]][1].to_f
               tracker[:time] += foo
               tracker[:itime][recipe[:product]] = tracker[:itime][recipe[:product]].to_i + foo
               tracker[:kill_for][npc][recipe[:product]] = tracker[:kill_for][npc][recipe[:product]].to_i + 1
            else
               tracker[:error]['attack-script'] = 1
            end
         end
      elsif step =~ /^light/
         unless (checkroom == '[A Secluded Corner]') or GameObj.room_desc.any? { |obj| obj.noun == 'cauldron' } or GameObj.loot.any? { |obj| obj.noun =~ cauldron_noun } or all_sack_contents.call.any? { |obj| obj.noun =~ cauldron_noun }
            tracker[:error]['cauldron'] = 1
         end
      elsif step =~ /^special/
         if vial = all_sack_contents.call.find { |obj| obj.name =~ sea_water_vial }
            tracker[:found][vial.name] = 1
         else
            tracker[:error]['vial for sea water'] = 1
         end
         if flask = all_sack_contents.call.find { |obj| obj.name =~ sea_water_flask }
            tracker[:found][flask.name] = 1
         else
            tracker[:error]['flask for sea water'] = 1
         end
         tracker[:time] += 40
      elsif step =~ /^simmer/
         tracker[:time] += 20
      elsif step =~ /^boil/
         tracker[:time] += 20
      elsif step =~ /^chant/
         tracker[:time] += 30
      elsif step =~ /^infuse/
         tracker[:time] += 15
         unless gld.call['alchemy'][:rank].to_i >= 30
            tracker[:error]['alchemy infuse'] = 1
         end
      elsif step =~ /^channel/
         tracker[:time] += 30
      elsif step =~ /^seal/
         tracker[:time] += 26
      elsif step =~ /^refract (moonlight|sunlight) through (.* lens)$/
         light = $1
         lens = $2
         unless all_sack_contents.call.any? { |obj| obj.name == lens }
            tracker[:error][lens] = 1
         end
         if (light == 'sunlight') and is_moonlight.call
            tracker[:error]['sunlight'] = 1
         elsif (light == 'moonlight') and is_sunlight.call
            tracker[:error]['moonlight'] = 1
         end
         tracker[:time] += 10
      else
         echo "warning: unkown step: #{step}"
      end
      recursive_padding -= 3
      respond "#{''.ljust(recursive_padding)}end step: #{step}: #{Time.now - step_start}" if $alchemy_debug
   }
   if top_level
      tracker[:recipe_count][recipe[:product]] = tracker[:recipe_count][recipe[:product]].to_i + 1
      recipe[:steps].each { |step| tracker[:finish_steps].push(step) unless step =~ /^buy|^forage|^kill/ }
   else
      recipe[:steps].each { |step| tracker[:prepare_steps].push(step) unless step =~ /^buy|^forage|^kill/ }
   end
   recipe[:steps].each { |step| tracker[:steps].push(step) unless step =~ /^buy|^forage|^kill/ }
   if recipe[:product] =~ /^(?:s'|t')?ayanad crystal$/
      tracker[:extra_ingredients].push(recipe[:product])
   end
   recursive_padding -= 3
   respond "#{''.ljust(recursive_padding)}end recipe: #{recipe[:product]}: #{Time.now - recipe_start}" if $alchemy_debug
   tracker
}

check_recipe = proc { |args|
   if args[:name]
      recipe_list = $alchemy_recipes.find_all { |recipe| recipe[:product] == args[:name] }
   elsif args[:names]
      recipe_list = $alchemy_recipes.find_all { |recipe| args[:names].include?(recipe[:product]) }
   elsif args[:recipe]
      recipe_list = [ args[:recipe] ]
   elsif args[:recipes]
      recipe_list = args[:recipes]
   end
   tracker = { :error => Hash.new, :recipe_count => Hash.new, :claimed_ingredients => Array.new, :ingredient_count => ingredient_count.dup, :extra_ingredients => Array.new, :found => Hash.new, :buy => Hash.new, :forage => Hash.new, :kill_for => Hash.new, :steps => Array.new, :prepare_steps => Array.new, :finish_steps => Array.new, :cost => 0, :time => 0, :itime => Hash.new, :icost => Hash.new }
   args[:reps] ||= 1
   args[:reps].times {
      if recipe_list.length > 0
         tracker_list = Array.new
         for recipe in recipe_list
            temp_tracker = { :error => tracker[:error].dup, :recipe_count => tracker[:recipe_count].dup, :claimed_ingredients => tracker[:claimed_ingredients].dup, :ingredient_count => tracker[:ingredient_count].dup, :extra_ingredients => tracker[:extra_ingredients].dup, :found => tracker[:found].dup, :buy => tracker[:buy].dup, :forage => tracker[:forage].dup, :kill_for => tracker[:kill_for].dup, :steps => tracker[:steps].dup, :prepare_steps => tracker[:prepare_steps].dup, :finish_steps => tracker[:finish_steps].dup, :cost => tracker[:cost], :time => tracker[:time], :itime => tracker[:itime].dup, :icost => tracker[:icost].dup }
            temp_tracker = recursive_check_recipe.call(recipe, temp_tracker, top_level=true)
            tracker_list.push(temp_tracker)
            ingredient_count.each_pair { |ingredient_id,count| tracker[:ingredient_count][ingredient_id] ||= count }
         end
         tracker_list.sort! { |a,b| (a[:cost] + (a[:time] * CharSettings['cost-per-second'])) <=> (b[:cost] + (b[:time] * CharSettings['cost-per-second'])) }
         tracker = tracker_list.find { |t| t[:error].empty? } || tracker_list.first
      else
         tracker[:error][recipe_name] = tracker[:error][recipe_name].to_i + 1
      end
   }
   fixed_buy = Hash.new
   tracker[:buy].each_pair { |where_what,how_many|
      where, what = where_what.split(';')
      fixed_buy[where] ||= Hash.new
      fixed_buy[where][what] = how_many
   }
   tracker[:buy] = fixed_buy
   tracker.delete(:claimed_ingredients)
   tracker.delete(:ingredient_count)
   tracker.delete(:extra_ingredients)
   tracker
}

other_check_recipe = proc { |recipe,repetitions|
   tracker = { :error => Hash.new, :recipe_count => Hash.new, :claimed_ingredients => Array.new, :ingredient_count => ingredient_count.dup, :extra_ingredients => Array.new, :found => Hash.new, :buy => Hash.new, :forage => Hash.new, :kill_for => Hash.new, :steps => Array.new, :prepare_steps => Array.new, :finish_steps => Array.new, :cost => 0, :time => 0, :itime => Hash.new, :icost => Hash.new }
   repetitions.times {
      tracker_list = Array.new
      temp_tracker = { :error => tracker[:error].dup, :recipe_count => tracker[:recipe_count].dup, :claimed_ingredients => tracker[:claimed_ingredients].dup, :ingredient_count => tracker[:ingredient_count].dup, :extra_ingredients => tracker[:extra_ingredients].dup, :found => tracker[:found].dup, :buy => tracker[:buy].dup, :forage => tracker[:forage].dup, :kill_for => tracker[:kill_for].dup, :steps => tracker[:steps].dup, :prepare_steps => tracker[:prepare_steps].dup, :finish_steps => tracker[:finish_steps].dup, :cost => tracker[:cost], :time => tracker[:time], :itime => tracker[:itime].dup, :icost => tracker[:icost].dup }
      temp_tracker = recursive_check_recipe.call(recipe, temp_tracker, top_level=true)
      tracker_list.push(temp_tracker)
      ingredient_count.each_pair { |ingredient_id,count| tracker[:ingredient_count][ingredient_id] ||= count }
      tracker_list.sort! { |a,b| (a[:cost] + (a[:time] * CharSettings['cost-per-second'])) <=> (b[:cost] + (b[:time] * CharSettings['cost-per-second'])) }
      tracker = tracker_list.find { |t| t[:error].empty? } || tracker_list.first
   }
   fixed_buy = Hash.new
   tracker[:buy].each_pair { |where_what,how_many|
      where, what = where_what.split(';')
      fixed_buy[where] ||= Hash.new
      fixed_buy[where][what] = how_many
   }
   tracker[:buy] = fixed_buy
   tracker.delete(:claimed_ingredients)
   tracker.delete(:ingredient_count)
   tracker.delete(:extra_ingredients)
   tracker
}

show_check = proc { |check_info|
   output = "\n"
   output.concat check_info[:recipe_count].collect { |n,c| if c == 1; n; else; "#{n} (#{c})"; end }.join(', ').to_s
   output.concat "\n"
   max_width = 0
   check_info[:found].each_pair { |n,c| max_width = [ max_width, n.sub(/s*\#.*$/, '').length ].max }
   check_info[:forage].each_pair { |n,c| max_width = [ max_width, n.sub(/s*\#.*$/, '').length ].max }
   check_info[:kill_for].each { |npc,foo| foo.each_pair { |n,c| max_width = [ max_width, n.sub(/s*\#.*$/, '').length ].max } }
   check_info[:buy].values.each { |place| place.each_pair { |n,c| max_width = [ max_width, n.sub(/s*\#.*$/, '').length ].max } }
   unless check_info[:found].empty?
      output.concat "   have:\n"
      check_info[:found].each_pair { |n,c|
         str = n.sub(/s*\#.*$/, '')
         str.concat " (#{c})" if c > 1
         output.concat "      #{str.ljust(max_width+8)}"
         if $alchemy_reagent_op_cost[n]
            output.concat add_commas.call(trading_sell.call($alchemy_reagent_op_cost[n])*c).rjust(7)
         else
            output.concat '      -'
         end
         output.concat "\n"
      }
   end
   unless check_info[:kill_for].empty?
      output.concat "   kill for:\n"
      check_info[:kill_for].each_pair { |npc,foo|
         foo.each_pair { |n,c|
            str = n.sub(/s*\#.*$/, '')
            str.concat " (#{c})" if c > 1
            output.concat "      #{str.ljust(max_width + 8)}"
            if bar = check_info[:itime][n]
               output.concat((bar/60.0).as_time)
            end
            output.concat "\n"
         }
      }
   end
   unless check_info[:forage].empty?
      output.concat "   forage:\n"
      check_info[:forage].each_pair { |n,c|
         str = n.sub(/s*\#.*$/, '')
         str.concat " (#{c})" if c > 1
         output.concat "      #{str.ljust(max_width + 8)}"
         if foo = check_info[:itime][n]
            output.concat((foo/60.0).as_time)
         end
         output.concat "\n"
      }
   end
   unless check_info[:buy].empty?
      output.concat "   buy:\n"
      check_info[:buy].values.each { |place|
         place.each_pair { |n,c|
            str = n.sub(/s*\#.*$/, '')
            str.concat " (#{c})" if c > 1
            output.concat "      #{str.ljust(max_width + 8)}"
            if foo = check_info[:icost][n]
               output.concat add_commas.call(foo).rjust(7)
            end
            output.concat "\n"
         }
      }
   end
   unless check_info[:error].empty?
      output.concat "   #{monsterbold_start}missing:#{monsterbold_end}\n"
      check_info[:error].each_pair { |n,c|
         output.concat "      #{n}"
         output.concat " (#{c})" if c > 1
         output.concat "\n"
      }
   end
   output.concat "\ncost: #{add_commas.call(check_info[:cost])}   time: #{(check_info[:time]/60.0).as_time}\n\n"
   if defined?(_respond)
      _respond output
   else
      $stdout.puts output rescue()
   end
}

do_steps = proc { |steps|
   error = false
   uber_return_room = nil
   while step = steps.shift
      if step == 'light'
         need_empty_flask = false
         wait_spirit = false
         temp_claimed_ingredients = Array.new
         temp_ingredient_count = ingredient_count.dup
         for sub_step in steps
            if sub_step =~ /^add\s+(.*)/
               ingredient_name = $1
               found, temp_claimed_ingredients, temp_ingredient_count = check_ingredient.call(ingredient_name,temp_claimed_ingredients,temp_ingredient_count)
               unless found
                  error = true
                  echo "error: missing #{ingredient_name}"
               end
            elsif sub_step == 'channel'
               wait_spirit = true
            elsif sub_step =~ /^(?:buy|forage|kill)/
               echo 'error: out of cheese'
               error = true
               break
            elsif sub_step == 'seal'
               break
            elsif sub_step =~ /^refract (moonlight|sunlight)/
               light = $1
               if (light == 'sunlight') and is_moonlight.call
                  echo 'error: missing sunlight'
                  error = true
                  break
               elsif (light == 'moonlight') and is_sunlight.call
                  echo 'error: missing moonlight'
                  error = true
                  break
               end
               unless is_workshop.call
                  uber_return_room = Room.current
                  get_cauldron.call
                  go_empty_workshop.call
               end
            end
         end
         if error
            break
         else
            if wait_spirit
               unless check_channel_spirit.call
                  echo 'waiting for spirit...'
                  sleep 0.3 until check_channel_spirit.call
               end
            end
            drop_cauldron.call
            unless mana >= 1
               echo 'waiting for mana...'
               wait_until { mana >= 1 }
            end
            light_result = dothis "light #{cauldron.noun || 'cauldron'}", /^You focus|^But that is already lit!$/
            if light_result =~ /^But that is already lit!$/
               force_drop_cauldron.call
               dothis "light #{cauldron.noun || 'cauldron'}", /^You focus|^But that is already lit!$/
            end
         end
      elsif step =~ /^(add|grind|extract|distill|separate)\s+(.*)/
         action = $1
         ingredient_name = $2
         unless ingredient = get_ingredient.call(ingredient_name)
            echo "error: missing #{ingredient_name}"
            error = true
            break
         end
         if action == 'add'
            dothis "put ##{ingredient.id} in #{cauldron.noun || 'cauldron'}", /^You place|^You pour/
            if GameObj.right_hand.name == 'empty flask'
               dothis "put ##{GameObj.right_hand.id} in ##{alchemy_sack.call.id}", put_regex
               need_empty_flask = true
            elsif GameObj.left_hand.name == 'empty flask'
               dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", put_regex
               need_empty_flask = true
            end
         elsif action == 'grind'
            if checkright
               dothis 'swap', /^You swap/
            end
            mortar = all_sack_contents.call.find { |obj| obj.noun == 'mortar' }
            dothis "get ##{mortar.id}", get_regex
            dothis "put ##{ingredient.id} in ##{mortar.id}", put_regex
            loop {
               haste = Spell[506]
               haste.cast if haste.known? and haste.affordable? and not haste.active?
               waitrt?
               grind_result = dothis "grind #{ingredient.noun} from my mortar", /^Roundtime. [0-9]+ sec\.$|appears to be as ground as it'?s going to get|^Grind what|^With what do you intend to grind/
               waitrt?
               if grind_result =~ /^With what do you intend to grind/
                  unless pestle = all_sack_contents.call.find { |obj| obj.noun == 'pestle' }
                     echo "error: missing pestle"
                     error = true
                     break
                  end
                  dothis "_drag ##{pestle.id} ##{mortar.id}", put_regex
               elsif grind_result =~ /appears to be as ground as it'?s going to get|^Grind what/
                  break
               end
            }
            break if error
            if mortar.contents.nil?
               dothis "look in ##{mortar.id}", /^In the .*? you see/
            end
            for item in mortar.contents
               next if item.noun == 'pestle'
               dothis "_drag ##{item.id} ##{alchemy_sack.call.id}", put_regex
            end
            dothis "put ##{mortar.id} in ##{alchemy_sack.call.id}", put_regex
         elsif action == 'extract'
            unless checkright
               dothis 'swap', /^You swap/
            end
            return_room = nil
            unless is_workshop.call
               return_room = Room.current
               get_cauldron.call
               go_empty_workshop.call
            end
            if is_workshop.call
               unless mana >= 10
                  echo 'waiting for mana...'
                  wait_until { mana >= 10 }
               end
               dothis 'alchemy extract', /^You carefully (?:pour|place)/
               result = nil
               900.times { 
                  sleep 0.1
                  break if result = clear.any? { |line| line =~ /Sensing the process nearing its end/ }
               }
               sleep 1
               waitrt?
               put_crap_away.call
               if return_room
                  start_script 'go2', [ return_room.id.to_s ]
                  wait_while { running?('go2') }
               end
               if result.nil?
                  echo "error: extract failed (game bug)"
                  error = true
                  break
               end
            else
               echo "error: failed to find workshop"
               error = true
               break
            end
         elsif action == 'distill'
            unless checkright
               dothis 'swap', /^You swap/
            end
            return_room = nil
            unless is_workshop.call
               return_room = Room.current
               get_cauldron.call
               go_empty_workshop.call
            end
            if is_workshop.call
               dothis 'alchemy distill', /^You select an unused/
               waitfor 'Sensing the process nearing its end'
               sleep 1
               waitrt?
               put_crap_away.call
               if return_room
                  start_script 'go2', [ return_room.id.to_s ]
                  wait_while { running?('go2') }
               end
            else
               echo "error: failed to find workshop"
               error = true
               break
            end
         elsif action == 'separate'
            noun = GameObj.right_hand.noun || GameObj.left_hand.noun
            dothis "get 1 #{noun.sub(/s$/, '')} from my #{noun}", /^You separate/
            put_crap_away.call
         end
      elsif step == 'boil'
         loop {
            unless mana >= 10
               echo 'waiting for mana...'
               wait_until { mana >= 10 }
            end
            boil_result = dothis 'alchemy boil', /^You focus on the [\w\s\-]+ (?:cauldron|vat|kettle|boiler) and push mana into it.  The flame beneath it (flickers briefly, but then dies down|quickly flares up wildly, bringing the contents to a rolling boil)\.$/
            waitrt?
            break if boil_result =~ /^You focus on the [\w\s\-]+ (?:cauldron|vat|kettle|boiler) and push mana into it.  The flame beneath it quickly flares up wildly, bringing the contents to a rolling boil\.$/
         }
      elsif step == 'simmer'
         loop {
            unless mana >= 10
               echo 'waiting for mana...'
               wait_until { mana >= 10 }
            end
            # simmer_result = dothis 'alchemy simmer', /^You focus on the [\w\s\-]+ (?:cauldron|vat|kettle|boiler) and gently push mana into it\.  The flame beneath it (flickers briefly, but then dies down|quickly flares to life, bringing the contents to a slow simmer)\.$/
            simmer_result = dothis 'alchemy simmer', /flickers briefly, but then dies down|quickly flares to life, bringing the contents to a slow simmer/
            waitrt?
            break if simmer_result =~ /quickly flares to life, bringing the contents to a slow simmer/
         }
      elsif step =~ /^chant /
         loop {
            # fixme: variable mana cost based on spell num?
            unless mana >= 10
               echo 'waiting for mana...'
               wait_until { mana >= 10 }
            end
            chant_result = dothis "alchemy #{step}", /^You extend/
            waitrt?
            break if chant_result =~ /^You extend your hands.*vanish into the solution/
         }
      elsif step =~ /^infuse/
         loop {
            unless mana >= 10
               echo 'waiting for mana...'
               wait_until { mana >= 10 }
            end
            dothis 'alchemy infuse', /^You focus/
            infuse_result = waitfor 'The translucent thread fades away.  You feel slightly drained from the ordeal.', 'Your concentration lapses and the translucent thread connecting you to the solution fades away.'
            waitrt?
            break if infuse_result == 'The translucent thread fades away.  You feel slightly drained from the ordeal.'
         }
      elsif step == 'channel'
         loop {
            unless check_channel_spirit.call
               echo 'waiting for spirit...'
               sleep 0.3 until check_channel_spirit.call
            end
            channel_result = dothis 'alchemy channel', /^You focus .*? and link your spirit|^You attempt to channel/
            waitrt?
            break if channel_result =~ /^You focus .*? and link your spirit/
         }
      elsif step =~ /^refract (?:moonlight|sunlight) through (.* lens)$/
         # >alchemy refract
         # You select an unused gem lens assembly and set it up on the brushed steel workbench.
         # You carefully set the sapphire lens within the assembly and adjust it, aiming the refracted sunlight into your iron cauldron.
         # The surface of the solution in the iron cauldron shimmers in response!
         lens_name = $1
         unless lens = all_sack_contents.call.find { |obj| obj.name == lens_name }
            echo "error: failed to find #{lens_name}"
            error = true
            break
         end
         dothistimeout "get ##{lens.id}", 10, get_regex
         dothistimeout 'alchemy refract', 10, /^The surface of the solution in .* shimmers in response!/
         waitrt?
         dothistimeout "put ##{lens.id} in ##{alchemy_sack.call.id}", 10, put_regex
      elsif step == 'seal'
         unless mana >= 20
            echo 'waiting for mana...'
            wait_until { mana >= 20 }
         end
         if need_empty_flask
            dothis "get empty flask from ##{alchemy_sack.call.id}", get_regex
         end
         fput "look in #{cauldron.noun || 'cauldron'}"
         dothis 'alchemy seal', /^You hold your hands over/
         nil until get =~ /You sense (?:that the ritual is complete|something amiss with the solution)/
         sleep 0.5
         waitrt?
         sleep 0.5
         put_crap_away.call
      elsif step == 'special'
         vial = all_sack_contents.call.find { |obj| obj.name =~ sea_water_vial }
         flask = all_sack_contents.call.find { |obj| obj.name =~ sea_water_flask }
         dothis "get ##{vial.id}", get_regex
         dothis "get ##{flask.id}", get_regex
         dothis "open ##{flask.id}", /^You gently twist the stopper on the flask|^It's already open\.$/
         pour_result = dothis "pour ##{flask.id} in ##{vial.id}", /^You pour|^It looks like your glass vial is already full\.$|^But your .*? flask is empty!$/
         if pour_result =~ /But your .*? flask is empty!/
            dothis "put ##{vial.id} in ##{alchemy_sack.call.id}", put_regex
            get_cauldron.call
            if room_id = where_is.call('alchemy sea water').first
               return_room = Room.current
               start_script 'go2', [ room_id.to_s ]
               wait_while { running?('go2') }
               dothis "harvest water with ##{flask.id}", /under water until it is filled|is already filled/
               dothis "get ##{vial.id}", get_regex
               dothis "harvest water with ##{vial.id}", /under water until it is filled|is already filled/
               start_script 'go2', [ return_room.id.to_s ]
               wait_while { running?('go2') }
            else
               echo 'error: failed to find a place to collect sea water'
               error = true
               break
            end
         end
         dothis "close ##{flask.id}", /^You draw up the slick crystal cork|^It's already corked\.$/
         dothis "put ##{flask.id} in ##{alchemy_sack.call.id}", put_regex
         unless is_workshop.call
            return_room = Room.current
            get_cauldron.call
            go_empty_workshop.call
         end
         if is_workshop.call
            unless mana >= 10
               echo 'waiting for mana...'
               wait_until { mana >= 10 }
            end
            dothis 'alchemy extract', /^You carefully (?:pour|place)/
            result = nil
            900.times { 
               sleep 0.1
               break if result = clear.any? { |line| line =~ /Sensing the process nearing its end/ }
            }
            sleep 1
            waitrt?
            dothistimeout "put ##{vial.id} in ##{alchemy_sack.call.id}", 3, put_regex
            put_crap_away.call
            if return_room
               start_script 'go2', [ return_room.id.to_s ]
               wait_while { running?('go2') }
            end
            if result.nil?
               echo "error: extract failed (game bug)"
               error = true
               break
            end
         else
            echo "error: failed to find workshop"
            error = true
            break
         end
      end
   end
   if uber_return_room
      get_cauldron.call
      start_script 'go2', [ uber_return_room.id.to_s ]
      wait_while { running?('go2') }
   end
   invalid_gld.call
   !error
}

forage = proc { |forage_list|
   get_cauldron.call
   if CharSettings['before-forage-script']
      start_script(CharSettings['before-forage-script'])
      wait_while { running?(CharSettings['before-forage-script']) }
   end
   start_forage_time = Time.now
   used_rooms = Array.new
   forage_result = nil
   sanct = Spell[213]
   for name,num in forage_list.dup
      break if (Time.now - start_forage_time) > CharSettings['max-forage-time']
      for room_num in where_is.call(name)
         break if (Time.now - start_forage_time) > CharSettings['max-forage-time']
         start_script 'go2', [ room_num.to_s ]
         wait_while { running? 'go2' }
         unless checkpcs
            start_time = Time.now
            found_count = 0
            sanct.cast if CharSettings['cast-sanctuary'] and sanct.known? and sanct.affordable?
            fput 'kneel'
            empty_hands
            loop {
               break if (Time.now - start_forage_time) > CharSettings['max-forage-time']
               if haste = Spell[506]
                  haste.cast if haste.known? and haste.affordable? and not haste.active?
               end
               if presence = Spell[402]
                  presence.cast if presence.known? and presence.affordable? and not presence.active?
               end
               if (id = GameObj.right_hand.id)
#                 dothis "put ##{id} in ##{herb_sack.call.id}", put_regex
                  dothis "put ##{id} in ##{alchemy_sack.call.id}", put_regex
               end
               if (id = GameObj.left_hand.id)
#                 dothis "put ##{id} in ##{herb_sack.call.id}", put_regex
                  dothis "put ##{id} in ##{alchemy_sack.call.id}", put_regex
               end
               forage_result = dothistimeout "forage for #{name.sub(/^(?:cluster|layer|mass|sprig|handful) of |^luminescent |^black\-tipped /, '').sub(/^(?:some fetid )/, 'some ')}", 10, /^You forage|^You make so much noise that only the dead would not notice you thrashing about in your unsuccessful search\.$|^You stumble about in a fruitless attempt at foraging\.$|you are unable to find anything useful|^As you carefully forage around you (can find no hint|see no evidence) of what you are looking for(?: right now, though you are fairly certain this is where it can be found)?\.|^You begin to forage around when your hand comes into contact with something that stabs you in the finger\.$|^As you forage around you suddenly feel a sharp pain in your right hand!|^You begin to forage around when suddenly you feel a burning sensation in your hand\.$|^You fumble about so badly in your search that you can only hope no one was watching you\.$/
               sleep 0.5
               waitrt?
               if forage_result =~ /^You forage briefly and manage to find/
                  if id = GameObj.right_hand.id
#                    dothis "put ##{id} in ##{herb_sack.call.id}", put_regex
                     dothis "put ##{id} in ##{alchemy_sack.call.id}", put_regex
                  end
                  if id = GameObj.left_hand.id
#                    dothis "put ##{id} in ##{herb_sack.call.id}", put_regex
                     dothis "put ##{id} in ##{alchemy_sack.call.id}", put_regex
                  end
                  if herb_doses[name]
                     forage_list[name] = forage_list[name] - herb_doses[name]
                     found_count += herb_doses[name]
                  else
                     forage_list[name] = forage_list[name] - 1
                     found_count += 1
                  end
                  if forage_list[name] < 1
                     break
                  end
               elsif forage_result =~ /^You begin to forage around when your hand comes into contact with something that stabs you in the finger./
                  waitrt?
                  unpoison = Spell[114]
                  unpoison.cast if unpoison.known? and unpoison.affordable?
               elsif forage_result =~ /^As you forage around you suddenly feel a sharp pain in your right hand!/
                  start_script 'useherbs'
                  wait_while { running? 'useherbs' }
               elsif forage_result.nil?  or (forage_result =~ /you are unable to find anything useful|^As you carefully forage around you (can find no hint|see no evidence) of what you are looking for(?: right now, though you are fairly certain this is where it can be found)?\./)
                  break
               end
            }
            fill_hands
            end_time = Time.now
            CharSettings['forage time'] ||= Hash.new
            if CharSettings['forage time'][name].nil?
               CharSettings['forage time'][name] = [ 1, 1 ]
            end
            CharSettings['forage time'][name][1] += found_count
            CharSettings['forage time'][name][0] += end_time - start_time
            fput 'stand'
            if forage_list[name] < 1
               forage_list.delete(name)
               break
            end
            break if forage_result =~ /though you are fairly certain this is where it can be found/
         end
         break if forage_result =~ /though you are fairly certain this is where it can be found/
      end
   end
   if CharSettings['after-forage-script']
      if room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
         start_script 'go2', [ room_id.to_s ]
         wait_while { running?('go2') }
      end
      start_script(CharSettings['after-forage-script'])
      wait_while { running?(CharSettings['after-forage-script']) }
   end
   forage_list
}

buy = proc { |shopping_list|
   empty_hands
   get_cauldron.call
   for place,hash in shopping_list.dup
      unless room_id = where_is.call(place).first
         echo "error: don't know where #{place} is"
         break
      end
      the_note_name = (note_name_from_place.call(Room[room_id].location) || note_name_from_place.call(place) || note_name.call)
      unless note = all_sack_contents.call.find { |obj| obj.name == the_note_name }
         echo "error: missing #{the_note_name}"
         break
      end
      start_script 'go2', [ room_id.to_s ]
      wait_while { running?('go2') }
      if place =~ /^(?:Icemule|River's Rest) empath guild entrance$/
         get_result = dothis "get ##{note.id}", get_regex
         for name,num in hash.dup
            if name == 'vial of faintly glowing aelotoi tears'
               num.times {
                  dothis 'buy aelotoi tears', /^A sales clerk .* Handing it to you/
                  dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", put_regex
               }
               shopping_list[place].delete(name)
            end
         end
         dothis "put ##{note.id} in ##{alchemy_sack.call.id}", put_regex
      else
         menu = read_menu.call
         get_result = dothis "get ##{note.id}", get_regex
         if get_result =~ /^Get what\?/
            echo "error: can't find bank note"
            break
         end
         for name,num in hash.dup
            unless order_number = menu[name].sub(/s*\#.*$/, '')
               if equivalent_names = equivalent.find { |list| list.include?(name) }
                  for ingredient_name in equivalent_names
                     break if order_number = menu[ingredient_name].sub(/s*\#.*$/, '')
                  end
               end
               unless order_number
                  echo "error: failed to find #{name} in the menu"
                  next
               end
            end
            if herb_doses[name]
               num = (num/herb_doses[name].to_f).ceil
            end
            (num/10).times {
               dothis "order #{10} of #{order_number}", /BUY/
               fput 'buy'
               dothis 'open my package', /^You open|^That is already open/
               # fixme: but nothing will fit
               # fixme: leaving the rest in the package.
               dothis "empty my package in ##{alchemy_sack.call.id}", /everything falls in/
               waitrt?
               dothis 'throw my package', /^You throw away/
               if herb_doses[name]
                  shopping_list[place][name] -= (herb_doses[name] * 10)
               else
                  shopping_list[place][name] -= 10
               end
            }
            num = num % 10
            if num > 1
               dothis "order #{num} of #{order_number}", /BUY/
               fput 'buy'
               dothis 'open my package', /^You open|^That is already open/
               dothis "empty my package in ##{alchemy_sack.call.id}", /everything falls in/
               waitrt?
               dothis 'throw my package', /^You throw away/
               if herb_doses[name]
                  shopping_list[place][name] -= (herb_doses[name] * num)
               else
                  shopping_list[place][name] -= num
               end
            elsif num == 1
               dothis "order #{order_number}", /BUY/
               fput 'buy'
               100.times { break if checkleft; sleep 0.1 }
               dothis "put ##{GameObj.left_hand.id} in ##{alchemy_sack.call.id}", put_regex
               if herb_doses[name]
                  shopping_list[place][name] -= (herb_doses[name] * 1)
               else
                  shopping_list[place][name] -= 1
               end
            end
            shopping_list[place].delete(name) if shopping_list[place][name] < 1
         end
         dothis "put ##{note.id} in ##{alchemy_sack.call.id}", put_regex
      end
      shopping_list.delete(place) if shopping_list[place].empty?
   end
   fill_hands
   shopping_list
}

kill_for = proc { |kill_for_list|
   get_cauldron.call
   if CharSettings['attack-script'].nil?
      echo 'error: no attack script is set up'
   elsif not kill_for_list.empty?
      if CharSettings['before-hunt-script']
         start_script(CharSettings['before-hunt-script'])
         wait_while { running?(CharSettings['before-hunt-script']) }
      end
      for npc,foo in kill_for_list.dup
         for ingredient_name,count in foo.dup
            recipe_list = $alchemy_recipes.find_all { |r| (r[:product] == ingredient_name) and (r[:steps].first =~ /^kill/) }
            target_list = recipe_list.collect { |r| /^kill\s+(.+)/.match(r[:steps].first).captures.first }
            wander_room_list = where_is.call(npc).collect { |num| num.to_s }
            start_kill_room = wander_room_list.first
            if start_kill_room
               current_ingredient_count = start_ingredient_count = all_sack_contents.call.find_all { |obj| obj.name == ingredient_name }.length
               start_script 'go2', [ start_kill_room.to_s ]
               wait_while { running?('go2') }
               start_time = Time.now
               $alchemy_abort_room = false
               $alchemy_abort_hunt = false
               start_hunt_time = Time.now
               while (Time.now - start_hunt_time) < CharSettings['max-hunt-time']
                  wander.call
                  sleep 0.1
                  next if checkpcs
                  next if GameObj.loot.find { |obj| (obj.noun == 'disk') and (obj.name !~ /#{Char.name}/) }
                  if GameObj.npcs.nil?
                     sleep 0.1 + (rand(10)/10.0)
                     next if GameObj.npcs.nil?
                  end
                  while (Time.now - start_hunt_time) < CharSettings['max-hunt-time']
                     target_ids = GameObj.npcs.find_all { |npc| target_list.include?(npc.name) and (npc.status !~ /dead/) }.collect { |npc| npc.id }
                     if target_ids.length > 0
                        if checkrt > 0 or checkcastrt > 0
                           sleep 0.1
                        else
                           start_script(CharSettings['attack-script'], target_ids)
                           wait_while { running?(CharSettings['attack-script']) }
                           if $alchemy_abort_room or $alchemy_abort_hunt
                              $alchemy_abort_room = false
                              break
                           end
                        end
                     else
                        break
                     end
                     if $alchemy_abort_hunt
                        $alchemy_abort_hunt = false
                        break
                     end
                  end
                  current_ingredient_count = all_sack_contents.call.find_all { |obj| obj.name == ingredient_name }.length
                  break unless current_ingredient_count < start_ingredient_count + count
                  break if Time.now - start_time > CharSettings['max-hunt-time']
               end
               end_time = Time.now
               CharSettings['kill time'] ||= Hash.new
               CharSettings['kill time'][npc] ||= Hash.new
               if CharSettings['kill time'][npc][ingredient_name].nil?
                  CharSettings['kill time'][npc][ingredient_name] = [ 1, 1 ]
               end
               CharSettings['kill time'][npc][ingredient_name][0] += (end_time - start_time)
               CharSettings['kill time'][npc][ingredient_name][1] += (current_ingredient_count - start_ingredient_count)
               kill_for_list[npc][ingredient_name] = kill_for_list[npc][ingredient_name] - (current_ingredient_count - start_ingredient_count)
               kill_for_list[npc].delete(ingredient_name) if kill_for_list[npc][ingredient_name] < 1
               kill_for_list.delete(npc) if kill_for_list[npc].empty?
            else
               echo 'error: kill: failed to find starting room'
            end
         end
      end
      if CharSettings['after-hunt-script']
         if room_id = where_is.call("#{Char.prof.downcase} alchemy administrator").first
            start_script 'go2', [ room_id.to_s ]
            wait_while { running?('go2') }
         end
         start_script(CharSettings['after-hunt-script'])
         wait_while { running?(CharSettings['after-hunt-script']) }
      end
   end
   kill_for_list
}

go_get_crap = proc { |check_info|
   error = false
   unless check_info[:forage].empty? and check_info[:kill_for].empty? and check_info[:buy].empty?
      unless check_info[:kill_for].empty?
         check_info[:kill_for] = kill_for.call(check_info[:kill_for])
         unless check_info[:kill_for].empty?
            echo "error: failed to find: #{check_info[:kill_for].values.inspect}"
            error = true
         end
      end
      unless error or check_info[:forage].empty?
         check_info[:forage] = forage.call(check_info[:forage])
         unless check_info[:forage].empty?
            echo "error: failed to find: #{check_info[:forage].inspect}"
            error = true
         end
      end
      unless error or check_info[:buy].empty?
         check_info[:buy] = buy.call(check_info[:buy])
         unless check_info[:buy].empty?
            echo "error: failed to buy: #{check_info[:buy].inspect}"
            error = true
         end
      end
   end
   !error
}

do_task_assembly = proc {
   error = false
   return_room = Room.current
   empty_hands
   get_cauldron.call
   if room_id = where_is.call("#{Char.prof.downcase} alchemy cleaning supplies").first
      start_script 'go2', [ room_id.to_s ]
      wait_while { running?('go2') }
      dothis 'get cloth', /^You take/
   else
      echo 'error: failed to find cleaning supplies'
      error = true
   end
   unless error
      room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
      if room_list.length > 0
         haste = Spell[506]
         for room_id in room_list
            start_script 'go2', [ room_id.to_s ]
            wait_while { running?('go2') }
            haste.cast if haste.known? and haste.affordable? and not haste.active?
            clean_result = dothis 'polish ass', /You have|Perhaps you should check another workshop/
            waitrt?
            break if clean_result =~ /You have completed/
         end
         fput 'put cloth'
      else
         echo 'error: failed to find workshop'
         error = true
      end
   end
   fill_hands
   unless Room.current == return_room
      start_script 'go2', [ return_room.id.to_s ]
      wait_while { running?('go2') }
   end
   invalid_gld.call
   !error
}

do_task_distill = proc {
   return_room = nil
   unless is_workshop.call
      return_room = Room.current
      get_cauldron.call
      go_empty_workshop.call
   end
   if is_workshop.call
      haste = Spell[506]
      loop {
         haste.cast if haste.known? and haste.affordable? and not haste.active?
         dothis "pour alembic", /^You collect/
         sleep 2
         waitrt?
         haste.cast if haste.known? and haste.affordable? and not haste.active?
         dothis "light alembic", /^You focus/
         waitfor "pressure within it builds"
         haste.cast if haste.known? and haste.affordable? and not haste.active?
         dothis "turn alembic", /^Turning a mithril lever/
         waitfor "pressure within it builds"
         haste.cast if haste.known? and haste.affordable? and not haste.active?
         dothis "turn alembic", /^Turning a mithril lever/
         waitfor "the flame beneath it suddenly dies down"
         haste.cast if haste.known? and haste.affordable? and not haste.active?
         dothis "clean alembic", /^Using a barrel of water/
         sleep 2
         waitrt?
         haste.cast if haste.known? and haste.affordable? and not haste.active?
         dothis "get alembic", /^Having cleaned the/
         line = waitfor "You have"
         waitrt?
         break if line == "[You have completed your training task.]"
      }
      unless Room.current == return_room
         start_script 'go2', [ return_room.id.to_s ]
         wait_while { running?('go2') }
      end
      invalid_gld.call
      true
   else
      echo 'error: failed to find workshop'
      false
   end
}

do_task_crucible = proc {
   error = false
   if room_id = where_is.call("#{Char.prof.downcase} alchemy cleaning supplies").first
      if Room.current.id == room_id
         return_room = nil
      else
         return_room = Room.current
         get_cauldron.call
         start_script 'go2', [ room_id.to_s ]
         wait_while { running?('go2') }
      end
      empty_hands
      dothistimeout 'get rag', 10, /^You take/
      haste = Spell[506]
      room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
      if room_list.length > 0
         for room_id in room_list
            start_script 'go2', [ room_id.to_s ]
            wait_while { running?('go2') }
            haste.cast if haste.known? and haste.affordable? and not haste.active?
            clean_result = dothistimeout 'clean crucible', 10, /You have|Perhaps you should check another workshop/
            waitrt?
            sleep 0.5
            break if clean_result =~ /You have completed/
         end
      else
         echo 'error: failed to find workshop'
         error = true
      end
      fput 'drop rag'
      fill_hands
      unless Room.current == return_room
         start_script 'go2', [ return_room.id.to_s ]
         wait_while { running?('go2') }
      end
   else
      echo 'error: failed to find cleaning supplies room'
      error = true
   end
   invalid_gld.call
   !error
}

do_task_sweep = proc {
   error = false
   if cleaning_supplies_room_id = where_is.call("#{Char.prof.downcase} alchemy cleaning supplies").first
      room_list = where_is.call("#{Char.prof.downcase} alchemy workshop")
      if room_list.length > 0
         return_room = Room.current
         get_cauldron.call
         start_script 'go2', [ cleaning_supplies_room_id.to_s ]
         wait_while { running?('go2') }
         empty_hands
         dothis 'get broom', /^You take/
         dothis 'get pan', /^You take/
         room_count = 0
         haste = Spell[506]
         location = Room[room_list.first].location
         room_list.delete_if { |room_id| Room[room_id].location != location }
         sweep_result = nil
         loop {
            for room_id in room_list
               start_script 'go2', [ room_id.to_s ]
               wait_while { running?('go2') }
               loop {
                  haste.cast if haste.known? and haste.affordable? and not haste.active?
                  sweep_result = dothis 'sweep dust', /^Roundtime|^Sweep what|^Your dust pan appears to be full\.|^But your dust pan is already full|^Someone else is already sweeping that pile of dust|^\.\.\.wait|^What did the dust ever do to you\?$/
                  sleep 0.5
                  waitrt?
                  break if sweep_result =~ /^Sweep what|^Your dust pan appears to be full\.$|^But your dust pan is already full|^Someone else is already sweeping that pile of dust|^What did the dust ever do to you\?$/
               }
               break if sweep_result =~ /^Your dust pan appears to be full\.$|^But your dust pan is already full\.$/
            end
            start_script 'go2', [ cleaning_supplies_room_id.to_s ]
            wait_while { running?('go2') }
            if sweep_result =~ /^Your dust pan appears to be full\.$|^But your dust pan is already full\.$/
               put_result = dothis 'put my pan in bin', /^.You have/
               fput 'put broom'
               if put_result == '[You have completed your training task.]'
                  fput 'put pan'
                  break
               end
               dothis 'get broom', /^You take/
            else
               fput 'put broom'
               fput 'get broom'
            end
         }
         start_script 'go2', [ return_room.id.to_s ]
         wait_while { running?('go2') }
         fill_hands
      else
         echo 'error: failed to find workshop'
         error = true
      end
   else
      echo 'error: failed to find cleaning supplies' 
      error = true
   end
   invalid_gld.call
   !error
}

do_task_grind = proc {
   if room_id = where_is.call("#{Char.prof.downcase} alchemy shop").first
      return_room = Room.current
      get_cauldron.call
      start_script 'go2', [ room_id.to_s ]
      wait_while { running?('go2') }
      haste = Spell[506]
      clerk = checknpcs.find { |npc_name| npc_name =~ /^clerk$|acolyte$|^hobgoblin$|^gnome$|^apothecary$|^apprentice$/ } || 'clerk'
      empty_hands
      result = dothis 'get mortars', /^You take|^You already have a stone mortar|^Get what\?/
      if result =~ /^Get what\?/
         result = dothis 'get stone mortar', /^You take|^You already have a stone mortar/
      end
      shelf = GameObj.room_desc.find { |obj| obj.noun == 'shelf' } || GameObj.loot.find { |obj| obj.noun == 'shelf' }
      loop {
         script.want_downstream = false
         script.want_downstream_xml = true
         contents_line = dothis "look on ##{shelf.id}", /On the .*? you see|There is nothing on there\.|^<pushBold\/>Special/
         if contents_line =~ /There is nothing on there\./
            script.want_downstream = true
            script.want_downstream_xml = false
            dothistimeout "ask #{clerk} about ingredients", 10, /^You ask the .*? about ingredients\.$/
            script.want_downstream = false
            script.want_downstream_xml = true
            contents_line = dothis "look on ##{shelf.id}", /On the .*? you see|There is nothing on there$|^<pushBold\/>Special/
         end
         script.want_downstream = true
         script.want_downstream_xml = false
         grindable_id, grindable_noun = /(?:you see|<pushBold\/>Special.*?<popBold\/>) .*?<a exist="(.*?)" noun="(.*?)"/.match(contents_line).captures[0..1]
         get_result = dothistimeout "get ##{grindable_id}", 10, /^You take/
         if get_result
            loop {         
               haste.cast if haste.known? and haste.affordable? and not haste.active?
               grind_result = dothistimeout "grind my #{grindable_noun}", 10, /^You take the stone pestle into your free hand and grind|ground as much as possible|as ground as it'?s going to get|^Grind what/
               waitrt?
               break if grind_result =~ /ground as much as possible|as ground as it'?s going to get|^Grind what/
            }
         end
         give_result = dothistimeout "give my mortar to #{clerk}", 10, /^\[You have/
         break unless give_result =~ /\[You have [0-9]+ repetitions? remaining\.\]/
      }
      fput 'put mortar'
      fill_hands
      unless Room.current == return_room
         start_script 'go2', [ return_room.id.to_s ]
         wait_while { running?('go2') }
      end
      invalid_gld.call
      true
   else
      echo 'error: failed to find alchemy shop'
      false
   end
}

do_task_grind_mine = proc {
   $alchemy_grind_history ||= Hash.new
   $alchemy_grind_history.delete_if { |recipe,time| time > Time.now + 600 }
   check_list = Array.new
   recipe_list = $alchemy_recipes.find_all { |recipe| (recipe[:steps].first =~ /^grind/) and not $alchemy_grind_history.keys.include?(recipe[:product]) }
   for recipe in recipe_list
      tracker = { :error => Hash.new, :recipe_count => Hash.new, :claimed_ingredients => Array.new, :ingredient_count => ingredient_count.dup, :extra_ingredients => Array.new, :found => Hash.new, :buy => Hash.new, :forage => Hash.new, :kill_for => Hash.new, :steps => Array.new, :prepare_steps => Array.new, :finish_steps => Array.new, :cost => 0, :time => 0, :itime => Hash.new, :icost => Hash.new }
      tracker = recursive_check_recipe.call(recipe, tracker, top_level=true)
      fixed_buy = Hash.new
      tracker[:buy].each_pair { |where_what,how_many|
         where, what = where_what.split(';')
         fixed_buy[where] ||= Hash.new
         fixed_buy[where][what] = how_many
      }
      tracker[:buy] = fixed_buy
      tracker.delete(:claimed_ingredients)
      tracker.delete(:ingredient_count)
      tracker.delete(:extra_ingredients)
      check_list.push(tracker)
   end
   check_list.delete_if { |check| !check[:error].empty? or check[:steps].first !~ /^grind/ }
   check_list.sort! { |a,b| (a[:cost] + (a[:time] * CharSettings['cost-per-second'])) <=> (b[:cost] + (b[:time] * CharSettings['cost-per-second'])) }
   result = nil
   empty_hands
   for check_info in check_list
      return_room = Room.current
      show_check.call(check_info)
      got_crap = go_get_crap.call(check_info)
      unless Room.current == return_room
         start_script 'go2', [ return_room.id.to_s ]
         wait_while { running?('go2') }
      end
      if got_crap
         do_steps.call(check_info[:steps])
         $alchemy_grind_history[check_info[:recipe_count].keys.first] = Time.now
         result = reget.reverse.find { |line| line =~ /^\[You have|as ground as it'?s going to get/ }
         break unless result =~ /remaining/
      end
   end
   fill_hands
   invalid_gld.call
   if result =~ /You have completed/
      true
   else
      false
   end
}

do_task = proc { |type|
   error = false
   if gld.call[type][:reps] > 0
      empty_hands
      if gld.call[type][:task] == 'visit a skilled master for a lesson'
         if room_id = where_is.call("#{Char.prof.downcase} alchemy masters").first
            start_script 'go2', [ room_id.to_s ]
            wait_while { running?('go2') }
            if checkpoison # fixme: failed
               echo "masters won't talk to you while you're poisoned..."
               wait_while { checkpoison }
               start_script 'go2', [ room_id.to_s ]
               wait_while { running?('go2') }
            end
            dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun}/
            while line = get
               if line =~ /First, we light the cauldron\.  Go ahead\.|Please #{XMLData.name}, LIGHT the cauldron/
                  fput 'light cauldron'
               elsif line =~ /Excellent, now try to extinguish it\.|Please #{XMLData.name}, EXTINGUISH the cauldron\./
                  fput 'extinguish cauldron'
               elsif line =~ /\[Use the ALCHEMY SEAL command to seal the solution inside the training cauldron\.\]|\[You can use the ALCHEMY verb to SEAL the mixture in the cauldron\.\]/
                  fput 'alchemy seal'
               elsif line =~ /try a recipe with (.*?) as a component/
                  required_step = $1.downcase
                  echo "required_step: #{required_step.inspect}" if $alchemy_debug
                  recipe_list = gld_suggestions.call[type][:recipes].dup
                  echo "recipe_list: #{recipe_list.inspect}" if $alchemy_debug
                  recipe_list.delete_if { |r| not r[:steps].any? { |step| step =~ /^#{required_step}/ } }
                  echo "recipe_list: #{recipe_list.inspect}" if $alchemy_debug
                  check_info = check_recipe.call(:recipes => recipe_list, :reps => 1)
                  if !check_info[:error].empty? or check_info[:steps].any? { |step| step =~ /^extract|^distill|^special/ } or not check_info[:buy].empty? or not check_info[:forage].empty? or not check_info[:kill_for].empty?
                     move 'out'
                     if ((silvers = check_silvers.call) > 0) and room_id = where_is.call('bank').first
                        start_script 'go2', [ room_id.to_s ]
                        wait_while { running?('go2') }
                        fput "deposit #{silvers}"
                     end
                     reps = [gld.call[type][:reps], 3].min
                     while reps > 0
                        check_info = check_recipe.call(:recipes => recipe_list, :reps => reps)
#                       echo "reps: #{reps.inspect}"
#                       echo "check_info: #{check_info.inspect}"
                        break if check_info[:error].empty?
                        reps -= 1
                     end
                     if reps < 1
                        echo 'error: failed to find a decent recipe (use ";alchemy suggest" to help figure out why)'
#                       echo "gld_suggestions.call[type][:recipes]: #{gld_suggestions.call[type][:recipes].inspect}"
                        sleep 0.5
                        error = true
                        break
                     end
                     show_check.call(check_info)
                     break unless go_get_crap.call(check_info)
                     go_empty_workshop.call
                     unless is_workshop.call
                        echo 'error: failed to find a workshop'
                        error = true
                        break
                     end
                     do_steps.call(check_info[:prepare_steps])
                     get_cauldron.call
                     if room_id = where_is.call("#{Char.prof.downcase} alchemy masters").first
                        start_script 'go2', [ room_id.to_s ]
                        wait_while { running?('go2') }
                        if checkpoison
                           echo "masters won't talk to you while you're poisoned..."
                           wait_while { checkpoison }
                           start_script 'go2', [ room_id.to_s ]
                           wait_while { running?('go2') }
                        end
                        dothistimeout "ask #{GameObj.npcs.last.noun} about training #{type}", 10, /^#{GameObj.npcs.last.noun}/
                     else
                        echo 'error: failed to find alchemy masters'
                        error = true
                        break
                     end
                  else
                     show_check.call(check_info)
                     do_steps.call(check_info[:steps])
                  end
               elsif line == '[You have completed your training task.]'
                  invalid_gld.call
                  move 'out'
                  if ((silvers = check_silvers.call) > 0) and room_id = where_is.call('bank').first
                     start_script 'go2', [ room_id.to_s ]
                     wait_while { running?('go2') }
                     fput "deposit #{silvers}"
                  end
                  break
               end
            end
         else
            echo 'error: failed to find alchemy masters'
            error = true
         end
      elsif gld.call[type][:task] =~ /^practice creating tough solutions|follow some tough recipes and create some items|^practice (?:distilling|extracting) for reagents/
         check_info = check_recipe.call(:recipes => gld_suggestions.call[type][:recipes], :reps => gld_suggestions.call[type][:reps])
         if check_info[:error].empty?
            get_cauldron.call
            show_check.call(check_info)
            if go_get_crap.call(check_info)
               go_empty_workshop.call
               if is_workshop.call
                  do_steps.call(check_info[:steps])
                  get_cauldron.call
               else
                  echo "error: failed to find workshop"
                  error = true
               end
            else
               error = true
            end
         else
            echo 'warning: failed to find a decent recipe (use ";alchemy suggest" to help figure out why)'
            error = true
         end
      elsif gld.call[type][:task] =~ /^visit the cauldron workshop and practice making solutions/
         check_info = check_recipe.call(:recipes => gld_suggestions.call[type][:recipes], :reps => gld_suggestions.call[type][:reps])
         if check_info[:error].empty?
            if cauldron_room_id = where_is.call("#{Char.prof.downcase} alchemy training cauldron").first
               get_cauldron.call
               show_check.call(check_info)
               if go_get_crap.call(check_info)
                  if check_info[:prepare_steps]
                     go_empty_workshop.call
                     do_steps.call(check_info[:prepare_steps])
                     get_cauldron.call
                     start_script 'go2', [ cauldron_room_id.to_s ]
                     wait_while { running?('go2') }
                     do_steps.call(check_info[:finish_steps])
                  else
                     start_script 'go2', [ cauldron_room_id.to_s ]
                     wait_while { running?('go2') }
                     show_check.call(check_info)
                     fput 'stance offensive' unless stance =~ /offensive/
                     do_steps.call(check_info[:steps])
                  end
               else
                  error = true
               end
            else
               echo "error: failed to find training cauldron"
               error = true
            end
         else
            echo 'warning: failed to find a decent recipe (use ";alchemy suggest" to help figure out why)'
            error = true
         end
      elsif gld.call[type][:task] == 'practice grinding various ingredients with a mortar and pestle'
         get_cauldron.call
         go_empty_workshop.call
         result = do_task_grind_mine.call
         error = !result
      elsif gld.call[type][:task] == 'polish tarnished lens assemblies and any nearby lenses in alchemy labs'
         result = do_task_assembly.call
         error = !result
      elsif gld.call[type][:task] == "grind some ingredients for the guild's supply"
         result = do_task_grind.call
         error = !result
      elsif gld.call[type][:task] == "distill water for the guild's supply"
         result = do_task_distill.call
         error = !result
      elsif gld.call[type][:task] == 'clean alchemic equipment in the labs'
         result = do_task_crucible.call
         error = !result
      elsif gld.call[type][:task] == 'sweep the alchemy labs'
         result = do_task_sweep.call
         error = !result
      end
      fill_hands
   end
   !error
}

top_off_jars = proc {
   empty_hands
   for jar in alchemy_sack.call.contents.find_all { |obj| obj.after_name =~ /^containing / }
      next if jar.after_name == 'containing fine white powder'
      got_jar = false
      for item in all_sack_contents.call.find_all { |obj| jar.after_name =~ /containing #{obj.name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ')}/ }
         unless got_jar
            dothis "get ##{jar.id}", get_regex
            got_jar = true
         end
         result = dothis "_drag ##{item.id} ##{jar.id}", /^You add|is full/
         if result =~ /is full/
            dothis "put ##{item.id} in ##{alchemy_sack.call.id}", put_regex
            break
         else
            ingredient_count[jar.id] = ingredient_count[jar.id] + 1 unless ingredient_count[jar.id].nil?
         end
      end
      if got_jar
         dothis "put ##{jar.id} in ##{alchemy_sack.call.id}", put_regex
      end
   end
   fill_hands
}

look_in_jars = proc {
   for jar in all_sack_contents.call.find_all { |obj| obj.after_name =~ /^containing / }
      next if jar.after_name == 'containing fine white powder'
      fput "look in ##{jar.id}"
   end
}

throw_away = proc {
   if room_id = where_is.call('trash').first
#     trash_items = loot_sack.call.contents.to_a.find_all { |obj| (obj.name =~ /^tincture of (?:acantha|tkaro|wolifrew|basal|ambrominas|ephlox|aloeas|cactacae|bolmara|pothinir|haphip|torban|calamia|sovyn|woth|brostheras|yabathilium|talneo)$|silvery potion|^flask of pure water$|^grot t'kel potion$|^spirit shard$|^handful of sea salt$|^some powdered|^some ground/) and (obj.name !~ /#{UserVars.needed_reagents}/) }
#     trash_items = [ loot_sack.call.contents.to_a + alchemy_sack.call.contents.to_a ].flatten.find_all { |obj| (obj.name =~ /^tincture of (?:acantha|tkaro|wolifrew|basal|ambrominas|ephlox|aloeas|cactacae|bolmara|pothinir|haphip|torban|calamia|sovyn|woth|brostheras|yabathilium|talneo)$|silvery potion|^flask of pure water$|^grot t'kel potion$|^spirit shard$|^handful of sea salt$|^some powdered|^some ground/) and (obj.name !~ /#{UserVars.needed_reagents}/) }
      trash_items = [ loot_sack.call.contents.to_a + alchemy_sack.call.contents.to_a ].flatten.find_all { |obj| (obj.name =~ /^tincture of (?:acantha|tkaro|wolifrew|basal|ambrominas|ephlox|aloeas|cactacae|bolmara|pothinir|haphip|torban|calamia|sovyn|woth|brostheras|yabathilium|talneo)$|^flask of pure water$|^spirit shard$|^handful of sea salt$|^some powdered|^some ground/) and (obj.name !~ /#{UserVars.needed_reagents}/) }
      unless trash_items.empty?
         start_script 'go2', [ room_id.to_s ]
         wait_while { running?('go2') }
         if trash_container = GameObj.loot.find { |obj| obj.noun =~ /^(?:receptacle|bin|barrel|trashcan)$/ }
            empty_hand
            for item in trash_items
               dothistimeout "get ##{item.id}", 3, get_regex
               dothistimeout "put ##{item.id} in ##{trash_container.id}", 3, put_regex
               if (GameObj.right_hand.id == item.id) or (GameObj.left_hand.id == item.id)
                  dothistimeout "put ##{item.id} in ##{lootsack.call.id}", 3, put_regex
               end
            end
            fill_hand
         end
      end
   else
      echo 'error: failed to find trash room'
   end
}

sell = proc {
#  sell_items = loot_sack.call.contents.to_a.find_all { |obj| obj.name =~ /^(?:iron wand|polished bloodwood wand)$/ }
   sell_items = loot_sack.call.contents.to_a.find_all { |obj| obj.name =~ /^(?:polished bloodwood wand)$/ }
   unless sell_items.empty?
      if room_id = where_is.call('pawnshop').first
         start_script 'go2', [ room_id.to_s ]
         wait_while { running?('go2') }
         empty_hand
         for item in sell_items
            fput "get ##{item.id}"
            fput "sell ##{item.id}"
            sleep 0.2
         end
         fill_hand
      else
         echo 'warning: failed to find a pawnshop within max-travel-time'
      end
   end
   sell_items = loot_sack.call.contents.to_a.find_all { |obj| obj.name =~ /^(?:pale green potion|dark shimmering oil|iridescent opal wand|some dull silvery dust|rohnuru potion|minor mana potion|sarmoc potion|minor mana potion|lesser mana potion|smooth crystalline wand|lesser health potion|glowing blue potion|clear potion|lesser mana regeneration potion|hazy glass vial|silvery potion|pale sea\-green potion|lesser mana potion|some pale glimmering dust|scintillating pale blue potion|smooth stone talisman|lesser mana-well potion|prismatic oil|glowing red potion|dark translucent crystal|foggy grey crystal|blue bubbling potion|sky-blue potion|aquamarine potion|shadowy dark crystal wand|greater mana-well potion|greater mana potion|greater mana regeneration potion)$/ or (obj.noun == 'vial' and obj.after_name == 'containing fine white powder') }
   unless sell_items.empty?
      if room_id = where_is.call('consignment').first
         start_script 'go2', [ room_id.to_s ]
         wait_while { running?('go2') }
         empty_hand
         for item in sell_items
            fput "get ##{item.id}"
            fput "sell ##{item.id}"
            sleep 0.2
         end
         fill_hand
      else
         echo 'warning: failed to find a consignment shop within max-travel-time'
      end
   end
}

buy_elusive = proc {
   unless UserVars.needed_reagents.nil? or UserVars.needed_reagents.empty?
      if room_id = where_is.call('reagent shop').first and (adj_room_id = Room[room_id].wayto.keys.first) and (way = Room[adj_room_id].wayto[room_id.to_s]) and (way.class == String)
         the_note_name = (note_name_from_place.call(Room[room_id].location) || note_name_from_place.call(place) || note_name.call)
         if note = all_sack_contents.call.find { |obj| obj.name == the_note_name }
            start_script 'go2', [ adj_room_id ]
            wait_while { running?('go2') }
            move way
            if table = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun == 'table' }
               count = Hash.new
               script.want_downstream_xml = true
               result = dothistimeout "look on ##{table.id}", 3, /^(?:<.*?>)?On the.*?you see/
               script.want_downstream_xml = false
               if table.contents.empty?
                  table_contents = Array.new
                  results = result.sub(/^.*?you see /, '')
                  while str = results.slice!(/.*?<a.*?\/a>/)
                     if str.sub(/^(?:, | and )/, '') =~ /^(.*?)<a exist="(.*?)" noun="(.*?)">(.*?)<\/a>(.*)$/
                        table_contents.push GameObj.new($2, $3, $4, $1.strip, $5.strip)
                     end
                  end
               else
                  table_contents = table.contents
               end
               unless table_contents.empty?
                  if table_contents.any? { |obj| obj.name =~ /#{UserVars.needed_reagents}/ }
                     empty_hands
                     dothistimeout "get ##{note.id}", 10, get_regex
                     for obj in table_contents
                        if obj.name =~ /#{UserVars.needed_reagents}/
                           unless count[obj.name]
                              count[obj.name] = all_sack_contents.call.find_all { |o| o.name == obj.name }.length
                              jar_list = all_sack_contents.call.find_all { |o| o.after_name =~ /containing #{obj.name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ')}/ }
                              for jar in jar_list
                                 if CharSettings['hide-jar-check']
                                    action = proc { |server_string|
                                       if server_string =~ /^Inside the .*? you see [0-9]+ portions?/
                                          DownstreamHook.remove('hide-jar-check')
                                          nil
                                       else
                                          server_string
                                       end
                                    }
                                    DownstreamHook.add('hide-jar-check', action)
                                 end
                                 look_result = dothistimeout "look in ##{jar.id}", 10, /^Inside .*? you see [0-9]+ portions?/
                                 count[obj.name] += look_result.slice(/[0-9]+/).to_i
                              end
                           end
                           if count[obj.name] < 20
                              did_something = true
                              count[obj.name] = count[obj.name].to_i + 1
                              fput 'unhide' if invisible?
                              fput "buy ##{obj.id}"
                              dothistimeout "put my #{obj.noun} in ##{alchemy_sack.call.id}", 10, put_regex
                           end
                        end
                     end
                     dothistimeout "put ##{note.id} in ##{alchemy_sack.call.id}", 10, put_regex
                     sleep 0.05
                     top_off_jars.call
                     empty_jar_list = alchemy_sack.call.contents.find_all { |obj| obj.noun =~ /^(?:jar|beaker|bottle)$/ and obj.after_name.nil? }
                     unless empty_jar_list.empty?
                        important_stuff = all_sack_contents.call.find_all { |obj| elusive_reagent_cost.keys.include?(obj.name) and not all_sack_contents.call.any? { |jar| jar.noun =~ /^(?:jar|beaker|bottle)$/ and jar.after_name =~ /containing #{obj.name.sub('some ', '(?:some )?').sub('handful of ', '(?:handful of )?').sub('sprig of ', '(?:sprig of )?').sub('tooth', '(?:teeth|tooth)').sub('leaf', '(?:leaf|leaves)').sub(/y\b/, '(?:y|ie)').split(' ').join('s? ')}/ } }
                        important_stuff_count = Hash.new
                        important_stuff.each { |stuff| important_stuff_count[stuff.name] = important_stuff_count[stuff.name].to_i + 1 }
                        important_stuff_count = important_stuff_count.sort { |a,b| b[1] <=> a[1] }.collect { |n| n[0] }
                        for empty_jar in empty_jar_list
                           if name = important_stuff_count.pop
                              dothistimeout "get ##{empty_jar.id}", 10, get_regex
                              for obj in all_sack_contents.call
                                 if obj.name == name
                                    result = dothistimeout "_drag ##{obj.id} ##{empty_jar.id}", 10, /^You add|^You put|is full/
                                    if result =~ /is full/
                                       dothistimeout "put ##{obj.id} in ##{alchemy_sack.call.id}", 10, put_regex
                                       break
                                    end
                                 end
                              end
                              dothistimeout "put ##{empty_jar.id} in ##{alchemy_sack.call.id}", 10, put_regex
                           end
                        end
                     end
                     fill_hands
                  end
               end
            else
               echo 'error: no table'
            end
         else
            echo "error: missing #{the_note_name}"
         end
      else
         echo 'error: failed to find a reagent shop'
      end
   end
}

if script.vars[1].downcase == 'set'
   fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
   if (script.vars[2] =~ /^(?:hide\-gld\-check|hide\-bundle\-check|hide\-jar\-check|cast\-sanctuary|buy\-crap|throw\-away\-crap|sell\-crap)$/i) and (script.vars[3] =~ /^(?:on|off|yes|no|true|false)$/i)
      CharSettings[script.vars[2].downcase] = fix_option[script.vars[3].downcase]
      echo 'setting saved'
   elsif (script.vars[2] =~ /^(?:max\-travel\-time|max\-hunt\-time|max\-forage\-time|cost\-per\-second)$/i) and (script.vars[3] =~ /^[0-9]+$/)
      CharSettings[script.vars[2].downcase] = script.vars[3].to_i
      echo 'setting saved'
   elsif (script.vars[2] =~ /^(?:attack\-script|before\-hunt\-script|after\-hunt\-script|before\-forage\-script|after\-forage\-script)$/i) and script.vars[3]
      CharSettings[script.vars[2].downcase] = script.vars[3]
      echo 'setting saved'
   elsif (script.vars[2].downcase == 'alchemysack') and script.vars[3]
      UserVars.alchemysack = script.vars[3..-1].join(' ')
      echo 'setting saved'
   elsif (script.vars[2].downcase == 'lootsack') and script.vars[3]
      UserVars.lootsack = script.vars[3..-1].join(' ')
      echo 'setting saved'
   elsif (script.vars[2].downcase == 'herbsack') and script.vars[3]
      UserVars.herbsack = script.vars[3..-1].join(' ')
      echo 'setting saved'
   else
      echo "you're doing it wrong; try #{$clean_lich_char}#{script.name} help"
   end
elsif script.vars[1].downcase == 'clear'
   if (script.vars[2] =~ /^(?:attack\-script|before\-hunt\-script|after\-hunt\-script|before\-forage\-script|after\-forage\-script)$/i)
      CharSettings[script.vars[2].downcase] = nil
      echo 'setting cleared'
   else
      echo "you're doing it wrong; try #{$clean_lich_char}#{script.name} help"
   end
elsif script.vars[1].downcase == 'add'
   if (script.vars[2].downcase == 'fav') and (search_string = script.vars[3..-1].join(' '))
      matching_recipes = $alchemy_recipes.find_all { |r| r[:spell] == search_string }.collect { |r| r[:product] }
      if matching_recipes.empty?
         matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /^#{search_string}$/i or r[:nick] =~ /^#{search_string}$/i }.collect { |r| r[:product] }
         if matching_recipes.empty?
            matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string}/i or r[:nick] =~ /#{search_string}/i }.collect { |r| r[:product] }
            if matching_recipes.empty?
               matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string.gsub(' ', '.*')}/i or r[:nick] =~ /#{search_string.gsub(' ', '.*')}/i }.collect { |r| r[:product] }
            end
         end
      end
      matching_recipes = matching_recipes | matching_recipes # remove duplicates
      if matching_recipes.length == 1
         recipe_name = matching_recipes.first
         if CharSettings['favorite-recipes'].include?(recipe_name)
            echo "#{recipe_name} is already a favorite recipe."
         else
            CharSettings['favorite-recipes'].push(recipe_name)
            set_needed_reagents.call
            echo "#{recipe_name} is now a favorite recipe."
         end
      elsif matching_recipes.length > 1
         output = "\nmatching recipes:\n"
         matching_recipes.each { |name| output.concat "   #{name}\n" }
         output.concat "\n"
         respond output
      else
         echo 'no matching recipe found.'
      end
   else
      echo "you're doing it wrong"
   end
elsif script.vars[1].downcase == 'del'
   if (script.vars[2].downcase == 'fav') and (search_string = script.vars[3..-1].join(' '))
      matching_recipes = $alchemy_recipes.find_all { |r| r[:spell] == search_string }.collect { |r| r[:product] }
      if matching_recipes.empty?
         matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /^#{search_string}$/i or r[:nick] =~ /^#{search_string}$/i }.collect { |r| r[:product] }
         if matching_recipes.empty?
            matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string}/i or r[:nick] =~ /#{search_string}/i }.collect { |r| r[:product] }
            if matching_recipes.empty?
               matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string.gsub(' ', '.*')}/i or r[:nick] =~ /#{search_string.gsub(' ', '.*')}/i }.collect { |r| r[:product] }
            end
         end
      end
      matching_recipes = matching_recipes | matching_recipes # remove duplicates
      if matching_recipes.length == 1
         recipe_name = matching_recipes.first
         if CharSettings['favorite-recipes'].include?(recipe_name)
            CharSettings['favorite-recipes'].delete(recipe_name)
            set_needed_reagents.call
            echo "#{recipe_name} is no longer a favorite recipe."
         else
            echo "#{recipe_name} is not favorite recipe."
         end
      elsif matching_recipes.length > 1
         output = "\nmatching recipes:\n"
         matching_recipes.each { |name| output.concat "   #{name}\n" }
         output.concat "\n"
         respond output
      else
         echo 'no matching recipe found.'
      end
   else
      echo "you're doing it wrong"
   end
elsif script.vars[1].downcase == 'suggest'
   output = "\n"
   for type in [ 'alchemy' , 'potions', 'trinkets' ]
      output.concat "\n#{type}:\n"
      if gld_suggestions.call[type][:recipes].nil? or gld_suggestions.call[type][:recipes].empty? or gld_suggestions.call[type][:reps].zero?
         output.concat "   (none)\n"
      else
         max_recipe_name = 0
         recipe_list = gld_suggestions.call[type][:recipes]
         recipe_list.each { |r| max_recipe_name = [max_recipe_name,r[:product].length].max }
         recipe_output_list = Array.new
         for recipe in recipe_list
            start = Time.now
            check = check_recipe.call(:recipe => recipe, :reps => gld_suggestions.call[type][:reps])
            echo "#{recipe[:product]}: #{Time.now - start}" if $alchemy_debug
            if check[:error].empty?
               recipe_output = "   #{monsterbold_start}#{recipe[:product].ljust(max_recipe_name)}#{monsterbold_end}"
            else
               recipe_output = "   #{recipe[:product].ljust(max_recipe_name)}"
            end
            recipe_output.concat "   ranks: #{recipe[:rank][0].to_s.rjust(2)}-#{recipe[:rank][1].to_s.rjust(2)}"
            recipe_output.concat "   cost: #{check[:cost].to_i.to_s.rjust(5)}   time: #{(check[:time]/60.0).as_time}"
            has_step = Array.new
            recipe[:steps].each { |step| if step =~ /^(boil|infuse|simmer|chant|distill|extract|channel)/ and not has_step.include?($1); has_step.push($1); end }
            recipe_output.concat "   includes: #{has_step.sort.join(', ')}" unless has_step.empty?
            recipe_output.concat "\n"
            unless check[:error].empty?
               check[:error].each_pair { |thing,count|
                  recipe_output.concat "   #{''.ljust(max_recipe_name)}   missing: #{thing} (#{count})\n"
               }
            end
            recipe_output_list.push([check[:cost], recipe_output])
         end
         recipe_output_list.sort { |a,b| a[0] <=> b[0] }.each { |o| output.concat(o[1]) }
         recipe_output_list = nil
      end
   end
   output.concat "\n"
   if defined?(_respond)
      _respond output
   else
      $stdout.puts output rescue()
   end
   close_sacks.call
elsif script.vars[1] =~ /^(check|make|prepare)$/i and not script.vars[2].nil?
   if $1.downcase == 'check'
      check_only = true
   else
      check_only = false
   end
   if $1.downcase == 'prepare'
      prepare_only = true
   else
      prepare_only = false
   end
   repetitions = (script.vars[2..-1].find { |var| var =~ /^[Xx][0-9]+$/ }.sub(/[Xx]/, '') || 1).to_i
   script.vars.delete_if { |line| line =~ /^[Xx]([0-9]+)$/ }
   search_string = script.vars[2..-1].join(' ')
   unless recipe_name = $alchemy_recipes.find { |r| r[:spell] == search_string }[:product]
      matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /^#{search_string}$/i or r[:nick] =~ /^#{search_string}$/i }.collect { |r| r[:product] }
      if matching_recipes.empty?
         matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string}/i or r[:nick] =~ /#{search_string}/i }.collect { |r| r[:product] }
         if matching_recipes.empty?
            matching_recipes = $alchemy_recipes.find_all { |r| r[:product] =~ /#{search_string.gsub(' ', '.*')}/i or r[:nick] =~ /#{search_string.gsub(' ', '.*')}/i }.collect { |r| r[:product] }
         end
      end
      matching_recipes = matching_recipes | matching_recipes # remove duplicates
      if matching_recipes.length == 1
         recipe_name = matching_recipes.first
      elsif matching_recipes.length > 1
         output = "\nmatching recipes:\n"
         matching_recipes.each { |name| output.concat "   #{name}\n" }
         output.concat "\n"
         respond output
         exit
      end
   end
   unless recipe_name
      echo 'no matching recipe'
      exit
   end
   check_info = check_recipe.call(:name => recipe_name, :reps => repetitions)
   show_check.call(check_info)
   if check_info[:error].empty? and not check_only
      echo 'starting in 3 seconds...'
      sleep 3
      empty_hands
      return_room = Room.current
      exit unless go_get_crap.call(check_info)
      unless Room.current == return_room
         start_script 'go2', [ return_room.id.to_s ]
         wait_while { running?('go2') }
      end
      if prepare_only
         do_steps.call(check_info[:prepare_steps])
      else
         do_steps.call(check_info[:steps])
      end
      get_cauldron.call
      fill_hands
      close_sacks.call
   end
   close_sacks.call
elsif script.vars[1].downcase == 'task' and not script.vars[2].nil?
   if script.vars[2].downcase == 'distill'
      do_task_distill.call
   elsif script.vars[2].downcase == 'assembly'
      do_task_assembly.call
   elsif script.vars[2].downcase == 'crucible'
      do_task_crucible.call
   elsif script.vars[2].downcase == 'grind'
      do_task_grind.call
   elsif script.vars[2].downcase == 'sweep'
      do_task_sweep.call
   elsif script.vars[2].downcase =~ /^grind\-?mine$/
      do_task_grind_mine.call
   elsif script.vars[2].downcase =~ /^(?:alchemy|potions|trinkets)$/
      do_administrator.call
      do_task.call(script.vars[2].downcase)
      do_administrator.call
   else
      echo 'unknown task'
   end
elsif script.vars[1].downcase == 'jar'
   top_off_jars.call
   look_in_jars.call
   close_sacks.call
elsif script.vars[1].downcase == 'buy'
   buy_elusive.call
   look_in_jars.call
   close_sacks.call
elsif script.vars[1].downcase == 'need'
   set_needed_reagents.call
elsif script.vars[1].downcase == 'auto'
   if script.vars[2].downcase =~ /^(alchemy|trinkets|potions)$/
      type_list = [ $1 ]
      if script.vars[3].downcase =~ /^(alchemy|trinkets|potions)$/
         type_list.push($1)
      end
   else
      type_list = [ 'alchemy', 'potions', 'trinkets' ]
   end
   set_needed_reagents.call if UserVars.needed_reagents.nil?
   empty_hands
   loop {
      do_administrator.call
      for type in type_list
         do_task.call(type)
      end
      get_cauldron.call
      sleep 0.5
      if CharSettings['throw-away-crap']
         throw_away.call
      end
      if CharSettings['sell-crap']
         sell.call
      end
      if ((silvers = check_silvers.call) > 0) and room_id = where_is.call('bank').first
         start_script 'go2', [ room_id.to_s ]
         wait_while { running?('go2') }
         fput "deposit #{silvers}"
      end
      # fixme: not sure what the real limit is..
      $last_alchemy_buy ||= Time.now - 481
      if CharSettings['buy-crap'] and (Time.now - $last_alchemy_buy) > 480
         buy_elusive.call
         $last_alchemy_buy = Time.now
      end
      sleep 0.5
   }
elsif script.vars[1].downcase == 'list'
   fix_option = { false => 'off', true => 'on' }
   output = "\n"
   output.concat "   cost-per-second:      #{CharSettings['cost-per-second']}\n"
   output.concat "   max-travel-time:      #{CharSettings['max-travel-time']}\n"
   output.concat "   max-hunt-time:        #{CharSettings['max-hunt-time']}\n"
   output.concat "   max-forage-time:      #{CharSettings['max-forage-time']}\n"
   output.concat "   hide-gld-check:       #{fix_option[CharSettings['hide-gld-check']]}\n"
   output.concat "   hide-bundle-check:    #{fix_option[CharSettings['hide-bundle-check']]}\n"
   output.concat "   hide-jar-check:       #{fix_option[CharSettings['hide-jar-check']]}\n"
   output.concat "   cast-sanctuary:       #{fix_option[CharSettings['cast-sanctuary']]}\n"
   output.concat "   buy-crap:             #{fix_option[CharSettings['buy-crap']]}\n"
   output.concat "   throw-away-crap:      #{fix_option[CharSettings['throw-away-crap']]}\n"
   output.concat "   sell-crap:            #{fix_option[CharSettings['sell-crap']]}\n"
   output.concat "   attack-script:        #{CharSettings['attack-script']}\n"
   output.concat "   before-hunt-script:   #{CharSettings['before-hunt-script']}\n"
   output.concat "   after-hunt-script:    #{CharSettings['after-hunt-script']}\n"
   output.concat "   before-forage-script: #{CharSettings['before-forage-script']}\n"
   output.concat "   after-forage-script:  #{CharSettings['after-forage-script']}\n"
   output.concat "\n"
   unless CharSettings['favorite-recipes'].empty?
      output.concat "   favorite-recipes:\n"
      for recipe_name in CharSettings['favorite-recipes']
         output.concat "      #{recipe_name}\n"
      end
      output.concat "\n"
   end
   respond output
elsif script.vars[1].downcase == 'sell'
   sell.call
else
   output = "\n"
   output.concat "setup:\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set alchemysack <container>      Where to put away reagents and alchemy equipment.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set lootsack <container>         Where to put away end-products and miscellaneous stuff.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set herbsack <container>         Where to put away herbs.\n"
   output.concat "\n"
   output.concat "   (the script will look for what it needs in all three of the above containers)\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set cost-per-second <#>          Used to convert time into silvers when finding the \n"
   output.concat "    #{''.rjust(script.name.length) }                                  fastest/cheapest recipe.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set max-travel-time <#>          Places that go2 thinks is more than # of seconds away\n"
   output.concat "    #{''.rjust(script.name.length) }                                  from your guild will be assumed to not exist.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set max-hunt-time <#>            Give up hunting for reagents after # seconds.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set hide-gld-check <on|off>      Hide spam from the script using the gld verb.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set hide-bundle-check <on|off>   Hide spam from the script measuring bundles.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set hide-jar-check <on|off>      Hide spam from the script measuring jars.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set cast-sanctuary <on|off>      Cast sanctuary before foraging in a room.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set buy-crap <on|off>            Buy things from the alchemist reagent shop (in auto mode).\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set throw-away-crap <on|off>     Throw away a pre-defined list (incomplete) of alchemy\n"
   output.concat "    #{''.rjust(script.name.length) }                                  byproducts that can't be sold (in auto mode).\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set sell-crap <on|off>           Sell alchemy products (in auto mode).\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set attack-script <scriptname>          A script you provide that will kill and loot the\n"
   output.concat "    #{''.rjust(script.name.length) }                                         monsters whose ids are passed to it.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set before-hunt-script <scriptname>     A script you provide that will get your hunting\n"
   output.concat "    #{''.rjust(script.name.length) }                                         gear out (or any other pre-hunt actions)\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set after-hunt-script <scriptname>      A script you provide that will put your gear away\n"
   output.concat "    #{''.rjust(script.name.length) }                                         (or any other post-hunt actions: make sure you\n"
   output.concat "    #{''.rjust(script.name.length) }                                         don't sell the reagents it just collected)\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set before-forage-script <scriptname>   A script you provide that does anything you might\n"
   output.concat "    #{''.rjust(script.name.length) }                                         need before going to to forage\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} set after-forage-script <scriptname>    A script you provide that does anything you might\n"
   output.concat "    #{''.rjust(script.name.length) }                                         need after going to to forage\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} clear <whatever>-script                 Clears one of the previous script settings\n"
   output.concat "\n"
   output.concat "commands:\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} list                              Show current settings.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} make <recipe>                     Follows the given recipe.\n"
   output.concat "   #{$clean_lich_char}#{script.name} make <recipe> x<repetitions>\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} prepare <recipe>                  Buys, forages, and makes all the requirements, so you\n"
   output.concat "   #{$clean_lich_char}#{script.name} prepare <recipe> x<repetitions>   can make the recipe later without having to run around.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} check <recipe>                    Gives the same summary as make, but does nothing.\n"
   output.concat "   #{$clean_lich_char}#{script.name} check <recipe> x<repetitions>\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} suggest                           Attempts to list the recipes you'll get ranks for\n"
   output.concat "    #{''.rjust(script.name.length) }                                   (and one of many possible reasons you can't use it).\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} jar                               Fills jars in your alchemy sack with loose items of\n"
   output.concat "    #{''.rjust(script.name.length) }                                   the same type.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} buy                               Buys reagents you need from the alchemist reagent shop\n"
   output.concat "    #{''.rjust(script.name.length) }                                   (up to a max of 20 of each item on you)\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} need                              Puts the names of all reagents you could use to get reps\n"
   output.concat "    #{''.rjust(script.name.length) }                                   from into a variable that can be accessed by other scripts\n"
   output.concat "    #{''.rjust(script.name.length) }                                   (in auto mode, this command is done for you).  loot-be-gone\n"
   output.concat "    #{''.rjust(script.name.length) }                                   uses this to automatically avoid selling things you need.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} add fav <recipename>              The reagents for the given recipe will be included in the\n"
   output.concat "    #{''.rjust(script.name.length) }                                   above \"need\" variable even if you can't get reps from it.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} del fav <recipename>              Undo the above commanmd.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} task alchemy                      Attempt to complete one task in general alchemy.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} task potions                      Attempt to complete one task in potions.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} task trinkets                     Attempt to complete one task in trinkets.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} task distill                      Does the \"distill water for the guild's supply\" task.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} task assembly                     Does the \"polish tarnished lens assemblies\" task.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} task grind                        Does the \"grind some ingredients for the guild's supply\" task.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} task grind-mine                   Does the \"grinding various ingredients\" task.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} task crucible                     Does the \"clean alchemic equipment\" task.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} task sweep                        Does the \"sweep the alchemy labs\" task.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} auto                              Attempts to do everything until you master.\n"
   output.concat "\n"
   output.concat "   #{$clean_lich_char}#{script.name} auto <alchemy|potions|trinkets>   Only work on the given area(s).\n"
   output.concat "\n"
   respond output 
end
