=begin
 
        bigshot.lic: the new optimus prime
 
        hunting script for hunting
 
              author: elanthia-online
        contributers: SpiffyJr, Tillmen, Kalros, Hazado, Tysong
                game: Gemstone
                tags: hunting
             version: 3.80
 
		Setup instructions: https://gswiki.play.net/Script_Bigshot
		To help contribute: https://github.com/elanthia-online/scripts
		Full Changelog: https://gswiki.play.net/Script_Bigshot_Changelog
		
		v3.81 (2019-09-06)
			-Fix for wands with extra descriptors in hand vs grab name
			-Add 1020 as an option for fleeing
		v3.80 (2019-08-01)
			-Exit cleanly from bounty mode
			-Don't count regenerating troll kings when deciding if there's enough enemies to flee
			-Treat intense shimmering circles like clouds when deciding to flee
			-Don't require Gtk if $bigshot_headless is defined
		v3.79 (2019-05-25)
			-Removed 309 from hardcoded selfcast list
		v3.78 (2019-05-10)
			-Missed a few settings for flying
		v3.77 (2019-05-10)
			-Added flying/!flying as command checks for attacks
		v3.76 (2018-07-04)
			-Fixed INCANT command to respect Spell.stance setting
		v3.75 (2018-07-02)
			-Fix ;bigshot bounty
			-Don't flee from your own group even if they're not hunting
		v3.74 (2018-04-30)
			-Added water as option for cmd_spell extra variable
		v3.73 (2018-04-22)
			-Add flee from webs option
			-Add 917 to not stance offensive if using incant
		v3.72 (2017-10-10)
			-Fix bug in berserk 
		v3.71 (2017-10-08)
			-Attack line now recognizes "wand" by itself
			-Fix GameObjAdd autostart
		v3.70 (2017-09-28)
			-Fix download loop of GameObjAdd.lic
		v3.69 (2016-09-20)
			-Wont stance offensive for the spell 703 anymore
			-Fixes for delayed looting
			-option to pull players to there feet, Defaults to on
			 Only pulls the player to there feet if their is an aggressive npc in the room with them
		v3.68 (2016-09-14)
			-option to stance defensive before looting if not all the creatures in room are dead
			-wracking option now will use "Symbol of Mana" for voln peoples :)
			-Performs the bless routine if needed when you wander or go to rest now
			-Added a delayed looting option
			 skips looting when creature still alive in the room or its been less than 15 seconds since the last creature died
			-Will now try to escape from the inside of a roa'ter if you get swallowed

=end
=begin	
		To do:
			Add more messaging for ambush checks (snipe, etc.)
			Add Stun Relief (108)|Undisease (113)|Unpoison (114) option for stunned group members
=end

unless Script.exists?('GameObjAdd')
	do_client(";repository download GameObjAdd.lic")
	wait_while { running?('repository') }
	do_client(";autostart add --global GameObjAdd")
	wait_while { running?('autostart') }
	pause 0.5
	do_client(";autostart add --global repository download-updates")
	wait_while { running?('autostart') }
	pause 0.5
	do_client(";repository set-updatable GameObjAdd.lic")
	wait_while { running?('repository') }
	pause 0.5
	do_client(";GameObjAdd")
	wait_while { running?('GameObjAdd') }
	pause 0.5
end


$bigshot_debug = false
$current_script_name = script.name
 
if $SAFE > 0
        echo "error: This script needs to be trusted to work. (;trust #{script.name})"
        exit
end

require 'drb'

BIGSHOT_VERSION = '3.80'
RALLY_TIME = 1
REST_INTERVAL = 60
$bigshot_quick = false
$rest_reason = nil
$not_hunting_reason = nil
$bigshot_status = nil
$bigshot_should_rest = false
$bigshot_aim = 0
$bigshot_ambush = 0
$bigshot_archery_aim = 0
$bigshot_archery_stuck_location = []
$bigshot_archery_location = nil
$bigshot_wand = 0
$bigshot_unarmed_tier = 1
$bigshot_unarmed_followup = false
$bigshot_unarmed_followup_attack = ""
$bigshot_flee = false
$bigshot_bless=[]
$bigshot_smite_list=[]
$companion ||= nil
$familiar = ""
$bigshot_adrenal_surge = Time.now + 301
$grouplist=[]
$bigshot_703_list=[]
$bigshot_1614_list=[]
$current_room_npcs=GameObj.npcs
$room_npcs_last_check=[]
$last_loot=nil
 
def spam
    def waitcastrt?
        return if Spell[515].active?
        if (XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f).abs)
        end
    end
 
    def waitrt?
        if (XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f).abs)
        end
    end
end
 
def unspam
    def waitcastrt?
        if (XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f + "0.6".to_f).abs)
        end
    end
 
    def waitrt?
        if (XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
            sleep((XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f + "0.6".to_f).abs)
        end
    end
end

bigshot_monitor = proc { |server_string|
	if server_string =~ /<a exist="\d+" noun="([a-zA-Z]*?)">[a-zA-Z]*?<\/a> leaps from hiding to attack!/i
		temp = $1
		if !$grouplist.any?{|s| s =~ /#{temp}/i}
			$ambusher_here = true
		end
	elsif server_string =~ /flies out of the shadows toward/i
		if server_string =~ /flies out of the shadows toward you/i
		elsif $grouplist.size == 0
			$ambusher_here = true
		end
	elsif server_string =~ /crimson mist.*?surround.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:corporeal plane!|vulnerable!)/i
		$bigshot_smite_list.push($1)
	elsif server_string =~ /crimson mist.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:returns to an ethereal state.|appears less vulnerable.)/i
		$bigshot_smite_list.delete($1)
	elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?is suddenly surrounded by a blood red haze./i
		$bigshot_703_list.push($1)
	elsif server_string =~ /The blood red haze dissipates from around.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?\./i
		$bigshot_703_list.delete($1)
	elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:visibly struggling against|in awe of) your radiant aura!/i
		$bigshot_1614_list.push($1)
	elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?recovers from being rebuked/i
		$bigshot_1614_list.delete($1)
	elsif server_string =~ /The.*sticks in.*\'s (.*)\!/i
		$bigshot_archery_stuck_location.push($1)
	elsif server_string =~ /You're now aiming at the (.*) of/i
		$bigshot_archery_location = $1
	elsif server_string =~ /You're now no longer aiming at anything in particular/i
		$bigshot_archery_location = nil
	elsif server_string =~ /but your attack has no effect!/i
		$bigshot_should_rest = true
		$rest_reason = "No blessing on weapon"
	elsif server_string =~ /Your <a exist="(.*?)" noun=".*?">.*?<\/a> returns to normal\./i
		$bigshot_bless.push($1)
	elsif server_string =~ /^You bolt/i
		$ambusher_here = false
		$bigshot_smite_list = []
		$bigshot_aim = 0
		$bigshot_ambush = 0
		$bigshot_archery_aim = 0
		$bigshot_archery_stuck_location = []
		$bigshot_unarmed_tier = 1
		$bigshot_unarmed_followup = false
		$bigshot_unarmed_followup_attack = ""
		$bigshot_703_list = []
		$bigshot_1614_list = []
		$bigshot_flee = false
	elsif server_string =~ /#{UserVars.op["flee_message"]}/i && UserVars.op["flee_message"] != ""
		$bigshot_flee = true
	end
	server_string
}
DownstreamHook.remove("#{script.name}_monitor")
DownstreamHook.add("#{script.name}_monitor", bigshot_monitor)
before_dying { DownstreamHook.remove("#{script.name}_monitor") }

before_dying { unspam() }
before_dying { $bigshot.gather_ammo }

class Event
    attr_accessor :type, :created_at, :room_id
    @@RECOGNIZED = [ :HUNTING_PREP_COMMANDS, :HUNTING_SCRIPTS_START, :CAST_SIGNS, :ATTACK, :PREP_REST, 
        :HUNTING_SCRIPTS_STOP, :RESTING_SCRIPTS_START, :RESTING_PREP_COMMANDS, :DISPLAY_WATCH ]
 
    def initialize( type, time_stamp, room_id )
        raise "Event type not recognized" unless @@RECOGNIZED.include?(type)
        @type       = type
        @created_at = time_stamp
        @room_id    = room_id
    end
 
    def stale?
        if( Room.current.id != @room_id || Time.now.to_i - @created_at > 15 )
            return true
        else
            return false
        end
    end
 
    def type
        return @type
    end
end
 
class Group
    include DRbUndumped
    attr_accessor :leader, :members
 
    def initialize()
        @members = Hash.new
    end
 
    def set_leader(leader)
        @leader = leader
    end
 
    def add_member(member)
        @members[member.name()] = member
    end
 
    def size()
        return @members.size
    end
 
    def get_names
        return @members.keys + [@leader.name]
    end
 
    def room_id()
        return @leader.room_id()
    end
 
    def add_event(type)
        @members.each_pair { |k,v|
            begin
                v.add_event( type, Time.now.to_i, Room.current.id )
            rescue
                @leader.message("Error adding #{type.to_s} event to members stack: #{$!}")
                @leader.message($!.backtrace.join("\n"))
            end
        }
    end
 
    def add_leader_event(event)
        @leader.add_event( Event.new(event) ) unless @leader.event_stack.size > 5
    end
 
    def roundtime?()
        @members.each_pair { |k,v|
            begin
                return true if v.rt? > 0
            rescue
                @leader.message("Error polling member for RT. Removing!")
                @members.delete(k)
            end
        }
        return false
    end
 
    def should_hunt?()
        emergency = @leader.event_stack.size == 0 ? nil : @leader.event_stack.shift
        if(emergency)
            @leader.clear_events
            return false
        end
 
        @members.each_pair { |k,v|
            begin
                return false if !v.should_hunt?
            rescue
                @leader.message("Error polling member. Removing!")
                @members.delete(k)
            end
        }
                $bigshot_status = :hunting
        return true
    end
 
    def should_rest?()
        @members.each_pair { |k,v|
            begin
                return false if !v.should_rest?
            rescue
                @leader.message("Error polling member. Removing!")
                @members.delete(k)
            end
        }
        return true
    end
   
    def emergency_rest?()
        @members.each_pair { |k,v|
            begin
                return true if v.wounded?
            rescue
                @leader.message("Error polling member. Removing!")
                @members.delete(k)
            end
        }
        return false
    end
end
 
class Bigshot
    include DRbUndumped
    attr_accessor :BIRTH_TIME, :START_TIME, :STORED_TIMES, :FRIED, :OOM,
        :SIGNS, :TARGETS, :INVALID_TARGETS, :FLEE_COUNT, :ALWAYS_FLEE_FROM,
        :USE_WRACKING, :AMMO, :AMMO_CONTAINER, :HIDE_FOR_AMMO,
        :REST_TILL_EXP, :REST_TILL_MANA, :USE_HERBS, :DEAD_MAN_SWITCH,
        :RESTING_ROOM_ID, :RESTING_COMMANDS, :RESTING_SCRIPTS, :HUNTING_ROOM_ID,
        :HUNTING_BOUNDARIES, :HUNTING_SCRIPTS, :HUNTING_COMMANDS,
        :DISABLE_COMMANDS, :HUNTING_STANCE, :HUNTING_PREP_COMMANDS,
        :MONITOR_INTERACTION, :FLEE_CLOUDS, :FLEE_VINES, :FLEE_WEBS, :WRACKING_SPIRIT,
        :REST_TILL_SPIRIT, :BOUNTY_MODE, :AMBUSH, :ARCHERY_AIM,
        :event_stack, :followers, :BLESS, :AIM, :TIER3, 
		:MSTRIKE_COOLDOWN, :MSTRIKE_STAMINA_COOLDOWN, :MSTRIKE_MOB, 
		:MSTRIKE_QUICKSTRIKE, :MSTRIKE_STAMINA_QUICKSTRIKE,
		:UAC_MSTRIKE, :WANDER_WAIT, :QUICK_COMMANDS, :PRIORITY,
		:QUICKHUNT_TARGETS, :UAC_SMITE, :FOG_RETURN, :LOOT_STANCE,
		:DELAY_LOOT, :PULL
 
    PRONE = /sleeping|webbed|stunned|kneeling|sitting|^lying|prone|frozen|held in place/
 
    def add_event( type, time_stamp, room_id )
		echo "add_event" if $bigshot_debug
        unless( @event_stack.size > 5 && type == :ATTACK )
            @event_stack.push( Event.new( type, time_stamp, room_id ) )
        end
    end
 
    def grab_event()
		echo "grab_event" if $bigshot_debug
        @event_stack.shift()
    end
 
    def clear_events()
		echo "clear_events" if $bigshot_debug
        @event_stack.clear
    end
 
    def initialize(bounty_mode=nil)
		echo "initialize" if $bigshot_debug
        $bigshot = self
        if bounty_mode
            @BOUNTY_MODE = true
        end
               
        UserVars.op ||= Hash.new
        CharSettings['targetable']   ||= Array.new
        CharSettings['untargetable'] ||= Array.new
        @BIRTH_TIME   = Time.now.to_i
        @START_TIME   = 1
        @STORED_TIMES = Array.new
 
        @followers = nil
        @event_stack = Array.new
 
        load_settings()
        dead_man_switch()
 
        # this is mainly for azbounty:
        before_dying {
            @HUNTING_SCRIPTS.each { |i|
                echo "Cleaning up hunting scripts: #{i}."
                stop_script(i) if running?(i)
            }
        }
               
    end
       
    def load_settings()
        set_value_required( 'hunting_commands',     'split_xx' )
        set_value_required( 'fried',                'to_i'     )
        set_value_required( 'oom',                  'to_i'     )
        set_value_required( 'rest_till_mana',       'to_i'     )
        set_value_required( 'rest_till_exp',        'to_i'     )
 
        set_value( 'hunting_room_id',      'to_i',  4 )
        set_value( 'resting_room_id',      'to_i',  4 )
        set_value( 'hunting_boundaries',   'split',    Array.new )
        set_value( 'hunting_commands_b',   'split_xx', Array.new )
        set_value( 'hunting_commands_c',   'split_xx', Array.new )
		set_value( 'hunting_commands_d',   'split_xx', Array.new )
		set_value( 'hunting_commands_e',   'split_xx', Array.new )
		set_value( 'hunting_commands_f',   'split_xx', Array.new )
		set_value( 'hunting_commands_g',   'split_xx', Array.new )
		set_value( 'hunting_commands_h',   'split_xx', Array.new )
		set_value( 'hunting_commands_i',   'split_xx', Array.new )
		set_value( 'hunting_commands_j',   'split_xx', Array.new )
        set_value( 'disable_commands',     'split_xx', Array.new )
		set_value( 'quick_commands',       'split_xx', Array.new )
               
        set_value( 'targets',          'targets',         nil       )
		set_value( 'quickhunt_targets','targets',         nil       )
        set_value( 'dead_man_switch',     '',             false     )
        set_value( 'monitor_interaction', '',             false     )
        set_value( 'depart_switch',       '',             false     )
        set_value( 'encumbered',       'to_i',            200       )
        set_value( 'signs',            'split',           Array.new )
        set_value( 'spam',             '',                true      )
        set_value( 'flee_count',       'to_i',            10        )
        set_value( 'wracking_spirit',  'to_i',            0         )
        set_value( 'invalid_targets',  'split',           Array.new )
        set_value( 'always_flee_from', 'split',           Array.new )
		set_value( 'flee_message',     '',                nil       )
        set_value( 'flee_clouds',      '',                false     )
		set_value( 'flee_vines',       '',                false     )
		set_value( 'flee_webs',       '',                false     )
        set_value( 'use_wracking',     '',                false     )
        set_value( 'lone_targets_only', '',               false     )
        set_value( 'rest_till_spirit', 'to_i',            0         )
        set_value( 'ammo',             '',                nil       )
        set_value( 'ammo_container',   '',                nil       )
        set_value( 'fresh_wand_container',   '',          nil       )
        set_value( 'dead_wand_container',    '',          nil       )
        set_value( 'wand',             'split',           nil       )
        set_value( 'wand_if_oom',            '',          false     )
        set_value( 'hide_for_ammo',    '',                nil       )
        set_value( 'wounded_eval',     '',                nil       )
        set_value( 'resting_scripts',  'split',           Array.new )
        set_value( 'hunting_scripts',  'split',           Array.new )
        set_value( 'loot_script',      '',                nil       )
        set_value( 'hunting_stance',   '',               'defensive')
        set_value( 'resting_commands',   'split_xx',      Array.new )
        set_value( 'hunting_prep_commands','split_xx',    Array.new )
		set_value( 'mstrike_mob',       'to_i',           2         )
		set_value( 'mstrike_cooldown',  '',				  nil   	)
		set_value( 'mstrike_stamina_cooldown','to_i',	  maxstamina)
		set_value( 'mstrike_quickstrike','',              nil       )
		set_value( 'mstrike_stamina_quickstrike','to_i',  maxstamina)
		set_value( 'aim',				'split',		  Array.new )
		set_value( 'ambush',            'split',          Array.new )
		set_value( 'archery_aim',		'split',          Array.new )
		set_value( 'tier3',				'',			      'punch'   )
		set_value( 'bless',				'',			      nil       )
		set_value( 'uac_mstrike',       'to_i',           1         )
		set_value( 'uac_smite',         '',               false     )
		set_value( 'wander_wait',		'to_f',			  0.3		)
		set_value( 'priority',          '',               false     )
		set_value( 'fog_return',        '',               nil       )
		set_value( 'loot_stance',       '',               false     )
		set_value( 'delay_loot',        '',               false     )
		set_value( 'pull',              '',               true      )
    end
 
    def clean_value( clean, value )
        if( clean == 'to_i' )
            return value.to_i
		elsif ( clean == 'to_f' )
			return value.to_f
        elsif( clean == 'split' )
            return value.split(/,\s*/)
        elsif( clean == 'split_xx' )
            cleaned = Array.new
            value.split(/,\s*/).each { |i|
                rep = 1
                cmd = ''
                if( i =~ /(.*)\(x(\d+)\)$/i )
                    rep = $2.to_i
                    cmd = $1
                elsif( i =~ /(.*)\(xx\)/i )
                    rep = 5
                    cmd = $1
                else
                    cmd = i
                end
                and_tokens = cmd.split(/\sand\s/)
                cmd = and_tokens.size == 1 ? and_tokens[0] : and_tokens
                rep.times do cleaned.push(cmd) end
            }
            return cleaned
        elsif( clean == 'targets' )
            targets = Hash.new
            tokens = value.split(/,/)
            tokens.each do |i|
                if( i =~ /(.*)\(([a|b|c|d|e|f|g|h|i|j|A|B|C|D|E|F|G|H|I|J])\)/ )
                    targets[$1.downcase.strip] = $2.downcase.strip
                else
                    targets[i.downcase.strip] = 'a'
                end
            end
            return targets
        else
            return value
        end
    end
 
    def set_value( key, clean, default )
        if( !UserVars.op[key].nil? && UserVars.op[key] !~ /^\s*$/ )
            cleaned = clean_value( clean, UserVars.op[key] )
            instance_variable_set( "@#{key.upcase}", cleaned )
        else
            instance_variable_set( "@#{key.upcase}", default )
        end
    end
 
    def set_value_required( key, clean )
        if( !UserVars.op[key].nil? && UserVars.op[key] !~ /^\s*$/ )
            set_value( key, clean, nil )
        else
            message("ERROR: Missing required setting: #{key}")
            message("(fried? is percenthealth and oom is percentmana)")
            Script.self.kill
        end
    end
 
    def cmd( command, npc = nil, stance_dance = true )
		echo "cmd" if $bigshot_debug
		GameObj.pcs.each {|s| if s.status =~ /kneeling|sitting|^lying|prone/;fput "pull #{s.noun}";end;} if GameObj.npcs.any? {|s| s.type =~ /aggressive npc/} && @PULL
        command = command.dup
		
		#Used to escape from Roa'ter swallowing
		if !checkroom("The Belly of the Beast").nil?
			RoaterEscape()
		end
		
        if( command.class.to_s == 'Array' )
            stance_dance = false if command.any? { |j| j =~ /stance/ }
            command.each do |i|
                break if npc.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == npc.id}
                echo i if $bigshot_debug
                cmd( i, npc, stance_dance )
            end
            return
        end
		
        # check mana/stamina/health(percentage)/encumbrance/unarmed tiering/mobs in room/target not prone/target undead
		# ! means the inverse/opposite effect
        if( command =~ /(.*)\((.*?(?:s|!s|m|!m|h|!h|e|!e|tier|!tier|mob|!mob|prone|!prone|undead|!undead|flying|!flying|hidden|!hidden|poison|!poison|disease|!disease|noncorporeal|!noncorporeal|pcs|!pcs).*?)\)$/i )
			command = $1
			commandcheckreturn = false
			$2.split(" ").each{|s|
				if s =~ /((?:s|!s|m|!m|h|!h|e|!e|tier|!tier|mob|!mob))(\d+)/i
					if( $1 == 's' )
						commandcheckreturn = true if !checkstamina($2.to_i)
					elsif( $1 == '!s' )
						commandcheckreturn = true if checkstamina($2.to_i)
					elsif( $1 == 'm' )
						commandcheckreturn = true if !checkmana($2.to_i)
					elsif( $1 == '!m' )
						commandcheckreturn = true if checkmana($2.to_i)
					elsif( $1 == 'h' )
						commandcheckreturn = true if !percenthealth($2.to_i)
					elsif( $1 == '!h' )
						commandcheckreturn = true if percenthealth($2.to_i)
					elsif( $1 == 'e' )
						commandcheckreturn = true if !checkencumbrance($2.to_i)
					elsif( $1 == '!e' )
						commandcheckreturn = true if checkencumbrance($2.to_i)
					elsif( $1 == 'tier' )
						commandcheckreturn = true if $bigshot_unarmed_tier < $2.to_i
					elsif( $1 == '!tier' )
						commandcheckreturn = true if $bigshot_unarmed_tier > $2.to_i
					elsif ( $1 == 'mob' )
						mobcheck = $2
						commandcheckreturn = true if GameObjNpcCheck() < mobcheck.to_i
					elsif ( $1 == '!mob' )
						mobcheck = $2
						commandcheckreturn = true if GameObjNpcCheck() > mobcheck.to_i
					end
				elsif s =~ /((?:prone|!prone|undead|!undead|flying|!flying|hidden|!hidden|poison|!poison|disease|!disease|noncorporeal|!noncorporeal|pcs|!pcs))/i
					if( $1 == 'prone' )
						commandcheckreturn = true if npc.status =~ PRONE
					elsif( $1 == '!prone' )
						commandcheckreturn = true if npc.status !~ PRONE
					elsif( $1 == 'undead' )
						commandcheckreturn = true if !npc.type.split(',').any?{|a| a == "undead"}
					elsif( $1 == '!undead' )
						commandcheckreturn = true if npc.type.split(',').any?{|a| a == "undead"}
					elsif( $1 == 'flying' )
						commandcheckreturn = true if !npc.status.include?("flying")
					elsif( $1 == '!flying' )
						commandcheckreturn = true if npc.status.include?("flying")
					elsif( $1 == 'hidden' )
						commandcheckreturn = true if !hiding?
					elsif( $1 == '!hidden' )
						commandcheckreturn = true if hiding?
					elsif( $1 == 'poison' )
						commandcheckreturn = true if !checkpoison?
					elsif( $1 == '!poison' )
						commandcheckreturn = true if checkpoison?
					elsif( $1 == 'disease' )
						commandcheckreturn = true if !checkdisease?
					elsif( $1 == '!disease' )
						commandcheckreturn = true if checkdisease?
					elsif( $1 == 'noncorporeal' )
						commandcheckreturn = true if !npc.type.split(',').any?{|a| a == "noncorporeal"}
					elsif( $1 == '!noncorporeal' )
						commandcheckreturn = true if npc.type.split(',').any?{|a| a == "noncorporeal"}
					elsif( $1 == 'pcs' )
						commandcheckreturn = true if !((checkpcs - $grouplist).count > 0)
					elsif( $1 == '!pcs' )
						commandcheckreturn = true if ((checkpcs - $grouplist).count > 0)
					end
				end
			}
			return if commandcheckreturn
        end
		
        if( command =~ /force\s+(.*)\s+(?:till|until)\s+(\d+)/i )
            cmd_force( $1, $2.to_i, npc )
            return
        end
       
        # sub id
        command.gsub!( /target/, "##{npc.id}" ) if !npc.nil?
       
		# Soothe routine
		if Spell[1205].known? && Spell[1205].affordable?
			if (Spell[201].active? || Spell[216].active? || Spell[1015].active? || Spell[1016].active? || Spell[1108].active? || Spell[1120].active?)
				waitrt?
				waitcastrt?
				Spell[1205].cast
			end
		end
		
		cmd_bless() if @BLESS && $bigshot_bless.count > 0
		
        # waitrt/waitcastrt
        unless( command =~ /^nudgeweapons?/ )
            waitrt?
            waitcastrt? if command =~ /^\d+|incant/
        end

		# Celerity (506) routine
 		if ( command =~ /^(celerity|haste|506)\s+(.*)/i )
			command = $2
			if Spell[506].known? and Spell[506].affordable?
				if (Spell[506].active? and Spell[506].timeleft <= 0.05) || (!Spell[506].active?)
					Spell[506].cast
				end
			end
		end

        # change_stance
        stand() if !standing?
        unless( command =~ /^(?:\d+|wait|sleep|wand|berserk|script|hide|nudgeweapon)/ )
            change_stance(@HUNTING_STANCE) if stance_dance
        end
 
        return if (npc && !valid_target?(npc)) or npc.status =~ /dead/
		return if @PRIORITY && !priority(npc)
 
        if( command =~ /^(incant)?\s?(\d+)\s?((?:open|closed)?\s?(?:cast|channel|evoke)?\s?(?:cast|channel|evoke)?\s?(?:open|closed)?\s?(?:air|earth|fire|lightning|water|cold)?)?.*$/i )
            cmd_spell( $1, $2.to_i, $3, npc )
		elsif( command =~ /^throw/i )
			cmd_throw( npc )
		elsif( command =~ /^k?weed/i )
			cmd_weed( command, npc )
        elsif( command =~ /^wand/i )
            cmd_wand(npc)
        elsif( command =~ /^hide/i )
            cmd_hide()
        elsif( command =~ /^mstrike/i )
            cmd_mstrike( command, npc )
        elsif( command =~ /^fire/i )
            cmd_ranged(npc)
        elsif( command =~ /^berserk/i )
            cmd_berserk()
        elsif( command =~ /^script\s+(.*?)(\s|$)(.*)/i )
            cmd_run_script( $1, $3 )
        elsif( command =~ /^sleep\s+(\d+)/i )
            cmd_sleep( $1, npc )
        elsif( command =~ /^stance\s+(.*)/i )
            change_stance($1)
        elsif( command =~ /^wait\s+(\d+)/i )
            wait_for_swing( $1.to_i, npc )
            $stop_wait = true
        elsif( command =~ /^nudgeweapons?\s*/i )
            cmd_nudge_weapons
        elsif( command =~ /^ambush\s?(.*)?/i )
            cmd_ambush( $1, npc )
		elsif( command =~ /^unarmed\s+([a-z]*).?([a-z]*)?$/i )
			unarmed( $1, npc , $2)
		elsif( command =~ /^smite/i )
			volnsmite( npc )
        else
            return if $ambusher_here
            echo "inside cmd: #{command}" if $bigshot_debug
            bs_put command
        end
    end
	
	def volnsmite(npc)
		echo "volnsmite" if $bigshot_debug
		while !$bigshot_smite_list.any?{|a| a.to_i == npc.id.to_i} && npc.status !~ /dead/ && GameObj.npcs.any? {|s| s.id == npc.id} && !should_flee? && (npc.type.split(',').any?{|a| a == "undead"} || npc.type.split(',').any?{|a| a == "noncorporeal"})
			res = dothistimeout "smite ##{npc.id}", 1, /^Roundtime|^What were you referring to\?$/
			if res =~ /^What were you referring to\?$/i
				break
			end
			sleep 1
		end
	end
	
	def unarmed( command , npc, manualaim)
		echo "unarmed" if $bigshot_debug
		
		return if npc.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == npc.id}
		$bigshot_aim = -1 if manualaim != "" && $bigshot_aim == 0
		mstrike_taken = false
		volnsmite(npc) if !$bigshot_smite_list.any?{|a| a.to_i == npc.id.to_i} && npc.type.split(',').any?{|a| a == "noncorporeal"} && $bigshot_unarmed_tier == 3 && Spell[9821].known? && @UAC_SMITE
		mstrike_spell_check() if Char.prof =~ /Paladin|Empath/i && Skills.multiopponentcombat >= 5
		if Skills.multiopponentcombat >= 5 && GameObj.npcs.all? { |i| i.noun !~ /nest/i }
			#9005 - Mstrike recovery
			#9699 - popped muscles
			if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
				if (GameObjNpcCheck() >= @UAC_MSTRIKE)
					if (checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE || GameObjNpcCheck() >= @UAC_MSTRIKE) && !Spell[9699].active?
						mstrike_taken = true
						if command =~ /jab/ && $bigshot_unarmed_tier == 3 && $bigshot_unarmed_followup == false
							cmd("mstrike #{@TIER3}", npc)
						elsif $bigshot_unarmed_followup == true
							cmd("mstrike #{$bigshot_unarmed_followup_attack}", npc)
						else
							cmd("mstrike #{command}", npc)
						end
					end
				end
			end
		end
		if mstrike_taken == false
			if command =~ /jab/ && $bigshot_unarmed_tier == 3 && $bigshot_unarmed_followup == false
				if manualaim != ""
					cmd("#{@TIER3} ##{npc.id} #{manualaim}", npc)
				elsif !@AIM[$bigshot_aim].nil?
					cmd("#{@TIER3} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
				else
					cmd("#{@TIER3} ##{npc.id}", npc)
				end
			elsif $bigshot_unarmed_followup == true
				command = $bigshot_unarmed_followup_attack
				if manualaim != ""
					cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{manualaim}", npc)
				elsif !@AIM[$bigshot_aim].nil?
					cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
				else
					cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id}", npc)
				end
			else
				if manualaim != ""
					cmd("#{command} ##{npc.id} #{manualaim}", npc)
				elsif !@AIM[$bigshot_aim].nil?
					cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
				else
					cmd("#{command} ##{npc.id}", npc)
				end
			end
		end
		timeNow = Time.now + 5
		while line = get
			if line =~ /You have (decent|good|excellent) positioning/
				tier = $1
				if tier =~ /decent/
					$bigshot_unarmed_tier = 1
				elsif tier =~ /good/
					$bigshot_unarmed_tier = 2
				elsif tier =~ /excellent/
					$bigshot_unarmed_tier = 3
				end
			elsif line =~ /.* = .* d100: .* = \-?(\d+)$/ && $bigshot_unarmed_followup == true
				endroll = $1
				if endroll.to_i > 100
					$bigshot_unarmed_followup = false
				end
			elsif line =~ /Strike leaves foe vulnerable to a followup (.*) attack!/
				$bigshot_unarmed_followup = true
				$bigshot_unarmed_followup_attack = $1
			elsif line =~ /You fail to find an opening for your strike\./
				$bigshot_aim += 1
			elsif line =~ /You cannot aim that high!|is already missing that!/
				$bigshot_aim += 1
				cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
			elsif line =~ /does not have/
				$bigshot_aim += 10
				cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
			elsif line =~ /Roundtime:/i
				$bigshot_aim = 0
				break
			elsif line =~ /^Try standing up first\.$|[wW]ait \d+ sec.*|You currently have no valid target\.  You will need to specify one\.|^It looks like somebody already did the job for you\.$|^What were you referring to\?$|Sorry,|You can't do that while entangled in a web|You are still stunned|from here\.  Perhaps you should try throwing or shooting something at it\./
				break
			elsif line =~ /You don't seem to be able to move to do that\./
				pause 2
				break
			elsif line =~ /You are unable to muster the will to attack anything\.|Your rage causes you to use all of your skill in an all out attack!/
				Spell[1205].cast if Spell[1205].known? && Spell[1205].affordable?
				break
			elsif npc.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == npc.id} || should_flee? || should_rest?
				break
			elsif timeNow < Time.now
				break
			end
		end
		mstrike_taken = false
	end
       
	def cmd_bless()
		echo "cmd_bless" if $bigshot_debug
		while $bigshot_bless.count > 0
			if Spell[1604].known? && Spell[1604].affordable?
				waitrt?
				waitcastrt?
				Spell[1604].cast("##{$bigshot_bless[$bigshot_bless.count-1]}")
			end
			if Spell[304].known? && Spell[304].affordable?
				waitrt?
				waitcastrt?
				Spell[304].cast("##{$bigshot_bless[$bigshot_bless.count-1]}")
				$bigshot_bless.delete($bigshot_bless[$bigshot_bless.count-1])
			elsif Spell[9802].known?
				waitrt?
				waitcastrt?
				fput "symbol bless ##{$bigshot_bless[$bigshot_bless.count-1]}"
				$bigshot_bless.delete($bigshot_bless[$bigshot_bless.count-1])
			else
				$bigshot_should_rest = true
				$rest_reason = "No blessing on weapon"
				$bigshot_bless = []
				return
			end
		end
	end
	   
	def cmd_throw( npc )
		echo "cmd_throw" if $bigshot_debug
		unless npc.status == 'lying down'
			empty_hands
			dothistimeout "throw ##{npc.id}", 1, /^You attempt to throw a .*\!$/
			waitrt?
			fill_hands
		end
	end
   
    def cmd_force( force_this, goal, npc )
		echo "cmd_force" if $bigshot_debug
        start = Time.now
        loop {
            cmd( force_this, npc )
            buffer = reget(20)
            buffer.each_with_index { |line, i|
                if( line =~ /^You.*(#{checknpcs.join('|')})(\.|!)|^You feint (high|low|(to the (left|right)))/ )
                    if (buffer[i + 1] && buffer[i + 1] =~ /== \+(\d+)/) || (buffer[i + 2] && buffer[i + 2] =~ /== \+(\d+)/)
                        return if $1.to_i >= goal # spell/swing
                    elsif (buffer[i - 1] && buffer[i - 1] =~ /^\[Roll result: (\d+)/) || (buffer[i - 2] && buffer[i - 2] =~ /^\[Roll result: (\d+)/)
                        return if $1.to_i >= goal # cman
                    elsif (buffer[i + 1] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/) || (buffer[i + 2] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/)
                        return
                    end
                elsif( line =~ /^You do not have enough stamina to attempt this maneuver\./ )
                    return
                elsif( line =~ /^Your magic fizzles ineffectually\./ )
                    return
                end
            }
            if ( force_this =~ /^(\d+) / && !Spell[$1.to_i].affordable? )
                message("Force ran out of mana. Giving up."); return;
            end
            return if GameObj.npcs.size.nil? || GameObjNpcCheck() == 0
            return if should_flee?
            return if should_rest?
            return if npc.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == npc.id}
            return if ( Time.now - start ) > 30
        }
    end
       
	def cmd_weed( command, target )
		echo "cmd_weed" if $bigshot_debug
		return if target.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == target.id}
		return if GameObj.loot.find { |loot| loot.name =~ /vine/ }
		return unless Spell[610].known? and Spell[610].affordable?
	   
		waitcastrt?
		change_stance('offensive') if command == 'kweed'
		Spell[610].cast("##{target.id}")
		change_stance('guarded') if command == 'kweed'
		waitcastrt?
	end
 
    def cmd_spell( incant = nil, id, extra, target )
		echo "cmd_spell" if $bigshot_debug
        selfcast = false
		if ( checkprep != "None" and checkprep != Spell[id].name )
            fput 'release'
        end
		
        return if id == 506 and Spell[506].active?
        return if id == 9605 and Spell[9606].active? # surge cooldown
		return if id == 608 and hiding?
		return if id == 703 and $bigshot_703_list.any? {|s| s == target.id}
		return if id == 1614 and $bigshot_1614_list.any? {|s| s == target.id}
        return if target.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == target.id}
        unless( Spell[id].affordable? )
            if(@WAND_IF_OOM)
                cmd_wand(target); return;
            end
            if(@USE_WRACKING)
                wrack()
            end
        end
               
		if ( !Spell[id].affordable? and id != 9605 and id != 506 )
			$bigshot_should_rest = true
			$rest_reason = "out of mana"
		end
		selfcast = true if id.to_s =~ /^(?:106|109|115|117|120|130|140|205|206|211|213|215|218|219|220|240|303|307|310|313|314|319|350|401|402|403|404|405|406|414|418|419|425|430|503|506|507|508|509|511|513|515|517|520|535|540|601|602|603|604|605|606|608|611|612|613|617|618|620|625|630|640|650|707|712|905|911|913|916|919|1003|1006|1007|1009|1010|1011|1012|1014|1017|1018|1019|1020|1025|1035|1040|1109|1119|1125|1130|1150|1202|1204|1208|1213|1214|1215|1216|1220|1235|1601|1603|1605|1606|1607|1608|1609|1610|1611|1612|1613|1616|1617|1618|1619|1635)$/
        waitcastrt?
		if !incant.nil?
			if XMLData.current_target_id != target.id && selfcast == false
				fput "target ##{target.id}"
			end
			change_stance('offensive') if Spell[id].stance || (id.to_s =~ /1700/i && extra =~ /evoke/i)
			bs_put "incant #{id} #{extra}"
			change_stance(@HUNTING_STANCE)
		else
			if selfcast == false
				Spell[id].cast("##{target.id}")
			else
				Spell[id].cast(Char.name)
			end
		end
    end
 
    def cmd_wand(target)
		echo "cmd_wand" if $bigshot_debug
        if(@FRESH_WAND_CONTAINER)
            hands = GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s
            until( (GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s) =~ /#{@WAND[$bigshot_wand].split(' ').join('.*?')}/i)
                result = dothistimeout( "get #{@WAND[$bigshot_wand]} from my #{@FRESH_WAND_CONTAINER}", 3, /You remove|You slip|Get what/ )
                if( result =~ /Get what/ )
					$bigshot_wand += 1
					if @WAND[$bigshot_wand].nil?
						message("ERROR: Couldn't find fresh wand. Gonna rest."); $bigshot_should_rest = true; return;
					end
                elsif(result.nil?)
                    message("ERROR: Timed out looking for wand."); return;
                end
            end
 
            change_stance('offensive')
            result = dothistimeout( "wave my #{@WAND[$bigshot_wand]} at ##{target.id}", 2, /d100|You hurl|is already dead|You do not see that here|You are in no condition|I could not find|Wait/ )
            change_stance(@HUNTING_STANCE)
           
            if( result =~ /You are in no condition/ )
                message("ERROR: Wounded. Gonna rest."); $bigshot_should_rest = true; return;
            elsif(result.nil?)
                if(@DEAD_WAND_CONTAINER)
                    bs_put "put my #{@WAND[$bigshot_wand]} in my #{@DEAD_WAND_CONTAINER}"
                else
                    bs_put "drop my #{@WAND[$bigshot_wand]}"
                end
            end
        else
            message("ERROR: Wand command called but fresh wand container not defined.")
        end
    end
 
    def cmd_hide()
		echo "cmd_hide" if $bigshot_debug
        tries = 0
        until(hiding?)
            break if tries > 3 || should_flee?
            change_stance('defensive')
            bs_put 'hide'; tries += 1;
        end
    end
 
	def mstrike_spell_check()
		echo "mstrike_spell_check" if $bigshot_debug
		#Rejuvenation
		if (Spell[1607].known? && !Spell[1607].active? && Spell[1607].affordable? && (checkstamina < (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
			if ((checkstamina + (15+(bonus=0;[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190].each { |n| bonus += 1 if Skills.slblessings >= n }; bonus*3))) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE))
				waitcastrt?
				Spell[1607].cast
			end
		end
		#Adrenal Surge
		if (Spell[1107].known? && Spell[1107].affordable? && !Spell[9010].active? && (Time.now >= $bigshot_adrenal_surge))
			if (Spell[9699].active? || ((maxstamina if Skills.slblessings >= 65 ) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
				waitcastrt?
				spell[1107].cast
				$bigshot_adrenal_surge = Time.now + 301
			elsif (Spell[9699].active? || ((checkstamina + (Skills.slblessings >= 35 ? 50 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
				waitcastrt?
				spell[1107].cast
				$bigshot_adrenal_surge = Time.now + 301
			elsif (Spell[9699].active? || ((checkstamina + (Skills.slblessings >= 35 ? 25 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
				waitcastrt?
				spell[1107].cast
				$bigshot_adrenal_surge = Time.now + 301
			end
		end
	end
 
 
    def cmd_mstrike( command, target )
		echo "cmd_mstrike" if $bigshot_debug
		mstrike_spell_check() if Char.prof =~ /Paladin|Empath/i
		#Mstrike checks
		if Skills.multiopponentcombat >= 30 && GameObj.npcs.all? { |i| i.noun !~ /nest/i }
			if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
				if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Spell[9699].active?
					if( GameObjNpcCheck() >= @MSTRIKE_MOB || target.nil? )
						bs_put "quickstrike 1 #{command}"
					else
						bs_put "quickstrike 1 #{command} ##{target.id}"
					end
				else
					if( GameObjNpcCheck() >= @MSTRIKE_MOB || target.nil? )
						bs_put "#{command}"
					else
						bs_put "#{command} ##{target.id}"
					end
				end
			end
		elsif Skills.multiopponentcombat >= 5 && GameObj.npcs.all?{ |i| i.noun !~ /nest/i }
			if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
				if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Spell[9699].active?
					bs_put "quickstrike 1 #{command}"
				else
					bs_put "#{command}"
				end
			end
		end
    end
 
    def cmd_ranged(npc)
		echo "cmd_ranged" if $bigshot_debug
		if !@ARCHERY_AIM[$bigshot_archery_aim].nil?
			if $bigshot_archery_stuck_location.any? { |s| s =~ /#{$bigshot_archery_location}/i }
				$bigshot_archery_aim += 1
				if $bigshot_archery_aim > @ARCHERY_AIM.length
					$bigshot_archery_aim = 0
					$bigshot_archery_stuck_location = []
				end
			end
			if @ARCHERY_AIM[$bigshot_archery_aim] !~ /#{$bigshot_archery_location.to_s}/i || $bigshot_archery_location.nil?
				fput "aim #{@ARCHERY_AIM[$bigshot_archery_aim]}"
			end
		end
		
		waitrt?
		
        result = dothistimeout "get 1 my #{@AMMO.sub(/s$/, '')}", 2, /You remove|Get what\?|You already/
		if( result =~ /Get what\?/ )
			$bigshot_should_rest = true
            $rest_reason = "Out of ammo"
			return
		end
               
        result = dothistimeout("fire ##{npc.id}", 2, /You fire|You cannot|Could not find|seconds|Get what?/)
        if( result =~ /^Could not find/ )
			gather_ammo()
		elsif( result =~ /You cannot fire/ )
			unless GameObj.right_hand.id.nil?
				line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
				if line =~ /closed/
					container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
					fput "open my ##{container.id}"
					fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
				end
			end
		elsif( result =~ /but it has no effect/ )
			$bigshot_should_rest = true
			$rest_reason = "Ammo had no effect (need blessed or magical)"
		elsif ( result == false )
			$bigshot_should_rest = true
			$rest_reason = "Unknown result from fire routine: #{result}"
        end
    end
 
    def cmd_berserk()
		echo "cmd_berserk" if $bigshot_debug
        if( checkstamina(20) )
            change_stance('defensive')
			Spell[9607].cast
			pause 5
			wait_until { !Spell[9607].active? }
        else
            bs_put 'target random'; bs_put 'kill';
        end
    end
 
    def cmd_run_script( name, args )
		echo "cmd_run_script" if $bigshot_debug
        if( args == nil || args =~ /^\s*$/ )
            run_script( name, true )
        else
            args = args.split(/ /)
            run_script( name, true, args )
        end
    end
 
    def cmd_sleep( time, npc )
		echo "cmd_sleep" if $bigshot_debug
        change_stance('defensive')
        time.to_i.times do
            sleep 1
            break if should_rest?
            break if npc && npc.status =~ /dead/
        end
    end

    def cmd_ambush(command, target)
		echo "cmd_ambush" if $bigshot_debug
		return if target.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == target.id}
		command = ["head", "right leg", "left leg", "chest"] if (command == "" || command.nil?) && @AMBUSH == []
		command = @AMBUSH if (command == "" || command == [] || command.nil?) && @AMBUSH != []
		command = [command] if command.class == String
		waitrt?
		result = dothistimeout "ambush ##{target.id} #{command[$bigshot_ambush]}", 2, /round(time)?|You cannot aim that high!|is already missing that!/i
		if result =~ /You cannot aim that high!|is already missing that!/i
			$bigshot_ambush += 1
			cmd_ambush(nil, target)
		elsif result =~ /round(time)?/i
			$bigshot_ambush = 0
		end
    end
   
    def cmd_nudge_weapons()
		echo "cmd_nudge_weapons" if $bigshot_debug
        return if checkpaths.size == 0
 
        GameObj.loot.each { |i|
            next unless i.noun =~ /axe|scythe|pitchfork|falchion|sword|lance|sword|dagger|estoc|falchion|handaxe|katana|katar|gauche|rapier|scimitar|whip-blade|cudgel|crowbill|whip|mace|star|hammer|claidhmore|flail|flamberge|maul|pick|staff|mattock/
            change_stance('defensive')
           
            sheathed = false
            unless( righthand.nil? || lefthand.nil? )
                sheathed = true
                fput 'sheath'
                unless( righthand.nil? || lefthand.nil? )
                    message("Unable to empty hands via sheath.")
                    return
                end
            end
       
            dirs = checkpaths
            dir  = checkpaths.shift
            fput "get ##{i.id}"
            put dir
            put "drop ##{i.id}"
            fput reverse_direction(dir)
            fput "gird" if sheathed
        }
    end
 
    def message(text)
        string = ''
        if $fake_stormfront then string.concat("\034GSL\r\n ") else string.concat("<pushBold\/>") end
        if( text.index('\n') )
            text.split('\n').each { |line| string.concat("| #{line}") }
        else
            string.concat('| ' + text)
        end
        if $fake_stormfront then string.concat("\034GSM\r\n ") else string.concat("<popBold\/>") end
        _respond string
    end
 
    def dead_man_switch()
		echo "dead_man_switch" if $bigshot_debug
        if @DEAD_MAN_SWITCH
            Thread.new {
                while( running?($current_script_name) )
                    if( dead? ||  percenthealth < 40 )
                        echo 'AUTOBOT ALERT: Your character is in trouble!'
                        fput 'quit'
                    end
                    sleep 2
                end
            };
        elsif @DEPART_SWITCH
            start_exec_script( <<-EOF
                while( running?($current_script_name) );
                    if(dead?);
                        stop_script($current_script_name);
                        fput 'depart'; fput 'depart';
                        fput 'depart confirm'; fput 'depart confirm';
                        start_script('waggle');
                        15.times { sleep 60; fput info; };
                        sleep 1 until percentspirit == 100 && !running?('waggle');
                        start_script( "#{$current_script_name}", ['solo'] );
                        Script.self.kill;
                    end;
                    sleep 5;
                end;
                EOF
            );
        else
            Thread.new {
                loop { Script.self.kill if dead?; sleep 5; }
            }
        end
    end
 
    def keep_awake()
		echo "keep_awake" if $bigshot_debug
        Thread.new {
            while( running?($current_script_name) )
                sleep 150; put 'look';
            end
        }
    end
 
    def monitor_interaction()
		echo "monitor_interaction" if $bigshot_debug
        if @MONITOR_INTERACTION
            start_exec_script( <<-eos
                def show_window(line);
                    window_title = Char.name + ':' + line;
                    Gtk.queue {
                        $myWindow = Gtk::Window.new;
                        $myWindow.title = "Autobot Alert!";
                        $myWindow.set_size_request(450, 25);
                        label = Gtk::Label.new window_title;
                        $myWindow.add(label);
                        $myWindow.show_all;
                    };
                end;
                while(line = get);
                    break unless running?($current_script_name);
                    if(line =~ /SEND|POLICY|[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]|peaking to you|unresponsive|taps you|nods to you|lease respond|not in control|character|violation|lease speak|peak out loud|Y U SHOU D|whispers,|speaking to you|smiles at you|waves to you|grins at you|hugs you|takes hold your hand|grabs your hand|clasps your hand|trying to drag you/);
                        unless(line =~ /LNet/);
                            show_window(line);
                            echo "AUTOBOT ALERT: " + line;
                        end;
                    end;
                end;
            eos
            )
        end
    end
	
	def GameObjNpcCheck()
		npcs = GameObj.npcs.find_all { |i| i.status !~ /dead/ }
		npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
		npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
		return npcs.size.to_i
	end
	
	def NPCRoomCheck()
		Thread.new{
			loop{
				$current_room_npcs = GameObj.npcs
				pause 0.5
			}
		}
	end
 
    def wrack()
		echo "wrack" if $bigshot_debug
        if Spell[9918].known? and not Spell[9012].active?
            Spell[9918].cast if checkspirit >= @WRACKING_SPIRIT
        elsif Spell[9718].known?
            ( checkstamina / 50 ).times { Spell[9718].cast }
		elsif Spell[9813].known? && !Spell[9048].active?
			Spell[9813].cast
        end
    end
 
    def change_stance( new_stance, force = true )
        return if Spell[1617].active? || Spell[216].active? || dead?
 
        if( stance() =~ /#{new_stance}/ )
            return
        elsif( checkcastrt() > 0 && new_stance =~ /def/ )
            return if stance() == 'guarded'
        end
 
        if(force)
            result = dothistimeout( "stance #{new_stance}", 3, /You are now in an?|Cast Round Time in effect|You are unable to change/ )
        else
            fput "stance #{new_stance}"
        end
    end
 
    def wait_for_swing( seconds, target = nil )
		echo "wait_for_swing" if $bigshot_debug
        start = Time.now
        swung = false
        $stop_wait = false
        $global_target = target.id
        $pcs = checkpcs ? ' you(\.|!|r? )|' + checkpcs.join('|') : 'you(\.|!|r? )'
     
        wait_for_swing_exec = <<-eos
        status_tags
        while line = get
            $stop_wait = true if line =~ /#{$global_target}.*#{$pcs}/ and line !~ /style id="".*style id="roomDesc"|(?:component|compDef) id='room objs'/
            break if $stop_wait
            break if !running?($current_script_name)
        end
        status_tags
        eos
 
        ExecScript.start(wait_for_swing_exec, :quiet => true)
       
        while(1)
            change_stance( 'defensive', false ) unless target && target.status =~ PRONE
            stand() if !standing?
            break if $stop_wait.call
            break if GameObj.npcs.size.nil? || GameObjNpcCheck() == 0
            break if should_flee?
            break if target && target.status =~ PRONE
            break if ( Time.now - start ) > seconds
            sleep 0.25
        end
    end
 
    def croak(message)
		echo "croak" if $bigshot_debug
        message(message);
        croak_scripts( ["#{$current_script_name}"] )
    end
 
    def run_script( name, pause_bigshot = false, args = [] )
		echo "run_script" if $bigshot_debug
        if Script.running.find { |s| s.name.downcase == name.downcase }.paused or running? name
            stop_script name
            wait_while { running? name }
        end
 
        start_script name, args
        if pause_bigshot
            wait_until { !running? name }
        end
    end
 
    def run_scripts( scripts, pause_bigshot = false )
		echo "run_scripts" if $bigshot_debug
        scripts.each do |i|
            tokens = i.split(/\s+/)
            if( tokens.size > 1 )
                run_script( tokens[0], pause_bigshot, tokens[1..-1] )
            else
                run_script( tokens[0], pause_bigshot )
            end
        end
    end
 
    def croak_script(name)
		echo "croak_script" if $bigshot_debug
        kill_script(name) if running?(name)
    end
 
    def croak_scripts(scripts)
		echo "croak_scripts" if $bigshot_debug
        scripts.each { |i| croak_script(i) }
    end
 
    def stand()
		echo "stand" if $bigshot_debug
        until(standing?)
            change_stance('defensive')
            bs_put 'stand'
        end
    end
 
	 def groupcheck()
		echo "groupcheck" if $bigshot_debug
		def checkgroupline(line)
			line =~ /exist="\-[0-9]+" noun=".*">(.*)<\/a> is (?:following you|the leader of your group|also a member of your group)/i
			if !$1.nil? then $grouplist.push($1); end
		end

		action = proc { |server_string|
			if checkgroupline(server_string) or server_string =~ /group status is currently|to set your group status|^.$|You are not currently in a group/m then nil
			else server_string
			end
		}
		DownstreamHook.add('grouphook',action)
		$_SERVER_.puts "group"
		waitfor "group status is currently", "to set your group status", "You are not currently in a group"
		pause 0.5
		DownstreamHook.remove('grouphook')
		echo $grouplist if $bigshot_debug
	end
 
    def lead( my_group = nil )
		echo "lead" if $bigshot_debug
        monitor_interaction()
		CompanionCheck()
		NPCRoomCheck()
        @followers = my_group || Group.new()
		if !checkpcs.nil?
			groupcheck()
		end
 
        if(should_rest? && !$bigshot_quick)
            rest()
        else
            hunt()
        end
    end
 
    def find_routine(target)
		echo "find_routine" if $bigshot_debug
		if( !solo? && fried? )
            return @DISABLE_COMMANDS
        else
			key = @TARGETS.keys.find { |k| target.name =~ /^#{k}$/i or target.noun =~ /^#{k}$/i }
			if key.nil?
					routine_letter = 'a'
			else
					routine_letter = @TARGETS[key]
			end
		   
			if routine_letter == 'quick'
				return @QUICK_COMMANDS unless @QUICK_COMMANDS.size == 0
			elsif routine_letter == 'j'
				return @HUNTING_COMMANDS_J unless @HUNTING_COMMANDS_J.size == 0
			elsif routine_letter == 'i'
				return @HUNTING_COMMANDS_I unless @HUNTING_COMMANDS_I.size == 0
			elsif routine_letter == 'h'
				return @HUNTING_COMMANDS_H unless @HUNTING_COMMANDS_H.size == 0
			elsif routine_letter == 'g'
				return @HUNTING_COMMANDS_G unless @HUNTING_COMMANDS_G.size == 0
			elsif routine_letter == 'f'
				return @HUNTING_COMMANDS_F unless @HUNTING_COMMANDS_F.size == 0
			elsif routine_letter == 'e'
				return @HUNTING_COMMANDS_E unless @HUNTING_COMMANDS_E.size == 0
			elsif routine_letter == 'd'
				return @HUNTING_COMMANDS_D unless @HUNTING_COMMANDS_D.size == 0
			elsif routine_letter == 'c'
				return @HUNTING_COMMANDS_C unless @HUNTING_COMMANDS_C.size == 0
			elsif routine_letter == 'b'
				return @HUNTING_COMMANDS_B unless @HUNTING_COMMANDS_B.size == 0
			end
		   
			return @HUNTING_COMMANDS
        end
    end
 
    def solo?
        # tails wont have followers
        if( @followers && @followers.size == 0 )
            return true
        else
            return false
        end
    end
 
    def leading?
        return !following?
    end
   
    def following?
        return @followers.nil?
    end
   
    def no_players()
		echo "no_players" if $bigshot_debug
        return false if GameObj.loot.find { |obj| obj.noun == 'disk' and obj.name !~ /#{Char.name}/}
        return false if ((checkpcs - $grouplist).count > 0) or $ambusher_here
        return true
    end
	
	def no_players_hunt()
		echo "no_players_hunt" if $bigshot_debug
        return false if $ambusher_here
        return true
    end
 
    def pre_hunt()
		echo "pre_hunt" if $bigshot_debug
        # prep/go
        @followers.add_event(:HUNTING_PREP_COMMANDS)
        @HUNTING_PREP_COMMANDS.each { |i|
            if i =~ /^script\s+(.*?)(\s|$)(.*)/i
               cmd_run_script( $1, $3 )
            else
                fput(i)
            end
        }
		
        @followers.add_event(:CAST_SIGNS)
        cast_signs()
 
        @followers.add_event(:HUNTING_SCRIPTS_START)
        run_scripts( @HUNTING_SCRIPTS, false )
		
		if !$bigshot_quick
			goto(@HUNTING_ROOM_ID)
		end
        if( !solo? && @followers.get_names.any? { |i| !checkpcs.include?(i) } )
            @followers.add_event(:CAST_SIGNS) # trigger rubber band
            sleep 10 # wait for followers
        end
    end
   
    def do_hunt()
		echo "do_hunt" if $bigshot_debug
        spam() if UserVars.op['spam']
       
        start_watch()
        message('Bigshot hunting')
 
        # loop
        target = nil
        just_arrived = true
        last_attack = 0
		reset_variables()
   
		while true
			while( (target = find_target(target, just_arrived)) && !should_rest? && no_players_hunt == true && !$bigshot_flee)
				echo "inside do_hunt loop" if $bigshot_debug
				echo target if $bigshot_debug
				target = find_target(nil) if @PRIORITY && !priority(target)
				echo "Priority target switch to #{target}" if $bigshot_debug && @PRIORITY
				if( (Time.now.to_i - last_attack > 15) || just_arrived )
					@followers.add_event(:ATTACK)
					last_attack = Time.now.to_i
				end
				attack(target)
				just_arrived = false
				loot() if $ambusher_here == false
			end
       
			echo "Exiting attack loop" if $bigshot_debug
			gather_ammo()
 
			if(should_rest?)
				break
			else
				prepare_for_movement()
				target = bs_wander()
				just_arrived = true
			end
		end
 
        unspam()
    end
 
    # this is a leader method
    def hunt()
		echo "hunt" if $bigshot_debug
        pre_hunt()
        do_hunt()
        rest()
    end
 
    # this is a leader method
    def rest()
		echo "rest" if $bigshot_debug
        message("Bigshot resting: #{$rest_reason}")
        $bigshot_should_rest = nil
        if @BOUNTY_MODE # bounty script should take over from here
          echo "Bounty mode. Killing self. Reason: #{$rest_reason}"
          exit
        end
         
        stop_watch()
 
        # prep/go
		prepare_for_movement()
		if (@FOG_RETURN.to_i != 0)
			if @FOG_RETURN.to_i == 1
				if Spell[130].known? && Spell[130].affordable?
					Spell[130].cast()
				elsif Spell[9825].known?
					fput "symbol of return"
				end
			elsif @FOG_RETURN.to_i == 2
				if Spell[9825].known?
					temproom = Room.current.id
					fput "symbol of return"
					pause 0.5
					if (Room.current.id == temproom && Spell[130].known? && Spell[130].affordable?)
						Spell[130].cast()
					end
				end
			elsif @FOG_RETURN.to_i == 3
				if Spell[1020].known? && Spell[1020].affordable?
					Spell[1020].cast()
				end
			end
		end
        goto(@RESTING_ROOM_ID)
 
        @followers.add_event(:HUNTING_SCRIPTS_STOP)
        croak_scripts(@HUNTING_SCRIPTS)
       
        @followers.add_event(:RESTING_PREP_COMMANDS)
        @RESTING_COMMANDS.each { |i| fput(i) }
 
        @followers.add_event(:RESTING_SCRIPTS_START)
        run_scripts( @RESTING_SCRIPTS, true )
		
		if($rest_reason =~ /No blessing on weapon|Ammo had no effect \(need blessed or magical\)/i)
			echo "Need a blessing on weapon to continue hunting"
			Script.self.kill
		end
        # loop
        until(should_hunt?)
			@followers.add_event(:DISPLAY_WATCH)
            fput 'exp'
            display_watch_current()
            display_watch_average()
            display_watch_total()
            message( "Bigshot last rested because: #{$rest_reason}" ) if $rest_reason
            message( "Bigshot isn't hunting because: #{$not_hunting_reason}" ) if $not_hunting_reason
            sleep REST_INTERVAL
        end
 
        hunt()
    end
 
    def attack(target)
		echo "attack" if $bigshot_debug
        commands = find_routine(target)
        echo "Inside attack(target) #{commands}" if $bigshot_debug
 
        commands.each do |i|
            break unless valid_target?(target)
            break if wounded? || $bigshot_should_rest
            break if $ambusher_here
            break if target.status =~ /dead/ || !GameObj.npcs.any? {|s| s.id == target.id}
			break if should_flee?
			break if should_rest?
			break if @PRIORITY && !priority(target)
            stand() if !standing?
            cast_signs()
           
            cmd( i, target )
        end
        echo commands.size if $bigshot_debug
        #sleep 1 if commands.size == 0
    end
 
    def goto(id)
		echo "goto" if $bigshot_debug
        prepare_for_movement()
        until( Room.current.id == id )
            run_script( 'go2', true, [ id, '_disable_confirm_' ] )
        end
    end
 
    def start_watch()
		echo "start_watch" if $bigshot_debug
        @START_TIME = Time.now.to_i
    end
 
    def stop_watch()
		echo "stop_watch" if $bigshot_debug
        if( @START_TIME > 100 )
            @STORED_TIMES.push( Time.now.to_i - @START_TIME )
        end
        @START_TIME = 0
    end
 
    def display_watch_current()
		echo "display_watch_current" if $bigshot_debug
        if( @STORED_TIMES.size > 0 )
            seconds = @STORED_TIMES[-1]
            message( sprintf( "Bigshot: Last Hunt: %d min. %0.2f secs.",
                seconds / 60, seconds % 60 ) )
        end
    end
 
    def display_watch_average()
		echo "display_watch_average" if $bigshot_debug
        average = 0
        if( @STORED_TIMES.size == 1 )
            average = @STORED_TIMES[0]
        elsif( @STORED_TIMES.size > 1 )
            @STORED_TIMES.each { |i| average += i }
            average /= @STORED_TIMES.size
        else
            return
        end
        message( sprintf( "Bigshot: Average Hunt: %d min. %0.2f secs.",
            average / 60, average % 60 ) )
    end
 
    def display_watch_total()
		echo "display_watch_total" if $bigshot_debug
        total = Time.now.to_i - @BIRTH_TIME
        message( sprintf( "Bigshot: Total Time Running: %d min.  %0.2f secs.",
            total / 60, total % 60 ) )
    end
 
    def room_id()
		echo "room_id" if $bigshot_debug
        return Room.current.id()
    end
 
    def name()
        return Char.name
    end
 
    def poaching?()
		echo "poaching?" if $bigshot_debug
		if($bigshot_quick && $grouplist.size > 0)
			return false
        elsif(leading?)
            (checkpcs - $grouplist).each { |i| return true unless @followers.get_names.include?(i) }
			if solo? && !$bigshot_quick
				GameObj.npcs.each { |i| return true if i.type =~ /companion/ && i.name !~ /#{$companion}/i } 
				GameObj.npcs.each { |i| return true if i.type =~ /familiar/ && i.name !~ /#{$familiar}/i }
			end
            return false
        else
            return false
        end
    end
 
    def should_flee?( just_entered = false )
		return false if $bigshot_quick
		return true if $bigshot_flee
        GameObj.loot.each { |i| return true if i.noun =~ /cloud|breath/ } if @FLEE_CLOUDS
		GameObj.loot.each { |i| return true if i.name == 'intense shimmering circle' } if @FLEE_CLOUDS
		GameObj.loot.each { |i| return true if i.noun =~ /vine/ } if @FLEE_VINES
		GameObj.loot.each { |i| return true if i.noun =~ /web/ } if @FLEE_WEBS
        return true if GameObj.npcs.any?  { |i| @ALWAYS_FLEE_FROM.include?(i.noun) or @ALWAYS_FLEE_FROM.include?(i.name) }
        return true if checkpcs.any?      { |i| @ALWAYS_FLEE_FROM.include?(i) }
        return true if !leading? && checkpcs.empty?
 
        npcs = GameObj.npcs.find_all { |i| i.status !~ /dead/ }
		npcs.delete_if { |npc| (@INVALID_TARGETS.include?(npc.name) or @INVALID_TARGETS.include?(npc.noun)) }
		npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
	    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
		npcs.delete_if { |npc| npc.noun =~ /^(?:arm|arms|grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i}
		npcs.delete_if { |npc| ['quickly growing troll king', 'severed troll arm', 'severed troll leg'].include?(npc.name) }
		npcs.delete_if { |npc| npc.type =~ /companion|familiar/i && npc.type !~ /aggressive npc/i }
	   
		flee_count = (just_entered && @LONE_TARGETS_ONLY) ? 1 : @FLEE_COUNT
		if npcs.size > flee_count
			return true
		end
    end
 
    def valid_target?( target, just_entered = false )
		echo "valid_target?" if $bigshot_debug
        return false if target == nil || target == false
        return false if should_flee?(just_entered)
        return false if just_entered && poaching?
        return false if target.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && target.name !~ /ethereal|celestial|unworldly/i
       
        if( !CharSettings['targetable'].include?(target.name) && !CharSettings['untargetable'].include?(target.name) && target.status !~ /dead/ )
            result = dothistimeout( "target ##{target.id}", 3, /^You are now targeting|^You can't target/ )
            if( result =~ /^You are now targeting/ )
                CharSettings['targetable'].push(target.name) if target.status !~ /dead/
            elsif( result =~ /^You can't target/ )
                CharSettings['untargetable'].push(target.name) if target.status !~ /dead/
            end
        end
        return false if CharSettings['untargetable'].include?(target.name)
        if (target.status !~ /dead/) and GameObj.npcs.any? { |n| n.id == target.id } and (@TARGETS.nil? or @TARGETS.keys.any? { |i| target.name =~ /#{i}/i or target.noun =~ /#{i}/i })
            return true
        else
            return false
        end
    end
 
    def sort_npcs()
		echo "sort_npcs" if $bigshot_debug
		if $bigshot_quick
			targets = Hash.new
			tokens = []
			if @QUICKHUNT_TARGETS.nil?
				@QUICKHUNT_TARGETS = Hash.new 
				@QUICKHUNT_TARGETS["ZZTestZZ"]="ZZTestZZ"
			end
			npcs = GameObj.npcs.find_all { |i| i.status !~ /dead/ }
			npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
			npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
			npcs.each {|i| tokens.push(i.name)}
			tokens.uniq.each {|i| 
				if i =~ /#{@QUICKHUNT_TARGETS.keys.join('|')}/i
					next
				else
					targets[i] = "quick"
				end
			}
			@TARGETS.replace(@QUICKHUNT_TARGETS)
			@TARGETS.merge!(targets)
			targets = @TARGETS
		else
			targets = @TARGETS
		end
			   
		npcs = GameObj.npcs
		sorted = Array.new
		targets.keys.each { |target| sorted += npcs.find_all { |npc| (npc.name =~ /^#{target}$/i or npc.noun =~ /^#{target}$/i) }.to_a }
		sorted.flatten
    end
    
	def priority(target)
		echo "priority" if $bigshot_debug
		echo "priority check: #{(!$current_room_npcs.zip($room_npcs_last_check).map{|x,y| x.id==y.id}.any?{|s| s == false})}" if $bigshot_debug
		return true if (!$current_room_npcs.zip($room_npcs_last_check).map{|x,y| x.id==y.id}.any?{|s| s == false})
		$room_npcs_last_check = GameObj.npcs
		priority = false
		stoppriority = false
		npcs = GameObj.npcs.find_all { |i| i.status !~ /dead/ }
		npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
	    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
		@TARGETS.keys.each{|t|
			break if stoppriority == true
			npcs.each{|s|
				break if stoppriority == true
				if (s.name =~ /#{t}/i or s.noun =~ /#{t}/i)
					if s.name == target.name
						stoppriority = true
						priority = true
					else
						stoppriority = true
					end
				end
			}
		}
		return priority
	end
	
    def find_target( target, just_entered = false )
		echo "find_target" if $bigshot_debug
        return target if valid_target?(target, just_entered)
		
		if @PRIORITY
			sort_npcs.each { |i| return i if valid_target?( i, just_entered ) && priority(i)  }
		else
			sort_npcs.each { |i| return i if valid_target?( i, just_entered ) }
		end
        return nil
    end
 
    def rt?()
		echo "rt?" if $bigshot_debug
        return checkrt()
    end
 
    def fried?()
        if( percentmind() >= @FRIED )
            return true
        end
        return false
    end
 
    def oom?()
        if( percentmana() < @OOM )
            return true
        end
        return false
    end
 
    def ammo_on_ground(ammo)
		echo "ammo_on_ground" if $bigshot_debug
        return GameObj.loot.find { |i| i.name =~ /\b#{ammo}s?\b/i or i.noun =~ /^#{ammo}s?$/i }
    end
 
    def gather_ammo()
		echo "gather_ammo" if $bigshot_debug
        ammo = @AMMO
		container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
		hide = @HIDE_FOR_AMMO
		
        return if wounded?
		
		if ammo.nil? or ammo.empty?
			return
		end
		
		if ammo =~ /\b(arrow|bolt|dart)\b/i
			ammo_noun = $1
		else
			echo "failed to gather: invalid ammo type specified (use the full name)"
		end
		
		if container.nil?
			echo "failed to gather: you must specify an ammo container to use this feature"
			return
		end
 
        while( ammo_on_ground(ammo_noun) )
            change_stance('defensive')
                       
			unless GameObj.right_hand.id.nil?
				line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
				if line =~ /closed/
					fput "open my ##{container.id}"
					fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
				end
			end
                       
            result = dothistimeout( "gather #{ammo_noun}", 2, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/ )
                       
			if( result =~ /on the ground/)
				result = dothistimeout "get #{ammo_noun}s", 3, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/
			end
 
            if( result =~ /^You gather|^You pick up/ )
                dothistimeout( "put my #{ammo_noun} in my #{ammo_noun}s in my #{container.noun}", 2, /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/ )
                bs_put "put my #{ammo_noun} in my ##{container.id}" if righthand?
			elsif( result =~ /You may only/ )
				return
            elsif( result == false || result =~ /^I could not find|^What were you/ )
                return
            elsif( result =~ /reach/ )
				bs_put 'hide' if hide and not hidden?
				sleep 4
            end
        end
    end
 
	def reset_variables()
		echo "reset_variables" if $bigshot_debug
		$ambusher_here = false
		$bigshot_smite_list = []
		$bigshot_aim = 0
		$bigshot_ambush = 0
		$bigshot_archery_aim = 0
		$bigshot_archery_stuck_location = []
		$bigshot_unarmed_tier = 1
		$bigshot_unarmed_followup = false
		$bigshot_unarmed_followup_attack = ""
		$bigshot_703_list = []
		$bigshot_1614_list = []
	end
	
    def wounded?()
		if $bigshot_quick
			return false
        elsif(@WOUNDED_EVAL)
            return eval @WOUNDED_EVAL
        else
            return false
        end
    end
 
    def should_hunt?()
		echo "should_hunt?" if $bigshot_debug
		if(wounded?)
            $not_hunting_reason = 'wounded.'
            return false
        elsif( percentencumbrance >= @ENCUMBERED )
            $not_hunting_reason = 'encumbered.'
            return false
        elsif( @RESTING_SCRIPTS.any? { |i| running?(i) } )
            $not_hunting_reason = 'resting scripts still running.'
            return false
        end
 
        followers_should = (leading? && !solo?) ? @followers.should_hunt? : true
        if(followers_should)
            if( percentmind() > @REST_TILL_EXP )
                $not_hunting_reason = 'mind still above threshold.'
                return false
            elsif( percentmana() < @REST_TILL_MANA )
                $not_hunting_reason = 'mana still below threshold.'
                return false
            elsif( checkspirit() < @REST_TILL_SPIRIT )
                $not_hunting_reason = 'spirit still below threshold.'
                return false
            end
        else
            $not_hunting_reason = 'followers still need rest.'
            return false
        end
		$bigshot_status = :hunting
        return true
    end
 
    def should_rest?()
		if($bigshot_quick)
			return false
        elsif($bigshot_should_rest)
            $rest_reason = "$bigshot_should_rest was set to true." unless $rest_reason
			$bigshot_status = :resting
            return true
        elsif(wounded?)
            $rest_reason = "wounded."
			$bigshot_status = :resting
            return true
        elsif( percentencumbrance >= @ENCUMBERED )
            $rest_reason = "encumbered."
			$bigshot_status = :resting
            return true
        elsif( leading? && !solo? && @followers.emergency_rest? )
            $rest_reason = "emergency rest."
			$bigshot_status = :resting
            return true
        end
 
        followers_fried = (leading? && !solo?) ? @followers.should_rest? : true
 
        if(followers_fried)
            if(fried?)
                $rest_reason = "fried."
				$bigshot_status = :resting
                return true
            elsif(oom?)
                wrack() if @USE_WRACKING
                return false if !oom?
               
                $rest_reason = "out of mana."
				$bigshot_status = :resting
                return true
            end
        end
       
        $rest_reason = "none."
        return false
    end
 
    def cast_signs(single_cast = false)
		echo "cast_signs?" if $bigshot_debug
        @SIGNS.each do |i|
            i = i.to_i
			next if [ 9903,9904,9905,9906,9907,9908,9909,9910,9912,9913,9914,9918 ].include?(i) and Spell[9012].active?
            next if i == 9918
            next if i == 9603 && Spell[9604].active?
            next if i == 9605 && Spell[9606].active?
            sign = Spell[i]
            next unless sign.known?
 
            # wrack?
            mana_cost = sign.mana_cost > 1 ? sign.mana_cost : 0 # Many erroneously return 1
            wrack() if !sign.affordable? and mana_cost > checkmana and @USE_WRACKING
 
            if( !sign.active? && sign.affordable? )
                if( i  == 9805 )
                    2.times { sign.cast }
                else
                    while(1)
                        result = sign.cast
                        break if result !~ /Spell Hindrance/ || !sign.affordable? || dead?
                    end
                end
                               
				break if single_cast
            end
        end
    end
 
    def loot()
        echo "loot" if $bigshot_debug
		waitrt?
		if checkroom("Duskruin Arena, Dueling Sands").nil?
			dead_npcs = GameObj.npcs.find_all { |i| i.status == 'dead' && i.type !~ /escort/i }
			reset_variables() if !dead_npcs.nil? && dead_npcs != []
			if @DELAY_LOOT && sort_npcs.any? {|s| valid_target?(s)} && (!dead_npcs.nil? && dead_npcs != []) && !should_flee?
				if $last_loot.nil?
					$last_loot=Time.now + 15
				elsif $last_loot <= Time.now
					dead_npcs.each { |i|
						$last_loot = nil
						change_stance('defensive') if GameObjNpcCheck() > 0 && @LOOT_STANCE
						if(@LOOT_SCRIPT)
							run_script( @LOOT_SCRIPT, true )
							break
						else
							bs_put "loot ##{i.id}"
						end
					}
				end
			else
				dead_npcs.each { |i|
					$last_loot = nil
					change_stance('defensive') if GameObjNpcCheck() > 0 && @LOOT_STANCE
					if(@LOOT_SCRIPT)
						run_script( @LOOT_SCRIPT, true )
						break
					else
						bs_put "loot ##{i.id}"
					end
				}
			end
		end
    end
 
    def prepare_for_movement()
		echo "prepare_for_movement" if $bigshot_debug
		reset_variables()
		change_stance('defensive')
        if( leading? && !solo? )
			@followers.add_event(:PREP_REST)
            wait_while { @followers.roundtime? }
            sleep 0.3
        end
		cmd_bless() if @BLESS && $bigshot_bless.count > 0
    end
 
    def bs_wander()
		echo "bs_wander" if $bigshot_debug
		$wander_rooms    ||= Array.new
               
        wander = proc {
            room = Room.current
            next_room_options = room.wayto.keys - @HUNTING_BOUNDARIES
			next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
			next_room = next_room_options.find_all { |r| not $wander_rooms.include?(r) }
			if next_room.empty?
				next_room = $wander_rooms.find { |r| next_room_options.include?(r) }
			else
				next_room = next_room[rand(next_room.length)]
			end
			$wander_rooms.delete(next_room)
			$wander_rooms.push(next_room)
			way = room.wayto[next_room]
            if way.class == String
				pause @WANDER_WAIT
                move(way)
            else
                way.call
            end
			GameObj.pcs.each {|s| if s.status =~ /kneeling|sitting|^lying|prone/;fput "pull #{s.noun}";end;} if GameObj.npcs.any? {|s| s.type =~ /aggressive npc/} && @PULL
			cast_signs(true)
        }
	   
        while true  # wander, check for players
			reset_variables()
			change_stance('defensive')
			exit if $bigshot_quick
            npcs = GameObj.npcs
            npcs.delete_if { |npc| (npc.status =~ /dead/) }
            sort_npcs.each{ |i| return i if valid_target?( i, true ) and no_players == true and (GameObjNpcCheck() > 0) }
            return if should_rest?
			wander.call
            sleep 0.1
			$bigshot_flee = false
        end
    end
 
	def CompanionCheck() 
		if ( Char.prof =~ /Ranger/i && Spell[630].known? && GameObj.npcs.any?{|i| i.type =~ /companion/} && $companion == nil )
			npcs = GameObj.npcs.find_all { |i| i.type =~ /companion/i }
			npcs.each {|i| 
				res = dothistimeout "lean ##{i.id}", 1, /your direction in acknowledgement|rubbing.*gently|while it is flying|You lean toward/i
				if res =~ /rubbing.*gently/i
					$companion = i.name
					echo "Ranger Companion set to #{i.name}"
					break
				end
			}
		end
		if ( Char.prof =~ /Wizard/i && Spell[920].known? && GameObj.npcs.any?{|i| i.type =~ /familiar/} )
			res = dothistimeout "tell familiar to return", 1, /You sense understanding from your .*\.|You have no familiar at this time\./i
			if res =~ /You sense understanding from your/i
				res.sub!('You sense understanding from your ','')
				res.gsub!('.','')
				GameObj.npcs.each{|s|
					if s.name =~ /#{res}/i
						$familiar = s.name
						break
					end
				}
				echo "Familiar set as #{$familiar}"
			end
		end
	end
	
	def RoaterEscape()
		find_all_containers_var = nil
		empty_hands
		hp = proc { |ss| if ss =~ /^You are wearing/; DownstreamHook.remove('find_all_container_ids'); nil; else; ss; end }
		DownstreamHook.add('find_all_container_ids', hp)
		restore_silent = script.silent
		restore_want_downstream = script.want_downstream
		restore_want_downstream_xml = script.want_downstream_xml
		script.silent = true
		script.want_downstream = false
		script.want_downstream_xml = true
		clear
		put 'inventory containers'
		script.silent = restore_silent
		timeout = Time.now + 30
		container_ids = []
		while (Time.now < timeout) and (line = get)
			if line =~ /^You are wearing/
				container_ids = line.scan(/<a exist=\"([^\"]+)\"/).flatten
				break
			end
		end
		script.want_downstream = restore_want_downstream
		script.want_downstream_xml = restore_want_downstream_xml
		clear
		find_all_containers_var = container_ids.collect { |id| GameObj[id] }
		find_all_containers_var.each{|i| 
			if i.contents.nil?
				fput "look in ##{i.id}"
			end
			i.contents.each{|s| 
				if s.name =~ /alfange|basilard|bodkin|cinquedea|dagger|dirk|knife|kozuka|ice pick|misericord|parazonium|pavade|poignard|pugio|scramasax|sgian achlais|spike|stiletto|tanto|sidearm-of-Onar/i
					fput "_drag ##{s.id} right"
					while !checkroom("The Belly of the Beast").nil?
						waitrt?
						fput "attack wall"
					end
					fput "_drag ##{s.id} ##{i.id}"
					break
				end
			}
		}
		fill_hands
	end
 
    def bs_put(message)
		echo "bs_put" if $bigshot_debug
        unless script = Script.self then respond('--- waitfor: Unable to identify calling script.'); return false; end
        clear
        put(message)
 
        while string = get
            if string =~ /(?:\.\.\.wait |Wait )[0-9]+/
                hold_up = string.slice(/[0-9]+/).to_i
                sleep(hold_up - 1) unless hold_up.nil? || hold_up == 1
                clear
                put(message)
                next
            elsif string =~ /struggle.+stand/
                clear
                bs_put("stand")
                next
            elsif string =~ /stunned|can't do that while|cannot seem|can't seem|don't seem|Sorry, you may only type ahead/
                if dead?
                    echo("You're dead...! You can't do that!")
                    sleep 0.25
                    script.downstream_buffer.unshift(string)
                    return false
                elsif checkstunned
                    while checkstunned
                        sleep("0.25".to_f)
                    end
                elsif checkwebbed
                    while checkwebbed
                        sleep("0.25".to_f)
                    end
                else
                    sleep(0.25)
                end
                clear
                put(message)
                next
            else
                script.downstream_buffer.unshift(string)
                return string
            end
        end
    end
 
    # gui
    def self.setup
        Gtk.queue {
            $OP_WINDOW = Gtk::Window.new
            $OP_WINDOW.title = "Big Shot: v#{BIGSHOT_VERSION}"
            $OP_WINDOW.set_border_width(10)
			$OP_WINDOW.keep_above = true
            $OP_BOX = Gtk::VBox.new(false)
            $OP_BOX.set_border_width(5)
 
            $OP_VERTICAL_BOX1 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX2 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX3 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX4 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX5 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX6 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX7 = Gtk::VBox.new(false, 0)
            $OP_VERTICAL_BOX8 = Gtk::VBox.new(false, 0)
			$OP_VERTICAL_BOX9 = Gtk::VBox.new(false, 0)
			$OP_VERTICAL_BOX10 = Gtk::VBox.new(false, 0)
			$OP_VERTICAL_BOX11 = Gtk::VBox.new(false, 0)
 
            $OP_WINDOW.add($OP_BOX)
            $OP_NOTEBOOK = Gtk::Notebook.new
            $OP_NOTEBOOK.set_show_border(true)
            $OP_BOX.add($OP_NOTEBOOK)
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX1, Gtk::Label.new('General'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX2, Gtk::Label.new('Resting'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX3, Gtk::Label.new('Hunting Map'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX4, Gtk::Label.new('Hunting'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX5, Gtk::Label.new('Attacking'))
			$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX6, Gtk::Label.new('Commands'))
			$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX7, Gtk::Label.new('UAC'))
			$OP_NOTEBOOK.append_page($OP_VERTICAL_BOX8, Gtk::Label.new('MSTRIKE'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX9, Gtk::Label.new('Should_hunt?'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX10, Gtk::Label.new('Should_rest?'))
            $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX11, Gtk::Label.new('Ammo/Wands'))
 
            $OP_ENTRY = Hash.new # For mapping entries to variables
            $OP_TABLE_SIZE = Hash.new # For mapping table sizes
        }
 
        Gtk.queue {
            $OP_TABLE1 = Gtk::Table.new(6, 3, false)
            $OP_TABLE1.row_spacings=3
            $OP_TABLE1.column_spacings=3
            $OP_VERTICAL_BOX1.pack_start($OP_TABLE1, false, false, 0)
 
            $OP_TABLE2 = Gtk::Table.new(6, 3, false)
            $OP_TABLE2.row_spacings=3
            $OP_TABLE2.column_spacings=3
            $OP_VERTICAL_BOX2.pack_start($OP_TABLE2, false, false, 0)
 
            $OP_TABLE3 = Gtk::Table.new(6, 3, false)
            $OP_TABLE3.row_spacings=3
            $OP_TABLE3.column_spacings=3
            $OP_VERTICAL_BOX3.pack_start($OP_TABLE3, false, false, 0)
 
            $OP_TABLE4 = Gtk::Table.new(6, 3, false)
            $OP_TABLE4.row_spacings=3
            $OP_TABLE4.column_spacings=3
            $OP_VERTICAL_BOX4.pack_start($OP_TABLE4, false, false, 0)
 
            $OP_TABLE5 = Gtk::Table.new(6, 3, false)
            $OP_TABLE5.row_spacings=3
            $OP_TABLE5.column_spacings=3
            $OP_VERTICAL_BOX5.pack_start($OP_TABLE5, false, false, 0)
 
            $OP_TABLE6 = Gtk::Table.new(6, 3, false)
            $OP_TABLE6.row_spacings=1
            $OP_TABLE6.column_spacings=1
            $OP_VERTICAL_BOX6.pack_start($OP_TABLE6, false, false, 0)
 
            $OP_TABLE7 = Gtk::Table.new(6, 3, false)
            $OP_TABLE7.row_spacings=3
            $OP_TABLE7.column_spacings=3
            $OP_VERTICAL_BOX7.pack_start($OP_TABLE7, false, false, 0)
 
            $OP_TABLE8 = Gtk::Table.new(6, 3, false)
            $OP_TABLE8.row_spacings=3
            $OP_TABLE8.column_spacings=3
            $OP_VERTICAL_BOX8.pack_start($OP_TABLE8, false, false, 0)
			
			$OP_TABLE9 = Gtk::Table.new(6, 3, false)
            $OP_TABLE9.row_spacings=3
            $OP_TABLE9.column_spacings=3
            $OP_VERTICAL_BOX9.pack_start($OP_TABLE9, false, false, 0)

			$OP_TABLE10 = Gtk::Table.new(6, 3, false)
            $OP_TABLE10.row_spacings=3
            $OP_TABLE10.column_spacings=3
            $OP_VERTICAL_BOX10.pack_start($OP_TABLE10, false, false, 0)
			
			$OP_TABLE11 = Gtk::Table.new(6, 3, false)
            $OP_TABLE11.row_spacings=3
            $OP_TABLE11.column_spacings=3
            $OP_VERTICAL_BOX11.pack_start($OP_TABLE11, false, false, 0)
        }
 
        def self.add_label_entry(table, label, variable)
            size = $OP_TABLE_SIZE[table] || 0
 
            label = Gtk::Label.new(label)
            align = Gtk::Alignment.new 1, 0, 0, 0
            align.set_padding(4, 0, 3, 4)
            align.add(label)
            table.attach(align, 0, 1, size, size + 1)
 
            entry = Gtk::Entry.new
            entry.text = UserVars.op[variable].to_s
            entry.set_width_request(157)
            table.attach(entry, 1, 2, size, size + 1)
 
            $OP_ENTRY[variable] = entry
            $OP_TABLE_SIZE[table] += 1
        end
		
        def self.add_dropdown(table, dropdown, variable, options)
            size = $OP_TABLE_SIZE[table] || 0
			i = 0
            label = Gtk::Label.new(dropdown)
			dropdown = Gtk::ComboBox.new
			options.split(',').each{|s|
				dropdown.append_text(s)
			}
			if UserVars.op[variable].nil?
				dropdown.set_active(0)
			else
				if UserVars.op[variable].class.to_s != "Fixnum"
					UserVars.op[variable] = 0
				end
				dropdown.set_active(UserVars.op[variable])
			end
            align = Gtk::Alignment.new 1, 0, 0, 0
			align2 = Gtk::Alignment.new 1, 0, 1, 0
            align.set_padding(4, 0, 3, 4)
			align2.set_padding(0, 0, 0, 0)
			align.add(label)
            align2.add(dropdown)
            table.attach(align, 0, 1, size, size + 1)
			table.attach(align2, 1, 2, size, size + 1)
			$OP_ENTRY[variable] = dropdown
            $OP_TABLE_SIZE[table] += 1
        end
 
        Gtk.queue {
            $OP_ENTRY = Hash.new
            add_label_entry($OP_TABLE2, "*room id:", 'resting_room_id')
            add_label_entry($OP_TABLE2, "pre-rest commands:", 'resting_commands')
            add_label_entry($OP_TABLE2, "active resting scripts:", 'resting_scripts')
            add_dropdown($OP_TABLE2, "Fog Options:", 'fog_return', 'None,Spirit Guide(130),Voln Symbol of Return,Traveler\'s Song(1020)')
            add_label_entry($OP_TABLE3, "*starting room ID:", 'hunting_room_id')
            add_label_entry($OP_TABLE3, "*boundary rooms:", 'hunting_boundaries')
            add_label_entry($OP_TABLE4, "valid targets:", 'targets')
			add_label_entry($OP_TABLE4, "quickhunt targets:", 'quickhunt_targets')
            add_label_entry($OP_TABLE4, "attack stance:", 'hunting_stance')
            add_label_entry($OP_TABLE4, "pre-hunt commands:", 'hunting_prep_commands')
            add_label_entry($OP_TABLE4, "active hunting scripts:", 'hunting_scripts')
            add_label_entry($OP_TABLE4, "society abilities/spells/cmans:", 'signs')
            add_label_entry($OP_TABLE4, "loot script:", 'loot_script')
            add_label_entry($OP_TABLE4, "wracking spirit >=", 'wracking_spirit')
			add_label_entry($OP_TABLE5, "Ambush aiming locations (head, etc):", 'ambush')
			add_label_entry($OP_TABLE5, "Archery aiming locations (head, etc):", 'archery_aim')
            add_label_entry($OP_TABLE5, "flee if enemy count is >", 'flee_count')
            add_label_entry($OP_TABLE5, "...but don't count these:", 'invalid_targets')
            add_label_entry($OP_TABLE5, "...and always flee from:", 'always_flee_from')
			add_label_entry($OP_TABLE5, "flee from environment message:", 'flee_message')
			add_label_entry($OP_TABLE5, "Wait before wandering to another room:", 'wander_wait')
			add_label_entry($OP_TABLE6, "hunting commands(a):", 'hunting_commands')
            add_label_entry($OP_TABLE6, "hunting commands(b):", 'hunting_commands_b')
            add_label_entry($OP_TABLE6, "hunting commands(c):", 'hunting_commands_c')
			add_label_entry($OP_TABLE6, "hunting commands(d):", 'hunting_commands_d')
			add_label_entry($OP_TABLE6, "hunting commands(e):", 'hunting_commands_e')
			add_label_entry($OP_TABLE6, "hunting commands(f):", 'hunting_commands_f')
			add_label_entry($OP_TABLE6, "hunting commands(g):", 'hunting_commands_g')
			add_label_entry($OP_TABLE6, "hunting commands(h):", 'hunting_commands_h')
			add_label_entry($OP_TABLE6, "hunting commands(i):", 'hunting_commands_i')
			add_label_entry($OP_TABLE6, "hunting commands(j):", 'hunting_commands_j')
            add_label_entry($OP_TABLE6, "fried hunting commands:", 'disable_commands')
			add_label_entry($OP_TABLE6, "quick hunting commands:", 'quick_commands')
			add_label_entry($OP_TABLE7, "Tier 3 Attack", 'tier3')
			add_label_entry($OP_TABLE7, "Aim at location (head, etc)", 'aim')
			add_label_entry($OP_TABLE7, "MSTRIKE when creatures equal or greater", 'uac_mstrike')
			add_label_entry($OP_TABLE8, "MSTRIKE during cooldown stamina requirement", 'mstrike_stamina_cooldown')
			add_label_entry($OP_TABLE8, "QUICKSTRIKE stamina requirement", 'mstrike_stamina_quickstrike')
			add_label_entry($OP_TABLE8, "Unfocused MSTRIKE when creatures equal or greater", 'mstrike_mob')
            add_label_entry($OP_TABLE9, "*when percentmind <=", 'rest_till_exp')
            add_label_entry($OP_TABLE9, "...*and percentmana >=", 'rest_till_mana')
            add_label_entry($OP_TABLE9, "...and CHECKspirit >=", 'rest_till_spirit')
            add_label_entry($OP_TABLE10, "*when percentmind >=", 'fried')
            add_label_entry($OP_TABLE10, "...*or percentmana <=", 'oom')
            add_label_entry($OP_TABLE10, "...or percentencumbrance >=", 'encumbered')
            add_label_entry($OP_TABLE10, "...or wounded eval:", 'wounded_eval')
            add_label_entry($OP_TABLE11, "find ammo in this container:", 'ammo_container')
            add_label_entry($OP_TABLE11, "use this ammo type:", 'ammo')
            add_label_entry($OP_TABLE11, "fresh wand container:", 'fresh_wand_container')
            add_label_entry($OP_TABLE11, "dead wand container:", 'dead_wand_container')
            add_label_entry($OP_TABLE11, "use this wand type:", 'wand')
        }
 
        def self.add_checkbox(table, x_pos, label, variable, default = false)
            size = $OP_TABLE_SIZE[table] || 0
            checkbox = Gtk::CheckButton.new label
            value = UserVars.op[variable].nil? ? default : UserVars.op[variable]
            checkbox.set_active(value)
            table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
            $OP_ENTRY[variable] = checkbox
            $OP_TABLE_SIZE[table] += 1 if x_pos == 1
        end
 
        Gtk.queue {
            add_checkbox($OP_TABLE1, 0, "Engage deadmans switch", 'dead_man_switch')
            add_checkbox($OP_TABLE1, 1, "Monitor interaction", 'monitor_interaction')
            add_checkbox($OP_TABLE1, 0, "Depart/rerun if dead", 'depart_switch')
            add_checkbox($OP_TABLE1, 1, "Flee from clouds", 'flee_clouds')
			add_checkbox($OP_TABLE1, 1, "Flee from vines", 'flee_vines')
			add_checkbox($OP_TABLE1, 1, "Flee from webs", 'flee_webs')
			add_checkbox($OP_TABLE4, 0, "Priority hunt", 'priority')
            add_checkbox($OP_TABLE4, 1, "Use sign of wracking/sigil of power/symbol of mana", 'use_wracking')
			add_checkbox($OP_TABLE4, 0, "Delay looting", 'delay_loot')
			add_checkbox($OP_TABLE4, 1, "Defensive stance before looting", 'loot_stance')
			add_checkbox($OP_TABLE4, 1, "Pull players to feet", 'pull', true)
            add_checkbox($OP_TABLE5, 1, "Spam attacks (recommended)", 'spam', true)
            add_checkbox($OP_TABLE5, 1, "Approach lone targets only", 'lone_targets_only', false)
			add_checkbox($OP_TABLE5, 1, "Bless weapon?", 'bless', false)
			add_checkbox($OP_TABLE7, 1, "Use Voln SMITE?", 'uac_smite', false)
			add_checkbox($OP_TABLE8, 1, "MSTRIKE during cooldown", 'mstrike_cooldown', false)
			add_checkbox($OP_TABLE8, 1, "Use QUICKSTRIKE for MSTRIKE", 'mstrike_quickstrike', false)
            add_checkbox($OP_TABLE11, 1, "Hide while waiting to pick up ammo", 'hide_for_ammo')
            add_checkbox($OP_TABLE11, 1, "Use wands when out of mana", 'wand_if_oom')
        }
       
        Gtk.queue {
            $OP_WINDOW.signal_connect("delete_event") {
                $OP_SETUP_COMPLETED = true
            }
        }
       
        Gtk.queue {
            $OP_TOOLTIPS = Gtk::Tooltips.new.enable
 
            label = Gtk::Label.new
            label.set_markup("<i>Bigshot is the leader of the Battle Patrol.\nHe comes equipped with a gun as long as his entire superstructure.\nTakes the edge off.\n\n\n***Settings with * are required.***</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(50, 0, 0, 40)
            align.add(label)
            $OP_TABLE1.attach(align, 1, 2, 8, 9)
 
            commands_tip =  "Example 1: 413 target, 903 target\nExample 2: 903 target(x2)\nExample 3: 903 target(xx)\nExample 4: 910 target(m50), 903 target\nExample 5: unarmed punch, wait 30\nExample 1 will cast 413 then 903 on the target. Example 2 will cast 903 on the target twice. Example 3 will cast 903 on the target until the fight is over. Example 4 will cast 910 if mana is at least 50, otherwise it will cast 903. Example 5 will start the unarmed routine with punch as the main attack. It will attack once, then wait 30 seconds for another attack to happen before attacking again.\nSeparate all commands with commas.\n\nNew feature: 'and'.\nFor example: stance def and 1615 target, kill target(xx)"
            $OP_TOOLTIPS.set_tip($OP_ENTRY['hunting_commands'], commands_tip, "")
            $OP_TOOLTIPS.set_tip($OP_ENTRY['g_hunting_commands'], commands_tip, "")
            $OP_TOOLTIPS.set_tip($OP_ENTRY['g_disable_commands'], commands_tip, "")
 
            signs_tip = "Shadow Mastery - 9603\nSurge of Strength - 9605\n\nSigil of Contact - 9703\nSigil of Resolve - 9704\nSigil of Minor Bane - 9705\nSigil of Defense - 9707\nSigil of Offense - 9708\nSigil of Minor Protection - 9710\nSigil of Focus - 9711\nSigil of Mending - 9713\nSigil of Concentration - 9714\nSigil of Major Bane - 9715\nSigil of Major Determination - 9716\nSigil of Major Protection - 9719\n\nSign of Warding - 9903\nSign of Striking - 9904\nSign of Thought - 9906\nSign of Defending - 9907\nSign of Smiting - 9908\nSign of Staunching - 9909\nSign of Deflection - 9910\nSign of Swords - 9912\nSign of Shields - 9913\nSign of Dissipation - 9914\nSign of Madness - 9916\n\nSymbol of Courage - 9805\nSymbol of Protection - 9806"
            $OP_TOOLTIPS.set_tip($OP_ENTRY['signs'], signs_tip, "")
			
			aim_tip = "Leave blank if you don't want to aim at anything\n\nSuggest leaving chest as last thing to aim at so you will always have something to hit"
			$OP_TOOLTIPS.set_tip($OP_ENTRY['aim'], aim_tip, "")
			$OP_TOOLTIPS.set_tip($OP_ENTRY['archery_aim'], aim_tip, "")
			
			mstrike_tip = "Set this to the highest you want your stamina to be before you MSTRIKE.\nImportant if MSTRIKEing during its cooldown or while using QUICKSTRIKE.\nLeave blank to use max stamina variable instead\nCombination of QUICKSTRIKE and MSTRIKE during cooldown may pop muscles.\nIve done best I can to ensure it doesn't happen, but depends on what you set your MSTRIKE stamina to.\n\nWorks in conjunction with MSTRIKE creature #, so if you meet the requirements for it and not this one you will MSTRIKE and visaversa."
			$OP_TOOLTIPS.set_tip($OP_ENTRY['mstrike_stamina_cooldown'], mstrike_tip, "")
			$OP_TOOLTIPS.set_tip($OP_ENTRY['mstrike_stamina_quickstrike'], mstrike_tip, "")
			
			mstrike_mob_tip = "How many creatures you want in the room before you perform an unfocused MSTRIKE.\nDefault is 2. Set to 1 to always do an unfocused MSTRIKE."
			$OP_TOOLTIPS.set_tip($OP_ENTRY['mstrike_mob'], mstrike_mob_tip, "")
			
			bless_tip = "Will bless whatever item ran out of blessing.\nWill do 304 if known or Symbol of Bless otherwise.\nIf you can do neither of those will rest and exit the script."
			$OP_TOOLTIPS.set_tip($OP_ENTRY['bless'], bless_tip, "")
			
			priority_tip = "Priority is based on order of valid targets box on hunting tab. Will switch to highest priority in room when attacking."
			$OP_TOOLTIPS.set_tip($OP_ENTRY['priority'], priority_tip, "")
			
			smite_tip = "Will SMITE a non-corporeal undead when tier is excellent during UAC Combat"
			$OP_TOOLTIPS.set_tip($OP_ENTRY['uac_smite'], smite_tip, "")
			
			flee_tip = "Input any text that when the game sends you want to move out of the room from\nlike a Roa'ter burrow attack \"You feel a rumble come from beneath your feet.\"\nSeperate different messages with a | in between them."
			$OP_TOOLTIPS.set_tip($OP_ENTRY['flee_message'], flee_tip, "")

			fog_tip = "None: Dont use any fog options when you return from a hunt\n\nSpirit Guide(130): Use 130 first, then if that fails Symbol of Return\n\nVoln Symbol of Return: Use Symbol of Return first, then if that fails 130\n\nTraveler's Song(1020): Use 1020 only"
			$OP_TOOLTIPS.set_tip($OP_ENTRY['fog_return'], fog_tip, "")
 
            size = $OP_TABLE_SIZE[$OP_TABLE3]
            label = Gtk::Label.new
            label.set_markup("<i>Note: Big Shot will not enter boundary rooms. The goal is to pin yourself into a hunting area.</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(75, 0, 0, 4)
            align.add(label)
            $OP_TABLE3.attach(align, 1, 2, size, size + 1)
 
            size = $OP_TABLE_SIZE[$OP_TABLE4]
            label = Gtk::Label.new
            label.set_markup("<i>Note: Use nouns or name for targets.\nMouse over society abilities field for more info.</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(10, 0, 0, 300)
            align.add(label)
            $OP_TABLE4.attach(align, 1, 2, size, size + 1)
 
            size = $OP_TABLE_SIZE[$OP_TABLE5]
            label = Gtk::Label.new
            label.set_markup("<i>Note: Use noun or name for flee info.\nMouse over some hunting commands field for more info.</i>")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(10, 0, 0, 200)
            align.add(label)
            $OP_TABLE5.attach(align, 1, 2, size, size + 1)
			
			size = $OP_TABLE_SIZE[$OP_TABLE8]
            label = Gtk::Label.new
            label.set_markup("1107 and 1607 automatically cast if appropriate when using MSTRIKE\nEmpaths and Paladins rejoice!")
            align = Gtk::Alignment.new(1, 0, 0, 0)
            align.set_padding(75, 0, 0, 75)
            align.add(label)
            $OP_TABLE8.attach(align, 1, 2, size , size + 1)
 
            $OP_WINDOW.show_all
        }
       
        $OP_SETUP_COMPLETED = false
        until($OP_SETUP_COMPLETED)
            sleep 0.5
        end
       
        UserVars.op ||= Hash.new
        $OP_ENTRY.keys.each { |key|
			echo "#{key} - #{$OP_ENTRY[key].class.to_s}" if $bigshot_debug
            if( $OP_ENTRY[key].class.to_s =~ /CheckButton/ )
                value = $OP_ENTRY[key].active?
                UserVars.op[key] = $OP_ENTRY[key].active?
			elsif ( $OP_ENTRY[key].class.to_s =~ /ComboBox/ )
				UserVars.op[key] = $OP_ENTRY[key].active
            else
                if(key == 'wounded_eval')
                    UserVars.op[key] = $OP_ENTRY[key].text
                else
                    UserVars.op[key] = $OP_ENTRY[key].text.strip.downcase
                end
            end
        }
        UserVars.save()
       
        Gtk.queue {
            $OP_WINDOW.destroy
        }
    end
end

if( script.vars[1].nil? || script.vars[1] =~ /solo|(bounty)|quick/i )
    bounty_mode = $1
	if script.vars[1] =~ /quick/i
		$bigshot_quick = true
	end
 
    bs = Bigshot.new(bounty_mode)
    bs.croak('Requires Lich V4') unless defined?(Gtk.queue) || defined?($bigshot_headless)
    bs.croak('Requires a mapped room.') if(( Room.current.id.nil? || Room.current.id == 4 ) && !$bigshot_quick)
    bs.lead()
	
elsif( script.vars[1] =~ /setup/i )
    Bigshot.setup()
 
elsif( script.vars[1] =~ /display/i )
    echo "Version: #{BIGSHOT_VERSION}"
    UserVars.op.each_pair { |k, v|
        echo "#{k}: #{v}" unless v.nil? || v.class.to_s == 'Array' || v =~ /^\s*$/
    }
	echo "Targetable Character Setting: #{CharSettings['targetable'].map{|c| c.downcase}.sort{|a,b| a.split(" ").last <=> b.split(" ").last}}"
	echo "Untargetable Character Setting: #{CharSettings['untargetable'].map{|c| c.downcase}.sort{|a,b| a.split(" ").last <=> b.split(" ").last}}"
	
elsif( script.vars[1] =~ /reset/i )
	CharSettings['targetable'] = nil
	CharSettings['untargetable'] = nil
	echo "Character Settings for Targetable and Untargetable are now reset"
	
elsif( script.vars[1] =~ /ranger|companion/i )
	$companion = nil
	echo "Ranger Companion reset"
	
elsif( script.vars[1] =~ /head|lead/i )
    # launch DRb server
    DRb.start_service( nil, Group.new )
    uri = DRb.uri
	
    Thread.new { DRb.thread.join }
 
    # launch DRb client
    DRb.start_service()
    bs = Bigshot.new()
 
    # set leader
    my_group = DRbObject.new( nil, uri )
    my_group.set_leader(bs)
 
    # announce/go
    (1..RALLY_TIME).each { |i| fput "whisper ooc group Bigshot rallying at #{uri}"; sleep 1; }
	echo "Waiting for members to join Bigshot rally..."
	wait_until{(my_group.size() > 0)}
	pause 3
    bs.lead(my_group)
 
elsif( script.vars[1] =~ /tail|follow/i )
    # Watch for rally
    group = nil
    bs = nil
    while( group.nil? && bs.nil? )
		echo "waiting for rally" if $bigshot_debug
        if( get =~ /rallying at (.*)\."$/ )
 
            # create group
            DRb.start_service()
            group = DRbObject.new( nil, $1 )
 
            # create Bigshot
            bs = Bigshot.new()
            group.add_member(bs)
            bs.keep_awake()
			bs.CompanionCheck()
			bs.NPCRoomCheck()
        end
    end
 
    # Participate
    bs.message("Joined group")
    leader = group.leader.name

	bs.groupcheck() if !checkpcs.nil?
	echo "Groupcheck done" if $bigshot_debug
 
    while(!dead?)
        begin
            bs.change_stance('defensive')
            bs.stand() if !standing?
            sleep 0.25
           
            # grab event
            event = bs.event_stack.size == 0 ? nil : bs.grab_event
            next if event.nil?
           
            # kertwang!
            until( checkpcs.include?(leader) )
                start_script( 'go2', [ group.room_id, '_disable_confirm_' ] )
                wait_while { running?('go2') }
                fput "join #{leader}"
                sleep 1
            end
   
            # process event
            bs.message("event: " + event.type.to_s)
            if( event.type == :HUNTING_PREP_COMMANDS )
				bs.HUNTING_PREP_COMMANDS.each { |i|
					if i =~ /^script\s+(.*?)(\s|$)(.*)/i
					   bs.cmd_run_script( $1, $3 )
					else
						fput(i)
					end
				}
   
            elsif( event.type == :CAST_SIGNS )
                bs.cast_signs()
   
            elsif( event.type == :HUNTING_SCRIPTS_START )
                bs.run_scripts( bs.HUNTING_SCRIPTS, false )
   
            elsif( event.type == :ATTACK )
                if( event.stale? ) # consider timestamp and room_id
                    bs.message("skipping attack because it's stale")
                    next
                end
 
                target = nil
                while( target = bs.find_target(target))
					next if event.type == :PREP_REST
					
					target = bs.find_target(nil) if @PRIORITY && !bs.priority(target)
                    bs.attack(target)
                end
   
            elsif( event.type == :HUNTING_SCRIPTS_STOP )
                bs.croak_scripts(bs.HUNTING_SCRIPTS)
   
            elsif( event.type == :RESTING_PREP_COMMANDS )
                $bigshot_should_rest = nil # need to reset this
                bs.RESTING_COMMANDS.each { |i| fput(i) }
   
            elsif( event.type == :RESTING_SCRIPTS_START )
                bs.run_scripts( bs.RESTING_SCRIPTS, true )
   
            elsif( event.type == :DISPLAY_WATCH )
                if( event.stale? )
                    bs.message("skipping display_watch because it's stale")
                    next
                end
				fput 'exp'
                bs.message( "Bigshot last rested because: #{$rest_reason}" ) if $rest_reason
                bs.message( "Bigshot isn't hunting because: #{$not_hunting_reason}" ) if $not_hunting_reason
                sleep( REST_INTERVAL / 10 )
            end
 
        rescue
            fput 'leave group'
            if( bs.RESTING_ROOM_ID && bs.RESTING_ROOM_ID != 4 )
                start_script( 'go2', [ bs.RESTING_ROOM_ID, '_disable_confirm_' ] )
                wait_while { running?('go2') }
            end
            echo "Fatal exception!"
            echo $!.to_s
            echo $!.backtrace.join("\n")
            Script.self.kill
        end
    end
end
