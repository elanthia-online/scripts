=begin

  bigshot.lic: the new optimus prime

  hunting script for hunting

        author: elanthia-online
  contributors: SpiffyJr, Tillmen, Kalros, Hazado, Tysong, Athias, Falicor, Deysh, Nisugi
          game: Gemstone
          tags: hunting, bigshot, combat
       version: 5.3.10
      required: Lich >= 5.5.0, infomon >= 1.18.11

  Setup Instructions: https://gswiki.play.net/Script_Bigshot
      Full Changelog: https://gswiki.play.net/Script_Bigshot/Changelog
     Help Contribute: https://github.com/elanthia-online/scripts

  Version Control:
    Major_change.feature_addition.bugfix
  v5.3.10 (2024-06-15)
    - added support for Seanette's Shout in Society/Abilities/Spells/Cmans section of the hunting tab
  v5.3.9 (2024-05-29)
    - add additional missing cmd_assault regex matching
  v5.3.8 (2024-05-18)
    - remove superfluous check for escorts, not needed since they are not valid targets
  v5.3.7 (2024-05-01)
    - fix for Char.prof/Char.level to Stats.prof/Stats.level
  v5.3.6 (2024-04-28)
    - add additional custom disk noun
  v5.3.5 (2024-04-24)
    - handle all the new custom disk nouns
  v5.3.4 (2024-03-29)
    - fix to add Tangle Weed (610) status of "entangled" to the PRONE regex
    - fix for kweed command to use EVOKE instead of stancing
  v5.3.3 (2024-03-15)
    - fix for cmd_briar to use MEASURE instead of LOOK due to gamefeed issue with extended show descriptions
    - fix for cmd_briar to support UCS worn gear and two weapon combat
  v5.3.2 (2024-03-12)
    - bugfix in check_required_values
  v5.3.1 (2024-03-11)
    - bugfix for UIDs in boundary rooms and new boundary return outside of hunting area feature
    - added cmd_curse command for Sorcerer spell Curse 715
    - added cmd_store command to store left, right or both, but only if something is in those hands
  v5.3.0 (2023-11-29)
    - added boundary return if character ends up outside hunting area
    - added option to double cast on fog options when returning from the Rift
    - added support for warcry holler buff
    - fixed bug in stand method when command is an array
    - fixed command to standardize to downcase
    - fixed bug in head/tail looting where the leader wasn't waiting for the follower to loot
    - removed $bigshot_briar in favor of Spell[9105]
    - added toggle to check for favor before using voln symbol on hunting tab
    - expanded need_to_loot method for 1108 kills
    - added escape for temporal rift
    - added eachtarget command that attacks each creature in the room eg. (eachtarget force incant 917 until 101 (once), incant 903 (x10))
    - removed change log comments before 5.0.0 and updated wiki
  v5.2.2 (2023-11-21)
    - bugfix causing bs_wander to delay 0.5 seconds longer than needed
    - added Roa'ter and Ooze escape check in bs_wander
  v5.2.1 (2023-11-15)
    - add new efury, caststop, and wield cmd
    - redo unravel/barddispel cmd
  v5.2.0 (2023-10-02)
    - general adjustment to group hunting
    - additions to group looting for exclude individuals as well as allowing for changing looter based on encumbrance
    - changes to try and prevent leaving stray bandits
    - update to prevent targeting 709 arms
    - allows multiple rally rooms just separate with commas
    - added multiple return room waypoints
    - added support for ranger tracking. Usage ;bigshot <options> <creature> example: ;bigshot single giant rat
  v5.1.10 (2023-09-28)
    - bugfix for ;bigshot quick occassionally stopping when another character enters the room
    - changed BIGSHOT_VERSION variable to pull version from title block
    - bugfix for display output
  v5.1.9 (2023-09-24)
    - fix to debug variable being hard set at launch to false.
    - add CLI debug option to toggle debug value between true/false.
  v5.1.8 (2023-09-18)
    - add acid & steam to incant 518 allowances in cmd_spell
  v5.1.7 (2023-09-16)
    - bugfix wracking not considering active COL signs
    - added RT check for wand method
  v5.1.6 (2023-09-12)
    - bugfix for cmd_force when target has 115
  v5.1.5 (2023-08-30)
    - bugfix for calling escape_rooms for tail
  v5.1.4 (2023-08-30)
    - bugfix for Roa'ter and Ooze escape for head/tail
  v5.1.3 (2023-08-26)
    - add 335/Divine Wrath cooldown check in cmd_spell to not cast
    - change cmd_spell to use Spell.force_incant for incanted spells instead of bs_put
  v5.1.2 (2023-08-21)
    - fix incorrect regex match for mighty blow
  v5.1.1 (2023-08-14)
    - fix missing regex match for censer command check
  v5.1.0 (2023-08-07)
    - add ooze_escape for getting out of Ooze, Innards in HW.
  v5.0.0 (2023-07-19)
    - move method spell_is_selfcast? inside Bigshot class
    - corrected deadmans typo
    - moved Setup class outside main Bigshot block
    - renamed various methods to snake case
    - removed changlog notes older than 4.17.0 and updated changelog on wiki
    - bugfix for bearhug complete_regex and in the command check
    - retry RT commands for warrior and rogue guild cmans
    - added rooted to status check
    - bugfix in check_target_vitals
    - bugfix in cast_signs undefined method `=~' for false:FalseClass
=end
=begin
    To do:
      Add more messaging for ambush checks (snipe, etc.)
      Add Stun Relief (108)|Undisease (113)|Unpoison (114) option for stunned group members
      Add Hand of Tonis to dismiss clouds
      Group logic for familiars/companions
      UCS will frequently use the last '$bigshot_unarmed_followup_attack', needs to be cleared
      Need support for tracking multiple NPC positioning tiers for UCS
      Celerity (506) support from grouped wizards for MStrikes
=end

# Compatability for Older Ruby Versions
if $SAFE > 0
  echo "error: This script needs to be trusted to work. (;trust #{script.name})"
  exit
end

infomon_gem_requires = '1.18.11'
lich_gem_requires = '5.5.0'
requirement_failed = false

# Check version in file if constant not defined or if the version is less than required
if !defined?(Infomon) && (!defined?(INFOMON_VERSION) or (Gem::Version.new(INFOMON_VERSION) < Gem::Version.new(infomon_gem_requires)))
  INFOMON_VERSION = '0.0.0'
  infomon_data = File.open(File.join(SCRIPT_DIR, "infomon.lic"), 'r').read
  if infomon_data =~ /^=begin\r?\n?(.+?)^=end/m
    comments = $1.split("\n")
  else
    comments = []
    infomon_data.split("\n").each { |line|
      if line =~ /^[\t\s]*#/
        comments.push(line)
      elsif line !~ /^[\t\s]*$/
        break
      end
    }
  end
  for line in comments
    if line =~ /^[\s\t#]*version:[\s\t]*([\w,\s\.\d]+)/i
      INFOMON_VERSION = $1.sub(/\s\(.*?\)/, '').strip
    end
  end
end

# Check version of infomon for compatibility
if !defined?(Infomon) && Gem::Version.new(INFOMON_VERSION) < Gem::Version.new(infomon_gem_requires)
  requirement_failed = true
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script: #{script.name} now requires a newer version of infomon (#{infomon_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running infomon Version: #{Gem::Version.new(INFOMON_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script: #{script.name} now requires a newer version of infomon (#{infomon_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently running infomon Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond "##" + "########################################"
  end
end

# Check version of Lich for compatibility
if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires)
  requirement_failed = true
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script: #{script.name} now requires a newer version of Lich (#{lich_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script: #{script.name} now requires a newer version of Lich (#{lich_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
    _respond "##" + "########################################"
  end
end

exit if requirement_failed
# end version checks

if UserVars

  # Create UserVars.op on first run
  if UserVars.op.nil?
    UserVars.op = Hash.new
  end

  # First time running a version with monitor strings that can be specified, set up default values
  if UserVars.op["monitor_strings"].nil? || UserVars.op["monitor_strings"].empty?
    UserVars.op["monitor_strings"] = "SEND||POLICY||[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]||speaking to you||unresponsive||taps you||nods to you||lease respond||not in control||violation||lease speak||peak out loud||Y U SHOU D||whispers,||speaking to you||smiles at you||waves to you||grins at you||hugs you||takes hold your hand||grabs your hand||clasps your hand||trying to drag you"
  end

  if UserVars.op["monitor_safe_strings"].nil? || UserVars.op["monitor_safe_strings"].empty?
    UserVars.op["monitor_safe_strings"] = "\[(?!Private)\w*\]-GS(?:T|IV):||We've noted a troubling increase in bandit activity recently||inviting you to join||Dreavening"
  end

  UserVars.save
end

def get_script_version
  data = Script.list.find { |x| x.name == Script.current.name }.inspect
  return data[/version: (\d+\.\d+\.\d+)/i, 1]
end

# All Requirements
require 'yaml'
require 'drb'
require 'fileutils'

# Make sure the directories exist for loading and saving profiles
FileUtils.mkdir_p(File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles"))

# Global Variables
BIGSHOT_VERSION = get_script_version
RALLY_TIME = 1
REST_INTERVAL = 60
$bigshot_1614_list = []
$bigshot_703_list = []
$bigshot_adrenal_surge = Time.now + 301
$bigshot_aim = 0
$bigshot_ambush = 0
$bigshot_arcane_reflex = false
$bigshot_archery_aim = 0
$bigshot_archery_stuck_location = []
$bigshot_archery_location = nil
$bigshot_dislodge_target = nil
$bigshot_dislodge_location = []
$bigshot_bandits = false
$bigshot_bless = []
$bigshot_bond_return = false
$bigshot_debug ||= false
$bigshot_flee = false
$bigshot_group_status = {}
$bigshot_lte_boost_counter = 0
$bigshot_overkill_counter = 0
$bigshot_quick = false
$bigshot_reaction = nil
$bigshot_should_rest = false
$bigshot_smite_list = []
$bigshot_status = nil
$bigshot_swift_justice = 0
$bigshot_unarmed_followup = false
$bigshot_unarmed_followup_attack = ""
$bigshot_unarmed_tier = 1
$bigshot_wand = 0
$companion ||= nil
$current_script_name = script.name
$current_room_npcs = GameObj.npcs
$familiar = ""
$grouplist = []
$last_loot = nil
$looting_inactive = true
$not_hunting_reason = nil
$rest_reason = nil
$room_npcs_last_check = []
$mstrike_taken = false
$bigshot_single = false
$bigshot_room_claimed = []
$bigshot_sneaky_hunt = false

# Event class for grouping
class Bigshot
  class Event
    attr_accessor :type, :created_at, :room_id, :cmd_input

    @@RECOGNIZED = [:HUNTING_PREP_COMMANDS, :HUNTING_SCRIPTS_START, :CAST_SIGNS, :ATTACK, :PREP_REST,
                    :HUNTING_SCRIPTS_STOP, :RESTING_SCRIPTS_START, :RESTING_PREP_COMMANDS, :DISPLAY_WATCH, :START_WATCH, :STOP_WATCH, :SINGLE_STOP,
                    :FOLLOWER_OVERKILL, :STAY_QUIET, :FOLLOW_NOW, :LOOT, :CUSTOM_PUT, :CUSTOM_CMD, :CUSTOM_DO_CLIENT,
                    :PUBLIC_SEND, :GO2_WAYPOINTS, :GO2_RESTING_ROOM, :GO2_RALLY_ROOM, :GO2_HUNTING_ROOM, :CHECK_MIND, :JOIN_LEADER, :FOG_RETURN, :CHECK_SNEAKY,
                    :LEAVE_GROUP, :FINAL_LOOT]

    def initialize(type, time_stamp, room_id, c_in = nil)
      raise "Event type not recognized" unless @@RECOGNIZED.include?(type)

      @type       = type
      @created_at = time_stamp
      @room_id    = room_id
      @cmd_input  = c_in
    end

    def stale?
      if (Room.current.id != @room_id || Time.now.to_i - @created_at > 15)
        return true
      else
        return false
      end
    end
  end
end

# Check inside boundary class
class Bigshot
  class BSAreaRooms
    attr_accessor :start_room, :boundaries, :area_rooms

    def initialize(hunting_room_id, hunting_boundaries)
      self.start_room = hunting_room_id
      self.boundaries = hunting_boundaries
      self.area_rooms = Set[self.start_room]
    end

    def get_valid_neighbors(room_id)
      room_obj = Room[room_id]
      neighbors = room_obj.wayto.keys - self.boundaries
      return neighbors.to_set
    end

    def build
      i = 0
      previous = nil
      until previous == self.area_rooms || i >= 200
        i += 1
        previous = self.area_rooms.dup
        previous.each { |r|
          neighbors = get_valid_neighbors(r)
          self.area_rooms.merge(neighbors)
        }
      end
    end

    def valid?(room_id = Room.current.id)
      return self.area_rooms.any?(room_id.to_s)
    end
  end
end

# Group class for head/tail
class Bigshot
  class Group
    include DRbUndumped
    attr_accessor :leader, :members

    def initialize()
      @members = Hash.new
    end

    def set_leader(leader)
      @leader = leader
    end

    def leader_name
      @leader.name
    end

    def add_member(member)
      @members[member.name()] = member
    end

    def size()
      return @members.size + 1
    end

    def group_size()
      return @members.size
    end

    def get_names
      return @members.keys + [@leader.name]
    end

    def room_id()
      return @leader.room_id()
    end

    def first_member
      @members[@leader.ma_looter].add_event(:LOOT, Time.now.to_i, Room.current.id)
    end

    def looting_done
      @members.each_pair { |k, v|
        begin
          return false if !v.looting_inactive?
        rescue
          @leader.message("yellow", "Error polling member(need_sneaky?). Removing #{k}!")
          @members.delete(k)
        end
      }

      return true
    end

    def set_group_looting_active
      @members[@leader.ma_looter].set_looting_active
    end

    def looter
      return @leader.DESIGNATED_LOOTER
    end

    def looter_present?
      return true if checkpcs.include?(@leader.ma_looter)

      if !checkpcs.include?(@leader.ma_looter)
        @members.delete(@leader.ma_looter)
        return false
      end
    end

    def obv_hide_set(player_present)
      @members.each_pair { |k, v|
        begin
          v.set_obvious_hiding_player(player_present)
        rescue
          @leader.message("yellow", "Error polling member(obv_hide_set). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def add_event(type, room = Room.current.id)
      @members.each_pair do |_k, v|
        begin
          v.add_event(type, Time.now.to_i, room)
        rescue
          @leader.message("yellow", "Error adding #{type} event to members stack(add_event): #{$!}")
          @leader.message("yellow", $!.backtrace.join("\n"))
        end
      end
    end

    def has_bounty?(bounty_regex)
      if !bounty_regex.is_a? Regexp
        @leader.message("yellow", "That's not a Regexp.  Killing Bigshot")
        client_do(";k bigshot")
      end
      @members.each_pair do |k, v|
        begin
          return true if v.cur_bounty =~ bounty_regex
        rescue
          @leader.message("yellow", "Error polling member(has_bounty?). Removing #{k}!")
          @members.delete(k)
        end
      end
      return false
    end

    def group_assist(should_attack)
      @members.each_pair { |k, v|
        begin
          v.set_help_group(should_attack)
        rescue
          @leader.message("yellow", "Error polling member(group_assist). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def add_leader_event(event)
      @leader.add_event(Event.new(event)) unless @leader.event_stack.size > 5
    end

    def return_waypoints_ids()
      return @leader.RETURN_WAYPOINT_IDS
    end

    def resting_id()
      return @leader.RESTING_ROOM_ID
    end

    def hunting_id()
      return @leader.HUNTING_ROOM_ID
    end

    def rally_ids()
      return @leader.RALLYPOINT_ROOM_IDS
    end

    def roundtime?()
      @members.each_pair { |k, v|
        begin
          return true if v.rt? > 0
        rescue
          @leader.message("yellow", "Error polling member(roundtime?). Removing #{k}!")
          @members.delete(k)
        end
      }
      return false
    end

    # Use this to perform combat actions
    def do_command(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:CUSTOM_CMD, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("yellow", "Error polling member(do_command). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    # Use this to perform non-combat actions
    def do_put(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:CUSTOM_PUT, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("yellow", "Error polling member(do_put). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    # Use this to perform perform actions as if they were typed through the client
    def client_do(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:CUSTOM_DO_CLIENT, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("yellow", "Error polling member(client_do). Removing! #{k}")
          @members.delete(k)
        end
      }
    end

    # Use this to perform perform actions as if they were typed through the client
    def pub_send(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:PUBLIC_SEND, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("yellow", "Error polling member. Removing!")
          @members.delete(k)
        end
      }
    end

    def clear_group_events()
      @members.each_pair { |k, v|
        begin
          v.clear_events()
        rescue
          @leader.message("yellow", "Error polling member(clear_group_events). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def group_should_hunt?()
      emergency = @leader.event_stack.size == 0 ? nil : @leader.event_stack.shift
      if (emergency)
        @leader.clear_events()
        return false
      end

      $bigshot_group_status = {}
      @members.each_pair { |k, v|
        begin
          reason = v.ready_to_hunt?
          if reason != "ready"
            $bigshot_group_status[k] = reason
          end
        rescue
          @leader.message("yellow", "Error polling member(group_should_hunt?). Removing #{k}!")
          @members.delete(k)
        end
      }
      if $bigshot_group_status.empty?
        $bigshot_status = :hunting
        return true
      else
        return false
      end
    end

    def group_bandit_hunting(kill_bandits)
      @members.each_pair { |k, v|
        begin
          v.set_bandit_hunting(kill_bandits)
        rescue
          @leader.message("yellow", "Error polling member(group_bandit_hunting). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def group_should_rest?()
      $bigshot_group_status = {}

      @members.each_pair { |k, v|
        begin
          reason = v.ready_to_rest?

          if !!reason
            $bigshot_group_status[k] = reason
          end
        rescue
          @leader.message("yellow", "Error polling member(should_rest?). Removing #{k}!")
          @members.delete(k)
        end
      }

      if $bigshot_group_status.empty?
        return false
      else
        return true
      end
    end

    def any_saturated?
      @members.each_pair do |k, v|
        begin
          return true if v.saturated?
        rescue StandardError
          @leader.message("yellow", "Error polling member(any_saturated?). Removing #{k}!")
          @members.delete(k)
        end
      end
      false
    end

    def group_encumbrance
      group_weight = {}
      @members.each_pair do |k, v|
        current, setting = v.encumbrance?
        group_weight[k] = (setting - current)
      end

      return group_weight
    end

    def need_sneaky?
      @members.each_pair { |k, v|
        begin
          return true if v.sneaky_hunt? && !v.player_hidden?
        rescue
          @leader.message("yellow", "Error polling member(need_sneaky?). Removing #{k}!")
          @members.delete(k)
        end
      }

      return false
    end

    def all_present?
      @members.each_pair { |k, _v|
        return false unless checkpcs.include?(k)
      }
      return true
    end

    def emergency_rest?()
      @members.each_pair { |k, v|
        begin
          return true if v.wounded?
        rescue
          @leader.message("yellow", "Error polling member(emergency_rest). Removing #{k}!")
          @members.delete(k)
        end
      }
      return false
    end
  end
end

# Setup class for UI
class Bigshot
  class Setup < Gtk::Builder
    attr_accessor :settings

    @@categories = {
      general: {

        # Profiles
        profile_current: { default: '' },
        profile_name: { default: '' },
        profile_button: { default: '' },
        save_current: { default: '' },
        profile_save: { default: '' },
        save_profile_name: { default: '' },
        profile_overwrite: { default: '' },
        profile_cancel: { default: '' },
        msg_label: { default: '' },
        no_current_profile: { default: '' },

        # Resting
        return_waypoint_ids: { default: '' },
        resting_room_id: { default: '' },
        resting_commands: { default: '' },
        resting_scripts: { default: '' },
        fog_return: { default: '' },
        fog_optional: { default: false },
        fog_rift: { default: false },
        fried: { default: '' },
        overkill: { default: '' },
        lte_boost: { default: '' },
        oom: { default: '' },
        encumbered: { default: '' },
        wounded_eval: { default: '' },
        bounty_eval: { default: '' },
        crushing_dread: { default: '' },
        creeping_dread: { default: '' },
        wot_poison: { default: false },
        confusion: { default: false },

        # Hunting
        hunting_room_id: { default: '' },
        rallypoint_room_ids: { default: '' },
        hunting_boundaries: { default: '' },
        rest_till_exp: { default: '' },
        rest_till_mana: { default: '' },
        rest_till_spirit: { default: '' },
        hunting_stance: { default: '' },
        hunting_prep_commands: { default: '' },
        hunting_scripts: { default: '' },
        signs: { default: '' },
        loot_script: { default: '' },
        wracking_spirit: { default: '' },
        priority: { default: false },
        delay_loot: { default: false },
        troubadours_rally: { default: false },
        sneaky_sneaky: { default: false },
        use_wracking: { default: false },
        loot_stance: { default: false },
        pull: { default: true },
        deader: { default: true },
        check_favor: { default: false },

        # Attacking
        ambush: { default: '' },
        archery_aim: { default: '' },
        flee_count: { default: '' },
        invalid_targets: { default: '' },
        always_flee_from: { default: '' },
        flee_message: { default: '' },
        wander_wait: { default: '' },
        boon_flee_from: { default: false },
        flee_clouds: { default: false },
        flee_vines: { default: false },
        flee_webs: { default: false },
        flee_voids: { default: false },
        lone_targets_only: { default: false },
        weapon_reaction: { default: true },
        bless: { default: false },

        # Commands
        hunting_commands: { default: '' },
        hunting_commands_b: { default: '' },
        hunting_commands_c: { default: '' },
        hunting_commands_d: { default: '' },
        hunting_commands_e: { default: '' },
        hunting_commands_f: { default: '' },
        hunting_commands_g: { default: '' },
        hunting_commands_h: { default: '' },
        hunting_commands_i: { default: '' },
        hunting_commands_j: { default: '' },
        disable_commands: { default: '' },
        quick_commands: { default: '' },
        targets: { default: '' },
        quickhunt_targets: { default: '' },

        # Misc
        tier3: { default: '' },
        aim: { default: '' },
        uac_smite: { default: false },
        uac_mstrike: { default: false },
        mstrike_stamina_cooldown: { default: '' },
        mstrike_stamina_quickstrike: { default: '' },
        mstrike_mob: { default: '' },
        mstrike_cooldown: { default: false },
        mstrike_quickstrike: { default: false },
        ammo_container: { default: '' },
        ammo: { default: '' },
        fresh_wand_container: { default: '' },
        dead_wand_container: { default: '' },
        wand: { default: '' },
        hide_for_ammo: { default: false },
        wand_if_oom: { default: false },
        independent_travel: { default: false },
        independent_return: { default: false },
        ma_looter: { default: '' },
        never_loot: { default: '' },
        random_loot: { default: false },

        # Monitoring
        dead_man_switch: { default: false },
        depart_switch: { default: false },
        quiet_followers: { default: true },
        monitor_interaction: { default: false },
        monitor_strings: { default: '' },
        monitor_safe_strings: { default: '' },

      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?

      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()
      @settings = settings
      @silent_exit = false

      # set default values if they don't exist

      @@categories.each do |_, data|
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end

      # remove settings that doesn't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }
      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        # add_from_file("#{$data_dir}bigshot.ui")
        add_from_string(Setup.ui)
        load_settings
        set_tooltips
        self['main'].keep_above = true
        self['main'].set_title "Big Shot: v#{BIGSHOT_VERSION}"

        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    def self.setup
      settings = UserVars.op.dup

      # convert the strings to symbol
      settings = settings.transform_keys(&:to_sym)

      # echo settings
      Setup.new(settings).start
    end

    def self.ui
      '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkWindow" id="main"><property name="can-focus">False</property><property name="title" translatable="yes">Bigshot Setup</property><property name="default-width">1100</property><property name="default-height">750</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkComboBoxText" id="profile_name"><property name="height-request">42</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">20</property><property name="has-entry">True</property><child internal-child="entry"><object class="GtkEntry"><property name="width-request">400</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="profile_button"><property name="label" translatable="yes">Load Profile</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">30</property><property name="margin-top">19</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">18</property><property name="margin-top">10</property><property name="label" translatable="yes">Current Profile:</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property>
      </packing></child><child><object class="GtkEntry" id="profile_current"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">18</property><property name="margin-bottom">10</property><property name="editable">False</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel" id="msg_label"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-end">10</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="width">2</property><property name="height">3</property></packing></child><child><object class="GtkButton" id="save_current"><property name="label" translatable="yes">Update Profile</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Saves setting changes to the current profile.</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">30</property><property name="margin-bottom">15</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel" id="no_current_profile"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-bottom">10</property><property name="label" translatable="yes">label</property><attributes><attribute name="foreground" value="#a5a51d1d2d2d"/></attributes></object><packing><property name="left-attach">0</property><property name="top-attach">3</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Load Profile</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-bottom">5</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkButton" id="profile_save"><property name="label" translatable="yes">Save Current Settings as...</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">15</property><property name="margin-top">10</property><property name="margin-bottom">5</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="save_profile_name"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-bottom">15</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property>
      </packing></child><child><object class="GtkLabel" id="test_label"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">15</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="label" translatable="yes">label</property><attributes><attribute name="foreground" value="#a5a51d1d2d2d"/></attributes></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkButton" id="profile_overwrite"><property name="label" translatable="yes">Save Profile</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">15</property><property name="margin-end">15</property><property name="margin-top">20</property><property name="margin-bottom">13</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="profile_cancel"><property name="label" translatable="yes">Cancel</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-end">10</property><property name="margin-top">20</property><property name="margin-bottom">13</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Save Profile</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
      </packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Profiles</property></object><packing><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=1 n-rows=13 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=7 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="resting_room_id"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Resting Room ID:</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="resting_commands"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Pre-rest Commands:</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="resting_scripts"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property><property name="width">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">41</property><property name="label" translatable="yes">Active Resting Scripts:</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property>
      </packing></child><child><object class="GtkComboBoxText" id="fog_return"><property name="width-request">200</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="active">0</property><property name="has-entry">True</property><items><item id="0" translatable="yes">None</item><item id="1" translatable="yes">Spirit Guide (130)</item><item id="2" translatable="yes">Voln Symbol of Return</item><item id="3" translatable="yes">Travelers Song (1020)</item><item id="4" translatable="yes">GoS Sigil of Escape</item><item id="5" translatable="yes">Familiar Gate (930)</item>
      </items><child internal-child="entry"><object class="GtkEntry"><property name="can-focus">False</property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Fog Options</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property>
      </packing></child><child><object class="GtkCheckButton" id="fog_optional"><property name="label" translatable="yes"> Fog ONLY if wounded or encumbered</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">5</property></packing></child><child><object class="GtkEntry" id="return_waypoint_ids"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="placeholder-text" translatable="yes">(optional list of rooms)</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Return Waypoint IDs:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="fog_rift"><property name="label" translatable="yes"> Fog twice if returning from the rift</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">6</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Where to Rest</property>
      </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="height">6</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=6 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="fried"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">percentmind &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="overkill"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">extra kills &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="lte_boost"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">used lte boosts &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="oom"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">percentmana &lt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="encumbered"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">percent encumbrance &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkEntry" id="wounded_eval"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">5</property><property name="width">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">wounded eval:</property></object><packing><property name="left-attach">0</property><property name="top-attach">5</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">50</property><property name="margin-top">10</property><property name="label" translatable="yes">creeping dread &gt;=</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="creeping_dread"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">crushing dread &gt;=</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="crushing_dread"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="wot_poison"><property name="label" translatable="yes">Wall of Thorns Poison</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="confusion"><property name="label" translatable="yes">Confusion Debuff</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Should Rest?</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">6</property><property name="height">7</property>
      </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object><packing><property name="position">1</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Resting</property>
      </object><packing><property name="position">1</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=4 n-rows=13 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="hunting_stance"><property name="width-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Attack Stance:</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="hunting_prep_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="hunting_scripts"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="signs"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="placeholder-text" translatable="yes">Mouse over for more info.</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="loot_script"><property name="width-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">4</property></packing></child><child><object class="GtkEntry" id="wracking_spirit"><property name="width-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">5</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Pre-hunt Commands:</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Active Hunting Scripts:</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">30</property><property name="label" translatable="yes">Society Abilities/Spells/Cmans:</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing>
      </child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Loot Script:</property><property name="single-line-mode">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Wracking Spirit &gt;=</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">5</property></packing></child><child><object class="GtkCheckButton" id="priority"><property name="label" translatable="yes">Priority Hunt</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">6</property></packing></child><child><object class="GtkCheckButton" id="delay_loot"><property name="label" translatable="yes">Delay Looting</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="troubadours_rally"><property name="label" translatable="yes">Troubadour\'s Rally</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">9</property></packing></child><child><object class="GtkCheckButton" id="sneaky_sneaky"><property name="label" translatable="yes">Sneaky Sneaky</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="use_wracking"><property name="label" translatable="yes">Use sign of wracking/sigil of power/symbol of mana</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">6</property></packing></child><child><object class="GtkCheckButton" id="loot_stance"><property name="label" translatable="yes">Defensive stance before looting</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="pull"><property name="label" translatable="yes">Pull players to feet</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="deader"><property name="label" translatable="yes">Stop for dead players</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="valign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">9</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="hunting_room_id"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="rallypoint_room_ids"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="hunting_boundaries"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Starting Room ID:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Rallypoint Room IDs:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">35</property><property name="label" translatable="yes">Boundary Room IDs:</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-end">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Bigshot will not enter boundary rooms.
      The goal is to pin yourself into a hunting area.</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Hunting Map</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property><property name="height">5</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="rest_till_exp"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">30</property><property name="margin-top">10</property><property name="label" translatable="yes">when percentmind &lt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="rest_till_mana"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">and percentmana &gt;=</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="rest_till_spirit"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">and checkspirit &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Should Hunt?</property>
      </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">6</property><property name="width">2</property><property name="height">4</property></packing></child><child><object class="GtkCheckButton" id="check_favor"><property name="label" translatable="yes">Check favor before casting symbols</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">10</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object>
      </child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object><packing><property name="position">2</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Hunting</property>
      </object><packing><property name="position">2</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=15 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="ambush"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="archery_aim"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="flee_count"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Ambush aiming locations (head, etc):</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Archery aiming locations (head, etc):</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Flee if enemy count is &gt;</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">100</property><property name="margin-end">10</property><property name="margin-top">20</property><property name="label" translatable="yes">Note: Use nouns or name for flee info.
                  Mouse over some hunting commands field for more info.</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">12</property><property name="width">2</property></packing></child><child><object class="GtkEntry" id="invalid_targets"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="always_flee_from"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkEntry" id="flee_message"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">5</property></packing></child><child><object class="GtkEntry" id="wander_wait"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">6</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">...but don\'t count these:</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">...and always flee from</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Flee from environmental message:</property></object><packing><property name="left-attach">0</property><property name="top-attach">5</property></packing>
      </child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Wait before wandering to another room</property></object><packing><property name="left-attach">0</property><property name="top-attach">6</property></packing></child><child><object class="GtkCheckButton" id="boon_flee_from"><property name="label" translatable="yes">Flee from Boon/Boss/Glamour creatures</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="lone_targets_only"><property name="label" translatable="yes">Approach Lone Targets Only</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="weapon_reaction"><property name="label" translatable="yes">Activate Weapon Reactions</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will initiate reactive strikes when the opportunity presents itself.</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">9</property></packing></child><child><object class="GtkCheckButton" id="bless"><property name="label" translatable="yes">Bless Weapon?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="flee_clouds"><property name="label" translatable="yes">Flee from Clouds</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="flee_vines"><property name="label" translatable="yes">Flee from Vines</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">9</property></packing></child><child><object class="GtkCheckButton" id="flee_webs"><property name="label" translatable="yes">Flee from Webs</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">10</property></packing></child><child><object class="GtkCheckButton" id="flee_voids"><property name="label" translatable="yes">Flee from Voids</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">11</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/>
      </child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
      </packing></child></object></child></object></child></object><packing><property name="position">3</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Attacking</property></object><packing><property name="position">3</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=4 n-rows=12 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="hunting_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="hunting_commands_b"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="hunting_commands_c"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (a):</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Hunting Commands (b):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (c):</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="hunting_commands_d"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="hunting_commands_e"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkEntry" id="hunting_commands_f"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">5</property></packing></child><child><object class="GtkEntry" id="hunting_commands_g"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">6</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (d):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (e):</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (f):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">5</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (g):</property></object><packing><property name="left-attach">0</property><property name="top-attach">6</property></packing></child><child><object class="GtkEntry" id="hunting_commands_h"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">7</property></packing></child><child><object class="GtkEntry" id="hunting_commands_i"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">8</property></packing></child><child><object class="GtkEntry" id="hunting_commands_j"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">9</property></packing></child><child><object class="GtkEntry" id="disable_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">5</property></packing></child><child><object class="GtkEntry" id="quick_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (h):</property></object><packing><property name="left-attach">0</property><property name="top-attach">7</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (i):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">8</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (j):</property></object><packing><property name="left-attach">0</property><property name="top-attach">9</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Fried Commands:</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">5</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Quick Commands:</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="targets"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Valid Targets:</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="quickhunt_targets"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Quickhunt Targets:</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">3</property><property name="top-attach">4</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/>
      </child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object><packing><property name="position">4</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Commands</property></object><packing><property name="position">4</property><property name="tab-fill">False</property>
      </packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><!-- n-columns=4 n-rows=11 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">30</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="tier3"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">15</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">30</property><property name="label" translatable="yes">Tier 3 Attack:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="aim"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">11</property><property name="label" translatable="yes">Aim at location (head, etc):</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing>
      </child><child><object class="GtkCheckButton" id="uac_smite"><property name="label" translatable="yes">Use Voln SMITE?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">15</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkCheckButton" id="uac_mstrike"><property name="label" translatable="yes">Do Not Mstrike.</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">UAC</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property><property name="height">4</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">15</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="mstrike_stamina_cooldown"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">15</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">15</property><property name="label" translatable="yes">MStrike during cooldown stamina requirement:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="mstrike_stamina_quickstrike"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">QuickStrike stamina requirement:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="mstrike_mob"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Unfocused MStrike when Creatures &gt;=</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="mstrike_cooldown"><property name="label" translatable="yes">MStrike during cooldown</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">end</property><property name="margin-end">15</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="mstrike_quickstrike"><property name="label" translatable="yes">Use QuickStrike for MStrike</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">MStrike</property></object></child></object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="width">2</property><property name="height">4</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">30</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=7 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="ammo_container"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Find ammo in this container:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="ammo"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Use this ammo type:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="fresh_wand_container"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Fresh wand container</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="dead_wand_container"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Dead wand container</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="wand"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Use this wand type</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkCheckButton" id="hide_for_ammo"><property name="label" translatable="yes">Hide to pick up ammo</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">15</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">5</property></packing></child><child><object class="GtkCheckButton" id="wand_if_oom"><property name="label" translatable="yes">Use wands when out of mana</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">6</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Ammo/Wands</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">4</property><property name="width">2</property><property name="height">7</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">15</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=6 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="ma_looter"><property name="width-request">342</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="placeholder-text" translatable="yes">optional: Defaults to group leader</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="label" translatable="yes">List of Characters that should never loot</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property><property name="width">2</property>
      </packing></child><child><object class="GtkEntry" id="never_loot"><property name="width-request">280</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">4</property><property name="placeholder-text" translatable="yes">Character names separated by commas: Character1, Character2...</property></object><packing><property name="left-attach">0</property><property name="top-attach">5</property><property name="width">2</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Primary Looter</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="random_loot"><property name="label" translatable="yes">Loot randomly based on lowest encumbrance</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="independent_travel"><property name="label" translatable="yes">Travel TO hunting grounds independently</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="independent_return"><property name="label" translatable="yes">Travel FROM hunting grounds independently</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">MA Grouping</property></object></child></object><packing><property name="left-attach">2</property><property name="top-attach">4</property><property name="width">2</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing>
      </child></object></child></object></child></object><packing><property name="position">5</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object><packing><property name="position">5</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=1 n-rows=6 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">20</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="monitor_interaction"><property name="label" translatable="yes">Monitor Interactions</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkFrame"><property name="width-request">600</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">50</property><property name="label-xalign">0</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><child><object class="GtkTextView" id="monitor_strings"><property name="visible">True</property><property name="can-focus">True</property><property name="wrap-mode">word</property>
      </object></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Watch for strings (or regexes) that contain</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkFrame"><property name="width-request">600</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">50</property><property name="label-xalign">0</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><child><object class="GtkTextView" id="monitor_safe_strings"><property name="visible">True</property><property name="can-focus">True</property><property name="wrap-mode">word</property>
      </object></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">....except if they also contain</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">5</property></packing></child><child><object class="GtkCheckButton" id="dead_man_switch"><property name="label" translatable="yes">Engage dead man\'s switch (Shattered Only)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="depart_switch"><property name="label" translatable="yes">Depart/rerun if dead</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="quiet_followers"><property name="label" translatable="yes">Quiet Followers</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object><packing><property name="position">6</property>
      </packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Monitoring</property></object><packing><property name="position">6</property><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">20</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes">To save properly, exit with the close button and not the X window. --&gt;</property><attributes><attribute name="style" value="italic"/>
      </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
      </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      self['no_current_profile'].hide
      self['test_label'].hide
      self['profile_save'].show
      self['save_profile_name'].show

      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::RadioButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::Button
          if obj.builder_name.to_s == "save_current"
            save_profile_changes
          end

          if obj.builder_name.to_s == "profile_button"
            on_profile_load
          end

          if obj.builder_name.to_s == "profile_save"
            save_profile
          end

          if obj.builder_name.to_s == "profile_overwrite"
            self['profile_overwrite'].hide
            self['profile_cancel'].hide
            File.write(@filename, @settings.to_yaml)
            self['test_label'].text = "The profile has been saved to \n#{@filename}"
            self['profile_current'].text = self['save_profile_name'].text
            self['save_profile_name'].text = ''
            self['test_label'].text = "The profile has been saved to #{@filename}"
            self['save_profile_name'].hide
            self['profile_save'].hide
            self['test_label'].show
          end

          if obj.builder_name.to_s == "profile_cancel"
            self['profile_overwrite'].hide
            self['profile_cancel'].hide
            self['test_label'].text = "The profile save has been canceled"
            self['save_profile_name'].text = ''
            self['profile_save'].show
          end

        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        #  echo "@settings[key]: #{@settings[key]} key: #{key} obj.text.strip: #{obj.text.strip}"
        elsif obj.class == Gtk::TextView
          @settings[key] = obj.buffer.text
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update
          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        elsif obj.class == Gtk::ComboBoxText
          if obj.builder_name.to_s == "fog_return"
            @settings[key] = obj.active_id
          else
            @settings[key] = obj.active_text
          end
        end
      end
    end

    def on_profile_load
      if @settings[:profile_name].empty?
        return
      end

      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")

      filename = @settings[:profile_name] + ".yaml"
      profile = File.join(dir, filename)
      from_file = YAML.load_file(profile)
      @settings = from_file.transform_keys(&:to_sym)
      self['profile_current'].text = self['profile_name'].active_text
      self['profile_name'].set_active(0)

      load_settings(false)
    end

    def on_drop_load
      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")

      self['profile_name'].remove_all
      self['profile_name'].append_text('')
      names = []
      Dir.foreach(dir) { |f| names.push(f) }
      names.each { |filename|
        next if filename == '.' || filename == '..'

        self['profile_name'].append_text("#{filename.sub(".yaml", "")}")
      }
    end

    def set_tooltips
      # Profile Tab

      # Message on Profile tab
      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
      msg = "This drop down shows profiles available at the new save location.\nThe location was changed to enable settings organized by character.\n\n"
      msg += "The new bigshot default profile location...\n#{dir}\n\n"
      msg += "The original location is here...\n#{File.join($script_dir, 'bigshot_profiles')}"
      self['msg_label'].text = msg
      # Profile dropdown
      self['profile_name'].tooltip_text = ''
      # Load Profile Button
      self['profile_button'].tooltip_text = ''
      # Current Profile Textbox
      self['profile_current'].tooltip_text = ''
      # Save Changes Button
      self['save_current'].tooltip_text = ''
      # Save Current Settings
      self['profile_save'].tooltip_text = ''
      # Save Current Textbox
      self['save_profile_name'].tooltip_text = ''
      # Save Profile Button
      self['profile_overwrite'].tooltip_text = ''
      # Cancel Button
      self['profile_cancel'].tooltip_text = ''

      # Resting Tab

      # Resting Room ID
      self['return_waypoint_ids'].tooltip_text = ''
      self['resting_room_id'].tooltip_text = "Supports traditional room numbers as well as uid's (ex u7000)"
      # Pre-rest Commands
      self['resting_commands'].tooltip_text = ''
      # Active Resting Scripts
      self['resting_scripts'].tooltip_text = ''
      # Fog Options
      fog_tooltip  = "None: Dont use any fog options when you return from a hunt\n\nSpirit Guide(130): Use 130 first, then if that fails Symbol of Return\n\n"
      fog_tooltip += "Voln Symbol of Return: Use Symbol of Return first, then if that fails 130\n\n"
      fog_tooltip += "Traveler's Song(1020): Use 1020 only\n\n"
      fog_tooltip += "GoS Sigil of Escape: Use Sigil of Escape\n\nFamiliar Gate(930): Summon familiar gate and go thru portal"
      self['fog_return'].tooltip_text = fog_tooltip
      # Fog Checkbox
      self['fog_optional'].tooltip_text = ''
      # Fog from Rift
      self['fog_rift'].tooltip_text = 'Only works for symbol of return and spell 130'
      # when percentmind
      self['fried'].tooltip_text = "Percentage of your mind (0-100) after which you will stop hunting.\n   101  will hunt until mana/encumbrance/wounded\n   100  is fully fried"
      # and extra kills
      self['overkill'].tooltip_text = "This is the number of additional monsters to kill after reaching your fried threshold.\nLeave blank to not kill any extra monsters"
      # and used lte boosts
      self['lte_boost'].tooltip_text = ''
      # or percent mana
      self['oom'].tooltip_text = ''
      # or percentencumbrance
      self['encumbered'].tooltip_text = ''
      # or wound eval
      self['wounded_eval'].tooltip_text = ''

      # Hunting Tab

      # Starting Room ID
      self['hunting_room_id'].tooltip_text = "Supports traditional room numbers as well as uid's (ex u7000)"
      # Rally Point ID
      rally_tooltip = "Supports an array of numbers - ex. 228, 227, 225 \n"
      rally_tooltip += "If left blank, will set to starting room ID.\n"
      rally_tooltip += "Set to a safe room BEFORE your hunting start point that you want to stop to cast your active hunting spells/signs/sigils/signs and start your active hunting scripts.\n\n"
      rally_tooltip += "If in a group, and this is the head, then will wait here for all tails before casting your active hunting spells/signs/sigils/signs and start your active hunting scripts.\n\n"
      rally_tooltip += "Use Case Example 1: You are hunting somewhere far away and dont want to cast Wall of Force before walking for half the duration.\n\n"
      rally_tooltip += "Use Case Example 2: You want to stop before your climb to start your sigils because there is a climb ahead."
      rally_tooltip += "Supports traditional room numbers as well as uid's (ex u7000)"
      self['rallypoint_room_ids'].tooltip_text = rally_tooltip
      # Boundary Rooms
      self['hunting_boundaries'].tooltip_text = "Supports traditional room numbers as well as uid's (ex u7000)"
      # when percentmind
      self['rest_till_exp'].tooltip_text = "Accurately calculates percentmind now."
      # and percentmana
      self['rest_till_mana'].tooltip_text = ''
      # and checkspirit
      self['rest_till_spirit'].tooltip_text = ''
      # Attack Stance
      self['hunting_stance'].tooltip_text = ''
      # Pre-hunt Commands
      self['hunting_prep_commands'].tooltip_text = ''
      # Active Hunting Scripts
      self['hunting_scripts'].tooltip_text = ''
      # Society Abilities/Spells/Cmans
      signs_tooltip  = "Shadow Mastery - 9603\nSurge of Strength - 9605\n\nSigil of Contact - 9703\nSigil of Resolve - 9704\nSigil of Minor Bane - 9705\nSigil of Defense - 9707\nSigil of Offense - 9708\n"
      signs_tooltip += "Sigil of Minor Protection - 9710\nSigil of Focus - 9711\nSigil of Mending - 9713\nSigil of Concentration - 9714\nSigil of Major Bane - 9715\nSigil of Major Determination - 9716\nSigil of Major Protection - 9719\n\n"
      signs_tooltip += "Sign of Warding - 9903\nSign of Striking - 9904\nSign of Thought - 9906\nSign of Defending - 9907\nSign of Smiting - 9908\nSign of Staunching - 9909\nSign of Deflection - 9910\n"
      signs_tooltip += "Sign of Swords - 9912\nSign of Shields - 9913\nSign of Dissipation - 9914\nSign of Madness - 9916\n\n"
      signs_tooltip += "Symbol of Courage - 9805\nSymbol of Protection - 9806\nSymbol of Supremacy - 9816\n\nBarkskin - 605\nFasthr's Reward - 115\n\nSeanette's Shout - 122420\n\n"
      self['signs'].tooltip_text = signs_tooltip
      # Loot Script
      self['loot_script'].tooltip_text = ''
      # Wracking Spirit
      self['wracking_spirit'].tooltip_text = ''
      # Priority Hunt
      self['priority'].tooltip_text = "Priority is based on order of valid targets box on hunting tab.\nWill switch to highest priority in room when attacking."
      # SNEAKY_SNEAKY
      self['sneaky_sneaky'].tooltip_text = "Sneak around while hunting."
      # Delay Looting
      self['delay_loot'].tooltip_text = ''
      # Troubadour's Rally
      self['troubadours_rally'].tooltip_text = "Shout 1040 when you or your group members are incapacitated."
      # Use Sign of Wracking/Sigil of Power/Symbol of Mana
      self['use_wracking'].tooltip_text = ''
      # Def Stance before Looting
      self['loot_stance'].tooltip_text = ''
      # Pull Players to Feet
      self['pull'].tooltip_text = ''
      # Stop for Deaders
      self['deader'].tooltip_text = ''

      # Attack Tab

      # Ambush aiming location
      self['ambush'].tooltip_text = ''
      # Archery aiming location
      self['archery_aim'].tooltip_text = ''
      # Flee enemy count
      self['flee_count'].tooltip_text = ''
      # but don't coint these
      self['invalid_targets'].tooltip_text = ''
      # Always flee from
      self['always_flee_from'].tooltip_text = ''
      # Flee from environmental msg
      flee_msg  = "Input any text that when the game sends you want to move out of the room...\n"
      flee_msg += 'like a Roa\'ter burrow attack \\"You feel a rumble come from beneath your feet."\\'
      flee_msg += "\nSeperate different messages with a | in between them.\nText compares to XML feed, not plain text."
      self['flee_message'].tooltip_text = flee_msg
      # Wait before wandering
      self['wander_wait'].tooltip_text = ''
      # Flee from boon/boss/glamour creatures
      self['boon_flee_from'].tooltip_text = ''
      # Flee from clouds
      self['flee_clouds'].tooltip_text = ''
      # Flee from vines
      self['flee_vines'].tooltip_text = ''
      # Flee from webs
      self['flee_webs'].tooltip_text = ''
      # Flee from voids
      self['flee_voids'].tooltip_text = ''
      # Approach lone targets only
      self['lone_targets_only'].tooltip_text = ''
      # Activate weapon reactions
      self['weapon_reaction'].tooltip_text = "Will initiate reactive strikes when the opportunity presents itself."
      # Bless Weapons
      self['bless'].tooltip_text = "If checked, will stop hunt when item's blesses run out.\nIf unchecked, will continue to hunt and remind to get blesses while resting."

      # Commands Tab

      # hunting_commands(a)
      hunting_tooltip  = "Example 1: 413 target, 903 target\nExample 2: 903 target(x2)\nExample 3: 903 target(xx)\nExample 4: 910 target(m50), 903 target\nExample 5: unarmed punch, wait 30\n\n"
      hunting_tooltip += "Example 1 will cast 413 then 903 on the target.\nExample 2 will cast 903 on the target twice.\nExample 3 will cast 903 on the target until the fight is over.\n"
      hunting_tooltip += "Example 4 will cast 910 if mana is at least 50, otherwise it will cast 903.\nExample 5 will start the unarmed routine with punch as the main attack. It will attack once, then wait 30 seconds for another attack to happen before attacking again.\n"
      hunting_tooltip += "Separate all commands with commas.\nMore examples available on the Wiki.\n\nNew feature: 'and'.\nFor example: stance def and 1615 target, kill target(xx)"
      self['hunting_commands'].tooltip_text = hunting_tooltip
      # hunting_commands_b
      self['hunting_commands_b'].tooltip_text = ''
      # hunting_commands_c
      self['hunting_commands_c'].tooltip_text = ''
      # hunting_commands_d
      self['hunting_commands_d'].tooltip_text = ''
      # hunting_commands_e
      self['hunting_commands_e'].tooltip_text = ''
      # hunting_commands_f
      self['hunting_commands_f'].tooltip_text = ''
      # hunting_commands_g
      self['hunting_commands_g'].tooltip_text = ''
      # hunting_commands_h
      self['hunting_commands_h'].tooltip_text = ''
      # hunting_commands_i
      self['hunting_commands_i'].tooltip_text = ''
      # hunting_commands_j
      self['hunting_commands_j'].tooltip_text = ''
      # Fried Hunting Commands
      fried_tooltip  = "If left blank and this character is in a bigshot group, character will continue to use standard hunting commands after mind is fried and overkill limit is reached.\n"
      fried_tooltip += "If row populated, and character is in a bigshot group, these commands will be used instead of standard hunting commands once fried and overkill limit reached.\n"
      fried_tooltip += "See Hunting Commands(a) tooltip for examples on what commands to use."
      self['disable_commands'].tooltip_text = fried_tooltip
      # Quick Hunting Commands
      self['quick_commands'].tooltip_text = ''
      # Valid Targets
      self['targets'].tooltip_text = ''
      # Quickhunt Targets
      self['quickhunt_targets'].tooltip_text = "Leave blank to target all critters."

      # Misc Tab

      # Tier 3 Attack
      self['tier3'].tooltip_text = ''
      # Aim at Location
      self['aim'].tooltip_text = "Leave blank if you don't want to aim at anything\n\nSuggest leaving chest as last thing to aim at so you will always have something to hit."
      # Use Voln Smite
      self['uac_smite'].tooltip_text = "Will SMITE a non-corporeal undead when tier is excellent during UAC Combat."
      # Do Not Mstrike
      self['uac_mstrike'].tooltip_text = "Enable check box to prevent mstrikes during unarmed attacks."
      # MStrike during cooldown
      mstrike_tooltip  = "Set this to the highest you want your stamina to be before you MSTRIKE.\n"
      mstrike_tooltip += "Important if MSTRIKEing during its cooldown or while using QUICKSTRIKE.\nLeave blank to only mstrike on cooldown with max stamina.\n"
      mstrike_tooltip += "Combination of QUICKSTRIKE and MSTRIKE during cooldown may pop muscles.\nIve done best I can to ensure it doesn't happen, but depends on what you set your MSTRIKE stamina to.\n\n"
      mstrike_tooltip += "Works in conjunction with MSTRIKE creature #, so if you meet the requirements for it and not this one you will MSTRIKE and visaversa."
      self['mstrike_stamina_cooldown'].tooltip_text = mstrike_tooltip
      # Quickstrike Stamina Requirements
      self['mstrike_stamina_quickstrike'].tooltip_text = ''
      # Unfocused MStrike when creature
      self['mstrike_mob'].tooltip_text = "How many creatures you want in the room before you perform an unfocused MSTRIKE.\nDefault is 2. Set to 1 to always do an unfocused MSTRIKE."
      # MStrike during cooldown
      self['mstrike_cooldown'].tooltip_text = ''
      # Use Quickstrike for Mstrike
      self['mstrike_quickstrike'].tooltip_text = ''
      # Find ammo in this container
      self['ammo_container'].tooltip_text = ''
      # Use this ammo type
      self['ammo'].tooltip_text = ''
      # Fresh wand container
      self['fresh_wand_container'].tooltip_text = ''
      # Dead wand container
      self['dead_wand_container'].tooltip_text = ''
      # Use this wand type
      self['wand'].tooltip_text = ''
      # Hide to pick up ammo
      self['hide_for_ammo'].tooltip_text = ''
      # Use wands when oom
      self['wand_if_oom'].tooltip_text = ''
      # Group Travelers
      self['independent_travel'].tooltip_text = ''
      self['independent_return'].tooltip_text = ''
      # Character Name of Looter
      self['ma_looter'].tooltip_text = "The lead (head) characters profile will set the looter.\nIf nothing is entered or that character isn't part of the group the lead will resume looting."
      # List of characters that should never loot
      self['never_loot'].tooltip_text = 'List of characters that should never loot'
      # Random looting based on character with the lowest overall encumbrance
      self['random_loot'].tooltip_text = 'Random looting based on the character with the lowest overall encumbrance'

      # Monitoring Tab

      # Engage Deadman switch
      self['dead_man_switch'].tooltip_text = ''
      # Depart/rerun if dead
      self['depart_switch'].tooltip_text = ''
      # Quiet Followers
      self['quiet_followers'].tooltip_text = "Followers will wait until Leader is done with both actions and resting scripts to begin using their own.\n\nUse Case: Prevents you from looking like you have mindless bots following while selling loot."
      # Monitor Interactions
      self['monitor_interaction'].tooltip_text = ''
      # Watch for strings
      self['monitor_strings'].tooltip_text = ''
      # ...excpet if they also contain
      self['monitor_safe_strings'].tooltip_text = ''
    end

    def pre_save
      @settings.delete(:profile_name)
      @settings.delete(:profile_button)
      @settings.delete(:save_current)
      @settings.delete(:profile_save)
      @settings.delete(:profile_overwrite)
      @settings.delete(:profile_cancel)
      @settings.delete(:msg_label)
      @settings.delete(:no_current_profile)

      @settings = @settings.transform_keys(&:to_s)
    end

    def on_close_clicked
      pre_save
      UserVars.op = @settings

      @silent_exit = true
      Lich::Messaging.msg('plain', " Bigshot UI closed, saving any changes")

      self['main'].destroy
    end

    def on_destroy
      Gtk.queue {
        Lich::Messaging.msg('plain', " Bigshot UI closed WITHOUT saving any changes") unless @silent_exit
        # Load settings here
        @running = false
      }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings(connect = true)
      Gtk.queue do
        # echo @settings
        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym

          next if (setting = Setup.get_setting(key)).nil?

          self['save_profile_name'].text = ''
          self['profile_current'].text = @settings["save_profile_name"] unless @settings["save_profile_name"].nil?

          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) } if connect
          elsif obj.class == Gtk::RadioButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) } if connect
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].to_s.strip
            obj.signal_connect('changed') { on_update(obj) } if connect
          elsif obj.class == Gtk::Label
            # if obj.builder_name.to_s == "msg_label"

            # end
          elsif obj.class == Gtk::TextView
            obj.buffer.text = @settings[key].to_s.strip
            obj.signal_connect('focus-out-event') { on_update(obj) } if connect
          elsif obj.class == Gtk::SpinButton
            obj.value = @settings[key]
            obj.adjustment.value = @settings[key]
            obj.signal_connect('changed') { on_update(obj) } if connect
          elsif obj.class == Gtk::Button
            if obj.builder_name.to_s == "profile_button"
              on_drop_load
            end
            obj.signal_connect('clicked') { on_update(obj) } if connect
          elsif obj.class == Gtk::ComboBoxText

            if obj.builder_name.to_s == "fog_return"
              obj.set_active_id(@settings[key].to_s)
            end

            obj.signal_connect('changed') { on_update(obj) } if connect
          elsif obj.class == Gtk::TreeView
            if (store = self["#{key}_store"]).nil?
              respond "** failed to find store for treeview #{key}"
              next
            elsif setting[:load].nil?
              respond "** no :load defined #{key}"
              next
            end

            setting[:load].call(store, @settings[key])

            # setup the signals
            if (add = self["#{key}_add"]).nil?
              respond "** failed to find add for treeview #{key}"
              next
            elsif (delete = self["#{key}_delete"]).nil?
              respond "** failed to find delete for treeview #{key}"
              next
            elsif (entry = self["#{key}_entry"]).nil?
              respond "** failed to find entry for treeview #{key}"
              next
            end

            add.signal_connect('clicked') do
              if setting[:set].nil?
                respond "** no :set defined for #{key}"
                next
              elsif entry.text.empty?
                next
              end
              setting[:set].call(store, entry.text, @settings[key])
              setting[:load].call(store, @settings[key])
            end if connect

            delete.signal_connect('clicked') do
              if setting[:delete].nil?
                respond "** no :delete defined for #{key}"
                next
              elsif (selected = obj.selection.selected).nil?
                next
              end
              setting[:delete].call(store, selected, @settings[key])
              setting[:load].call(store, @settings[key])
            end if connect
          end
        end

        # checkboxes for array storage with id's <setting>:<value>
        # this is primarily used by the loot types
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)
          next unless obj.builder_name =~ /^([^:]+):(.*)$/i
          next unless obj.class == Gtk::CheckButton

          key = Regexp.last_match(1).to_sym
          value = Regexp.last_match(2).to_s
          # echo "key: #{key} value: #{value}"
          next if Setup.get_setting(key).nil?

          # echo @settings[key].include?(value)
          obj.active = @settings[key].include?(value)

          # add in hook
          obj.signal_connect('toggled') do
            @settings[key].delete(value)
            if obj.active?
              @settings[key].push(value)
              @settings[key].uniq!.sort!
            end
          end if connect
        end
      end
    end

    def save_profile
      self['test_label'].hide
      @filename = ''

      if self['save_profile_name'].text.empty?
        self['test_label'].text = "Please enter a name before saving the profile"
        self['test_label'].show
        return
      end

      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
      @filename = File.join(dir, "#{self['save_profile_name'].text}.yaml")
      pre_save

      if File.exist?("#{@filename}")
        self['profile_overwrite'].show
        self['profile_cancel'].show
        self['profile_save'].hide
        self['test_label'].text = "File already exists!\nIf you wish to overwrite, please click the save profile button or cancel --->"
        self['test_label'].show
        return
      end
      File.write(@filename, @settings.to_yaml)
      self['profile_current'].text = self['save_profile_name'].text
      self['save_profile_name'].text = ''

      on_drop_load

      self['profile_save'].hide
      self['save_profile_name'].hide
      self['test_label'].text = "The profile has been saved to #{@filename}"
      self['test_label'].show
    end

    def save_profile_changes
      self['no_current_profile'].hide
      @filename = ''

      if self['profile_current'].text.empty?
        self['no_current_profile'].text = "Please enter a name before saving the profile"
        self['no_current_profile'].show
        return
      end

      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
      @filename = File.join(dir, "#{self['profile_current'].text}.yaml")
      pre_save
      File.write(@filename, @settings.to_yaml)

      self['no_current_profile'].text = "#{self['profile_current'].text} has been saved with current settings."
      self['no_current_profile'].show
    end

    def start
      @running = true
      Gtk.queue {
        self['main'].show_all
        self['test_label'].hide
        self['no_current_profile'].hide
        self['profile_overwrite'].hide
        self['profile_cancel'].hide
      }

      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[general internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def self.update_setting(key, value)
      setting = Setup.get_setting(key)
      echo "** Setting #{key.inspect} does not exist" if setting.nil?
      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        echo " Reset #{key}"
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          echo " #{value.inspect} removed from #{key.inspect}"
        else
          @settings[key].push(value)
          echo " #{value.inspect} added to #{key.inspect}"
        end

        echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        echo "#{key.inspect} has been set to #{value.inspect}"
        @settings[key] = value
      end
    end
  end
end

# Main
class Bigshot
  include DRbUndumped
  attr_accessor :BIRTH_TIME, :START_TIME, :STORED_TIMES, :FRIED, :OOM,
                :SIGNS, :TARGETS, :INVALID_TARGETS, :FLEE_COUNT, :ALWAYS_FLEE_FROM,
                :USE_WRACKING, :AMMO, :AMMO_CONTAINER, :HIDE_FOR_AMMO, :BOON_FLEE_FROM,
                :REST_TILL_EXP, :REST_TILL_MANA, :USE_HERBS, :DEAD_MAN_SWITCH, :RETURN_WAYPOINT_IDS,
                :RESTING_ROOM_ID, :RESTING_COMMANDS, :RESTING_SCRIPTS, :HUNTING_ROOM_ID,
                :RALLYPOINT_ROOM_IDS, :HUNTING_BOUNDARIES, :HUNTING_SCRIPTS, :HUNTING_COMMANDS,
                :DISABLE_COMMANDS, :HUNTING_STANCE, :HUNTING_PREP_COMMANDS,
                :MONITOR_INTERACTION, :FLEE_CLOUDS, :FLEE_VINES, :FLEE_WEBS, :FLEE_VOIDS, :WRACKING_SPIRIT,
                :REST_TILL_SPIRIT, :BOUNTY_MODE, :AMBUSH, :ARCHERY_AIM,
                :event_stack, :inbounds, :followers, :BLESS, :AIM, :TIER3, :QUIET_FOLLOWERS,
                :MSTRIKE_COOLDOWN, :MSTRIKE_STAMINA_COOLDOWN, :MSTRIKE_MOB,
                :MSTRIKE_QUICKSTRIKE, :MSTRIKE_STAMINA_QUICKSTRIKE, :UAC_MSTRIKE,
                :WANDER_WAIT, :QUICK_COMMANDS, :PRIORITY, :TROUBADOURS_RALLY, :SNEAKY_SNEAKY,
                :QUICKHUNT_TARGETS, :UAC_SMITE, :FOG_RETURN, :FOG_OPTIONAL, :LOOT_STANCE,
                :DELAY_LOOT, :PULL, :OVERKILL, :LTE_BOOST, :HELP_GROUP_KILL, :WEAPON_REACTION, :DEADER, :CORRECT_PERCENT_MIND, :MA_LOOTER,
                :NEVER_LOOT, :RANDOM_LOOT, :BANDIT_HUNTING, :INDEPENDENT_TRAVEL, :INDEPENDENT_RETURN, :DESIGNATED_LOOTER, :CONTAINERS,
                :REMAINING_SKINS, :SKIN, :BUNDLE_SKIN, :GEM, :GEM_NUMBER, :TRACKING_CREATURE, :BOUNTY_EVAL, :CHECK_FAVOR

  PRONE = /sleeping|webbed|stunned|kneeling|sitting|^lying|prone|frozen|held in place|entangled/
  # Changed to gameobj-data.xml detection 4.12.2 update
  # No longer needed
  # BOON_LIST_ADJECTIVES = /^(?:adroit |afflicted |apt |barbed |belligerent |blurry |canny |combative |dazzling |deft |diseased |drab |dreary |ethereal |flashy |flexile |flickering |flinty |frenzied |ghastly |ghostly |gleaming |glittering |glorious |glowing |grotesque |hardy |illustrious |indistinct |keen |lanky |luminous |lustrous |muculent |nebulous |oozing |pestilent |radiant |raging |ready |resolute |robust |rune-covered |shadowy |shielded |shifting |shimmering |shining |sickly green |sinuous |slimy |sparkling |spindly |spiny |stalwart |steadfast |stout |tattooed |tenebrous |tough |twinkling |unflinching |unyielding |wavering |wispy )/

  def hunt_monitor(cur_action)
    bigshot_monitor = proc { |server_string|
      if !$bigshot_bandits && server_string =~ /<a exist="\d+" noun="([a-zA-Z]*?)">[a-zA-Z]*?<\/a> leaps from hiding to attack!/i
        temp = $1
        if !$grouplist.any? { |s| s =~ /#{temp}/i }
          $ambusher_here = true
        end
      elsif !$bigshot_bandits && server_string =~ /flies out of the shadows toward|A shadowy figure leaps from hiding to attack/i
        if $grouplist.size == 0
          $ambusher_here = true
        end
      # Remove people from room claim if they walk out of the room.
      elsif server_string =~ /^You notice <a exist="-\d+" noun="(\w+)">[^<]+<\/a> moving stealthily \w+\.$/
        check_room_claimed($1)
      elsif server_string =~ /<a exist="-\d+" noun="(\w+)">[^<]+<\/a>[^<]+<d cmd='[^']+'>[^<]+<\/d>/i
        check_room_claimed($1)
      elsif server_string =~ /^You could use this opportunity to <d cmd='WEAPON (\w+\s#\d+)'>.*<\/d>!/i
        $bigshot_reaction = $1
      elsif server_string =~ /^Vital energy infuses you, hastening your arcane reflexes!/i
        $bigshot_arcane_reflex = true
      elsif server_string =~ /^Nature's blessing of vitality departs as your arcane prowess returns to normal./i
        $bigshot_arcane_reflex = false
      elsif server_string =~ /obvious signs of someone hiding/i
        $obvious_hiding_player = true
      elsif server_string =~ /crimson mist.*?surround.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:corporeal plane!|vulnerable!)/i
        $bigshot_smite_list.push($1)
      elsif server_string =~ /crimson mist.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:returns to an ethereal state.|appears less vulnerable.)/i
        $bigshot_smite_list.delete($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?is suddenly surrounded by a blood red haze./i
        $bigshot_703_list.push($1)
      elsif server_string =~ /The blood red haze dissipates from around.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?\./i
        $bigshot_703_list.delete($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:visibly struggling against|in awe of) your radiant aura!/i
        $bigshot_1614_list.push($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?recovers from being rebuked/i
        $bigshot_1614_list.delete($1)
      elsif server_string =~ /The.*sticks in <pushBold\/>an? <a exist="(\d+)" noun="[^"]+">[^<]+<\/a><popBold\/>'s (?:left |right )?(.*)!/i
        $bigshot_archery_stuck_location.push($2)
        $bigshot_dislodge_location.push($2)
        $bigshot_dislodge_target = $1
      elsif server_string =~ /You're now aiming at the (.*) of/i
        $bigshot_archery_location = $1
      elsif server_string =~ /You're now no longer aiming at anything in particular/i
        $bigshot_archery_location = nil
      elsif server_string =~ /The <a exist="(.*?)" noun="(.*?)">.*?<\/a> strikes? true.* shrugs off some of the damage!/i
        my_id = $1.dup
        my_noun = $2.dup
        my_item = GameObj.inv.find { |i| i.id == "#{my_id}" }
        if @AMMO == "#{my_noun}" || my_item || (checkright || checkleft) == "#{my_noun}"
          $bigshot_bless.push(my_id) if !$bigshot_bless.include?(my_id)
        end
      elsif server_string =~ /Your <a exist="(.*?)" noun=".*?">.*?<\/a> returns? to normal\./i
        $bigshot_bless.push($1)
      elsif server_string =~ /^You bolt/i
        $ambusher_here = false
        $bigshot_smite_list = []
        $bigshot_aim = 0
        $bigshot_ambush = 0
        $bigshot_archery_aim = 0
        $bigshot_archery_stuck_location = []
        $bigshot_unarmed_tier = 1
        $bigshot_unarmed_followup = false
        $bigshot_unarmed_followup_attack = ""
        $bigshot_703_list = []
        $bigshot_1614_list = []
        $bigshot_flee = false
        $obvious_hiding_player = false
        $bigshot_reaction = nil
      elsif server_string =~ /#{UserVars.op["flee_message"]}/i && UserVars.op["flee_message"] != ""
        $bigshot_flee = true
      elsif server_string =~ /^\s+Strike leaves foe vulnerable to a followup (.*) attack!/
        $bigshot_unarmed_followup = true
        $bigshot_unarmed_followup_attack = $1
      elsif server_string =~ /^You have (decent|good|excellent) positioning against <pushBold\/>\w+ <a exist="\d+" noun=" ?\w+">[^<]+<\/a><popBold\/>\./
        tier = $1
        if tier =~ /decent/
          $bigshot_unarmed_tier = 1
        elsif tier =~ /good/
          $bigshot_unarmed_tier = 2
        elsif tier =~ /excellent/
          $bigshot_unarmed_tier = 3
        end
      elsif server_string =~ /^You (?:make a precise )?attempt to (\w+) <pushBold\/>\w+ <a exist="(\d+)" noun=" ?(\w+)">([^<]+)<\/a><popBold\/>!/
        if $bigshot_unarmed_followup && ($bigshot_unarmed_followup_attack.to_s == $1.to_s)
          assess_followup
        end
      elsif server_string =~ /^A[n]? (.*) rises out of the shadows and flies back to your waiting hand!/i
        $bigshot_bond_return = true
      elsif server_string =~ /Your Swift Justice charges are increased to (\d+)\./i
        $bigshot_swift_justice = $1.to_i
      elsif server_string =~ /Your Swift Justice surges through you! Its charges are reduced to (\d+)\./i
        $bigshot_swift_justice = $1.to_i
      end
      server_string
    }

    DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    before_dying { DownstreamHook.remove("#{$current_script_name}_monitor") }

    if cur_action == "start"
      echo "starting bigshot_monitor" if $bigshot_debug
      DownstreamHook.add("#{$current_script_name}_monitor", bigshot_monitor)
    elsif cur_action == "stop"
      echo "removing bigshot_monitor" if $bigshot_debug
      DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    else
      echo "removing bigshot_monitor" if $bigshot_debug
      DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    end
  end

  def add_event(type, time_stamp, room_id, c_in = nil)
    echo "add_event" if $bigshot_debug
    unless (@event_stack.size > 5 && type == :ATTACK)
      if (type == :FOLLOWER_OVERKILL)
        add_overkill()
        @event_stack.push(Event.new(type, time_stamp, room_id, c_in)) unless (@event_stack.any? { |a| a.type == type })
      else
        @event_stack.push(Event.new(type, time_stamp, room_id, c_in))
      end
    end
  end

  def grab_event()
    echo "grab_event" if $bigshot_debug
    @event_stack.shift()
  end

  def clear_events()
    echo "clear_events" if $bigshot_debug
    @event_stack.clear
  end

  def initialize(options = nil)
    echo "initialize" if $bigshot_debug
    $bigshot = self

    @HELP_GROUP_KILL = true

    UserVars.op ||= Hash.new
    CharSettings['targetable']   ||= Array.new
    CharSettings['untargetable'] ||= Array.new
    CharSettings['untargetable'] = CharSettings['untargetable'].uniq
    @BIRTH_TIME   = Time.now.to_i
    @START_TIME   = 1
    @STORED_TIMES = Array.new
    @COMMANDS_REGISTRY = {}

    @followers = nil
    @event_stack = Array.new

    load_settings()
    convert_from_uid

    unless $bigshot_quick
      @inbounds = BSAreaRooms.new(@HUNTING_ROOM_ID, @HUNTING_BOUNDARIES)
      @inbounds.build
    end

    instance_variable_set("@CORRECT_PERCENT_MIND", check_mind)

    @TRACKING_CREATURE = options[0].gsub(/(solo|bounty|quick|single|head|tail)\s*/i, '').strip

    if options.any? { |var| var =~ /bounty/i }
      @BOUNTY_MODE = true
      if checkbounty.include?("bandit")
        @BANDIT_HUNTING = true
      end
      set_bounty_eval()
    end

    dead_man_switch()

    before_dying {
      @HUNTING_SCRIPTS.each { |hs|
        # check for scripts with args passed
        hs_name = hs.split(/\s+/).first
        echo "Cleaning up hunting scripts: #{hs_name}."
        stop_script(hs_name) if running?(hs_name)
      }
      fput("movement autosneak off") if $bigshot_sneaky_hunt
    }
  end

  def load_settings()
    check_required_values

    # Resting Tab - Where to Rest
    set_value('return_waypoint_ids',          'split', Array.new) # return waypoint room ids
    set_value('resting_room_id',              '', 4)                      # resting room ID
    set_value('resting_commands',             'split_xx',  Array.new)     # pre-rest commands
    set_value('resting_scripts',              'split',     Array.new)     # active resting scripts
    set_value('fog_return',                   '',          nil)           # fog options
    set_value('fog_optional',                 '',          false)         # fog only if wounded or encumbered
    set_value('fog_rift',                     '',          false)         # fog twice if returning from the rift

    # Resting Tab - Should Rest?
    set_value('fried',                        'to_i',      nil)           # when percentmind >=
    set_value('overkill',                     'to_i',      0)             # and extra kills >=
    set_value('lte_boost',                    'to_i',      0)             # and use lte boosts >=
    set_value('oom',                          'to_i',      nil)           # or percentmana <=
    set_value('encumbered',                   'to_i',      200)           # or percent encumbrance
    set_value('wounded_eval',                 '',          nil)           # or wounded eval
    set_value('creeping_dread',               'to_i',      0)             # when creeping dread >=
    set_value('crushing_dread',               'to_i',      0)             # when crushing dread >=
    set_value('wot_poison',                   '',          false)         # wall of thorns poison
    set_value('confusion',                    '',          false)         # confusion debuff

    # Hunting Tab - Hunting Map
    set_value('hunting_room_id',              '',          4)             # starting room id
    set_value('rallypoint_room_ids',          'split',     Array.new)     # rallypoint room ids
    set_value('hunting_boundaries',           'split',     Array.new)     # boundary room ids_from_uid

    # Hunting Tab - Should Hunt?
    set_value('rest_till_exp',                'to_i',      nil)           # when percentmind <=
    set_value('rest_till_mana',               'to_i',      nil)           # and percentmana >=
    set_value('rest_till_spirit',             'to_i',      0)             # and checkspirit >=

    # Hunting Tab - Right Side
    set_value('hunting_stance',               '',          'defensive')   # attack stance
    set_value('hunting_prep_commands',        'split_xx',  Array.new)     # pre-hunt commands
    set_value('hunting_scripts',              'split',     Array.new)     # active hunting scripts
    set_value('signs',                        'split',     Array.new)     # society abilities/spells/cman
    set_value('loot_script',                  '',          nil)           # loot script
    set_value('wracking_spirit',              'to_i',      0)             # wracking spirit >=

    # Hunting Tab - Right Side Toggles
    set_value('priority',                     '',          false)         # priority hunt
    set_value('delay_loot',                   '',          false)         # delay looting
    set_value('troubadours_rally',            '',          false)         # troubadours rally
    set_value('use_wracking',                 '',          false)         # use sign of wracking/sigil of power/symbol of mana
    set_value('loot_stance',                  '',          false)         # defensive stance before looting
    set_value('pull',                         '',          true)          # pull players to feet
    set_value('deader',                       '',          false)         # stop for dead players
    set_value('sneaky_sneaky',                '',          false)         # sneak during hunts
    set_value('check_favor',                  '',          false)         # checks for favor before casting symbols

    # Attacking Tab
    set_value('ambush',                       'split',     Array.new)     # ambush aiming locations
    set_value('archery_aim',                  'split',     Array.new)     # archery aiming locations
    set_value('flee_count',                   'to_i',      10)            # flee if enemy count is >
    set_value('invalid_targets',              'split',     Array.new)     # but don't count these
    set_value('always_flee_from',             'split',     Array.new)     # and always flee from
    set_value('flee_message',                 '',          nil)           # flee from environmental message
    set_value('wander_wait',                  'to_f',      0.3)           # wait before wandering to another room

    # Attack Tab - Toggles
    set_value('boon_flee_from',               '',          false)         # flee from boon/boss/glamour creatures
    set_value('flee_clouds',                  '',          false)         # flee from clouds
    set_value('flee_vines',                   '',          false)         # flee from vines
    set_value('flee_webs',                    '',          false)         # flee from webs
    set_value('flee_voids',                   '',          false)         # flee from voids
    set_value('bless',                        '',          nil)           # bless weapon
    set_value('lone_targets_only',            '',          false)         # approach loan targets only
    set_value('weapon_reaction',              '',          true)          # activate weapon reactions

    # Commands Tab - Left
    set_value('hunting_commands',             'split_xx',  nil)           # hunting commands(a)
    set_value('hunting_commands_b',           'split_xx',  Array.new)     # hunting commands(b)
    set_value('hunting_commands_c',           'split_xx',  Array.new)     # hunting commands(c)
    set_value('hunting_commands_d',           'split_xx',  Array.new)     # hunting commands(d)
    set_value('hunting_commands_e',           'split_xx',  Array.new)     # hunting commands(e)
    set_value('hunting_commands_f',           'split_xx',  Array.new)     # hunting commands(f)
    set_value('hunting_commands_g',           'split_xx',  Array.new)     # hunting commands(g)
    set_value('hunting_commands_h',           'split_xx',  Array.new)     # hunting commands(h)
    set_value('hunting_commands_i',           'split_xx',  Array.new)     # hunting commands(i)
    set_value('hunting_commands_j',           'split_xx',  Array.new)     # hunting commands(j)

    # Commands Tab - Right
    set_value('targets',                      'targets',   nil)           # valid targets
    set_value('quickhunt_targets',            'qtargets',  nil)           # quickhunt targets
    set_value('quick_commands',               'split_xx',  Array.new)     # quick commands
    set_value('disable_commands',             'split_xx',  Array.new)     # fried commands

    # Misc Tab - UAC
    set_value('tier3',                        '',          'punch')       # tier 3 attack
    set_value('aim',                          'split',     Array.new)     # aim at location
    set_value('uac_smite',                    '',          false)         # use voln smite
    set_value('uac_mstrike', '', false) # do not mstrike

    # Misc Tab - Mstrike
    set_value('mstrike_stamina_cooldown',     'to_i',      maxstamina)    # mstrike during cooldown stamina requirement
    set_value('mstrike_stamina_quickstrike',  'to_i',      maxstamina)    # quickstrike stamina requirement
    set_value('mstrike_mob',                  'to_i',      2)             # unfocused mstrike when creature >=
    set_value('mstrike_cooldown',             '',          nil)           # mstrike during cooldown
    set_value('mstrike_quickstrike',          '',          nil)           # use quickstrike for mstrike

    # Misc Tab - Ammo/Wands
    set_value('ammo_container',               '',          nil)           # find ammo in this container
    set_value('ammo',                         '',          nil)           # use this ammo type
    set_value('fresh_wand_container',         '',          nil)           # fresh wand container
    set_value('dead_wand_container',          '',          nil)           # dead wand container
    set_value('wand',                         'split',     nil)           # use this wand type
    set_value('hide_for_ammo',                '',          nil)           # hide to pick up ammo
    set_value('wand_if_oom',                  '',          false)         # use wands when oom

    # Misc Tab - MA Grouping
    set_value('independent_travel',            '',         false)         # travel TO hunting grounds not as a group
    set_value('independent_return',            '',         false)         # travel FROM hunting grounds not as a group
    set_value('ma_looter',                    '',          nil)           # character name of looter
    set_value('never_loot',                   'split_xx',  Array.new)     # no-looting list
    set_value('random_loot',                  '',          false)         # random looting based on encumbrance

    # Monitoring Tab
    set_value('dead_man_switch',              '',          false)         # engage dead man's switch
    set_value('depart_switch',                '',          false)         # depart/rerun if dead
    set_value('quiet_followers',              '',          true)          # quiet followers
    set_value('monitor_interaction',          '',          false)         # monitor interactions
    set_value('monitor_strings',              'split',     Array.new)     # watch for strings(or regex) that contain
    set_value('monitor_safe_strings',         'split',     Array.new)     # except if they also contain

    # Internal
    set_value('bounty_eval',                  '',          nil) # used to set bounty rest parameters
  end

  def clean_value(clean, value)
    if (clean == 'to_i')
      return value.to_i
    elsif (clean == 'to_f')
      return value.to_f
    elsif (clean == 'split')
      return value.split(/,\s*/)
    elsif (clean == 'split_xx')
      cleaned = Array.new
      value.split(/,\s*/).each { |i|
        rep = 1
        cmd = ''
        if (i =~ /(.*)\(x(\d+)\)$/i)
          rep = $2.to_i
          cmd = $1
        elsif (i =~ /(.*)\(xx\)/i)
          rep = 5
          cmd = $1
        else
          cmd = i
        end
        and_tokens = cmd.split(/\sand\s/)
        cmd = and_tokens.size == 1 ? and_tokens[0] : and_tokens
        rep.times do cleaned.push(cmd) end
      }
      return cleaned
    elsif (clean =~ /targets|qtargets/)
      targets = Hash.new
      tokens = value.split(/,/)
      tokens.each do |i|
        if (i =~ /(.*)\(([a|b|c|d|e|f|g|h|i|j|A|B|C|D|E|F|G|H|I|J])\)/)
          targets[$1.downcase.strip] = $2.downcase.strip
        else
          default = clean == "targets" ? 'a' : 'quick'
          targets[i.downcase.strip] = default
        end
      end
      return targets
    else
      return value
    end
  end

  def set_value(key, clean, default)
    if (!UserVars.op[key].nil? && UserVars.op[key].to_s !~ /^\s*$/)
      cleaned = clean_value(clean, UserVars.op[key])
      instance_variable_set("@#{key.upcase}", cleaned)
    else
      instance_variable_set("@#{key.upcase}", default)
    end
  end

  def convert_from_uid
    # provide support for uid's

    return if $bigshot_quick

    # Return Waypoint(s)
    @RETURN_WAYPOINT_IDS.map! { |place|
      uid_match(place.to_s).to_s
    }

    # Hunting Room
    @HUNTING_ROOM_ID = uid_match(@HUNTING_ROOM_ID.to_s)

    # Resting Room
    @RESTING_ROOM_ID = uid_match(@RESTING_ROOM_ID.to_s)

    # Rally Room(s)
    @RALLYPOINT_ROOM_IDS.map! { |place|
      uid_match(place.to_s).to_s
    }
    # @RALLYPOINT_ROOM_ID = uid_match(@RALLYPOINT_ROOM_ID.to_s)

    # Boundary Rooms
    @HUNTING_BOUNDARIES.map! { |place|
      uid_match(place.to_s).to_s
    }
  end

  def uid_match(room)
    uid_pattern = /u(?<uid>\d+)/
    if (m = uid_pattern.match(room))
      uid = m[:uid].to_i
      lookup_id = Map.ids_from_uid(uid)
      if lookup_id.size > 0
        room = lookup_id[0]
      else
        echo "Not able to find #{room} in the map database! Exiting..."
        exit
      end
    end
    return room.to_i
  end

  def color(color, msg)
    if defined?(Lich::Messaging)
      Lich::Messaging.msg_format(color, msg)
    else
      msg
    end
  end

  def check_required_values
    if !$bigshot_quick
      unless (UserVars.op["fried"].to_s.empty? || UserVars.op["oom"].to_s.empty? || UserVars.op["rest_till_mana"].to_s.empty? || UserVars.op["resting_room_id"].to_s.empty? ||
             UserVars.op["rest_till_exp"].to_s.empty? || UserVars.op["hunting_commands"].to_s.empty? || UserVars.op["hunting_room_id"].to_s.empty? || UserVars.op["rest_till_spirit"].to_s.empty? ||
             UserVars.op["targets"].to_s.empty?)
        return
      end

    elsif $bigshot_quick
      unless (UserVars.op["quick_commands"].to_s.empty?)
        return
      end
    end

    output = []
    output << "<output class='mono'/>"
    output << ""
    output << "   #{color("yellow", "There are required setting missing for Bigshot to function...")}"
    output << ""

    if UserVars.op["resting_room_id"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "Resting room id :  This is on the Resting tab")}"
      output << ""
    end

    if UserVars.op["fried"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "when percentmind >=  :  This is on the Resting tab")}"
      output << ""
    end

    if UserVars.op["oom"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "or percentmana <=  :  This is on the Resting tab")}"
      output << ""
    end

    if UserVars.op["hunting_room_id"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "starting room id  :  This is on the Hunting tab")}"
      output << ""
    end

    if UserVars.op["rest_till_exp"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "when percent mind <=  :  This is on the Hunting tab")}"
      output << ""
    end

    if UserVars.op["rest_till_mana"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "and percent mana >=  :  This is on the Hunting tab")}"
      output << ""
    end

    if UserVars.op["rest_till_spirit"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "and checkspirit >=  :  This is on the Hunting tab")}"
      output << ""
    end

    if UserVars.op["hunting_commands"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "Hunting Commands (a)  :  This is on the Commands tab")}"
      output << ""
    end

    if UserVars.op["targets"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "Valid Targets  :  This is on the Commands tab")}"
      output << ""
    end

    if UserVars.op["quick_commands"].to_s.empty? && $bigshot_quick
      output << "   #{color("yellow", "Quick Hunting Commands  :  This is on the Commands tab")}"
      output << ""
    end

    output << "<output class=''/>"
    output << ""

    results = []
    output.each { |line|
      new_line = line

      if $frontend =~ /^(?:wizard)$/
        sf_to_wiz(line)
        items = /<output class='mono'\/>|<output class=''\/>/
        new_line = new_line.gsub(items, "")
        new_line = new_line.gsub(/&lt;/, "<")
        new_line = new_line.gsub(/&gt;/, ">")
      else
        line.scan(/\<[^\]\<]*[^\/]>/).each { |item|
          next if item.include?("preset") ||
                  (new_line = new_line.gsub(item, item.encode(:xml => :text)))
        }
      end

      results.push(new_line)
    }

    _respond results

    Script.self.kill
  end

  def set_bounty_eval()
    return unless @BOUNTY_EVAL.to_s.empty?

    @CONTAINERS = []
    GameObj.inv.each { |item|
      if GameObj.containers[item.id]
        @CONTAINERS.push(item)
      end
    }

    bounty_eval = %Q{!!(checkbounty =~ /^You.*?(succeeded|located|failed )|your task is failed/)} # bounty complete
    bounty_eval += %Q{ || !!(checkbounty =~ /^You are not currently assigned / && !Effects::Cooldowns.to_h.include?('Next Bounty'))}

    if checkbounty =~ /A local divinist has had visions of the child fleeing/
      bounty_eval += %Q{ || !!(checkbounty =~ /^You have made contact with the child/ && GameObj.npcs.any? { |npc| npc.name =~ /\\bchild\\b/ })}
    elsif checkbounty =~ /You have been tasked to retrieve(.*)of at least/
      if checkbounty =~ /You have been tasked to retrieve (\d+) (.*?)(?:s)? of at/
        @REMAINING_SKINS = $1.to_i
        @SKIN = $2
      end
      @BUNDLE_SKIN = @SKIN.match(/(\w+)\s+(\w+)\s*\Z/)

      @SKIN = @SKIN.strip.downcase
                   .gsub(/s$/, "")
                   .gsub(/teeth/, "tooth")
                   .gsub(/hooves?/, "hoof")
                   .gsub(/ruffs?/, "ruff")


      bounty_eval += %Q{ || !!(count = 0;@CONTAINERS.each{|i| i.contents.each{ |k| if k.name =~ /bundle of #{@BUNDLE_SKIN}/ && !@BUNDLE_SKIN.to_s.empty? && !hidden?; lines = Lich::Util.quiet_command_xml("measure #"+k.id.to_s, /You glance through/);count += $1.to_i if lines.any?{ |l| l=~ /count a total of ([0-9]+) <a exist/};end;};};count >= @REMAINING_SKINS)}
      bounty_eval += %Q{ || !!(j=0;@CONTAINERS.each{|i| j += i.contents.count{|l| l.name =~ /#{@SKIN}/i && !@SKIN.to_s.empty?}.to_i }; j >= @REMAINING_SKINS)}
    elsif checkbounty =~ /The gem dealer/
      gem_regex = /The gem dealer in (?<town>[^,]+), [^,]+, has received orders from multiple customers requesting (?:an?|some) (?<gem>[^.]+)\.  You have been tasked to retrieve (?<number>\d+) (?:more\s+)?of them\./
      match_data = checkbounty.match(gem_regex)
      @GEM = match_data['gem']
      @GEM_NUMBER = match_data['number'].to_i

      bounty_eval += %Q{ || !!(t=0;@CONTAINERS.each{|k| t += k.contents.count{|v| v.name =~ /#{@GEM.strip}/i && !@GEM.to_s.empty?}.to_i}; t>= @GEM_NUMBER)}
    end

    @BOUNTY_EVAL = bounty_eval
  end

  def get_res(command, regex = nil)
    rt_regex = /(?:Roundtime:|\.\.\.wait|Wait) (\d+) [Ss]ec(?:onds?)?\.?/
    regex = regex.nil? ? Regexp.union(/.*?/, rt_regex) : Regexp.union(regex, rt_regex)
    result = nil
    loop do
      result = dothistimeout(command, 2, regex)
      break unless result =~ rt_regex
      delay_for = Regexp.last_match(1).to_i
      sleep(delay_for)
      wait_while { checkrt > 0 }
      sleep 0.2
    end

    return result
  end

  def check_for_deaders_prone
    return unless @PULL
    return if GameObj.pcs.nil?
    GameObj.pcs.each { |s| if s.status =~ /sitting|^lying|prone/ && s.status !~ /dead/; fput "pull #{s.noun}"; end; } if GameObj.targets.any? { |s| s.type =~ /aggressive npc/ }

    if GameObj.pcs.any? { |s| s.status =~ /dead/ } && @DEADER
      puts "#{monsterbold_start} Found a deader! #{monsterbold_end}"
      echo "PAUSING SCRIPT"
      echo ";u bigshot"
      echo "TO CONTINUE"
      pause_script
    end
  end

  def cmd(command, npc = nil, stance_dance = true)
    echo "cmd #{command}" if $bigshot_debug

    check_for_deaders_prone

    original_command = command
    command = command.dup

    # Check for Roa'ter swallowing or Hinterwilds Ooze swallowing
    escape_rooms

    if (command.class.to_s == 'Array')
      stance_dance = false if command.any? { |j| j =~ /stance/ }
      command.each do |i|
        break if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }

        echo i if $bigshot_debug
        cmd(i, npc, stance_dance)
      end
      return
    end

    $bigshot_dislodge_location = [] if npc.status =~ /dead|gone/

    # waitrt/waitcastrt
    unless (command =~ /^nudgeweapons?|slipperymind/)
      waitrt?
      waitcastrt? unless command =~ /hide|cock/
    end

    # Check if the command meets all the right conditions
    return false if command_check(command, npc)

    if (command =~ /^force\s+(.*)\s+(?:till|until)\s+(\d+)/i)
      cmd_force($1, $2.to_i, npc)
      return
    end

    if (command =~ /^eachtarget\s+(.*)/i)
      cmd_eachtarget($1, npc)
      return
    end

    # sub id
    command.gsub!(/target/, "##{npc.id}") if !npc.nil?

    # Soothe routine - Minor Mental Spell circle
    if Spell[1201].known? && Spell[1201].affordable?
      if (Spell[201].active? || Spell[216].active? || Spell[1015].active? || Spell[1016].active? || Spell[1108].active? || Spell[1120].active?)
        waitrt?
        waitcastrt?
        Spell[1201].cast
      end
    end

    cmd_bless() if @BLESS && $bigshot_bless.count > 0

    # Celerity (506) routine
    if (command =~ /^(celerity|haste|506)\s+(.*)/i)
      command = $2
      if Spell[506].known? and Spell[506].affordable?
        if (Spell[506].active? and Spell[506].timeleft <= 0.05) || (!Spell[506].active?)
          Spell[506].cast
        end
      end
    end

    # Spirit Slayer (240) routine
    if (command =~ /^(slayer|240)\s+(.*)/i)
      command = $2
      if Spell[240].known? && Spell[240].affordable? && !Effects::Cooldowns.active?(Spell[240].name)
        if (Spell[240].active? && Spell[240].timeleft <= 0.05) || (!Spell[240].active?)
          Spell[240].cast
        end
      end
    end

    if (command =~ /^(tonis|1035)\s+(.*)/i)
      command = $2
      if Spell[1035].known? && Spell[1035].affordable?
        if (Spell[1035].active? && Spell[1035].timeleft <= 0.05) || (!Spell[1035].active?)
          Spell[1035].cast
        end
      end
    end

    # Condition check passed, drop the conditions from the command and lets do something
    command = command =~ /(.*)\((.*?)\)$/ ? $1.strip : command.strip
    command = command.downcase

    # Change_stance
    stand(command) if !standing?
    unless (command =~ /^(?:\d+|wait|sleep|wand|berserk|script|hide|nudgeweapon)/i)
      change_stance(@HUNTING_STANCE) if stance_dance
    end

    # Target gone or not priority? Then return
    return if (npc && !valid_target?(npc)) or npc.status =~ /dead|gone/
    return if @PRIORITY && !priority(npc)

    # Perform the command
    if (command =~ /^(incant)?\s?(\d+)\s?((?:open|closed)?\s?(?:cast|channel|evoke)?\s?(?:cast|channel|evoke)?\s?(?:open|closed)?\s?(?:acid|air|cold|earth|fire|lightning|steam|water)?)?.*$/i)
      cmd_spell($1, $2.to_i, $3, npc)
    elsif (command =~ /^barrage|^flurry|^fury|^gthrusts|^pummel|^thrash/i)
      cmd_assault(npc, command)
    elsif (command =~ /^pindown|^cripple|^charge|^twinhammer|^dizzyingswing|^clash|^volley|^pulverize|^cyclone|^whirlwind|^wblade/i)
      cmd_weapons(npc, command)
    elsif (command =~ /^shield throw|^shield bash|^shield charge|^shield strike|^shield pin|^shield trample|^shield push/i)
      cmd_shields(npc, command)
    elsif (command =~ /^bullrush|^coupdegrace|^cpress|^dirtkick|^exsanguinate|^feint|^gkick|^hamstring|^haymaker|^headbutt|^kifocus|^leapattack|^mblow|^sattack|^sbash|^sblow|^scleave|^sthieve|^sunder|^tackle|^trip|^truestrike|^vaultkick/i)
      cmd_cmans(npc, command)
    elsif (command =~ /^bearhug/i)
      cmd_bearhug(npc, command)
    elsif (command =~ /^cutthroat|^divert|^shroud|^eviscerate|^eyepoke|^footstomp|^garrote|^kneebash|^mug|^nosetweak|^spunch|^subdue|^sweep|^swiftkick|^templeshot|^throatchop/i)
      cmd_rogue_cmans(npc, command)
    elsif (command =~ /^shout|^yowlp|^holler|^bellow|^growl|^cry/i)
      cmd_warrior_shouts(npc, command)
    elsif (command =~ /^throw/i)
      cmd_throw(npc)
    elsif (command =~ /^k?weed/i)
      cmd_weed(command, npc)
    elsif (command =~ /^wand/i)
      cmd_wand(npc)
    elsif (command =~ /^hide\s?(\d+)?/i)
      cmd_hide($1.to_i)
    elsif (command =~ /^mstrike/i)
      cmd_mstrike(command, npc)
    elsif (command =~ /^fire/i)
      cmd_ranged(npc)
    elsif (command =~ /dislodge\s?(.*)/i)
      cmd_dislodge(npc, $1)
    elsif (command =~ /^burst/i)
      cmd_burst()
    elsif (command =~ /^surge/i)
      cmd_surge()
    elsif (command =~ /^berserk/i)
      cmd_berserk()
    elsif (command =~ /^script\s+(.*?)(\s|$)(.*)/i)
      cmd_run_script($1, $3)
    elsif (command =~ /^sleep\s+(\d+)/i)
      cmd_sleep($1, npc)
    elsif (command =~ /^stance\s+(.*)/i)
      change_stance($1)
    elsif (command =~ /^wait\s+(\d+)/i)
      wait_for_swing($1.to_i, npc)
      $stop_wait = true
    elsif (command =~ /^nudgeweapons?\s*/i)
      cmd_nudge_weapons
    elsif (command =~ /^ambush\s?(.*)?/i)
      cmd_ambush($1, npc)
    elsif (command =~ /^unarmed\s+([a-z]*).?([a-z]*)?$/i)
      cmd_unarmed($1, npc, $2)
    elsif (command =~ /^smite/i)
      cmd_volnsmite(npc)
    elsif (command =~ /^caststop\s+(\d+)\s?(.*)?/i)
      cmd_caststop(npc, $1.to_i, $2)
    elsif (command =~ /^(?:unravel|barddispel)\s?(.*)?/i)
      cmd_unravel($1, npc)
    elsif (command =~ /^stomp/i)
      cmd_stomp()
    elsif (command =~ /^leech/i)
      cmd_leech()
    elsif (command =~ /^curse\s+(clumsy|weakness|darkness|itch|hex|pox|nightmare|star)$/i)
      cmd_curse(npc, $1)
    elsif (command =~ /^efury\s?(fire|cold)?/i)
      cmd_efury(npc, $1)
    elsif (command =~ /^dhurl/i)
      cmd_dhurl()
    elsif (command =~ /briar\s?(\w+)/i)
      cmd_briar($1)
    elsif (command =~ /^assume\s?(\w+)?\s?(\w+)?/i)
      cmd_assume($1, $2)
    elsif (command =~ /^wield\s+(\w+)\s?(left|right)?/i)
      cmd_wield($1, $2)
    elsif (command =~ /^store\s+(left|right|both)?/i)
      cmd_store($1)
    else
      return if $ambusher_here
      return if $obvious_hiding_player

      echo "inside cmd: #{command}" if $bigshot_debug

      bs_put command
    end
    once_commands_register(npc, original_command)
  end

  def once_commands_register(npc, command)
    echo "once_commands_register - #{npc.id} - #{command}" if $bigshot_debug
    if @COMMANDS_REGISTRY[npc.id].nil?
      @COMMANDS_REGISTRY[npc.id] = [command]
    elsif !@COMMANDS_REGISTRY[npc.id].include?(command)
      @COMMANDS_REGISTRY[npc.id].push(command)
    end
  end

  def cmd_eachtarget(command, npc)
    echo "eachtarget - command(#{command}) called on #{npc}(#{npc.id})" if $bigshot_debug
    current_target = npc
    GameObj.targets.each { |target|
      next unless valid_target?(target)
      fput "target ##{target.id}" unless XMLData.current_target_id == target.id
      cmd(command, target)
    }
    fput "target ##{current_target.id}" unless XMLData.current_target_id == current_target.id
  end

  def command_check(command, npc)
    echo "command_check #{command}" if $bigshot_debug
    # should_return = false
    # check mana/stamina/health(percentage)/encumbrance/unarmed tiering/mobs in room/target not prone/target undead
    # ! means the inverse/opposite effect
    original_command = command
    if (command =~ /(.*)\((.*?(?:barrage|!barrage|bearhug|!bearhug|buff|burst|!burst|censer|disease|!disease|e|!e|frozen|!frozen|flurry|!flurry|flying|!flying|fury|!fury|h|!h|hidden|!hidden|holler|!holler|justice|!justice|k|!k|m|!m|mob|!mob|noncorporeal|!noncorporeal|once|outside|!outside|pcs|!pcs|poison|!poison|prone|!prone|pummel|!pummel|reflex|!reflex|rooted|!rooted|s|!s|shout|!shout|surge|!surge|tailwind|!tailwind|tier|!tier|tier1|!tier1|tier2|!tier2|tier3|!tier3|thrash|!thrash|undead|!undead|v|!v|vigor|!vigor|yowlp|!yowlp).*?)\)$/i)
      command = $1.strip

      $2.split(" ").each { |s|
        if s =~ /((?:e|!e|h|!h|k|!k|m|!m|mob|!mob|s|!s|tier|!tier|v|!v))(\d+)/i
          amount = $2.to_i
          split_item = $1.strip

          split_check = {
            'e'     => !checkencumbrance(amount),
            '!e'    => checkencumbrance(amount),
            'h'     => !percenthealth(amount),
            '!h'    => percenthealth(amount),
            'k'     => !checkkneeling,
            '!k'    => checkkneeling,
            'm'     => !checkmana(amount),
            '!m'    => checkmana(amount),
            'mob'   => gameobj_npc_check() < amount,
            '!mob'  => gameobj_npc_check() > amount,
            's'     => !checkstamina(amount),
            '!s'    => checkstamina(amount),
            'tier'  => $bigshot_unarmed_tier < amount,
            '!tier' => $bigshot_unarmed_tier > amount,
            'v'     => !checkspirit(amount),
            '!v'    => checkspirit(amount),
          }

          echo "command_check section 1 #{s} #{split_check[split_item]}" if $bigshot_debug
          return split_check[split_item] if split_check[split_item]
        end

        if s =~ /((?:buff))(\d+)/i
          amount = $2.to_i
          buff_check = {
            'barrage' => !(Effects::Buffs.time_left("Enh. Dexterity (+10)") <= (amount / 60.to_f)),
            'bearhug' => !(Effects::Buffs.time_left("Enh. Strength (+10)") <= (amount / 60.to_f)),
            'fury'    => !(Effects::Buffs.time_left("Enh. Constitution (+10)") <= (amount / 60.to_f)),
            'flurry'  => !(Effects::Buffs.time_left("Slashing Strikes") <= (amount / 60.to_f)),
            'pummel'  => !(Effects::Buffs.time_left("Concussive Blows") <= (amount / 60.to_f)),
            'thrash'  => !(Effects::Buffs.time_left("Forceful Blows") <= (amount / 60.to_f)),
            'yowlp'   => !(Effects::Buffs.time_left("Yertie's Yowlp") <= (amount / 60.to_f)),
            'shout'   => !(Effects::Buffs.time_left("Empowered (+20)") <= (amount / 60.to_f)),
            'kweed'   => !(Effects::Buffs.time_left("Tangleweed Vigor") <= (amount / 60.to_f)),
            'weed'    => !(Effects::Buffs.time_left("Tangleweed Vigor") <= (amount / 60.to_f)),
          }

          echo "command_check section 2 #{s} #{buff_check[command]}" if $bigshot_debug
          return buff_check[command] if buff_check[command]
        end

        if s =~ /((?:barrage|!barrage|bearhug|!bearhug|burst|!burst|censer|disease|!disease|flurry|!flurry|flying|!flying|frozen|!frozen|fury|!fury|hidden|!hidden|holler|!holler|justice|!justice|noncorporeal|!noncorporeal|once|outside|!outside|pcs|!pcs|poison|!poison|prone|!prone|pummel|!pummel|reflex|!reflex|rooted|!rooted|shout|!shout|surge|!surge|tailwind|!tailwind|thrash|!thrash|tier1|!tier1|tier2|!tier2|tier3|!tier3|undead|!undead|vigor|!vigor|yowlp|!yowlp))/i
          item = $1.strip
          other_checks = {
            'barrage'       => !Effects::Buffs.active?("Enh. Dexterity (+10)"),
            '!barrage'      => Effects::Buffs.active?("Enh. Dexterity (+10)"),
            'bearhug'       => (!Effects::Buffs.active?("Enh. Strength (+10)") && !Effects::Buffs.active?("Enh. Strength (+20)")),
            '!bearhug'      => (Effects::Buffs.active?("Enh. Strength (+10)") || Effects::Buffs.active?("Enh. Strength (+20)")),
            'burst'         => Effects::Buffs.to_h.keys.grep(/Enh. Dexterity/).length.positive?,
            '!burst'        => Effects::Cooldowns.active?("Burst of Swiftness"),
            'disease'       => !checkdisease,
            '!disease'      => checkdisease,
            'flurry'        => !Effects::Buffs.active?("Slashing Strikes"),
            '!flurry'       => Effects::Buffs.active?("Slashing Strikes"),
            'flying'        => !npc.status.include?("flying"),
            '!flying'       => npc.status.include?("flying"),
            'frozen'        => npc.status =~ /frozen/i,
            '!frozen'       => npc.status !~ /frozen/i,
            'fury'          => !Effects::Buffs.active?("Enh. Constitution (+10)"),
            '!fury'         => Effects::Buffs.active?("Enh. Constitution (+10)"),
            'hidden'        => !hiding?,
            '!hidden'       => hiding?,
            'holler'        => !Effects::Buffs.active?('Enh. Health (+20)'),
            '!holler'       => Effects::Buffs.active?('Enh. Health (+20)'),
            'justice'       => $bigshot_swift_justice == 0,
            '!justice'      => $bigshot_swift_justice >= 1,
            'noncorporeal'  => !npc.type.split(',').any? { |a| a == "noncorporeal" },
            '!noncorporeal' => npc.type.split(',').any? { |a| a == "noncorporeal" },
            'once'          => @COMMANDS_REGISTRY[npc.id].include?(original_command),
            'outside'       => !outside?,
            '!outside'      => outside?,
            'pcs'           => !((checkpcs - $grouplist).count > 0),
            '!pcs'          => ((checkpcs - $grouplist).count > 0),
            'poison'        => !checkpoison,
            '!poison'       => checkpoison,
            'prone'         => npc.status =~ PRONE,
            '!prone'        => npc.status !~ PRONE,
            'pummel'        => !Effects::Buffs.active?("Concussive Blows"),
            '!pummel'       => Effects::Buffs.active?("Concussive Blows"),
            'reflex'        => !$bigshot_arcane_reflex,
            '!reflex'       => $bigshot_arcane_reflex,
            'rooted'        => npc.status =~ /rooted/i,
            '!rooted'       => npc.status !~ /rooted/i,
            'shout'         => !Effects::Buffs.active?('Empowered (+20)'),
            '!shout'        => Effects::Buffs.active?('Empowered (+20)'),
            'surge'         => Effects::Buffs.active?("Enh. Strength (+32)") || Effects::Buffs.active?("Enh. Strength (+28)") || Effects::Buffs.active?("Enh. Strength (+24)") || Effects::Buffs.active?("Enh. Strength (+20)") || Effects::Buffs.active?("Enh. Strength (+16)"),
            '!surge'        => Effects::Cooldowns.active?("Surge of Strength"),
            'tailwind'      => !Effects::Buffs.active?("Breeze Archery Tailwind"),
            '!tailwind'     => Effects::Buffs.active?("Breeze Archery Tailwind"),
            'thrash'        => !Effects::Buffs.active?("Forceful Blows"),
            '!thrash'       => Effects::Buffs.active?("Forceful Blows"),
            'tier1'         => $bigshot_unarmed_tier != 1,
            '!tier1'        => $bigshot_unarmed_tier == 1,
            'tier2'         => $bigshot_unarmed_tier != 2,
            '!tier2'        => $bigshot_unarmed_tier == 2,
            'tier3'         => $bigshot_unarmed_tier != 3,
            '!tier3'        => $bigshot_unarmed_tier == 3,
            'undead'        => !npc.type.split(',').any? { |a| a == "undead" },
            '!undead'       => npc.type.split(',').any? { |a| a == "undead" },
            'vigor'         => !Effects::Buffs.active?('Tangleweed Vigor'),
            '!vigor'        => Effects::Buffs.active?('Tangleweed Vigor'),
            'yowlp'         => !Effects::Buffs.active?("Yertie's Yowlp"),
            '!yowlp'        => Effects::Buffs.active?("Yertie's Yowlp"),
          }

          if (item == 'censer')
            if (command =~ /^(incant)?\s?(\d+)\s?((?:open|closed)?\s?(?:cast|channel|evoke)?\s?(?:cast|channel|evoke)?\s?(?:open|closed)?\s?(?:air|earth|fire|lightning|water|cold)?)?.*$/i)
              id = $2.to_i
              spell_cost = Spell[id].cost.to_i + Spell[320].cost.to_i
            else
              spell_cost = Spell[320].cost.to_i
            end

            if !Effects::Cooldowns.active?("Ethereal Censer") && Spell[320].known?
              Spell[320].cast if (checkmana >= spell_cost)
            end
          else
            echo "command_check section 3 #{s} #{other_checks[item]}" if $bigshot_debug
            return other_checks[item] if other_checks[item]
          end

        end
      }

    end

    return false
  end

  def cmd_wield(noun, hand)
    echo("cmd_wield(#{noun})") if $bigshot_debug
    return if (hand.empty? || hand == 'right') && GameObj.right_hand.noun == "#{noun}"
    return if hand == 'left' && GameObj.left_hand.noun == "#{noun}"
    if hand.empty? || hand == 'right'
      fput('store right')
    else
      fput('store left')
    end
    fput("get my #{noun}")
  end

  def cmd_store(hand)
    echo("cmd_store(#{hand})") if $bigshot_debug
    return if GameObj.right_hand.id.nil? && hand == 'right'
    return if GameObj.left_hand.id.nil? && hand == 'left'
    return if GameObj.left_hand.id.nil? && GameObj.right_hand.id.nil? && (hand == 'both' || hand.empty?)
    case hand
    when 'right'
      fput('store right')
    when 'left'
      fput('store left')
    else
      fput('store both')
    end
  end

  def cmd_assault(npc, cmd)
    echo "cmd_assault - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /Distracted, you hesitate/i,
      /glides to its inevitable end with one final twirl/i,
      /You feel a fair amount more durable./i,
      /With a final snap of your wrist/i,
      /You complete your assault/i,
      /to the ready, your assault complete\./i,
      /Upon firing your last (?:arrow|bolt)/i,
      /With a final, explosive breath/i,
      /recentering yourself for the fight/i,
      /You don't seem to be able to move your legs to do that/i,
      /too injured/i,
      /already dead/i,
      /little bit late/i,
      /could not find/i,
    )

    error_regex = Regexp.union(
      /Barrage can not be used with attack as the attack type/i,
      /may not be activated within 60 seconds of a Multi-Strike\./i,
      /\.\.\.wait/i,
      /(?:Barrage|Flurry|Fury|Guardant Thrusts|Pummel|Thrash) is still in cooldown\./,
    )

    result_regex = Regexp.union(complete_regex, error_regex)

    commands = {
      "barrage"  => "Barrage",
      "flurry"   => "Flurry",
      "fury"     => "Fury",
      "gthrusts" => "Guardant Thrusts",
      "pummel"   => "Pummel",
      "thrash"   => "Thrash",
    }

    cmd_clean = cmd.split(' ').first
    return if !Weapon.available?(commands[cmd_clean])
    return unless Weapon.affordable?(commands[cmd_clean])
    if commands[cmd_clean] == "Fury" && $bigshot_unarmed_tier == 3
      cmd = commands[cmd_clean] + " " + @TIER3
    end

    waitrt?
    waitcastrt?

    break_out = Time.now() + 12
    loop {
      result = dothistimeout("weapon #{cmd} ##{npc.id}", 10, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ /Barrage can not be used with attack as the attack type/i
        # Bow in the wrong hand
        fput "swap"
        next
      elsif result =~ /may not be activated within 60 seconds of a Multi-Strike\./i
        break
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_curse(npc, type)
    echo("cmd_curse(#{npc}, #{type})") if $bigshot_debug
    return if type == 'star' && Effects::Spells.time_left("Curse of the Star (bonus)") > 0.5
    timeout = Time.now + 10
    loop do
      return unless Spell[715].known? && Spell[715].affordable?
      waitrt?
      waitcastrt?
      results = dothistimeout('prep 715', 2, /Your spell is ready\./)
      break if results
      return if Time.now > timeout
    end
    waitrt?
    waitcastrt?
    fput("curse ##{npc.id} #{type}")
  end

  def cmd_weapons(npc, cmd)
    echo "cmd_weapons - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /You rush forward/i, # charge
      /Steeling yourself for a brawl/i, # clash
      /You reverse your grip/i, # cripple
      /a blurred cyclone/i, # cyclone
      /lash out in a strike/i, # dizzyingswing
      /You take quick assessment/i, # pindown
      /pulverize your foes/i, # pulverize
      /You raise your hands high/i, # twinhammer
      /filling the sky with a volley of deadly projectiles/i, # volley
      /With a broad flourish/i, # wblade
      /Twisting and spinning/i, # whirlwind
      /would be a rather awkward proposition/i,
      /is out of reach/i,
      /You don't seem to be able to move your legs to do that/i,
      /too injured/i,
      /already dead/i,
      /little bit late/i,
      /could not find/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "charge"        => "Charge",
      "clash"         => "Clash",
      "cripple"       => "Cripple",
      "cyclone"       => "Cyclone",
      "dizzyingswing" => "Dizzying Swing",
      "pindown"       => "Pin Down",
      "pulverize"     => "Pulverize",
      "twinhammer"    => "Twin Hammerfists",
      "volley"        => "Volley",
      "wblade"        => "Whirling Blade",
      "whirlwind"     => "Whirlwind",
    }

    cmd_clean = cmd.split(' ').first
    return if !Weapon.available?(commands[cmd_clean])
    return unless Weapon.affordable?(commands[cmd_clean])
    return if npc.status =~ PRONE && commands[cmd] =~ /Charge|Twin Hammerfists/

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("weapon #{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_shields(npc, cmd)
    echo "cmd_shields - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /awkward proposition/i,
      /little bit late/i,
      /still stunned/i,
      /too injured/i,
      /what?/i,
      /You cannot/i,
      /Could not find/i,
      /seconds/i,
      /You snap your arm/i,
      /attempt a shield bash/i,
      /attempt a shield charge/i,
      /launch a quick bash/i,
      /diversionary shield bash/i,
      /charge headlong towards/i,
      /attempt to push/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "shield bash"    => "Shield Bash",
      "shield charge"  => "Shield Charge",
      "shield pin"     => "Shield Pin",
      "shield push"    => "Shield Push",
      "shield strike"  => "Shield Strike",
      "shield throw"   => "Shield Throw",
      "shield trample" => "Shield Trample",
    }

    # need to check if its the cman version or the shield version
    if cmd =~ /shield bash/ && CMan.available?("Shield Bash")
      return unless CMan.affordable?("Shield Bash")

      cmd = "cman sbash"
    else
      return if !Shield.available?(commands[cmd])
      return unless Shield.affordable?(commands[cmd])
    end

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("#{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_caststop(npc, spell, extra)
    echo "cmd_caststop - spell(#{spell}) - extra(#{extra})" if $bigshot_debug
    return if npc.status.match?(/dead|gone/)
    return unless GameObj.targets.any? { |s| s.id == npc.id }
    return unless Spell[spell].known? and Spell[spell].affordable?
    waitrt?
    waitcastrt?
    Spell[spell].force_cast("##{npc.id}", "#{extra}")
    fput "stop #{spell}"
  end

  def cmd_unravel(cmd, npc)
    echo("cmd_unravel") if $bigshot_debug

    return if npc.status.match?(/dead|gone/)
    return unless GameObj.targets.any? { |s| s.id == npc.id }
    return unless Spell[1013].known? && Spell[1013].affordable?

    cast_results = Regexp.union(
      /You are already singing that spellsong\./,
      /The evanescent shield shrouding .* flares to life and absorbs the essence of the spell, dissipating it harmlessly\./,
      /You feel your song resonate around the .*, pulling at the threads of mana within\./,
      /The silvery tendril continues to wend its way away from the /,
      /You gain \d+ mana!/,
      /You feel your song echo around the .* as if it had entered a vast empty chamber\./,
      /The serpentine thread stretching between you and the (.*) fades, then disappears\./,
      /Your concentration on unravelling the threads of mana is broken\./,
    )

    loop do
      waitrt?
      waitcastrt?
      result = Spell[1013].force_cast("##{npc.id}", "#{cmd || ''}", cast_results)
      case result
      when /You are already singing that spellsong\./
        fput('stop 1013')
      when /You feel your song resonate around the .*, pulling at the threads of mana within\.|You gain \d+ mana!/
        waitrt?
        waitcastrt?
        fput("renew 1013 ##{npc.id}") if cmd.empty? && percentmana < 100
        waitrt?
        fput('stop 1013')
        break
      when /The silvery tendril continues to wend its way away from the .*\./
        fput('stop 1013')
      when /Your concentration on unravelling the threads of mana is broken\.|You feel your song echo around the .* as if it had entered a vast empty chamber\./
        break
      end
    end
  end

  def cmd_cmans(npc, cmd)
    echo "cmd_cmans - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|You cannot|Could not find|seconds/i,
      /attempt a shield bash/i,
      /release your grip/i,
      /feat of strength empowers/i,
      /your grasp/i,
      /leaving you flailing/i,
      /completely miss/i,
      /unable to complete/i,
      /dip your shoulder and rush/i,
      /intending to finish/i,
      /isn't injured enough/i,
      /thwarts your attempt/i,
      /You approach/i,
      /You maneuver in close/i,
      /try to maneuver/i,
      /can't manage to do that right now/i,
      /rooted in place/i,
      /foot and let it fly/i,
      /clump of dust/i,
      /blur of steel in your eagerness/i,
      /slows to a trickle and finally stops/i,
      /You let out a shrill yell and leap, spinning through the air/i,
      /is not bleeding/i,
      /You feint/i,
      /deliver a kick/i,
      /out of reach/i,
      /try to hamstring/i,
      /roundhouse punch/i,
      /attempt to headbutt/i,
      /leap into the air/i,
      /low enough for you to attack/i,
      /isn't flying/i,
      /with all(?: of)? your might/i,
      /with staggering might/i,
      /concentrate on the magical wards/i,
      /anti-magical equipment/i,
      /spinning leap towards/i,
      /split it asunder/i,
      /holding a shield/i,
      /You hurl yourself/i,
      /jerk the weapon sharply sideways/i,
      /will strike true/i,
      /vaulting kick/i,
      /is lying down/i,
      /concentrate on the magic/i,
      /anti-magical equipment/i,
      /summon your inner ki and focus it/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "bullrush"     => "Bull Rush",
      "coupdegrace"  => "Coup de Grace",
      "cpress"       => "Crowd Press",
      "dirtkick"     => "Dirtkick",
      "exsanguinate" => "Exsanguinate",
      "feint"        => "Feint",
      "gkick"        => "Groin Kick",
      "hamstring"    => "Hamstring",
      "haymaker"     => "Haymaker",
      "headbutt"     => "Headbutt",
      "kifocus"      => "Ki Focus",
      "leapattack"   => "Leap Attack",
      "mblow"        => "Mighty Blow",
      "sattack"      => "Spin Attack",
      "sbash"        => "Shield Bash",
      "sblow"        => "Staggering Blow",
      "scleave"      => "Spell Cleave",
      "sthieve"      => "Spell Thieve",
      "sunder"       => "Sunder Shield",
      "tackle"       => "Tackle",
      "trip"         => "Trip",
      "truestrike"   => "True Strike",
      "vaultkick"    => "Vault Kick",
    }

    cmd_clean = cmd.split(' ').first
    return if !CMan.available?(commands[cmd_clean])
    return unless CMan.affordable?(commands[cmd_clean])
    return if npc.status =~ PRONE && cmd =~ /^bullrush/i
    return if Effects::Cooldowns.active?("Spell Cleave") && cmd =~ /^scleave/i
    return if Effects::Cooldowns.active?("Spell Thieve") && cmd =~ /^sthieve/i

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("cman #{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_bearhug(npc, cmd)
    echo "cmd_bearhug - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /You release your grip/i,
      /You feel a fair amount stronger./i,
      /avoids your grasp/i,
      /fend off your grasp/i,
      /leaving you flailing/i,
      /Your concentration lapses/i,
      /You don't seem to be able to move your legs to do that/i,
      /too injured/i,
      /already dead/i,
      /little bit late/i,
      /could not find/i,
      /but you stumble and completely miss/i,
      /is out of reach/i,
      /You cannot bearhug/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "bearhug" => "Bearhug"
    }

    cmd_clean = cmd.split(' ').first
    return if !CMan.available?(commands[cmd_clean])
    return unless CMan.affordable?(commands[cmd_clean])

    waitrt?
    waitcastrt?

    break_out = Time.now() + 17 # Up to 5 rounds at 3 sec each plus a little
    loop {
      result = dothistimeout("cman #{cmd} ##{npc.id}", 16, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_rogue_cmans(npc, cmd)
    echo "cmd_rogue_cmans - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|You cannot|Could not find|seconds/i,
      /attempt to slit/i,
      /Try hiding first/i,
      /kicking up as much dirt/i,
      /you're already out of sight/i,
      /Try hiding first/i,
      /prepare your diversion/i,
      /poised to eviscerate/i,
      /finger at the eye/i,
      /attempting to footstomp/i,
      /fling your wire around/i,
      /damage to yourself/i,
      /down at the knee/i,
      /boldly accost/i,
      /won't fall for that again/i,
      /reach out and grab/i,
      /stand up first/i,
      /spring from hiding/i,
      /You swing/i,
      /crouch and sweep/i,
      /attempting a swiftkick/i,
      /swing the blunt end/i,
      /You chop/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "cutthroat"  => "Cutthroat",
      "divert"     => "Divert",
      "shroud"     => "Dust Shroud",
      "eviscerate" => "Eviscerate",
      "eyepoke"    => "Eyepoke",
      "footstomp"  => "Footstomp",
      "garrote"    => "Garrote",
      "kneebash"   => "Kneebash",
      "mug"        => "Mug",
      "nosetweak"  => "Nosetweak",
      "subdue"     => "Subdue",
      "spunch"     => "Sucker Punch",
      "sweep"      => "Sweep",
      "swiftkick"  => "Swiftkick",
      "templeshot" => "Templeshot",
      "throatchop" => "Throatchop",

    }

    cmd_clean = cmd.split(' ').first
    return if !CMan.available?(commands[cmd_clean])
    return unless CMan.affordable?(commands[cmd_clean])

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("cman #{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_warrior_shouts(npc, cmd)
    echo "cmd_warrior_shouts - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    cmd = cmd.downcase

    return if Effects::Debuffs.active?("Overexerted")
    return if cmd == "shout"  && checkstamina < 25
    return if cmd == "yowlp"  && checkstamina < 11
    return if cmd == "holler" && checkstamina < 31
    return if cmd == "bellow all" && checkstamina < 21
    return if cmd == "bellow" && checkstamina < 11
    return if cmd == "growl all" && checkstamina < 15
    return if cmd == "growl" && checkstamina < 8
    return if cmd == "cry all" && checkstamina < 31
    return if cmd == "cry" && checkstamina < 16

    result_regex = Regexp.union(
      /You let loose an echoing shout!/i,
      /You throw back your shoulders and let out a resounding yowlp!/i,
      /You throw back your head and let out a thundering holler!/i,
      /Your fighting spirit is bolstered!|round(time)?|seconds/i,
      /nerve-shattering bellow!/i,
      /round(time)?|seconds/i,
      /eerie, modulating cry/i,
      /You must be an active member/i,
    )

    waitrt?
    waitcastrt?

    if cmd.include?("all")
      result = dothistimeout("warcry #{cmd}", 2, result_regex)
    elsif cmd =~ /bellow|growl|cry/i
      result = dothistimeout("warcry #{cmd} ##{npc.id}", 2, result_regex)
    else
      result = dothistimeout("warcry #{cmd}", 2, result_regex)
    end

    if (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from #{cmd} routine: #{result}"
    end

    sleep(0.5)
  end

  def cmd_volnsmite(npc)
    echo "cmd_volnsmite" if $bigshot_debug
    while !$bigshot_smite_list.any? { |a| a.to_i == npc.id.to_i } && npc.status !~ /dead|gone/ && GameObj.targets.any? { |s| s.id == npc.id } && !should_flee? && (npc.type.split(',').any? { |a| a == "undead" } || npc.type.split(',').any? { |a| a == "noncorporeal" })
      res = dothistimeout "smite ##{npc.id}", 1, /^Roundtime|^What were you referring to\?$/
      if res =~ /^What were you referring to\?$/i
        break
      end

      sleep(1)
    end
  end

  def assess_followup
    follow_up_results = $_SERVERBUFFER_.dup.join("\n")
    follow_up_results = follow_up_results.split("\n").delete_if { |line| line.nil? or line.empty? or line =~ /^[\r\n\s\t]*$/ }
    follow_up_results = follow_up_results.find_all { |line| line =~ /UAF: -?\d+ vs UDF: -?\d+ = [\d\.]+(?: \(capped\))? \* MM: \d+ \+ d100: \d+ = (\d+)/ }
    if follow_up_results[-1] =~ /UAF: -?\d+ vs UDF: -?\d+ = [\d\.]+(?: \(capped\))? \* MM: \d+ \+ d100: \d+ = (\d+)/
      $bigshot_unarmed_followup = false if ($1.to_i > 100)
    end
  end

  def cmd_unarmed(command, npc, manualaim)
    echo "cmd_unarmed" if $bigshot_debug
    return if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }

    $bigshot_aim = -1 if manualaim != "" && $bigshot_aim == 0
    $mstrike_taken = false
    cmd_volnsmite(npc) if !$bigshot_smite_list.any? { |a| a.to_i == npc.id.to_i } && npc.type.split(',').any? { |a| a == "noncorporeal" } && $bigshot_unarmed_tier == 3 && Spell[9821].known? && @UAC_SMITE
    # 9005 - Mstrike recovery
    # 9699 - popped muscles

    # mstrike using Tier3 and auto-tierup
    if @TIER3 && !@UAC_MSTRIKE
      cmd("mstrike #{@TIER3}", npc)
      sleep(0.3)
    elsif !@UAC_MSTRIKE
      cmd("mstrike #{command}", npc)
      sleep(0.3)
    end

    if (!$mstrike_taken)
      if $bigshot_unarmed_tier == 3 && $bigshot_unarmed_followup == false # command =~ /jab/ &&
        if manualaim != ""
          cmd("#{@TIER3} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{@TIER3} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{@TIER3} ##{npc.id}", npc)
        end
      elsif $bigshot_unarmed_followup == true
        command = $bigshot_unarmed_followup_attack
        if manualaim != ""
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id}", npc)
        end
      else
        if manualaim != ""
          cmd("#{command} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{command} ##{npc.id}", npc)
        end
      end
    end
    timeNow = Time.now + 5
    while (line = get)
      if line =~ /You have (decent|good|excellent) positioning/
        tier = $1
        if tier =~ /decent/
          $bigshot_unarmed_tier = 1
        elsif tier =~ /good/
          $bigshot_unarmed_tier = 2
        elsif tier =~ /excellent/
          $bigshot_unarmed_tier = 3
        end
      elsif line =~ /.* = .* d100: .* = \-?(\d+)$/ && $bigshot_unarmed_followup == true
        endroll = $1
        if endroll.to_i > 100
          $bigshot_unarmed_followup = false
        end
      elsif line =~ /Strike leaves foe vulnerable to a followup (.*) attack!/
        $bigshot_unarmed_followup = true
        $bigshot_unarmed_followup_attack = $1
      elsif line =~ /You fail to find an opening for your strike\./
        $bigshot_aim += 1
      elsif line =~ /You cannot aim that high!|is already missing that!/
        $bigshot_aim += 1
        cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
      elsif line =~ /does not have/
        $bigshot_aim += 1
        cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
      elsif line =~ /Roundtime:/i
        $bigshot_aim = 0
        break
      elsif line =~ /^Try standing up first\.$|[wW]ait \d+ sec.*|Sorry,|You can't do that while entangled in a web|You are still stunned|from here\.  Perhaps you should try throwing or shooting something at it\./
        break
      elsif line =~ /You don't seem to be able to move to do that\./
        sleep(2)
        break
      elsif line =~ /You are unable to muster the will to attack anything\.|Your rage causes you to use all of your skill in an all out attack!/
        Spell[1201].cast if Spell[1201].known? && Spell[1201].affordable?
        break
      elsif npc.status =~ /dead|gone/ || !(GameObj.targets.any? { |s| s.id == npc.id }) || should_flee? || should_rest? || line =~ /You currently have no valid target\.  You will need to specify one\.|^It looks like somebody already did the job for you\.$|What were you referring to/
        $bigshot_unarmed_tier = 1
        $bigshot_unarmed_followup = false
        $bigshot_unarmed_followup_attack = ""
        break
      elsif timeNow < Time.now
        break
      end
    end
    $mstrike_taken = false
  end

  def cmd_bless()
    echo "cmd_bless" if $bigshot_debug
    while $bigshot_bless.count > 0
      if Spell[1604].known? && Spell[1604].affordable?
        waitrt?
        waitcastrt?
        next if Spell[1604].cast("##{$bigshot_bless[$bigshot_bless.count - 1]}", /A violet tongue of flame enfolds the/) =~ /A violet tongue of flame enfolds the/
      end
      if Spell[304].known? && Spell[304].affordable?
        waitrt?
        waitcastrt?
        Spell[304].cast("##{$bigshot_bless[$bigshot_bless.count - 1]}")
        $bigshot_bless.delete($bigshot_bless[$bigshot_bless.count - 1])
      elsif Spell[9802].known?
        waitrt?
        waitcastrt?
        fput "symbol bless ##{$bigshot_bless[$bigshot_bless.count - 1]}"
        $bigshot_bless.delete($bigshot_bless[$bigshot_bless.count - 1])
      else
        $bigshot_should_rest = true
        $rest_reason = "No blessing on weapon"
        $bigshot_bless = []
        return
      end
    end
  end

  def cmd_assume(aspect, extra)
    echo "cmd_assume(#{aspect}, #{extra})" if $bigshot_debug
    return unless Spell[650].known?
    return if Spell["Aspect of the #{aspect.capitalize()} Cooldown"].active? && Spell["Aspect of the #{extra.capitalize()} Cooldown"].active?

    unless aspect =~ /^(?:jackal|wolf|lion|panther|hawk|owl|porcupine|rat|bear|burgee|mantis|serpent|spider|yierka)$/i
      message("yellow", "cmd_assume requires a proper aspect to assume. You used #{aspect}. They are:")
      message("yellow", "jackal, wolf, lion, panther, hawk, owl, porcupine, rat, bear, burgee, mantis, serpent, spider, yierka")
      message("yellow", "Please use the following for a command: assume <aspect1> <aspect2/evoke>")
      message("yellow", "Please use the following for society box: 650 <aspect1> <aspect2/evoke>")
      return
    end
    unless extra =~ /^(?:jackal|wolf|lion|panther|hawk|owl|porcupine|rat|bear|burgee|mantis|serpent|spider|yierka|evoke)$/i
      message("yellow", "Assume command requires to be given either two aspects or aspect + evoke")
      message("yellow", "Example:")
      message("yellow", "   Command - assume lion wolf")
      message("yellow", "   Command - assume lion evoke")
      message("yellow", "   Society - 650 lion wolf")
      message("yellow", "   Society - 650 lion evoke")
      message("yellow", "Due to improper above structure, wasting half of Assume Aspect ability")
    end

    unless Effects::Buffs.active?("Aspect of the #{aspect.capitalize()}") || Effects::Buffs.active?("Aspect of the #{extra.capitalize()}")

      if (checkprep != "None" and checkprep != "Assume Aspect")
        fput 'release'
      end

      waitrt?
      waitcastrt?
      first_aspect = false

      # Let's prep 650 if it's not already active
      unless Effects::Buffs.active?("Assume Aspect") || Effects::Buffs.active?("650") || checkprep == "Assume Aspect"
        Spell[650].force_evoke if ((extra =~ /evoke/i) && Spell[650].affordable?)
        waitcastrt?
        fput("prep 650") if ((extra !~ /evoke/i) && Spell[650].affordable?)
        first_aspect = true
      end
      return unless checkprep == "Assume Aspect" || Effects::Buffs.active?("Assume Aspect") || Effects::Buffs.active?("650")

      ttl = Time.now + 1
      if (!Spell["Aspect of the #{aspect.capitalize()} Cooldown"].active? && ((first_aspect == true) || (checkmana >= 25)))
        dothistimeout("assume #{aspect}", 1, /^You concentrate your focus upon the Aspect|^You feel that you will not be able to fully concentrate upon the Aspect/i)
        wait_while { !Effects::Buffs.active?("Aspect of the #{aspect.capitalize()}") and Time.now < ttl }
        # first_aspect = false # useless assignment Rubocop
      elsif (!Spell["Aspect of the #{extra.capitalize()} Cooldown"].active? && ((first_aspect == true) || (checkmana >= 25)))
        return if extra =~ /evoke/i
        dothistimeout("assume #{extra}", 1, /^You concentrate your focus upon the Aspect|^You feel that you will not be able to fully concentrate upon the Aspect/i)
        wait_while { !Effects::Buffs.active?("Aspect of the #{extra.capitalize()}") and Time.now < ttl }
        # first_aspect = false # useless assignment Rubocop
      elsif checkprep == "Assume Aspect"
        fput("cast") if Spell[650].affordable?
      end
    end
  end

  def cmd_briar(weapon)
    echo("cmd_briar(weapon:#{weapon.inspect})") if $bigshot_debug
    return if (weapon.nil? || Spell[9105].active?)
    briar_weapons = []
    briar_weapons.push(GameObj.right_hand) if GameObj.right_hand.to_s == weapon
    briar_weapons.push(GameObj.left_hand) if GameObj.left_hand.to_s == weapon
    GameObj.inv.each { |item|
      briar_weapons.push(item) if item.noun == weapon
    }
    return if briar_weapons.empty?

    briar_weapons.each { |briar_weapon|
      ready = false
      silence_me unless (undo_silence = silence_me)
      res = Lich::Util.quiet_command_xml("measure ##{briar_weapon.id}", /^You gaze intently|^Now, why are you trying to measure/, /<prompt time=/)
      if res.any? { |line| line =~ /to be about (\d+) percent\./i }
        ready = true if $1.to_i == 100
        sleep(0.2)
      end
      silence_me if undo_silence
      fput "raise ##{briar_weapon.id}" if ready == true
    }
  end

  def cmd_throw(npc)
    echo "cmd_throw" if $bigshot_debug
    unless npc.status == 'lying down'
      empty_hands
      dothistimeout "throw ##{npc.id}", 1, /^You attempt to throw a .*\!$/
      waitrt?
      fill_hands
    end
  end

  def cmd_force(force_this, goal, npc)
    echo "cmd_force: force_this: #{force_this} | goal: #{goal} | npc: #{npc}" if $bigshot_debug
    result_regex = Regexp.union(
      /== \+(\d+)/,
      /^\[(?:Roll|SMR|SSR) result: (\d+)/,
    )

    failure_regex = Regexp.union(
      /^As you focus on your magic, your vision swims with a swirling haze of crimson/,
      /^You do not have enough stamina to attempt this maneuver\./,
      /^(?:.*) is lying down -- attempting to (?:.*) would be a rather awkward proposition\./,
      /^Your magic fizzles ineffectually\./,
      /^You are (?:still )?stunned\./,
    )

    start = Time.now
    loop do
      return if cmd(force_this, npc) == false

      sleep(0.1)
      buffer = reget(35)

      buffer.each_with_index do |line, i|
        return false if line =~ failure_regex || muckled?

        if line =~ /^You.*(#{checknpcs.join('|')})|^You feint (high|low|(to the (left|right)))/
          if buffer[i - 2..i + 3].any? { |l| l =~ result_regex }
            captures = $~.captures.compact
            capture = captures.first # prioritize the first capture
            return true if capture.to_i >= goal # spell/swing/cman
          end
        end
      end

      if (force_this =~ /^(\d+) / && !Spell[$1.to_i].affordable?)
        message("yellow", "Force ran out of mana. Giving up."); return;
      end
      return if GameObj.targets.size.nil? || gameobj_npc_check() == 0
      return if should_flee?
      return if should_rest?
      return if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }
      return if (Time.now - start) > 30
    end
  end

  def cmd_weed(command, target)
    echo "cmd_weed" if $bigshot_debug

    return if target.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == target.id }
    return if GameObj.loot.find { |loot| loot.name =~ /\b(?:vine|bramble|widgeonweed|vathor club|swallowwort|smilax|creeper|briar|ivy|tumbleweed)\b/ }
    return unless Spell[610].known? and Spell[610].affordable?

    waitcastrt?
    if command =~ /kweed/
      Spell[610].force_evoke("##{target.id}")
    else
      Spell[610].cast("##{target.id}")
    end
    waitcastrt?
  end

  def spell_is_selfcast?(spell_id) # used in cmd_spell
    [
      106, 109, 115, 117, 120, 130, 140,
      205, 206, 211, 213, 215, 218, 219, 220, 240,
      303, 307, 310, 313, 314, 319, 350,
      401, 402, 403, 404, 405, 406, 414, 418, 419, 425, 430,
      503, 506, 507, 508, 509, 511, 513, 515, 517, 520, 535, 540,
      601, 602, 604, 605, 606, 608, 612, 613, 617, 618, 620, 625, 630, 640, 650,
      707, 712,
      905, 911, 913, 916, 919,
      1003, 1006, 1007, 1009, 1010, 1011, 1012, 1014, 1017, 1018, 1019, 1020, 1025, 1035, 1040,
      1109, 1119, 1125, 1130, 1150,
      1202, 1204, 1208, 1213, 1214, 1215, 1216, 1220, 1235,
      1601, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1616, 1617, 1618, 1619, 1635
    ].include?(spell_id)
  end

  def cmd_spell(incant = nil, id, extra, target)
    echo "cmd_spell" if $bigshot_debug
    selfcast = spell_is_selfcast?(id)

    if (checkprep != "None" and checkprep != Spell[id].name)
      fput 'release'
    end

    return if id == 506 and Spell[506].active?
    return if id == 9605 and Effects::Cooldowns.active?("Surge of Strength") # surge cooldown
    return if id == 9625 and Effects::Cooldowns.active?("Burst of Swiftness") # burst cooldown
    return if id == 335 and Effects::Cooldowns.active?(335) # Divine Wrath cooldown
    return if id == 608 and hiding?
    return if id == 703 and $bigshot_703_list.any? { |s| s == target.id }
    return if id == 1614 and $bigshot_1614_list.any? { |s| s == target.id }
    return if target.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == target.id }

    unless (Spell[id].affordable?)
      if (@WAND_IF_OOM)
        cmd_wand(target); return;
      end
      if (@USE_WRACKING)
        wrack()
      end
    end

    if (!Spell[id].affordable? and id != 9605 and id != 506)
      $bigshot_should_rest = true
      $rest_reason = "out of mana"
    end
    return if !Spell[id].affordable?

    waitrt?
    waitcastrt?

    if incant.nil?
      if selfcast
        Spell[id].cast(Char.name)
      else
        Spell[id].cast("##{target.id}")
      end
    else
      if selfcast
        bs_put "target clear"
      end

      change_stance('offensive') if Spell[id].stance || (id.to_s =~ /1700/i && extra =~ /evoke/i)
      Spell[id].force_incant(extra) # bs_put "incant #{id} #{extra}"
      change_stance(@HUNTING_STANCE)

      if selfcast
        bs_put "target ##{target.id}"
      end
    end
  end

  def cmd_wand(target)
    echo "cmd_wand | target: #{target}" if $bigshot_debug
    if (@FRESH_WAND_CONTAINER)
      # hands = GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s
      until ((GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s) =~ /#{@WAND[$bigshot_wand].split(' ').join('.*?')}/i)
        result = dothistimeout("get #{@WAND[$bigshot_wand]} from my #{@FRESH_WAND_CONTAINER}", 3, /You remove|You slip|Get what/)
        if (result =~ /Get what/)
          $bigshot_wand += 1
          if @WAND[$bigshot_wand].nil?
            message("yellow", "ERROR: Couldn't find fresh wand. Gonna rest."); $bigshot_should_rest = true; return;
          end
        elsif (result.nil?)
          message("yellow", "ERROR: Timed out looking for wand."); return;
        end
      end

      change_stance('offensive')
      result = get_res("wave my #{@WAND[$bigshot_wand]} at ##{target.id}", /d100|You hurl|is already dead|You do not see that here|You are in no condition|I could not find/)
      change_stance(@HUNTING_STANCE)

      if (result =~ /You are in no condition/)
        message("yellow", "ERROR: Wounded. Gonna rest."); $bigshot_should_rest = true; return;
      elsif (result.nil?)
        if (@DEAD_WAND_CONTAINER)
          bs_put "put my #{@WAND[$bigshot_wand]} in my #{@DEAD_WAND_CONTAINER}"
        else
          bs_put "drop my #{@WAND[$bigshot_wand]}"
        end
      end
    else
      message("yellow", "ERROR: Wand command called but fresh wand container not defined.")
    end
  end

  def cmd_stomp()
    echo "cmd_stomp" if $bigshot_debug
    return if !Spell[909].known?

    waitrt?
    waitcastrt?
    if Spell[909].active?
      fput "stomp" if checkmana(5)
    elsif Spell["909"].affordable?
      Spell["909"].force_channel
      waitcastrt?
      fput "stomp" if checkmana(5)
    end
  end

  def cmd_leech()
    echo "cmd_leech" if $bigshot_debug
    return if !Spell[516].known?

    if (Effects::Cooldowns.time_left("Mana Leech") < 15) && (Spell[516].affordable?)
      waitrt?
      waitcastrt?
      Spell[516].cast
    end
  end

  def cmd_efury(npc, extra)
    echo "cmd_efury - npc: #{npc}" if $bigshot_debug
    return if npc.status =~ /dead|gone/
    return unless GameObj.targets.any? { |s| s.id == npc.id }
    return unless Spell[917].known? and Spell[917].affordable?

    waitrt?
    waitcastrt?
    time_out = Time.now + 12
    Spell[917].force_incant("#{extra}")

    loop {
      line = get?
      break if Time.now > time_out
      break if should_flee?
      break if npc.status =~ /dead|gone/
      break unless GameObj.targets.any? { |s| s.id == npc.id }
      break if line =~ /The (?:floor|ground) beneath .* suddenly calms\./
      break if line =~ /The evanescent shield shrouding .* flares to life and absorbs the essence of the spell, dissipating it harmlessly\./
      stand unless standing?
      sleep(0.01)
    }
  end

  def cmd_hide(attempts)
    echo "cmd_hide" if $bigshot_debug
    tries = 0
    attempts = 3 if attempts == 0
    until (hiding?)
      break if tries > attempts || should_flee?

      change_stance('defensive')
      fput "hide"
      tries += 1
    end
  end

  def mstrike_spell_check()
    echo "mstrike_spell_check" if $bigshot_debug
    # Rejuvenation
    if (Spell[1607].known? && !Spell[1607].active? && Spell[1607].affordable? && (checkstamina < (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
      if ((checkstamina + (15 + (bonus = 0; [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190].each { |n| bonus += 1 if Skills.slblessings >= n }; bonus * 3))) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE))
        waitcastrt?
        Spell[1607].cast
      end
    end
    # Adrenal Surge
    if (Spell[1107].known? && Spell[1107].affordable? && !Spell[9010].active? && (Time.now >= $bigshot_adrenal_surge))
      if (Spell[9699].active? || ((maxstamina if Skills.slblessings >= 65) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      elsif (Spell[9699].active? || ((checkstamina + (Skills.slblessings >= 35 ? 50 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      elsif (Spell[9699].active? || ((checkstamina + (Skills.slblessings >= 35 ? 25 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      end
    end
  end

  def cmd_mstrike(command, target)
    echo "cmd_mstrike" if $bigshot_debug
    mstrike_spell_check() if Stats.prof =~ /Paladin|Empath/i
    # Mstrike checks
    if Effects::Debuffs.active?("Overexerted") # TODO PoPped muscle check updates
      $mstrike_taken = false
      return
    end
    if Skills.multiopponentcombat >= 30 && GameObj.targets.all? { |i| i.noun !~ /nest/i }
      if (!Effects::Cooldowns.active?("Multi-Strike") || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
        if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Effects::Debuffs.active?("Overexerted")
          if (gameobj_npc_check() >= @MSTRIKE_MOB || target.nil?)
            bs_put "quickstrike 1 #{command}"
          else
            bs_put "quickstrike 1 #{command} ##{target.id}"
          end
        else
          if (gameobj_npc_check() >= @MSTRIKE_MOB || target.nil?)
            bs_put "#{command}"
          else
            bs_put "#{command} ##{target.id}"
          end
        end
        $mstrike_taken = true
      end
    elsif Skills.multiopponentcombat >= 5 && GameObj.targets.all? { |i| i.noun !~ /nest/i } && gameobj_npc_check() >= @MSTRIKE_MOB
      if (!Effects::Cooldowns.active?("Multi-Strike") || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
        if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Effects::Debuffs.active?("Overexerted")
          bs_put "quickstrike 1 #{command}"
        else
          bs_put "#{command}"
        end
        $mstrike_taken = true
      end
    end
  end

  def check_target_vitals(command, target, ranged = false)
    # General logic for this taken from ;fire by Oweodry
    fput "look ##{target.id}"
    loc = (ranged) ? $bigshot_archery_aim : $bigshot_ambush
    woundinfo = matchtimeout(1, /(he|she|it) has .*|I could not find/i).to_s
    if (command[loc] == "head" && woundinfo =~ /severe head trauma and bleeding from .* ears/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "neck" && woundinfo =~ /snapped bones and serious bleeding from .* neck/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "left eye" && woundinfo =~ /blinded left eye/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "right eye" && woundinfo =~ /blinded right eye/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    end
  end

  def cmd_1040(target)
    echo "cmd_1040 #{target}" if $bigshot_debug
    return if !Spell[1040].known?

    waitrt?
    waitcastrt?
    fput 'mana pulse' if !Spell[1040].affordable?
    if target != Char.name
      Spell[1040].cast if Spell[1040].affordable?
    elsif target == Char.name
      until !webbed? && !sleeping? && !stunned? && !frozen?
        Spell[1040].cast if Spell[1040].affordable?
        fput 'mana pulse' if !Spell[1040].affordable?
        waitcastrt?
      end
    end
  end

  def cmd_dhurl()
    echo "cmd_dhurl" if $bigshot_debug
    waitrt?
    waitcastrt?
    res = dothistimeout "hurl", 1, Regexp.union(
      /^Roundtime/,
      /^What were you referring to\?$/,
      /^You throw/,
      /^You take aim and throw/,
      /That's not going to do much.  Try using a weapon/,
      /You find nothing recoverable/
    )
    if res =~ /You take aim and throw|You throw/
      weapon_hurled_room = Room.current.id
      hold = 6 - checkrt.to_f
      hold = 0 if hold.to_f <= 0
      waitrt?
      sleep(hold)
      Script.run("go2", weapon_hurled_room)
      cmd_recover()
    elsif res =~ /That's not going to do much.  Try using a weapon|You find nothing recoverable/
      Script.run("go2", weapon_hurled_room)
      cmd_recover()
      return
    end
  end

  def cmd_recover(weapon_lost = true)
    echo "cmd_recover" if $bigshot_debug
    until weapon_lost == false
      break if $bigshot_bond_return == true

      waitrt?
      res = dothistimeout "recover hurl", 1, Regexp.union(
        /You know (.*) is around here somewhere, but you don't see it./,
        /You spy a (.*) and recover it/,
        /A (.*) rises out of the shadows and flies back to your waiting hand!/,
        /In order to recover your hurled weapon, you'll need to have a free hand./,
        /You find nothing recoverable./,
      )
      if res =~ /You know (.*) is around here somewhere, but you don't see it./
        sleep(0.5)
      elsif res =~ /You spy a (.*) and recover it|(.*) rises out of the shadows and flies back to your waiting hand!/
        weapon_lost = false
      elsif res =~ /In order to recover your hurled weapon, you'll need to have a free hand.|You find nothing recoverable./
        weapon_lost = false
      end
    end
  end

  def cmd_ranged(npc)
    echo "cmd_ranged" if $bigshot_debug
    if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }
      $bigshot_archery_aim = 0
      $bigshot_archery_stuck_location = []
      return
    end
    if !@ARCHERY_AIM[$bigshot_archery_aim].nil?
      if $bigshot_archery_stuck_location.any? { |s| s =~ /#{$bigshot_archery_location}/i }
        $bigshot_archery_aim += 1
      end
      if (@ARCHERY_AIM[$bigshot_archery_aim] == "head" || @ARCHERY_AIM[$bigshot_archery_aim] == "neck" || @ARCHERY_AIM[$bigshot_archery_aim] == "left eye" || @ARCHERY_AIM[$bigshot_archery_aim] == "right eye")
        check_target_vitals(@ARCHERY_AIM, npc, true)
      end
      if $bigshot_archery_aim > @ARCHERY_AIM.length
        $bigshot_archery_aim = 0
        $bigshot_archery_stuck_location = []
      end

      if @ARCHERY_AIM[$bigshot_archery_aim] !~ /#{$bigshot_archery_location}/i || $bigshot_archery_location.nil?
        fput "aim #{@ARCHERY_AIM[$bigshot_archery_aim]}"
      end
    end

    waitrt?
    waitcastrt?

    result = dothistimeout("fire ##{npc.id}", 2, /round(time)?|You cannot|Could not find|seconds|Get what?/i)
    if (result =~ /^Could not find/)
      # gather_ammo()#Not used since archery updates.
    elsif (result =~ /You cannot fire/)
      unless GameObj.right_hand.id.nil?
        line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
      end
    elsif (result =~ /but it has no effect/)
      $bigshot_should_rest = true
      $rest_reason = "Ammo had no effect (need blessed or magical)"
    elsif (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from fire routine: #{result}"
    elsif result =~ /round(time)?/i
      $bigshot_archery_aim = 0
      $bigshot_archery_stuck_location = []
    end
  end

  def cmd_dislodge(npc, location)
    echo "cmd_dislodge #{npc} #{location}" if $bigshot_debug
    return if !CMan.available?("Dislodge")
    return if npc.id != $bigshot_dislodge_target

    target = nil
    location = location.split(/ /, 9) # [bigshot: ["eye", "head", "neck", "chest", "back", "abdomen", "arm", "leg", "hand"]]
    location.each { |loc|
      if $bigshot_dislodge_location.include?(loc)
        target = loc
        break
      end
    }
    return if target.nil?

    waitrt?
    waitcastrt?
    result = dothistimeout("cman dislodge ##{npc.id} #{target}", 2, /attempting to dislodge|suitable weapons lodged|You can't reach|awkward proposition|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
    if (result =~ /You manage to dislodge|You skillfully wrench/ && npc.status =~ /dead|gone/)
      $bigshot_dislodge_location = []
      $bigshot_dislodge_target = nil
    elsif (result =~ /You manage to dislodge|You skillfully wrench/)
      $bigshot_dislodge_location.delete(target)
      target = nil
    elsif (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from dislodge routine: #{result}"
    end
  end

  def cmd_burst()
    echo "cmd_burst" if $bigshot_debug
    return if !CMan.known?("Burst of Swiftness")
    return if Effects::Buffs.to_h.keys.grep(/Enh. Dexterity/).length.positive?

    burst_regex = /^You feel (?:significantly|a great deal|a fair amount) more (?:agile|dextrous)\.$|^Your muscles ache much too badly to even think about attempting this maneuver\.$/
    rt_regex = /(?:Roundtime:|Wait|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i
    cmd_regex = Regexp.union(burst_regex, rt_regex)

    if (checkstamina >= 30 && !Effects::Cooldowns.active?("Burst of Swiftness")) || (checkstamina >= 60 && Effects::Cooldowns.active?("Burst of Swiftness"))
      loop do
        waitrt?
        waitcastrt?
        result = dothistimeout("cman burst", 1, cmd_regex)
        break unless result =~ rt_regex
      end
    end
  end

  def cmd_surge()
    echo "cmd_surge" if $bigshot_debug
    return if !CMan.known?("Surge of Strength")
    return if (Effects::Buffs.active?("Enh. Strength (+32)") || Effects::Buffs.active?("Enh. Strength (+28)") || Effects::Buffs.active?("Enh. Strength (+24)") || Effects::Buffs.active?("Enh. Strength (+20)") || Effects::Buffs.active?("Enh. Strength (+16)"))

    waitrt?
    waitcastrt?
    if (checkstamina >= 30 && !Effects::Cooldowns.active?("Surge of Strength"))
      result = dothistimeout("cman surge", 1, /You feel a great deal stronger.|untapped sources of strength|still recent prior attempt|come from your muscles|ache much too badly/i)
      if (result == false)
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from surge routine: #{result}"
      end
    elsif (checkstamina >= 60 && Effects::Cooldowns.active?("Surge of Strength"))
      result = dothistimeout("cman surge", 1, /You feel a great deal stronger.|untapped sources of strength|still recent prior attempt|come from your muscles|ache much too badly/i)
      if (result == false)
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from surge routine: #{result}"
      end
    end
  end

  def cmd_berserk()
    echo "cmd_berserk" if $bigshot_debug
    if (checkstamina(20))
      change_stance('defensive')
      Spell[9607].cast
      pause 5
      wait_until { !Spell[9607].active? }
    else
      bs_put 'target random'; bs_put 'kill';
    end
  end

  def cmd_run_script(name, args)
    echo "cmd_run_script" if $bigshot_debug
    if (args == nil || args =~ /^\s*$/)
      run_script(name, true)
    else
      args = args.split(/ /)
      run_script(name, true, args)
    end
  end

  def cmd_sleep(time, npc)
    echo "cmd_sleep" if $bigshot_debug
    change_stance('defensive')
    time.to_i.times do
      sleep(1)
      break if should_rest?
      break if npc && npc.status =~ /dead|gone/
    end
  end

  def cmd_ambush(command, target)
    echo "cmd_ambush" if $bigshot_debug
    if target.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == target.id }
      $bigshot_ambush = 0
      return
    end
    command = ["head", "right leg", "left leg", "chest"] if (command == "" || command.nil?) && @AMBUSH == []
    command = @AMBUSH if (command == "" || command == [] || command.nil?) && @AMBUSH != []
    command = [command] if command.class == String
    if ($bigshot_ambush >= command.length())
      # If you have gotten here, there is nothing left to target on your list.
      $bigshot_ambush = 0
      command = ["chest"]
    end
    if (command[$bigshot_ambush] == "head" || command[$bigshot_ambush] == "neck" || command[$bigshot_ambush] == "left eye" || command[$bigshot_ambush] == "right eye")
      check_target_vitals(command, target)
    end
    waitrt?
    ambush_or_attack = (hidden?) ? "ambush" : "attack"
    result = dothistimeout "#{ambush_or_attack} ##{target.id} #{command[$bigshot_ambush]}", 2, /round(time)?|You cannot aim that high!|does not have a head!|is already missing that!|does not have a .* leg!|does not have a .* arm!/i
    if result =~ /You cannot aim that high!|does not have a head!|is already missing that!|does not have a (?:right|left) leg!|does not have a (?:right|left) arm!/i
      $bigshot_ambush += 1
      cmd_ambush(nil, target)
    elsif result =~ /round(time)?/i
      $bigshot_ambush = 0
    end
  end

  def cmd_nudge_weapons()
    echo "cmd_nudge_weapons" if $bigshot_debug
    return if checkpaths.size == 0

    GameObj.loot.each { |i|
      next unless i.noun =~ /axe|scythe|pitchfork|falchion|sword|lance|sword|dagger|estoc|falchion|handaxe|katana|katar|gauche|rapier|scimitar|whip-blade|cudgel|crowbill|whip|mace|star|hammer|claidhmore|flail|flamberge|maul|pick|staff|mattock/

      change_stance('defensive')

      sheathed = false
      unless (righthand.nil? || lefthand.nil?)
        sheathed = true
        fput 'sheath'
        unless (righthand.nil? || lefthand.nil?)
          message("yellow", "Unable to empty hands via sheath.")
          break
        end
      end

      # dirs = checkpaths
      dir  = checkpaths.shift
      fput "get ##{i.id}"
      put dir
      put "drop ##{i.id}"
      fput reverse_direction(dir)
      fput "gird" if sheathed
    }
  end

  def group_status_ailments()
    echo "group_status_ailments" if $bigshot_debug
    if @TROUBADOURS_RALLY && Spell[1040].known?
      if webbed? || sleeping? || stunned? || frozen?
        cmd_1040(Char.name)
      end
      GameObj.pcs.each { |s|
        if s.status =~ /webbed|sleeping|stunned|frozen|immobilized|held in place|horrified|staggered/i && $grouplist.include?(s.noun)
          cmd_1040(s.noun)
          break
        end
      }
    end
  end

  def message(type = "info", text)
    # color options - set type to use
    # yellow, orange, teal, green, plain

    return if type == "debug" && !$bigshot_debug

    if text.class == Hash
      text = text.inspect.gsub("#<", "#")
    elsif text.class == Array
      text = text.to_s
    elsif text.class == String
      text = text.gsub("#<", "#")
    end

    Lich::Messaging.msg(type, text)
  end

  def dead_man_switch()
    echo "dead_man_switch" if $bigshot_debug
    if @DEAD_MAN_SWITCH && XMLData.game =~ /GSF/
      Thread.new {
        while (running?($current_script_name))
          if (dead? || percenthealth < 40)
            echo 'AUTOBOT ALERT: Your character is in trouble!'
            fput 'quit'
          end
          sleep(2)
        end
      };
    elsif @DEPART_SWITCH
      start_exec_script(<<-EOF
                while( running?($current_script_name) );
                    if(dead?);
                        stop_script($current_script_name);
                        fput 'depart'; fput 'depart';
                        fput 'depart confirm'; fput 'depart confirm';
                        start_script('waggle');
                        15.times { sleep(60); fput info; };
                        sleep(1) until percentspirit == 100 && !running?('waggle');
                        start_script( "#{$current_script_name}", ['solo'] );
                        Script.self.kill;
                    end;
                    sleep(5);
                end;
      EOF
                       );
    else
      Thread.new {
        loop { Script.self.kill if dead?; sleep(5); }
      }
    end
  end

  def keep_awake()
    echo "keep_awake" if $bigshot_debug
    Thread.new {
      while (running?($current_script_name))
        sleep(600); put 'look';
      end
    }
  end

  def monitor_interaction()
    echo "monitor_interaction" if $bigshot_debug
    if @MONITOR_INTERACTION
      start_exec_script(<<-eos
        watch_list = /#{@monitor_strings.gsub("||", "|")}/io
        safe_strings = /#{@monitor_safe_strings.gsub("||", "|")}/io

        def show_window(line)
          window_title = Char.name + ':' + line
          Gtk.queue do
            $myWindow = Gtk::Window.new
            $myWindow.title = "Autobot Alert!"
            $myWindow.set_size_request(450, 25)
            label = Gtk::Label.new window_title
            $myWindow.add(label)
            $myWindow.show_all
          end
        end

        while(line = get)
          break unless running?($current_script_name)
          if watch_list.match?(line) && !safe_strings.match?(line)
            show_window(line)
            echo "AUTOBOT ALERT: " + line
          end
        end
      eos
                       )
    end
  end

  def gameobj_npc_check()
    npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| (npc.name =~ /animated/ && npc.name !~ /animated slush/) }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /^(?:arm|appendage|claw|limb|pincer|tentacle)s?$|^(?:palpus|palpi)$/i }
    return npcs.size.to_i
  end

  def npc_room_check()
    Thread.new {
      loop {
        $current_room_npcs = GameObj.npcs
        pause 0.5
      }
    }
  end

  def wrack()
    echo "wrack" if $bigshot_debug
    if Spell[9918].known? && !Spell[9012].active? && checkspirit(@WRACKING_SPIRIT) && checkspirit(6 + [9912, 9913, 9914, 9916, 9916, 9916].count { |num| Spell[num].active? })
      Spell[9918].cast
    elsif Spell[9718].known?
      (checkstamina / 50).times { Spell[9718].cast }
    elsif Spell[9813].known? && !Effects::Cooldowns.active?("Symbol of Mana")
      Spell[9813].cast
    end
  end

  def cur_bounty()
    return bounty?
  end

  def set_bandit_hunting(kill_bandits)
    # Need to circumvent anti-poach and protections some to hunt bandits
    $bigshot_bandits = kill_bandits
  end

  def change_stance(new_stance, force = true)
    return if Spell[216].active? || dead?
    return unless checkroom('Ooze, Innards').nil?

    perfect_stance = nil
    if new_stance =~ /10|20|30|40|50|60|70|80|90|100/i
      perfect_stance = new_stance
      new_stance = "advance" if perfect_stance =~ /10|20/i
      new_stance = "forward" if perfect_stance =~ /30|40/i
      new_stance = "neutral" if perfect_stance =~ /50|60/i
      new_stance = "guarded" if perfect_stance =~ /70|80/i
      new_stance = "defensive" if perfect_stance =~ /90|100/i
    end
    if (stance() =~ /#{new_stance}/)
      return
    elsif (checkcastrt() > 0 && new_stance =~ /def/)
      return if stance() == 'guarded'
    end

    if ((force) && (perfect_stance != nil) && (CMan.known?("Stance Perfection")))
      dothistimeout("cman stance #{perfect_stance}", 3, /You are now in an?|You move into an?|You fall back into a|Cast Roundtime in effect|You are unable to change/)
    elsif (force)
      dothistimeout("stance #{new_stance}", 3, /You are now in an?|You move into an?|You fall back into a|Cast Roundtime in effect|You are unable to change/)
    else
      fput "stance #{new_stance}"
    end
  end

  def wait_for_swing(seconds, target = nil)
    echo "wait_for_swing" if $bigshot_debug
    start = Time.now
    # swung = false
    $stop_wait = false
    $global_target = target.id
    $pcs = checkpcs ? ' you(\.|!|r? )|' + checkpcs.join('|') : 'you(\.|!|r? )'

    wait_for_swing_exec = <<-eos
        status_tags
        while line = get
            $stop_wait = true if line =~ /#{$global_target}.*#{$pcs}|The thorny barrier surrounding you blocks the attack from the .*#{$global_target}/ and line !~ /style id="".*style id="roomDesc"|(?:component|compDef) id='room objs'/
            break if $stop_wait
            break if !running?($current_script_name)
        end
        status_tags
    eos

    ExecScript.start(wait_for_swing_exec, :quiet => true)

    loop do
      change_stance('defensive', false) unless target && target.status =~ PRONE
      stand() if !standing?
      break if $stop_wait
      break if GameObj.targets.size.nil? || gameobj_npc_check() == 0
      break if should_flee?
      break if target && target.status =~ PRONE
      break if (Time.now - start) > seconds

      sleep(0.25)
    end
  end

  def croak(message)
    echo "croak" if $bigshot_debug
    message("yellow", message);
    croak_scripts(["#{$current_script_name}"])
  end

  def run_script(name, pause_bigshot = false, args = [])
    echo "run_script" if $bigshot_debug
    if Script.running.find { |s| s.name.downcase == name.downcase }.paused or running? name
      stop_script name
      wait_while { running? name }
    end

    start_script name, args
    if pause_bigshot
      wait_until { !running? name }
    end
  end

  def run_scripts(scripts, pause_bigshot = false)
    echo "run_scripts" if $bigshot_debug
    scripts.each do |i|
      tokens = i.split(/\s+/)
      if (tokens.size > 1)
        run_script(tokens[0], pause_bigshot, tokens[1..-1])
      else
        run_script(tokens[0], pause_bigshot)
      end
    end
  end

  def croak_script(name)
    echo "croak_script" if $bigshot_debug
    # check for script name string with args
    name = name.split(/\s+/).first
    kill_script(name) if running?(name)
  end

  def croak_scripts(scripts)
    echo "croak_scripts" if $bigshot_debug
    scripts.each { |i| croak_script(i) }
  end

  def stand(stand_command = nil)
    echo "stand" if $bigshot_debug
    return if Array(stand_command).any? { |cmd| cmd =~ /^(?:fire|kneel|hide)/i } && kneeling? && checkleft =~ /^(?:arbalest|kut'ziko|crossbow|kut'zikokra)$/

    until (standing?)
      return unless checkroom('Ooze, Innards').nil?
      change_stance('defensive')
      bs_put 'stand'
    end
  end

  def groupcheck()
    lines = Lich::Util.quiet_command_xml('group', /You are (?:leading|grouped with) (.*)\.|You are not currently in a group/i)

    $grouplist = []
    if lines.any? { |l| l =~ /You are (?:leading|grouped with) (.*)\./i }
      $grouplist = Regexp.last_match(1).split(/,(?:\s+and)?| and /).map { |x| x.gsub(/who is \w+|\(\w+\)|<a exist="-\d+" noun="\w+">|<\/a>/, '').strip }
    end

    echo "groupcheck: #{$grouplist}" if $bigshot_debug
  end

  def ma_looter
    looter = nil

    if solo?
      looter = Char.name
    elsif @RANDOM_LOOT
      encumbrance_hash = @followers.group_encumbrance
      encumbrance_hash[Char.name] = (@ENCUMBERED - percentencumbrance) # Add the leader
      encumbrance_hash.reject! { |key, _value| @NEVER_LOOT.include?(key) } # Remove any character in the no-loot list

      # Find the max
      max_value = encumbrance_hash.values.max

      # Find all party members with the same amount
      all_max_values = encumbrance_hash.select { |_key, value| value == max_value }.keys

      if all_max_values.include?(@MA_LOOTER) # favor the designated looter
        looter = @MA_LOOTER
      else
        looter = all_max_values.sample # otherwise just pick one at random
      end
    elsif !@MA_LOOTER.to_s.empty?
      looter = @followers.get_names.find { |name| name =~ /#{@MA_LOOTER}/i }
    else
      looter_list = @followers.get_names.reject { |element| @NEVER_LOOT.include?(element) }
      if looter_list.include?(@followers.leader_name)
        looter = @followers.leader_name
      else
        looter = looter_list.sample
      end
    end

    return looter
  end

  def lead(my_group = nil)
    echo "lead" if $bigshot_debug
    monitor_interaction()
    companion_check()
    npc_room_check()
    @followers = my_group || Group.new()
    if !checkpcs.nil?
      groupcheck()
    end

    if (should_rest? && !$bigshot_quick)
      rest()
    else
      hunt()
    end
  end

  def find_routine(target)
    echo "find_routine" if $bigshot_debug
    echo "@DISABLE_COMMANDS.size = #{@DISABLE_COMMANDS.size}" if $bigshot_debug
    if (!solo? && fried? && @DISABLE_COMMANDS.size > 0)
      return @DISABLE_COMMANDS
    else
      key = @TARGETS.keys.find { |k| target.name =~ /^#{k}$/i or target.noun =~ /^#{k}$/i }
      if key.nil?
        routine_letter = 'a'
      else
        routine_letter = @TARGETS[key]
      end

      if routine_letter == 'quick' || ($bigshot_quick && key.nil?)
        return @QUICK_COMMANDS unless @QUICK_COMMANDS.size == 0
      elsif routine_letter == 'j'
        return @HUNTING_COMMANDS_J unless @HUNTING_COMMANDS_J.size == 0
      elsif routine_letter == 'i'
        return @HUNTING_COMMANDS_I unless @HUNTING_COMMANDS_I.size == 0
      elsif routine_letter == 'h'
        return @HUNTING_COMMANDS_H unless @HUNTING_COMMANDS_H.size == 0
      elsif routine_letter == 'g'
        return @HUNTING_COMMANDS_G unless @HUNTING_COMMANDS_G.size == 0
      elsif routine_letter == 'f'
        return @HUNTING_COMMANDS_F unless @HUNTING_COMMANDS_F.size == 0
      elsif routine_letter == 'e'
        return @HUNTING_COMMANDS_E unless @HUNTING_COMMANDS_E.size == 0
      elsif routine_letter == 'd'
        return @HUNTING_COMMANDS_D unless @HUNTING_COMMANDS_D.size == 0
      elsif routine_letter == 'c'
        return @HUNTING_COMMANDS_C unless @HUNTING_COMMANDS_C.size == 0
      elsif routine_letter == 'b'
        return @HUNTING_COMMANDS_B unless @HUNTING_COMMANDS_B.size == 0
      end

      return @HUNTING_COMMANDS
    end
  end

  def solo?
    # tails wont have followers
    if (@followers && @followers.size == 1)
      return true
    else
      return false
    end
  end

  def leading?
    return !following?
  end

  def following?
    return @followers.nil?
  end

  def find_disk_names_in_room()
    disk_nouns_reg = Regexp.union(['bassinet',
                                   'cassone',
                                   'chest',
                                   'coffer',
                                   'coffin',
                                   'coffret',
                                   'disk',
                                   'hamper',
                                   'saucer',
                                   'sphere',
                                   'trunk',
                                   'tureen'])
    player_disk_names = []
    room_disks = GameObj.loot.find_all { |obj| obj.name =~ /([A-Z][a-z]+) #{disk_nouns_reg}/ }
    room_disks.each do |disk|
      disk_match = disk.name.match(/([A-Z][a-z]+) #{disk_nouns_reg}/)
      player_disk_names.push(disk_match[1])
    end
    return player_disk_names
  end

  def room_contains_disks_of_non_group_members()
    allowed_disk_names = $grouplist + [Char.name]
    return !(find_disk_names_in_room() - allowed_disk_names).empty?
  end

  def no_players()
    echo "no_players" if $bigshot_debug
    if ((checkpcs - $grouplist).count > 0)
      echo "no_players: checkpcs present" if $bigshot_debug
      return false
    elsif room_contains_disks_of_non_group_members()
      echo "no_players: Disk is present from someone not in group" if $bigshot_debug
      return false
    elsif $ambusher_here
      echo "no_players: Ambusher here" if $bigshot_debug
      return false
    elsif $obvious_hiding_player
      echo "no_players: Obvious Hiding Player here" if $bigshot_debug
      return false
    elsif $bigshot_room_claimed.length > 0
      echo "no_players: Room Claimed by #{$bigshot_room_claimed}" if $bigshot_debug
      return false
    else
      return true
    end
  end

  def no_players_hunt()
    echo "no_players_hunt" if $bigshot_debug
    return true if $bigshot_quick
    return false if $ambusher_here
    return false if $obvious_hiding_player
    return false if $bigshot_room_claimed.length > 0
    return false if room_contains_disks_of_non_group_members()

    return true
  end

  def pre_hunt(manually_walking = false)
    echo "pre_hunt" if $bigshot_debug

    if (!solo? && leading?)
      @followers.group_assist(true)
    end

    @followers.add_event(:HUNTING_PREP_COMMANDS)

    @HUNTING_PREP_COMMANDS.each { |i|
      if i =~ /^script\s+(.*?)(\s|$)(.*)/i
        cmd_run_script($1, $3)
      else
        fput(i)
        sleep(0.3)
      end
    }

    if !$bigshot_quick && !manually_walking
      unless @INDEPENDENT_TRAVEL
        @followers.add_event(:FOLLOW_NOW) # trigger rubber band
        @followers.add_event(:JOIN_LEADER)
        message("yellow", "Waiting for followers....") if !@followers.all_present?
        sleep(0.5) while (!@followers.all_present?)
      end

      prepare_for_movement(false) if @RALLYPOINT_ROOM_IDS.length.positive?

      if @INDEPENDENT_TRAVEL
        @followers.add_event(:GO2_RALLY_ROOM)
        @RALLYPOINT_ROOM_IDS.each { |room| go2(room.to_i) }
      else
        @RALLYPOINT_ROOM_IDS.each { |room|
          go2(room.to_i)
          if !@followers.all_present?
            @followers.add_event(:FOLLOW_NOW) # trigger rubber band
            message("yellow", "Waiting for followers....")
            sleep(0.5) while (!@followers.all_present?)
          end
        }
      end
    end

    prepare_for_movement()
    @followers.obv_hide_set(false)

    @followers.add_event(:HUNTING_SCRIPTS_START)
    run_scripts(@HUNTING_SCRIPTS, false)

    # Start bigshot hunting monitor
    hunt_monitor("start")

    # If using rally point, do a manual "look" to grab current room description/objects/etc
    # Which allows hunt_monitor to pick up on things incase same room as @HUNTING_ROOM_ID
    # Such as obvious hiding players.
    fput "look" if (@RALLYPOINT_ROOM_IDS.last == @HUNTING_ROOM_ID && !$bigshot_quick && !manually_walking)

    if Stats.prof == "Paladin"
      # Sync charges of Swift Justice or other abilites for buff tracking.
      res = Lich::Util.quiet_command_xml("spell", /<output class="mono"\/>/, /<prompt time=/)
      $bigshot_swift_justice = $1.to_i if res.any? { |line| line =~ /You have stored (\d+) charges of Swift Justice./i }
    end

    if !$bigshot_quick && !manually_walking
      @followers.add_event(:GO2_HUNTING_ROOM) if @INDEPENDENT_TRAVEL
      goto(@HUNTING_ROOM_ID)
    end
    # set autosneak on if we're sneaking
    if @SNEAKY_SNEAKY
      fput("movement autosneak on")
      $bigshot_sneaky_hunt = true
    end

    if (!solo? && leading?)
      unless @followers.all_present?
        @followers.add_event(:FOLLOW_NOW) # trigger rubber band
        message("yellow", "Waiting for followers....") if !@followers.all_present?
        sleep 0.5 while (!@followers.all_present?)
      end
      sleep 0.5

      check_for_deaders_prone

      @followers.add_event(:JOIN_LEADER)
      @followers.add_event(:CAST_SIGNS)

      # make sure we're hiding if we're sneaking
      if @followers.need_sneaky?
        message("yellow", "Waiting for followers to hide.")
        @followers.add_event(:CHECK_SNEAKY)
        wait_while { @followers.need_sneaky? }
        sleep 0.5
        wait_while { @followers.roundtime? }
        sleep 0.5
      end

      prepare_for_movement()
    end

    while $grouplist.length < @followers.group_size
      groupcheck()
    end

    sleep 0.5

    set_room_claimed([])
    cast_signs()
  end

  def do_hunt() # Finds target and calls attack block
    echo "do_hunt" if $bigshot_debug

    start_watch()
    message("yellow", 'Bigshot hunting')

    target = nil
    just_arrived = true
    last_attack = 0
    reset_variables()
    target = bs_wander() if !$bigshot_quick
    return if should_rest?

    while true
      while ((target = find_target(target, just_arrived)) && !should_rest? && no_players_hunt && !$bigshot_flee)
        echo "inside do_hunt loop | target: #{target}" if $bigshot_debug
        target = find_target(nil) if @PRIORITY && !priority(target)
        if ((Time.now.to_i - last_attack > 15) || just_arrived)
          @followers.add_event(:ATTACK)
          last_attack = Time.now.to_i
        end
        attack(target)
        just_arrived = false
      end

      # if its dead lets loot it!
      need_to_loot?(target, true)

      return if should_rest?

      target = bs_wander()
      just_arrived = true
    end
  end

  # this is a leader method
  def hunt()
    echo "hunt" if $bigshot_debug
    pre_hunt()
    do_hunt()
    rest()
  end

  # this is a leader method
  def rest()
    echo "rest" if $bigshot_debug

    $bigshot_group_status[Char.name] = $rest_reason
    sorted_hash = $bigshot_group_status.sort_by { |key, _| [key == Char.name ? -1 : 0, key.to_s] }.to_h
    any_wounded = $bigshot_group_status.values.include?("wounded.")

    _respond
    sorted_hash.each { |name, reason|
      next if reason.nil?
      message("yellow", " #{name} resting: #{reason}")
    }
    _respond

    # Stop bigshot hunting monitor
    hunt_monitor("stop")

    if @BOUNTY_MODE && ((GameObj.npcs.find { |n| n.name =~ /child/i } && checkbounty =~ /^You have made contact with the child you are to rescue/) || Script.running?("ebounty"))
      msg = checkbounty =~ /^You have made contact with the child you are to rescue/ ? " Exiting: Bounty mode with child rescue." : " Exiting: Bounty mode - #{$rest_reason}"
      message("yellow", msg)
      @BOUNTY_EVAL = ''
      single_stop()
      @followers.add_event(:SINGLE_STOP)
    end

    stop_watch()

    # set autosneak off if we're sneaking
    if @SNEAKY_SNEAKY
      fput("movement autosneak off")
      $bigshot_sneaky_hunt = false
    end

    # reset hunting globals
    $bigshot_should_rest = false
    $bigshot_overkill_counter = 0
    $bigshot_lte_boost_counter = 0

    set_obvious_hiding_player(false)
    prepare_for_movement

    wait_while { @followers.roundtime? }

    @followers.clear_group_events
    @followers.add_event(:HUNTING_SCRIPTS_STOP)
    croak_scripts(@HUNTING_SCRIPTS)

    if @INDEPENDENT_RETURN
      if $grouplist.length.positive?
        @followers.add_event(:PREP_REST)
        @followers.add_event(:LEAVE_GROUP)
        @followers.add_event(:FOG_RETURN)
        @followers.add_event(:GO2_WAYPOINTS)
        @followers.add_event(:GO2_RESTING_ROOM)

        Lich::Util.quiet_command_xml("disband group", /You have no group to disband|You disband your group/)
        until $grouplist.empty?
          groupcheck()
        end
      end

      @RETURN_WAYPOINT_IDS.each { |room| go2(room.to_i) }
      go2(@RESTING_ROOM_ID)
    else
      @followers.add_event(:FOLLOW_NOW)
      fog_return

      @RETURN_WAYPOINT_IDS.each { |room|
        go2(room.to_i)
        @followers.add_event(:FOLLOW_NOW)
        message("yellow", "Waiting for followers....") if !@followers.all_present?
        while (!@followers.all_present?)
          break if any_wounded
          message("yellow", "Waiting for followers....")
          sleep(0.5)
        end
      }

      go2(@RESTING_ROOM_ID)
    end

    escape_rooms

    if (@QUIET_FOLLOWERS) && !any_wounded
      @followers.add_event(:FOLLOW_NOW)
      message("yellow", "Waiting for followers....") if !@followers.all_present?
      while (!@followers.all_present?)
        break if any_wounded
        sleep(0.5)
      end
      sleep 2

      @RESTING_COMMANDS.each { |i|
        fput(i)
        sleep(0.3)
      }

      run_scripts(@RESTING_SCRIPTS, true)

      @followers.add_event(:RESTING_PREP_COMMANDS)
      @followers.add_event(:RESTING_SCRIPTS_START)
    else
      @followers.add_event(:RESTING_PREP_COMMANDS)
      @followers.add_event(:RESTING_SCRIPTS_START)

      @RESTING_COMMANDS.each { |i|
        fput(i)
        sleep(0.3)
      }

      run_scripts(@RESTING_SCRIPTS, true)
    end

    if $bigshot_single || (@BOUNTY_MODE && $rest_reason =~ /bounty complete/i)
      msg = $bigshot_single ? " Exiting Bigshot: Single loop complete" : " Exiting Bigshot: Bounty mode - #{$rest_reason}"
      message("yellow", msg)
      @followers.add_event(:SINGLE_STOP)
      single_stop()
    end

    # join everyone back to the leader
    Lich::Util.quiet_command_xml("group open", /Your group status/)
    @followers.add_event(:JOIN_LEADER)
    message("yellow", "Waiting for followers....") if !@followers.all_present?
    sleep(0.5) while (!@followers.all_present?)

    sleep 2

    # make sure we get everyone recognized as part of the group
    groupcheck()

    # this doesn't seem to do anything? Custom bit for something?
    if (!solo? && leading?)
      @followers.group_assist(true)
    end

    until (should_hunt?)
      @followers.add_event(:DISPLAY_WATCH)
      fput 'exp'
      sleep 0.2
      display_watch()
      message("yellow", "Bigshot last rested because: #{$rest_reason}") unless $rest_reason.nil?

      $bigshot_group_status[Char.name] = $not_hunting_reason
      sorted_hash = $bigshot_group_status.sort_by { |key, _| [key == Char.name ? -1 : 0, key.to_s] }.to_h

      sorted_hash.each { |name, reason|
        next if reason.nil? || reason == "ready"
        message("yellow", "#{name} isn't hunting because: #{reason}")
      }
      _respond
      sleep(REST_INTERVAL)
    end

    hunt() if !$bigshot_bandits
  end

  def mana_pulse(spell_id)
    return unless Spell[spell_id].known? && !Spell[spell_id].affordable?

    mana_regex = Regexp.union(
      /An invigorating rush of mana pulses through you/i,
      /You are too mentally fatigued to attempt this ability/i,
      /You're already at full mana./i,
      /Your mana control skills are not yet advanced/i,
    )

    dothistimeout "mana pulse", 2, mana_regex
    sleep 0.2
  end

  def fog_return_spirit(from_voln = false)
    current_room = Room.current.id
    mana_pulse(130)
    if Spell[130].known? && Spell[130].affordable?
      Spell[130].cast()
      sleep 0.5
      waitcastrt?
      if Room.current.id == 2635 && @FOG_RIFT && @RESTING_ROOM_ID != 2635 && current_room != Room.current.id
        mana_pulse(130)

        Spell[130].cast() if Spell[130].known? && Spell[130].affordable?
        sleep 0.5
        waitcastrt?
      end
    end

    # Something went wrong and 130 didn't work. Trying symbol of return
    if current_room == Room.current.id && Spell[9825].known? && !from_voln
      fog_return_voln(true)
    end
  end

  def fog_return_voln(from_130 = false)
    current_room = Room.current.id
    if Spell[9825].known?
      fput 'symbol of return'
      sleep(0.5)

      if current_room != Room.current.id && Room.current.id == 2635 && @FOG_RIFT && @RESTING_ROOM_ID != 2635
        fput 'symbol of return'
        sleep 0.5
      end
    end

    # Something went wrong and sym of return didn't work. Trying 130
    if current_room == Room.current.id && Spell[130].known? && !from_130
      fog_return_spirit(true)
    end
  end

  def fog_return
    return if @FOG_RETURN.to_i.zero?
    return if @FOG_OPTIONAL && $rest_reason !~ /wounded|encumbered/

    sleep(0.5)
    waitcastrt?
    waitrt?

    case @FOG_RETURN.to_i
    when 1 # Spirit Guide(130)
      fog_return_spirit
    when 2 # Symbol of Return
      fog_return_voln
    when 3 # Travelers Song(1020)
      mana_pulse(1020)
      sleep(0.2)
      Spell[1020].cast() if Spell[1020].known? && Spell[1020].affordable?
    when 4 # GoS - Sigil of Escape
      if Spell[9720].known? && Spell[9720].affordable?
        Spell[9720].cast()
        sleep(0.5)
        waitcastrt?
        waitrt?
      end
    when 5 # Familiar Gate
      mana_pulse(930)

      if Spell[930].known? && Spell[930].affordable?
        Spell[930].cast()
        fput 'go portal'
        sleep(0.5)
        waitcastrt?
        waitrt?
        escape_rooms
      end
    end
  end

  def attack(target) # Starts the process when a target is found
    echo "attack" if $bigshot_debug
    commands = find_routine(target)
    echo "Inside attack(target) #{commands}" if $bigshot_debug

    if XMLData.current_target_id != target.id
      bs_put "target ##{target.id}" if target.status !~ /dead|gone/
    end

    commands.each do |i|
      break unless valid_target?(target)
      break if wounded? || $bigshot_should_rest
      break if $ambusher_here
      break if $obvious_hiding_player

      temp_var = !GameObj.targets.any? { |s| s.id == target.id }
      break if target.status =~ /dead|gone/ || temp_var
      break if should_flee?
      break if should_rest?
      break if !($bigshot_bandits) && @PRIORITY && !priority(target)
      break if @event_stack.any? { |a| a.type == :PREP_REST }

      group_status_ailments() if @TROUBADOURS_RALLY && Spell[1040].known?
      stand(i) if !standing?
      cast_signs()

      echo "reaction_check" if $bigshot_debug
      echo "| #{$bigshot_reaction}" if $bigshot_debug
      echo "| #{@WEAPON_REACTION}" if $bigshot_debug
      perform_reaction if ($bigshot_reaction != nil) && @WEAPON_REACTION
      cmd(i, target)
    end

    # Check for Roa'ter swallowing or Hinterwilds Ooze swallowing
    escape_rooms

    # if its dead lets loot it!
    need_to_loot?(target)

    echo "commands.size = #{commands.size}" if $bigshot_debug
  end

  def need_to_loot?(target, after_attack_loop = false)
    if (target.status =~ /dead|gone/ || after_attack_loop) && !$ambusher_here
      @DESIGNATED_LOOTER = ma_looter
      if Char.name == @DESIGNATED_LOOTER && (Char.name == @followers.leader_name || @followers.leader_name.nil?)
        loot()
      else
        if Char.name == @followers.leader_name
          $looting_inactive = false
          @followers.set_group_looting_active
          @followers.add_event(:PREP_REST)
          @followers.add_event(:LOOT)
        end
      end
      check_mind

      if @BOUNTY_MODE && (bounty_check?)
        $bigshot_should_rest = true
      end
    end
  end

  def go2(place)
    fput('unhide') if (hidden? || invisible?)
    return if Room.current.id == place.to_i || Room.current.tags.include?(place)
    Script.run('go2', "#{place} --disable-confirm", { quiet: true })
  end

  def goto(id, cast_signs_moving = true)
    echo "goto" if $bigshot_debug
    prepare_for_movement(cast_signs_moving)
    set_obvious_hiding_player(false)
    until (Room.current.id == id)
      run_script('go2', true, [id, '_disable_confirm_'])
    end
  end

  def start_watch()
    echo "start_watch" if $bigshot_debug
    @START_TIME = Time.now.to_i
    @followers.add_event(:START_WATCH)
  end

  def stop_watch()
    echo "stop_watch" if $bigshot_debug
    if (@START_TIME > 100)
      @STORED_TIMES.push(Time.now.to_i - @START_TIME)
      @followers.add_event(:STOP_WATCH)
    end
    @START_TIME = 0
  end

  def display_watch()
    echo "display_watch" if $bigshot_debug

    # current
    if (@STORED_TIMES.size > 0)
      seconds = @STORED_TIMES[-1]
      message("yellow", sprintf("Bigshot: Last Hunt: %d min. %0.2f secs.", seconds / 60, seconds % 60))
    end

    # average
    average = 0
    if (@STORED_TIMES.size == 1)
      average = @STORED_TIMES[0]
      message("yellow", sprintf("Bigshot: Average Hunt: %d min. %0.2f secs.", average / 60, average % 60))
    elsif (@STORED_TIMES.size > 1)
      @STORED_TIMES.each { |i| average += i }
      average /= @STORED_TIMES.size
      message("yellow", sprintf("Bigshot: Average Hunt: %d min. %0.2f secs.", average / 60, average % 60))
    end

    # total
    total = Time.now.to_i - @BIRTH_TIME
    message("yellow", sprintf("Bigshot: Total Time Running: %d min.  %0.2f secs.", total / 60, total % 60))
  end

  def display_items_for_blessing()
    echo "display_items_for_blessing" if $bigshot_debug
    $bigshot_bless = $bigshot_bless - ["", nil]
    bless_bundles = false
    if $bigshot_bless.count > 0
      message("yellow", "Bigshot: The following items should be blessed before next hunt")
      $bigshot_bless.each { |id|
        noun = GameObj.inv.find { |obj| obj.id == "#{id}" }
        if noun.nil? or noun.empty?
          bless_bundles = true
        else
          message("yellow", "Bigshot: #{noun}")
        end
      }
      message("yellow", "Bigshot: arrows or other bundled weapon-type") if bless_bundles
    end
    bless_bundles = false
  end

  def single_stop()
    Script.self.kill
    sleep 0.5
  end

  def room_id()
    echo "room_id" if $bigshot_debug
    return Room.current.id()
  end

  def name()
    return Char.name
  end

  def poaching?()
    echo "poaching?" if $bigshot_debug
    if $bigshot_quick
      return false
    elsif (leading?)
      message("yellow", "Obvious hiding player present") if $obvious_hiding_player
      return true if $obvious_hiding_player

      (checkpcs - $grouplist).each { |i| return true unless @followers.get_names.include?(i) }
      if solo? && !$bigshot_quick
        message("yellow", "Obvious hiding player present") if $obvious_hiding_player
        return true if $obvious_hiding_player

        GameObj.npcs.each { |i| return true if i.type =~ /companion/ && i.name !~ /#{$companion}/i }
        GameObj.npcs.each { |i| return true if i.type =~ /familiar/ && i.name !~ /#{$familiar}/i }
      end
      return true if $bigshot_room_claimed.length > 0

      return false
    else
      return false
    end
  end

  def perform_reaction()
    echo "performing weapon reaction" if $bigshot_debug

    fput "weapon #{$bigshot_reaction}"
    $bigshot_reaction = nil
  end

  def get_grouplist()
    return $grouplist
  end

  def should_flee?(just_entered = false)
    echo "should_flee" if $bigshot_debug
    return false if $bigshot_quick
    return false if $bigshot_bandits
    return true if $bigshot_flee

    GameObj.loot.each { |i| return true if i.noun =~ /cloud|breath/ } if @FLEE_CLOUDS
    GameObj.loot.each { |i| return true if i.name == 'intense shimmering circle' } if @FLEE_CLOUDS
    GameObj.loot.each { |i| return true if i.noun =~ /vine/ } if @FLEE_VINES
    GameObj.loot.each { |i| return true if i.noun =~ /web/ } if @FLEE_WEBS
    GameObj.loot.each { |i| return true if i.name =~ /black void/ } if @FLEE_VOIDS
    return true if GameObj.npcs.any?  { |i| @ALWAYS_FLEE_FROM.include?(i.noun) or @ALWAYS_FLEE_FROM.include?(i.name) }
    return true if checkpcs.any?      { |i| @ALWAYS_FLEE_FROM.include?(i) }
    return true if GameObj.targets.any? { |i| i.type =~ /boon/ } && @BOON_FLEE_FROM
    return true if !leading? && checkpcs.empty?

    npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| (@INVALID_TARGETS.include?(npc.name) or @INVALID_TARGETS.include?(npc.noun)) }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /^(?:arm|appendage|claw|limb|pincer|tentacle)s?$|^(?:palpus|palpi)$/i }
    npcs.delete_if { |npc| npc.noun =~ /^(?:grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i }
    npcs.delete_if { |npc| ['quickly growing troll king', 'severed troll arm', 'severed troll leg'].include?(npc.name) }
    npcs.delete_if { |npc| npc.type =~ /companion|familiar/i && npc.type !~ /aggressive npc/i }

    flee_count = (just_entered && @LONE_TARGETS_ONLY) ? 1 : @FLEE_COUNT
    if npcs.size > flee_count
      return true
    end
  end

  def valid_target?(target, just_entered = false)
    echo "valid_target? (given #{target})" if $bigshot_debug
    echo "return false if target == nil #{target == nil} || target == false #{target == false}" if $bigshot_debug
    return false if target == nil || target == false

    echo "return false if should_flee?(just_entered) #{should_flee?(just_entered)}" if $bigshot_debug
    return false if should_flee?(just_entered)

    echo " return false if just_entered #{just_entered} && poaching? #{poaching?}" if $bigshot_debug
    return false if just_entered && poaching?

    echo " return false if $bigshot_room_claimed.length #{$bigshot_room_claimed.length} > 0" if $bigshot_debug
    return false if $bigshot_room_claimed.length > 0

    echo " false if target.name =~ /animated/ #{target.name =~ /animated/}" if $bigshot_debug
    if (target.name =~ /animated/ && target.name !~ /animated slush/)
      CharSettings['untargetable'].push(target.name) if target.status !~ /dead|gone/
      return false
    end
    if (!CharSettings['targetable'].include?(target.name) && !CharSettings['untargetable'].include?(target.name) && target.status !~ /dead|gone/)
      result = dothistimeout("target ##{target.id}", 3, /^You are now targeting|^You can't target|^You discern that you are the origin|^You are unable to discern the origin/)
      if (result =~ /^You are now targeting/)
        CharSettings['targetable'].push(target.name) if target.status !~ /dead|gone/
      elsif (result =~ /^You can't target|^You discern that you are the origin|^You are unable to discern the origin/)
        CharSettings['untargetable'].push(target.name) if target.status !~ /dead|gone/
      end
    end
    echo "return false if CharSettings['untargetable'].include?(target.name)  #{CharSettings['untargetable'].include?(target.name)}" if $bigshot_debug
    return false if CharSettings['untargetable'].include?(target.name)

    echo "return false if (target.status =~ /dead|gone/)  #{(target.status =~ /dead|gone/)}" if $bigshot_debug
    return false if (target.status =~ /dead|gone/)

    temp_var = !GameObj.targets.any? { |n| n.id == target.id } # Exists solely for debug printout
    echo "!GameObj.targets.any? { |n| n.id == target.id }  #{temp_var}" if $bigshot_debug
    return false if temp_var

    if (@TARGETS.nil? or @TARGETS.keys.any? { |i| target.name =~ /#{i}/i or target.noun =~ /#{i}/i })
      echo "returning true from valid_target for #{target.name}" if $bigshot_debug
      return true
    else
      echo "Returning valid_target == false for #{target.name}" if $bigshot_debug
      return false
    end
  end

  def sort_npcs()
    echo "sort_npcs" if $bigshot_debug
    if $bigshot_quick || $bigshot_bandits
      targets = Hash.new
      tokens = []
      if @QUICKHUNT_TARGETS.nil?
        @QUICKHUNT_TARGETS = Hash.new
      end
      npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
      npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
      if ($bigshot_bandits)
        npcs.delete_if { |npc| npc.noun !~ /thief|rogue|bandit|mugger|outlaw|highwayman|marauder|brigand|thug|robber/i }
      end
      npcs.each { |i| tokens.push(i.name) }

      tokens.uniq.each { |i|
        targets[i] = "quick" if @QUICKHUNT_TARGETS.empty?
      }

      if @TARGETS.nil?
        @TARGETS = Hash.new
      end

      @TARGETS.replace(@QUICKHUNT_TARGETS)
      @TARGETS.merge!(targets)
      targets = @TARGETS

    else
      targets = @TARGETS
    end

    npcs = GameObj.targets
    sorted = Array.new
    targets.keys.each { |target| sorted += npcs.find_all { |npc| (npc.name =~ /^#{target}$/i or npc.noun =~ /^#{target}$/i) }.to_a }
    sorted.flatten
  end

  def priority(target)
    echo "priority" if $bigshot_debug
    return true if (!$current_room_npcs.zip($room_npcs_last_check).map { |x, y| x.id == y.id }.any? { |s| s == false })

    $room_npcs_last_check = GameObj.npcs
    priority = false
    stoppriority = false
    npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    @TARGETS.keys.each { |t|
      break if stoppriority == true

      npcs.each { |s|
        break if stoppriority == true

        if (s.name =~ /#{t}/i or s.noun =~ /#{t}/i)
          if s.name == target.name
            stoppriority = true
            priority = true
          else
            stoppriority = true
          end
        end
      }
    }
    return priority
  end

  def find_target(target, just_entered = false)
    echo "find_target: #{target} | valid_target?(target, just_entered): #{valid_target?(target, just_entered)}" if $bigshot_debug
    return target if valid_target?(target, just_entered)

    if @PRIORITY && !$bigshot_bandits
      echo "@PRIORITY: #{@PRIORITY} && !$bigshot_bandits" if $bigshot_debug
      sort_npcs.each { |i| return i if valid_target?(i, just_entered) && priority(i) }
    else
      sort_npcs.each { |i| return i if valid_target?(i, just_entered) }
    end
    echo "\n\n\nfind target returning nil\n\n\n" if $bigshot_debug
    return nil
  end

  def rt?()
    echo "rt?" if $bigshot_debug
    return checkrt()
  end

  def fried?()
    if $bigshot_quick || @FRIED > 100
      return false
    elsif (@CORRECT_PERCENT_MIND >= @FRIED)
      return true
    else
      return false
    end
  end

  def oom?()
    if (percentmana() < @OOM)
      return true
    else
      return false
    end
  end

  def player_hidden?
    return hidden?
  end

  def sneaky_hunt?
    return @SNEAKY_SNEAKY
  end

  def encumbrance?
    return [percentencumbrance, @ENCUMBERED]
  end

  def saturated?()
    if checkmind =~ /saturated/
      return true
    else
      return false
    end
  end

  def overkill?()
    if ($bigshot_overkill_counter >= @OVERKILL && lte_boost?)
      return true
    else
      return false
    end
  end

  def set_help_group(keep_attacking)
    @HELP_GROUP_KILL = keep_attacking
  end

  def lte_boost?()
    if ($bigshot_lte_boost_counter >= @LTE_BOOST)
      return true
    else
      return false
    end
  end

  def use_lte_boost()
    if (fried? && !lte_boost?) # Need the check because of the race condition caused if you are a follower in RT when called
      boost_attempt = dothistimeout "boost longterm", 3, /You do not have any Long-Term Experience Boosts to redeem.|You have deducted 500 experience points from your field experience/
      if boost_attempt =~ /You do not have any Long-Term Experience Boosts to redeem./
        message("yellow", "No more LTE boosts available - Skipping")
        $bigshot_lte_boost_counter = @LTE_BOOST
        add_overkill()
      elsif boost_attempt =~ /You have deducted 500 experience points from your field experience/
        $bigshot_lte_boost_counter += 1
        message("yellow", "Used LTE Boost: #{$bigshot_lte_boost_counter} of #{@LTE_BOOST}")
        $bigshot_overkill_counter = 0
      end
    end
  end

  def check_mind
    @followers.add_event(:CHECK_MIND)
    lines = Lich::Util.quiet_command_xml("experience", /<output class="mono"\/>/)

    if lines.any? { |l| l =~ /Field Exp\:\s*([0-9,]+)\/([0-9,]+)/i }
      in_bucket = $1.delete(",").to_f
      max_bucket = $2.delete(",").to_f
    end

    actual_percent = (in_bucket / max_bucket) * 100
    echo "in_bucket: #{in_bucket} | max_bucket: #{max_bucket} | actual_percent: #{actual_percent}" if $bigshot_debug
    if actual_percent.nil?
      @CORRECT_PERCENT_MIND = percentmind()
    else
      @CORRECT_PERCENT_MIND = actual_percent
    end

    return @CORRECT_PERCENT_MIND
  end

  def ammo_on_ground(ammo)
    echo "ammo_on_ground" if $bigshot_debug
    return GameObj.loot.find { |i| i.name =~ /\b#{ammo}s?\b/i or i.noun =~ /^#{ammo}s?$/i }
  end

  def gather_ammo()
    echo "gather_ammo" if $bigshot_debug
    ammo = @AMMO
    container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
    hide = @HIDE_FOR_AMMO

    return if wounded?

    if ammo.nil? or ammo.empty?
      return
    end

    if ammo =~ /\b(arrow|bolt|dart)\b/i
      ammo_noun = $1
    else
      echo "failed to gather: invalid ammo type specified (use the full name)"
    end

    if container.nil?
      echo "failed to gather: you must specify an ammo container to use this feature"
      return
    end

    while (ammo_on_ground(ammo_noun))
      change_stance('defensive')

      unless GameObj.right_hand.id.nil?
        line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
      end

      result = dothistimeout("gather #{ammo_noun}", 2, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/)

      if (result =~ /on the ground/)
        result = dothistimeout "get #{ammo_noun}s", 3, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/
      end

      if (result =~ /^You gather|^You pick up/)
        dothistimeout("put my #{ammo_noun} in my #{ammo_noun}s in my #{container.noun}", 2, /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/)
        bs_put "put my #{ammo_noun} in my ##{container.id}" if righthand?
      elsif (result =~ /You may only/)
        return
      elsif (result == false || result =~ /^I could not find|^What were you/)
        return
      elsif (result =~ /reach/)
        bs_put 'hide' if hide and not hidden?
        sleep(4)
      end
    end
  end

  def reset_variables()
    echo "reset_variables" if $bigshot_debug
    $ambusher_here = false
    $bigshot_smite_list = []
    $bigshot_aim = 0
    $bigshot_ambush = 0
    $bigshot_archery_aim = 0
    $bigshot_archery_stuck_location = []
    $bigshot_dislodge_location = []
    $bigshot_unarmed_tier = 1
    $bigshot_unarmed_followup = false
    $bigshot_unarmed_followup_attack = ""
    $bigshot_703_list = []
    $bigshot_1614_list = []
    $bigshot_reaction = nil
  end

  def wounded?()
    echo "wounded?" if $bigshot_debug
    if $bigshot_quick
      return false
    elsif (@WOUNDED_EVAL)
      return eval @WOUNDED_EVAL
    else
      return false
    end
  end

  def creaping_dread?
    Effects::Debuffs.to_h.keys.map(&:to_s).find { |k| k.include? "Creeping Dread" }.match(/\((\d+)\)/)[1].to_i
    counter = $1.to_i
    if counter >= @CREEPING_DREAD && @CREEPING_DREAD > 0
      return true
    end

    return false
  end

  def crushing_dread?
    Effects::Debuffs.to_h.keys.map(&:to_s).find { |k| k.include? "Crushing Dread" }.match(/\((\d+)\)/)[1].to_i
    counter = $1.to_i
    if counter >= @CRUSHING_DREAD && @CRUSHING_DREAD > 0
      return true
    end

    return false
  end

  def wot_poison?
    poisoned = false
    if Effects::Debuffs.active?("Wall of Thorns Poison 1") || Effects::Debuffs.active?("Wall of Thorns Poison 2") || Effects::Debuffs.active?("Wall of Thorns Poison 3") || Effects::Debuffs.active?("Wall of Thorns Poison 4") || Effects::Debuffs.active?("Wall of Thorns Poison 5")
      poisoned = true
    end

    if poisoned && @WOT_POISON == true
      return true
    end

    return false
  end

  def bounty_check?()
    return false unless @BOUNTY_MODE
    return false if @BANDIT_HUNTING && GameObj.targets.any? { |target| target.type =~ /bandit/ }

    if @BOUNTY_EVAL.to_s.empty?
      Lich::Messaging.msg('error', " Bigshot is running in bounty mode and bounty_eval is empty. Exiting...")
      exit
    end

    result = eval(@BOUNTY_EVAL)
    echo "bounty_check? result: #{result} | called by #{caller[0]}" if $bigshot_debug

    return result
  end

  def ready_to_hunt?
    echo "ready_to_hunt? called by #{caller[0]}" if $bigshot_debug
    $not_hunting_reason = nil
    not_hunting = {
      'wounded.'                           => lambda { wounded? },
      'encumbered.'                        => lambda { percentencumbrance >= @ENCUMBERED },
      'creaping dread active.'             => lambda { creaping_dread? },
      'crushing dread active.'             => lambda { crushing_dread? },
      'confusion debuff active.'           => lambda { Effects::Debuffs.active?("Confusion") && @CONFUSION == true },
      'wall of thorns poison active.'      => lambda { wot_poison? },
      'resting scripts are still running.' => lambda { @RESTING_SCRIPTS.any? { |i| running?(i) } },
      'mind still above threshold.'        => lambda { @CORRECT_PERCENT_MIND > @REST_TILL_EXP },
      'mana still below threshold.'        => lambda { percentmana() < @REST_TILL_MANA },
      'spirit still below threshold.'      => lambda { checkspirit() < @REST_TILL_SPIRIT }
    }

    not_hunting.each do |reason, condition|
      if condition.call
        $not_hunting_reason = reason
        return reason
      end
    end

    return "ready"
  end

  def should_hunt?()
    echo "should_hunt? called by #{caller[0]}" if $bigshot_debug

    if @BOUNTY_MODE && (bounty_check?)
      echo "should_hunt? @BOUNTY_MODE = #{@BOUNTY_MODE} | bounty_check? = #{bounty_check?}" if $bigshot_debug
      message("yellow", " Bounty mode. Killing self. Reason: Bounty available or complete.")
      @BOUNTY_EVAL = ''
      $bigshot_status = :rest_stop
      exit
    end

    check_mind

    leader_reason = ready_to_hunt?
    group_reason = @followers.group_should_hunt?

    if (group_reason && leader_reason == "ready")
      $bigshot_status = :hunting
      return true
    else
      $not_hunting_reason = leader_reason
      return false
    end
  end

  def ready_to_rest?
    echo "ready_to_rest? called by #{caller[0]}" if $bigshot_debug
    return false if $bigshot_quick
    $rest_reason = nil

    # Define rest_conditions with lambda functions representing conditions
    rest_conditions = {
      bounty_mode: lambda { @BOUNTY_MODE && $bigshot_should_rest },
      should_rest: lambda { $bigshot_should_rest },
      wounded: lambda { wounded? },
      percentencumbrance: lambda { percentencumbrance >= @ENCUMBERED },
      creaping_dread: lambda { creaping_dread? },
      crushing_dread: lambda { crushing_dread? },
      wot_poison: lambda { wot_poison? },
      confusion_debuff: lambda { @CONFUSION == true && Effects::Debuffs.active?("Confusion") },
      fried_overkill_and_lte_boost: lambda { fried? && overkill? && lte_boost? },
      oom: lambda { oom? }
    }

    # Define rest_actions with lambda functions representing actions
    rest_actions = {
      bounty_mode: lambda { $rest_reason = 'bounty complete.' },
      should_rest: lambda { $rest_reason = '$bigshot_should_rest was set to true.' unless $rest_reason },
      wounded: lambda { $rest_reason = 'wounded.' },
      percentencumbrance: lambda { $rest_reason = 'encumbered.' },
      creaping_dread: lambda { $rest_reason = 'creaping dread limit.' },
      crushing_dread: lambda { $rest_reason = 'crushing dread limit.' },
      wot_poison: lambda { $rest_reason = 'wall of thorns poison.' },
      confusion_debuff: lambda { $rest_reason = 'confusion debuff.' },
      fried_overkill_and_lte_boost: lambda { $rest_reason = 'fried.' },
      oom: lambda { wrack() if @USE_WRACKING; return false unless oom?; $rest_reason = 'out of mana.' }
    }

    # Iterate through rest_conditions and execute corresponding actions from rest_actions
    rest_conditions.each do |condition, lambda_function|
      if lambda_function.call
        if rest_actions[condition].call
          $bigshot_status = :resting
          return $rest_reason
        end
      end
    end
    return false
  end

  def should_rest?()
    echo "should_rest? called by #{caller[0]}" if $bigshot_debug

    group_rest = @followers.group_should_rest?
    leader_rest = ready_to_rest?

    # return false if no one needs to rest
    return false if !group_rest && !leader_rest

    # combine all the rest reasons
    rest_reasons = $bigshot_group_status.to_a.map { |_, reason| reason }.push($rest_reason)
    rest_reasons.compact!

    # return false if some are fried but others aren't and no other issues
    if rest_reasons.all? { |reason| reason =~ /fried/ } && (rest_reasons.length < @followers.size.to_i || @followers.size.to_i.zero?)
      return false
    end

    # Otherwise we need to rest for some reason
    # call loot for certain situations but not if wounded
    if rest_reasons.any? { |reason| reason.match?(/dread limit|bounty complete|fried|out of mana|encumbered/) } && !$ambusher_here && $bigshot_room_claim.length.to_i.zero? && !rest_reasons.include?('wounded.')
      final_loot()
    end
    # Fixme: wounded group members need to be mobile before leaving
    $bigshot_status = :resting
    return true
  end

  def add_overkill()
    if (fried? && lte_boost?)
      $bigshot_overkill_counter += 1
      message("yellow", "Extra Kills currently at: #{$bigshot_overkill_counter} of #{@OVERKILL}") unless @OVERKILL == 0
    end

    if (!solo? && leading?)
      @followers.add_event(:FOLLOWER_OVERKILL)
    end
  end

  def bard_renewal()
    $bard_renewal_cost ||= 0
    $bard_renewal_check ||= (Time.now - 61)
    if Stats.prof == "Bard" && (Time.now - $bard_renewal_check).to_i > 60
      song_renewal_cost = Lich::Util.quiet_command_xml("song status", /currently singing:|not singing/, /<prompt time=/)
      if song_renewal_cost.any? { |line| line =~ /Your current renewal cost is (\d+) mana./i }
        $bard_renewal_cost = $1.to_i
      end
      $bard_renewal_check = Time.now
    end
    return $bard_renewal_cost
  end

  def voln_favor()
    current_favor = 0
    favor_pattern = /Voln Favor: (([,\d]+))/

    lines = Lich::Util.quiet_command_xml("resources", /<output class="mono"\/>/).join(" ")

    if lines =~ favor_pattern
      current_favor = $1.gsub(',', '').to_i;
    end

    return current_favor
  end

  def cast_signs(single_cast = false)
    echo "cast_signs?" if $bigshot_debug

    @SIGNS.each do |i|
      if i =~ /\b650\s?(\w+)?\s?(\w+)?\s?/
        cmd_assume($1.to_s, $2.to_s)
        next
      end
      i = i.to_i
      next if [9903, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9912, 9913, 9914, 9918].include?(i) and Spell[9012].active?
      next if i == 9918
      next if (i == 9605 && Effects::Cooldowns.active?("Surge of Strength"))
      next if (i == 320 && Effects::Cooldowns.active?("Ethereal Censer"))
      next if (i == 605 && Effects::Cooldowns.active?("Barkskin"))
      next if (i == 9625 && Effects::Cooldowns.active?("Burst of Swiftness"))
      next if (i == 1035 && Effects::Buffs.active?("Song of Tonis"))

      if i == 122420
        next unless Warcry.available?("Seanette's Shout")
        next if !(Effects::Buffs.time_left("Empowered (+20)") <= (10 / 60.to_f))
        next if checkstamina < 25

        waitrt?
        waitcastrt?

        result_regex = Regexp.union(
          /You let loose an echoing shout!/i,
          /Your fighting spirit is bolstered!|round(time)?|seconds/i,
          /round(time)?|seconds/i,
          /You must be an active member/i,
        )

        rt_regex = /(?:Roundtime:|\.\.\.wait|Wait) (\d+) [Ss]ec(?:onds?)?\.?/
        regex = Regexp.union(result_regex, rt_regex)

        result = nil
        loop {
          wait_rt
          result = dothistimeout("warcry shout", 3, regex)
          break unless result =~ rt_regex
        }
      end
      if i == 9605
        next if (!CMan.known?("Surge of Strength") || Effects::Debuffs.active?("Overexerted"))

        waitrt?
        waitcastrt?
        if (checkstamina >= 30)
          result = dothistimeout("cman surge", 1, /You feel a great deal stronger.|untapped sources of strength|still recent prior attempt|come from your muscles|ache much too badly/i)
          if (result == false)
            $bigshot_should_rest = true
            $rest_reason = "Unknown result from surge routine: #{result}"
          end
          sleep 0.5
        end
        next
      end
      if i == 9625
        next if (!CMan.known?("Burst of Swiftness") || Effects::Debuffs.active?("Overexerted"))

        waitrt?
        waitcastrt?
        if (checkstamina >= 30)
          result = dothistimeout("cman burst", 1, /You prepare yourself to move swiftly at a moment's notice|ache much too badly/i)
          if (result == false)
            $bigshot_should_rest = true
            $rest_reason = "Unknown result from burst routine: #{result}"
          end
          sleep 0.5
        end
        next
      end
      if i == 909
        Spell[909].force_channel if (Spell[909].known? && Spell[909].affordable? && !Spell[909].active?)
        next
      end

      sign = Spell[i]
      next unless sign.known?
      next if [140, 211, 215, 219, 240, 919, 1619, 1650].include?(sign.num) && Effects::Cooldowns.active?(sign.name)

      if [9805, 9806, 9816].include?(sign.num) && !sign.active? && @CHECK_FAVOR
        current_favor = voln_favor()
        symbol_cost = { 9805 => 0.1, 9806 => 0.1, 9816 => 0.5 }

        # symbol of return cost from wiki (over estimates slightly)
        favor_cost = ((2161 / 97) * Stats.level) - (5222 / 97)
        sym_cost = favor_cost * symbol_cost[sign.num]

        next if sym_cost > current_favor
      end

      # wrack?
      mana_cost = sign.mana_cost > 1 ? sign.mana_cost : 0 # Many erroneously return 1
      wrack() if !sign.affordable? and mana_cost > checkmana and @USE_WRACKING

      if (!sign.active? && sign.affordable?)
        next if (Stats.prof == "Bard" && !checkmana(bard_renewal + sign.mana_cost))
        loop do
          result = sign.cast
          break if (result.to_s !~ /Spell Hindrance/ || !sign.affordable? || !checkmana(bard_renewal + sign.mana_cost) || dead?)
        end
        break if single_cast
      end
    end
  end

  def looting_inactive?
    return $looting_inactive
  end

  def set_looting_active
    $looting_inactive = false
  end

  def final_loot
    @DESIGNATED_LOOTER = ma_looter
    if Char.name == @DESIGNATED_LOOTER && (Char.name == @followers.leader_name || @followers.leader_name.nil?)
      loot_dead
    else
      if Char.name == @followers.leader_name
        @followers.add_event(:PREP_REST)
        @followers.add_event(:FINAL_LOOT)
      end
    end
  end

  def loot
    echo "loot" if $bigshot_debug
    return unless checkroom("Duskruin Arena, Dueling Sands").nil?

    waitrt?

    $last_loot ||= Time.now + 15
    if @DELAY_LOOT && sort_npcs.any? { |s| valid_target?(s) }
      loot_dead if $last_loot <= Time.now
    else
      loot_dead
    end
  end

  def loot_dead
    dead_npcs = GameObj.npcs.find_all { |i| i.status == 'dead' && i.type !~ /escort/i }
    if dead_npcs.length.zero?
      reset_variables()
      return
    end
    return if should_flee?

    $looting_inactive = false
    dead_npcs.each { |i|
      next if i.status =~ /gone/
      $last_loot = nil
      use_lte_boost()
      add_overkill()
      change_stance('defensive') if gameobj_npc_check() > 0 && @LOOT_STANCE

      if (@LOOT_SCRIPT)
        run_script(@LOOT_SCRIPT, true)
      else
        bs_put "loot ##{i.id}"
        bs_put "loot room"
      end

      break unless GameObj.npcs.any? { |npc| npc.status == 'dead' && npc.type !~ /escort/i }
    }
    $looting_inactive = true
  end

  def check_room_claimed(player_present)
    if $bigshot_room_claimed.length > 0
      $bigshot_room_claimed.each { |player|
        if player =~ /#{player_present}/
          Lich::Messaging.msg("info", "Removing claim: #{player_present}") && UserVars.show_claim
          $bigshot_room_claimed.delete(player)
          break
        end
      }
    end
  end

  def set_room_claimed(claimed)
    $bigshot_room_claimed = claimed

    if $bigshot_quick
      $bigshot_room_claimed = []
      return
    end

    # check our buffer to see if someone was "Also here"
    buffer_one = reget(50, /^Also here:/, /^Obvious (?:exits|paths)/, /obvious signs of someone hiding/)
    if buffer_one[-2] =~ /^Also here: (.*)/
      $bigshot_room_claimed = $1.gsub("\r", "").split(",")
    elsif buffer_one[-2] =~ /obvious signs of someone hiding/
      $bigshot_room_claimed.push("hidden")
    else
      sleep(0.1)
      buffer_two = reget(20, /^Also here:/, /^Obvious (?:exits|paths)/, /obvious signs of someone hiding/)
      if buffer_two[-2] =~ /^Also here: (.*)/
        $bigshot_room_claimed = $1.gsub("\r", "").split(",")
      elsif buffer_two[-2] =~ /obvious signs of someone hiding/
        $bigshot_room_claimed.push("hidden")
      end
    end

    # remove any group members that made it on the list. needed for bigshot quick
    $bigshot_room_claimed = ($bigshot_room_claimed - $grouplist)

    # echo room claim status
    unless $bigshot_room_claimed.empty? || !UserVars.show_claim
      Lich::Messaging.msg("info", "Claimed: #{$bigshot_room_claimed.to_s.gsub(/\[|\]|\"/, "")}")
    end
  end

  def set_obvious_hiding_player(player_present)
    $obvious_hiding_player = player_present
    if !solo? && leading?
      @followers.obv_hide_set(player_present)
    end
  end

  def get_obvious_hiding_player_status()
    return $obvious_hiding_player
  end

  def prepare_for_movement(move_signs = true)
    echo "prepare_for_movement| move_signs: #{move_signs}" if $bigshot_debug

    reset_variables()
    change_stance('defensive')

    if (leading? && !solo?)
      @followers.add_event(:PREP_REST) if move_signs
      @followers.add_event(:FOLLOW_NOW) if !move_signs
      wait_while { @followers.roundtime? }
      sleep(0.3)
    end
    cmd_bless() if @BLESS && $bigshot_bless.count > 0
    cast_signs if move_signs
  end

  def wait_rt
    sleep 0.2
    wait_while { checkrt > 0 }
    sleep 0.2
  end

  def bs_wander()
    echo "bs_wander" if $bigshot_debug
    return if should_rest?

    $wander_rooms    ||= Array.new
    @COMMANDS_REGISTRY = {}

    wander = proc {
      room = Room.current
      next_room_options = room.wayto.keys - @HUNTING_BOUNDARIES
      next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
      next_room = next_room_options.find_all { |r| not $wander_rooms.include?(r) }
      if next_room.empty?
        next_room = $wander_rooms.find { |r| next_room_options.include?(r) }
      else
        next_room = next_room[rand(next_room.length)]
      end
      $wander_rooms.delete(next_room)
      $wander_rooms.push(next_room)
      way = room.wayto[next_room]
      if way.class == String
        move(way)
      else
        way.call
      end

      escape_rooms
      set_room_claimed([])
      check_for_deaders_prone
      cast_signs(true)
    }

    while true # wander, check for players
      prepare_for_movement()
      exit if $bigshot_quick
      npcs = GameObj.targets
      npcs.delete_if { |npc| (npc.status =~ /dead|gone/) }
      sort_npcs.each { |i| return i if valid_target?(i, true) and no_players == true and (gameobj_npc_check() > 0) }

      return if should_rest?
      pause @WANDER_WAIT unless should_flee?(true)

      unless should_flee?(true) || !$bigshot_room_claimed.empty?
        npcs = GameObj.targets
        npcs.delete_if { |npc| (npc.status =~ /dead|gone/) }
        sort_npcs.each { |i| return i if valid_target?(i, false) and no_players_hunt == true and (gameobj_npc_check() > 0) }
      end

      if !@followers.all_present?
        @followers.add_event(:FOLLOW_NOW) # trigger rubber band
        message("yellow", "Waiting for followers....")
        sleep(0.5) while (!@followers.all_present?)
      end

      # Wait for follower to finish looting if needed
      while !@followers.looting_done
        $looting_inactive = @followers.looting_done
        sleep 0.5
      end

      # make sure we're hiding if we're sneaking
      @followers.add_event(:CHECK_SNEAKY)
      while @event_stack.any? { |a| a.type == :CHECK_SNEAKY }
        sleep 0.5
        wait_while { @followers.roundtime? }
        sleep 1
      end

      if $bigshot_sneaky_hunt
        cmd_hide(1) unless hidden
        wait_rt
      end

      escape_rooms
      wait_while { @followers.roundtime? }

      if (Stats.prof == "Ranger") && !Effects::Cooldowns.active?("Tracking") && !@TRACKING_CREATURE.empty?
        return if ranger_track # true we skip the wander.call, false, we perform the wander.call
      end
      set_obvious_hiding_player(false)

      unless @inbounds.valid?
        @followers.add_event(:GO2_HUNTING_ROOM)
        goto(@HUNTING_ROOM_ID)
        @followers.add_event(:JOIN_LEADER)
        message("yellow", "Waiting for followers....") if !@followers.all_present?
        sleep 0.5 while (!@followers.all_present?)
      else
        wander.call
      end
      sleep(0.1)
      $bigshot_flee = false
    end
  end

  def ranger_track # track bounty targets on cooldown
    tracking_results = Regexp.union(
      /You don't have to go far\./, # target in the room, probably hidden.
      /Your keen eye spots the beginnings of a trail and you rush to follow it/, # success
      /was here, but the trail is clearly too old to be worth following\./, # failure
      /While you carefully study the area looking for tracks, you find no trace of what you are looking for\./, # wrong area
      /You don't know how to track creatures within town\./, # town
      /You haven't yet recovered from your previous tracking exploit\./ # cooldown
    )

    result = dothistimeout("track #{@TRACKING_CREATURE}", 1, tracking_results)
    case result
    when /Your keen eye spots the beginnings of a trail and you rush to follow it/ # success, new room, so we can go ahead and clear obvious hiding
      $bigshot_room_claimed = [] # we can clear room claim because track will not take you to a room with a player
      set_obvious_hiding_player(false) # we can clear obvious hiding same as above
      uncover() if GameObj.targets.empty? # maybe remove - probably a lot bigger update to reveal hidden targets universally
      return true # return true to return out of wander and not change rooms again
    when /^You don't have to go far\./ # success, but target is hidden in the existing room
      if $bigshot_room_claimed.empty?
        uncover() if GameObj.targets.empty? # probably remove - same as above
        return true # return true so wander doesn't move us
      elsif $bigshot_room_claimed
        return false # if room is claimed, we return false and let wander move us because track kept us in the same room which had to already been claimed
      end
    end
  end

  def uncover
    echo "uncover" if $bigshot_debug
    waitrt?
    return unless GameObj.targets.empty?
    if Stats.prof == "Ranger" && Spell[609].known? && Spell[609].affordable?
      waitcastrt?
      fput("incant 609 open")
    else
      fput "search"
      waitrt?
    end
    waitcastrt?
    return
  end

  def companion_check()
    if (Stats.prof =~ /Ranger/i && Spell[630].known? && GameObj.npcs.any? { |i| i.type =~ /companion/ } && $companion == nil)
      npcs = GameObj.npcs.find_all { |i| i.type =~ /companion/i }
      npcs.each { |i|
        res = dothistimeout "lean ##{i.id}", 1, /your direction in acknowledgement|rubbing.*gently|while it is flying|You lean toward/i
        if res =~ /rubbing.*gently/i
          $companion = i.name
          echo "Ranger Companion set to #{i.name}"
          break
        end
      }
    end
    if (Stats.prof =~ /Wizard/i && Spell[920].known? && GameObj.npcs.any? { |i| i.type =~ /familiar/ })
      res = dothistimeout "tell familiar to enter fakeportal", 1, /You sense confusion from your .*\.|You have no familiar at this time\./i
      if res =~ /You sense confusion from your/i
        res.sub!('You sense confusion from your ', '')
        res.gsub!('.', '')
        GameObj.npcs.each { |s|
          if s.name =~ /#{res}/i
            $familiar = s.name
            break
          end
        }
        echo "Familiar set as #{$familiar}"
      end
    end
  end

  def escape_rooms
    # Used to escape from Roa'ter swallowing
    unless checkroom("The Belly of the Beast").nil?
      roater_escape()
    end

    # Used to escape from Hinterwilds Ooze swallowing
    unless checkroom("Ooze, Innards").nil?
      ooze_escape()
    end

    # Used to escape a Temporal Rift due to failed 930 casting
    unless checkroom("Temporal Rift").nil?
      temporal_escape()
    end
  end

  def roater_escape()
    # find_all_containers_var = nil
    dagger_found = false
    container_ids = []
    empty_hands
    res = Lich::Util.quiet_command_xml("inventory containers", /Your worn items are:/, /<prompt time=/)
    res.each { |l|
      container_ids = l.scan(/<a exist=\"([^\"]+)\"/).flatten if (l =~ /<a exist=\"([^\"]+)\"/)
    }
    find_all_containers_var = container_ids.collect { |id| GameObj[id] }
    find_all_containers_var.each { |i|
      if i.contents.nil?
        res = Lich::Util.quiet_command_xml("look in ##{i.id}", /In the|There is nothing|This|is closed|shut too tightly/, /<prompt time=/)
        if res.any? { |line| line =~ /is closed|shut too tightly/i } # do we want it to open containers to look for daggers?
          Lich::Util.quiet_command_xml("open ##{i.id}", /<a exist=/, /<prompt time=/)
          Lich::Util.quiet_command_xml("look in ##{i.id}", /In the|There is nothing|This/, /<prompt time=/)
        end
      end
      i.contents.each { |s|
        if s.name =~ /alfange|basilard|bodkin|cinquedea|dagger|dirk|knife|kozuka|ice pick|misericord|parazonium|pavade|poignard|pugio|scramasax|sgian achlais|spike|stiletto|tanto|sidearm-of-Onar/i
          fput "_drag ##{s.id} right"
          dagger_found = true if (checkright =~ /#{s.noun}/)
          while !checkroom("The Belly of the Beast").nil?
            waitrt?
            fput "attack wall"
          end
          fput "_drag ##{s.id} ##{i.id}"
          break
        end
      }
      break if dagger_found
    }
    fill_hands
  end

  def ooze_escape
    weapon_found = false
    container_ids = []
    weapon_nouns = Regexp.union(
      # Blunt Weapons
      /\b(?:whip|bull whip|cat o' nine tails|signal whip|single-tail whip|training whip)\b/, # whip - crush
      # /\b(?:crowbill|hakapik|skull-piercer)\b/, # crowbill - puncture/crush
      /\b(?:cudgel|aklys|baculus|club|jo stick|lisan|periperiu|shillelagh|tambara|truncheon|waihaka|war club)\b/, # cudgel - crush
      /\b(?:mace|bulawa|dhara|flanged mace|knee-breaker|massuelle|mattina|nifa otti|ox mace|pernat|quadrelle|ridgemace|studded mace)\b/, # mace - crush
      /\b(?:ball and chain|binnol|goupillon|mace and chain)\b/, # ball and chain - crush
      # /\b(?:war hammer|fang|hammerbeak|hoolurge|horseman's hammer|skull-crusher|taavish)\b/, # war hammer - puncture/crush
      /\b(?:morning star|spiked mace|holy water sprinkler|spikestar)\b/, # morning star - crush/puncture
      # Brawling Weapons
      /\b(?:cestus)\b/, # cestus - crush
      /\b(?:knuckle-duster|knuckle guard|\w+ knuckles)\b/, # knuckle-duster - crush
      /\b(?:blackjack|bludgeon|sap)\b/, # blackjack - crush
      # Two-handed Weapons
      /\b(?:runestaff|asaya|crook|crosier|pastoral staff|rune staff|scepter|staff|staff-of-Lumnis|walking stick)\b/, # runestaff - crush
      /\b(?:quaterstaff|bo stick|toyak|walking staff|warstaff|yoribo)\b/, # quarterstaff - crush
      /\b(?:war mattock|mattock|oncin|pickaxe|sabar)\b/, # war mattock - crush
      /\b(?:maul|battle hammer|footman's hammer|sledgehammer|tetsubo)\b/, # maul - crush
    )
    waitrt?
    result = dothistimeout('kill organ', 3, /causing the ooze around you to convulse violently!|but the spongey amorphous organ is impervious to this kind of attack!/)
    case result
    when /causing the ooze around you to convulse violently!/
      while !checkroom('Ooze, Innards').nil?
        waitrt?
        fput 'kill organ'
      end
      return true
    when /but the spongey amorphous organ is impervious to this kind of attack!/
      empty_hands
    else
      echo "ooze_escape error, result: #{result}"
      echo "Please report issue and you're on your own for escaping for now!"
      sleep(0.5) until checkroom('Ooze, Innards').nil?
      return true
    end

    res = Lich::Util.quiet_command_xml("inventory containers", /Your worn items are:/, /<prompt time=/)
    res.each { |l|
      container_ids = l.scan(/<a exist=\"([^\"]+)\"/).flatten if (l =~ /<a exist=\"([^\"]+)\"/)
    }
    find_all_containers_var = container_ids.collect { |id| GameObj[id] }
    find_all_containers_var.each { |i|
      if i.contents.nil?
        res = Lich::Util.quiet_command_xml("look in ##{i.id}", /In the|There is nothing|This|is closed|shut too tightly/, /<prompt time=/)
        if res.any? { |line| line =~ /is closed|shut too tightly/i } # do we want it to open containers to look for daggers?
          Lich::Util.quiet_command_xml("open ##{i.id}", /<a exist=/, /<prompt time=/)
          Lich::Util.quiet_command_xml("look in ##{i.id}", /In the|There is nothing|This/, /<prompt time=/)
        end
      end
      i.contents.each { |s|
        if s.name =~ weapon_nouns
          fput "_drag ##{s.id} right"
          weapon_found = true if (checkright =~ /#{s.noun}/)
          while !checkroom('Ooze, Innards').nil?
            waitrt?
            fput 'kill organ'
          end
          fput "_drag ##{s.id} ##{i.id}"
          break
        end
      }
      break if weapon_found
    }
    fill_hands
  end

  def temporal_escape()
    while !checkroom("Temporal Rift").nil?
      move(checkpaths.sample)
      waitrt?
    end
  end

  def bs_put(message)
    echo "bs_put" if $bigshot_debug
    unless (script = Script.self) then
      respond("--- waitfor: Unable to identify calling script. | script: #{script} Script.self: #{Script.self} message: #{message}")
      return false
    end
    clear
    put(message)

    while (string = get)
      if string =~ /(?:\.\.\.wait |Wait )[0-9]+/
        hold_up = string.slice(/[0-9]+/).to_i
        sleep(hold_up - 1) unless hold_up.nil? || hold_up == 1
        clear
        put(message)
        next
      elsif string =~ /struggle.+stand/
        clear
        bs_put("stand")
        next
      elsif string =~ /stunned|can't do that while|cannot seem|can't seem|don't seem|Sorry, you may only type ahead/
        if dead?
          echo("You're dead...! You can't do that!")
          sleep(0.25)
          script.downstream_buffer.unshift(string)
          return false
        elsif checkstunned
          while checkstunned
            sleep(0.25)
          end
        elsif checkwebbed
          while checkwebbed
            sleep(0.25)
          end
        else
          sleep(0.25)
        end
        clear
        put(message)
        next
      else
        script.downstream_buffer.unshift(string)
        return string
      end
    end
  end

  def group_put(message)
    echo "group_put" if $bigshot_debug
    bs_put(message)
  end

  def group_cmd(message)
    echo "group_cmd" if $bigshot_debug
    cmd(message)
  end

  def group_do(message)
    echo "group_do" if $bigshot_debug
    do_client(message)
  end

  def self.profile(vars)
    if vars[2] =~ /load/i
      if vars[3] != nil
        dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
        filename = File.join(dir, "#{vars[3]}.yaml")
        if !File.exist?("#{filename}")
          respond ""
          respond " You are trying to load a profile that does not exist."
          respond ""
          respond "***************************"
          respond " Notice- your default Bigshot profiles folder has changed to:"
          respond " #{dir}"
          respond ""
          respond " The old location is here: #{File.join($script_dir, 'bigshot_profiles')}"
          respond " You can copy this folder or appropriate profiles into the relevant character directory in your operating system"
          respond "****************************"
          respond ""
        else
          from_file = YAML.load_file(filename)
          UserVars.op = from_file
          echo "Settings loaded from profile: #{filename}."
        end
      else
        echo "You forgot to name your profile you wish to load."
        echo "Syntax: ;bigshot profile load <NAME Here, no Spaces!>"
      end
    elsif vars[2] =~ /save/i
      if vars[3] != nil
        dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
        filename = File.join(dir, "#{vars[3]}.yaml")
        if File.exist?("#{filename}")
          echo "File already exists, if you wish to overwrite, please ;unpause bigshot."
          echo "Else ;kill bigshot and choose another filename."
          pause_script
        end
        File.write(filename, UserVars.op.to_yaml)
        echo "Settings saved to profile: #{filename}."
      else
        echo "You forgot to name your profile you wish to save."
        echo "Syntax: ;bigshot profile save <NAME Here, no Spaces!>"
      end
    end
  end
end

if Script.current.vars.any? { |var| var =~ /single|once/i }
  $bigshot_single = true
end

if (Script.current.vars[1].nil? || Script.current.vars[1] =~ /solo|(bounty)|quick|single|once/i)
  if Script.current.vars[1] =~ /quick/i
    $bigshot_quick = true
  end

  bs = Bigshot.new(Script.current.vars)
  bs.croak('Requires Lich V4') unless defined?(Gtk.queue) || defined?($bigshot_headless)
  bs.croak('Requires a mapped room.') if ((Room.current.id.nil? || Room.current.id == 4) && !$bigshot_quick)
  bs.lead()

elsif (Script.current.vars[1] =~ /setup/i)
  Bigshot::Setup.setup
elsif (Script.current.vars[1] =~ /debug/i)
  echo "Changing debug mode from #{$bigshot_debug} to #{!$bigshot_debug}"
  $bigshot_debug = !$bigshot_debug
elsif (Script.current.vars[1] =~ /profile/i)
  Bigshot.profile(Script.current.vars)

elsif (Script.current.vars[1] =~ /display/i)
  echo "Version: #{BIGSHOT_VERSION}"
  UserVars.op.each_pair { |k, v|
    echo "#{k}: #{v}" unless v.nil? || v.class.to_s == 'Array' || v.to_s =~ /^\s*$/
  }
  echo "Targetable Character Setting: #{CharSettings['targetable'].map { |c| c.downcase }.sort { |a, b| a.split(" ").last <=> b.split(" ").last }}"
  echo "Untargetable Character Setting: #{CharSettings['untargetable'].map { |c| c.downcase }.sort { |a, b| a.split(" ").last <=> b.split(" ").last }}"

elsif (Script.current.vars[1] =~ /reset/i)
  CharSettings['targetable'] = nil
  CharSettings['untargetable'] = nil
  echo "Character Settings for Targetable and Untargetable are now reset"

elsif (Script.current.vars[1] =~ /ranger|companion/i)
  $companion = nil
  echo "Ranger Companion reset"

elsif (Script.current.vars[1] =~ /head|lead/i)
  # launch DRb server
  DRb.start_service(nil, Bigshot::Group.new)

  uri = DRb.uri

  Thread.new { DRb.thread.join }

  # launch DRb client
  DRb.start_service()

  bs = Bigshot.new(Script.current.vars)

  # set leader
  my_group = DRbObject.new(nil, uri)
  my_group.set_leader(bs)

  # announce/go
  (1..RALLY_TIME).each { |_i| fput "whisper ooc group Bigshot rallying at #{uri}"; sleep(1); }
  echo "Waiting for members to join Bigshot rally..."

  wait_until { (my_group.size() > 1) }
  pause 3

  bs.lead(my_group)
elsif (Script.current.vars[1] =~ /tail|follow|link/i)
  # Watch for rally
  group = nil
  bs = nil
  uri = nil

  while (group.nil? && bs.nil?)
    if Script.current.vars[1] =~ /link/i && Script.current.vars[2].nil?
      echo "Must supply target URI when using LINK option"
      exit
    end
    echo "waiting for rally" if $bigshot_debug
    if Script.current.vars[1] =~ /link/i
      uri = Script.current.vars[2]
    end
    if (!uri.nil? || get =~ /rallying at (.*)\."$/)
      uri = uri.nil? ? Regexp.last_match(1) : uri
      fput "whisper ooc group Bigshot rallying at #{uri}" unless Script.current.vars[1] =~ /link/i
      # create group
      DRb.start_service()

      group = DRbObject.new(nil, uri)

      # create Bigshot
      bs = Bigshot.new(Script.current.vars)
      group.add_member(bs)
      bs.keep_awake()
      bs.companion_check()
      bs.npc_room_check()
    end
  end

  # Participate
  bs.message("yellow", " Joined group")
  leader = group.leader.name

  $bigshot_overkill_counter = 0

  bs.groupcheck() if !checkpcs.nil?
  echo " Groupcheck done" if $bigshot_debug

  while (!dead?)

    begin
      bs.change_stance('defensive')
      bs.stand() if !standing? && $looting_inactive
      sleep(0.25)

      # grab event
      event = bs.event_stack.size == 0 ? nil : bs.grab_event
      next if event.nil?

      if bs.event_stack.any? { |a| [:LOOT, :FINAL_LOOT].include?(a.type) }
        if group.looter == Char.name
          $looting_inactive = false
        end
      end

      # kertwang!
      if [:FOLLOW_NOW, :ATTACK].include?(event.type)
        unless checkpcs.include?(leader)
          is_joined = false
          until (checkpcs.include?(leader)) && is_joined
            break if Char.name == leader

            bs.go2(group.room_id)
            bs.groupcheck()

            if $grouplist.include?(leader) && checkpcs.include?(leader)
              is_joined = true
            else
              fput "join #{leader}"
              sleep 0.5
            end
          end
        end
      end

      # process event
      events_to_skip = [:FOLLOWER_OVERKILL, :PREP_REST, :DISPLAY_WATCH, :START_WATCH, :STOP_WATCH, :CHECK_MIND, :FOLLOW_NOW, :GO2_RALLY_ROOM, :GO2_HUNTING_ROOM, :CHECK_SNEAKY]
      bs.message("yellow", " Event: " + event.type.to_s) unless events_to_skip.include?(event.type)
      if (event.type == :HUNTING_PREP_COMMANDS)
        bs.HUNTING_PREP_COMMANDS.each { |i|
          if i =~ /^script\s+(.*?)(\s|$)(.*)/i
            bs.cmd_run_script($1, $3)
          else
            fput(i)
          end
        }
      elsif (event.type == :JOIN_LEADER)
        next if Char.name == leader

        bs.go2(group.room_id) until checkpcs.include?(leader)
        bs.groupcheck()

        until $grouplist.include?(leader)
          dothistimeout("join #{leader}", 3, /You are already a member|You join/)
          bs.groupcheck()
        end
      elsif (event.type == :LEAVE_GROUP)
        dothistimeout('leave group', 1, /You leave|But you are not in a group/)
      elsif (event.type == :CHECK_SNEAKY)
        next if Char.name == leader
        bs.cmd_hide(1) if bs.sneaky_hunt? && !hidden
      elsif (event.type == :GO2_RALLY_ROOM)
        rally_rooms = group.rally_ids
        rally_rooms.each { |place|
          bs.go2(place) until (Room.current.id == place.to_i)
        }
      elsif (event.type == :GO2_HUNTING_ROOM)
        until (Room.current.id == group.hunting_id)
          bs.go2(group.hunting_id)
        end
      elsif (event.type == :SINGLE_STOP)
        bs.message("yellow", " Stopping: Bigshot set to single loop")
        bs.single_stop()
      elsif (event.type == :FOLLOWER_OVERKILL)
        bs.use_lte_boost()
      elsif (event.type == :CAST_SIGNS)
        bs.cast_signs()
      elsif (event.type == :HUNTING_SCRIPTS_START)
        bs.run_scripts(bs.HUNTING_SCRIPTS, false)
      elsif (event.type == :ATTACK)
        if (event.stale?) # consider timestamp and room_id
          bs.message("yellow", " Skipping attack because it's stale")
          next
        end

        stop_attack = false
        target = nil
        while (!stop_attack)
          stop_attack = event.stale?
          while ((target = bs.find_target(target)) && !stop_attack)
            if (bs.event_stack.any? { |a| a.type == :PREP_REST })
              bs.message("yellow", " Preparing to move, skipping attack")
              stop_attack = true
              break
            end
            if bs.event_stack.any? { |a| [:LOOT, :FINAL_LOOT].include?(a.type) }
              if group.looter == Char.name
                $looting_inactive = false
              end
            end

            target = bs.find_target(nil) if !$bigshot_bandits && @PRIORITY && !bs.priority(target)
            bs.attack(target)

            bs.escape_rooms

            stop_attack = bs.should_rest?
          end
          break if stop_attack

          stop_attack = bs.event_stack.any? { |a| a.type == :PREP_REST }
          sleep(0.3)
        end
      elsif (event.type == :CHECK_MIND)
        next if Char.name == leader
        lines = Lich::Util.quiet_command_xml("experience", /<output class="mono"\/>/)

        if lines.any? { |l| l =~ /Field Exp\:\s*([0-9,]+)\/([0-9,]+)/i }
          in_bucket = $1.delete(",").to_f
          max_bucket = $2.delete(",").to_f
        end

        actual_percent = (in_bucket / max_bucket) * 100

        if actual_percent.nil?
          bs.CORRECT_PERCENT_MIND = percentmind()
        else
          bs.CORRECT_PERCENT_MIND = actual_percent
        end
      elsif (event.type == :PREP_REST)
        bs.prepare_for_movement()
      elsif (event.type == :FOG_RETURN)
        bs.fog_return
      elsif (event.type == :GO2_WAYPOINTS)
        fput('unhide') if (hidden? || invisible?)
        waypoint_rooms = group.return_waypoints_ids
        waypoint_rooms.each { |place|
          bs.go2(place) until (Room.current.id == place.to_i)
        }
      elsif (event.type == :GO2_RESTING_ROOM)
        until (Room.current.id == group.resting_id)
          bs.go2(group.resting_id)
        end
      elsif (event.type == :LOOT)
        if group.looter == Char.name
          $looting_inactive = false
          bs.loot
          sleep 0.5
          $looting_inactive = true
        end
      elsif (event.type == :FINAL_LOOT)
        if group.looter == Char.name
          $looting_inactive = false
          bs.loot_dead
          sleep 0.5
          $looting_inactive = true
        end
      elsif (event.type == :HUNTING_SCRIPTS_STOP)
        bs.croak_scripts(bs.HUNTING_SCRIPTS)
      elsif (event.type == :RESTING_PREP_COMMANDS)
        $bigshot_should_rest = false # need to reset this
        $bigshot_overkill_counter = 0
        next if Char.name == leader

        bs.RESTING_COMMANDS.each { |i| fput(i) }

      elsif (event.type == :RESTING_SCRIPTS_START)
        next if Char.name == leader

        bs.run_scripts(bs.RESTING_SCRIPTS, true)
      elsif (event.type == :START_WATCH)
        bs.START_TIME = Time.now.to_i
      elsif (event.type == :STOP_WATCH)
        bs.STORED_TIMES.push(Time.now.to_i - bs.START_TIME)
        bs.START_TIME = 0
      elsif (event.type == :DISPLAY_WATCH)
        next if Char.name == leader

        if (event.stale?)
          bs.message("yellow", " Skipping display_watch because it's stale")
          next
        end
        fput 'exp'
        sleep 0.2

        bs.display_watch()
        bs.message("yellow", "Bigshot last rested because: #{$rest_reason}") if $rest_reason
        bs.message("yellow", "Bigshot isn't hunting because: #{$not_hunting_reason}") if $not_hunting_reason
        _respond
      elsif (event.type == :CUSTOM_PUT)
        bs.group_put(event.cmd_input)
      elsif (event.type == :CUSTOM_CMD)
        bs.group_cmd(event.cmd_input)
      elsif (event.type == :CUSTOM_DO_CLIENT)
        bs.group_do(event.cmd_input)
      elsif (event.type == :PUBLIC_SEND)
        echo "SENT: #{bs.public_send(event.cmd_input) if bs.respond_to? event.cmd_input}"
      end
    rescue
      fput 'leave group'
      if (bs.RESTING_ROOM_ID && bs.RESTING_ROOM_ID != 4)
        start_script('go2', [bs.RESTING_ROOM_ID, '_disable_confirm_'])
        wait_while { running?('go2') }
      end
      echo "Fatal exception!"
      echo $!.to_s
      echo $!.backtrace.join("\n")
      Script.self.kill
    end
  end
end
