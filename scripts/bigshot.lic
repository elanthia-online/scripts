=begin

  bigshot.lic: the new optimus prime

  hunting script for hunting

        author: elanthia-online
  contributors: SpiffyJr, Tillmen, Kalros, Hazado, Tysong, Athias, Falicor
          game: Gemstone
          tags: hunting
       version: 4.8.1
      requires: Lich >= 5.3.0

  Setup instructions: https://gswiki.play.net/Script_Bigshot
  To help contribute: https://github.com/elanthia-online/scripts
  Full Changelog: https://gswiki.play.net/Script_Bigshot_Changelog

  Version Control:
    Major_change.feature_addition.bugfix

  v4.8.1 (2022-03-07)
    Added version check for Lich due to new Effects/Cmans

  v4.8.0 (2022-03-07)
    Integrated weapon/shield/cman skills and warcries.
    barrage(!barrage) will only barrage if you don't have the buff
    bellow all, will aoe bellow vs bellow target, will single target bellow

  v4.7.7 (2022-03-02)
    Add option to Stop for Deaders on Hunting tab
    When enabled, bigshot will PAUSE when it encounters a dead player

  v4.7.6 (2022-03-02)
    Updated Fog options to include Sigil of Escape

  v4.7.5 (2022-02-02)
    Updated needs bless logic to to remove false positives (most cases)

  v4.7.4 (2022-01-29)
    Updated target logic to ignore sorcerer animates.
    Updated loot subroutine to flag looting active - prevent BS from forcing stand

  v4.7.3 (2022-01-25)
    Updated bless routines to current text and provide option to continue hunt.
    Disabled default startup sound value. Uncomment print "\a" unless $bigshot_quick if function is desired.

  v4.7.2 (2021-12-14)
    Updated GTK version detection for proper display in dark-mode

  v4.7.1 (2021-12-12)
     Adding bigshot single run mode accessed via ;bigshot single

  v4.7.0 (2021-01-01)
    -Rallypoints added
    -Support for weapon reactions
    BUGFIX:Bigshot monitor moved to pre_hunt() routine to resolve poaching edge case
    BUGFIX:Group logic updates for use by external scripts
    BUGFIX:Adrenal Surge for empaths

  v4.6.1 (2021-08-11)
    -Updated group and event namespace to prevent future conflicts
    -Consolidated Changelog and updated it on the GS wiki
    -Added warning for older Ruby versions

  v4.6.0 (2021-08-06)
    -Separated bigshot_monitor to only run while hunting (to resolve lag in very active rooms)
    -Added initial automatic weapon reactions

  v4.5.0 (2021-06-25)
    -Add fog only if encumbered or injured checkbox

  v4.4.0 (2021-06-25)
    -Add flee from voids option to general tab

=end
=begin
    To do:
      Add more messaging for ambush checks (snipe, etc.)
      Add Stun Relief (108)|Undisease (113)|Unpoison (114) option for stunned group members
      Add Hand of Tonis to dismiss clouds
      Group logic for familiars/companions
      UCS will frequently use the last '$bigshot_unarmed_followup_attack', needs to be cleared
      Need support for tracking multiple NPC positioning tiers for UCS
      Celerity (506) support from grouped wizards for MStrikes
=end

# Compatability for Older Ruby Versions
if $SAFE > 0
  echo "error: This script needs to be trusted to work. (;trust #{script.name})"
  exit
end

# Check version of Lich for compatability
LICH_GEM_REQUIRES = '5.3.0'
if Gem::Version.new(LICH_VERSION) < Gem::Version.new(LICH_GEM_REQUIRES)
   if $frontend == 'stormfront' || $frontend == 'profanity'
     _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{LICH_GEM_REQUIRES}+) to run." + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
     _respond ""
     _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION) }" + "\<\/preset\>"
     _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
     _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
   else
     _respond "##" + "########################################" 
     _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{LICH_GEM_REQUIRES}+) to run." 
     _respond ">" + "Please update to a newer version."
     _respond ">" + ""
     _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION) }"
     _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
     _respond "##" + "########################################"
   end
   exit
end

# Still used until all aspects of GameObjAdd are moved into GameObj.xml properly
unless Script.exists?('GameObjAdd')
  do_client(";repository download GameObjAdd.lic")
  wait_while { running?('repository') }
  do_client(";autostart add --global GameObjAdd")
  wait_while { running?('autostart') }
  sleep(0.5)
  do_client(";autostart add --global repository download-updates")
  wait_while { running?('autostart') }
  sleep(0.5)
  do_client(";repository set-updatable GameObjAdd.lic")
  wait_while { running?('repository') }
  sleep(0.5)
  do_client(";GameObjAdd")
  wait_while { running?('GameObjAdd') }
  sleep(0.5)
end

if UserVars
  # First time running a version with monitor strings that can be specified, set up default values
  if UserVars.op["monitor_strings"].nil?
    UserVars.op["monitor_strings"] = "SEND||POLICY||[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]||speaking to you||unresponsive||taps you||nods to you||lease respond||not in control||violation||lease speak||peak out loud||Y U SHOU D||whispers,||speaking to you||smiles at you||waves to you||grins at you||hugs you||takes hold your hand||grabs your hand||clasps your hand||trying to drag you"
  end

  if UserVars.op["monitor_safe_strings"].nil?
    UserVars.op["monitor_safe_strings"] = "\[(?!Private)\w*\]-GS(?:T|IV):||We've noted a troubling increase in bandit activity recently||inviting you to join||Dreavening"
  end

  UserVars.save
end

# All Requirements
require 'yaml'
require 'drb'

# Alphabetized Global Variables
BIGSHOT_VERSION = '4.8.1'
RALLY_TIME = 1
REST_INTERVAL = 60
$bigshot_1614_list = []
$bigshot_703_list = []
$bigshot_adrenal_surge = Time.now + 301
$bigshot_aim = 0
$bigshot_ambush = 0
$bigshot_arcane_reflex = false
$bigshot_archery_aim = 0
$bigshot_archery_stuck_location = []
$bigshot_archery_location = nil
$bigshot_bandits = false
$bigshot_bless = []
$bigshot_debug = false
$bigshot_flee = false
$bigshot_lte_boost_counter = 0
$bigshot_overkill_counter = 0
$bigshot_quick = false
$bigshot_reaction = nil
$bigshot_should_rest = false
$bigshot_smite_list = []
$bigshot_status = nil
$bigshot_unarmed_followup = false
$bigshot_unarmed_followup_attack = ""
$bigshot_unarmed_tier = 1
$bigshot_wand = 0
$companion ||= nil
$current_script_name = script.name
$current_room_npcs = GameObj.npcs
$familiar = ""
$grouplist = []
$last_loot = nil
$looting_inactive = true
$not_hunting_reason = nil
$rest_reason = nil
$room_npcs_last_check = []
$mstrike_taken = false
$bigshot_single = false

def spam
  def waitcastrt?
    return if Spell[515].active?

    if (XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
      sleep((XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f).abs)
    end
  end

  def waitrt?
    if (XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
      sleep((XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f).abs)
    end
  end
end

def unspam
  def waitcastrt?
    if (XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
      sleep((XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f + "0.6".to_f).abs)
    end
  end

  def waitrt?
    if (XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
      sleep((XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f + "0.6".to_f).abs)
    end
  end
end

def spell_is_selfcast?(spell_id)
  [
    106, 109, 115, 117, 120, 130, 140,
    205, 206, 211, 213, 215, 218, 219, 220, 240,
    303, 307, 310, 313, 314, 319, 350,
    401, 402, 403, 404, 405, 406, 414, 418, 419, 425, 430,
    503, 506, 507, 508, 509, 511, 513, 515, 517, 520, 535, 540,
    601, 602, 604, 605, 606, 608, 612, 613, 617, 618, 620, 625, 630, 640, 650,
    707, 712,
    905, 911, 913, 916, 919,
    1003, 1006, 1007, 1009, 1010, 1011, 1012, 1014, 1017, 1018, 1019, 1020, 1025, 1035, 1040,
    1109, 1119, 1125, 1130, 1150,
    1202, 1204, 1208, 1213, 1214, 1215, 1216, 1220, 1235,
    1601, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1616, 1617, 1618, 1619, 1635
  ].include? spell_id
end

before_dying { unspam() }
before_dying { $bigshot.gather_ammo }

class Bigshot
  class Event
    attr_accessor :type, :created_at, :room_id, :cmd_input

    @@RECOGNIZED = [:HUNTING_PREP_COMMANDS, :HUNTING_SCRIPTS_START, :CAST_SIGNS, :ATTACK, :PREP_REST,
                    :HUNTING_SCRIPTS_STOP, :RESTING_SCRIPTS_START, :RESTING_PREP_COMMANDS, :DISPLAY_WATCH,
                    :FOLLOWER_OVERKILL, :STAY_QUIET, :FOLLOW_NOW, :LOOT, :CUSTOM_PUT, :CUSTOM_CMD, :CUSTOM_DO_CLIENT,
                    :PUBLIC_SEND]

    def initialize(type, time_stamp, room_id, c_in = nil)
      raise "Event type not recognized" unless @@RECOGNIZED.include?(type)

      @type       = type
      @created_at = time_stamp
      @room_id    = room_id
      @cmd_input = c_in
    end

    def stale?
      if (Room.current.id != @room_id || Time.now.to_i - @created_at > 15)
        return true
      else
        return false
      end
    end

    def type
      return @type
    end
  end
end

class Bigshot
  class Group
    include DRbUndumped
    attr_accessor :leader, :members

    def initialize()
      @members = Hash.new
    end

    def set_leader(leader)
      @leader = leader
    end

    def add_member(member)
      @members[member.name()] = member
    end

    def size()
      return @members.size
    end

    def get_names
      return @members.keys + [@leader.name]
    end

    def room_id()
      return @leader.room_id()
    end

    def obv_hide_set(player_present)
      @members.each_pair { |k, v|
        begin
          v.set_obvious_hiding_player(player_present)
        rescue
          @leader.message("Error polling member(obv_hide_set). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def add_event(type)
      @members.each_pair do |k, v|
        begin
          v.add_event(type, Time.now.to_i, Room.current.id)
        rescue
          @leader.message("Error adding #{type.to_s} event to members stack(add_event): #{$!}")
          @leader.message($!.backtrace.join("\n"))
        end
      end
    end

    def has_bounty?(bounty_regex)
      if !bounty_regex.is_a? Regexp
        @leader.message("That's not a Regexp.  Killing Bigshot")
        client_do(";k bigshot")
      end
      @members.each_pair do |k, v|
        begin
          return true if v.cur_bounty =~ bounty_regex
        rescue
          @leader.message("Error polling member(has_bounty?). Removing #{k}!")
          @members.delete(k)
        end
      end
      return false
    end

    def group_assist(should_attack)
      @members.each_pair { |k, v|
        begin
          v.set_help_group(should_attack)
        rescue
          @leader.message("Error polling member(group_assist). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def add_leader_event(event)
      @leader.add_event(Event.new(event)) unless @leader.event_stack.size > 5
    end

    def resting_id()
      return @leader.RESTING_ROOM_ID
    end

    def roundtime?()
      @members.each_pair { |k, v|
        begin
          return true if v.rt? > 0
        rescue
          @leader.message("Error polling member(roundtime?). Removing #{k}!")
          @members.delete(k)
        end
      }
      return false
    end

    # Use this to perform combat actions
    def do_command(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:CUSTOM_CMD, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("Error polling member(do_command). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    # Use this to perform non-combat actions
    def do_put(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:CUSTOM_PUT, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("Error polling member(do_put). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    # Use this to perform perform actions as if they were typed through the client
    def client_do(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:CUSTOM_DO_CLIENT, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("Error polling member(client_do). Removing! #{k}")
          @members.delete(k)
        end
      }
    end

    # Use this to perform perform actions as if they were typed through the client
    def pub_send(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:PUBLIC_SEND, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("Error polling member. Removing!")
          @members.delete(k)
        end
      }
    end

    def clear_group_events()
      @members.each_pair { |k, v|
        begin
          v.clear_events()
        rescue
          @leader.message("Error polling member(clear_group_events). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def should_hunt?()
      emergency = @leader.event_stack.size == 0 ? nil : @leader.event_stack.shift
      if (emergency)
        @leader.clear_events()
        return false
      end

      @members.each_pair { |k, v|
        begin
          return false if !v.should_hunt?
        rescue
          @leader.message("Error polling member(should_hunt?). Removing #{k}!")
          @members.delete(k)
        end
      }
      $bigshot_status = :hunting
      return true
    end

    def group_bandit_hunting(kill_bandits)
      @members.each_pair { |k, v|
        begin
          v.set_bandit_hunting(kill_bandits)
        rescue
          @leader.message("Error polling member(group_bandit_hunting). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def should_rest?()
      @members.each_pair { |k, v|
        begin
          return false if !v.should_rest?
        rescue
          @leader.message("Error polling member(should_rest?). Removing #{k}!")
          @members.delete(k)
        end
      }
      return true
    end

    def any_saturated?
      @members.each_pair do |k, v|
        begin
          return true if v.saturated?
        rescue StandardError
          @leader.message("Error polling member(any_saturated?). Removing #{k}!")
          @members.delete(k)
        end
      end
      false
    end

    def all_present?
      @members.each_pair { |k, v|
        begin
          return false if !checkpcs.include?(k) && k != @leader.name
        rescue
          @leader.message("Error polling member(all_present?). Removing #{k}!")
          @members.delete(k)
        end
      }
      return true
    end

    def emergency_rest?()
      @members.each_pair { |k, v|
        begin
          return true if v.wounded?
        rescue
          @leader.message("Error polling member(emergency_rest). Removing #{k}!")
          @members.delete(k)
        end
      }
      return false
    end
  end
end

class Bigshot
  include DRbUndumped
  attr_accessor :BIRTH_TIME, :START_TIME, :STORED_TIMES, :FRIED, :OOM,
    :SIGNS, :TARGETS, :INVALID_TARGETS, :FLEE_COUNT, :ALWAYS_FLEE_FROM,
    :USE_WRACKING, :AMMO, :AMMO_CONTAINER, :HIDE_FOR_AMMO, :BOON_FLEE_FROM,
    :REST_TILL_EXP, :REST_TILL_MANA, :USE_HERBS, :DEAD_MAN_SWITCH,
    :RESTING_ROOM_ID, :RESTING_COMMANDS, :RESTING_SCRIPTS, :HUNTING_ROOM_ID,
    :RALLYPOINT_ROOM_ID, :HUNTING_BOUNDARIES, :HUNTING_SCRIPTS, :HUNTING_COMMANDS,
    :DISABLE_COMMANDS, :HUNTING_STANCE, :HUNTING_PREP_COMMANDS,
    :MONITOR_INTERACTION, :FLEE_CLOUDS, :FLEE_VINES, :FLEE_WEBS, :FLEE_VOIDS, :WRACKING_SPIRIT,
    :REST_TILL_SPIRIT, :BOUNTY_MODE, :AMBUSH, :ARCHERY_AIM,
    :event_stack, :followers, :BLESS, :AIM, :TIER3, :QUIET_FOLLOWERS,
    :MSTRIKE_COOLDOWN, :MSTRIKE_STAMINA_COOLDOWN, :MSTRIKE_MOB,
    :MSTRIKE_QUICKSTRIKE, :MSTRIKE_STAMINA_QUICKSTRIKE,
    :UAC_MSTRIKE, :WANDER_WAIT, :QUICK_COMMANDS, :PRIORITY,
    :QUICKHUNT_TARGETS, :UAC_SMITE, :FOG_RETURN, :FOG_OPTIONAL, :LOOT_STANCE,
    :DELAY_LOOT, :PULL, :OVERKILL, :LTE_BOOST, :HELP_GROUP_KILL, :WEAPON_REACTION, :DEADER

  PRONE = /sleeping|webbed|stunned|kneeling|sitting|^lying|prone|frozen|held in place/

  BOON_LIST_ADJECTIVES = /^(?:adroit |afflicted |apt |barbed |belligerent |blurry |canny |combative |dazzling |deft |diseased |drab |dreary |ethereal |flashy |flexile |flickering |flinty |frenzied |ghastly |ghostly |gleaming |glittering |glorious |glowing |grotesque |hardy |illustrious |indistinct |keen |lanky |luminous |lustrous |muculent |nebulous |oozing |pestilent |radiant |raging |ready |resolute |robust |rune-covered |shadowy |shielded |shifting |shimmering |shining |sickly green |sinuous |slimy |sparkling |spindly |spiny |stalwart |steadfast |stout |tattooed |tenebrous |tough |twinkling |unflinching |unyielding |wavering |wispy )/

  def hunt_monitor(cur_action)
    bigshot_monitor = proc { |server_string|
      if !$bigshot_bandits && server_string =~ /<a exist="\d+" noun="([a-zA-Z]*?)">[a-zA-Z]*?<\/a> leaps from hiding to attack!/i
        temp = $1
        if !$grouplist.any? { |s| s =~ /#{temp}/i }
          $ambusher_here = true
        end
      elsif !$bigshot_bandits && server_string =~ /flies out of the shadows toward|A shadowy figure leaps from hiding to attack/i
        if $grouplist.size == 0
          $ambusher_here = true
        end
      elsif server_string =~ /^You could use this opportunity to <d cmd='WEAPON (\w+\s#\d+)'>.*<\/d>!/i
        $bigshot_reaction = $1
	  elsif server_string =~ /^Vital energy infuses you, hastening your arcane reflexes!/i
	    $bigshot_arcane_reflex = true
	  elsif server_string =~ /^Nature's blessing of vitality departs as your arcane prowess returns to normal./i
	    $bigshot_arcane_reflex = false
      elsif server_string =~ /obvious signs of someone hiding/i
        $obvious_hiding_player = true
      elsif server_string =~ /crimson mist.*?surround.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:corporeal plane!|vulnerable!)/i
        $bigshot_smite_list.push($1)
      elsif server_string =~ /crimson mist.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:returns to an ethereal state.|appears less vulnerable.)/i
        $bigshot_smite_list.delete($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?is suddenly surrounded by a blood red haze./i
        $bigshot_703_list.push($1)
      elsif server_string =~ /The blood red haze dissipates from around.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?\./i
        $bigshot_703_list.delete($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:visibly struggling against|in awe of) your radiant aura!/i
        $bigshot_1614_list.push($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?recovers from being rebuked/i
        $bigshot_1614_list.delete($1)
      elsif server_string =~ /The.*sticks in.*\'s (.*)\!/i
        $bigshot_archery_stuck_location.push($1)
      elsif server_string =~ /You're now aiming at the (.*) of/i
        $bigshot_archery_location = $1
      elsif server_string =~ /You're now no longer aiming at anything in particular/i
        $bigshot_archery_location = nil
      elsif server_string =~ /The <a exist="(.*?)" noun="(.*?)">.*?<\/a> strikes? true.* shrugs off some of the damage!/i
        my_id = $1.dup
        my_noun = $2.dup
        my_item = GameObj.inv.find { |i| i.id == "#{my_id}" }
        if @AMMO == "#{my_noun}" || my_item || (checkright || checkleft ) == "#{my_noun}"
          $bigshot_bless.push(my_id) if !$bigshot_bless.include?(my_id)
        end
      elsif server_string =~ /Your <a exist="(.*?)" noun=".*?">.*?<\/a> returns? to normal\./i
        $bigshot_bless.push($1)
      elsif server_string =~ /^You bolt/i
        $ambusher_here = false
        $bigshot_smite_list = []
        $bigshot_aim = 0
        $bigshot_ambush = 0
        $bigshot_archery_aim = 0
        $bigshot_archery_stuck_location = []
        $bigshot_unarmed_tier = 1
        $bigshot_unarmed_followup = false
        $bigshot_unarmed_followup_attack = ""
        $bigshot_703_list = []
        $bigshot_1614_list = []
        $bigshot_flee = false
        $obvious_hiding_player = false
        $bigshot_reaction = nil
      elsif server_string =~ /#{UserVars.op["flee_message"]}/i && UserVars.op["flee_message"] != ""
        $bigshot_flee = true
      end
      server_string
    }

    DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    before_dying { DownstreamHook.remove("#{$current_script_name}_monitor") }

    if cur_action == "start"
      echo "starting bigshot_monitor" if $bigshot_debug
      DownstreamHook.add("#{$current_script_name}_monitor", bigshot_monitor)
    elsif cur_action == "stop"
      echo "removing bigshot_monitor" if $bigshot_debug
      DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    else
      echo "removing bigshot_monitor" if $bigshot_debug
      DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    end
  end

  def add_event(type, time_stamp, room_id, c_in = nil)
    echo "add_event" if $bigshot_debug
    unless (@event_stack.size > 5 && type == :ATTACK)
      if (type == :FOLLOWER_OVERKILL)
        add_overkill()
        @event_stack.push(Event.new(type, time_stamp, room_id, c_in)) unless (@event_stack.any? { |a| a.type == type })
      else
        @event_stack.push(Event.new(type, time_stamp, room_id, c_in))
      end
    end
  end

  def grab_event()
    echo "grab_event" if $bigshot_debug
    @event_stack.shift()
  end

  def clear_events()
    echo "clear_events" if $bigshot_debug
    @event_stack.clear
  end

  def initialize(bounty_mode = nil)
    echo "initialize" if $bigshot_debug
    $bigshot = self
    @HELP_GROUP_KILL = true
    if bounty_mode
      @BOUNTY_MODE = true
    end

    UserVars.op ||= Hash.new
    CharSettings['targetable']   ||= Array.new
    CharSettings['untargetable'] ||= Array.new
    @BIRTH_TIME   = Time.now.to_i
    @START_TIME   = 1
    @STORED_TIMES = Array.new

    @followers = nil
    @event_stack = Array.new

    load_settings()
    dead_man_switch()

    # this is mainly for azbounty:
    before_dying {
      @HUNTING_SCRIPTS.each { |i|
        echo "Cleaning up hunting scripts: #{i}."
        stop_script(i) if running?(i)
      }
    }
  end

  def load_settings()
    set_value_required('hunting_commands',  'split_xx')
    set_value_required('fried',             'to_i')
    set_value_required('oom',               'to_i')
    set_value_required('rest_till_mana',    'to_i')
    set_value_required('rest_till_exp',     'to_i')

    set_value('hunting_room_id',              'to_i',      4)
    set_value('rallypoint_room_id',           'to_i',      -5)
    set_value('resting_room_id',              'to_i',      4)
    set_value('hunting_boundaries',           'split',     Array.new)
    set_value('hunting_commands_b',           'split_xx',  Array.new)
    set_value('hunting_commands_c',           'split_xx',  Array.new)
    set_value('hunting_commands_d',           'split_xx',  Array.new)
    set_value('hunting_commands_e',           'split_xx',  Array.new)
    set_value('hunting_commands_f',           'split_xx',  Array.new)
    set_value('hunting_commands_g',           'split_xx',  Array.new)
    set_value('hunting_commands_h',           'split_xx',  Array.new)
    set_value('hunting_commands_i',           'split_xx',  Array.new)
    set_value('hunting_commands_j',           'split_xx',  Array.new)
    set_value('disable_commands',             'split_xx',  Array.new)
    set_value('quick_commands',               'split_xx',  Array.new)
    set_value('targets',                      'targets',   nil)
    set_value('quickhunt_targets',            'targets',   nil)
    set_value('dead_man_switch',              '',          false)
    set_value('monitor_interaction',          '',          false)
    set_value('monitor_strings',              'split',     Array.new)
    set_value('monitor_safe_strings',         'split',     Array.new)
    set_value('depart_switch',                '',          false)
    set_value('encumbered',                   'to_i',      200)
    set_value('signs',                        'split',     Array.new)
    set_value('spam',                         '',          true)
    set_value('flee_count',                   'to_i',      10)
    set_value('wracking_spirit',              'to_i',      0)
    set_value('invalid_targets',              'split',     Array.new)
    set_value('always_flee_from',             'split',     Array.new)
    set_value('boon_flee_from',               '',          false)
    set_value('flee_message',                 '',          nil)
    set_value('flee_clouds',                  '',          false)
    set_value('flee_vines',                   '',          false)
    set_value('flee_webs',                    '',          false)
    set_value('flee_voids',                   '',          false)
    set_value('use_wracking',                 '',          false)
    set_value('lone_targets_only',            '',          false)
    set_value('rest_till_spirit',             'to_i',      0)
    set_value('ammo',                         '',          nil)
    set_value('ammo_container',               '',          nil)
    set_value('fresh_wand_container',         '',          nil)
    set_value('dead_wand_container',          '',          nil)
    set_value('wand',                         'split',     nil)
    set_value('wand_if_oom',                  '',          false)
    set_value('hide_for_ammo',                '',          nil)
    set_value('wounded_eval',                 '',          nil)
    set_value('resting_scripts',              'split',     Array.new)
    set_value('hunting_scripts',              'split',     Array.new)
    set_value('loot_script',                  '',          nil)
    set_value('hunting_stance',               '',          'defensive')
    set_value('resting_commands',             'split_xx',  Array.new)
    set_value('hunting_prep_commands',        'split_xx',  Array.new)
    set_value('mstrike_mob',                  'to_i',      2)
    set_value('mstrike_cooldown',             '',          nil)
    set_value('mstrike_stamina_cooldown',     'to_i',      maxstamina)
    set_value('mstrike_quickstrike',          '',          nil)
    set_value('mstrike_stamina_quickstrike',  'to_i',      maxstamina)
    set_value('aim',                          'split',     Array.new)
    set_value('ambush',                       'split',     Array.new)
    set_value('archery_aim',                  'split',     Array.new)
    set_value('tier3',                        '',          'punch')
    set_value('bless',                        '',          nil)
    set_value('uac_smite',                    '',          false)
    set_value('wander_wait',                  'to_f',      0.3)
    set_value('priority',                     '',          false)
    set_value('fog_return',                   '',          nil)
    set_value('fog_optional',                 '',          false)
    set_value('loot_stance',                  '',          false)
    set_value('delay_loot',                   '',          false)
    set_value('pull',                         '',          true)
    set_value('deader',                         '',        true)
    set_value('overkill',                     'to_i',      0)
    set_value('lte_boost',                    'to_i',      0)
    set_value('quiet_followers',              '',          true)
    set_value('weapon_reaction',              '',          true)
  end

  def clean_value(clean, value)
    if (clean == 'to_i')
      return value.to_i
    elsif (clean == 'to_f')
      return value.to_f
    elsif (clean == 'split')
      return value.split(/,\s*/)
    elsif (clean == 'split_xx')
      cleaned = Array.new
      value.split(/,\s*/).each { |i|
        rep = 1
        cmd = ''
        if (i =~ /(.*)\(x(\d+)\)$/i)
          rep = $2.to_i
          cmd = $1
        elsif (i =~ /(.*)\(xx\)/i)
          rep = 5
          cmd = $1
        else
          cmd = i
        end
        and_tokens = cmd.split(/\sand\s/)
        cmd = and_tokens.size == 1 ? and_tokens[0] : and_tokens
        rep.times do cleaned.push(cmd) end
      }
      return cleaned
    elsif (clean == 'targets')
      targets = Hash.new
      tokens = value.split(/,/)
      tokens.each do |i|
        if (i =~ /(.*)\(([a|b|c|d|e|f|g|h|i|j|A|B|C|D|E|F|G|H|I|J])\)/)
          targets[$1.downcase.strip] = $2.downcase.strip
        else
          targets[i.downcase.strip] = 'a'
        end
      end
      return targets
    else
      return value
    end
  end

  def set_value(key, clean, default)
    if (!UserVars.op[key].nil? && UserVars.op[key] !~ /^\s*$/)
      cleaned = clean_value(clean, UserVars.op[key])
      instance_variable_set("@#{key.upcase}", cleaned)
    else
      instance_variable_set("@#{key.upcase}", default)
    end
  end

  def set_value_required(key, clean)
    if (!UserVars.op[key].nil? && UserVars.op[key] !~ /^\s*$/)
      set_value(key, clean, nil)
    else
      message("ERROR: Missing required setting: #{key}")
      message("  Current Settings:")
      message("               fried:\t#{@FRIED}")
      message("                 oom:\t#{@OOM}")
      message("      rest_till_mana:\t#{@REST_TILL_MANA}")
      message("       rest_till_exp:\t#{@REST_TILL_EXP}")
      message("    hunting_commands:\t#{@HUNTING_COMMANDS}")
      Script.self.kill
    end
  end

  def cmd(command, npc = nil, stance_dance = true)
    echo "cmd #{command}" if $bigshot_debug
    GameObj.pcs.each { |s| if s.status =~ /kneeling|sitting|^lying|prone/; fput "pull #{s.noun}"; end; } if GameObj.npcs.any? { |s| s.type =~ /aggressive npc/ } && @PULL
    
    if GameObj.pcs.any? { |s| s.status =~ /dead/ } && @DEADER
      puts "#{monsterbold_start} Found a deader! #{monsterbold_end}"
      echo "PAUSING SCRIPT"
      echo ";u bigshot"
      echo "TO CONTINUE"
      pause_script 
    end

    command = command.dup

    # Used to escape from Roa'ter swallowing
    if !checkroom("The Belly of the Beast").nil?
      RoaterEscape()
    end

    if (command.class.to_s == 'Array')
      stance_dance = false if command.any? { |j| j =~ /stance/ }
      command.each do |i|
        break if npc.status =~ /dead|gone/ || !GameObj.npcs.any? { |s| s.id == npc.id }

        echo i if $bigshot_debug
        cmd(i, npc, stance_dance)
      end
      return
    end

    # check mana/stamina/health(percentage)/encumbrance/unarmed tiering/mobs in room/target not prone/target undead
    # ! means the inverse/opposite effect
    if (command =~ /(.*)\((.*?(?:s|!s|m|!m|h|!h|e|!e|v|!v|tier|!tier|mob|!mob|prone|!prone|undead|!undead|flying|!flying|hidden|!hidden|poison|!poison|disease|!disease|noncorporeal|!noncorporeal|pcs|!pcs|outside|!outside|barrage|!barrage|fury|!fury|flurry|!flurry|pummel|!pummel|thrash|!thrash|reflex|!reflex|vigor|!vigor|shout|!shout|yowlp|!yowlp).*?)\)$/i)
      command = $1
      commandcheckreturn = false
      $2.split(" ").each { |s|
        if s =~ /((?:s|!s|m|!m|h|!h|e|!e|v|!v|tier|!tier|mob|!mob))(\d+)/i
          if ($1 == 's')
            commandcheckreturn = true if !checkstamina($2.to_i)
          elsif ($1 == '!s')
            commandcheckreturn = true if checkstamina($2.to_i)
          elsif ($1 == 'm')
            commandcheckreturn = true if !checkmana($2.to_i)
          elsif ($1 == '!m')
            commandcheckreturn = true if checkmana($2.to_i)
          elsif ($1 == 'v')
            commandcheckreturn = true if !checkspirit($2.to_i)
          elsif ($1 == '!v')
            commandcheckreturn = true if checkspirit($2.to_i)
          elsif ($1 == 'h')
            commandcheckreturn = true if !percenthealth($2.to_i)
          elsif ($1 == '!h')
            commandcheckreturn = true if percenthealth($2.to_i)
          elsif ($1 == 'e')
            commandcheckreturn = true if !checkencumbrance($2.to_i)
          elsif ($1 == '!e')
            commandcheckreturn = true if checkencumbrance($2.to_i)
          elsif ($1 == 'tier')
            commandcheckreturn = true if $bigshot_unarmed_tier < $2.to_i
          elsif ($1 == '!tier')
            commandcheckreturn = true if $bigshot_unarmed_tier > $2.to_i
          elsif ($1 == 'mob')
            mobcheck = $2
            commandcheckreturn = true if GameObjNpcCheck() < mobcheck.to_i
          elsif ($1 == '!mob')
            mobcheck = $2
            commandcheckreturn = true if GameObjNpcCheck() > mobcheck.to_i
          end
         elsif s =~ /((?:prone|!prone|undead|!undead|flying|!flying|hidden|!hidden|poison|!poison|disease|!disease|noncorporeal|!noncorporeal|pcs|!pcs|outside|!outside|barrage|!barrage|fury|!fury|flurry|!flurry|pummel|!pummel|thrash|!thrash|reflex|!reflex|vigor|!vigor|shout|!shout|yowlp|!yowlp))/i
          if ($1 == 'prone')
            commandcheckreturn = true if npc.status =~ PRONE
          elsif ($1 == '!prone')
            commandcheckreturn = true if npc.status !~ PRONE
          elsif ($1 == 'undead')
            commandcheckreturn = true if !npc.type.split(',').any? { |a| a == "undead" }
          elsif ($1 == '!undead')
            commandcheckreturn = true if npc.type.split(',').any? { |a| a == "undead" }
          elsif ($1 == 'flying')
            commandcheckreturn = true if !npc.status.include?("flying")
          elsif ($1 == '!flying')
            commandcheckreturn = true if npc.status.include?("flying")
          elsif ($1 == 'hidden')
            commandcheckreturn = true if !hiding?
          elsif ($1 == '!hidden')
            commandcheckreturn = true if hiding?
          elsif ($1 == 'poison')
            commandcheckreturn = true if !checkpoison?
          elsif ($1 == '!poison')
            commandcheckreturn = true if checkpoison?
          elsif ($1 == 'disease')
            commandcheckreturn = true if !checkdisease?
          elsif ($1 == '!disease')
            commandcheckreturn = true if checkdisease?
          elsif ($1 == 'noncorporeal')
            commandcheckreturn = true if !npc.type.split(',').any? { |a| a == "noncorporeal" }
          elsif ($1 == '!noncorporeal')
            commandcheckreturn = true if npc.type.split(',').any? { |a| a == "noncorporeal" }
          elsif ($1 == 'pcs')
            commandcheckreturn = true if !((checkpcs - $grouplist).count > 0)
          elsif ($1 == '!pcs')
            commandcheckreturn = true if ((checkpcs - $grouplist).count > 0)
          elsif ($1 == 'outside')
            commandcheckreturn = true if !outside?
          elsif ($1 == '!outside')
            commandcheckreturn = true if outside?
          #Check for buffs to perform actions. May have delay due to the way updates are sent but should only be noticed on fast paced buffs like arcane reflex.
		  elsif ($1 == 'barrage')
		    commandcheckreturn = true if !Effects::Buffs.active?("Enh. Dexterity (+10)")#untested.. imo
		  elsif ($1 == '!barrage')
		    commandcheckreturn = true if Effects::Buffs.active?("Enh. Dexterity (+10)")#works
		  elsif ($1 == 'fury')
		    commandcheckreturn = true if !Effects::Buffs.active?("Enh. Constitution (+10)")#untested
		  elsif ($1 == '!fury')
		    commandcheckreturn = true if Effects::Buffs.active?("Enh. Constitution (+10)")#untested
		  elsif ($1 == 'flurry')
		    commandcheckreturn = true if !Effects::Buffs.active?("Slashing Strikes")#untested
		  elsif ($1 == '!flurry')
		    commandcheckreturn = true if Effects::Buffs.active?("Slashing Strikes")#untested
		  elsif ($1 == 'pummel')
		    commandcheckreturn = true if !Effects::Buffs.active?("Concussive Blows")#untested
		  elsif ($1 == '!pummel')
		    commandcheckreturn = true if Effects::Buffs.active?("Concussive Blows")#untested
		  elsif ($1 == 'thrash')
		    commandcheckreturn = true if !Effects::Buffs.active?("Forceful Blows")#untested
		  elsif ($1 == '!thrash')
		    commandcheckreturn = true if Effects::Buffs.active?("Forceful Blows")#untested
		  elsif ($1 == 'reflex')
		    #commandcheckreturn = true if !Effects::Buffs.active?("Nature's Touch Arcane Ref")#untested
			commandcheckreturn = true if $bigshot_arcane_reflex != true #untested
		  elsif ($1 == '!reflex')
		    #commandcheckreturn = true if Effects::Buffs.active?("Nature's Touch Arcane Ref")#untested
			commandcheckreturn = true if $bigshot_arcane_reflex != false #untested
		  elsif ($1 == 'vigor')
		    commandcheckreturn = true if !Effects::Buffs.active?('Tangleweed Vigor')#untested
		  elsif ($1 == '!vigor')
		    commandcheckreturn = true if Effects::Buffs.active?('Tangleweed Vigor')#untested
		  elsif ($1 == 'shout')
		    commandcheckreturn = true if !Effects::Buffs.active?('Empowered (+20)')#untested
		  elsif ($1 == '!shout')
		    commandcheckreturn = true if Effects::Buffs.active?('Empowered (+20)')#untested
		  elsif ($1 == 'yowlp')
		    commandcheckreturn = true if !Effects::Buffs.active?("Yertie's Yowlp")#untested
		  elsif ($1 == '!yowlp')
		    commandcheckreturn = true if Effects::Buffs.active?("Yertie's Yowlp")#untested
          end
        end
      }
      return if commandcheckreturn
    end

    if (command =~ /force\s+(.*)\s+(?:till|until)\s+(\d+)/i)
      cmd_force($1, $2.to_i, npc)
      return
    end

    # sub id
    command.gsub!(/target/, "##{npc.id}") if !npc.nil?

    # Soothe routine
    if Spell[1201].known? && Spell[1201].affordable?
      if (Spell[201].active? || Spell[216].active? || Spell[1015].active? || Spell[1016].active? || Spell[1108].active? || Spell[1120].active?)
        waitrt?
        waitcastrt?
        Spell[1201].cast
      end
    end

    cmd_bless() if @BLESS && $bigshot_bless.count > 0

    # waitrt/waitcastrt
    unless (command =~ /^nudgeweapons?/)
      waitrt?
      waitcastrt? if command =~ /^\d+|incant/
    end

    # Celerity (506) routine
    if (command =~ /^(celerity|haste|506)\s+(.*)/i)
      command = $2
      if Spell[506].known? and Spell[506].affordable?
        if (Spell[506].active? and Spell[506].timeleft <= 0.05) || (!Spell[506].active?)
          Spell[506].cast
        end
      end
    end

    # change_stance
    stand(command) if !standing?
    unless (command =~ /^(?:\d+|wait|sleep|wand|berserk|script|hide|nudgeweapon)/)
      change_stance(@HUNTING_STANCE) if stance_dance
    end

    return if (npc && !valid_target?(npc)) or npc.status =~ /dead|gone/
    return if @PRIORITY && !priority(npc)

    if (command =~ /^(incant)?\s?(\d+)\s?((?:open|closed)?\s?(?:cast|channel|evoke)?\s?(?:cast|channel|evoke)?\s?(?:open|closed)?\s?(?:air|earth|fire|lightning|water|cold)?)?.*$/i)
      cmd_spell($1, $2.to_i, $3, npc)
    elsif (command =~ /^throw/i)
      cmd_throw(npc)
    elsif (command =~ /^k?weed/i)
      cmd_weed(command, npc)
    elsif (command =~ /^wand/i)
      cmd_wand(npc)
    elsif (command =~ /^hide/i)
      cmd_hide()
    elsif (command =~ /^mstrike/i)
      cmd_mstrike(command, npc)
    elsif (command =~ /^fire/i)
      cmd_ranged(npc)
    elsif (command =~ /^barrage/i)
	  cmd_barrage(npc)
	elsif (command =~ /^charge/i)
	  cmd_charge(npc)
	elsif (command =~ /^clash/i)
	  cmd_clash(npc)
	elsif (command =~ /^cripple/i)
	  cmd_cripple(npc)
	elsif (command =~ /^cyclone/i)
	  cmd_cyclone(npc)
	elsif (command =~ /^dizzyingswing/i)
	  cmd_dizzyingswing(npc)
	elsif (command =~ /^flurry/i)
	  cmd_flurry(npc)
	elsif (command =~ /^fury/i)
	  cmd_fury(npc)
	elsif (command =~ /^gthrusts/i)
	  cmd_gthrusts(npc)
	elsif (command =~ /^pindown/i)
	  cmd_pindown(npc)
	elsif (command =~ /^pin down/i)
	  cmd_pindown(npc)
	elsif (command =~ /^pulverize/i)
	  cmd_pulverize(npc)  
	elsif (command =~ /^pummel/i)
	  cmd_pummel(npc)
	elsif (command =~ /^radialsweep/i)
	  cmd_radialsweep(npc)
	elsif (command =~ /^thrash/i)
	  cmd_thrash(npc)
	elsif (command =~ /^twinhammer/i)
	  cmd_twinhammer(npc)
	elsif (command =~ /^volley/i)
	  cmd_volley(npc)
	elsif (command =~ /^wblade/i)
	  cmd_wblade(npc)
	elsif (command =~ /^whirlwind/i)
	  cmd_whirlwind(npc)
	elsif (command =~ /^shield throw/i)
	  cmd_shieldthrow(npc)
	elsif (command =~ /^shield bash/i)
	  cmd_shieldbash(npc)
	elsif (command =~ /^shield charge/i)
	  cmd_shieldcharge(npc)
	elsif (command =~ /^shield strike/i)
	  cmd_shieldstrike(npc)
	elsif (command =~ /^shield pin/i)
	  cmd_shieldpin(npc)
	elsif (command =~ /^shield trample/i)
	  cmd_shieldtrample(npc)
	elsif (command =~ /^shield push/i)
	  cmd_shieldpush(npc)
	elsif (command =~ /^shout/i)
	  cmd_shout()
	elsif (command =~ /^yowlp/i)
	  cmd_yowlp()
	elsif (command =~ /^holler/i)
	  cmd_holler()
	elsif (command =~ /^bellow\s?(\w+)?/i)
	  cmd_bellow($1.to_s,npc)
	elsif (command =~ /^growl\s?(\w+)?/i)
	  cmd_growl($1.to_s,npc)
	elsif (command =~ /^cry\s?(\w+)?/i)
	  cmd_cry($1.to_s,npc)
	elsif (command =~ /^bearhug/i)
	  cmd_bearhug(npc)
	elsif (command =~ /^bullrush/i)
	  cmd_bullrush(npc)
	elsif (command =~ /^coupdegrace/i)
	  cmd_coupdegrace(npc)
	elsif (command =~ /^cpress/i)
	  cmd_cpress(npc)
	elsif (command =~ /^dirtkick/i)
	  cmd_dirtkick(npc)
	elsif (command =~ /^dislodge/i)
	  cmd_dislodge(npc)
	elsif (command =~ /^exsanguinate/i)
	  cmd_exsanguinate(npc)
	elsif (command =~ /^feint/i)
	  cmd_feint(npc)
	elsif (command =~ /^gkick/i)
	  cmd_gkick(npc)
	elsif (command =~ /^hamstring/i)
	  cmd_hamstring(npc)
	elsif (command =~ /^haymaker/i)
	  cmd_haymaker(npc)
	elsif (command =~ /^headbutt/i)
	  cmd_headbutt(npc)
	elsif (command =~ /^leapattack/i)
	  cmd_leapattack(npc)
	elsif (command =~ /^mblow/i)
	  cmd_mblow(npc)
	elsif (command =~ /^scleave/i)
	  cmd_scleave(npc)
	elsif (command =~ /^sattack/i)
	  cmd_sattack(npc)
	elsif (command =~ /^sblow/i)
	  cmd_sblow(npc)
	elsif (command =~ /^sunder/i)
	  cmd_sunder(npc)
	elsif (command =~ /^tackle/i)
	  cmd_tackle(npc)
	elsif (command =~ /^trip/i)
	  cmd_trip(npc)
	elsif (command =~ /^truestrike/i)
	  cmd_truestrike(npc)
	elsif (command =~ /^vaultkick/i)
	  cmd_vaultkick(npc)
	elsif (command =~ /^cutthroat/i)
	  cmd_cutthroat(npc)
	elsif (command =~ /^divert/i)
	  cmd_divert(npc)
	elsif (command =~ /^shroud/i)
	  cmd_shroud()
	elsif (command =~ /^eviscerate/i)
	  cmd_eviscerate(npc)
	elsif (command =~ /^eyepoke/i)
	  cmd_eyepoke(npc)
	elsif (command =~ /^footstomp/i)
	  cmd_footstomp(npc)
	elsif (command =~ /^garrote/i)
	  cmd_garrote(npc)
	elsif (command =~ /^kneebash/i)
	  cmd_kneebash(npc)
	elsif (command =~ /^mug/i)
	  cmd_mug(npc)
	elsif (command =~ /^nosetweak/i)
	  cmd_nosetweak(npc)
	elsif (command =~ /^sbash/i)
	  cmd_sbash(npc)
	elsif (command =~ /^subdue/i)
	  cmd_subdue(npc)
	elsif (command =~ /^spunch/i)
	  cmd_spunch(npc)
	elsif (command =~ /^sweep/i)
	  cmd_sweep(npc)
	elsif (command =~ /^swiftkick/i)
	  cmd_swiftkick(npc)
	elsif (command =~ /^templeshot/i)
	  cmd_templeshot(npc)
	elsif (command =~ /^throatchop/i)
	  cmd_throatchop(npc)
	elsif (command =~ /^sthieve/i)
	  cmd_sthieve(npc)
    elsif (command =~ /^berserk/i)
      cmd_berserk()
    elsif (command =~ /^script\s+(.*?)(\s|$)(.*)/i)
      cmd_run_script($1, $3)
    elsif (command =~ /^sleep\s+(\d+)/i)
      cmd_sleep($1, npc)
    elsif (command =~ /^stance\s+(.*)/i)
      change_stance($1)
    elsif (command =~ /^wait\s+(\d+)/i)
      wait_for_swing($1.to_i, npc)
      $stop_wait = true
    elsif (command =~ /^nudgeweapons?\s*/i)
      cmd_nudge_weapons
    elsif (command =~ /^ambush\s?(.*)?/i)
      cmd_ambush($1, npc)
    elsif (command =~ /^unarmed\s+([a-z]*).?([a-z]*)?$/i)
      unarmed($1, npc, $2)
    elsif (command =~ /^smite/i)
      volnsmite(npc)
    else
      return if $ambusher_here
      return if $obvious_hiding_player

      echo "inside cmd: #{command}" if $bigshot_debug
      bs_put command
    end
  end

  def volnsmite(npc)
    echo "volnsmite" if $bigshot_debug
    while !$bigshot_smite_list.any? { |a| a.to_i == npc.id.to_i } && npc.status !~ /dead|gone/ && GameObj.npcs.any? { |s| s.id == npc.id } && !should_flee? && (npc.type.split(',').any? { |a| a == "undead" } || npc.type.split(',').any? { |a| a == "noncorporeal" })
      res = dothistimeout "smite ##{npc.id}", 1, /^Roundtime|^What were you referring to\?$/
      if res =~ /^What were you referring to\?$/i
        break
      end

      sleep(1)
    end
  end

  def unarmed(command, npc, manualaim)
    echo "unarmed" if $bigshot_debug
    return if npc.status =~ /dead|gone/ || !GameObj.npcs.any? { |s| s.id == npc.id }

    $bigshot_aim = -1 if manualaim != "" && $bigshot_aim == 0
    $mstrike_taken = false
    volnsmite(npc) if !$bigshot_smite_list.any? { |a| a.to_i == npc.id.to_i } && npc.type.split(',').any? { |a| a == "noncorporeal" } && $bigshot_unarmed_tier == 3 && Spell[9821].known? && @UAC_SMITE
    # 9005 - Mstrike recovery
    # 9699 - popped muscles

    # mstrike using Tier3 and auto-tierup
    if @TIER3
      cmd("mstrike #{@TIER3}", npc)
      pause 0.3
    else
      cmd("mstrike #{command}", npc)
      pause 0.3
    end

    if (!$mstrike_taken)
      if $bigshot_unarmed_tier == 3 && $bigshot_unarmed_followup == false # command =~ /jab/ &&
        if manualaim != ""
          cmd("#{@TIER3} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{@TIER3} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{@TIER3} ##{npc.id}", npc)
        end
      elsif $bigshot_unarmed_followup == true
        command = $bigshot_unarmed_followup_attack
        if manualaim != ""
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id}", npc)
        end
      else
        if manualaim != ""
          cmd("#{command} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{command} ##{npc.id}", npc)
        end
      end
    end
    timeNow = Time.now + 5
    while line = get
      if line =~ /You have (decent|good|excellent) positioning/
        tier = $1
        if tier =~ /decent/
          $bigshot_unarmed_tier = 1
        elsif tier =~ /good/
          $bigshot_unarmed_tier = 2
        elsif tier =~ /excellent/
          $bigshot_unarmed_tier = 3
        end
      elsif line =~ /.* = .* d100: .* = \-?(\d+)$/ && $bigshot_unarmed_followup == true
        endroll = $1
        if endroll.to_i > 100
          $bigshot_unarmed_followup = false
        end
      elsif line =~ /Strike leaves foe vulnerable to a followup (.*) attack!/
        $bigshot_unarmed_followup = true
        $bigshot_unarmed_followup_attack = $1
      elsif line =~ /You fail to find an opening for your strike\./
        $bigshot_aim += 1
      elsif line =~ /You cannot aim that high!|is already missing that!/
        $bigshot_aim += 1
        cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
      elsif line =~ /does not have/
        $bigshot_aim += 1
        cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
      elsif line =~ /Roundtime:/i
        $bigshot_aim = 0
        break
      elsif line =~ /^Try standing up first\.$|[wW]ait \d+ sec.*|Sorry,|You can't do that while entangled in a web|You are still stunned|from here\.  Perhaps you should try throwing or shooting something at it\./
        break
      elsif line =~ /You don't seem to be able to move to do that\./
        sleep(2)
        break
      elsif line =~ /You are unable to muster the will to attack anything\.|Your rage causes you to use all of your skill in an all out attack!/
        Spell[1201].cast if Spell[1201].known? && Spell[1201].affordable?
        break
      elsif npc.status =~ /dead|gone/ || !(GameObj.npcs.any? { |s| s.id == npc.id }) || should_flee? || should_rest? || line =~ /You currently have no valid target\.  You will need to specify one\.|^It looks like somebody already did the job for you\.$|What were you referring to/
        $bigshot_unarmed_tier = 1
        $bigshot_unarmed_followup = false
        $bigshot_unarmed_followup_attack = ""
        break
      elsif timeNow < Time.now
        break
      end
    end
    $mstrike_taken = false
  end

  def cmd_bless()
    echo "cmd_bless" if $bigshot_debug
    while $bigshot_bless.count > 0
      if Spell[1604].known? && Spell[1604].affordable?
        waitrt?
        waitcastrt?
        Spell[1604].cast("##{$bigshot_bless[$bigshot_bless.count - 1]}")
      end
      if Spell[304].known? && Spell[304].affordable?
        waitrt?
        waitcastrt?
        Spell[304].cast("##{$bigshot_bless[$bigshot_bless.count - 1]}")
        $bigshot_bless.delete($bigshot_bless[$bigshot_bless.count - 1])
      elsif Spell[9802].known?
        waitrt?
        waitcastrt?
        fput "symbol bless ##{$bigshot_bless[$bigshot_bless.count - 1]}"
        $bigshot_bless.delete($bigshot_bless[$bigshot_bless.count - 1])
      else
        $bigshot_should_rest = true
        $rest_reason = "No blessing on weapon"
        $bigshot_bless = []
        return
      end
    end
  end

  def cmd_throw(npc)
    echo "cmd_throw" if $bigshot_debug
    unless npc.status == 'lying down'
      empty_hands
      dothistimeout "throw ##{npc.id}", 1, /^You attempt to throw a .*\!$/
      waitrt?
      fill_hands
    end
  end

  def cmd_force(force_this, goal, npc)
    echo "cmd_force" if $bigshot_debug
    start = Time.now
    loop {
      cmd(force_this, npc)
      buffer = reget(20)
      buffer.each_with_index { |line, i|
        if (line =~ /^You.*(#{checknpcs.join('|')})|^You feint (high|low|(to the (left|right)))/)
          if (buffer[i + 1] && buffer[i + 1] =~ /== \+(\d+)/) || (buffer[i + 2] && buffer[i + 2] =~ /== \+(\d+)/)
            return if $1.to_i >= goal # spell/swing
          elsif (buffer[i - 1] && buffer[i - 1] =~ /^\[(?:Roll|SMR) result: (\d+)/) || (buffer[i - 2] && buffer[i - 2] =~ /^\[(?:Roll|SMR) result: (\d+)/) || (buffer[i + 1] && buffer[i + 1] =~ /^\[(?:Roll|SMR) result: (\d+)/) || (buffer[i + 2] && buffer[i + 2] =~ /^\[(?:Roll|SMR) result: (\d+)/)
            return if $1.to_i >= goal # cman
          elsif (buffer[i + 1] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/) || (buffer[i + 2] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/)
            return
          end
        elsif (line =~ /^You do not have enough stamina to attempt this maneuver\./)
          return
        elsif (line =~ /^Your magic fizzles ineffectually\./)
          return
        end
      }
      if (force_this =~ /^(\d+) / && !Spell[$1.to_i].affordable?)
        message("Force ran out of mana. Giving up."); return;
      end
      return if GameObj.npcs.size.nil? || GameObjNpcCheck() == 0
      return if should_flee?
      return if should_rest?
      return if npc.status =~ /dead|gone/ || !GameObj.npcs.any? { |s| s.id == npc.id }
      return if (Time.now - start) > 30
    }
  end

  def cmd_weed(command, target)
    echo "cmd_weed" if $bigshot_debug
    return if target.status =~ /dead|gone/ || !GameObj.npcs.any? { |s| s.id == target.id }
    return if GameObj.loot.find { |loot| loot.name =~ /vine|bramble|widgeonweed/ }
    return unless Spell[610].known? and Spell[610].affordable?

    waitcastrt?
    change_stance('offensive') if command == 'kweed'
    Spell[610].cast("##{target.id}")
    change_stance('guarded') if command == 'kweed'
    waitcastrt?
  end

  def cmd_spell(incant = nil, id, extra, target)
    echo "cmd_spell" if $bigshot_debug
    selfcast = spell_is_selfcast?(id)

    if (checkprep != "None" and checkprep != Spell[id].name)
      fput 'release'
    end

    return if id == 506 and Spell[506].active?
    return if id == 9605 and Effects::Cooldowns.to_h.include?("Surge of Strength") # surge cooldown
    return if id == 9625 and Effects::Cooldowns.to_h.include?("Burst of Swiftness") # burst cooldown
    return if id == 608 and hiding?
    return if id == 703 and $bigshot_703_list.any? { |s| s == target.id }
    return if id == 1614 and $bigshot_1614_list.any? { |s| s == target.id }
    return if target.status =~ /dead|gone/ || !GameObj.npcs.any? { |s| s.id == target.id }

    unless (Spell[id].affordable?)
      if (@WAND_IF_OOM)
        cmd_wand(target); return;
      end
      if (@USE_WRACKING)
        wrack()
      end
    end

    if (!Spell[id].affordable? and id != 9605 and id != 506)
      $bigshot_should_rest = true
      $rest_reason = "out of mana"
    end

    waitcastrt?

    if incant.nil?
      if selfcast
        Spell[id].cast(Char.name)
      else
        Spell[id].cast("##{target.id}")
      end
    else
      if XMLData.current_target_id != target.id && selfcast == false
        fput "target ##{target.id}"
      end
      change_stance('offensive') if Spell[id].stance || (id.to_s =~ /1700/i && extra =~ /evoke/i)
      bs_put "incant #{id} #{extra}"
      change_stance(@HUNTING_STANCE)
    end
  end

  def cmd_wand(target)
    echo "cmd_wand" if $bigshot_debug
    if (@FRESH_WAND_CONTAINER)
      hands = GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s
      until ((GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s) =~ /#{@WAND[$bigshot_wand].split(' ').join('.*?')}/i)
        result = dothistimeout("get #{@WAND[$bigshot_wand]} from my #{@FRESH_WAND_CONTAINER}", 3, /You remove|You slip|Get what/)
        if (result =~ /Get what/)
          $bigshot_wand += 1
          if @WAND[$bigshot_wand].nil?
            message("ERROR: Couldn't find fresh wand. Gonna rest."); $bigshot_should_rest = true; return;
          end
        elsif (result.nil?)
          message("ERROR: Timed out looking for wand."); return;
        end
      end

      change_stance('offensive')
      result = dothistimeout("wave my #{@WAND[$bigshot_wand]} at ##{target.id}", 2, /d100|You hurl|is already dead|You do not see that here|You are in no condition|I could not find|Wait/)
      change_stance(@HUNTING_STANCE)

      if (result =~ /You are in no condition/)
        message("ERROR: Wounded. Gonna rest."); $bigshot_should_rest = true; return;
      elsif (result.nil?)
        if (@DEAD_WAND_CONTAINER)
          bs_put "put my #{@WAND[$bigshot_wand]} in my #{@DEAD_WAND_CONTAINER}"
        else
          bs_put "drop my #{@WAND[$bigshot_wand]}"
        end
      end
    else
      message("ERROR: Wand command called but fresh wand container not defined.")
    end
  end

  def cmd_hide()
    echo "cmd_hide" if $bigshot_debug
    tries = 0
    until (hiding?)
      break if tries > 3 || should_flee?

      change_stance('defensive')
      bs_put 'hide'; tries += 1;
    end
  end

  def mstrike_spell_check()
    echo "mstrike_spell_check" if $bigshot_debug
    # Rejuvenation
    if (Spell[1607].known? && !Spell[1607].active? && Spell[1607].affordable? && (checkstamina < (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
      if ((checkstamina + (15 + (bonus = 0; [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190].each { |n| bonus += 1 if Skills.slblessings >= n }; bonus * 3))) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE))
        waitcastrt?
        Spell[1607].cast
      end
    end
    # Adrenal Surge
    if (Spell[1107].known? && Spell[1107].affordable? && !Spell[9010].active? && (Time.now >= $bigshot_adrenal_surge))
      if (Spell[9699].active? || ((maxstamina if Skills.slblessings >= 65) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      elsif (Spell[9699].active? || ((checkstamina + (Skills.slblessings >= 35 ? 50 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      elsif (Spell[9699].active? || ((checkstamina + (Skills.slblessings >= 35 ? 25 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      end
    end
  end

  def cmd_mstrike(command, target)
    echo "cmd_mstrike" if $bigshot_debug
    mstrike_spell_check() if Char.prof =~ /Paladin|Empath/i
    # Mstrike checks
    if Spell[9699].active? #TODO PoPped muscle check updates
      $mstrike_taken = false
      return
    end
    if Skills.multiopponentcombat >= 30 && GameObj.npcs.all? { |i| i.noun !~ /nest/i }
      if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
        if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Spell[9699].active?
          if (GameObjNpcCheck() >= @MSTRIKE_MOB || target.nil?)
            bs_put "quickstrike 1 #{command}"
          else
            bs_put "quickstrike 1 #{command} ##{target.id}"
          end
        else
          if (GameObjNpcCheck() >= @MSTRIKE_MOB || target.nil?)
            bs_put "#{command}"
          else
            bs_put "#{command} ##{target.id}"
          end
        end
        $mstrike_taken = true
      end
    elsif Skills.multiopponentcombat >= 5 && GameObj.npcs.all? { |i| i.noun !~ /nest/i } && GameObjNpcCheck() >= @MSTRIKE_MOB
      if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
        if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Spell[9699].active?
          bs_put "quickstrike 1 #{command}"
        else
          bs_put "#{command}"
        end
        $mstrike_taken = true
      end
    end
  end

  def checkTargetVitals(command, target, ranged = false)
    # General logic for this taken from ;fire by Oweodry
    fput "look ##{target.id}"
    loc = (ranged) ? $bigshot_archery_aim : $bigshot_ambush
    woundinfo = matchtimeout(1, /(he|she|it) has .*/i)
    if (command[loc] == "head" && woundinfo =~ /severe head trauma and bleeding from .* ears/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "neck" && woundinfo =~ /snapped bones and serious bleeding from .* neck/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "left eye" && woundinfo =~ /blinded left eye/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "right eye" && woundinfo =~ /blinded right eye/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    end
  end

  def cmd_ranged(npc)
    echo "cmd_ranged" if $bigshot_debug
    if npc.status =~ /dead|gone/ || !GameObj.npcs.any? { |s| s.id == npc.id }
      $bigshot_archery_aim = 0
      $bigshot_archery_stuck_location = []
      return
    end
    if !@ARCHERY_AIM[$bigshot_archery_aim].nil?
      if $bigshot_archery_stuck_location.any? { |s| s =~ /#{$bigshot_archery_location}/i }
        $bigshot_archery_aim += 1
      end
      if (@ARCHERY_AIM[$bigshot_archery_aim] == "head" || @ARCHERY_AIM[$bigshot_archery_aim] == "neck" || @ARCHERY_AIM[$bigshot_archery_aim] == "left eye" || @ARCHERY_AIM[$bigshot_archery_aim] == "right eye")
        checkTargetVitals(@ARCHERY_AIM, npc, true)
      end
      if $bigshot_archery_aim > @ARCHERY_AIM.length
        $bigshot_archery_aim = 0
        $bigshot_archery_stuck_location = []
      end

      if @ARCHERY_AIM[$bigshot_archery_aim] !~ /#{$bigshot_archery_location.to_s}/i || $bigshot_archery_location.nil?
        fput "aim #{@ARCHERY_AIM[$bigshot_archery_aim]}"
      end
    end

    waitrt?
    waitcastrt?

    if @AMMO
      result = dothistimeout "get 1 my #{@AMMO.sub(/s$/, '')}", 2, /You remove|Get what\?|You already/
      if (result =~ /Get what\?/)
        $bigshot_should_rest = true
        $rest_reason = "Out of ammo"
        return
      end
    end

    result = dothistimeout("fire ##{npc.id}", 2, /round(time)?|You cannot|Could not find|seconds|Get what?/i)
    if (result =~ /^Could not find/)
      gather_ammo()
    elsif (result =~ /You cannot fire/)
      unless GameObj.right_hand.id.nil?
        line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
      end
    elsif (result =~ /but it has no effect/)
      $bigshot_should_rest = true
      $rest_reason = "Ammo had no effect (need blessed or magical)"
    elsif (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from fire routine: #{result}"
    elsif result =~ /round(time)?/i
      $bigshot_archery_aim = 0
      $bigshot_archery_stuck_location = []
    end
  end

  def cmd_pindown(npc)
	echo "cmd_pindown" if $bigshot_debug
	return if !Weapon.available?("Pin Down")
	waitrt?
	waitcastrt?	
	result = dothistimeout("weapon pindown ##{npc.id}", 2, /take quick assessment and raise your|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
    if (result == false)
 	  $bigshot_should_rest = true
      $rest_reason = "Unknown result from pindown routine: #{result}"
	elsif (result =~ /but it has no effect/)
      $bigshot_should_rest = true
      $rest_reason = "Ammo had no effect (need blessed or magical)"
	end
  end

  def cmd_cripple(npc)
	echo "cmd_cripple" if $bigshot_debug
	return if !Weapon.available?("Cripple")
	waitrt?
	waitcastrt?	
	result = dothistimeout("weapon cripple ##{npc.id}", 2, /You reverse your grip|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from cripple routine: #{result}"
	end  
  end

  def cmd_charge(npc)
	echo "cmd_charge" if $bigshot_debug
	return if !Weapon.available?("Charge")
	waitrt?
	waitcastrt?	
	result = dothistimeout("weapon charge ##{npc.id}", 2, /attempt a charge|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from charge routine: #{result}"
	end  
  end

  def cmd_twinhammer(npc)
	echo "cmd_twinhammer" if $bigshot_debug
	return if !Weapon.available?("Twin Hammerfists")
	return if npc.status =~ /prone|stunned/
	waitrt?
	waitcastrt?
	result = dothistimeout("weapon twinhammer ##{npc.id}", 2, /raise your hands high|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from twinhammer routine: #{result}"
	end
  end

  def cmd_dizzyingswing(npc)
	echo "cmd_dizzyingswing" if $bigshot_debug
	return if !Weapon.available?("Dizzying Swing")
	waitrt?
	waitcastrt?
	result = dothistimeout("weapon dizzyingswing ##{npc.id}", 2, /lash out in a strike|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from dizzyingswing routine: #{result}"
	end  
  end

  def cmd_barrage(npc)
    echo "cmd_barrage" if $bigshot_debug
	return if !Weapon.available?("Barrage")
    waitrt?
    waitcastrt?
    result = dothistimeout("weapon barrage ##{npc.id}", 10, /Upon firing|Distracted|last arrow|Your satisfying display|little bit late|still stunned|too injured|You cannot|Could not find|seconds|what?/i)
	if (result =~ /You cannot fire/)
	  unless GameObj.right_hand.id.nil?
	    line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ } #Probably need to change this?
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
	  end
	elsif (result =~ /but it has no effect/)
      $bigshot_should_rest = true
      $rest_reason = "Ammo had no effect (need blessed or magical)"
    elsif (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from barrage routine: #{result}"
    end
  end

  def cmd_flurry(npc)
	echo "cmd_flurry" if $bigshot_debug
	return if !Weapon.available?("Flurry")
	waitrt?
	waitcastrt?
	result = dothistimeout("weapon flurry ##{npc.id}", 10, /Distracted|inevitable end|ready position|You watch for openings|little bit late|still stunned|too injured|what?|already dead|little bit late|could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from flurry routine: #{result}"
	end
  end

  def cmd_thrash(npc)
    echo "cmd_thrash" if $bigshot_debug
	return if !Weapon.available?("Thrash")
	waitrt?
	waitcastrt?
	result = dothistimeout("weapon thrash ##{npc.id}", 10, /Distracted|inevitable end|ready position|little bit late|still stunned|too injured|what?|already dead|little bit late|could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from thrash routine: #{result}"
	end
  end

  def cmd_pummel(npc)
    echo "cmd_pummel" if $bigshot_debug
	return if !Weapon.available?("Pummel")
	waitrt?
	waitcastrt?
	result = dothistimeout("weapon pummel ##{npc.id}", 10, /Distracted|your assault complete|little bit late|still stunned|too injured|what?|already dead|little bit late|could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from pummel routine: #{result}"
	end
  end

  def cmd_fury(npc)
    echo "cmd_fury" if $bigshot_debug
	return if !Weapon.available?("Fury")
	waitrt?
	waitcastrt?
	result = dothistimeout("weapon fury ##{npc.id}", 10, /Distracted|recentering yourself|Your furious assault|little bit late|still stunned|too injured|what?|already dead|little bit late|could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from fury routine: #{result}"
	end
  end

  def cmd_gthrusts(npc)
    echo "cmd_gthrusts" if $bigshot_debug
	return if !Weapon.available?("Guardant Thrusts")
	waitrt?
	waitcastrt?
	result = dothistimeout("weapon gthrusts ##{npc.id}", 10, /Distracted|inevitable end|complete your assault|little bit late|still stunned|too injured|what?|already dead|little bit late|could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from gthrusts routine: #{result}"
	end
  end

  def cmd_clash(npc)
	echo "cmd_clash" if $bigshot_debug
	return if !Weapon.available?("Clash")
	waitrt?
	waitcastrt?
	result = dothistimeout("weapon clash ##{npc.id}", 2, /you plunge into the fray|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from clash routine: #{result}"
	end
  end

  def cmd_volley(npc)
	echo "cmd_volley" if $bigshot_debug
	return if !Weapon.available?("Volley")
	waitrt?
	waitcastrt?	
	result = dothistimeout("weapon volley ##{npc.id}", 2, /filling the sky with a volley of deadly projectiles|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
  	  $bigshot_should_rest = true
      $rest_reason = "Unknown result from volley routine: #{result}"
	elsif (result =~ /but it has no effect/)
      $bigshot_should_rest = true
      $rest_reason = "Ammo had no effect (need blessed or magical)"
	end
  end

  def cmd_pulverize(npc)
	echo "cmd_pulverize" if $bigshot_debug
	return if !Weapon.available?("Pulverize")
	waitrt?
	waitcastrt?
	result = dothistimeout("weapon pulverize ##{npc.id}", 2, /pulverize your foes|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from pulverize routine: #{result}"
	end
  end

  def cmd_cyclone(npc)
	echo "cmd_cyclone" if $bigshot_debug
	return if !Weapon.available?("Cyclone")
	waitrt?
	waitcastrt?
	result = dothistimeout("weapon cyclone ##{npc.id}", 2, /a blurred cyclone|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from cyclone routine: #{result}"
	end
  end

  def cmd_whirlwind(npc)
	echo "cmd_whirlwind" if $bigshot_debug
	return if !Weapon.available?("Whirlwind")
	waitrt?
	waitcastrt?	
	result = dothistimeout("weapon whirlwind ##{npc.id}", 2, /Twisting and spinning|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from whirlwind routine: #{result}"
	end
  end

  def cmd_wblade(npc)
	echo "cmd_wblade" if $bigshot_debug
	return if !Weapon.available?("Whirling Blade")
	waitrt?
	waitcastrt?	
	result = dothistimeout("weapon wblade ##{npc.id}", 2, /With a broad flourish|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from wblade routine: #{result}"
	end
  end

  def cmd_shieldthrow(npc)
	echo "cmd_shieldthrow" if $bigshot_debug
	return if !Shield.available?("Shield Throw")
	waitrt?
	waitcastrt?	
	result = dothistimeout("shield throw ##{npc.id}", 2, /You snap your arm|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from shieldthrow routine: #{result}"
	end    
  end

  def cmd_shieldbash(npc)
	echo "cmd_shieldbash" if $bigshot_debug
	return if !Shield.available?("Shield Bash")
	waitrt?
	waitcastrt?	
	result = dothistimeout("shield bash ##{npc.id}", 2, /attempt a shield bash|awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from shield bash routine: #{result}"
	end  
  end

  def cmd_shieldcharge(npc)
	echo "cmd_shieldcharge" if $bigshot_debug
	return if !Shield.available?("Shield Charge")
	waitrt?
	waitcastrt?
	result = dothistimeout("shield charge ##{npc.id}", 2, /attempt a shield charge|awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from shield charge routine: #{result}"
	end  
  end

  def cmd_shieldstrike(npc)
	echo "cmd_shieldstrike" if $bigshot_debug
	return if !Shield.available?("Shield Strike")
	waitrt?
	waitcastrt?	
	result = dothistimeout("shield strike ##{npc.id}", 2, /launch a quick bash|awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from shield strike routine: #{result}"
	end  
  end

  def cmd_shieldpin(npc)
	echo "cmd_shieldpin" if $bigshot_debug
	return if !Shield.available?("Shield Pin")
	waitrt?
	waitcastrt?	
	result = dothistimeout("shield pin ##{npc.id}", 2, /diversionary shield bash|awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from shield pin routine: #{result}"
	end  
  end

  def cmd_shieldtrample(npc)
	echo "cmd_shieldtrample" if $bigshot_debug
	return if !Shield.available?("Shield Trample")
	waitrt?
	waitcastrt?	
	result = dothistimeout("shield trample ##{npc.id}", 2, /charge headlong towards|awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from shield trample routine: #{result}"
	end  
  end

  def cmd_shieldpush(npc)
	echo "cmd_shieldpush" if $bigshot_debug
	return if !Shield.available?("Shield Push")
	waitrt?
	waitcastrt?	
	result = dothistimeout("shield push ##{npc.id}", 2, /attempt to push|awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from shield push routine: #{result}"
	end  
  end

  def cmd_shout()
	echo "cmd_shout" if $bigshot_debug
	return if Effects::Buffs.active?('Empowered (+20)') || (checkstamina < 21)
	waitrt?
	waitcastrt?	
	result = dothistimeout("warcry shout", 2, /You let loose an echoing shout!|Your fighting spirit is bolstered!|round(time)?|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from shout routine: #{result}"
	end  
  end

  def cmd_yowlp()
	echo "cmd_yowlp" if $bigshot_debug
	return if Effects::Buffs.active?('Yertie\'s Yowlp') || (checkstamina < 11)
	waitrt?
	waitcastrt?	
	result = dothistimeout("warcry yowlp", 2, /You throw back your shoulders and let out a resounding yowlp!|Your fighting spirit is emboldened!|round(time)?|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from yowlp routine: #{result}"
	end  
  end

  def cmd_holler()
	echo "cmd_holler" if $bigshot_debug
	return if Effects::Buffs.active?('Enh. Health (+20)') || (checkstamina < 31)
	waitrt?
	waitcastrt?	
	result = dothistimeout("warcry holler", 2, /You throw back your head and let out a thundering holler!|You throw back your head and holler your war cry!|Your fighting spirit is bolstered to heroic proportions!|round(time)?|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from holler routine: #{result}"
	end  
  end

  def cmd_bellow(target,npc)
	echo "cmd_bellow" if $bigshot_debug
	waitrt?
	waitcastrt?
    if (target == 'all') && (checkstamina > 21)
	  result = dothistimeout("warcry bellow all",2, /nerve-shattering bellow!|round(time)?|seconds/i)
	  if (result == false)
	    $bigshot_should_rest = true
	    $rest_reason = "Unknown result from bellow routine: #{result}"
	  end  
	elsif (checkstamina > 11)
	  result = dothistimeout("warcry bellow ##{npc.id}", 2, /nerve-shattering bellow!|round(time)?|seconds/i)
	  if (result == false)
	    $bigshot_should_rest = true
	    $rest_reason = "Unknown result from bellow routine: #{result}"
	  end  
	end
  end

  def cmd_growl(target,npc)
	echo "cmd_growl" if $bigshot_debug
	waitrt?
	waitcastrt?
	if (target == 'all') && (checkstamina > 15)
      result = dothistimeout("warcry growl all",2, /nerve-shattering bellow!|round(time)?|seconds/i)
	  if (result == false)
	    $bigshot_should_rest = true
	    $rest_reason = "Unknown result from bellow routine: #{result}"
	  end  
	elsif (checkstamina > 8)
	  result = dothistimeout("warcry growl ##{npc.id}", 2, /nerve-shattering bellow!|round(time)?|seconds/i)
	  if (result == false)
	    $bigshot_should_rest = true
	    $rest_reason = "Unknown result from growl routine: #{result}"
	  end  
	end
  end

  def cmd_cry(target,npc)
	echo "cmd_cry" if $bigshot_debug
	waitrt?
	waitcastrt?
	if (target == 'all') && (checkstamina > 31)
	    result = dothistimeout("warcry cry all",2, /eerie, modulating cry|round(time)?|seconds/i)
	    if (result == false)
	      $bigshot_should_rest = true
	      $rest_reason = "Unknown result from bellow routine: #{result}"
	    end  
	elsif (checkstamina > 16)
	    result = dothistimeout("warcry cry ##{npc.id}", 2, /eerie, modulating cry|round(time)?|seconds/i)
	    if (result == false)
	      $bigshot_should_rest = true
	      $rest_reason = "Unknown result from cry routine: #{result}"
	    end  
	end
  end

  def cmd_bearhug(npc)
	echo "cmd_bearhug" if $bigshot_debug
	return if !CMan.available?("Bearhug") # "Enh. Strength (+10)"
	waitrt?
	waitcastrt?
	result = dothistimeout("cman bearhug ##{npc.id}", 9, /release your grip|feat of strength empowers|avoids your grasp|fend off your grasp|leaving you flailing|completely miss|unable to complete|You can't reach|little bit late|still stunned|too injured|what?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from bearhug routine: #{result}"
	end 
  end

  def cmd_bullrush(npc)
	echo "cmd_bullrush" if $bigshot_debug
	return if !CMan.available?("Bull Rush")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman bullrush ##{npc.id}", 2, /dip your shoulder and rush|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from bullrush routine: #{result}"
	end 
  end

  def cmd_coupdegrace(npc)
	echo "cmd_coupdegrace" if $bigshot_debug
	return if !CMan.available?("Coup de Grace") # "Enh. Strength (+10)"
	waitrt?
	waitcastrt?
#need success messaging and maybe more failure messaging.
	result = dothistimeout("cman coupdegrace ##{npc.id}", 2, /intending to finish|isn't injured enough|thwarts your attempt|unable to complete|You can't reach|little bit late|still stunned|too injured|what?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from coupdegrace routine: #{result}"
	end 
  end

  def cmd_cpress(npc)
	echo "cmd_cpress" if $bigshot_debug
	return if !CMan.available?("Crowd Press")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman cpress ##{npc.id}", 2, /You approach|You maneuver in close|try to maneuver|can't manage to do that right now|rooted in place|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from cpress routine: #{result}"
	end 
  end

  def cmd_dirtkick(npc)
	echo "cmd_dirtkick" if $bigshot_debug
	return if !CMan.available?("Dirtkick")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman dirtkick ##{npc.id}", 2, /foot and let it fly|clump of dust|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from dirtkick routine: #{result}"
	end 
  end

  def cmd_dislodge(npc)
	echo "cmd_dislodge" if $bigshot_debug
	return if !CMan.available?("Dislodge")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman dislodge ##{npc.id}", 2, /attempting to dislodge|suitable weapons lodged|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from dislodge routine: #{result}"
	end 
  end
  
  def cmd_exsanguinate(npc)
	echo "cmd_exsanguinate" if $bigshot_debug
	return if !CMan.available?("Exsanguinate")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman exsanguinate ##{npc.id}", 2, /blur of steel in your eagerness|slows to a trickle and finally stops|is not bleeding|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from exsanguinate routine: #{result}"
	end 
  end

  def cmd_feint(npc)
	echo "cmd_feint" if $bigshot_debug
	return if !CMan.available?("Feint")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman feint ##{npc.id}", 2, /You feint|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from feint routine: #{result}"
	end 
  end

  def cmd_gkick(npc)
	echo "cmd_gkick" if $bigshot_debug
	return if !CMan.available?("Groin Kick")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman gkick ##{npc.id}", 2, /deliver a kick|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from gkick routine: #{result}"
	end 
  end

  def cmd_hamstring(npc)
	echo "cmd_hamstring" if $bigshot_debug
	return if !CMan.available?("Hamstring")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman hamstring ##{npc.id}", 2, /try to hamstring|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from hamstring routine: #{result}"
	end 
  end
  
  def cmd_haymaker(npc)
	echo "cmd_haymaker" if $bigshot_debug
	return if !CMan.available?("Haymaker")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman haymaker ##{npc.id}", 2, /roundhouse punch|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from haymaker routine: #{result}"
	end 
  end

  def cmd_headbutt(npc)
	echo "cmd_headbutt" if $bigshot_debug
	return if !CMan.available?("Headbutt")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman headbutt ##{npc.id}", 2, /attempt to headbutt|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from headbutt routine: #{result}"
	end 
  end

  def cmd_leapattack(npc)
	echo "cmd_leapattack" if $bigshot_debug
	return if !CMan.available?("Leap Attack")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman leapattack ##{npc.id}", 2, /leap into the air|low enough for you to attack|isn't flying|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from leapattack routine: #{result}"
	end 
  end
  
  def cmd_mblow(npc)
	echo "cmd_mblow" if $bigshot_debug
	return if !CMan.available?("Mighty Blow")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman mblow ##{npc.id}", 2, /with all your might|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from mblow routine: #{result}"
	end 
  end
  
  def cmd_sblow(npc)
	echo "cmd_sblow" if $bigshot_debug
	return if !CMan.available?("Staggering Blow")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman sblow ##{npc.id}", 2, /with staggering might|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from sblow routine: #{result}"
	end 
  end
  
  def cmd_scleave(npc)
	echo "cmd_scleave" if $bigshot_debug
	return if !CMan.available?("Spell_Cleave")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman scleave ##{npc.id}", 2, /concentrate on the magical wards|anti-magical equipment|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from scleave routine: #{result}"
	end 
  end 
  
  def cmd_sattack(npc)
	echo "cmd_sattack" if $bigshot_debug
	return if !CMan.available?("Spin_Attack")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman sattack ##{npc.id}", 2, /spinning leap towards|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from sattack routine: #{result}"
	end 
  end

  def cmd_sunder(npc)
	echo "cmd_sunder" if $bigshot_debug
	return if !CMan.available?("Sunder Shield")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman sunder ##{npc.id}", 2, /split it asunder|holding a shield|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from sunder routine: #{result}"
	end 
  end
  
  def cmd_tackle(npc)
	echo "cmd_tackle" if $bigshot_debug
	return if !CMan.available?("Tackle")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman tackle ##{npc.id}", 2, /You hurl yourself|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from tackle routine: #{result}"
	end 
  end

  def cmd_trip(npc)
	echo "cmd_trip" if $bigshot_debug
	return if !CMan.available?("Trip")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman trip ##{npc.id}", 2, /jerk the weapon sharply sideways|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from trip routine: #{result}"
	end 
  end

  def cmd_truestrike(npc)
	echo "cmd_truestrike" if $bigshot_debug
	return if !CMan.available?("True Strike")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman truestrike ##{npc.id}", 2, /will strike true|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from truestrike routine: #{result}"
	end 
  end

  def cmd_vaultkick(npc)
	echo "cmd_vaultkick" if $bigshot_debug
	return if !CMan.available?("Vault Kick")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman vaultkick ##{npc.id}", 2, /vaulting kick|is lying down|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from vaultkick routine: #{result}"
	end 
  end

  def cmd_cutthroat(npc)
	echo "cmd_cutthroat" if $bigshot_debug
	return if !CMan.available?("Cutthroat")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman cutthroat ##{npc.id}", 2, /attempt to slit|Try hiding first|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from cutthroat routine: #{result}"
	end 
  end
  
  def cmd_shroud(npc)
	echo "cmd_shroud" if $bigshot_debug
	return if !CMan.available?("Dust Shroud")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman shroud ##{npc.id}", 1, /kicking up as much dirt|you're already out of sight|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from shroud routine: #{result}"
	end 
  end
  
  def cmd_divert(npc)
	echo "cmd_divert" if $bigshot_debug
	return if !CMan.available?("Divert")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman divert ##{npc.id}", 2, /Try hiding first|prepare your diversion|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from divert routine: #{result}"
	end 
  end

  def cmd_eviscerate(npc)
	echo "cmd_eviscerate" if $bigshot_debug
	return if !CMan.available?("Eviscerate")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman eviscerate ##{npc.id}", 2, /poised to eviscerate|Try hiding first|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from eviscerate routine: #{result}"
	end 
  end
  
  def cmd_eyepoke(npc)
	echo "cmd_eyepoke" if $bigshot_debug
	return if !CMan.available?("Eyepoke")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman eyepoke ##{npc.id}", 2, /finger at the eye|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from eyepoke routine: #{result}"
	end 
  end
  
  def cmd_footstomp(npc)
	echo "cmd_footstomp" if $bigshot_debug
	return if !CMan.available?("Footstomp")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman footstomp ##{npc.id}", 2, /attempting to footstomp|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from footstomp routine: #{result}"
	end 
  end

  def cmd_garrote(npc)
	echo "cmd_garrote" if $bigshot_debug
	return if !CMan.available?("Garrote")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman garrote ##{npc.id}", 2, /fling your wire around|damage to yourself|other hand clear|holding a garrote|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from garrote routine: #{result}"
	end 
  end

  def cmd_kneebash(npc)
	echo "cmd_kneebash" if $bigshot_debug
	return if !CMan.available?("Kneebash")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman kneebash ##{npc.id}", 2, /down at the knee|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from kneebash routine: #{result}"
	end 
  end
  
  def cmd_mug(npc)
	echo "cmd_mug" if $bigshot_debug
	return if !CMan.available?("Mug")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman mug ##{npc.id}", 2, /boldly accost|won't fall for that again|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from mug routine: #{result}"
	end 
  end

  def cmd_nosetweak(npc)
	echo "cmd_nosetweak" if $bigshot_debug
	return if !CMan.available?("Nosetweak")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman nosetweak ##{npc.id}", 2, /reach out and grab|stand up first|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from nosetweak routine: #{result}"
	end 
  end

  def cmd_sbash(npc)
	echo "cmd_shieldbash" if $bigshot_debug
	return if !CMan.available?("Shield Bash")
	waitrt?
	waitcastrt?	
	result = dothistimeout("cman sbash ##{npc.id}", 2, /attempt a shield bash|awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from sbash routine: #{result}"
	end  
  end
  
  def cmd_subdue(npc)
	echo "cmd_subdue" if $bigshot_debug
	return if !CMan.available?("Subdue")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman subdue ##{npc.id}", 2, /spring from hiding|Try hiding first|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from subdue routine: #{result}"
	end 
  end
  
  def cmd_sthieve(npc)
	echo "cmd_sthieve" if $bigshot_debug
	return if !CMan.available?("Spell Thieve")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman sthieve ##{npc.id}", 2, /concentrate on the magic|anti-magical equipment|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from sthieve routine: #{result}"
	end 
  end

  def cmd_spunch(npc)
	echo "cmd_spunch" if $bigshot_debug
	return if !CMan.available?("Sucker Punch")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman spunch ##{npc.id}", 2, /You swing|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from spunch routine: #{result}"
	end 
  end
  
  def cmd_sweep(npc)
	echo "cmd_sweep" if $bigshot_debug
	return if !CMan.available?("Sweep")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman sweep ##{npc.id}", 2, /crouch and sweep|out of reach|awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from sweep routine: #{result}"
	end 
  end

  def cmd_swiftkick(npc)
	echo "cmd_swiftkick" if $bigshot_debug
	return if !CMan.available?("Swiftkick")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman swiftkick ##{npc.id}", 2, /attempting a swiftkick|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from swiftkick routine: #{result}"
	end 
  end

  def cmd_templeshot(npc)
	echo "cmd_templeshot" if $bigshot_debug
	return if !CMan.available?("Templeshot")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman templeshot ##{npc.id}", 2, /swing the blunt end|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from templeshot routine: #{result}"
	end 
  end

  def cmd_throatchop(npc)
	echo "cmd_throatchop" if $bigshot_debug
	return if !CMan.available?("Throatchop")
	waitrt?
	waitcastrt?
	result = dothistimeout("cman throatchop ##{npc.id}", 2, /You chop|out of reach|You can't reach|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
	if (result == false)
	  $bigshot_should_rest = true
	  $rest_reason = "Unknown result from throatchop routine: #{result}"
	end 
  end

  def cmd_checker()
	echo "cmd_checker" if $bigshot_debug
	echo " ************ "
	echo "barrage buff #{Effects::Buffs.active?("Enh. Dexterity (+10)")}" 
	echo "arcane reflex #{Effects::Buffs.active?("Nature's Touch Arcane Ref")}" 
	echo " ************ "
  end

  def cmd_berserk()
    echo "cmd_berserk" if $bigshot_debug
    if (checkstamina(20))
      change_stance('defensive')
      Spell[9607].cast
      pause 5
      wait_until { !Spell[9607].active? }
    else
      bs_put 'target random'; bs_put 'kill';
    end
  end

  def cmd_run_script(name, args)
    echo "cmd_run_script" if $bigshot_debug
    if (args == nil || args =~ /^\s*$/)
      run_script(name, true)
    else
      args = args.split(/ /)
      run_script(name, true, args)
    end
  end

  def cmd_sleep(time, npc)
    echo "cmd_sleep" if $bigshot_debug
    change_stance('defensive')
    time.to_i.times do
      sleep(1)
      break if should_rest?
      break if npc && npc.status =~ /dead|gone/
    end
  end

  def cmd_ambush(command, target)
    echo "cmd_ambush" if $bigshot_debug
    if target.status =~ /dead|gone/ || !GameObj.npcs.any? { |s| s.id == target.id }
      $bigshot_ambush = 0
      return
    end
    command = ["head", "right leg", "left leg", "chest"] if (command == "" || command.nil?) && @AMBUSH == []
    command = @AMBUSH if (command == "" || command == [] || command.nil?) && @AMBUSH != []
    command = [command] if command.class == String
    if ($bigshot_ambush >= command.length())
      # If you have gotten here, there is nothing left to target on your list.
      $bigshot_ambush = 0
      command = ["chest"]
    end
    if (command[$bigshot_ambush] == "head" || command[$bigshot_ambush] == "neck" || command[$bigshot_ambush] == "left eye" || command[$bigshot_ambush] == "right eye")
      checkTargetVitals(command, target)
    end
    waitrt?
    result = dothistimeout "ambush ##{target.id} #{command[$bigshot_ambush]}", 2, /round(time)?|You cannot aim that high!|does not have a head!|is already missing that!|does not have a .* leg!|does not have a .* arm!/i
    if result =~ /You cannot aim that high!|does not have a head!|is already missing that!|does not have a (?:right|left) leg!|does not have a (?:right|left) arm!/i
      $bigshot_ambush += 1
      cmd_ambush(nil, target)
    elsif result =~ /round(time)?/i
      $bigshot_ambush = 0
    end
  end

  def cmd_nudge_weapons()
    echo "cmd_nudge_weapons" if $bigshot_debug
    return if checkpaths.size == 0

    GameObj.loot.each { |i|
      next unless i.noun =~ /axe|scythe|pitchfork|falchion|sword|lance|sword|dagger|estoc|falchion|handaxe|katana|katar|gauche|rapier|scimitar|whip-blade|cudgel|crowbill|whip|mace|star|hammer|claidhmore|flail|flamberge|maul|pick|staff|mattock/

      change_stance('defensive')

      sheathed = false
      unless (righthand.nil? || lefthand.nil?)
        sheathed = true
        fput 'sheath'
        unless (righthand.nil? || lefthand.nil?)
          message("Unable to empty hands via sheath.")
          return
        end
      end

      dirs = checkpaths
      dir  = checkpaths.shift
      fput "get ##{i.id}"
      put dir
      put "drop ##{i.id}"
      fput reverse_direction(dir)
      fput "gird" if sheathed
    }
  end

  def message(text)
    string = ''
    if $fake_stormfront then string.concat("\034GSL\r\n ") else string.concat("<pushBold\/>") end
    if (text.index('\n'))
      text.split('\n').each { |line| string.concat("| #{line}") }
    else
      string.concat('| ' + text)
    end
    if $fake_stormfront then string.concat("\034GSM\r\n ") else string.concat("<popBold\/>") end
    _respond string
  end

  def dead_man_switch()
    echo "dead_man_switch" if $bigshot_debug
    if @DEAD_MAN_SWITCH
      Thread.new {
        while (running?($current_script_name))
          if (dead? || percenthealth < 40)
            echo 'AUTOBOT ALERT: Your character is in trouble!'
            fput 'quit'
          end
          sleep(2)
        end
      };
    elsif @DEPART_SWITCH
      start_exec_script(<<-EOF
                while( running?($current_script_name) );
                    if(dead?);
                        stop_script($current_script_name);
                        fput 'depart'; fput 'depart';
                        fput 'depart confirm'; fput 'depart confirm';
                        start_script('waggle');
                        15.times { sleep(60); fput info; };
                        sleep(1) until percentspirit == 100 && !running?('waggle');
                        start_script( "#{$current_script_name}", ['solo'] );
                        Script.self.kill;
                    end;
                    sleep(5);
                end;
                        EOF
                       );
    else
      Thread.new {
        loop { Script.self.kill if dead?; sleep(5); }
      }
    end
  end

  def keep_awake()
    echo "keep_awake" if $bigshot_debug
    Thread.new {
      while (running?($current_script_name))
        sleep(150); put 'look';
      end
    }
  end

  def monitor_interaction()
    echo "monitor_interaction" if $bigshot_debug
    if @MONITOR_INTERACTION
      start_exec_script(<<-eos
        watch_list = /#{@monitor_strings.gsub("||","|")}/io
        safe_strings = /#{@monitor_safe_strings.gsub("||","|")}/io

        def show_window(line)
          window_title = Char.name + ':' + line
          Gtk.queue do
            $myWindow = Gtk::Window.new
            $myWindow.title = "Autobot Alert!"
            $myWindow.set_size_request(450, 25)
            label = Gtk::Label.new window_title
            $myWindow.add(label)
            $myWindow.show_all
          end
        end

        while(line = get)
          break unless running?($current_script_name)
          if watch_list.match?(line) && !safe_strings.match?(line)
            show_window(line)
            echo "AUTOBOT ALERT: " + line
          end
        end
      eos
      )
    end
  end

  def GameObjNpcCheck()
    npcs = GameObj.npcs.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| npc.name =~ /animated/ }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
    return npcs.size.to_i
  end

  def NPCRoomCheck()
    Thread.new {
      loop {
        $current_room_npcs = GameObj.npcs
        pause 0.5
      }
    }
  end

  def wrack()
    echo "wrack" if $bigshot_debug
    if Spell[9918].known? and not Spell[9012].active?
      Spell[9918].cast if checkspirit >= @WRACKING_SPIRIT
    elsif Spell[9718].known?
      (checkstamina / 50).times { Spell[9718].cast }
    elsif Spell[9813].known? && !Spell[9048].active?
      Spell[9813].cast
    end
  end

  def cur_bounty()
    return bounty?
  end

  def get_rallypoint()
    return @RALLYPOINT_ROOM_ID
  end

  def set_bandit_hunting(kill_bandits)
    # Need to circumvent anti-poach and protections some to hunt bandits
    $bigshot_bandits = kill_bandits
  end

  def change_stance(new_stance, force = true)
    return if Spell[216].active? || dead?

    if (stance() =~ /#{new_stance}/)
      return
    elsif (checkcastrt() > 0 && new_stance =~ /def/)
      return if stance() == 'guarded'
    end

    if (force)
      result = dothistimeout("stance #{new_stance}", 3, /You are now in an?|You move into an?|You fall back into a|Cast Roundtime in effect|You are unable to change/)
    else
      fput "stance #{new_stance}"
    end
  end

  def wait_for_swing(seconds, target = nil)
    echo "wait_for_swing" if $bigshot_debug
    start = Time.now
    swung = false
    $stop_wait = false
    $global_target = target.id
    $pcs = checkpcs ? ' you(\.|!|r? )|' + checkpcs.join('|') : 'you(\.|!|r? )'

    wait_for_swing_exec = <<-eos
        status_tags
        while line = get
            $stop_wait = true if line =~ /#{$global_target}.*#{$pcs}/ and line !~ /style id="".*style id="roomDesc"|(?:component|compDef) id='room objs'/
            break if $stop_wait
            break if !running?($current_script_name)
        end
        status_tags
    eos

    ExecScript.start(wait_for_swing_exec, :quiet => true)

    while (1)
      change_stance('defensive', false) unless target && target.status =~ PRONE
      stand() if !standing?
      break if $stop_wait.call
      break if GameObj.npcs.size.nil? || GameObjNpcCheck() == 0
      break if should_flee?
      break if target && target.status =~ PRONE
      break if (Time.now - start) > seconds

      sleep(0.25)
    end
  end

  def croak(message)
    echo "croak" if $bigshot_debug
    message(message);
    croak_scripts(["#{$current_script_name}"])
  end

  def run_script(name, pause_bigshot = false, args = [])
    echo "run_script" if $bigshot_debug
    if Script.running.find { |s| s.name.downcase == name.downcase }.paused or running? name
      stop_script name
      wait_while { running? name }
    end

    start_script name, args
    if pause_bigshot
      wait_until { !running? name }
    end
  end

  def run_scripts(scripts, pause_bigshot = false)
    echo "run_scripts" if $bigshot_debug
    scripts.each do |i|
      tokens = i.split(/\s+/)
      if (tokens.size > 1)
        run_script(tokens[0], pause_bigshot, tokens[1..-1])
      else
        run_script(tokens[0], pause_bigshot)
      end
    end
  end

  def croak_script(name)
    echo "croak_script" if $bigshot_debug
    kill_script(name) if running?(name)
  end

  def croak_scripts(scripts)
    echo "croak_scripts" if $bigshot_debug
    scripts.each { |i| croak_script(i) }
  end

  def stand(stand_command = nil)
    echo "stand" if $bigshot_debug
    return if (stand_command =~ /^(?:fire|kneel)/i && kneeling? && checkleft =~ /^(?:arbalest|kut'ziko|crossbow|kut'zikokra)$/)
    until (standing?)
      change_stance('defensive')
      bs_put 'stand'
    end
  end

  def groupcheck()
    echo "groupcheck" if $bigshot_debug
    def checkgroupline(line)
      line =~ /exist="\-[0-9]+" noun=".*">(.*)<\/a> is (?:following you|the leader of your group|also a member of your group)/i
      if !$1.nil? then $grouplist.push($1); end
    end

    action = proc { |server_string|
      if checkgroupline(server_string) or server_string =~ /group status is currently|to set your group status|^.$|You are not currently in a group/m then nil
      else server_string
      end
    }
    DownstreamHook.add('grouphook', action)
    $_SERVER_.puts "group"
    waitfor "group status is currently", "to set your group status", "You are not currently in a group"
    pause 0.5
    DownstreamHook.remove('grouphook')
    echo $grouplist if $bigshot_debug
  end

  def lead(my_group = nil)
    echo "lead" if $bigshot_debug
    monitor_interaction()
    CompanionCheck()
    NPCRoomCheck()
    @followers = my_group || Group.new()
    if !checkpcs.nil?
      groupcheck()
    end

    if (should_rest? && !$bigshot_quick)
      rest()
    else
      hunt()
    end
  end

  def find_routine(target)
    echo "find_routine" if $bigshot_debug
    echo "@DISABLE_COMMANDS.size = #{@DISABLE_COMMANDS.size}" if $bigshot_debug
    if (!solo? && fried? && @DISABLE_COMMANDS.size > 0)
      return @DISABLE_COMMANDS
    else
      key = @TARGETS.keys.find { |k| target.name =~ /^#{k}$/i or target.noun =~ /^#{k}$/i }
      if key.nil?
        routine_letter = 'a'
      else
        routine_letter = @TARGETS[key]
      end

      if routine_letter == 'quick' || $bigshot_quick
        return @QUICK_COMMANDS unless @QUICK_COMMANDS.size == 0
      elsif routine_letter == 'j'
        return @HUNTING_COMMANDS_J unless @HUNTING_COMMANDS_J.size == 0
      elsif routine_letter == 'i'
        return @HUNTING_COMMANDS_I unless @HUNTING_COMMANDS_I.size == 0
      elsif routine_letter == 'h'
        return @HUNTING_COMMANDS_H unless @HUNTING_COMMANDS_H.size == 0
      elsif routine_letter == 'g'
        return @HUNTING_COMMANDS_G unless @HUNTING_COMMANDS_G.size == 0
      elsif routine_letter == 'f'
        return @HUNTING_COMMANDS_F unless @HUNTING_COMMANDS_F.size == 0
      elsif routine_letter == 'e'
        return @HUNTING_COMMANDS_E unless @HUNTING_COMMANDS_E.size == 0
      elsif routine_letter == 'd'
        return @HUNTING_COMMANDS_D unless @HUNTING_COMMANDS_D.size == 0
      elsif routine_letter == 'c'
        return @HUNTING_COMMANDS_C unless @HUNTING_COMMANDS_C.size == 0
      elsif routine_letter == 'b'
        return @HUNTING_COMMANDS_B unless @HUNTING_COMMANDS_B.size == 0
      end

      return @HUNTING_COMMANDS
    end
  end

  def solo?
    # tails wont have followers
    if (@followers && @followers.size == 0)
      return true
    else
      return false
    end
  end

  def leading?
    return !following?
  end

  def following?
    return @followers.nil?
  end

  def no_players()
    echo "no_players" if $bigshot_debug
    if ((checkpcs - $grouplist).count > 0)
      return false
      echo "no_players: checkpcs present" if $bigshot_debug
    elsif GameObj.loot.find { |obj| obj.noun == 'disk' and obj.name !~ /#{Char.name}/ }
      # This can cause poaching if you walk into a room with your disk already present.  Need to find a workaround
      echo "no_players: GameObj disk present" if $bigshot_debug
      return false
    elsif $ambusher_here
      echo "no_players: Ambusher here" if $bigshot_debug
      return false
    elsif $obvious_hiding_player
      echo "no_players: Obvious Hiding Player here" if $bigshot_debug
      return false
    else
      return true
    end
  end

  def no_players_hunt()
    echo "no_players_hunt" if $bigshot_debug
    return false if $ambusher_here
    return false if $obvious_hiding_player

    return true
  end

  def pre_hunt(manually_walking = false)
    echo "pre_hunt" if $bigshot_debug
    if (!solo? && leading?)
      @followers.group_assist(true)
    end
    # prep/go
    #print "\a" unless $bigshot_quick
    #print "\a" unless $bigshot_quick

    @followers.add_event(:HUNTING_PREP_COMMANDS)

    @HUNTING_PREP_COMMANDS.each { |i|
      if i =~ /^script\s+(.*?)(\s|$)(.*)/i
        cmd_run_script($1, $3)
      else
        fput(i)
        sleep(0.3)
      end
    }

    if (get_rallypoint() != -5 && !$bigshot_quick && !manually_walking)
      prepare_for_movement(false)
      goto(@RALLYPOINT_ROOM_ID, false)
      while (!@followers.all_present?)
        message("Waiting for followers....")
        sleep(REST_INTERVAL / 5)
      end
    end

    prepare_for_movement()
    @followers.obv_hide_set(false)
    # @followers.add_event(:CAST_SIGNS)
    # cast_signs()

    @followers.add_event(:HUNTING_SCRIPTS_START)
    run_scripts(@HUNTING_SCRIPTS, false)

    # Start bigshot hunting monitor
    hunt_monitor("start")

    if !$bigshot_quick && !manually_walking
      goto(@HUNTING_ROOM_ID)
    end
    if (!solo? && leading?)
      @followers.add_event(:FOLLOW_NOW) # trigger rubber band
      while (!@followers.all_present?)
        message("Waiting for followers....")
        sleep(REST_INTERVAL / 5)
      end
      GameObj.pcs.each { |s| if s.status =~ /kneeling|sitting|^lying|prone/; fput "pull #{s.noun}"; end; } if GameObj.npcs.any? { |s| s.type =~ /aggressive npc/ } && @PULL
      
      if GameObj.pcs.any? { |s| s.status =~ /dead/ } && @DEADER
        puts "#{monsterbold_start} Found a deader! #{monsterbold_end}"
        echo "PAUSING SCRIPT"
        echo ";u bigshot"
        echo "TO CONTINUE"
        pause_script 
      end
      
      @followers.add_event(:CAST_SIGNS)
      prepare_for_movement()
    end
    cast_signs()
  end

  def do_hunt()
    echo "do_hunt" if $bigshot_debug
    spam() if UserVars.op['spam']


    start_watch()
    message('Bigshot hunting')

    # loop
    target = nil
    just_arrived = true
    last_attack = 0
    reset_variables()

    while true
      while ((target = find_target(target, just_arrived)) && !should_rest? && no_players_hunt == true && !$bigshot_flee)
        echo "inside do_hunt loop" if $bigshot_debug
        echo target if $bigshot_debug
        target = find_target(nil) if @PRIORITY && !priority(target)
        if ((Time.now.to_i - last_attack > 15) || just_arrived)
          @followers.add_event(:ATTACK)
          last_attack = Time.now.to_i
        end
        attack(target)
        just_arrived = false
        loot() if $ambusher_here == false
      end
      # prepare_for_movement()
      echo "Exiting attack loop" if $bigshot_debug
      gather_ammo()

      if (should_rest?)
        break
      else
        target = bs_wander()
        just_arrived = true
      end
    end

    unspam()
  end

  # this is a leader method
  def hunt()
    echo "hunt" if $bigshot_debug
    pre_hunt()
    do_hunt()
    rest()
  end

  # this is a leader method
  def rest()

    # Stop bigshot hunting monitor
    hunt_monitor("stop")

    echo "rest" if $bigshot_debug
    message("Bigshot resting: #{$rest_reason}")
    $bigshot_should_rest = nil
    if @BOUNTY_MODE # bounty script should take over from here
      echo "Bounty mode. Killing self. Reason: #{$rest_reason}"
      exit
    end

    stop_watch()

    # prep/go
    prepare_for_movement()
    set_obvious_hiding_player(false)
    if (@FOG_RETURN.to_i != 0 && @FOG_OPTIONAL == false) || (@FOG_RETURN.to_i != 0 && @FOG_OPTIONAL == true && $rest_reason =~ /wounded|encumbered/)
      sleep(0.5)
      waitcastrt?
      waitrt?
      if @FOG_RETURN.to_i == 1
        if Spell[130].known? && Spell[130].affordable?
          Spell[130].cast()
        elsif Spell[9825].known?
          sleep(0.5)
          waitcastrt?
          waitrt?
          fput "symbol of return"
        end
      elsif @FOG_RETURN.to_i == 2
        if Spell[9825].known?
          temproom = Room.current.id
          sleep(0.5)
          waitcastrt?
          waitrt?
          fput "symbol of return"
          sleep(0.5)
          if (Room.current.id == temproom && Spell[130].known? && Spell[130].affordable?)
            Spell[130].cast()
          end
        end
      elsif @FOG_RETURN.to_i == 3
        if Spell[1020].known? && Spell[1020].affordable?
          Spell[1020].cast()
        end
      elsif @FOG_RETURN.to_i == 4
        if Spell[9720].known? && Spell[9720].affordable?
          Spell[9720].cast()
          sleep(0.5)
          waitcastrt?
          waitrt?
        end
      end
    end

    # resetting overkill counter
    $bigshot_overkill_counter = 0

    # resetting lte_boost counter
    $bigshot_lte_boost_counter = 0

    @followers.add_event(:HUNTING_SCRIPTS_STOP)
    croak_scripts(@HUNTING_SCRIPTS)

    goto(@RESTING_ROOM_ID)
    if (@QUIET_FOLLOWERS)
      @followers.add_event(:STAY_QUIET)
    else
      @followers.add_event(:FOLLOW_NOW)
    end
    while (!@followers.all_present?)
      message("Waiting for followers....")
      sleep(REST_INTERVAL / 5)
    end
    # Stops followers from doing things like using waggle while the leader is selling loot.

    @followers.add_event(:RESTING_PREP_COMMANDS)
    @RESTING_COMMANDS.each { |i|
      fput(i)
      sleep(0.3)
    }

    @followers.add_event(:RESTING_SCRIPTS_START)
    run_scripts(@RESTING_SCRIPTS, true)

    if ($rest_reason =~ /No blessing on weapon|Ammo had no effect \(need blessed or magical\)/i)
      message("Need a blessing on weapon to continue hunting")
      Script.self.kill
    end

    if (!solo? && leading?)
      @followers.group_assist(true)
    end

	if $bigshot_single
      echo "Single Bigshot loop complete"
      Script.self.kill
    end



    # loop
    until (should_hunt?)
      @followers.add_event(:DISPLAY_WATCH)
      fput 'exp'
      display_watch_current()
      display_watch_average()
      display_watch_total()
      display_items_for_blessing()
      message("Bigshot last rested because: #{$rest_reason}") if $rest_reason
      message("Bigshot isn't hunting because: #{$not_hunting_reason}") if $not_hunting_reason
      sleep(REST_INTERVAL)
    end

    hunt() if !$bigshot_bandits
  end

  def attack(target)
    echo "attack" if $bigshot_debug
    commands = find_routine(target)
    echo "Inside attack(target) #{commands}" if $bigshot_debug

    commands.each do |i|
      break unless valid_target?(target)
      break if wounded? || $bigshot_should_rest
      break if $ambusher_here
      break if $obvious_hiding_player

      temp_var = !GameObj.npcs.any? { |s| s.id == target.id }
      break if target.status =~ /dead|gone/ || temp_var
      break if should_flee?
      break if should_rest?
      break if !($bigshot_bandits) && @PRIORITY && !priority(target)

      stand(i) if !standing?
      cast_signs()

      echo "reaction_check" if $bigshot_debug
      echo "| #{$bigshot_reaction}" if $bigshot_debug
      echo "| #{@WEAPON_REACTION}" if $bigshot_debug
      perform_reaction if ($bigshot_reaction != nil) && @WEAPON_REACTION
      cmd(i, target)
    end
    echo "commands.size = #{commands.size}" if $bigshot_debug
    # sleep 1 if commands.size == 0
  end

  def goto(id, cast_signs_moving=true)
    echo "goto" if $bigshot_debug
    prepare_for_movement(cast_signs_moving)
    set_obvious_hiding_player(false)
    until (Room.current.id == id)
      run_script('go2', true, [id, '_disable_confirm_'])
    end
  end

  def start_watch()
    echo "start_watch" if $bigshot_debug
    @START_TIME = Time.now.to_i
  end

  def stop_watch()
    echo "stop_watch" if $bigshot_debug
    if (@START_TIME > 100)
      @STORED_TIMES.push(Time.now.to_i - @START_TIME)
    end
    @START_TIME = 0
  end

  def display_watch_current()
    echo "display_watch_current" if $bigshot_debug
    if (@STORED_TIMES.size > 0)
      seconds = @STORED_TIMES[-1]
      message(sprintf("Bigshot: Last Hunt: %d min. %0.2f secs.",
                      seconds / 60, seconds % 60))
    end
  end

  def display_watch_average()
    echo "display_watch_average" if $bigshot_debug
    average = 0
    if (@STORED_TIMES.size == 1)
      average = @STORED_TIMES[0]
    elsif (@STORED_TIMES.size > 1)
      @STORED_TIMES.each { |i| average += i }
      average /= @STORED_TIMES.size
    else
      return
    end
    message(sprintf("Bigshot: Average Hunt: %d min. %0.2f secs.",
                    average / 60, average % 60))
  end

  def display_watch_total()
    echo "display_watch_total" if $bigshot_debug
    total = Time.now.to_i - @BIRTH_TIME
    message(sprintf("Bigshot: Total Time Running: %d min.  %0.2f secs.",
                    total / 60, total % 60))
  end

  def display_items_for_blessing()
    echo "display_items_for_blessing" if $bigshot_debug
    $bigshot_bless = $bigshot_bless - ["", nil]
    bless_bundles = false
    if $bigshot_bless.count > 0
      message(sprintf("Bigshot: The following items should be blessed before next hunt"))
      $bigshot_bless.each { |id|
        noun = GameObj.inv.find { |obj| obj.id == "#{id}" }
        if noun.nil? or noun.empty?
          bless_bundles = true
        else
        message(sprintf("Bigshot: #{noun}"))
        end
      }
      message(sprintf("Bigshot: arrows or other bundled weapon-type")) if bless_bundles
    end
    bless_bundles = false
  end

  def room_id()
    echo "room_id" if $bigshot_debug
    return Room.current.id()
  end

  def name()
    return Char.name
  end

  def poaching?()
    echo "poaching?" if $bigshot_debug
    if ($bigshot_quick && $grouplist.size > 0)
      return false
    elsif (leading?)
      message "Obvious hiding player present" if $obvious_hiding_player
      return true if $obvious_hiding_player

      (checkpcs - $grouplist).each { |i| return true unless @followers.get_names.include?(i) }
      if solo? && !$bigshot_quick
        message "Obvious hiding player present" if $obvious_hiding_player
        return true if $obvious_hiding_player

        GameObj.npcs.each { |i| return true if i.type =~ /companion/ && i.name !~ /#{$companion}/i }
        GameObj.npcs.each { |i| return true if i.type =~ /familiar/ && i.name !~ /#{$familiar}/i }
      end
      return false
    else
      return false
    end
  end

  def perform_reaction()
    echo "performing weapon reaction" if $bigshot_debug

    #reactions = {
    #  "Clobber" => "clobber",
    #  "Overpower" => "overpower",
    #  "Radial Sweep" => "radialsweep",
    #  "Reactive Shot" => "reactiveshot",
    #  "Reverse Strike" => "reversestrike",
    #  "Riposte" => "riposte",
    #  "Spin Kick" => "spinkick"
    #  }

    fput "weapon #{$bigshot_reaction}"
    $bigshot_reaction = nil
  end

  def get_grouplist()
    return $grouplist
  end

  def should_flee?(just_entered = false)
    echo "should_flee" if $bigshot_debug
    return false if $bigshot_quick
    return false if $bigshot_bandits
    return true if $bigshot_flee

    GameObj.loot.each { |i| return true if i.noun =~ /cloud|breath/ } if @FLEE_CLOUDS
    GameObj.loot.each { |i| return true if i.name == 'intense shimmering circle' } if @FLEE_CLOUDS
    GameObj.loot.each { |i| return true if i.noun =~ /vine/ } if @FLEE_VINES
    GameObj.loot.each { |i| return true if i.noun =~ /web/ } if @FLEE_WEBS
    GameObj.loot.each { |i| return true if i.name =~ /black void/ } if @FLEE_VOIDS
    return true if GameObj.npcs.any?  { |i| @ALWAYS_FLEE_FROM.include?(i.noun) or @ALWAYS_FLEE_FROM.include?(i.name) }
    return true if checkpcs.any?      { |i| @ALWAYS_FLEE_FROM.include?(i) }
    return true if GameObj.npcs.any? { |i| i.name =~ BOON_LIST_ADJECTIVES } && @BOON_FLEE_FROM
    return true if !leading? && checkpcs.empty?

    npcs = GameObj.npcs.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| (@INVALID_TARGETS.include?(npc.name) or @INVALID_TARGETS.include?(npc.noun)) }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
    npcs.delete_if { |npc| npc.noun =~ /^(?:arm|arms|grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i }
    npcs.delete_if { |npc| ['quickly growing troll king', 'severed troll arm', 'severed troll leg'].include?(npc.name) }
    npcs.delete_if { |npc| npc.type =~ /companion|familiar/i && npc.type !~ /aggressive npc/i }

    flee_count = (just_entered && @LONE_TARGETS_ONLY) ? 1 : @FLEE_COUNT
    if npcs.size > flee_count
      return true
    end
  end

  def valid_target?(target, just_entered = false)
    echo "valid_target? (given #{target})" if $bigshot_debug
    echo "return false if target == nil #{target == nil} || target == false #{target == false}" if $bigshot_debug
    return false if target == nil || target == false

    echo "return false if should_flee?(just_entered) #{should_flee?(just_entered)}" if $bigshot_debug
    return false if should_flee?(just_entered)

    echo " return false if just_entered #{just_entered} && poaching? #{poaching?}" if $bigshot_debug
    return false if just_entered && poaching?

    echo " false if target.noun.... (not last one)" if $bigshot_debug
    return false if target.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && target.name !~ /ethereal|celestial|unworldly/i

    echo " false if target.name =~ /animated/ #{ target.name =~ /animated/ }" if $bigshot_debug
    if target.name =~ /animated/
      CharSettings['untargetable'].push(target.name) if target.status !~ /dead|gone/
      return false
    end
    if (!CharSettings['targetable'].include?(target.name) && !CharSettings['untargetable'].include?(target.name) && target.status !~ /dead|gone/)
      result = dothistimeout("target ##{target.id}", 3, /^You are now targeting|^You can't target/)
      if (result =~ /^You are now targeting/)
        CharSettings['targetable'].push(target.name) if target.status !~ /dead|gone/
      elsif (result =~ /^You can't target/)
        CharSettings['untargetable'].push(target.name) if target.status !~ /dead|gone/
      end
    end
    echo "return false if CharSettings['untargetable'].include?(target.name)  #{CharSettings['untargetable'].include?(target.name)}" if $bigshot_debug
    return false if CharSettings['untargetable'].include?(target.name)

    echo "return false if (target.status =~ /dead|gone/)  #{(target.status =~ /dead|gone/)}" if $bigshot_debug
    return false if (target.status =~ /dead|gone/)

    temp_var = !GameObj.npcs.any? { |n| n.id == target.id } # Exists solely for debug printout
    echo "!GameObj.npcs.any? { |n| n.id == target.id }  #{temp_var}" if $bigshot_debug
    return false if temp_var

    if (@TARGETS.nil? or @TARGETS.keys.any? { |i| target.name =~ /#{i}/i or target.noun =~ /#{i}/i })
      echo "returning true from valid_target for #{target.name}" if $bigshot_debug
      return true
    else
      echo "Returning valid_target == false for #{target.name}" if $bigshot_debug
      return false
    end
  end

  def sort_npcs()
    echo "sort_npcs" if $bigshot_debug
    if $bigshot_quick || $bigshot_bandits
      targets = Hash.new
      tokens = []
      if @QUICKHUNT_TARGETS.nil?
        @QUICKHUNT_TARGETS = Hash.new
        @QUICKHUNT_TARGETS["ZZTestZZ"] = "ZZTestZZ"
      end
      npcs = GameObj.npcs.find_all { |i| i.status !~ /dead|gone/ }
      npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
      npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
      if ($bigshot_bandits)
        npcs.delete_if { |npc| npc.noun !~ /thief|rogue|bandit|mugger|outlaw|highwayman|marauder|brigand|thug|robber/i && npc.name !~ /ethereal|celestial|unworldly/i }
      end
      npcs.each { |i| tokens.push(i.name) }
      tokens.uniq.each { |i|
        if i =~ /#{@QUICKHUNT_TARGETS.keys.join('|')}/i
          next
        else
          targets[i] = "quick"
        end
      }
      @TARGETS.replace(@QUICKHUNT_TARGETS)
      @TARGETS.merge!(targets)
      targets = @TARGETS
    else
      targets = @TARGETS
    end

    npcs = GameObj.npcs
    sorted = Array.new
    targets.keys.each { |target| sorted += npcs.find_all { |npc| (npc.name =~ /^#{target}$/i or npc.noun =~ /^#{target}$/i) }.to_a }
    sorted.flatten
  end

  def priority(target)
    echo "priority" if $bigshot_debug
    return true if (!$current_room_npcs.zip($room_npcs_last_check).map { |x, y| x.id == y.id }.any? { |s| s == false })

    $room_npcs_last_check = GameObj.npcs
    priority = false
    stoppriority = false
    npcs = GameObj.npcs.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
    @TARGETS.keys.each { |t|
      break if stoppriority == true

      npcs.each { |s|
        break if stoppriority == true

        if (s.name =~ /#{t}/i or s.noun =~ /#{t}/i)
          if s.name == target.name
            stoppriority = true
            priority = true
          else
            stoppriority = true
          end
        end
      }
    }
    return priority
  end

  def find_target(target, just_entered = false)
    echo "find_target" if $bigshot_debug
    return target if valid_target?(target, just_entered)

    if @PRIORITY && !$bigshot_bandits
      echo "@PRIORITY && !$bigshot_bandits" if $bigshot_debug
      sort_npcs.each { |i| return i if valid_target?(i, just_entered) && priority(i) }
    else
      sort_npcs.each { |i| return i if valid_target?(i, just_entered) }
    end
    echo "\n\n\nfind target returning nil\n\n\n" if $bigshot_debug
    return nil
  end

  def rt?()
    echo "rt?" if $bigshot_debug
    return checkrt()
  end

  def fried?()
    if (percentmind() >= @FRIED)
      return true
    else
      return false
    end
  end

  def oom?()
    if (percentmana() < @OOM)
      return true
    else
      return false
    end
  end

  def saturated?()
    if checkmind =~ /saturated/
      return true
    else
      return false
    end
  end

  def overkill?()
    if ($bigshot_overkill_counter >= @OVERKILL && lte_boost?)
      return true
    else
      return false
    end
  end

  def set_help_group(keep_attacking)
    @HELP_GROUP_KILL = keep_attacking
  end

  def lte_boost?()
    if ($bigshot_lte_boost_counter >= @LTE_BOOST)
      return true
    else
      return false
    end
  end

  def use_lte_boost()
    if (fried? && !lte_boost?) # Need the check because of the race condition caused if you are a follower in RT when called
      boost_attempt = dothistimeout "boost longterm", 3, /You do not have any Long-Term Experience Boosts to redeem.|You have deducted 500 experience points from your field experience/
      if boost_attempt =~ /You do not have any Long-Term Experience Boosts to redeem./
        message("No more LTE boosts available - Skipping")
        $bigshot_lte_boost_counter = @LTE_BOOST
        add_overkill()
      elsif boost_attempt =~ /You have deducted 500 experience points from your field experience/
        $bigshot_lte_boost_counter += 1
        message("Used LTE Boost: #{$bigshot_lte_boost_counter} of #{@LTE_BOOST}")
        $bigshot_overkill_counter = 0
      end
    end
  end

  def ammo_on_ground(ammo)
    echo "ammo_on_ground" if $bigshot_debug
    return GameObj.loot.find { |i| i.name =~ /\b#{ammo}s?\b/i or i.noun =~ /^#{ammo}s?$/i }
  end

  def gather_ammo()
    echo "gather_ammo" if $bigshot_debug
    ammo = @AMMO
    container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
    hide = @HIDE_FOR_AMMO

    return if wounded?

    if ammo.nil? or ammo.empty?
      return
    end

    if ammo =~ /\b(arrow|bolt|dart)\b/i
      ammo_noun = $1
    else
      echo "failed to gather: invalid ammo type specified (use the full name)"
    end

    if container.nil?
      echo "failed to gather: you must specify an ammo container to use this feature"
      return
    end

    while (ammo_on_ground(ammo_noun))
      change_stance('defensive')

      unless GameObj.right_hand.id.nil?
        line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
      end

      result = dothistimeout("gather #{ammo_noun}", 2, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/)

      if (result =~ /on the ground/)
        result = dothistimeout "get #{ammo_noun}s", 3, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/
      end

      if (result =~ /^You gather|^You pick up/)
        dothistimeout("put my #{ammo_noun} in my #{ammo_noun}s in my #{container.noun}", 2, /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/)
        bs_put "put my #{ammo_noun} in my ##{container.id}" if righthand?
      elsif (result =~ /You may only/)
        return
      elsif (result == false || result =~ /^I could not find|^What were you/)
        return
      elsif (result =~ /reach/)
        bs_put 'hide' if hide and not hidden?
        sleep(4)
      end
    end
  end

  def reset_variables()
    echo "reset_variables" if $bigshot_debug
    $ambusher_here = false
    $bigshot_smite_list = []
    $bigshot_aim = 0
    $bigshot_ambush = 0
    $bigshot_archery_aim = 0
    $bigshot_archery_stuck_location = []
    $bigshot_unarmed_tier = 1
    $bigshot_unarmed_followup = false
    $bigshot_unarmed_followup_attack = ""
    $bigshot_703_list = []
    $bigshot_1614_list = []
    $bigshot_reaction = nil
  end

  def wounded?()
    echo "wounded?" if $bigshot_debug
    if $bigshot_quick
      return false
    elsif (@WOUNDED_EVAL)
      return eval @WOUNDED_EVAL
    else
      return false
    end
  end

  def should_hunt?()
    echo "should_hunt?" if $bigshot_debug
    if (wounded?)
      $not_hunting_reason = 'wounded.'
      return false
    elsif (percentencumbrance >= @ENCUMBERED)
      $not_hunting_reason = 'encumbered.'
      return false
    elsif (@RESTING_SCRIPTS.any? { |i| running?(i) })
      $not_hunting_reason = 'resting scripts still running.'
      return false
    end

    followers_should = (leading? && !solo?) ? @followers.should_hunt? : true
    if (followers_should)
      if (percentmind() > @REST_TILL_EXP)
        $not_hunting_reason = 'mind still above threshold.'
        return false
      elsif (percentmana() < @REST_TILL_MANA)
        $not_hunting_reason = 'mana still below threshold.'
        return false
      elsif (checkspirit() < @REST_TILL_SPIRIT)
        $not_hunting_reason = 'spirit still below threshold.'
        return false
      end
    else
      $not_hunting_reason = 'followers still need rest.'
      return false
    end
    $bigshot_status = :hunting
    return true
  end

  def should_rest?()
    echo "should_rest?" if $bigshot_debug
    if ($bigshot_quick)
      return false
    elsif ($bigshot_should_rest)
      $rest_reason = "$bigshot_should_rest was set to true." unless $rest_reason
      $bigshot_status = :resting
      return true
    elsif (wounded?)
      $rest_reason = "wounded."
      $bigshot_status = :resting
      return true
    elsif (percentencumbrance >= @ENCUMBERED)
      $rest_reason = "encumbered."
      $bigshot_status = :resting
      return true
    elsif (leading? && !solo? && @followers.emergency_rest?)
      $rest_reason = "emergency rest."
      $bigshot_status = :resting
      return true
    elsif (!solo? && !leading? && @HELP_GROUP_KILL)
      return false if !oom?
    end

    if (leading? && !solo? && fried? && overkill? && lte_boost?)
      @followers.group_assist(false)
    end

    followers_fried = (leading? && !solo?) ? (@followers.should_rest? && overkill? && lte_boost?) : true

    if (followers_fried)
      if (fried? && overkill? && lte_boost?)
        $rest_reason = "fried."
        $bigshot_status = :resting
        return true
      elsif (oom?)
        wrack() if @USE_WRACKING
        return false if !oom?

        $rest_reason = "out of mana."
        $bigshot_status = :resting
        return true
      end
    end

    $rest_reason = "none."
    if (!solo? && leading?)
      @followers.group_assist(true)
    end
    return false
  end

  def add_overkill()
    if (fried? && lte_boost?)
      $bigshot_overkill_counter += 1
      message("Extra Kills currently at: #{$bigshot_overkill_counter} of #{@OVERKILL}")
    end

    if (!solo? && leading?)
      @followers.add_event(:FOLLOWER_OVERKILL)
    end
  end

  def cast_signs(single_cast = false)
    echo "cast_signs?" if $bigshot_debug
    @SIGNS.each do |i|
      i = i.to_i
      next if [9903, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9912, 9913, 9914, 9918].include?(i) and Spell[9012].active?
      next if i == 9918
      next if i == 9603 && Spell[9604].active?
      next if i == 9605 && Spell[9606].active?
      next if i == 320 && Spell[399].active?

      sign = Spell[i]
      next unless sign.known?

      # wrack?
      mana_cost = sign.mana_cost > 1 ? sign.mana_cost : 0 # Many erroneously return 1
      wrack() if !sign.affordable? and mana_cost > checkmana and @USE_WRACKING

      if (!sign.active? && sign.affordable?)
        if (i == 9805)
          2.times { sign.cast }
        else
          while (1)
            result = sign.cast
            break if result !~ /Spell Hindrance/ || !sign.affordable? || dead?
          end
        end

        break if single_cast
      end
    end
  end

  def loot()
    echo "loot" if $bigshot_debug
    waitrt?
    if checkroom("Duskruin Arena, Dueling Sands").nil?
      dead_npcs = GameObj.npcs.find_all { |i| i.status == 'dead' && i.type !~ /escort/i }
      reset_variables() if !dead_npcs.nil? && dead_npcs != []
      if @DELAY_LOOT && sort_npcs.any? { |s| valid_target?(s) } && (!dead_npcs.nil? && dead_npcs != []) && !should_flee?
        if $last_loot.nil?
          $last_loot = Time.now + 15
        elsif $last_loot <= Time.now
          $looting_inactive = false
          dead_npcs.each { |i|
            $last_loot = nil
            use_lte_boost()
            add_overkill()
            change_stance('defensive') if GameObjNpcCheck() > 0 && @LOOT_STANCE
            if (@LOOT_SCRIPT)
              run_script(@LOOT_SCRIPT, true)
              break
            else
              bs_put "loot ##{i.id}"
              bs_put "loot room"
            end
          }
          $looting_inactive = true
        end
      else
        $looting_inactive = false
        dead_npcs.each { |i|
          $last_loot = nil
          use_lte_boost()
          add_overkill()
          change_stance('defensive') if GameObjNpcCheck() > 0 && @LOOT_STANCE
          if (@LOOT_SCRIPT)
            run_script(@LOOT_SCRIPT, true)
            break
          else
            bs_put "loot ##{i.id}"
            bs_put "loot room"
          end
        }
        $looting_inactive = true
      end
    end
  end

  def set_obvious_hiding_player(player_present)
    $obvious_hiding_player = player_present
    if !solo? && leading?
      @followers.obv_hide_set(player_present)
    end
  end

  def get_obvious_hiding_player_status()
    return $obvious_hiding_player
  end

  def prepare_for_movement(move_signs=true)
    echo "prepare_for_movement" if $bigshot_debug
    echo "move_signs is #{move_signs}" if $bigshot_debug
    reset_variables()
    change_stance('defensive')
    if (leading? && !solo?)
      @followers.add_event(:PREP_REST) if move_signs
      @followers.add_event(:FOLLOW_NOW) if !move_signs
      wait_while { @followers.roundtime? }
      sleep(0.3)
    end
    cmd_bless() if @BLESS && $bigshot_bless.count > 0
    cast_signs if move_signs
  end

  def bs_wander()
    echo "bs_wander" if $bigshot_debug
    $wander_rooms    ||= Array.new

    wander = proc {
      room = Room.current
      next_room_options = room.wayto.keys - @HUNTING_BOUNDARIES
      next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
      next_room = next_room_options.find_all { |r| not $wander_rooms.include?(r) }
      if next_room.empty?
        next_room = $wander_rooms.find { |r| next_room_options.include?(r) }
      else
        next_room = next_room[rand(next_room.length)]
      end
      $wander_rooms.delete(next_room)
      $wander_rooms.push(next_room)
      way = room.wayto[next_room]
      if way.class == String
        pause @WANDER_WAIT
        move(way)
      else
        way.call
      end
      GameObj.pcs.each { |s| if s.status =~ /kneeling|sitting|^lying|prone/; fput "pull #{s.noun}"; end; } if GameObj.npcs.any? { |s| s.type =~ /aggressive npc/ } && @PULL
      if GameObj.pcs.any? { |s| s.status =~ /dead/ } && @DEADER
        puts "#{monsterbold_start} Found a deader! #{monsterbold_end}"
        echo "PAUSING SCRIPT"
        echo ";u bigshot"
        echo "TO CONTINUE"
        pause_script 
      end
      cast_signs(true)
    }

    while true # wander, check for players
      prepare_for_movement()
      exit if $bigshot_quick
      npcs = GameObj.npcs
      npcs.delete_if { |npc| (npc.status =~ /dead|gone/) }
      sort_npcs.each { |i| return i if valid_target?(i, true) and no_players == true and (GameObjNpcCheck() > 0) }
      return if should_rest?

      set_obvious_hiding_player(false)
      wander.call
      sleep(0.1)
      $bigshot_flee = false
    end
  end

  def CompanionCheck()
    if (Char.prof =~ /Ranger/i && Spell[630].known? && GameObj.npcs.any? { |i| i.type =~ /companion/ } && $companion == nil)
      npcs = GameObj.npcs.find_all { |i| i.type =~ /companion/i }
      npcs.each { |i|
        res = dothistimeout "lean ##{i.id}", 1, /your direction in acknowledgement|rubbing.*gently|while it is flying|You lean toward/i
        if res =~ /rubbing.*gently/i
          $companion = i.name
          echo "Ranger Companion set to #{i.name}"
          break
        end
      }
    end
    if (Char.prof =~ /Wizard/i && Spell[920].known? && GameObj.npcs.any? { |i| i.type =~ /familiar/ })
      res = dothistimeout "tell familiar to return", 1, /You sense understanding from your .*\.|You have no familiar at this time\./i
      if res =~ /You sense understanding from your/i
        res.sub!('You sense understanding from your ', '')
        res.gsub!('.', '')
        GameObj.npcs.each { |s|
          if s.name =~ /#{res}/i
            $familiar = s.name
            break
          end
        }
        echo "Familiar set as #{$familiar}"
      end
    end
  end

  def RoaterEscape()
    find_all_containers_var = nil
    empty_hands
    hp = proc { |ss| if ss =~ /^You are wearing/; DownstreamHook.remove('find_all_container_ids'); nil; else; ss; end }
    DownstreamHook.add('find_all_container_ids', hp)
    restore_silent = script.silent
    restore_want_downstream = script.want_downstream
    restore_want_downstream_xml = script.want_downstream_xml
    script.silent = true
    script.want_downstream = false
    script.want_downstream_xml = true
    clear
    put 'inventory containers'
    script.silent = restore_silent
    timeout = Time.now + 30
    container_ids = []
    while (Time.now < timeout) and (line = get)
      if line =~ /^You are wearing/
        container_ids = line.scan(/<a exist=\"([^\"]+)\"/).flatten
        break
      end
    end
    script.want_downstream = restore_want_downstream
    script.want_downstream_xml = restore_want_downstream_xml
    clear
    find_all_containers_var = container_ids.collect { |id| GameObj[id] }
    find_all_containers_var.each { |i|
      if i.contents.nil?
        fput "look in ##{i.id}"
      end
      i.contents.each { |s|
        if s.name =~ /alfange|basilard|bodkin|cinquedea|dagger|dirk|knife|kozuka|ice pick|misericord|parazonium|pavade|poignard|pugio|scramasax|sgian achlais|spike|stiletto|tanto|sidearm-of-Onar/i
          fput "_drag ##{s.id} right"
          while !checkroom("The Belly of the Beast").nil?
            waitrt?
            fput "attack wall"
          end
          fput "_drag ##{s.id} ##{i.id}"
          break
        end
      }
    }
    fill_hands
  end

  def bs_put(message)
    echo "bs_put" if $bigshot_debug
    unless script = Script.self then respond('--- waitfor: Unable to identify calling script.'); return false; end
    clear
    put(message)

    while string = get
      if string =~ /(?:\.\.\.wait |Wait )[0-9]+/
        hold_up = string.slice(/[0-9]+/).to_i
        sleep(hold_up - 1) unless hold_up.nil? || hold_up == 1
        clear
        put(message)
        next
      elsif string =~ /struggle.+stand/
        clear
        bs_put("stand")
        next
      elsif string =~ /stunned|can't do that while|cannot seem|can't seem|don't seem|Sorry, you may only type ahead/
        if dead?
          echo("You're dead...! You can't do that!")
          sleep(0.25)
          script.downstream_buffer.unshift(string)
          return false
        elsif checkstunned
          while checkstunned
            sleep(0.25)
          end
        elsif checkwebbed
          while checkwebbed
            sleep(0.25)
          end
        else
          sleep(0.25)
        end
        clear
        put(message)
        next
      else
        script.downstream_buffer.unshift(string)
        return string
      end
    end
  end

  def group_put(message)
    echo "group_put" if $bigshot_debug
    bs_put(message)
  end

  def group_cmd(message)
    echo "group_cmd" if $bigshot_debug
    cmd(message)
  end

  def group_do(message)
    echo "group_do" if $bigshot_debug
    do_client(message)
  end

  # gui
  def self.setup
    @theme_state = Lich.track_dark_mode if defined? Lich.track_dark_mode
    Gtk.queue do
      @get_vBox = proc {
        if Gtk.check_version(3,0,0).nil?
          Gtk::Box.new(:vertical)
        else
          Gtk::VBox.new(false, 0)
        end
      }
      @OP_WINDOW = Gtk::Window.new
      @OP_WINDOW.title = "Big Shot: v#{BIGSHOT_VERSION}"
      @OP_WINDOW.set_icon(@default_icon)
      @OP_WINDOW.set_border_width(10)
      @OP_WINDOW.keep_above = true

			if Gtk.check_version(3,0,0).nil? && (@theme_state == 'off' or @theme_state.nil?)
        grey = Gdk::RGBA::parse("#d3d3d3")
      	@OP_WINDOW.override_background_color(:normal, grey)
			end
      @OP_BOX = @get_vBox.call
      @OP_BOX.set_border_width(5)
      @OP_WINDOW.add(@OP_BOX)

      @OP_NOTEBOOK = Gtk::Notebook.new
      @OP_NOTEBOOK.set_show_border(true)
			if Gtk.check_version(3,0,0).nil? && (@theme_state == 'off' or @theme_state.nil?)
      	@OP_NOTEBOOK.override_background_color(:normal, grey)
			end
      @OP_BOX.add(@OP_NOTEBOOK)
      @OP_ENTRY = Hash.new # For mapping entries to variables
      @OP_TABLE_SIZE = Hash.new # For mapping table sizes
    end

    Gtk.queue do
      tab_names = %w[
        General
        Resting
        Hunting\ Map
        Hunting
        Attacking
        Commands
        UAC
        MSTRIKE
        Should_hunt?
        Should_rest?
        Ammo/Wands
        Monitoring
      ]

      tab_names.each.with_index(1) do |name, val|
        new_table = Gtk::Table.new(6, 3, false).tap do |table|
          table.row_spacings = 3
          table.column_spacings = 3
        end

        new_box = if Gtk.check_version(3,0,0).nil?
          Gtk::Box.new(:vertical)
        else
          Gtk::VBox.new(false, 0)
        end

        if Gtk.check_version(3,0,0).nil?
          new_box.pack_start(new_table, expand: false, fill: false, padding: 0)
        else
          new_box.pack_start(new_table, false, false, 0)
        end

        @OP_NOTEBOOK.append_page(new_box, Gtk::Label.new(name))

        instance_variable_set("@OP_TABLE#{val}", new_table)
        instance_variable_set("@OP_VERTICAL_BOX#{val}", new_box)
      end
    end

    def self.add_label_entry(table, label, variable)
      size = @OP_TABLE_SIZE[table] || 0

      label = Gtk::Label.new(label)
      align = Gtk::Alignment.new 1, 0, 0, 0
      align.set_padding(4, 0, 3, 4)
      align.add(label)
      table.attach(align, 0, 1, size, size + 1)

      entry = Gtk::Entry.new
      entry.text = UserVars.op[variable].to_s
      entry.set_width_request(200)
      table.attach(entry, 1, 2, size, size + 1)

      @OP_ENTRY[variable] = entry
      @OP_TABLE_SIZE[table] += 1
    end

    def self.add_dropdown(table, dropdown, variable, options)
      size = @OP_TABLE_SIZE[table] || 0
      i = 0

      label = Gtk::Label.new(dropdown)
      dropdown = if Gtk.check_version(3,0,0).nil?
        Gtk::ComboBoxText.new
      else
        Gtk::ComboBox.new
      end

      options.split(',').each { |s| dropdown.append_text(s) }
      if UserVars.op[variable].nil?
        dropdown.set_active(0)
      else
        if UserVars.op[variable].class.to_s != "Fixnum" && UserVars.op[variable].class.to_s != "Integer"
          UserVars.op[variable] = 0
        end
        dropdown.set_active(UserVars.op[variable])
      end
      align = Gtk::Alignment.new 1, 0, 0, 0
      align2 = Gtk::Alignment.new 1, 0, 1, 0
      align.set_padding(4, 0, 3, 4)
      align2.set_padding(0, 0, 0, 0)
      align.add(label)
      align2.add(dropdown)
      table.attach(align, 0, 1, size, size + 1)
      table.attach(align2, 1, 2, size, size + 1)
      @OP_ENTRY[variable] = dropdown
      @OP_TABLE_SIZE[table] += 1
    end

    def self.add_text_area(vbox, label, variable)
      # Grab value for a manual check since we can't rely on a version of Ruby with safe operators
      current_value = UserVars.op[variable]

      entry = Gtk::TextView.new
      entry.buffer.text = current_value ? current_value.gsub("||","\n") : ""

      swin = Gtk::ScrolledWindow.new
      swin.border_width = 5
      swin.add(entry)
      swin.set_policy(:AUTOMATIC, :ALWAYS)

      frame = Gtk::Frame.new(label)
      frame.add(swin)

      vbox.pack_start(frame)

      @OP_ENTRY[variable] = entry
    end

    Gtk.queue do
      @OP_ENTRY = Hash.new
      # Resting
      add_label_entry(@OP_TABLE2, "*room id:", 'resting_room_id')
      add_label_entry(@OP_TABLE2, "pre-rest commands:", 'resting_commands')
      add_label_entry(@OP_TABLE2, "active resting scripts:", 'resting_scripts')
      add_dropdown(@OP_TABLE2, "Fog Options:", 'fog_return', 'None,Spirit Guide(130),Voln Symbol of Return,Traveler\'s Song(1020),GoS Sigil of Escape')
      # Hunting Map
      add_label_entry(@OP_TABLE3, "*starting room ID:", 'hunting_room_id')
      add_label_entry(@OP_TABLE3, "*rallypoint ID:", 'rallypoint_room_id')
      add_label_entry(@OP_TABLE3, "*boundary rooms:", 'hunting_boundaries')
      # Hunting
      add_label_entry(@OP_TABLE4, "valid targets:", 'targets')
      add_label_entry(@OP_TABLE4, "quickhunt targets:", 'quickhunt_targets')
      add_label_entry(@OP_TABLE4, "attack stance:", 'hunting_stance')
      add_label_entry(@OP_TABLE4, "pre-hunt commands:", 'hunting_prep_commands')
      add_label_entry(@OP_TABLE4, "active hunting scripts:", 'hunting_scripts')
      add_label_entry(@OP_TABLE4, "society abilities/spells/cmans:", 'signs')
      add_label_entry(@OP_TABLE4, "loot script:", 'loot_script')
      add_label_entry(@OP_TABLE4, "wracking spirit >=", 'wracking_spirit')
      # Attacking
      add_label_entry(@OP_TABLE5, "Ambush aiming locations (head, etc):", 'ambush')
      add_label_entry(@OP_TABLE5, "Archery aiming locations (head, etc):", 'archery_aim')
      add_label_entry(@OP_TABLE5, "flee if enemy count is >", 'flee_count')
      add_label_entry(@OP_TABLE5, "...but don't count these:", 'invalid_targets')
      add_label_entry(@OP_TABLE5, "...and always flee from:", 'always_flee_from')
      add_label_entry(@OP_TABLE5, "flee from environment message:", 'flee_message')
      add_label_entry(@OP_TABLE5, "Wait before wandering to another room:", 'wander_wait')
      # Commands
      add_label_entry(@OP_TABLE6, "hunting commands(a):", 'hunting_commands')
      add_label_entry(@OP_TABLE6, "hunting commands(b):", 'hunting_commands_b')
      add_label_entry(@OP_TABLE6, "hunting commands(c):", 'hunting_commands_c')
      add_label_entry(@OP_TABLE6, "hunting commands(d):", 'hunting_commands_d')
      add_label_entry(@OP_TABLE6, "hunting commands(e):", 'hunting_commands_e')
      add_label_entry(@OP_TABLE6, "hunting commands(f):", 'hunting_commands_f')
      add_label_entry(@OP_TABLE6, "hunting commands(g):", 'hunting_commands_g')
      add_label_entry(@OP_TABLE6, "hunting commands(h):", 'hunting_commands_h')
      add_label_entry(@OP_TABLE6, "hunting commands(i):", 'hunting_commands_i')
      add_label_entry(@OP_TABLE6, "hunting commands(j):", 'hunting_commands_j')
      add_label_entry(@OP_TABLE6, "fried hunting commands:", 'disable_commands')
      add_label_entry(@OP_TABLE6, "quick hunting commands:", 'quick_commands')
      # UAC
      add_label_entry(@OP_TABLE7, "Tier 3 Attack", 'tier3')
      add_label_entry(@OP_TABLE7, "Aim at location (head, etc)", 'aim')
      # MStrike
      add_label_entry(@OP_TABLE8, "MSTRIKE during cooldown stamina requirement", 'mstrike_stamina_cooldown')
      add_label_entry(@OP_TABLE8, "QUICKSTRIKE stamina requirement", 'mstrike_stamina_quickstrike')
      add_label_entry(@OP_TABLE8, "Unfocused MSTRIKE when creatures equal or greater", 'mstrike_mob')
      # Should Hunt?
      add_label_entry(@OP_TABLE9, "*when percentmind <=", 'rest_till_exp')
      add_label_entry(@OP_TABLE9, "...*and percentmana >=", 'rest_till_mana')
      add_label_entry(@OP_TABLE9, "...and CHECKspirit >=", 'rest_till_spirit')
      # Should Rest?
      add_label_entry(@OP_TABLE10, "*when percentmind >=", 'fried')
      add_label_entry(@OP_TABLE10, "...and extra kills >=", 'overkill')
      add_label_entry(@OP_TABLE10, "...and used lte boosts >=", 'lte_boost')
      add_label_entry(@OP_TABLE10, "...*or percentmana <=", 'oom')
      add_label_entry(@OP_TABLE10, "...or percentencumbrance >=", 'encumbered')
      add_label_entry(@OP_TABLE10, "...or wounded eval:", 'wounded_eval')
      # Ammo/Wands
      add_label_entry(@OP_TABLE11, "find ammo in this container:", 'ammo_container')
      add_label_entry(@OP_TABLE11, "use this ammo type:", 'ammo')
      add_label_entry(@OP_TABLE11, "fresh wand container:", 'fresh_wand_container')
      add_label_entry(@OP_TABLE11, "dead wand container:", 'dead_wand_container')
      add_label_entry(@OP_TABLE11, "use this wand type:", 'wand')
      # Monitoring
      add_text_area(@OP_VERTICAL_BOX12, 'Watch for strings (or regexes) that contain', 'monitor_strings')
      add_text_area(@OP_VERTICAL_BOX12, '..except if they also contain', 'monitor_safe_strings')
    end

    def self.add_checkbox(table, x_pos, label, variable, default = false)
      size = @OP_TABLE_SIZE[table] || 0

      checkbox = Gtk::CheckButton.new label
      value = UserVars.op[variable] || default
      checkbox.active = value
      table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
      @OP_ENTRY[variable] = checkbox
      @OP_TABLE_SIZE[table] += 1 if x_pos == 1
    end

    Gtk.queue do
      # General
      add_checkbox(@OP_TABLE1,  0, "Engage deadmans switch", 'dead_man_switch')
      add_checkbox(@OP_TABLE1,  1, "Flee from clouds", 'flee_clouds')
      add_checkbox(@OP_TABLE1,  0, "Depart/rerun if dead", 'depart_switch')
      add_checkbox(@OP_TABLE1,  1, "Flee from vines", 'flee_vines')
      add_checkbox(@OP_TABLE1,  0, "Quiet followers", 'quiet_followers')
      add_checkbox(@OP_TABLE1,  1, "Flee from webs", 'flee_webs')
      add_checkbox(@OP_TABLE1,  1, "Flee from voids", 'flee_voids')
      # Resting
      add_checkbox(@OP_TABLE2,  1, "Fog ONLY if wounded or encumbered", 'fog_optional')
      # Hunting
      add_checkbox(@OP_TABLE4,  0, "Priority hunt", 'priority')
      add_checkbox(@OP_TABLE4,  1, "Use sign of wracking/sigil of power/symbol of mana", 'use_wracking')
      add_checkbox(@OP_TABLE4,  0, "Delay looting", 'delay_loot')
      add_checkbox(@OP_TABLE4,  1, "Defensive stance before looting", 'loot_stance')
      add_checkbox(@OP_TABLE4,  1, "Pull players to feet", 'pull')
      add_checkbox(@OP_TABLE4,  1, "Stop for dead players", 'deader')
      # Attacking
      add_checkbox(@OP_TABLE5,  0, "Flee from boon/boss/glamour creatures", 'boon_flee_from')
      add_checkbox(@OP_TABLE5,  1, "Spam attacks (recommended)", 'spam')
      add_checkbox(@OP_TABLE5,  0, "Approach lone targets only", 'lone_targets_only')
      add_checkbox(@OP_TABLE5,  1, "Bless weapon?", 'bless')
      add_checkbox(@OP_TABLE5,  0, "Activate Weapon Reactions", 'weapon_reaction')
      # UAC
      add_checkbox(@OP_TABLE7,  1, "Use Voln SMITE?", 'uac_smite')
      # MStrike
      add_checkbox(@OP_TABLE8,  1, "MSTRIKE during cooldown", 'mstrike_cooldown')
      add_checkbox(@OP_TABLE8,  1, "Use QUICKSTRIKE for MSTRIKE", 'mstrike_quickstrike')
      # Ammo/Wands
      add_checkbox(@OP_TABLE11, 1, "Hide while waiting to pick up ammo", 'hide_for_ammo')
      add_checkbox(@OP_TABLE11, 1, "Use wands when out of mana", 'wand_if_oom')
      # Monitoring
      add_checkbox(@OP_TABLE12,  0, "Monitor interaction", 'monitor_interaction')
    end

    Gtk.queue do
      @OP_WINDOW.signal_connect("delete_event") do
        @OP_SETUP_COMPLETED = true
      end
    end

    Gtk.queue do
      #      @OP_TOOLTIPS = Gtk::Tooltips.new.enable

      label = Gtk::Label.new
      label.set_markup("<i>Bigshot is the leader of the Battle Patrol.\nHe comes equipped with a gun as long as his entire superstructure.\nTakes the edge off.\n\n\n***Settings with * are required.***</i>")
      align = Gtk::Alignment.new(1, 0, 0, 0)
      align.set_padding(50, 0, 0, 40)
      align.add(label)
      @OP_TABLE1.attach(align, 1, 2, 8, 9)

      commands_tip = "Example 1: 413 target, 903 target\nExample 2: 903 target(x2)\nExample 3: 903 target(xx)\nExample 4: 910 target(m50), 903 target\nExample 5: unarmed punch, wait 30\nExample 1 will cast 413 then 903 on the target. Example 2 will cast 903 on the target twice. Example 3 will cast 903 on the target until the fight is over. Example 4 will cast 910 if mana is at least 50, otherwise it will cast 903. Example 5 will start the unarmed routine with punch as the main attack. It will attack once, then wait 30 seconds for another attack to happen before attacking again.\nSeparate all commands with commas.\n\nNew feature: 'and'.\nFor example: stance def and 1615 target, kill target(xx)"
      disable_tip = "If left blank and this character is in a bigshot group, character will continue to use standard hunting commands after mind is fried and overkill limit is reached\nIf row populated, and character is in a bigshot group, these commands will be used instead of standard hunting commands once fried and overkill limit reached\nSee hunting commands tooltip for examples on what commands to use."

      rallypoint_tip = "If left blank, will set to starting room ID.\nSet to a safe room BEFORE your hunting start point that you want to stop to cast your active hunting spells/signs/sigils/signs and start your active hunting scripts.\n\nIf in a group, and this is the head, then will wait here for all tails before casting your active hunting spells/signs/sigils/signs and start your active hunting scripts.\n\nUse Case Example 1: You are hunting somewhere far away and dont want to cast Wall of Force before walking for half the duration\n\nUse Case Example 2: You want to stop before your climb to start your sigils because there is a climb ahead"
      @OP_ENTRY['rallypoint_room_id'].set_tooltip_text(rallypoint_tip)

      @OP_ENTRY['hunting_commands'].set_tooltip_text(commands_tip)
      @OP_ENTRY['hunting_commands_g'].set_tooltip_text(commands_tip)
      @OP_ENTRY['disable_commands'].set_tooltip_text(disable_tip)

      quiet_followers_tip = "Followers will wait until Leader is done with both actions and resting scripts to begin using their own\n\nUse Case: Prevents you from looking like you have mindless bots following while selling loot"
      @OP_ENTRY['quiet_followers'].set_tooltip_text(quiet_followers_tip)

      signs_tip = "Shadow Mastery - 9603\nSurge of Strength - 9605\n\nSigil of Contact - 9703\nSigil of Resolve - 9704\nSigil of Minor Bane - 9705\nSigil of Defense - 9707\nSigil of Offense - 9708\nSigil of Minor Protection - 9710\nSigil of Focus - 9711\nSigil of Mending - 9713\nSigil of Concentration - 9714\nSigil of Major Bane - 9715\nSigil of Major Determination - 9716\nSigil of Major Protection - 9719\n\nSign of Warding - 9903\nSign of Striking - 9904\nSign of Thought - 9906\nSign of Defending - 9907\nSign of Smiting - 9908\nSign of Staunching - 9909\nSign of Deflection - 9910\nSign of Swords - 9912\nSign of Shields - 9913\nSign of Dissipation - 9914\nSign of Madness - 9916\n\nSymbol of Courage - 9805\nSymbol of Protection - 9806"
      @OP_ENTRY['signs'].set_tooltip_text(signs_tip)

      aim_tip = "Leave blank if you don't want to aim at anything\n\nSuggest leaving chest as last thing to aim at so you will always have something to hit"
      @OP_ENTRY['aim'].set_tooltip_text(aim_tip)
      @OP_ENTRY['archery_aim'].set_tooltip_text(aim_tip)

      mstrike_tip = "Set this to the highest you want your stamina to be before you MSTRIKE.\nImportant if MSTRIKEing during its cooldown or while using QUICKSTRIKE.\nLeave blank to use max stamina variable instead\nCombination of QUICKSTRIKE and MSTRIKE during cooldown may pop muscles.\nIve done best I can to ensure it doesn't happen, but depends on what you set your MSTRIKE stamina to.\n\nWorks in conjunction with MSTRIKE creature #, so if you meet the requirements for it and not this one you will MSTRIKE and visaversa."
      @OP_ENTRY['mstrike_stamina_cooldown'].set_tooltip_text(mstrike_tip)
      @OP_ENTRY['mstrike_stamina_quickstrike'].set_tooltip_text(mstrike_tip)

      mstrike_mob_tip = "How many creatures you want in the room before you perform an unfocused MSTRIKE.\nDefault is 2. Set to 1 to always do an unfocused MSTRIKE."
      @OP_ENTRY['mstrike_mob'].set_tooltip_text(mstrike_mob_tip)

      bless_tip = "If checked, will stop hunt when item's blesses run out.  If unchecked, will continue to hunt and remind to get blesses while resting."
      @OP_ENTRY['bless'].set_tooltip_text(bless_tip)

      weapon_reaction_tip = "Will initiate reactive strikes when the opportunity presents itself"
      @OP_ENTRY['weapon_reaction'].set_tooltip_text(weapon_reaction_tip)

      priority_tip = "Priority is based on order of valid targets box on hunting tab. Will switch to highest priority in room when attacking."
      @OP_ENTRY['priority'].set_tooltip_text(priority_tip)

      smite_tip = "Will SMITE a non-corporeal undead when tier is excellent during UAC Combat"
      @OP_ENTRY['uac_smite'].set_tooltip_text(smite_tip)

      flee_tip = "Input any text that when the game sends you want to move out of the room from\nlike a Roa'ter burrow attack \"You feel a rumble come from beneath your feet.\"\nSeperate different messages with a | in between them."
      @OP_ENTRY['flee_message'].set_tooltip_text(flee_tip)

      fog_tip = "None: Dont use any fog options when you return from a hunt\n\nSpirit Guide(130): Use 130 first, then if that fails Symbol of Return\n\nVoln Symbol of Return: Use Symbol of Return first, then if that fails 130\n\nTraveler's Song(1020): Use 1020 only\n\nGoS Sigil of Escape: Use Sigil of Escape"
      @OP_ENTRY['fog_return'].set_tooltip_text(fog_tip)

      fried_tip = "Percentage of your mind (0-100) after which you will stop hunting.\n  101\t will hunt until mana/encumbrance/wounded\n  100\tis fully fried"
      @OP_ENTRY['fried'].set_tooltip_text(fried_tip)

      overkill_tip = "This is the number of additional monsters to kill after reaching your fried threshold.\n  0    \tWill not kill extra monsters\n  3-5\trecommended to ensure true 100% fried state"
      @OP_ENTRY['overkill'].set_tooltip_text(overkill_tip)

      size = @OP_TABLE_SIZE[@OP_TABLE3]
      label = Gtk::Label.new
      label.set_markup("<i>Note: Big Shot will not enter boundary rooms. The goal is to pin yourself into a hunting area.</i>")
      align = Gtk::Alignment.new(1, 0, 0, 0)
      align.set_padding(75, 0, 0, 4)
      align.add(label)
      @OP_TABLE3.attach(align, 1, 2, size, size + 1)

      size = @OP_TABLE_SIZE[@OP_TABLE4]
      label = Gtk::Label.new
      label.set_markup("<i>Note: Use nouns or name for targets.\nMouse over society abilities field for more info.</i>")
      align = Gtk::Alignment.new(1, 0, 0, 0)
      align.set_padding(10, 0, 0, 300)
      align.add(label)
      @OP_TABLE4.attach(align, 1, 2, size, size + 1)

      size = @OP_TABLE_SIZE[@OP_TABLE5]
      label = Gtk::Label.new
      label.set_markup("<i>Note: Use noun or name for flee info.\nMouse over some hunting commands field for more info.</i>")
      align = Gtk::Alignment.new(1, 0, 0, 0)
      align.set_padding(10, 0, 0, 200)
      align.add(label)
      @OP_TABLE5.attach(align, 1, 2, size, size + 1)

      size = @OP_TABLE_SIZE[@OP_TABLE8]
      label = Gtk::Label.new
      label.set_markup("1107 and 1607 automatically cast if appropriate when using MSTRIKE\nEmpaths and Paladins rejoice!")
      align = Gtk::Alignment.new(1, 0, 0, 0)
      align.set_padding(75, 0, 0, 75)
      align.add(label)
      @OP_TABLE8.attach(align, 1, 2, size, size + 1)

      @OP_WINDOW.show_all
    end

    @OP_SETUP_COMPLETED = false
    until (@OP_SETUP_COMPLETED)
      sleep(0.5)
    end

    UserVars.op ||= Hash.new
    @OP_ENTRY.keys.each do |key|
      echo "#{key} - #{@OP_ENTRY[key].class.to_s}" if $bigshot_debug
      if @OP_ENTRY[key].class.to_s =~ /CheckButton/
        value = @OP_ENTRY[key].active?
        UserVars.op[key] = @OP_ENTRY[key].active?
      elsif @OP_ENTRY[key].class.to_s =~ /ComboBox/
        UserVars.op[key] = @OP_ENTRY[key].active
      elsif @OP_ENTRY[key].class.to_s =~ /TextView/
        # Store these with double pipes so we don't mess up any supplied expressions
        UserVars.op[key] = @OP_ENTRY[key].buffer.text.gsub("\n","||")
      else
        if key == 'wounded_eval'
          UserVars.op[key] = @OP_ENTRY[key].text
        else
          UserVars.op[key] = @OP_ENTRY[key].text.strip.downcase
        end
      end
    end
    UserVars.save

    Gtk.queue do
      @OP_WINDOW.destroy
    end
  end

  def self.profile(vars)
    if vars[2] =~ /load/i
      if vars[3] != nil
        dir = "#{$lich_dir}scripts/bigshot_profiles"
        filename = "#{dir}/#{vars[3]}.yaml"
        if !File.exists?("#{filename}")
          echo "Trying to load a profile that does not exist."
        else
          from_file = YAML.load_file(filename)
          UserVars.op = from_file
          echo "Settings loaded from profile: #{filename}."
        end
      else
        echo "You forgot to name your profile you wish to load."
        echo "Syntax: ;bigshot profile load <NAME Here, no Spaces!>"
      end
    elsif vars[2] =~ /save/i
      if vars[3] != nil
        Dir.mkdir("#{$lich_dir}scripts/bigshot_profiles") unless File.exists?("#{$lich_dir}scripts/bigshot_profiles")
        dir = "#{$lich_dir}scripts/bigshot_profiles"
        filename = "#{dir}/#{vars[3]}.yaml"
        if File.exists?("#{filename}")
          echo "File already exists, if you wish to overwrite, please ;unpause bigshot."
          echo "Else ;kill bigshot and choose another filename."
          pause_script
        end
        File.write(filename, UserVars.op.to_yaml)
        echo "Settings saved to profile: #{filename}."
      else
        echo "You forgot to name your profile you wish to save."
        echo "Syntax: ;bigshot profile save <NAME Here, no Spaces!>"
      end
    end
  end
end

if (script.vars[1].nil? || script.vars[1] =~ /solo|(bounty)|quick|single/i)
  bounty_mode = $1
  if script.vars[1] =~ /quick/i
    $bigshot_quick = true
  end

  if script.vars[1] =~ /single/i
		$bigshot_single = true
	end

  bs = Bigshot.new(bounty_mode)
  bs.croak('Requires Lich V4') unless defined?(Gtk.queue) || defined?($bigshot_headless)
  bs.croak('Requires a mapped room.') if ((Room.current.id.nil? || Room.current.id == 4) && !$bigshot_quick)
  bs.lead()

elsif (script.vars[1] =~ /setup/i)
  Bigshot.setup()

elsif (script.vars[1] =~ /profile/i)
  Bigshot.profile(script.vars)

elsif (script.vars[1] =~ /display/i)
  echo "Version: #{BIGSHOT_VERSION}"
  UserVars.op.each_pair { |k, v|
    echo "#{k}: #{v}" unless v.nil? || v.class.to_s == 'Array' || v =~ /^\s*$/
  }
  echo "Targetable Character Setting: #{CharSettings['targetable'].map { |c| c.downcase }.sort { |a, b| a.split(" ").last <=> b.split(" ").last }}"
  echo "Untargetable Character Setting: #{CharSettings['untargetable'].map { |c| c.downcase }.sort { |a, b| a.split(" ").last <=> b.split(" ").last }}"

elsif (script.vars[1] =~ /reset/i)
  CharSettings['targetable'] = nil
  CharSettings['untargetable'] = nil
  echo "Character Settings for Targetable and Untargetable are now reset"

elsif (script.vars[1] =~ /ranger|companion/i)
  $companion = nil
  echo "Ranger Companion reset"

elsif (script.vars[1] =~ /head|lead/i)
  # launch DRb server
  DRb.start_service(nil, Bigshot::Group.new)
  uri = DRb.uri

  Thread.new { DRb.thread.join }

  # launch DRb client
  DRb.start_service()
  bs = Bigshot.new()

  # set leader
  my_group = DRbObject.new(nil, uri)
  my_group.set_leader(bs)

  # announce/go
  (1..RALLY_TIME).each { |i| fput "whisper ooc group Bigshot rallying at #{uri}"; sleep(1); }
  echo "Waiting for members to join Bigshot rally..."
  wait_until { (my_group.size() > 0) }
  pause 3
  bs.lead(my_group)
elsif (script.vars[1] =~ /tail|follow|link/i)
  # Watch for rally
  group = nil
  bs = nil
  uri = nil
  while (group.nil? && bs.nil?)
    if script.vars[1] =~ /link/i && script.vars[2].nil?
      echo "Must supply target URI when using LINK option"
      exit
    end
    echo "waiting for rally" if $bigshot_debug
    if script.vars[1] =~ /link/i
      uri = script.vars[2]
    end
    if (!uri.nil? || get =~ /rallying at (.*)\."$/)
      uri = uri.nil? ? Regexp.last_match(1) : uri
      fput "whisper ooc group Bigshot rallying at #{uri}" unless script.vars[1] =~ /link/i
      # create group
      DRb.start_service()
      group = DRbObject.new(nil, uri)

      # create Bigshot
      bs = Bigshot.new()
      group.add_member(bs)
      bs.keep_awake()
      bs.CompanionCheck()
      bs.NPCRoomCheck()
    end
  end

  # Participate
  bs.message("Joined group")
  leader = group.leader.name
  $bigshot_overkill_counter = 0

  bs.groupcheck() if !checkpcs.nil?
  echo "Groupcheck done" if $bigshot_debug

  while (!dead?)
    begin
      bs.change_stance('defensive')
      bs.stand() if !standing? && $looting_inactive
      sleep(0.25)

      # grab event
      event = bs.event_stack.size == 0 ? nil : bs.grab_event
      next if event.nil?

      # kertwang!
      if (event.type != :STAY_QUIET)
        until (checkpcs.include?(leader))
          break if Char.name == leader

          start_script('go2', [group.room_id, '_disable_confirm_'])
          wait_while { running?('go2') }
          fput "join #{leader}"
          sleep(1)
        end
      end

      # process event
      bs.message("event: " + event.type.to_s) unless event.type == :FOLLOWER_OVERKILL || event.type == :PREP_REST
      if (event.type == :HUNTING_PREP_COMMANDS)
        bs.HUNTING_PREP_COMMANDS.each { |i|
          if i =~ /^script\s+(.*?)(\s|$)(.*)/i
            bs.cmd_run_script($1, $3)
          else
            fput(i)
          end
        }

      elsif (event.type == :STAY_QUIET)
        next if Char.name == leader

        # If they got left somewhere besides the resting room, put them in a known (and hopefully safe) location
        if (Room.current.id != group.resting_id)
          bs.goto(group.resting_id)
          wait_while { running?('go2') }
        end
        bs.message("Waiting for Bigshot leader to finish running resting scripts")
        loop do
          break if Char.name == leader

          sleep(REST_INTERVAL)
          break if checkpcs.include?(leader) && Room.current.id == group.resting_id
        end
        fput "join #{leader}"

      elsif (event.type == :FOLLOWER_OVERKILL)
        bs.use_lte_boost()

      elsif (event.type == :CAST_SIGNS)
        bs.cast_signs()

      elsif (event.type == :HUNTING_SCRIPTS_START)
        bs.run_scripts(bs.HUNTING_SCRIPTS, false)

      elsif (event.type == :ATTACK)
        if (event.stale?) # consider timestamp and room_id
          bs.message("skipping attack because it's stale")
          next
        end

        stop_attack = false
        target = nil
        while (!stop_attack)
          stop_attack = event.stale?
          while ((target = bs.find_target(target)) && !stop_attack)
            if (bs.event_stack.any? { |a| a.type == :PREP_REST })
              bs.message("Preparing to move, skipping attack")
              stop_attack = true
              break
            end

            target = bs.find_target(nil) if !$bigshot_bandits && @PRIORITY && !bs.priority(target)
            bs.attack(target)

            until (checkpcs.include?(leader))
              break if Char.name == leader

              start_script('go2', [group.room_id, '_disable_confirm_'])
              wait_while { running?('go2') }
              fput "join #{leader}"
              sleep(1)
            end

            stop_attack = bs.should_rest?
          end
          break if stop_attack

          stop_attack = bs.event_stack.any? { |a| a.type == :PREP_REST }
          sleep(0.3)
        end

      elsif (event.type == :PREP_REST)
        bs.prepare_for_movement()

      elsif (event.type == :LOOT)
        bs.loot

      elsif (event.type == :HUNTING_SCRIPTS_STOP)
        bs.croak_scripts(bs.HUNTING_SCRIPTS)

      elsif (event.type == :RESTING_PREP_COMMANDS)
        $bigshot_should_rest = nil # need to reset this
        $bigshot_overkill_counter = 0
        next if Char.name == leader

        bs.RESTING_COMMANDS.each { |i| fput(i) }

      elsif (event.type == :RESTING_SCRIPTS_START)
        next if Char.name == leader

        bs.run_scripts(bs.RESTING_SCRIPTS, true)

      elsif (event.type == :DISPLAY_WATCH)
        next if Char.name == leader

        if (event.stale?)
          bs.message("skipping display_watch because it's stale")
          next
        end
        fput 'exp'
        bs.message("Bigshot last rested because: #{$rest_reason}") if $rest_reason
        bs.message("Bigshot isn't hunting because: #{$not_hunting_reason}") if $not_hunting_reason
        sleep(REST_INTERVAL / 10)

      elsif (event.type == :CUSTOM_PUT)
        bs.group_put(event.cmd_input)

      elsif (event.type == :CUSTOM_CMD)
        bs.group_cmd(event.cmd_input)

      elsif (event.type == :CUSTOM_DO_CLIENT)
        bs.group_do(event.cmd_input)

      elsif (event.type == :PUBLIC_SEND)
        echo "SENT: #{bs.public_send(event.cmd_input) if bs.respond_to? event.cmd_input}"
      end
    rescue
      fput 'leave group'
      if (bs.RESTING_ROOM_ID && bs.RESTING_ROOM_ID != 4)
        start_script('go2', [bs.RESTING_ROOM_ID, '_disable_confirm_'])
        wait_while { running?('go2') }
      end
      echo "Fatal exception!"
      echo $!.to_s
      echo $!.backtrace.join("\n")
      Script.self.kill
    end
  end
end
