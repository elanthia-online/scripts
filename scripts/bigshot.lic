=begin

  bigshot.lic: the new optimus prime

  hunting script for hunting

        author: elanthia-online
  contributors: SpiffyJr, Tillmen, Kalros, Hazado, Tysong, Athias, Falicor, Deysh, Nisugi
          game: Gemstone
          tags: hunting, bigshot, combat
       version: 4.15.6
      required: Lich >= 5.5.0, infomon >= 1.18.11

  Setup Instructions: https://gswiki.play.net/Script_Bigshot
      Full Changelog: https://gswiki.play.net/Script_Bigshot/Changelog
     Help Contribute: https://github.com/elanthia-online/scripts

  Version Control:
    Major_change.feature_addition.bugfix
  v4.15.6 (2023-04-04)
    - Add cman sbash to cmans as was missing
  v4.15.5 (2023-03-15)
    - Rubocop cleanup
    - replace script.vars with Script.current.vars
  v4.15.4 (2023-03-13)
    - add additional missing 709 arms to exclude for NPCs check
  v4.15.3 (2023-03-02)
    - bugfix for cmd_shields
  v4.15.2 (2023-03-01)
    - bugfix to allow cmd_weapons to work if using more than base Mnemonic
    - bugfix to allow cmd_shields to work if using more than base Mnemonic
    - bugfix to allow cmd_cmans to work if using more than base Mnemonic
    - bugfix to allow cmd_bearhug to work if using more than base Mnemonic
    - bugfix to allow cmd_rogue_cmans to work if using more than base Mnemonic
  v4.15.1 (2023-02-18)
    - initial bugfix(s) for Ruby 3.x compliance
    - fix for exiting cmd_force if command check fails on cmd
  v4.15.0 (2023-02-18)
    - add tonis/1035 command
    - bugfix to not try to pull dead people up
  v4.14.8 (2023-02-11)
    - moved bounty check to after looting to avoid excessive game feed
  v4.14.7 (2023-02-09)
    - added missing room claim check
  v4.14.6 (2023-02-06)
    - fix head/tail issues with claim
    - cleaned up also here detection
    - cleaned up cast_signs to not spam song status for bards
  v4.14.5 (2023-02-03)
    - regex fix for hunt monitor claim_room
    - fix in bs_wander method for 'approach lone target only'
  v4.14.4 (2023-02-02)
    - fix second target aquisition to use valid_targets?
    - fix odd issue that would cause you to loot existing corpses in specific scenarios.
  v4.14.3 (2023-02-01)
    - fixed bigshot quick group room claim
    - fixed regex to prevent attacks from removing people from claim
  v4.14.2 (2023-01-31)
    - updates to room claim system ;e UserVars.show_claim = true/false to echo when room is claimed.
  v4.14.1 (2023-01-28)
    - bugfix for GTK display if old settings contained integer for certain fields
    - bugfix to allow cmd_assault to work if using more than Mnemonic (ie fury punch)
    - add new regex result for cmd_cmans for sattack
    - remove spam/unspam as waitrt?/waitcastrt? updated in Lich5 to be faster by default
  v4.14.0 (2023-01-25)
    - add new slayer command for 240
    - fix for wander_wait to use should_flee?
  v4.13.18 (2023-01-24)
    - introduced room claim system to prevent poaching.
  v4.13.17 (2023-01-23)
    - move wander_wait to prevent poaching
  v4.13.16 (2023-01-21)
    - added support to rest for debuffs: Wall of Thorn Poison, Confusion, Creeping Dread, and Crushing Dread
  v4.13.15 (2023-01-12)
    - Add 1650 cooldown check for cast_signs
  v4.13.14 (2023-01-12)
    - bugfix for casting 1650 in cast_signs not working due to 650 regex

=end
=begin
    To do:
      Add more messaging for ambush checks (snipe, etc.)
      Add Stun Relief (108)|Undisease (113)|Unpoison (114) option for stunned group members
      Add Hand of Tonis to dismiss clouds
      Group logic for familiars/companions
      UCS will frequently use the last '$bigshot_unarmed_followup_attack', needs to be cleared
      Need support for tracking multiple NPC positioning tiers for UCS
      Celerity (506) support from grouped wizards for MStrikes
=end

# Compatability for Older Ruby Versions
if $SAFE > 0
  echo "error: This script needs to be trusted to work. (;trust #{script.name})"
  exit
end

infomon_gem_requires = '1.18.11'
lich_gem_requires = '5.5.0'
requirement_failed = false

# Check version in file if constant not defined or if the version is less than required
if !defined?(INFOMON_VERSION) or (Gem::Version.new(INFOMON_VERSION) < Gem::Version.new(infomon_gem_requires))
  INFOMON_VERSION = '0.0.0'
  infomon_data = File.open(File.join(SCRIPT_DIR, "infomon.lic"), 'r').read
  if infomon_data =~ /^=begin\r?\n?(.+?)^=end/m
    comments = $1.split("\n")
  else
    comments = []
    infomon_data.split("\n").each { |line|
      if line =~ /^[\t\s]*#/
        comments.push(line)
      elsif line !~ /^[\t\s]*$/
        break
      end
    }
  end
  for line in comments
    if line =~ /^[\s\t#]*version:[\s\t]*([\w,\s\.\d]+)/i
      INFOMON_VERSION = $1.sub(/\s\(.*?\)/, '').strip
    end
  end
end

# Check version of infomon for compatibility
if Gem::Version.new(INFOMON_VERSION) < Gem::Version.new(infomon_gem_requires)
  requirement_failed = true
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script: #{script.name} now requires a newer version of infomon (#{infomon_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running infomon Version: #{Gem::Version.new(INFOMON_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script: #{script.name} now requires a newer version of infomon (#{infomon_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently running infomon Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond "##" + "########################################"
  end
end

# Check version of Lich for compatibility
if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires)
  requirement_failed = true
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script: #{script.name} now requires a newer version of Lich (#{lich_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script: #{script.name} now requires a newer version of Lich (#{lich_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
    _respond "##" + "########################################"
  end
end

exit if requirement_failed
# end version checks

if UserVars

  # Create UserVars.op on first run
  if UserVars.op.nil?
    UserVars.op = Hash.new
  end

  # First time running a version with monitor strings that can be specified, set up default values
  if UserVars.op["monitor_strings"].nil? || UserVars.op["monitor_strings"].empty?
    UserVars.op["monitor_strings"] = "SEND||POLICY||[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]||speaking to you||unresponsive||taps you||nods to you||lease respond||not in control||violation||lease speak||peak out loud||Y U SHOU D||whispers,||speaking to you||smiles at you||waves to you||grins at you||hugs you||takes hold your hand||grabs your hand||clasps your hand||trying to drag you"
  end

  if UserVars.op["monitor_safe_strings"].nil? || UserVars.op["monitor_safe_strings"].empty?
    UserVars.op["monitor_safe_strings"] = "\[(?!Private)\w*\]-GS(?:T|IV):||We've noted a troubling increase in bandit activity recently||inviting you to join||Dreavening"
  end

  UserVars.save
end

# All Requirements
require 'yaml'
require 'drb'
require 'fileutils'

# Make sure the directories exist for loading and saving profiles
FileUtils.mkdir_p(File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles"))

# Alphabetized Global Variables
BIGSHOT_VERSION = '4.15.6'
RALLY_TIME = 1
REST_INTERVAL = 60
$bigshot_1614_list = []
$bigshot_703_list = []
$bigshot_adrenal_surge = Time.now + 301
$bigshot_aim = 0
$bigshot_ambush = 0
$bigshot_arcane_reflex = false
$bigshot_archery_aim = 0
$bigshot_archery_stuck_location = []
$bigshot_archery_location = nil
$bigshot_dislodge_target = nil
$bigshot_dislodge_location = []
$bigshot_bandits = false
$bigshot_bless = []
$bigshot_bond_return = false
$bigshot_briars = false
$bigshot_debug = false
$bigshot_flee = false
$bigshot_lte_boost_counter = 0
$bigshot_overkill_counter = 0
$bigshot_quick = false
$bigshot_reaction = nil
$bigshot_should_rest = false
$bigshot_smite_list = []
$bigshot_status = nil
$bigshot_swift_justice = 0
$bigshot_unarmed_followup = false
$bigshot_unarmed_followup_attack = ""
$bigshot_unarmed_tier = 1
$bigshot_wand = 0
$companion ||= nil
$current_script_name = script.name
$current_room_npcs = GameObj.npcs
$familiar = ""
$grouplist = []
$last_loot = nil
$looting_inactive = true
$not_hunting_reason = nil
$rest_reason = nil
$room_npcs_last_check = []
$mstrike_taken = false
$bigshot_single = false
$bigshot_room_claimed = []

def spell_is_selfcast?(spell_id)
  [
    106, 109, 115, 117, 120, 130, 140,
    205, 206, 211, 213, 215, 218, 219, 220, 240,
    303, 307, 310, 313, 314, 319, 350,
    401, 402, 403, 404, 405, 406, 414, 418, 419, 425, 430,
    503, 506, 507, 508, 509, 511, 513, 515, 517, 520, 535, 540,
    601, 602, 604, 605, 606, 608, 612, 613, 617, 618, 620, 625, 630, 640, 650,
    707, 712,
    905, 911, 913, 916, 919,
    1003, 1006, 1007, 1009, 1010, 1011, 1012, 1014, 1017, 1018, 1019, 1020, 1025, 1035, 1040,
    1109, 1119, 1125, 1130, 1150,
    1202, 1204, 1208, 1213, 1214, 1215, 1216, 1220, 1235,
    1601, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1616, 1617, 1618, 1619, 1635
  ].include? spell_id
end

class Bigshot
  class Event
    attr_accessor :type, :created_at, :room_id, :cmd_input

    @@RECOGNIZED = [:HUNTING_PREP_COMMANDS, :HUNTING_SCRIPTS_START, :CAST_SIGNS, :ATTACK, :PREP_REST,
                    :HUNTING_SCRIPTS_STOP, :RESTING_SCRIPTS_START, :RESTING_PREP_COMMANDS, :DISPLAY_WATCH,
                    :FOLLOWER_OVERKILL, :STAY_QUIET, :FOLLOW_NOW, :LOOT, :CUSTOM_PUT, :CUSTOM_CMD, :CUSTOM_DO_CLIENT,
                    :PUBLIC_SEND]

    def initialize(type, time_stamp, room_id, c_in = nil)
      raise "Event type not recognized" unless @@RECOGNIZED.include?(type)

      @type       = type
      @created_at = time_stamp
      @room_id    = room_id
      @cmd_input  = c_in
    end

    def stale?
      if (Room.current.id != @room_id || Time.now.to_i - @created_at > 15)
        return true
      else
        return false
      end
    end
  end
end

class Bigshot
  class Group
    include DRbUndumped
    attr_accessor :leader, :members

    def initialize()
      @members = Hash.new
    end

    def set_leader(leader)
      @leader = leader
    end

    def add_member(member)
      @members[member.name()] = member
    end

    def size()
      return @members.size
    end

    def get_names
      return @members.keys + [@leader.name]
    end

    def room_id()
      return @leader.room_id()
    end

    def first_member
      @members[@leader.ma_looter].add_event(:LOOT, Time.now.to_i, Room.current.id)
    end

    def looting_done
      # Fixme: change to named member
      return @members[@leader.ma_looter].looting_inactive?
      # @members.each_pair { |k, v|
      # echo "looting_done: #{$looting_inactive}"
      # return v.looting_inactive?
      # }
    end

    def looter
      return @leader.ma_looter
    end

    def looter_present?
      return true if checkpcs.include?(@leader.ma_looter)

      if !checkpcs.include?(@leader.ma_looter)
        @members.delete(@leader.ma_looter)
        return false
      end
    end

    def obv_hide_set(player_present)
      @members.each_pair { |k, v|
        begin
          v.set_obvious_hiding_player(player_present)
        rescue
          @leader.message("yellow", "Error polling member(obv_hide_set). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def add_event(type)
      @members.each_pair do |_k, v|
        begin
          v.add_event(type, Time.now.to_i, Room.current.id)
        rescue
          @leader.message("yellow", "Error adding #{type} event to members stack(add_event): #{$!}")
          @leader.message("yellow", $!.backtrace.join("\n"))
        end
      end
    end

    def has_bounty?(bounty_regex)
      if !bounty_regex.is_a? Regexp
        @leader.message("yellow", "That's not a Regexp.  Killing Bigshot")
        client_do(";k bigshot")
      end
      @members.each_pair do |k, v|
        begin
          return true if v.cur_bounty =~ bounty_regex
        rescue
          @leader.message("yellow", "Error polling member(has_bounty?). Removing #{k}!")
          @members.delete(k)
        end
      end
      return false
    end

    def group_assist(should_attack)
      @members.each_pair { |k, v|
        begin
          v.set_help_group(should_attack)
        rescue
          @leader.message("yellow", "Error polling member(group_assist). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def add_leader_event(event)
      @leader.add_event(Event.new(event)) unless @leader.event_stack.size > 5
    end

    def resting_id()
      return @leader.RESTING_ROOM_ID
    end

    def roundtime?()
      @members.each_pair { |k, v|
        begin
          return true if v.rt? > 0
        rescue
          @leader.message("yellow", "Error polling member(roundtime?). Removing #{k}!")
          @members.delete(k)
        end
      }
      return false
    end

    # Use this to perform combat actions
    def do_command(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:CUSTOM_CMD, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("yellow", "Error polling member(do_command). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    # Use this to perform non-combat actions
    def do_put(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:CUSTOM_PUT, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("yellow", "Error polling member(do_put). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    # Use this to perform perform actions as if they were typed through the client
    def client_do(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:CUSTOM_DO_CLIENT, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("yellow", "Error polling member(client_do). Removing! #{k}")
          @members.delete(k)
        end
      }
    end

    # Use this to perform perform actions as if they were typed through the client
    def pub_send(command_input)
      @members.each_pair { |k, v|
        begin
          v.add_event(:PUBLIC_SEND, Time.now.to_i, Room.current.id, command_input)
        rescue
          @leader.message("yellow", "Error polling member. Removing!")
          @members.delete(k)
        end
      }
    end

    def clear_group_events()
      @members.each_pair { |k, v|
        begin
          v.clear_events()
        rescue
          @leader.message("yellow", "Error polling member(clear_group_events). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def should_hunt?()
      emergency = @leader.event_stack.size == 0 ? nil : @leader.event_stack.shift
      if (emergency)
        @leader.clear_events()
        return false
      end

      @members.each_pair { |k, v|
        begin
          return false if !v.should_hunt?
        rescue
          @leader.message("yellow", "Error polling member(should_hunt?). Removing #{k}!")
          @members.delete(k)
        end
      }
      $bigshot_status = :hunting
      return true
    end

    def group_bandit_hunting(kill_bandits)
      @members.each_pair { |k, v|
        begin
          v.set_bandit_hunting(kill_bandits)
        rescue
          @leader.message("yellow", "Error polling member(group_bandit_hunting). Removing #{k}!")
          @members.delete(k)
        end
      }
    end

    def should_rest?()
      @members.each_pair { |k, v|
        begin
          return false if !v.should_rest?
        rescue
          @leader.message("yellow", "Error polling member(should_rest?). Removing #{k}!")
          @members.delete(k)
        end
      }
      return true
    end

    def any_saturated?
      @members.each_pair do |k, v|
        begin
          return true if v.saturated?
        rescue StandardError
          @leader.message("yellow", "Error polling member(any_saturated?). Removing #{k}!")
          @members.delete(k)
        end
      end
      false
    end

    def all_present?
      @members.each_pair { |k, _v|
        begin
          return false if !checkpcs.include?(k) && k != @leader.name
        rescue
          @leader.message("yellow", "Error polling member(all_present?). Removing #{k}!")
          @members.delete(k)
        end
      }
      return true
    end

    def emergency_rest?()
      @members.each_pair { |k, v|
        begin
          return true if v.wounded?
        rescue
          @leader.message("yellow", "Error polling member(emergency_rest). Removing #{k}!")
          @members.delete(k)
        end
      }
      return false
    end
  end
end

class Bigshot
  include DRbUndumped
  attr_accessor :BIRTH_TIME, :START_TIME, :STORED_TIMES, :FRIED, :OOM,
                :SIGNS, :TARGETS, :INVALID_TARGETS, :FLEE_COUNT, :ALWAYS_FLEE_FROM,
                :USE_WRACKING, :AMMO, :AMMO_CONTAINER, :HIDE_FOR_AMMO, :BOON_FLEE_FROM,
                :REST_TILL_EXP, :REST_TILL_MANA, :USE_HERBS, :DEAD_MAN_SWITCH,
                :RESTING_ROOM_ID, :RESTING_COMMANDS, :RESTING_SCRIPTS, :HUNTING_ROOM_ID,
                :RALLYPOINT_ROOM_ID, :HUNTING_BOUNDARIES, :HUNTING_SCRIPTS, :HUNTING_COMMANDS,
                :DISABLE_COMMANDS, :HUNTING_STANCE, :HUNTING_PREP_COMMANDS,
                :MONITOR_INTERACTION, :FLEE_CLOUDS, :FLEE_VINES, :FLEE_WEBS, :FLEE_VOIDS, :WRACKING_SPIRIT,
                :REST_TILL_SPIRIT, :BOUNTY_MODE, :AMBUSH, :ARCHERY_AIM,
                :event_stack, :followers, :BLESS, :AIM, :TIER3, :QUIET_FOLLOWERS,
                :MSTRIKE_COOLDOWN, :MSTRIKE_STAMINA_COOLDOWN, :MSTRIKE_MOB,
                :MSTRIKE_QUICKSTRIKE, :MSTRIKE_STAMINA_QUICKSTRIKE, :UAC_MSTRIKE,
                :WANDER_WAIT, :QUICK_COMMANDS, :PRIORITY, :TROUBADOURS_RALLY,
                :QUICKHUNT_TARGETS, :UAC_SMITE, :FOG_RETURN, :FOG_OPTIONAL, :LOOT_STANCE,
                :DELAY_LOOT, :PULL, :OVERKILL, :LTE_BOOST, :HELP_GROUP_KILL, :WEAPON_REACTION, :DEADER, :CORRECT_PERCENT_MIND, :MA_LOOTER

  PRONE = /sleeping|webbed|stunned|kneeling|sitting|^lying|prone|frozen|held in place/
  # Changed to gameobj-data.xml detection 4.12.2 update
  # No longer needed
  # BOON_LIST_ADJECTIVES = /^(?:adroit |afflicted |apt |barbed |belligerent |blurry |canny |combative |dazzling |deft |diseased |drab |dreary |ethereal |flashy |flexile |flickering |flinty |frenzied |ghastly |ghostly |gleaming |glittering |glorious |glowing |grotesque |hardy |illustrious |indistinct |keen |lanky |luminous |lustrous |muculent |nebulous |oozing |pestilent |radiant |raging |ready |resolute |robust |rune-covered |shadowy |shielded |shifting |shimmering |shining |sickly green |sinuous |slimy |sparkling |spindly |spiny |stalwart |steadfast |stout |tattooed |tenebrous |tough |twinkling |unflinching |unyielding |wavering |wispy )/

  def hunt_monitor(cur_action)
    bigshot_monitor = proc { |server_string|
      if !$bigshot_bandits && server_string =~ /<a exist="\d+" noun="([a-zA-Z]*?)">[a-zA-Z]*?<\/a> leaps from hiding to attack!/i
        temp = $1
        if !$grouplist.any? { |s| s =~ /#{temp}/i }
          $ambusher_here = true
        end
      elsif !$bigshot_bandits && server_string =~ /flies out of the shadows toward|A shadowy figure leaps from hiding to attack/i
        if $grouplist.size == 0
          $ambusher_here = true
        end
      # Remove people from room claim if they walk out of the room.
      elsif server_string =~ /^You notice <a exist="-\d+" noun="(\w+)">[^<]+<\/a> moving stealthily \w+\.$/
        check_room_claimed($1)
      elsif server_string =~ /<a exist="-\d+" noun="(\w+)">[^<]+<\/a>[^<]+<d cmd='[^']+'>[^<]+<\/d>/i
        check_room_claimed($1)
      elsif server_string =~ /^You could use this opportunity to <d cmd='WEAPON (\w+\s#\d+)'>.*<\/d>!/i
        $bigshot_reaction = $1
      elsif server_string =~ /^Vital energy infuses you, hastening your arcane reflexes!/i
        $bigshot_arcane_reflex = true
      elsif server_string =~ /^Nature's blessing of vitality departs as your arcane prowess returns to normal./i
        $bigshot_arcane_reflex = false
      elsif server_string =~ /obvious signs of someone hiding/i
        $obvious_hiding_player = true
      elsif server_string =~ /crimson mist.*?surround.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:corporeal plane!|vulnerable!)/i
        $bigshot_smite_list.push($1)
      elsif server_string =~ /crimson mist.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:returns to an ethereal state.|appears less vulnerable.)/i
        $bigshot_smite_list.delete($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?is suddenly surrounded by a blood red haze./i
        $bigshot_703_list.push($1)
      elsif server_string =~ /The blood red haze dissipates from around.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?\./i
        $bigshot_703_list.delete($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:visibly struggling against|in awe of) your radiant aura!/i
        $bigshot_1614_list.push($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?recovers from being rebuked/i
        $bigshot_1614_list.delete($1)
      elsif server_string =~ /The.*sticks in <pushBold\/>an? <a exist="(\d+)" noun="[^"]+">[^<]+<\/a><popBold\/>'s (?:left |right )?(.*)!/i
        $bigshot_archery_stuck_location.push($2)
        $bigshot_dislodge_location.push($2)
        $bigshot_dislodge_target = $1
      elsif server_string =~ /You're now aiming at the (.*) of/i
        $bigshot_archery_location = $1
      elsif server_string =~ /You're now no longer aiming at anything in particular/i
        $bigshot_archery_location = nil
      elsif server_string =~ /The <a exist="(.*?)" noun="(.*?)">.*?<\/a> strikes? true.* shrugs off some of the damage!/i
        my_id = $1.dup
        my_noun = $2.dup
        my_item = GameObj.inv.find { |i| i.id == "#{my_id}" }
        if @AMMO == "#{my_noun}" || my_item || (checkright || checkleft) == "#{my_noun}"
          $bigshot_bless.push(my_id) if !$bigshot_bless.include?(my_id)
        end
      elsif server_string =~ /Your <a exist="(.*?)" noun=".*?">.*?<\/a> returns? to normal\./i
        $bigshot_bless.push($1)
      elsif server_string =~ /^You bolt/i
        $ambusher_here = false
        $bigshot_smite_list = []
        $bigshot_aim = 0
        $bigshot_ambush = 0
        $bigshot_archery_aim = 0
        $bigshot_archery_stuck_location = []
        $bigshot_unarmed_tier = 1
        $bigshot_unarmed_followup = false
        $bigshot_unarmed_followup_attack = ""
        $bigshot_703_list = []
        $bigshot_1614_list = []
        $bigshot_flee = false
        $obvious_hiding_player = false
        $bigshot_reaction = nil
      elsif server_string =~ /#{UserVars.op["flee_message"]}/i && UserVars.op["flee_message"] != ""
        $bigshot_flee = true
      elsif server_string =~ /The vines lose all crimson hues, and strength courses through your blood\.$/i
        $bigshot_briars = true
      elsif server_string =~ /^You no longer look stronger\./i
        $bigshot_briars = false
      elsif server_string =~ /^A[n]? (.*) rises out of the shadows and flies back to your waiting hand!/i
        $bigshot_bond_return = true
      elsif server_string =~ /Your Swift Justice charges are increased to (\d+)\./i
        $bigshot_swift_justice = $1.to_i
      elsif server_string =~ /Your Swift Justice surges through you! Its charges are reduced to (\d+)\./i
        $bigshot_swift_justice = $1.to_i
      end
      server_string
    }

    DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    before_dying { DownstreamHook.remove("#{$current_script_name}_monitor") }

    if cur_action == "start"
      echo "starting bigshot_monitor" if $bigshot_debug
      DownstreamHook.add("#{$current_script_name}_monitor", bigshot_monitor)
    elsif cur_action == "stop"
      echo "removing bigshot_monitor" if $bigshot_debug
      DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    else
      echo "removing bigshot_monitor" if $bigshot_debug
      DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    end
  end

  def add_event(type, time_stamp, room_id, c_in = nil)
    echo "add_event" if $bigshot_debug
    unless (@event_stack.size > 5 && type == :ATTACK)
      if (type == :FOLLOWER_OVERKILL)
        add_overkill()
        @event_stack.push(Event.new(type, time_stamp, room_id, c_in)) unless (@event_stack.any? { |a| a.type == type })
      else
        @event_stack.push(Event.new(type, time_stamp, room_id, c_in))
      end
    end
  end

  def grab_event()
    echo "grab_event" if $bigshot_debug
    @event_stack.shift()
  end

  def clear_events()
    echo "clear_events" if $bigshot_debug
    @event_stack.clear
  end

  def initialize(bounty_mode = nil)
    echo "initialize" if $bigshot_debug
    $bigshot = self
    @HELP_GROUP_KILL = true
    if bounty_mode
      @BOUNTY_MODE = true
    end

    UserVars.op ||= Hash.new
    CharSettings['targetable']   ||= Array.new
    CharSettings['untargetable'] ||= Array.new
    CharSettings['untargetable'] = CharSettings['untargetable'].uniq
    @BIRTH_TIME   = Time.now.to_i
    @START_TIME   = 1
    @STORED_TIMES = Array.new

    @followers = nil
    @event_stack = Array.new

    load_settings()
    convert_from_uid
    instance_variable_set("@CORRECT_PERCENT_MIND", check_mind)

    dead_man_switch()

    # this is mainly for azbounty:
    before_dying {
      @HUNTING_SCRIPTS.each { |hs|
        # check for scripts with args passed
        hs_name = hs.split(/\s+/).first
        echo "Cleaning up hunting scripts: #{hs_name}."
        stop_script(hs_name) if running?(hs_name)
      }
    }
  end

  def load_settings()
    check_required_values

    # Resting Tab - Where to Rest
    set_value('resting_room_id',              '', 4) # resting room ID
    set_value('resting_commands',             'split_xx',  Array.new)     # pre-rest commands
    set_value('resting_scripts',              'split',     Array.new)     # active resting scripts
    set_value('fog_return',                   '',          nil)           # fog options
    set_value('fog_optional',                 '',          false)         # fog only if wounded or encumbered

    # Resting Tab - Should Rest?
    set_value('fried',                        'to_i', nil) # when percentmind >=
    set_value('overkill',                     'to_i',      0)             # and extra kills >=
    set_value('lte_boost',                    'to_i',      0)             # and use lte boosts >=
    set_value('oom',                          'to_i', nil) # or percentmana <=
    set_value('encumbered',                   'to_i',      200)           # or percent encumbrance
    set_value('wounded_eval',                 '',          nil)           # or wounded eval
    set_value('creeping_dread',               'to_i',      0)             # when creeping dread >=
    set_value('crushing_dread',               'to_i',      0)             # when crushing dread >=
    set_value('wot_poison',                   '',          false)         # wall of thorns poison
    set_value('confusion',                    '',          false)         # confusion debuff

    # Hunting Tab - Hunting Map
    set_value('hunting_room_id',              '', 4) # starting room id
    set_value('rallypoint_room_id',           '', -5) # rallypoint room id
    set_value('hunting_boundaries',           'split', Array.new) # boundary room ids_from_uid

    # Hunting Tab - Should Hunt?
    set_value('rest_till_exp',                'to_i',       nil)          # when percentmind <=
    set_value('rest_till_mana',               'to_i',       nil)          # and percentmana >=
    set_value('rest_till_spirit',             'to_i',      0)             # and checkspirit >=

    # Hunting Tab - Right Side
    set_value('hunting_stance',               '',          'defensive')   # attack stance
    set_value('hunting_prep_commands',        'split_xx',  Array.new)     # pre-hunt commands
    set_value('hunting_scripts',              'split',     Array.new)     # active hunting scripts
    set_value('signs',                        'split',     Array.new)     # society abilities/spells/cman
    set_value('loot_script',                  '',          nil)           # loot script
    set_value('wracking_spirit',              'to_i',      0)             # wracking spirit >=

    # Hunting Tab - Right Side Toggles
    set_value('priority',                     '',          false)         # priority hunt
    set_value('delay_loot',                   '',          false)         # delay looting
    set_value('troubadours_rally', '', false) # troubadours rally
    set_value('use_wracking',                 '',          false)         # use sign of wracking/sigil of power/symbol of mana
    set_value('loot_stance',                  '',          false)         # defensive stance before looting
    set_value('pull',                         '',          true)          # pull players to feet
    set_value('deader',                       '',          true)          # stop for dead players

    # Attacking Tab
    set_value('ambush',                       'split',     Array.new)     # ambush aiming locations
    set_value('archery_aim',                  'split',     Array.new)     # archery aiming locations
    set_value('flee_count',                   'to_i',      10)            # flee if enemy count is >
    set_value('invalid_targets',              'split',     Array.new)     # but don't count these
    set_value('always_flee_from',             'split',     Array.new)     # and always flee from
    set_value('flee_message',                 '',          nil)           # flee from environmental message
    set_value('wander_wait',                  'to_f',      0.3)           # wait before wandering to another room

    # Attack Tab - Toggles
    set_value('boon_flee_from',               '',          false)         # flee from boon/boss/glamour creatures
    set_value('flee_clouds',                  '',          false)         # flee from clouds
    set_value('flee_vines',                   '',          false)         # flee from vines
    set_value('flee_webs',                    '',          false)         # flee from webs
    set_value('flee_voids',                   '',          false)         # flee from voids
    set_value('bless',                        '',          nil)           # bless weapon
    set_value('lone_targets_only',            '',          false)         # approach loan targets only
    set_value('weapon_reaction',              '',          true)          # activate weapon reactions

    # Commands Tab - Left
    set_value('hunting_commands',             'split_xx', nil) # hunting commands(a)
    set_value('hunting_commands_b',           'split_xx',  Array.new)     # hunting commands(b)
    set_value('hunting_commands_c',           'split_xx',  Array.new)     # hunting commands(c)
    set_value('hunting_commands_d',           'split_xx',  Array.new)     # hunting commands(d)
    set_value('hunting_commands_e',           'split_xx',  Array.new)     # hunting commands(e)
    set_value('hunting_commands_f',           'split_xx',  Array.new)     # hunting commands(f)
    set_value('hunting_commands_g',           'split_xx',  Array.new)     # hunting commands(g)
    set_value('hunting_commands_h',           'split_xx',  Array.new)     # hunting commands(h)
    set_value('hunting_commands_i',           'split_xx',  Array.new)     # hunting commands(i)
    set_value('hunting_commands_j',           'split_xx',  Array.new)     # hunting commands(j)

    # Commands Tab - Right
    set_value('targets',                      'targets',   nil) # valid targets
    set_value('quickhunt_targets',            'qtargets', nil) # quickhunt targets
    set_value('quick_commands',               'split_xx',  Array.new)     # quick commands
    set_value('disable_commands',             'split_xx',  Array.new)     # fried commands

    # Misc Tab - UAC
    set_value('tier3',                        '',          'punch')       # tier 3 attack
    set_value('aim',                          'split',     Array.new)     # aim at location
    set_value('uac_smite',                    '',          false)         # use voln smite
    set_value('uac_mstrike', '', false) # do not mstrike

    # Misc Tab - Mstrike
    set_value('mstrike_stamina_cooldown',     'to_i',      maxstamina)    # mstrike during cooldown stamina requirement
    set_value('mstrike_stamina_quickstrike',  'to_i',      maxstamina)    # quickstrike stamina requirement
    set_value('mstrike_mob',                  'to_i',      2)             # unfocused mstrike when creature >=
    set_value('mstrike_cooldown',             '',          nil)           # mstrike during cooldown
    set_value('mstrike_quickstrike',          '',          nil)           # use quickstrike for mstrike

    # Misc Tab - Ammo/Wands
    set_value('ammo_container',               '',          nil)           # find ammo in this container
    set_value('ammo',                         '',          nil)           # use this ammo type
    set_value('fresh_wand_container',         '',          nil)           # fresh wand container
    set_value('dead_wand_container',          '',          nil)           # dead wand container
    set_value('wand',                         'split',     nil)           # use this wand type
    set_value('hide_for_ammo',                '',          nil)           # hide to pick up ammo
    set_value('wand_if_oom',                  '',          false)         # use wands when oom

    # Misc Tab - MA Grouping
    set_value('ma_looter',                    '',          nil) # character name of looter

    # Monitoring Tab
    set_value('dead_man_switch',              '',          false)         # engage deadmans switch
    set_value('depart_switch',                '',          false)         # depart/rerun if dead
    set_value('quiet_followers',              '',          true)          # quiet followers
    set_value('monitor_interaction',          '',          false)         # monitor interactions
    set_value('monitor_strings',              'split',     Array.new)     # watch for strings(or regex) that contain
    set_value('monitor_safe_strings',         'split',     Array.new)     # except if they also contain

    # Internal
    set_value('bounty_eval',                  '',          nil) # used to set bounty rest parameters
  end

  def clean_value(clean, value)
    if (clean == 'to_i')
      return value.to_i
    elsif (clean == 'to_f')
      return value.to_f
    elsif (clean == 'split')
      return value.split(/,\s*/)
    elsif (clean == 'split_xx')
      cleaned = Array.new
      value.split(/,\s*/).each { |i|
        rep = 1
        cmd = ''
        if (i =~ /(.*)\(x(\d+)\)$/i)
          rep = $2.to_i
          cmd = $1
        elsif (i =~ /(.*)\(xx\)/i)
          rep = 5
          cmd = $1
        else
          cmd = i
        end
        and_tokens = cmd.split(/\sand\s/)
        cmd = and_tokens.size == 1 ? and_tokens[0] : and_tokens
        rep.times do cleaned.push(cmd) end
      }
      return cleaned
    elsif (clean =~ /targets|qtargets/)
      targets = Hash.new
      tokens = value.split(/,/)
      tokens.each do |i|
        if (i =~ /(.*)\(([a|b|c|d|e|f|g|h|i|j|A|B|C|D|E|F|G|H|I|J])\)/)
          targets[$1.downcase.strip] = $2.downcase.strip
        else
          default = clean == "targets" ? 'a' : 'quick'
          targets[i.downcase.strip] = default
        end
      end
      return targets
    else
      return value
    end
  end

  def set_value(key, clean, default)
    if (!UserVars.op[key].nil? && UserVars.op[key].to_s !~ /^\s*$/)
      cleaned = clean_value(clean, UserVars.op[key])
      instance_variable_set("@#{key.upcase}", cleaned)
    else
      instance_variable_set("@#{key.upcase}", default)
    end
  end

  def convert_from_uid
    # provide support for uid's

    return if $bigshot_quick

    # Hunting Room
    @HUNTING_ROOM_ID = uid_match(@HUNTING_ROOM_ID.to_s)

    # Resting Room
    @RESTING_ROOM_ID = uid_match(@RESTING_ROOM_ID.to_s)

    # Rally Point
    @RALLYPOINT_ROOM_ID = uid_match(@RALLYPOINT_ROOM_ID.to_s)

    # Boundary Rooms
    @HUNTING_BOUNDARIES.map! { |place|
      uid_match(place.to_s).to_s
    }
  end

  def uid_match(room)
    uid_pattern = /u(?<uid>\d+)/
    if (m = uid_pattern.match(room))
      uid = m[:uid].to_i
      lookup_id = Map.ids_from_uid(uid)
      if lookup_id.size > 0
        room = lookup_id[0]
      else
        echo "Not able to find #{room} in the map database! Exiting..."
        exit
      end
    end
    return room.to_i
  end

  def color(color, msg)
    if defined?(Lich::Messaging)
      Lich::Messaging.msg_format(color, msg)
    else
      msg
    end
  end

  def check_required_values
    if !$bigshot_quick
      unless (UserVars.op["fried"].to_s.empty? || UserVars.op["oom"].to_s.empty? || UserVars.op["rest_till_mana"].to_s.empty? || UserVars.op["resting_room_id"].to_s.empty? ||
             UserVars.op["rest_till_exp"].to_s.empty? || UserVars.op["hunting_commands"].to_s.empty? || UserVars.op["hunting_room_id"].to_s.empty? || UserVars.op["rest_till_spirit"].to_s.empty? ||
             UserVars.op["targets"].to_s.empty?)
        return
      end

    elsif $bigshot_quick
      unless (UserVars.op["quick_commands"].to_s.empty?)
        return
      end
    end

    output = []
    output << "<output class='mono'/>"
    output << ""
    output << "   #{color("yellow", "There are required setting missing for Bigshot to function...")}"
    output << ""

    if UserVars.op["resting_room_id"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "Resting room id :  This is on the Resting tab")}"
      output << ""
    end

    if UserVars.op["fried"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "when percentmind >=  :  This is on the Resting tab")}"
      output << ""
    end

    if UserVars.op["oom"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "or percentmana <=  :  This is on the Resting tab")}"
      output << ""
    end

    if UserVars.op["hunting_room_id"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "starting room id  :  This is on the Hunting tab")}"
      output << ""
    end

    if UserVars.op["rest_till_exp"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "when percent mind <=  :  This is on the Hunting tab")}"
      output << ""
    end

    if UserVars.op["rest_till_mana"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "and percent mana >=  :  This is on the Hunting tab")}"
      output << ""
    end

    if UserVars.op["rest_till_spirit"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "and checkspirit >=  :  This is on the Hunting tab")}"
      output << ""
    end

    if UserVars.op["hunting_commands"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "Hunting Commands (a)  :  This is on the Commands tab")}"
      output << ""
    end

    if UserVars.op["hunting_commands"].to_s.empty? && !$bigshot_quick
      output << "   #{color("yellow", "valid targets  :  This is on the Commands tab")}"
      output << ""
    end

    if UserVars.op["quick_commands"].to_s.empty? && $bigshot_quick
      output << "   #{color("yellow", "Quick Hunting Commands  :  This is on the Commands tab")}"
      output << ""
    end

    output << "<output class=''/>"
    output << ""

    results = []
    output.each { |line|
      new_line = line

      if $frontend =~ /^(?:wizard)$/
        sf_to_wiz(line)
        items = /<output class='mono'\/>|<output class=''\/>/
        new_line = new_line.gsub(items, "")
        new_line = new_line.gsub(/&lt;/, "<")
        new_line = new_line.gsub(/&gt;/, ">")
      else
        line.scan(/\<[^\]\<]*[^\/]>/).each { |item|
          next if item.include?("preset") ||
                  (new_line = new_line.gsub(item, item.encode(:xml => :text)))
        }
      end

      results.push(new_line)
    }

    _respond results

    Script.self.kill
  end

  def cmd(command, npc = nil, stance_dance = true)
    echo "cmd #{command}" if $bigshot_debug
    GameObj.pcs.each { |s| if s.status =~ /sitting|^lying|prone/ && s.status !~ /dead/; fput "pull #{s.noun}"; end; } if GameObj.targets.any? { |s| s.type =~ /aggressive npc/ } && @PULL

    if GameObj.pcs.any? { |s| s.status =~ /dead/ } && @DEADER
      puts "#{monsterbold_start} Found a deader! #{monsterbold_end}"
      echo "PAUSING SCRIPT"
      echo ";u bigshot"
      echo "TO CONTINUE"
      pause_script
    end

    command = command.dup

    # Used to escape from Roa'ter swallowing
    if !checkroom("The Belly of the Beast").nil?
      RoaterEscape()
    end

    if (command.class.to_s == 'Array')
      stance_dance = false if command.any? { |j| j =~ /stance/ }
      command.each do |i|
        break if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }

        echo i if $bigshot_debug
        cmd(i, npc, stance_dance)
      end
      return
    end

    $bigshot_dislodge_location = [] if npc.status =~ /dead|gone/

    # waitrt/waitcastrt
    unless (command =~ /^nudgeweapons?/)
      waitrt?
      waitcastrt? unless command =~ /hide|cock/
    end

    # Check if the command meets all the right conditions
    return false if command_check(command, npc)

    # Not sure why this isn't with the rest below?
    if (command =~ /force\s+(.*)\s+(?:till|until)\s+(\d+)/i)
      cmd_force($1, $2.to_i, npc)
      return
    end

    # sub id
    command.gsub!(/target/, "##{npc.id}") if !npc.nil?

    # Soothe routine - Minor Mental Spell circle
    if Spell[1201].known? && Spell[1201].affordable?
      if (Spell[201].active? || Spell[216].active? || Spell[1015].active? || Spell[1016].active? || Spell[1108].active? || Spell[1120].active?)
        waitrt?
        waitcastrt?
        Spell[1201].cast
      end
    end

    cmd_bless() if @BLESS && $bigshot_bless.count > 0

    # Celerity (506) routine
    if (command =~ /^(celerity|haste|506)\s+(.*)/i)
      command = $2
      if Spell[506].known? and Spell[506].affordable?
        if (Spell[506].active? and Spell[506].timeleft <= 0.05) || (!Spell[506].active?)
          Spell[506].cast
        end
      end
    end

    # Spirit Slayer (240) routine
    if (command =~ /^(slayer|240)\s+(.*)/i)
      command = $2
      if Spell[240].known? && Spell[240].affordable? && !Effects::Cooldowns.active?(Spell[240].name)
        if (Spell[240].active? && Spell[240].timeleft <= 0.05) || (!Spell[240].active?)
          Spell[240].cast
        end
      end
    end

    if (command =~ /^(tonis|1035)\s+(.*)/i)
      command = $2
      if Spell[1035].known? && Spell[1035].affordable?
        if (Spell[1035].active? && Spell[1035].timeleft <= 0.05) || (!Spell[1035].active?)
          Spell[1035].cast
        end
      end
    end

    # Condition check passed, drop the conditions from the command and lets do something
    command = command =~ /(.*)\((.*?)\)$/ ? $1.strip : command.strip

    # Change_stance
    stand(command) if !standing?
    unless (command =~ /^(?:\d+|wait|sleep|wand|berserk|script|hide|nudgeweapon)/)
      change_stance(@HUNTING_STANCE) if stance_dance
    end

    # Target gone or not priority? Then return
    return if (npc && !valid_target?(npc)) or npc.status =~ /dead|gone/
    return if @PRIORITY && !priority(npc)

    # Perform the command
    if (command =~ /^(incant)?\s?(\d+)\s?((?:open|closed)?\s?(?:cast|channel|evoke)?\s?(?:cast|channel|evoke)?\s?(?:open|closed)?\s?(?:air|earth|fire|lightning|water|cold)?)?.*$/i)
      cmd_spell($1, $2.to_i, $3, npc)
    elsif (command =~ /^barrage|^flurry|^fury|^gthrusts|^pummel|^thrash/i)
      cmd_assault(npc, command)
    elsif (command =~ /^pindown|^cripple|^charge|^twinhammer|^dizzyingswing|^clash|^volley|^pulverize|^cyclone|^whirlwind|^wblade/i)
      cmd_weapons(npc, command)
    elsif (command =~ /^shield throw|^shield bash|^shield charge|^shield strike|^shield pin|^shield trample|^shield push/i)
      cmd_shields(npc, command)
    elsif (command =~ /^bullrush|^coupdegrace|^cpress|^dirtkick|^exsanguinate|^feint|^gkick|^hamstring|^haymaker|^headbutt|^leapattack|^mblow|^sattack|^sbash|^sblow|^scleave|^sthieve|^sunder|^tackle|^trip|^truestrike|^vaultkick/i)
      cmd_cmans(npc, command)
    elsif (command =~ /^bearhug/i)
      cmd_bearhug(npc, command)
    elsif (command =~ /^cutthroat|^divert|^shroud|^eviscerate|^eyepoke|^footstomp|^garrote|^kneebash|^mug|^nosetweak|^spunch|^subdue|^sweep|^swiftkick|^templeshot|^throatchop/i)
      cmd_rogue_cmans(npc, command)
    elsif (command =~ /^shout|^yowlp|^holler|^bellow|^growl|^cry/i)
      cmd_warrior_shouts(npc, command)
    elsif (command =~ /^throw/i)
      cmd_throw(npc)
    elsif (command =~ /^k?weed/i)
      cmd_weed(command, npc)
    elsif (command =~ /^wand/i)
      cmd_wand(npc)
    elsif (command =~ /^hide\s?(\d+)?/i)
      cmd_hide($1.to_i)
    elsif (command =~ /^mstrike/i)
      cmd_mstrike(command, npc)
    elsif (command =~ /^fire/i)
      cmd_ranged(npc)
    elsif (command =~ /dislodge\s?(.*)/i)
      cmd_dislodge(npc, $1)
    elsif (command =~ /^surge/i)
      cmd_surge()
    elsif (command =~ /^berserk/i)
      cmd_berserk()
    elsif (command =~ /^script\s+(.*?)(\s|$)(.*)/i)
      cmd_run_script($1, $3)
    elsif (command =~ /^sleep\s+(\d+)/i)
      cmd_sleep($1, npc)
    elsif (command =~ /^stance\s+(.*)/i)
      change_stance($1)
    elsif (command =~ /^wait\s+(\d+)/i)
      wait_for_swing($1.to_i, npc)
      $stop_wait = true
    elsif (command =~ /^nudgeweapons?\s*/i)
      cmd_nudge_weapons
    elsif (command =~ /^ambush\s?(.*)?/i)
      cmd_ambush($1, npc)
    elsif (command =~ /^unarmed\s+([a-z]*).?([a-z]*)?$/i)
      unarmed($1, npc, $2)
    elsif (command =~ /^smite/i)
      volnsmite(npc)
    elsif (command =~ /^stomp/i)
      cmd_stomp()
    elsif (command =~ /^leech/i)
      cmd_leech()
    elsif (command =~ /^dhurl/i)
      cmd_dhurl()
    elsif (command =~ /briar\s?(\w+)/i)
      cmd_briar($1)
    elsif (command =~ /^assume\s?(\w+)?\s?(\w+)?/i)
      cmd_assume($1, $2)
    else
      return if $ambusher_here
      return if $obvious_hiding_player

      echo "inside cmd: #{command}" if $bigshot_debug

      bs_put command
    end
  end

  def command_check(command, npc)
    echo "command_check #{command}" if $bigshot_debug
    # should_return = false
    # check mana/stamina/health(percentage)/encumbrance/unarmed tiering/mobs in room/target not prone/target undead
    # ! means the inverse/opposite effect
    if (command =~ /(.*)\((.*?(?:s|!s|m|!m|h|!h|e|!e|v|!v|k|!k|tier|!tier|mob|!mob|prone|!prone|frozen|!frozen|undead|!undead|flying|!flying|hidden|!hidden|poison|!poison|disease|!disease|noncorporeal|!noncorporeal|pcs|!pcs|outside|!outside|barrage|!barrage|fury|!fury|flurry|!flurry|pummel|!pummel|thrash|!thrash|reflex|!reflex|vigor|!vigor|shout|!shout|yowlp|!yowlp|buff|censer|justice|!justice|tailwind|!tailwind).*?)\)$/i)
      command = $1.strip

      $2.split(" ").each { |s|
        if s =~ /((?:s|!s|m|!m|h|!h|e|!e|v|!v|tier|!tier|mob|!mob))(\d+)/i
          amount = $2.to_i
          split_item = $1.strip

          split_check = {
            's'     => !checkstamina(amount),
            '!s'    => checkstamina(amount),
            'm'     => !checkmana(amount),
            '!m'    => checkmana(amount),
            'v'     => !checkspirit(amount),
            '!v'    => checkspirit(amount),
            'h'     => !percenthealth(amount),
            '!h'    => percenthealth(amount),
            'e'     => !checkencumbrance(amount),
            '!e'    => checkencumbrance(amount),
            'k'     => !checkkneeling,
            '!k'    => checkkneeling,
            'tier'  => $bigshot_unarmed_tier < amount,
            '!tier' => $bigshot_unarmed_tier > amount,
            'mob'   => GameObjNpcCheck() < amount,
            '!mob'  => GameObjNpcCheck() > amount,
          }

          echo "command_check section 1 #{s} #{split_check[split_item]}" if $bigshot_debug
          return split_check[split_item] if split_check[split_item]
        end

        if s =~ /((?:buff))(\d+)/i
          amount = $2.to_i
          buff_check = {
            'barrage' => !(Effects::Buffs.time_left("Enh. Dexterity (+10)") <= (amount / 60.to_f)),
            'bearhug' => !(Effects::Buffs.time_left("Enh. Strength (+10)") <= (amount / 60.to_f)),
            'fury'    => !(Effects::Buffs.time_left("Enh. Constitution (+10)") <= (amount / 60.to_f)),
            'flurry'  => !(Effects::Buffs.time_left("Slashing Strikes") <= (amount / 60.to_f)),
            'pummel'  => !(Effects::Buffs.time_left("Concussive Blows") <= (amount / 60.to_f)),
            'thrash'  => !(Effects::Buffs.time_left("Forceful Blows") <= (amount / 60.to_f)),
            'yowlp'   => !(Effects::Buffs.time_left("Yertie's Yowlp") <= (amount / 60.to_f)),
            'shout'   => !(Effects::Buffs.time_left("Empowered (+20)") <= (amount / 60.to_f)),
            'kweed'   => !(Effects::Buffs.time_left("Tangleweed Vigor") <= (amount / 60.to_f)),
            'weed'    => !(Effects::Buffs.time_left("Tangleweed Vigor") <= (amount / 60.to_f)),
          }

          echo "command_check section 2 #{s} #{buff_check[command]}" if $bigshot_debug
          return buff_check[command] if buff_check[command]
        end

        if s =~ /((?:prone|!prone|frozen|!frozen|undead|!undead|flying|!flying|hidden|!hidden|poison|!poison|disease|!disease|noncorporeal|!noncorporeal|pcs|!pcs|outside|!outside|bearhug|!bearhug|barrage|!barrage|fury|!fury|flurry|!flurry|pummel|!pummel|thrash|!thrash|reflex|!reflex|vigor|!vigor|shout|!shout|yowlp|!yowlp|surge|!surge|censer|justice|!justice|tailwind|!tailwind))/i

          item = $1.strip

          other_checks = {
            'prone'         => npc.status =~ PRONE,
            '!prone'        => npc.status !~ PRONE,
            'frozen'        => npc.status =~ /frozen/i,
            '!frozen'       => npc.status !~ /frozen/i,
            'undead'        => !npc.type.split(',').any? { |a| a == "undead" },
            '!undead'       => npc.type.split(',').any? { |a| a == "undead" },
            'flying'        => !npc.status.include?("flying"),
            '!flying'       => npc.status.include?("flying"),
            'hidden'        => !hiding?,
            '!hidden'       => hiding?,
            'poison'        => !checkpoison,
            '!poison'       => checkpoison,
            'disease'       => !checkdisease,
            '!disease'      => checkdisease,
            'noncorporeal'  => !npc.type.split(',').any? { |a| a == "noncorporeal" },
            '!noncorporeal' => npc.type.split(',').any? { |a| a == "noncorporeal" },
            'pcs'           => !((checkpcs - $grouplist).count > 0),
            '!pcs'          => ((checkpcs - $grouplist).count > 0),
            'outside'       => !outside?,
            '!outside'      => outside?,
            'barrage'       => !Effects::Buffs.active?("Enh. Dexterity (+10)"),
            '!barrage'      => Effects::Buffs.active?("Enh. Dexterity (+10)"),
            'bearhug'       => !Effects::Buffs.active?("Enh. Strength (+10)"),
            '!bearhug'      => Effects::Buffs.active?("Enh. Strength (+10)"),
            'fury'          => !Effects::Buffs.active?("Enh. Constitution (+10)"),
            '!fury'         => Effects::Buffs.active?("Enh. Constitution (+10)"),
            'flurry'        => !Effects::Buffs.active?("Slashing Strikes"),
            '!flurry'       => Effects::Buffs.active?("Slashing Strikes"),
            'pummel'        => !Effects::Buffs.active?("Concussive Blows"),
            '!pummel'       => Effects::Buffs.active?("Concussive Blows"),
            'thrash'        => !Effects::Buffs.active?("Forceful Blows"),
            '!thrash'       => Effects::Buffs.active?("Forceful Blows"),
            'tailwind'      => !Effects::Buffs.active?("Breeze Archery Tailwind"),
            '!tailwind'     => Effects::Buffs.active?("Breeze Archery Tailwind"),
            'reflex'        => !$bigshot_arcane_reflex,
            '!reflex'       => $bigshot_arcane_reflex,
            'justice'       => $bigshot_swift_justice == 0,
            '!justice'      => $bigshot_swift_justice >= 1,
            'vigor'         => !Effects::Buffs.active?('Tangleweed Vigor'),
            '!vigor'        => Effects::Buffs.active?('Tangleweed Vigor'),
            'shout'         => !Effects::Buffs.active?('Empowered (+20)'),
            '!shout'        => Effects::Buffs.active?('Empowered (+20)'),
            'yowlp'         => !Effects::Buffs.active?("Yertie's Yowlp"),
            '!yowlp'        => Effects::Buffs.active?("Yertie's Yowlp"),
            'surge'         => Effects::Buffs.active?("Enh. Strength (+32)") || Effects::Buffs.active?("Enh. Strength (+28)") || Effects::Buffs.active?("Enh. Strength (+24)") || Effects::Buffs.active?("Enh. Strength (+20)") || Effects::Buffs.active?("Enh. Strength (+16)"),
            '!surge'        => Effects::Cooldowns.active?("Surge of Strength"),
          }

          if (item == 'censer')
            if (command =~ /^(incant)?\s?(\d+)\s?((?:open|closed)?\s?(?:cast|channel|evoke)?\s?(?:cast|channel|evoke)?\s?(?:open|closed)?\s?(?:air|earth|fire|lightning|water|cold)?)?.*$/i)
              id = $2.to_i
              spell_cost = Spell[id].cost.to_i + Spell[320].cost.to_i
            else
              spell_cost = Spell[320].cost.to_i
            end

            if !Effects::Cooldowns.active?("Ethereal Censer") && Spell[320].known?
              Spell[320].cast if (checkmana >= spell_cost)
            end
          else
            echo "command_check section 3 #{s} #{other_checks[item]}" if $bigshot_debug
            return other_checks[item] if other_checks[item]
          end

        end
      }

    end

    return false
  end

  def cmd_assault(npc, cmd)
    echo "cmd_assault - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /Distracted, you hesitate/i,
      /glides to its inevitable end with one final twirl/i,
      /You feel a fair amount more durable./i,
      /With a final snap of your wrist/i,
      /You complete your assault/i,
      /Upon firing your last arrow/i,
      /With a final, explosive breath/i,
      /You don't seem to be able to move your legs to do that/i,
      /too injured/i,
      /already dead/i,
      /little bit late/i,
      /could not find/i,
    )

    error_regex = Regexp.union(
      /Barrage can not be used with attack as the attack type/i,
      /may not be activated within 60 seconds of a Multi-Strike\./i,
      /\.\.\.wait/i,
    )

    result_regex = Regexp.union(complete_regex, error_regex)

    commands = {
      "barrage"  => "Barrage",
      "flurry"   => "Flurry",
      "fury"     => "Fury",
      "gthrusts" => "Guardant Thrusts",
      "pummel"   => "Pummel",
      "thrash"   => "Thrash",
    }

    cmd_clean = cmd.split(' ').first
    return if !Weapon.available?(commands[cmd_clean])
    return unless Weapon.affordable?(commands[cmd_clean])

    waitrt?
    waitcastrt?

    break_out = Time.now() + 12
    loop {
      result = dothistimeout("weapon #{cmd} ##{npc.id}", 10, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ /Barrage can not be used with attack as the attack type/i
        # Bow in the wrong hand
        fput "swap"
        next
      elsif result =~ /may not be activated within 60 seconds of a Multi-Strike\./i
        break
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_weapons(npc, cmd)
    echo "cmd_weapons - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /You rush forward/i, # charge
      /Steeling yourself for a brawl/i, # clash
      /You reverse your grip/i, # cripple
      /a blurred cyclone/i, # cyclone
      /lash out in a strike/i, # dizzyingswing
      /You take quick assessment/i, # pindown
      /pulverize your foes/i, # pulverize
      /You raise your hands high/i, # twinhammer
      /filling the sky with a volley of deadly projectiles/i, # volley
      /With a broad flourish/i, # wblade
      /Twisting and spinning/i, # whirlwind
      /would be a rather awkward proposition/i,
      /is out of reach/i,
      /You don't seem to be able to move your legs to do that/i,
      /too injured/i,
      /already dead/i,
      /little bit late/i,
      /could not find/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "charge"        => "Charge",
      "clash"         => "Clash",
      "cripple"       => "Cripple",
      "cyclone"       => "Cyclone",
      "dizzyingswing" => "Dizzying Swing",
      "pindown"       => "Pin Down",
      "pulverize"     => "Pulverize",
      "twinhammer"    => "Twin Hammerfists",
      "volley"        => "Volley",
      "wblade"        => "Whirling Blade",
      "whirlwind"     => "Whirlwind",
    }

    cmd_clean = cmd.split(' ').first
    return if !Weapon.available?(commands[cmd_clean])
    return unless Weapon.affordable?(commands[cmd_clean])
    return if npc.status =~ PRONE && commands[cmd] =~ /Charge|Twin Hammerfists/

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("weapon #{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_shields(npc, cmd)
    echo "cmd_shields - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /awkward proposition/i,
      /little bit late/i,
      /still stunned/i,
      /too injured/i,
      /what?/i,
      /You cannot/i,
      /Could not find/i,
      /seconds/i,
      /You snap your arm/i,
      /attempt a shield bash/i,
      /attempt a shield charge/i,
      /launch a quick bash/i,
      /diversionary shield bash/i,
      /charge headlong towards/i,
      /attempt to push/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "shield bash"    => "Shield Bash",
      "shield charge"  => "Shield Charge",
      "shield pin"     => "Shield Pin",
      "shield push"    => "Shield Push",
      "shield strike"  => "Shield Strike",
      "shield throw"   => "Shield Throw",
      "shield trample" => "Shield Trample",
    }

    # need to check if its the cman version or the shield version
    if cmd =~ /shield bash/ && CMan.available?("Shield Bash")
      return unless CMan.affordable?("Shield Bash")

      cmd = "cman sbash"
    else
      return if !Shield.available?(commands[cmd])
      return unless Shield.affordable?(commands[cmd])
    end

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("#{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_cmans(npc, cmd)
    echo "cmd_cmans - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|You cannot|Could not find|seconds/i,
      /attempt a shield bash/i,
      /release your grip/i,
      /feat of strength empowers/i,
      /your grasp/i,
      /leaving you flailing/i,
      /completely miss/i,
      /unable to complete/i,
      /dip your shoulder and rush/i,
      /intending to finish/i,
      /isn't injured enough/i,
      /thwarts your attempt/i,
      /You approach/i,
      /You maneuver in close/i,
      /try to maneuver/i,
      /can't manage to do that right now/i,
      /rooted in place/i,
      /foot and let it fly/i,
      /clump of dust/i,
      /blur of steel in your eagerness/i,
      /slows to a trickle and finally stops/i,
      /You let out a shrill yell and leap, spinning through the air/i,
      /is not bleeding/i,
      /You feint/i,
      /deliver a kick/i,
      /out of reach/i,
      /try to hamstring/i,
      /roundhouse punch/i,
      /attempt to headbutt/i,
      /leap into the air/i,
      /low enough for you to attack/i,
      /isn't flying/i,
      /with all your might/i,
      /with staggering might/i,
      /concentrate on the magical wards/i,
      /anti-magical equipment/i,
      /spinning leap towards/i,
      /split it asunder/i,
      /holding a shield/i,
      /You hurl yourself/i,
      /jerk the weapon sharply sideways/i,
      /will strike true/i,
      /vaulting kick/i,
      /is lying down/i,
      /concentrate on the magic/i,
      /anti-magical equipment/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "bullrush"     => "Bull Rush",
      "coupdegrace"  => "Coup de Grace",
      "cpress"       => "Crowd Press",
      "dirtkick"     => "Dirtkick",
      "exsanguinate" => "Exsanguinate",
      "feint"        => "Feint",
      "gkick"        => "Groin Kick",
      "hamstring"    => "Hamstring",
      "haymaker"     => "Haymaker",
      "headbutt"     => "Headbutt",
      "leapattack"   => "Leap Attack",
      "mblow"        => "Mighty Blow",
      "sattack"      => "Spin Attack",
      "sbash"        => "Shield Bash",
      "sblow"        => "Staggering Blow",
      "scleave"      => "Spell Cleave",
      "sthieve"      => "Spell Thieve",
      "sunder"       => "Sunder Shield",
      "tackle"       => "Tackle",
      "trip"         => "Trip",
      "truestrike"   => "True Strike",
      "vaultkick"    => "Vault Kick",
    }

    cmd_clean = cmd.split(' ').first
    return if !CMan.available?(commands[cmd_clean])
    return unless CMan.affordable?(commands[cmd_clean])
    return if npc.status =~ PRONE && cmd =~ /^bullrush/i
    return if Effects::Cooldowns.active?("Spell Cleave") && cmd =~ /^scleave/i
    return if Effects::Cooldowns.active?("Spell Thieve") && cmd =~ /^sthieve/i

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("cman #{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_bearhug(npc, cmd)
    echo "cmd_bearhug - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    complete_regex = Regexp.union(
      /You release your grip/i,
      /You feel a fair amount stronger./i,
      /avoids your grasp/i,
      /fend off your grasp/i,
      /leaving you flailing/i,
      /Your concentration lapses/i,
      /You don't seem to be able to move your legs to do that/i,
      /too injured/i,
      /already dead/i,
      /little bit late/i,
      /could not find/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "bearhug" => "Bearhug"
    }

    cmd_clean = cmd.split(' ').first
    return if !CMan.available?(commands[cmd_clean])
    return unless CMan.affordable?(commands[cmd_clean])

    waitrt?
    waitcastrt?

    break_out = Time.now() + 17 # Up to 5 rounds at 3 sec each plus a little
    loop {
      result = dothistimeout("cman #{cmd} ##{npc.id}", 16, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_rogue_cmans(npc, cmd)
    echo "cmd_rogue_cmans - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    result_regex = Regexp.union(
      /awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|You cannot|Could not find|seconds/i,
      /attempt to slit/i,
      /Try hiding first/i,
      /kicking up as much dirt/i,
      /you're already out of sight/i,
      /Try hiding first/i,
      /prepare your diversion/i,
      /poised to eviscerate/i,
      /finger at the eye/i,
      /attempting to footstomp/i,
      /fling your wire around/i,
      /damage to yourself/i,
      /down at the knee/i,
      /boldly accost/i,
      /won't fall for that again/i,
      /reach out and grab/i,
      /stand up first/i,
      /spring from hiding/i,
      /You swing/i,
      /crouch and sweep/i,
      /attempting a swiftkick/i,
      /swing the blunt end/i,
      /You chop/i,
    )

    commands = {
      "cutthroat"  => "Cutthroat",
      "divert"     => "Divert",
      "shroud"     => "Dust Shroud",
      "eviscerate" => "Eviscerate",
      "eyepoke"    => "Eyepoke",
      "footstomp"  => "Footstomp",
      "garrote"    => "Garrote",
      "kneebash"   => "Kneebash",
      "mug"        => "Mug",
      "nosetweak"  => "Nosetweak",
      "subdue"     => "Subdue",
      "spunch"     => "Sucker Punch",
      "sweep"      => "Sweep",
      "swiftkick"  => "Swiftkick",
      "templeshot" => "Templeshot",
      "throatchop" => "Throatchop",

    }

    cmd_clean = cmd.split(' ').first
    return if !CMan.available?(commands[cmd_clean])
    return unless CMan.affordable?(commands[cmd_clean])

    waitrt?
    waitcastrt?

    result = dothistimeout("cman #{cmd} ##{npc.id}", 2, result_regex)
    if (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from #{cmd} routine: #{result}"
    end
  end

  def cmd_warrior_shouts(npc, cmd)
    echo "cmd_warrior_shouts - npc: #{npc} cmd: #{cmd}" if $bigshot_debug

    cmd = cmd.downcase

    return if Effects::Debuffs.active?("Overexerted")
    return if cmd == "shout"  && checkstamina < 21
    return if cmd == "yowlp"  && checkstamina < 11
    return if cmd == "holler" && checkstamina < 31
    return if cmd == "bellow all" && checkstamina < 21
    return if cmd == "bellow" && checkstamina < 11
    return if cmd == "growl all" && checkstamina < 15
    return if cmd == "growl" && checkstamina < 8
    return if cmd == "cry all" && checkstamina < 31
    return if cmd == "cry" && checkstamina < 16

    result_regex = Regexp.union(
      /You let loose an echoing shout!/i,
      /You throw back your shoulders and let out a resounding yowlp!/i,
      /You throw back your head and let out a thundering holler!/i,
      /Your fighting spirit is bolstered!|round(time)?|seconds/i,
      /nerve-shattering bellow!/i,
      /round(time)?|seconds/i,
      /eerie, modulating cry/i,
      /You must be an active member/i,
    )

    waitrt?
    waitcastrt?

    if cmd.include?("all")
      result = dothistimeout("warcry #{cmd}", 2, result_regex)
    elsif cmd =~ /bellow|growl|cry/i
      result = dothistimeout("warcry #{cmd} ##{npc.id}", 2, result_regex)
    else
      result = dothistimeout("warcry #{cmd}", 2, result_regex)
    end

    if (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from #{cmd} routine: #{result}"
    end

    sleep(0.5)
  end

  def volnsmite(npc)
    echo "volnsmite" if $bigshot_debug
    while !$bigshot_smite_list.any? { |a| a.to_i == npc.id.to_i } && npc.status !~ /dead|gone/ && GameObj.targets.any? { |s| s.id == npc.id } && !should_flee? && (npc.type.split(',').any? { |a| a == "undead" } || npc.type.split(',').any? { |a| a == "noncorporeal" })
      res = dothistimeout "smite ##{npc.id}", 1, /^Roundtime|^What were you referring to\?$/
      if res =~ /^What were you referring to\?$/i
        break
      end

      sleep(1)
    end
  end

  def unarmed(command, npc, manualaim)
    echo "unarmed" if $bigshot_debug
    return if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }

    $bigshot_aim = -1 if manualaim != "" && $bigshot_aim == 0
    $mstrike_taken = false
    volnsmite(npc) if !$bigshot_smite_list.any? { |a| a.to_i == npc.id.to_i } && npc.type.split(',').any? { |a| a == "noncorporeal" } && $bigshot_unarmed_tier == 3 && Spell[9821].known? && @UAC_SMITE
    # 9005 - Mstrike recovery
    # 9699 - popped muscles

    # mstrike using Tier3 and auto-tierup
    if @TIER3 && !@UAC_MSTRIKE
      cmd("mstrike #{@TIER3}", npc)
      sleep(0.3)
    elsif !@UAC_MSTRIKE
      cmd("mstrike #{command}", npc)
      sleep(0.3)
    end

    if (!$mstrike_taken)
      if $bigshot_unarmed_tier == 3 && $bigshot_unarmed_followup == false # command =~ /jab/ &&
        if manualaim != ""
          cmd("#{@TIER3} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{@TIER3} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{@TIER3} ##{npc.id}", npc)
        end
      elsif $bigshot_unarmed_followup == true
        command = $bigshot_unarmed_followup_attack
        if manualaim != ""
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id}", npc)
        end
      else
        if manualaim != ""
          cmd("#{command} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{command} ##{npc.id}", npc)
        end
      end
    end
    timeNow = Time.now + 5
    while (line = get)
      if line =~ /You have (decent|good|excellent) positioning/
        tier = $1
        if tier =~ /decent/
          $bigshot_unarmed_tier = 1
        elsif tier =~ /good/
          $bigshot_unarmed_tier = 2
        elsif tier =~ /excellent/
          $bigshot_unarmed_tier = 3
        end
      elsif line =~ /.* = .* d100: .* = \-?(\d+)$/ && $bigshot_unarmed_followup == true
        endroll = $1
        if endroll.to_i > 100
          $bigshot_unarmed_followup = false
        end
      elsif line =~ /Strike leaves foe vulnerable to a followup (.*) attack!/
        $bigshot_unarmed_followup = true
        $bigshot_unarmed_followup_attack = $1
      elsif line =~ /You fail to find an opening for your strike\./
        $bigshot_aim += 1
      elsif line =~ /You cannot aim that high!|is already missing that!/
        $bigshot_aim += 1
        cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
      elsif line =~ /does not have/
        $bigshot_aim += 1
        cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
      elsif line =~ /Roundtime:/i
        $bigshot_aim = 0
        break
      elsif line =~ /^Try standing up first\.$|[wW]ait \d+ sec.*|Sorry,|You can't do that while entangled in a web|You are still stunned|from here\.  Perhaps you should try throwing or shooting something at it\./
        break
      elsif line =~ /You don't seem to be able to move to do that\./
        sleep(2)
        break
      elsif line =~ /You are unable to muster the will to attack anything\.|Your rage causes you to use all of your skill in an all out attack!/
        Spell[1201].cast if Spell[1201].known? && Spell[1201].affordable?
        break
      elsif npc.status =~ /dead|gone/ || !(GameObj.targets.any? { |s| s.id == npc.id }) || should_flee? || should_rest? || line =~ /You currently have no valid target\.  You will need to specify one\.|^It looks like somebody already did the job for you\.$|What were you referring to/
        $bigshot_unarmed_tier = 1
        $bigshot_unarmed_followup = false
        $bigshot_unarmed_followup_attack = ""
        break
      elsif timeNow < Time.now
        break
      end
    end
    $mstrike_taken = false
  end

  def cmd_bless()
    echo "cmd_bless" if $bigshot_debug
    while $bigshot_bless.count > 0
      if Spell[1604].known? && Spell[1604].affordable?
        waitrt?
        waitcastrt?
        next if Spell[1604].cast("##{$bigshot_bless[$bigshot_bless.count - 1]}", /A violet tongue of flame enfolds the/) =~ /A violet tongue of flame enfolds the/
      end
      if Spell[304].known? && Spell[304].affordable?
        waitrt?
        waitcastrt?
        Spell[304].cast("##{$bigshot_bless[$bigshot_bless.count - 1]}")
        $bigshot_bless.delete($bigshot_bless[$bigshot_bless.count - 1])
      elsif Spell[9802].known?
        waitrt?
        waitcastrt?
        fput "symbol bless ##{$bigshot_bless[$bigshot_bless.count - 1]}"
        $bigshot_bless.delete($bigshot_bless[$bigshot_bless.count - 1])
      else
        $bigshot_should_rest = true
        $rest_reason = "No blessing on weapon"
        $bigshot_bless = []
        return
      end
    end
  end

  def cmd_assume(aspect, extra)
    echo "cmd_assume" if $bigshot_debug
    return unless Spell[650].known?

    unless aspect =~ /^(?:jackal|wolf|lion|panther|hawk|owl|porcupine|rat|bear|burgee|mantis|serpent|spider|yierka)$/i
      message("yellow", "cmd_assume requires a proper aspect to assume. You used #{aspect}. They are:")
      message("yellow", "jackal, wolf, lion, panther, hawk, owl, porcupine, rat, bear, burgee, mantis, serpent, spider, yierka")
      message("yellow", "Please use the following for a command: assume <aspect1> <aspect2/evoke>")
      message("yellow", "Please use the following for society box: 650 <aspect1> <aspect2/evoke>")
      return
    end
    unless extra =~ /^(?:jackal|wolf|lion|panther|hawk|owl|porcupine|rat|bear|burgee|mantis|serpent|spider|yierka|evoke)$/i
      message("yellow", "Assume command requires to be given either two aspects or aspect + evoke")
      message("yellow", "Example:")
      message("yellow", "   Command - assume lion wolf")
      message("yellow", "   Command - assume lion evoke")
      message("yellow", "   Society - 650 lion wolf")
      message("yellow", "   Society - 650 lion evoke")
      message("yellow", "Due to improper above structure, wasting half of Assume Aspect ability")
    end

    timer = (Time.now - 240)
    CharSettings['jackal']     = timer if CharSettings['jackal'].nil?
    CharSettings['wolf']       = timer if CharSettings['wolf'].nil?
    CharSettings['lion']       = timer if CharSettings['lion'].nil?
    CharSettings['panther']    = timer if CharSettings['panther'].nil?
    CharSettings['hawk']       = timer if CharSettings['hawk'].nil?
    CharSettings['owl']	       = timer if CharSettings['owl'].nil?
    CharSettings['porcupine']  = timer if CharSettings['porcupine'].nil?
    CharSettings['rat']        = timer if CharSettings['rat'].nil?
    CharSettings['bear']       = timer if CharSettings['bear'].nil?
    CharSettings['burgee']     = timer if CharSettings['burgee'].nil?
    CharSettings['mantis']     = timer if CharSettings['mantis'].nil?
    CharSettings['serpent']    = timer if CharSettings['serpent'].nil?
    CharSettings['spider']     = timer if CharSettings['spider'].nil?
    CharSettings['yierka']     = timer if CharSettings['yierka'].nil?
    aspect_timer = CharSettings.to_hash

    waitrt?
    waitcastrt?
    unless Effects::Buffs.active?("Assume Aspect") || Effects::Buffs.active?("650")
      Spell[650].force_evoke if ((extra =~ /evoke/i) && Spell[650].affordable?)
      Spell[650].cast if ((extra !~ /evoke/i) && Spell[650].affordable?)
      first_aspect = true
      waitcastrt?
    end
    return unless Effects::Buffs.active?("Assume Aspect") || Effects::Buffs.active?("650")

    if (!Effects::Buffs.active?("Aspect of the #{aspect.capitalize()}") && !Effects::Buffs.active?("Aspect of the #{extra.capitalize()}"))
      if ((Time.now > aspect_timer[aspect]) && ((first_aspect == true) || (checkmana >= 25)))
        dothistimeout "assume #{aspect}", 1, /^You concentrate your focus upon the Aspect|^You feel that you will not be able to fully concentrate upon the Aspect/i
        # first_aspect = false
        CharSettings[aspect] = (Time.now + 240)
        echo CharSettings[aspect] if $bigshot_debug
      elsif ((!extra.to_s.empty? && extra !~ /evoke/i) && (Time.now > aspect_timer[extra]) && ((first_aspect == true) || (checkmana >= 25)))
        dothistimeout "assume #{extra}", 1, /^You concentrate your focus upon the Aspect|^You feel that you will not be able to fully concentrate upon the Aspect/i
        # first_aspect = false
        CharSettings[extra] = (Time.now + 240)
        echo CharSettings[extra] if $bigshot_debug
      end
    end
  end

  def cmd_briar(weapon)
    echo "cmd_briar" if $bigshot_debug
    return if (weapon.nil? || $bigshot_briars)
    return if (weapon != GameObj.right_hand.to_s && weapon != GameObj.left_hand.to_s)

    ready = false
    silence_me unless (undo_silence = silence_me)
    res = Lich::Util.quiet_command_xml("look #{weapon}", /You gaze intently|You see/, /<prompt time=/)
    if res.any? { |line| line =~ /to be about (\d+) percent./i }
      ready = true if $1.to_i == 100
      sleep(0.2)
    end
    silence_me if undo_silence
    fput "raise #{weapon}" if ready == true
  end

  def cmd_throw(npc)
    echo "cmd_throw" if $bigshot_debug
    unless npc.status == 'lying down'
      empty_hands
      dothistimeout "throw ##{npc.id}", 1, /^You attempt to throw a .*\!$/
      waitrt?
      fill_hands
    end
  end

  def cmd_force(force_this, goal, npc)
    echo "cmd_force" if $bigshot_debug
    start = Time.now
    loop {
      return if cmd(force_this, npc) == false

      sleep(0.1)
      buffer = reget(35)
      buffer.each_with_index { |line, i|
        if (line =~ /^You.*(#{checknpcs.join('|')})|^You feint (high|low|(to the (left|right)))/)
          if (buffer[i + 1] && buffer[i + 1] =~ /== \+(\d+)/) || (buffer[i + 2] && buffer[i + 2] =~ /== \+(\d+)/)
            return true if $1.to_i >= goal # spell/swing
          elsif (buffer[i - 1] && buffer[i - 1] =~ /^\[(?:Roll|SMR|SSR) result: (\d+)/) || (buffer[i - 2] && buffer[i - 2] =~ /^\[(?:Roll|SMR|SSR) result: (\d+)/) || (buffer[i + 1] && buffer[i + 1] =~ /^\[(?:Roll|SMR|SSR) result: (\d+)/) || (buffer[i + 2] && buffer[i + 2] =~ /^\[(?:Roll|SMR|SSR) result: (\d+)/)
            return true if $1.to_i >= goal # cman
          elsif (buffer[i + 1] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/) || (buffer[i + 2] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/)
            return false
          end
        elsif (line =~ /^You do not have enough stamina to attempt this maneuver\.|^(?:.*) is lying down -- attempting to (?:.*) would be a rather awkward proposition\./)
          return false
        elsif (line =~ /^Your magic fizzles ineffectually\./)
          return false
        elsif (line =~ /^You are (?:still )?stunned\./ || muckled?)
          return false
        end
      }
      if (force_this =~ /^(\d+) / && !Spell[$1.to_i].affordable?)
        message("yellow", "Force ran out of mana. Giving up."); return;
      end
      return if GameObj.targets.size.nil? || GameObjNpcCheck() == 0
      return if should_flee?
      return if should_rest?
      return if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }
      return if (Time.now - start) > 30
    }
  end

  def cmd_weed(command, target)
    echo "cmd_weed" if $bigshot_debug

    return if target.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == target.id }
    return if GameObj.loot.find { |loot| loot.name =~ /\b(?:vine|bramble|widgeonweed|vathor club|swallowwort|smilax|creeper|briar|ivy|tumbleweed)\b/ }
    return unless Spell[610].known? and Spell[610].affordable?

    waitcastrt?
    change_stance('offensive') if command =~ /kweed/
    Spell[610].cast("##{target.id}")
    change_stance('guarded') if command =~ /kweed/
    waitcastrt?
  end

  def cmd_spell(incant = nil, id, extra, target)
    echo "cmd_spell" if $bigshot_debug
    selfcast = spell_is_selfcast?(id)

    if (checkprep != "None" and checkprep != Spell[id].name)
      fput 'release'
    end

    return if id == 506 and Spell[506].active?
    return if id == 9605 and Effects::Cooldowns.active?("Surge of Strength") # surge cooldown
    return if id == 9625 and Effects::Cooldowns.active?("Burst of Swiftness") # burst cooldown
    return if id == 608 and hiding?
    return if id == 703 and $bigshot_703_list.any? { |s| s == target.id }
    return if id == 1614 and $bigshot_1614_list.any? { |s| s == target.id }
    return if target.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == target.id }

    unless (Spell[id].affordable?)
      if (@WAND_IF_OOM)
        cmd_wand(target); return;
      end
      if (@USE_WRACKING)
        wrack()
      end
    end

    if (!Spell[id].affordable? and id != 9605 and id != 506)
      $bigshot_should_rest = true
      $rest_reason = "out of mana"
    end
    return if !Spell[id].affordable? && $bigshot_quick

    waitrt?
    waitcastrt?

    if incant.nil?
      if selfcast
        Spell[id].cast(Char.name)
      else
        Spell[id].cast("##{target.id}")
      end
    else
      if selfcast
        bs_put "target clear"
      end

      change_stance('offensive') if Spell[id].stance || (id.to_s =~ /1700/i && extra =~ /evoke/i)
      bs_put "incant #{id} #{extra}"
      change_stance(@HUNTING_STANCE)

      if selfcast
        bs_put "target ##{target.id}"
      end
    end
  end

  def cmd_wand(target)
    echo "cmd_wand" if $bigshot_debug
    if (@FRESH_WAND_CONTAINER)
      # hands = GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s
      until ((GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s) =~ /#{@WAND[$bigshot_wand].split(' ').join('.*?')}/i)
        result = dothistimeout("get #{@WAND[$bigshot_wand]} from my #{@FRESH_WAND_CONTAINER}", 3, /You remove|You slip|Get what/)
        if (result =~ /Get what/)
          $bigshot_wand += 1
          if @WAND[$bigshot_wand].nil?
            message("yellow", "ERROR: Couldn't find fresh wand. Gonna rest."); $bigshot_should_rest = true; return;
          end
        elsif (result.nil?)
          message("yellow", "ERROR: Timed out looking for wand."); return;
        end
      end

      change_stance('offensive')
      result = dothistimeout("wave my #{@WAND[$bigshot_wand]} at ##{target.id}", 2, /d100|You hurl|is already dead|You do not see that here|You are in no condition|I could not find|Wait/)
      change_stance(@HUNTING_STANCE)

      if (result =~ /You are in no condition/)
        message("yellow", "ERROR: Wounded. Gonna rest."); $bigshot_should_rest = true; return;
      elsif (result.nil?)
        if (@DEAD_WAND_CONTAINER)
          bs_put "put my #{@WAND[$bigshot_wand]} in my #{@DEAD_WAND_CONTAINER}"
        else
          bs_put "drop my #{@WAND[$bigshot_wand]}"
        end
      end
    else
      message("yellow", "ERROR: Wand command called but fresh wand container not defined.")
    end
  end

  def cmd_stomp()
    echo "cmd_stomp" if $bigshot_debug
    return if !Spell[909].known?

    waitrt?
    waitcastrt?
    if Spell[909].active?
      fput "stomp" if checkmana(5)
    elsif Spell["909"].affordable?
      Spell["909"].force_channel
      waitcastrt?
      fput "stomp" if checkmana(5)
    end
  end

  def cmd_leech()
    echo "cmd_leech" if $bigshot_debug
    return if !Spell[516].known?

    if (Effects::Cooldowns.time_left("Mana Leech") < 15) && (Spell[516].affordable?)
      waitrt?
      waitcastrt?
      Spell[516].cast
    end
  end

  def cmd_hide(attempts)
    echo "cmd_hide" if $bigshot_debug
    tries = 0
    attempts = 3 if attempts == 0
    until (hiding?)
      break if tries > attempts || should_flee?

      change_stance('defensive')
      fput "hide"
      tries += 1
    end
  end

  def mstrike_spell_check()
    echo "mstrike_spell_check" if $bigshot_debug
    # Rejuvenation
    if (Spell[1607].known? && !Spell[1607].active? && Spell[1607].affordable? && (checkstamina < (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
      if ((checkstamina + (15 + (bonus = 0; [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190].each { |n| bonus += 1 if Skills.slblessings >= n }; bonus * 3))) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE))
        waitcastrt?
        Spell[1607].cast
      end
    end
    # Adrenal Surge
    if (Spell[1107].known? && Spell[1107].affordable? && !Spell[9010].active? && (Time.now >= $bigshot_adrenal_surge))
      if (Spell[9699].active? || ((maxstamina if Skills.slblessings >= 65) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      elsif (Spell[9699].active? || ((checkstamina + (Skills.slblessings >= 35 ? 50 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      elsif (Spell[9699].active? || ((checkstamina + (Skills.slblessings >= 35 ? 25 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      end
    end
  end

  def cmd_mstrike(command, target)
    echo "cmd_mstrike" if $bigshot_debug
    mstrike_spell_check() if Char.prof =~ /Paladin|Empath/i
    # Mstrike checks
    if Effects::Debuffs.active?("Overexerted") # TODO PoPped muscle check updates
      $mstrike_taken = false
      return
    end
    if Skills.multiopponentcombat >= 30 && GameObj.targets.all? { |i| i.noun !~ /nest/i }
      if (!Effects::Cooldowns.active?("Multi-Strike") || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
        if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Effects::Debuffs.active?("Overexerted")
          if (GameObjNpcCheck() >= @MSTRIKE_MOB || target.nil?)
            bs_put "quickstrike 1 #{command}"
          else
            bs_put "quickstrike 1 #{command} ##{target.id}"
          end
        else
          if (GameObjNpcCheck() >= @MSTRIKE_MOB || target.nil?)
            bs_put "#{command}"
          else
            bs_put "#{command} ##{target.id}"
          end
        end
        $mstrike_taken = true
      end
    elsif Skills.multiopponentcombat >= 5 && GameObj.targets.all? { |i| i.noun !~ /nest/i } && GameObjNpcCheck() >= @MSTRIKE_MOB
      if (!Effects::Cooldowns.active?("Multi-Strike") || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
        if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Effects::Debuffs.active?("Overexerted")
          bs_put "quickstrike 1 #{command}"
        else
          bs_put "#{command}"
        end
        $mstrike_taken = true
      end
    end
  end

  def checkTargetVitals(command, target, ranged = false)
    # General logic for this taken from ;fire by Oweodry
    fput "look ##{target.id}"
    loc = (ranged) ? $bigshot_archery_aim : $bigshot_ambush
    woundinfo = matchtimeout(1, /(he|she|it) has .*/i)
    if (command[loc] == "head" && woundinfo =~ /severe head trauma and bleeding from .* ears/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "neck" && woundinfo =~ /snapped bones and serious bleeding from .* neck/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "left eye" && woundinfo =~ /blinded left eye/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "right eye" && woundinfo =~ /blinded right eye/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    end
  end

  def cmd_1040(target)
    echo "cmd_1040 #{target}" if $bigshot_debug
    return if !Spell[1040].known?

    waitrt?
    waitcastrt?
    fput "mana pulse" if !Spell[1040].affordable?
    if target != Char.name
      Spell[1040].cast if Spell[1040].affordable?
    elsif target == Char.name
      until !webbed? && !sleeping? && !stunned? && !frozen?
        Spell[1040].cast if Spell[1040].affordable?
        fput "mana pulse" if !Spell[1040].affordable?
        waitcastrt?
      end
    end
  end

  def cmd_dhurl()
    echo "cmd_dhurl" if $bigshot_debug
    waitrt?
    waitcastrt?
    res = dothistimeout "hurl", 1, Regexp.union(
      /^Roundtime/,
      /^What were you referring to\?$/,
      /^You throw/,
      /^You take aim and throw/,
      /That's not going to do much.  Try using a weapon/,
      /You find nothing recoverable/
    )
    if res =~ /You take aim and throw|You throw/
      weapon_hurled_room = Room.current.id
      hold = 6 - checkrt.to_f
      hold = 0 if hold.to_f <= 0
      waitrt?
      sleep(hold)
      Script.run("go2", weapon_hurled_room)
      cmd_recover()
    elsif res =~ /That's not going to do much.  Try using a weapon|You find nothing recoverable/
      Script.run("go2", weapon_hurled_room)
      cmd_recover()
      return
    end
  end

  def cmd_recover(weapon_lost = true)
    echo "cmd_recover" if $bigshot_debug
    until weapon_lost == false
      break if $bigshot_bond_return == true

      waitrt?
      res = dothistimeout "recover hurl", 1, Regexp.union(
        /You know (.*) is around here somewhere, but you don't see it./,
        /You spy a (.*) and recover it/,
        /A (.*) rises out of the shadows and flies back to your waiting hand!/,
        /In order to recover your hurled weapon, you'll need to have a free hand./,
        /You find nothing recoverable./,
      )
      if res =~ /You know (.*) is around here somewhere, but you don't see it./
        sleep(0.5)
      elsif res =~ /You spy a (.*) and recover it|(.*) rises out of the shadows and flies back to your waiting hand!/
        weapon_lost = false
      elsif res =~ /In order to recover your hurled weapon, you'll need to have a free hand.|You find nothing recoverable./
        weapon_lost = false
      end
    end
  end

  def cmd_ranged(npc)
    echo "cmd_ranged" if $bigshot_debug
    if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }
      $bigshot_archery_aim = 0
      $bigshot_archery_stuck_location = []
      return
    end
    if !@ARCHERY_AIM[$bigshot_archery_aim].nil?
      if $bigshot_archery_stuck_location.any? { |s| s =~ /#{$bigshot_archery_location}/i }
        $bigshot_archery_aim += 1
      end
      if (@ARCHERY_AIM[$bigshot_archery_aim] == "head" || @ARCHERY_AIM[$bigshot_archery_aim] == "neck" || @ARCHERY_AIM[$bigshot_archery_aim] == "left eye" || @ARCHERY_AIM[$bigshot_archery_aim] == "right eye")
        checkTargetVitals(@ARCHERY_AIM, npc, true)
      end
      if $bigshot_archery_aim > @ARCHERY_AIM.length
        $bigshot_archery_aim = 0
        $bigshot_archery_stuck_location = []
      end

      if @ARCHERY_AIM[$bigshot_archery_aim] !~ /#{$bigshot_archery_location}/i || $bigshot_archery_location.nil?
        fput "aim #{@ARCHERY_AIM[$bigshot_archery_aim]}"
      end
    end

    waitrt?
    waitcastrt?

    #    if @AMMO
    #      result = dothistimeout "get 1 my #{@AMMO.sub(/s$/, '')}", 2, /You remove|Get what\?|You already/
    #      if (result =~ /Get what\?/)
    #        $bigshot_should_rest = true
    #        $rest_reason = "Out of ammo"
    #        return
    #      end
    #    end

    result = dothistimeout("fire ##{npc.id}", 2, /round(time)?|You cannot|Could not find|seconds|Get what?/i)
    if (result =~ /^Could not find/)
      # gather_ammo()#Not used since archery updates.
    elsif (result =~ /You cannot fire/)
      unless GameObj.right_hand.id.nil?
        line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
      end
    elsif (result =~ /but it has no effect/)
      $bigshot_should_rest = true
      $rest_reason = "Ammo had no effect (need blessed or magical)"
    elsif (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from fire routine: #{result}"
    elsif result =~ /round(time)?/i
      $bigshot_archery_aim = 0
      $bigshot_archery_stuck_location = []
    end
  end

  def cmd_dislodge(npc, location)
    echo "cmd_dislodge #{npc} #{location}" if $bigshot_debug
    return if !CMan.available?("Dislodge")
    return if npc.id != $bigshot_dislodge_target

    target = nil
    location = location.split(/ /, 9) # [bigshot: ["eye", "head", "neck", "chest", "back", "abdomen", "arm", "leg", "hand"]]
    location.each { |loc|
      if $bigshot_dislodge_location.include?(loc)
        target = loc
        break
      end
    }
    return if target.nil?

    waitrt?
    waitcastrt?
    result = dothistimeout("cman dislodge ##{npc.id} #{target}", 2, /attempting to dislodge|suitable weapons lodged|You can't reach|awkward proposition|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
    if (result =~ /You manage to dislodge|You skillfully wrench/ && npc.status =~ /dead|gone/)
      $bigshot_dislodge_location = []
      $bigshot_dislodge_target = nil
    elsif (result =~ /You manage to dislodge|You skillfully wrench/)
      $bigshot_dislodge_location.delete(target)
      target = nil
    elsif (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from dislodge routine: #{result}"
    end
  end

  def cmd_surge()
    echo "cmd_surge" if $bigshot_debug
    return if !CMan.known?("Surge of Strength")
    return if (Effects::Buffs.active?("Enh. Strength (+32)") || Effects::Buffs.active?("Enh. Strength (+28)") || Effects::Buffs.active?("Enh. Strength (+24)") || Effects::Buffs.active?("Enh. Strength (+20)") || Effects::Buffs.active?("Enh. Strength (+16)"))

    waitrt?
    waitcastrt?
    if (checkstamina >= 30 && !Effects::Cooldowns.active?("Surge of Strength"))
      result = dothistimeout("cman surge", 1, /You feel a great deal stronger.|untapped sources of strength|still recent prior attempt|come from your muscles|ache much too badly/i)
      if (result == false)
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from surge routine: #{result}"
      end
    elsif (checkstamina >= 60 && Effects::Cooldowns.active?("Surge of Strength"))
      result = dothistimeout("cman surge", 1, /You feel a great deal stronger.|untapped sources of strength|still recent prior attempt|come from your muscles|ache much too badly/i)
      if (result == false)
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from surge routine: #{result}"
      end
    end
  end

  def cmd_berserk()
    echo "cmd_berserk" if $bigshot_debug
    if (checkstamina(20))
      change_stance('defensive')
      Spell[9607].cast
      pause 5
      wait_until { !Spell[9607].active? }
    else
      bs_put 'target random'; bs_put 'kill';
    end
  end

  def cmd_run_script(name, args)
    echo "cmd_run_script" if $bigshot_debug
    if (args == nil || args =~ /^\s*$/)
      run_script(name, true)
    else
      args = args.split(/ /)
      run_script(name, true, args)
    end
  end

  def cmd_sleep(time, npc)
    echo "cmd_sleep" if $bigshot_debug
    change_stance('defensive')
    time.to_i.times do
      sleep(1)
      break if should_rest?
      break if npc && npc.status =~ /dead|gone/
    end
  end

  def cmd_ambush(command, target)
    echo "cmd_ambush" if $bigshot_debug
    if target.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == target.id }
      $bigshot_ambush = 0
      return
    end
    command = ["head", "right leg", "left leg", "chest"] if (command == "" || command.nil?) && @AMBUSH == []
    command = @AMBUSH if (command == "" || command == [] || command.nil?) && @AMBUSH != []
    command = [command] if command.class == String
    if ($bigshot_ambush >= command.length())
      # If you have gotten here, there is nothing left to target on your list.
      $bigshot_ambush = 0
      command = ["chest"]
    end
    if (command[$bigshot_ambush] == "head" || command[$bigshot_ambush] == "neck" || command[$bigshot_ambush] == "left eye" || command[$bigshot_ambush] == "right eye")
      checkTargetVitals(command, target)
    end
    waitrt?
    ambush_or_attack = (hidden?) ? "ambush" : "attack"
    result = dothistimeout "#{ambush_or_attack} ##{target.id} #{command[$bigshot_ambush]}", 2, /round(time)?|You cannot aim that high!|does not have a head!|is already missing that!|does not have a .* leg!|does not have a .* arm!/i
    if result =~ /You cannot aim that high!|does not have a head!|is already missing that!|does not have a (?:right|left) leg!|does not have a (?:right|left) arm!/i
      $bigshot_ambush += 1
      cmd_ambush(nil, target)
    elsif result =~ /round(time)?/i
      $bigshot_ambush = 0
    end
  end

  def cmd_nudge_weapons()
    echo "cmd_nudge_weapons" if $bigshot_debug
    return if checkpaths.size == 0

    GameObj.loot.each { |i|
      next unless i.noun =~ /axe|scythe|pitchfork|falchion|sword|lance|sword|dagger|estoc|falchion|handaxe|katana|katar|gauche|rapier|scimitar|whip-blade|cudgel|crowbill|whip|mace|star|hammer|claidhmore|flail|flamberge|maul|pick|staff|mattock/

      change_stance('defensive')

      sheathed = false
      unless (righthand.nil? || lefthand.nil?)
        sheathed = true
        fput 'sheath'
        unless (righthand.nil? || lefthand.nil?)
          message("yellow", "Unable to empty hands via sheath.")
          break
        end
      end

      # dirs = checkpaths
      dir  = checkpaths.shift
      fput "get ##{i.id}"
      put dir
      put "drop ##{i.id}"
      fput reverse_direction(dir)
      fput "gird" if sheathed
    }
  end

  def group_status_ailments()
    echo "group_status_ailments" if $bigshot_debug
    if @TROUBADOURS_RALLY && Spell[1040].known?
      if webbed? || sleeping? || stunned? || frozen?
        cmd_1040(Char.name)
      end
      GameObj.pcs.each { |s|
        if s.status =~ /webbed|sleeping|stunned|frozen|immobilized|held in place|horrified|staggered/i && $grouplist.include?(s.noun)
          cmd_1040(s.noun)
          break
        end
      }
    end
  end

  def message(type = "info", text)
    # color options - set type to use
    # yellow, orange, teal, green, plain

    return if type == "debug" && !$bigshot_debug

    if text.class == Hash
      text = text.inspect.gsub("#<", "#")
    elsif text.class == Array
      text = text.to_s
    elsif text.class == String
      text = text.gsub("#<", "#")
    end

    Lich::Messaging.msg(type, text)
  end

  def dead_man_switch()
    echo "dead_man_switch" if $bigshot_debug
    if @DEAD_MAN_SWITCH && XMLData.game =~ /GSF/
      Thread.new {
        while (running?($current_script_name))
          if (dead? || percenthealth < 40)
            echo 'AUTOBOT ALERT: Your character is in trouble!'
            fput 'quit'
          end
          sleep(2)
        end
      };
    elsif @DEPART_SWITCH
      start_exec_script(<<-EOF
                while( running?($current_script_name) );
                    if(dead?);
                        stop_script($current_script_name);
                        fput 'depart'; fput 'depart';
                        fput 'depart confirm'; fput 'depart confirm';
                        start_script('waggle');
                        15.times { sleep(60); fput info; };
                        sleep(1) until percentspirit == 100 && !running?('waggle');
                        start_script( "#{$current_script_name}", ['solo'] );
                        Script.self.kill;
                    end;
                    sleep(5);
                end;
      EOF
                       );
    else
      Thread.new {
        loop { Script.self.kill if dead?; sleep(5); }
      }
    end
  end

  def keep_awake()
    echo "keep_awake" if $bigshot_debug
    Thread.new {
      while (running?($current_script_name))
        sleep(150); put 'look';
      end
    }
  end

  def monitor_interaction()
    echo "monitor_interaction" if $bigshot_debug
    if @MONITOR_INTERACTION
      start_exec_script(<<-eos
        watch_list = /#{@monitor_strings.gsub("||", "|")}/io
        safe_strings = /#{@monitor_safe_strings.gsub("||", "|")}/io

        def show_window(line)
          window_title = Char.name + ':' + line
          Gtk.queue do
            $myWindow = Gtk::Window.new
            $myWindow.title = "Autobot Alert!"
            $myWindow.set_size_request(450, 25)
            label = Gtk::Label.new window_title
            $myWindow.add(label)
            $myWindow.show_all
          end
        end

        while(line = get)
          break unless running?($current_script_name)
          if watch_list.match?(line) && !safe_strings.match?(line)
            show_window(line)
            echo "AUTOBOT ALERT: " + line
          end
        end
      eos
                       )
    end
  end

  def GameObjNpcCheck()
    npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| (npc.name =~ /animated/ && npc.name !~ /animated slush/) }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
    npcs.delete_if { |npc| npc.noun =~ /^(?:arm|appendage|claw|limb|pincer|tentacle)s?$|^(?:palpus|palpi)$/i }
    return npcs.size.to_i
  end

  def NPCRoomCheck()
    Thread.new {
      loop {
        $current_room_npcs = GameObj.npcs
        pause 0.5
      }
    }
  end

  def wrack()
    echo "wrack" if $bigshot_debug
    if Spell[9918].known? and not Spell[9012].active?
      Spell[9918].cast if checkspirit >= @WRACKING_SPIRIT
    elsif Spell[9718].known?
      (checkstamina / 50).times { Spell[9718].cast }
    elsif Spell[9813].known? && !Effects::Cooldowns.active?("Symbol of Mana")
      Spell[9813].cast
    end
  end

  def cur_bounty()
    return bounty?
  end

  def get_rallypoint()
    return @RALLYPOINT_ROOM_ID
  end

  def set_bandit_hunting(kill_bandits)
    # Need to circumvent anti-poach and protections some to hunt bandits
    $bigshot_bandits = kill_bandits
  end

  def change_stance(new_stance, force = true)
    return if Spell[216].active? || dead?

    perfect_stance = nil
    if new_stance =~ /10|20|30|40|50|60|70|80|90|100/i
      perfect_stance = new_stance
      new_stance = "advance" if perfect_stance =~ /10|20/i
      new_stance = "forward" if perfect_stance =~ /30|40/i
      new_stance = "neutral" if perfect_stance =~ /50|60/i
      new_stance = "guarded" if perfect_stance =~ /70|80/i
      new_stance = "defensive" if perfect_stance =~ /90|100/i
    end
    if (stance() =~ /#{new_stance}/)
      return
    elsif (checkcastrt() > 0 && new_stance =~ /def/)
      return if stance() == 'guarded'
    end

    if ((force) && (perfect_stance != nil) && (CMan.known?("Stance Perfection")))
      dothistimeout("cman stance #{perfect_stance}", 3, /You are now in an?|You move into an?|You fall back into a|Cast Roundtime in effect|You are unable to change/)
    elsif (force)
      dothistimeout("stance #{new_stance}", 3, /You are now in an?|You move into an?|You fall back into a|Cast Roundtime in effect|You are unable to change/)
    else
      fput "stance #{new_stance}"
    end
  end

  def wait_for_swing(seconds, target = nil)
    echo "wait_for_swing" if $bigshot_debug
    start = Time.now
    # swung = false
    $stop_wait = false
    $global_target = target.id
    $pcs = checkpcs ? ' you(\.|!|r? )|' + checkpcs.join('|') : 'you(\.|!|r? )'

    wait_for_swing_exec = <<-eos
        status_tags
        while line = get
            $stop_wait = true if line =~ /#{$global_target}.*#{$pcs}|The thorny barrier surrounding you blocks the attack from the .*#{$global_target}/ and line !~ /style id="".*style id="roomDesc"|(?:component|compDef) id='room objs'/
            break if $stop_wait
            break if !running?($current_script_name)
        end
        status_tags
    eos

    ExecScript.start(wait_for_swing_exec, :quiet => true)

    loop do
      change_stance('defensive', false) unless target && target.status =~ PRONE
      stand() if !standing?
      break if $stop_wait
      break if GameObj.targets.size.nil? || GameObjNpcCheck() == 0
      break if should_flee?
      break if target && target.status =~ PRONE
      break if (Time.now - start) > seconds

      sleep(0.25)
    end
  end

  def croak(message)
    echo "croak" if $bigshot_debug
    message("yellow", message);
    croak_scripts(["#{$current_script_name}"])
  end

  def run_script(name, pause_bigshot = false, args = [])
    echo "run_script" if $bigshot_debug
    if Script.running.find { |s| s.name.downcase == name.downcase }.paused or running? name
      stop_script name
      wait_while { running? name }
    end

    start_script name, args
    if pause_bigshot
      wait_until { !running? name }
    end
  end

  def run_scripts(scripts, pause_bigshot = false)
    echo "run_scripts" if $bigshot_debug
    scripts.each do |i|
      tokens = i.split(/\s+/)
      if (tokens.size > 1)
        run_script(tokens[0], pause_bigshot, tokens[1..-1])
      else
        run_script(tokens[0], pause_bigshot)
      end
    end
  end

  def croak_script(name)
    echo "croak_script" if $bigshot_debug
    # check for script name string with args
    name = name.split(/\s+/).first
    kill_script(name) if running?(name)
  end

  def croak_scripts(scripts)
    echo "croak_scripts" if $bigshot_debug
    scripts.each { |i| croak_script(i) }
  end

  def stand(stand_command = nil)
    echo "stand" if $bigshot_debug
    return if (stand_command =~ /^(?:fire|kneel|hide)/i && kneeling? && checkleft =~ /^(?:arbalest|kut'ziko|crossbow|kut'zikokra)$/)

    until (standing?)
      change_stance('defensive')
      bs_put 'stand'
    end
  end

  def groupcheck()
    echo "groupcheck" if $bigshot_debug
    checkgroupline = lambda { |line|
      line =~ /exist="\-[0-9]+" noun=".*">(.*)<\/a> is (?:following you|the leader of your group|also a member of your group)/i
      if !$1.nil?
        $grouplist.push($1)
      end
    }

    action = proc { |server_string|
      if checkgroupline.call(server_string) or server_string =~ /group status is currently|to set your group status|^.$|You are not currently in a group/m
        nil
      else
        server_string
      end
    }
    DownstreamHook.add('grouphook', action)
    $_SERVER_.puts "group"
    waitfor "group status is currently", "to set your group status", "You are not currently in a group"
    pause 0.5
    DownstreamHook.remove('grouphook')
    echo $grouplist if $bigshot_debug
  end

  def ma_looter
    return @MA_LOOTER
  end

  def lead(my_group = nil)
    echo "lead" if $bigshot_debug
    monitor_interaction()
    CompanionCheck()
    NPCRoomCheck()
    @followers = my_group || Group.new()
    if !checkpcs.nil?
      groupcheck()
    end

    # Set @MA_LOOTER to match the group member
    @MA_LOOTER = @MA_LOOTER.to_s.empty? ? Char.name : @followers.get_names.find { |name| name =~ /#{@MA_LOOTER}/i }

    if (should_rest? && !$bigshot_quick)
      rest()
    else
      hunt()
    end
  end

  def find_routine(target)
    echo "find_routine" if $bigshot_debug
    echo "@DISABLE_COMMANDS.size = #{@DISABLE_COMMANDS.size}" if $bigshot_debug
    if (!solo? && fried? && @DISABLE_COMMANDS.size > 0)
      return @DISABLE_COMMANDS
    else
      key = @TARGETS.keys.find { |k| target.name =~ /^#{k}$/i or target.noun =~ /^#{k}$/i }
      if key.nil?
        routine_letter = 'a'
      else
        routine_letter = @TARGETS[key]
      end

      if routine_letter == 'quick' || ($bigshot_quick && key.nil?)
        return @QUICK_COMMANDS unless @QUICK_COMMANDS.size == 0
      elsif routine_letter == 'j'
        return @HUNTING_COMMANDS_J unless @HUNTING_COMMANDS_J.size == 0
      elsif routine_letter == 'i'
        return @HUNTING_COMMANDS_I unless @HUNTING_COMMANDS_I.size == 0
      elsif routine_letter == 'h'
        return @HUNTING_COMMANDS_H unless @HUNTING_COMMANDS_H.size == 0
      elsif routine_letter == 'g'
        return @HUNTING_COMMANDS_G unless @HUNTING_COMMANDS_G.size == 0
      elsif routine_letter == 'f'
        return @HUNTING_COMMANDS_F unless @HUNTING_COMMANDS_F.size == 0
      elsif routine_letter == 'e'
        return @HUNTING_COMMANDS_E unless @HUNTING_COMMANDS_E.size == 0
      elsif routine_letter == 'd'
        return @HUNTING_COMMANDS_D unless @HUNTING_COMMANDS_D.size == 0
      elsif routine_letter == 'c'
        return @HUNTING_COMMANDS_C unless @HUNTING_COMMANDS_C.size == 0
      elsif routine_letter == 'b'
        return @HUNTING_COMMANDS_B unless @HUNTING_COMMANDS_B.size == 0
      end

      return @HUNTING_COMMANDS
    end
  end

  def solo?
    # tails wont have followers
    if (@followers && @followers.size == 0)
      return true
    else
      return false
    end
  end

  def leading?
    return !following?
  end

  def following?
    return @followers.nil?
  end

  def find_disk_names_in_room()
    player_disk_names = []
    room_disks = GameObj.loot.find_all { |obj| obj.noun == 'disk' }
    room_disks.each do |disk|
      disk_name_parts = disk.name.split
      player_name_index = disk_name_parts.rindex('disk') - 1
      player_disk_names.push(disk_name_parts[player_name_index])
    end
    return player_disk_names
  end

  def room_contains_disks_of_non_group_members()
    allowed_disk_names = $grouplist + [Char.name]
    return !(find_disk_names_in_room() - allowed_disk_names).empty?
  end

  def no_players()
    echo "no_players" if $bigshot_debug
    if ((checkpcs - $grouplist).count > 0)
      echo "no_players: checkpcs present" if $bigshot_debug
      return false
    elsif room_contains_disks_of_non_group_members()
      echo "no_players: Disk is present from someone not in group" if $bigshot_debug
      return false
    elsif $ambusher_here
      echo "no_players: Ambusher here" if $bigshot_debug
      return false
    elsif $obvious_hiding_player
      echo "no_players: Obvious Hiding Player here" if $bigshot_debug
      return false
    elsif $bigshot_room_claimed.length > 0
      echo "no_players: Room Claimed by #{$bigshot_room_claimed}" if $bigshot_debug
      return false
    else
      return true
    end
  end

  def no_players_hunt()
    echo "no_players_hunt" if $bigshot_debug
    return false if $ambusher_here
    return false if $obvious_hiding_player
    return false if $bigshot_room_claimed.length > 0
    return false if room_contains_disks_of_non_group_members()

    return true
  end

  def pre_hunt(manually_walking = false)
    echo "pre_hunt" if $bigshot_debug
    if (!solo? && leading?)
      @followers.group_assist(true)
    end
    # prep/go
    # print "\a" unless $bigshot_quick
    # print "\a" unless $bigshot_quick

    @followers.add_event(:HUNTING_PREP_COMMANDS)

    @HUNTING_PREP_COMMANDS.each { |i|
      if i =~ /^script\s+(.*?)(\s|$)(.*)/i
        cmd_run_script($1, $3)
      else
        fput(i)
        sleep(0.3)
      end
    }

    if (get_rallypoint() != -5 && !$bigshot_quick && !manually_walking)
      prepare_for_movement(false)
      goto(@RALLYPOINT_ROOM_ID, false)
      @followers.add_event(:FOLLOW_NOW) # trigger rubber band
      while (!@followers.all_present?)
        message("yellow", "Waiting for followers....")
        sleep(REST_INTERVAL / 5)
      end
    end

    prepare_for_movement()
    @followers.obv_hide_set(false)
    # @followers.add_event(:CAST_SIGNS)
    # cast_signs()

    @followers.add_event(:HUNTING_SCRIPTS_START)
    run_scripts(@HUNTING_SCRIPTS, false)

    # Start bigshot hunting monitor
    hunt_monitor("start")

    # If using rally point, do a manual "look" to grab current room description/objects/etc
    # Which allows hunt_monitor to pick up on things incase same room as @HUNTING_ROOM_ID
    # Such as obvious hiding players.
    fput "look" if (get_rallypoint() == @HUNTING_ROOM_ID && !$bigshot_quick && !manually_walking)

    # Sync charges of Swift Justice or other abilites for buff tracking.
    silence_me unless (undo_silence = silence_me)
    res = Lich::Util.quiet_command_xml("spell", /<output class="mono"\/>/, /<prompt time=/)
    silence_me if undo_silence
    $bigshot_swift_justice = $1.to_i if res.any? { |line| line =~ /You have stored (\d+) charges of Swift Justice./i }
    if !$bigshot_quick && !manually_walking
      goto(@HUNTING_ROOM_ID)
    end
    if (!solo? && leading?)
      @followers.add_event(:FOLLOW_NOW) # trigger rubber band
      while (!@followers.all_present?)
        message("yellow", "Waiting for followers....")
        sleep(REST_INTERVAL / 5)
      end
      GameObj.pcs.each { |s| if s.status =~ /kneeling|sitting|^lying|prone/ && s.status !~ /dead/; fput "pull #{s.noun}"; end; } if GameObj.targets.any? { |s| s.type =~ /aggressive npc/ } && @PULL

      if GameObj.pcs.any? { |s| s.status =~ /dead/ } && @DEADER
        puts "#{monsterbold_start} Found a deader! #{monsterbold_end}"
        echo "PAUSING SCRIPT"
        echo ";u bigshot"
        echo "TO CONTINUE"
        pause_script
      end

      @followers.add_event(:CAST_SIGNS)
      prepare_for_movement()
    end
    set_room_claimed([])
    cast_signs()
  end

  def do_hunt() # Finds target and calls attack block
    echo "do_hunt" if $bigshot_debug

    start_watch()
    message("yellow", 'Bigshot hunting')

    # loop
    target = nil
    just_arrived = true
    last_attack = 0
    reset_variables()
    target = bs_wander() if !$bigshot_quick

    while true

      while ((target = find_target(target, just_arrived)) && !should_rest? && no_players_hunt == true && !$bigshot_flee)
        echo "inside do_hunt loop | target: #{target}" if $bigshot_debug
        target = find_target(nil) if @PRIORITY && !priority(target)
        if ((Time.now.to_i - last_attack > 15) || just_arrived)
          @followers.add_event(:ATTACK)
          last_attack = Time.now.to_i
        end
        attack(target)
        just_arrived = false

      end

      if GameObj.npcs.find_all { |i| i.status =~ /dead|gone/ }
        $looting_inactive = false
        if @followers.get_names.find { |name| name =~ /#{@MA_LOOTER}/i } && @MA_LOOTER != Char.name && @followers.looter_present?
          @followers.first_member if $ambusher_here == false
          wait_while { @followers.roundtime? }
          sleep 1
        else
          loot() if $ambusher_here == false && $bigshot_room_claim.length == 0
        end
      end

      check_mind

      if @followers.get_names.find { |name| name =~ /#{@MA_LOOTER}/i } && @MA_LOOTER != Char.name && @followers.looter_present?
        while !@followers.looting_done
          echo "@followers.looting_done: #{@followers.looting_done}" if $bigshot_debug
          sleep 0.5
        end
      end

      $looting_inactive = true

      # prepare_for_movement()
      echo "Exiting attack loop" if $bigshot_debug
      # gather_ammo()#Not used since archery updates.

      if (should_rest?)
        break
      else
        target = bs_wander()
        just_arrived = true
      end
    end
  end

  # this is a leader method
  def hunt()
    echo "hunt" if $bigshot_debug
    pre_hunt()
    do_hunt()
    rest()
  end

  # this is a leader method
  def rest()
    # Stop bigshot hunting monitor
    hunt_monitor("stop")

    echo "rest" if $bigshot_debug
    message("yellow", " Bigshot resting: #{$rest_reason}")
    $bigshot_should_rest = nil
    if @BOUNTY_MODE && $rest_reason =~ /bounty complete/i # bounty script should take over from here
      message("yellow", " Bounty mode. Killing self. Reason: #{$rest_reason}")
      @BOUNTY_EVAL = ''
      exit
    end

    stop_watch()

    # prep/go
    prepare_for_movement()
    set_obvious_hiding_player(false)
    if (@FOG_RETURN.to_i != 0 && @FOG_OPTIONAL == false) || (@FOG_RETURN.to_i != 0 && @FOG_OPTIONAL == true && $rest_reason =~ /wounded|encumbered/)
      sleep(0.5)
      waitcastrt?
      waitrt?
      if @FOG_RETURN.to_i == 1
        if (Spell[130].known? && !Spell[130].affordable?)
          fput "mana pulse"
          sleep(0.2)
        end
        if (Spell[130].known? && Spell[130].affordable?)
          Spell[130].cast()
        elsif Spell[9825].known?
          sleep(0.5)
          waitcastrt?
          waitrt?
          fput "symbol of return"
        end
      elsif @FOG_RETURN.to_i == 2
        if Spell[9825].known?
          temproom = Room.current.id
          sleep(0.5)
          waitcastrt?
          waitrt?
          fput "symbol of return"
          sleep(0.5)
          if (Room.current.id == temproom && Spell[130].known?)
            waitrt?
            waitcastrt?
            fput "mana pulse" if !Spell[130].affordable?
            sleep(0.2)
            Spell[130].cast() if Spell[130].affordable?
          end
        end
      elsif @FOG_RETURN.to_i == 3
        if Spell[1020].known? && Spell[1020].affordable?
          Spell[1020].cast()
        end
      elsif @FOG_RETURN.to_i == 4
        if Spell[9720].known? && Spell[9720].affordable?
          Spell[9720].cast()
          sleep(0.5)
          waitcastrt?
          waitrt?
        end
      elsif @FOG_RETURN.to_i == 5
        if (Spell[930].known? && !Spell[930].affordable?)
          fput "mana pulse"
          sleep(0.2)
        end
        if (Spell[930].known? && Spell[930].affordable?)
          Spell[930].cast()
          fput "go portal"
          sleep(0.5)
          waitcastrt?
          waitrt?
        end
      end
    end

    # resetting overkill counter
    $bigshot_overkill_counter = 0

    # resetting lte_boost counter
    $bigshot_lte_boost_counter = 0

    @followers.add_event(:HUNTING_SCRIPTS_STOP)
    croak_scripts(@HUNTING_SCRIPTS)

    goto(@RESTING_ROOM_ID)
    if (@QUIET_FOLLOWERS)
      @followers.add_event(:STAY_QUIET)
    else
      @followers.add_event(:FOLLOW_NOW)
    end
    while (!@followers.all_present?)
      message("yellow", " Waiting for followers....")
      sleep(REST_INTERVAL / 5)
    end
    # Stops followers from doing things like using waggle while the leader is selling loot.

    @followers.add_event(:RESTING_PREP_COMMANDS)
    @RESTING_COMMANDS.each { |i|
      fput(i)
      sleep(0.3)
    }

    @followers.add_event(:RESTING_SCRIPTS_START)
    run_scripts(@RESTING_SCRIPTS, true)

    if ($rest_reason =~ /No blessing on weapon|Ammo had no effect \(need blessed or magical\)/i)
      message("yellow", "Need a blessing on weapon to continue hunting")
      Script.self.kill
    end

    if (!solo? && leading?)
      @followers.group_assist(true)
    end

    if $bigshot_single
      message("yellow", " Single Bigshot loop complete")
      Script.self.kill
    end

    # loop
    until (should_hunt?)
      @followers.add_event(:DISPLAY_WATCH)
      fput 'exp'
      display_watch()
      display_items_for_blessing()
      message("yellow", "Bigshot last rested because: #{$rest_reason}") if $rest_reason
      message("yellow", "Bigshot isn't hunting because: #{$not_hunting_reason}") if $not_hunting_reason
      sleep(REST_INTERVAL)
    end

    hunt() if !$bigshot_bandits
  end

  def attack(target) # Starts the process when a target is found
    echo "attack" if $bigshot_debug
    commands = find_routine(target)
    echo "Inside attack(target) #{commands}" if $bigshot_debug

    if XMLData.current_target_id != target.id
      bs_put "target ##{target.id}" if target.status !~ /dead|gone/
    end

    commands.each do |i|
      break unless valid_target?(target)
      break if wounded? || $bigshot_should_rest
      break if $ambusher_here
      break if $obvious_hiding_player

      temp_var = !GameObj.targets.any? { |s| s.id == target.id }
      break if target.status =~ /dead|gone/ || temp_var
      break if should_flee?
      break if should_rest?
      break if !($bigshot_bandits) && @PRIORITY && !priority(target)

      group_status_ailments() if @TROUBADOURS_RALLY && Spell[1040].known?
      stand(i) if !standing?
      cast_signs()

      echo "reaction_check" if $bigshot_debug
      echo "| #{$bigshot_reaction}" if $bigshot_debug
      echo "| #{@WEAPON_REACTION}" if $bigshot_debug
      perform_reaction if ($bigshot_reaction != nil) && @WEAPON_REACTION
      cmd(i, target)
    end

    # if its dead lets loot it!
    if target.status =~ /dead|gone/
      $looting_inactive = false
      check_mind
      if @MA_LOOTER == Char.name
        loot() if $ambusher_here == false
      end
    end

    echo "commands.size = #{commands.size}" if $bigshot_debug
    # sleep(1) if commands.size == 0
  end

  def goto(id, cast_signs_moving = true)
    echo "goto" if $bigshot_debug
    prepare_for_movement(cast_signs_moving)
    set_obvious_hiding_player(false)
    until (Room.current.id == id)
      run_script('go2', true, [id, '_disable_confirm_'])
    end
  end

  def start_watch()
    echo "start_watch" if $bigshot_debug
    @START_TIME = Time.now.to_i
  end

  def stop_watch()
    echo "stop_watch" if $bigshot_debug
    if (@START_TIME > 100)
      @STORED_TIMES.push(Time.now.to_i - @START_TIME)
    end
    @START_TIME = 0
  end

  def display_watch()
    echo "display_watch" if $bigshot_debug

    # current
    if (@STORED_TIMES.size > 0)
      seconds = @STORED_TIMES[-1]
      message("yellow", sprintf("Bigshot: Last Hunt: %d min. %0.2f secs.", seconds / 60, seconds % 60))
    end

    # average
    average = 0
    if (@STORED_TIMES.size == 1)
      average = @STORED_TIMES[0]
      message("yellow", sprintf("Bigshot: Average Hunt: %d min. %0.2f secs.", average / 60, average % 60))
    elsif (@STORED_TIMES.size > 1)
      @STORED_TIMES.each { |i| average += i }
      average /= @STORED_TIMES.size
      message("yellow", sprintf("Bigshot: Average Hunt: %d min. %0.2f secs.", average / 60, average % 60))
    end

    # total
    total = Time.now.to_i - @BIRTH_TIME
    message("yellow", sprintf("Bigshot: Total Time Running: %d min.  %0.2f secs.", total / 60, total % 60))
  end

  def display_items_for_blessing()
    echo "display_items_for_blessing" if $bigshot_debug
    $bigshot_bless = $bigshot_bless - ["", nil]
    bless_bundles = false
    if $bigshot_bless.count > 0
      message("yellow", "Bigshot: The following items should be blessed before next hunt")
      $bigshot_bless.each { |id|
        noun = GameObj.inv.find { |obj| obj.id == "#{id}" }
        if noun.nil? or noun.empty?
          bless_bundles = true
        else
          message("yellow", "Bigshot: #{noun}")
        end
      }
      message("yellow", "Bigshot: arrows or other bundled weapon-type") if bless_bundles
    end
    bless_bundles = false
  end

  def room_id()
    echo "room_id" if $bigshot_debug
    return Room.current.id()
  end

  def name()
    return Char.name
  end

  def poaching?()
    echo "poaching?" if $bigshot_debug
    if ($bigshot_quick && $grouplist.size > 0)
      return false
    elsif (leading?)
      message("yellow", "Obvious hiding player present") if $obvious_hiding_player
      return true if $obvious_hiding_player

      (checkpcs - $grouplist).each { |i| return true unless @followers.get_names.include?(i) }
      if solo? && !$bigshot_quick
        message("yellow", "Obvious hiding player present") if $obvious_hiding_player
        return true if $obvious_hiding_player

        GameObj.npcs.each { |i| return true if i.type =~ /companion/ && i.name !~ /#{$companion}/i }
        GameObj.npcs.each { |i| return true if i.type =~ /familiar/ && i.name !~ /#{$familiar}/i }
      end
      return true if $bigshot_room_claimed.length > 0

      return false
    else
      return false
    end
  end

  def perform_reaction()
    echo "performing weapon reaction" if $bigshot_debug

    fput "weapon #{$bigshot_reaction}"
    $bigshot_reaction = nil
  end

  def get_grouplist()
    return $grouplist
  end

  def should_flee?(just_entered = false)
    echo "should_flee" if $bigshot_debug
    return false if $bigshot_quick
    return false if $bigshot_bandits
    return true if $bigshot_flee

    GameObj.loot.each { |i| return true if i.noun =~ /cloud|breath/ } if @FLEE_CLOUDS
    GameObj.loot.each { |i| return true if i.name == 'intense shimmering circle' } if @FLEE_CLOUDS
    GameObj.loot.each { |i| return true if i.noun =~ /vine/ } if @FLEE_VINES
    GameObj.loot.each { |i| return true if i.noun =~ /web/ } if @FLEE_WEBS
    GameObj.loot.each { |i| return true if i.name =~ /black void/ } if @FLEE_VOIDS
    return true if GameObj.npcs.any?  { |i| @ALWAYS_FLEE_FROM.include?(i.noun) or @ALWAYS_FLEE_FROM.include?(i.name) }
    return true if checkpcs.any?      { |i| @ALWAYS_FLEE_FROM.include?(i) }
    return true if GameObj.targets.any? { |i| i.type =~ /boon/ } && @BOON_FLEE_FROM
    return true if !leading? && checkpcs.empty?

    npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| (@INVALID_TARGETS.include?(npc.name) or @INVALID_TARGETS.include?(npc.noun)) }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
    npcs.delete_if { |npc| npc.noun =~ /^(?:arm|appendage|claw|limb|pincer|tentacle)s?$|^(?:palpus|palpi)$/i }
    npcs.delete_if { |npc| npc.noun =~ /^(?:grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i }
    npcs.delete_if { |npc| ['quickly growing troll king', 'severed troll arm', 'severed troll leg'].include?(npc.name) }
    npcs.delete_if { |npc| npc.type =~ /companion|familiar/i && npc.type !~ /aggressive npc/i }

    flee_count = (just_entered && @LONE_TARGETS_ONLY) ? 1 : @FLEE_COUNT
    if npcs.size > flee_count
      return true
    end
  end

  def valid_target?(target, just_entered = false)
    echo "valid_target? (given #{target})" if $bigshot_debug
    echo "return false if target == nil #{target == nil} || target == false #{target == false}" if $bigshot_debug
    return false if target == nil || target == false

    echo "return false if should_flee?(just_entered) #{should_flee?(just_entered)}" if $bigshot_debug
    return false if should_flee?(just_entered)

    echo " return false if just_entered #{just_entered} && poaching? #{poaching?}" if $bigshot_debug
    return false if just_entered && poaching?

    echo " return false if $bigshot_room_claimed.length #{$bigshot_room_claimed.length} > 0" if $bigshot_debug
    return false if $bigshot_room_claimed.length > 0

    echo " false if target.noun.... (not last one)" if $bigshot_debug
    return false if target.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && target.name !~ /ethereal|celestial|unworldly/i

    echo " false if target.name =~ /animated/ #{target.name =~ /animated/}" if $bigshot_debug
    if (target.name =~ /animated/ && target.name !~ /animated slush/)
      CharSettings['untargetable'].push(target.name) if target.status !~ /dead|gone/
      return false
    end
    if (!CharSettings['targetable'].include?(target.name) && !CharSettings['untargetable'].include?(target.name) && target.status !~ /dead|gone/)
      result = dothistimeout("target ##{target.id}", 3, /^You are now targeting|^You can't target/)
      if (result =~ /^You are now targeting/)
        CharSettings['targetable'].push(target.name) if target.status !~ /dead|gone/
      elsif (result =~ /^You can't target/)
        CharSettings['untargetable'].push(target.name) if target.status !~ /dead|gone/
      end
    end
    echo "return false if CharSettings['untargetable'].include?(target.name)  #{CharSettings['untargetable'].include?(target.name)}" if $bigshot_debug
    return false if CharSettings['untargetable'].include?(target.name)

    echo "return false if (target.status =~ /dead|gone/)  #{(target.status =~ /dead|gone/)}" if $bigshot_debug
    return false if (target.status =~ /dead|gone/)

    temp_var = !GameObj.targets.any? { |n| n.id == target.id } # Exists solely for debug printout
    echo "!GameObj.targets.any? { |n| n.id == target.id }  #{temp_var}" if $bigshot_debug
    return false if temp_var

    if (@TARGETS.nil? or @TARGETS.keys.any? { |i| target.name =~ /#{i}/i or target.noun =~ /#{i}/i })
      echo "returning true from valid_target for #{target.name}" if $bigshot_debug
      return true
    else
      echo "Returning valid_target == false for #{target.name}" if $bigshot_debug
      return false
    end
  end

  def sort_npcs()
    echo "sort_npcs" if $bigshot_debug
    if $bigshot_quick || $bigshot_bandits
      targets = Hash.new
      tokens = []
      if @QUICKHUNT_TARGETS.nil?
        @QUICKHUNT_TARGETS = Hash.new
      end
      npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
      npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
      npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
      if ($bigshot_bandits)
        npcs.delete_if { |npc| npc.noun !~ /thief|rogue|bandit|mugger|outlaw|highwayman|marauder|brigand|thug|robber/i && npc.name !~ /ethereal|celestial|unworldly/i }
      end
      npcs.each { |i| tokens.push(i.name) }

      tokens.uniq.each { |i|
        targets[i] = "quick" if @QUICKHUNT_TARGETS.empty?
      }

      if @TARGETS.nil?
        @TARGETS = Hash.new
      end

      @TARGETS.replace(@QUICKHUNT_TARGETS)
      @TARGETS.merge!(targets)
      targets = @TARGETS

    else
      targets = @TARGETS
    end

    npcs = GameObj.targets
    sorted = Array.new
    targets.keys.each { |target| sorted += npcs.find_all { |npc| (npc.name =~ /^#{target}$/i or npc.noun =~ /^#{target}$/i) }.to_a }
    sorted.flatten
  end

  def priority(target)
    echo "priority" if $bigshot_debug
    return true if (!$current_room_npcs.zip($room_npcs_last_check).map { |x, y| x.id == y.id }.any? { |s| s == false })

    $room_npcs_last_check = GameObj.npcs
    priority = false
    stoppriority = false
    npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
    @TARGETS.keys.each { |t|
      break if stoppriority == true

      npcs.each { |s|
        break if stoppriority == true

        if (s.name =~ /#{t}/i or s.noun =~ /#{t}/i)
          if s.name == target.name
            stoppriority = true
            priority = true
          else
            stoppriority = true
          end
        end
      }
    }
    return priority
  end

  def find_target(target, just_entered = false)
    echo "find_target: #{target} | valid_target?(target, just_entered): #{valid_target?(target, just_entered)}" if $bigshot_debug
    return target if valid_target?(target, just_entered)

    if @PRIORITY && !$bigshot_bandits
      echo "@PRIORITY: #{@PRIORITY} && !$bigshot_bandits" if $bigshot_debug
      sort_npcs.each { |i| return i if valid_target?(i, just_entered) && priority(i) }
    else
      sort_npcs.each { |i| return i if valid_target?(i, just_entered) }
    end
    echo "\n\n\nfind target returning nil\n\n\n" if $bigshot_debug
    return nil
  end

  def rt?()
    echo "rt?" if $bigshot_debug
    return checkrt()
  end

  def fried?()
    if $bigshot_quick || @FRIED > 100
      return false
    elsif (@CORRECT_PERCENT_MIND >= @FRIED)
      return true
    else
      return false
    end
  end

  def oom?()
    if (percentmana() < @OOM)
      return true
    else
      return false
    end
  end

  def saturated?()
    if checkmind =~ /saturated/
      return true
    else
      return false
    end
  end

  def overkill?()
    if ($bigshot_overkill_counter >= @OVERKILL && lte_boost?)
      return true
    else
      return false
    end
  end

  def set_help_group(keep_attacking)
    @HELP_GROUP_KILL = keep_attacking
  end

  def lte_boost?()
    if ($bigshot_lte_boost_counter >= @LTE_BOOST)
      return true
    else
      return false
    end
  end

  def use_lte_boost()
    if (fried? && !lte_boost?) # Need the check because of the race condition caused if you are a follower in RT when called
      boost_attempt = dothistimeout "boost longterm", 3, /You do not have any Long-Term Experience Boosts to redeem.|You have deducted 500 experience points from your field experience/
      if boost_attempt =~ /You do not have any Long-Term Experience Boosts to redeem./
        message("yellow", "No more LTE boosts available - Skipping")
        $bigshot_lte_boost_counter = @LTE_BOOST
        add_overkill()
      elsif boost_attempt =~ /You have deducted 500 experience points from your field experience/
        $bigshot_lte_boost_counter += 1
        message("yellow", "Used LTE Boost: #{$bigshot_lte_boost_counter} of #{@LTE_BOOST}")
        $bigshot_overkill_counter = 0
      end
    end
  end

  def check_mind
    lines = Lich::Util.quiet_command_xml("experience", /<output class="mono"\/>/)
    # actual_percent = nil
    if lines.any? { |l| l =~ /Field Exp\:\s*([0-9,]+)\/([0-9,]+)/i }
      in_bucket = $1.delete(",").to_f
      max_bucket = $2.delete(",").to_f
    end

    actual_percent = (in_bucket / max_bucket) * 100
    echo "in_bucket: #{in_bucket} max_bucket: #{max_bucket} actual_percent: #{actual_percent}" if $bigshot_debug
    if actual_percent.nil?
      @CORRECT_PERCENT_MIND = percentmind()
    else
      @CORRECT_PERCENT_MIND = actual_percent
    end

    return @CORRECT_PERCENT_MIND
  end

  def ammo_on_ground(ammo)
    echo "ammo_on_ground" if $bigshot_debug
    return GameObj.loot.find { |i| i.name =~ /\b#{ammo}s?\b/i or i.noun =~ /^#{ammo}s?$/i }
  end

  def gather_ammo()
    echo "gather_ammo" if $bigshot_debug
    ammo = @AMMO
    container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
    hide = @HIDE_FOR_AMMO

    return if wounded?

    if ammo.nil? or ammo.empty?
      return
    end

    if ammo =~ /\b(arrow|bolt|dart)\b/i
      ammo_noun = $1
    else
      echo "failed to gather: invalid ammo type specified (use the full name)"
    end

    if container.nil?
      echo "failed to gather: you must specify an ammo container to use this feature"
      return
    end

    while (ammo_on_ground(ammo_noun))
      change_stance('defensive')

      unless GameObj.right_hand.id.nil?
        line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
      end

      result = dothistimeout("gather #{ammo_noun}", 2, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/)

      if (result =~ /on the ground/)
        result = dothistimeout "get #{ammo_noun}s", 3, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/
      end

      if (result =~ /^You gather|^You pick up/)
        dothistimeout("put my #{ammo_noun} in my #{ammo_noun}s in my #{container.noun}", 2, /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/)
        bs_put "put my #{ammo_noun} in my ##{container.id}" if righthand?
      elsif (result =~ /You may only/)
        return
      elsif (result == false || result =~ /^I could not find|^What were you/)
        return
      elsif (result =~ /reach/)
        bs_put 'hide' if hide and not hidden?
        sleep(4)
      end
    end
  end

  def reset_variables()
    echo "reset_variables" if $bigshot_debug
    $ambusher_here = false
    $bigshot_smite_list = []
    $bigshot_aim = 0
    $bigshot_ambush = 0
    $bigshot_archery_aim = 0
    $bigshot_archery_stuck_location = []
    $bigshot_dislodge_location = []
    $bigshot_unarmed_tier = 1
    $bigshot_unarmed_followup = false
    $bigshot_unarmed_followup_attack = ""
    $bigshot_703_list = []
    $bigshot_1614_list = []
    $bigshot_reaction = nil
  end

  def wounded?()
    echo "wounded?" if $bigshot_debug
    if $bigshot_quick
      return false
    elsif (@WOUNDED_EVAL)
      return eval @WOUNDED_EVAL
    else
      return false
    end
  end

  def creaping_dread?
    Effects::Debuffs.to_h.keys.map(&:to_s).find { |k| k.include? "Creeping Dread" }.match(/\((\d+)\)/)[1].to_i
    counter = $1.to_i
    if counter >= @CREEPING_DREAD && @CREEPING_DREAD > 0
      return true
    end

    return false
  end

  def crushing_dread?
    Effects::Debuffs.to_h.keys.map(&:to_s).find { |k| k.include? "Crushing Dread" }.match(/\((\d+)\)/)[1].to_i
    counter = $1.to_i
    if counter >= @CRUSHING_DREAD && @CRUSHING_DREAD > 0
      return true
    end

    return false
  end

  def wot_poison?
    poisoned = false
    if Effects::Debuffs.active?("Wall of Thorns Poison 1") || Effects::Debuffs.active?("Wall of Thorns Poison 2") || Effects::Debuffs.active?("Wall of Thorns Poison 3") || Effects::Debuffs.active?("Wall of Thorns Poison 4") || Effects::Debuffs.active?("Wall of Thorns Poison 5")
      poisoned = true
    end

    if poisoned && @WOT_POISON == true
      return true
    end

    return false
  end

  def bounty_check?()
    echo "bounty_check? @BOUNTY_MODE = #{@BOUNTY_MODE} | @BOUNTY_EVAL = #{@BOUNTY_EVAL}" if $bigshot_debug
    return false unless @BOUNTY_MODE

    if @BOUNTY_EVAL.to_s.empty?
      Lich::Messaging.msg('error', " Bigshot is running in bounty mode and bounty_eval is empty. Exiting...")
      exit
    end

    result = eval(@BOUNTY_EVAL)
    echo "bounty_check? after result: #{result}" if $bigshot_debug
    return result
  end

  def should_hunt?()
    echo "should_hunt?" if $bigshot_debug

    if @BOUNTY_MODE && (bounty_check?)
      echo "should_hunt? @BOUNTY_MODE = #{@BOUNTY_MODE} | bounty_check? = #{bounty_check?}" if $bigshot_debug
      message("yellow", " Bounty mode. Killing self. Reason: Bounty available or complete.")
      @BOUNTY_EVAL = ''
      $bigshot_status = :rest_stop
      exit
    end

    if (wounded?)
      $not_hunting_reason = 'wounded.'
      return false
    elsif (percentencumbrance >= @ENCUMBERED)
      $not_hunting_reason = 'encumbered.'
      return false
    elsif (creaping_dread?)
      $not_hunting_reason = 'creaping dread active.'
      return false
    elsif (crushing_dread?)
      $not_hunting_reason = 'crushing dread active.'
      return false
    elsif Effects::Debuffs.active?("Confusion") && @CONFUSION == true
      $not_hunting_reason = 'confusion debuff active.'
      return false
    elsif (wot_poison?)
      $not_hunting_reason = 'wall of thorns poison active.'
      return false
    elsif (@RESTING_SCRIPTS.any? { |i| running?(i) })
      $not_hunting_reason = 'resting scripts still running.'
      return false
    end

    check_mind

    followers_should = (leading? && !solo?) ? @followers.should_hunt? : true
    if (followers_should)
      if (@CORRECT_PERCENT_MIND > @REST_TILL_EXP)
        $not_hunting_reason = 'mind still above threshold.'
        return false
      elsif (percentmana() < @REST_TILL_MANA)
        $not_hunting_reason = 'mana still below threshold.'
        return false
      elsif (checkspirit() < @REST_TILL_SPIRIT)
        $not_hunting_reason = 'spirit still below threshold.'
        return false
      end
    else
      $not_hunting_reason = 'followers still need rest.'
      return false
    end
    $bigshot_status = :hunting

    return true
  end

  def should_rest?()
    echo "should_rest?" if $bigshot_debug
    if ($bigshot_quick)
      return false
    elsif @BOUNTY_MODE && $bigshot_should_rest
      $rest_reason = "bounty complete."
      $bigshot_status = :resting
      @BOUNTY_EVAL = ''
      return true
    elsif ($bigshot_should_rest)
      $rest_reason = "$bigshot_should_rest was set to true." unless $rest_reason
      $bigshot_status = :resting
      return true
    elsif (wounded?)
      $rest_reason = "wounded."
      $bigshot_status = :resting
      return true
    elsif (percentencumbrance >= @ENCUMBERED)
      $rest_reason = "encumbered."
      $bigshot_status = :resting
      return true
    elsif (creaping_dread?)
      $rest_reason = "creaping dread limit."
      $bigshot_status = :resting
      return true
    elsif (crushing_dread?)
      $rest_reason = "crushing dread limit."
      $bigshot_status = :resting
      return true
    elsif (wot_poison?)
      $rest_reason = "wall of thorns poison."
      $bigshot_status = :resting
      return true
    elsif @CONFUSION == true && Effects::Debuffs.active?("Confusion")
      $rest_reason = "confusion debuff."
      $bigshot_status = :resting
      return true
    elsif (leading? && !solo? && @followers.emergency_rest?)
      $rest_reason = "emergency rest."
      $bigshot_status = :resting
      return true
    elsif (!solo? && !leading? && @HELP_GROUP_KILL)
      return false if !oom?
    end

    if (leading? && !solo? && fried? && overkill? && lte_boost?)
      @followers.group_assist(false)
    end

    followers_fried = (leading? && !solo?) ? (@followers.should_rest? && overkill? && lte_boost?) : true

    if (followers_fried)
      if (fried? && overkill? && lte_boost?)
        $rest_reason = "fried."
        $bigshot_status = :resting
        return true
      elsif (oom?)
        wrack() if @USE_WRACKING
        return false if !oom?

        $rest_reason = "out of mana."
        $bigshot_status = :resting
        return true
      end
    end

    $rest_reason = "none."
    if (!solo? && leading?)
      @followers.group_assist(true)
    end
    return false
  end

  def add_overkill()
    if (fried? && lte_boost?)
      $bigshot_overkill_counter += 1
      message("yellow", "Extra Kills currently at: #{$bigshot_overkill_counter} of #{@OVERKILL}") unless @OVERKILL == 0
    end

    if (!solo? && leading?)
      @followers.add_event(:FOLLOWER_OVERKILL)
    end
  end

  def bard_renewal()
    $bard_renewal_cost ||= 0
    $bard_renewal_check ||= (Time.now - 61)
    if Char.prof == "Bard" && (Time.now - $bard_renewal_check).to_i > 60
      song_renewal_cost = Lich::Util.quiet_command_xml("song status", /currently singing:|not singing/, /<prompt time=/)
      if song_renewal_cost.any? { |line| line =~ /Your current renewal cost is (\d+) mana./i }
        $bard_renewal_cost = $1.to_i
      end
      $bard_renewal_check = Time.now
    end
    return $bard_renewal_cost
  end

  def cast_signs(single_cast = false)
    echo "cast_signs?" if $bigshot_debug

    @SIGNS.each do |i|
      if i =~ /\b650\s?(\w+)?\s?(\w+)?\s?/
        cmd_assume($1.to_s, $2.to_s)
        next
      end
      i = i.to_i
      next if [9903, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9912, 9913, 9914, 9918].include?(i) and Spell[9012].active?
      next if i == 9918
      next if (i == 9605 && Effects::Cooldowns.active?("Surge of Strength"))
      next if (i == 320 && Effects::Cooldowns.active?("Ethereal Censer"))
      next if (i == 605 && Effects::Cooldowns.active?("Barkskin"))
      next if (i == 9625 && Effects::Cooldowns.active?("Burst of Swiftness"))
      next if (i == 1035 && Effects::Buffs.active?("Song of Tonis"))

      if i == 9605
        next if (!CMan.known?("Surge of Strength") || Effects::Debuffs.active?("Overexerted"))

        waitrt?
        waitcastrt?
        if (checkstamina >= 30)
          result = dothistimeout("cman surge", 1, /You feel a great deal stronger.|untapped sources of strength|still recent prior attempt|come from your muscles|ache much too badly/i)
          if (result == false)
            $bigshot_should_rest = true
            $rest_reason = "Unknown result from surge routine: #{result}"
          end
          sleep 0.5
        end
        next
      end
      if i == 9625
        next if (!CMan.known?("Burst of Swiftness") || Effects::Debuffs.active?("Overexerted"))

        waitrt?
        waitcastrt?
        if (checkstamina >= 30)
          result = dothistimeout("cman burst", 1, /You prepare yourself to move swiftly at a moment's notice|ache much too badly/i)
          if (result == false)
            $bigshot_should_rest = true
            $rest_reason = "Unknown result from burst routine: #{result}"
          end
          sleep 0.5
        end
        next
      end
      if i == 909
        Spell[909].force_channel if (Spell[909].known? && Spell[909].affordable? && !Spell[909].active?)
        next
      end

      sign = Spell[i]
      next unless sign.known?
      next if [140, 211, 215, 219, 240, 919, 1619, 1650].include?(sign.num) && Effects::Cooldowns.active?(sign.name)

      # wrack?
      mana_cost = sign.mana_cost > 1 ? sign.mana_cost : 0 # Many erroneously return 1
      wrack() if !sign.affordable? and mana_cost > checkmana and @USE_WRACKING

      if (!sign.active? && sign.affordable? && checkmana(bard_renewal + sign.mana_cost))
        loop do
          result = sign.cast
          break if (result !~ /Spell Hindrance/ || !sign.affordable? || !checkmana(bard_renewal + sign.mana_cost) || dead? || result =~ /You feel more courageous/)
        end
        break if single_cast
      end
    end
  end

  def looting_inactive?
    return $looting_inactive
  end

  def loot()
    echo "loot" if $bigshot_debug
    waitrt?
    if checkroom("Duskruin Arena, Dueling Sands").nil?
      dead_npcs = GameObj.npcs.find_all { |i| i.status == 'dead' && i.type !~ /escort/i }
      reset_variables() if !dead_npcs.nil? && dead_npcs != []
      if @DELAY_LOOT && sort_npcs.any? { |s| valid_target?(s) } && (!dead_npcs.nil? && dead_npcs != []) && !should_flee?
        if $last_loot.nil?
          $last_loot = Time.now + 15
        elsif $last_loot <= Time.now
          $looting_inactive = false
          dead_npcs.each { |i|
            $last_loot = nil
            use_lte_boost()
            add_overkill()
            change_stance('defensive') if GameObjNpcCheck() > 0 && @LOOT_STANCE

            if (@LOOT_SCRIPT)
              run_script(@LOOT_SCRIPT, true)
            else
              bs_put "loot ##{i.id}"
              bs_put "loot room"
            end

            break unless GameObj.npcs.any? { |npc| npc.status == 'dead' && npc.type !~ /escort/i }
          }
          $looting_inactive = true
        end
      else
        $looting_inactive = false
        dead_npcs.each { |i|
          $last_loot = nil
          use_lte_boost()
          add_overkill()
          change_stance('defensive') if GameObjNpcCheck() > 0 && @LOOT_STANCE

          if (@LOOT_SCRIPT)
            run_script(@LOOT_SCRIPT, true)
          else
            bs_put "loot ##{i.id}"
            bs_put "loot room"

          end

          break unless GameObj.npcs.any? { |npc| npc.status == 'dead' && npc.type !~ /escort/i }
        }

      end

      if @BOUNTY_MODE && (bounty_check?)
        $bigshot_should_rest = true
      end

    end

    $looting_inactive = true
  end

  def check_room_claimed(player_present)
    if $bigshot_room_claimed.length > 0
      $bigshot_room_claimed.each { |player|
        if player =~ /#{player_present}/
          Lich::Messaging.msg("info", "Removing claim: #{player_present}") && UserVars.show_claim
          $bigshot_room_claimed.delete(player)
          break
        end
      }
    end
  end

  def set_room_claimed(claimed)
    $bigshot_room_claimed = claimed

    if $bigshot_quick
      $bigshot_room_claimed = []
      return
    end

    # check our buffer to see if someone was "Also here"
    buffer_one = reget(50, /^Also here:/, /^Obvious (?:exits|paths)/, /obvious signs of someone hiding/)
    if buffer_one[-2] =~ /^Also here: (.*)/
      $bigshot_room_claimed = $1.gsub("\r", "").split(",")
    elsif buffer_one[-2] =~ /obvious signs of someone hiding/
      $bigshot_room_claimed.push("hidden")
    else
      sleep(0.1)
      buffer_two = reget(20, /^Also here:/, /^Obvious (?:exits|paths)/, /obvious signs of someone hiding/)
      if buffer_two[-2] =~ /^Also here: (.*)/
        $bigshot_room_claimed = $1.gsub("\r", "").split(",")
      elsif buffer_two[-2] =~ /obvious signs of someone hiding/
        $bigshot_room_claimed.push("hidden")
      end
    end

    # remove any group members that made it on the list. needed for bigshot quick
    $bigshot_room_claimed = ($bigshot_room_claimed - $grouplist)

    # echo room claim status
    unless $bigshot_room_claimed.empty? || !UserVars.show_claim
      Lich::Messaging.msg("info", "Claimed: #{$bigshot_room_claimed.to_s.gsub(/\[|\]|\"/, "")}")
    end
  end

  def set_obvious_hiding_player(player_present)
    $obvious_hiding_player = player_present
    if !solo? && leading?
      @followers.obv_hide_set(player_present)
    end
  end

  def get_obvious_hiding_player_status()
    return $obvious_hiding_player
  end

  def prepare_for_movement(move_signs = true)
    echo "prepare_for_movement" if $bigshot_debug
    echo "move_signs is #{move_signs}" if $bigshot_debug
    reset_variables()
    change_stance('defensive')

    if (leading? && !solo?)
      @followers.add_event(:PREP_REST) if move_signs
      @followers.add_event(:FOLLOW_NOW) if !move_signs
      wait_while { @followers.roundtime? }
      sleep(0.3)
    end
    cmd_bless() if @BLESS && $bigshot_bless.count > 0
    cast_signs if move_signs
  end

  def bs_wander()
    echo "bs_wander" if $bigshot_debug
    $wander_rooms    ||= Array.new

    wander = proc {
      room = Room.current
      next_room_options = room.wayto.keys - @HUNTING_BOUNDARIES
      next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
      next_room = next_room_options.find_all { |r| not $wander_rooms.include?(r) }
      if next_room.empty?
        next_room = $wander_rooms.find { |r| next_room_options.include?(r) }
      else
        next_room = next_room[rand(next_room.length)]
      end
      $wander_rooms.delete(next_room)
      $wander_rooms.push(next_room)
      way = room.wayto[next_room]
      if way.class == String
        move(way)
      else
        way.call
      end
      set_room_claimed([])
      GameObj.pcs.each { |s| if s.status =~ /kneeling|sitting|^lying|prone/ && s.status !~ /dead/; fput "pull #{s.noun}"; end; } if GameObj.targets.any? { |s| s.type =~ /aggressive npc/ } && @PULL
      if GameObj.pcs.any? { |s| s.status =~ /dead/ } && @DEADER
        puts "#{monsterbold_start} Found a deader! #{monsterbold_end}"
        echo "PAUSING SCRIPT"
        echo ";u bigshot"
        echo "TO CONTINUE"
        pause_script
      end
      cast_signs(true)
    }

    while true # wander, check for players
      prepare_for_movement()
      exit if $bigshot_quick
      npcs = GameObj.targets
      npcs.delete_if { |npc| (npc.status =~ /dead|gone/) }
      sort_npcs.each { |i| return i if valid_target?(i, true) and no_players == true and (GameObjNpcCheck() > 0) }
      return if should_rest?

      pause @WANDER_WAIT unless should_flee?(true)

      unless should_flee?(true) || !$bigshot_room_claimed.empty?
        npcs = GameObj.targets
        npcs.delete_if { |npc| (npc.status =~ /dead|gone/) }
        sort_npcs.each { |i| return i if valid_target?(i, false) and no_players_hunt == true and (GameObjNpcCheck() > 0) }
      end

      set_obvious_hiding_player(false)
      wander.call
      sleep(0.1)
      $bigshot_flee = false
    end
  end

  def CompanionCheck()
    if (Char.prof =~ /Ranger/i && Spell[630].known? && GameObj.npcs.any? { |i| i.type =~ /companion/ } && $companion == nil)
      npcs = GameObj.npcs.find_all { |i| i.type =~ /companion/i }
      npcs.each { |i|
        res = dothistimeout "lean ##{i.id}", 1, /your direction in acknowledgement|rubbing.*gently|while it is flying|You lean toward/i
        if res =~ /rubbing.*gently/i
          $companion = i.name
          echo "Ranger Companion set to #{i.name}"
          break
        end
      }
    end
    if (Char.prof =~ /Wizard/i && Spell[920].known? && GameObj.npcs.any? { |i| i.type =~ /familiar/ })
      res = dothistimeout "tell familiar to enter fakeportal", 1, /You sense confusion from your .*\.|You have no familiar at this time\./i
      if res =~ /You sense confusion from your/i
        res.sub!('You sense confusion from your ', '')
        res.gsub!('.', '')
        GameObj.npcs.each { |s|
          if s.name =~ /#{res}/i
            $familiar = s.name
            break
          end
        }
        echo "Familiar set as #{$familiar}"
      end
    end
  end

  def RoaterEscape()
    # find_all_containers_var = nil
    dagger_found = false
    container_ids = []
    empty_hands
    res = Lich::Util.quiet_command_xml("inventory containers", /Your worn items are:/, /<prompt time=/)
    res.each { |l|
      container_ids = l.scan(/<a exist=\"([^\"]+)\"/).flatten if (l =~ /<a exist=\"([^\"]+)\"/)
    }
    find_all_containers_var = container_ids.collect { |id| GameObj[id] }
    find_all_containers_var.each { |i|
      if i.contents.nil?
        res = Lich::Util.quiet_command_xml("look in ##{i.id}", /In the|There is nothing|This|is closed|shut too tightly/, /<prompt time=/)
        if res.any? { |line| line =~ /is closed|shut too tightly/i } # do we want it to open containers to look for daggers?
          Lich::Util.quiet_command_xml("open ##{i.id}", /<a exist=/, /<prompt time=/)
          Lich::Util.quiet_command_xml("look in ##{i.id}", /In the|There is nothing|This/, /<prompt time=/)
        end
      end
      i.contents.each { |s|
        if s.name =~ /alfange|basilard|bodkin|cinquedea|dagger|dirk|knife|kozuka|ice pick|misericord|parazonium|pavade|poignard|pugio|scramasax|sgian achlais|spike|stiletto|tanto|sidearm-of-Onar/i
          fput "_drag ##{s.id} right"
          dagger_found = true if (checkright =~ /#{s.noun}/)
          while !checkroom("The Belly of the Beast").nil?
            waitrt?
            fput "attack wall"
          end
          fput "_drag ##{s.id} ##{i.id}"
          break
        end
      }
      break if dagger_found
    }
    fill_hands
  end

  def bs_put(message)
    echo "bs_put" if $bigshot_debug
    unless (script = Script.self) then
      respond('--- waitfor: Unable to identify calling script.')
      return false
    end
    clear
    put(message)

    while (string = get)
      if string =~ /(?:\.\.\.wait |Wait )[0-9]+/
        hold_up = string.slice(/[0-9]+/).to_i
        sleep(hold_up - 1) unless hold_up.nil? || hold_up == 1
        clear
        put(message)
        next
      elsif string =~ /struggle.+stand/
        clear
        bs_put("stand")
        next
      elsif string =~ /stunned|can't do that while|cannot seem|can't seem|don't seem|Sorry, you may only type ahead/
        if dead?
          echo("You're dead...! You can't do that!")
          sleep(0.25)
          script.downstream_buffer.unshift(string)
          return false
        elsif checkstunned
          while checkstunned
            sleep(0.25)
          end
        elsif checkwebbed
          while checkwebbed
            sleep(0.25)
          end
        else
          sleep(0.25)
        end
        clear
        put(message)
        next
      else
        script.downstream_buffer.unshift(string)
        return string
      end
    end
  end

  def group_put(message)
    echo "group_put" if $bigshot_debug
    bs_put(message)
  end

  def group_cmd(message)
    echo "group_cmd" if $bigshot_debug
    cmd(message)
  end

  def group_do(message)
    echo "group_do" if $bigshot_debug
    do_client(message)
  end

  class Setup < Gtk::Builder
    attr_accessor :settings

    @@categories = {
      general: {

        # Profiles
        profile_current: { default: '' },
        profile_name: { default: '' },
        profile_button: { default: '' },
        save_current: { default: '' },
        profile_save: { default: '' },
        save_profile_name: { default: '' },
        profile_overwrite: { default: '' },
        profile_cancel: { default: '' },
        msg_label: { default: '' },
        no_current_profile: { default: '' },

        # Resting
        resting_room_id: { default: '' },
        resting_commands: { default: '' },
        resting_scripts: { default: '' },
        fog_return: { default: '' },
        fog_optional: { default: false },
        fried: { default: '' },
        overkill: { default: '' },
        lte_boost: { default: '' },
        oom: { default: '' },
        encumbered: { default: '' },
        wounded_eval: { default: '' },
        bounty_eval: { default: '' },
        crushing_dread: { default: '' },
        creeping_dread: { default: '' },
        wot_poison: { default: false },
        confusion: { default: false },

        # Hunting
        hunting_room_id: { default: '' },
        rallypoint_room_id: { default: '' },
        hunting_boundaries: { default: '' },
        rest_till_exp: { default: '' },
        rest_till_mana: { default: '' },
        rest_till_spirit: { default: '' },
        hunting_stance: { default: '' },
        hunting_prep_commands: { default: '' },
        hunting_scripts: { default: '' },
        signs: { default: '' },
        loot_script: { default: '' },
        wracking_spirit: { default: '' },
        priority: { default: false },
        delay_loot: { default: false },
        troubadours_rally: { default: false },
        use_wracking: { default: false },
        loot_stance: { default: false },
        pull: { default: true },
        deader: { default: true },

        # Attacking
        ambush: { default: '' },
        archery_aim: { default: '' },
        flee_count: { default: '' },
        invalid_targets: { default: '' },
        always_flee_from: { default: '' },
        flee_message: { default: '' },
        wander_wait: { default: '' },
        boon_flee_from: { default: false },
        flee_clouds: { default: false },
        flee_vines: { default: false },
        flee_webs: { default: false },
        flee_voids: { default: false },
        lone_targets_only: { default: false },
        weapon_reaction: { default: true },
        bless: { default: false },

        # Commands
        hunting_commands: { default: '' },
        hunting_commands_b: { default: '' },
        hunting_commands_c: { default: '' },
        hunting_commands_d: { default: '' },
        hunting_commands_e: { default: '' },
        hunting_commands_f: { default: '' },
        hunting_commands_g: { default: '' },
        hunting_commands_h: { default: '' },
        hunting_commands_i: { default: '' },
        hunting_commands_j: { default: '' },
        disable_commands: { default: '' },
        quick_commands: { default: '' },
        targets: { default: '' },
        quickhunt_targets: { default: '' },

        # Misc
        tier3: { default: '' },
        aim: { default: '' },
        uac_smite: { default: false },
        uac_mstrike: { default: false },
        mstrike_stamina_cooldown: { default: '' },
        mstrike_stamina_quickstrike: { default: '' },
        mstrike_mob: { default: '' },
        mstrike_cooldown: { default: false },
        mstrike_quickstrike: { default: false },
        ammo_container: { default: '' },
        ammo: { default: '' },
        fresh_wand_container: { default: '' },
        dead_wand_container: { default: '' },
        wand: { default: '' },
        hide_for_ammo: { default: false },
        wand_if_oom: { default: false },
        ma_looter: { default: '' },

        # Monitoring
        dead_man_switch: { default: false },
        depart_switch: { default: false },
        quiet_followers: { default: true },
        monitor_interaction: { default: false },
        monitor_strings: { default: '' },
        monitor_safe_strings: { default: '' },

      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?

      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()
      @settings = settings
      @silent_exit = false

      # set default values if they don't exist

      @@categories.each do |_, data|
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end

      # remove settings that doesn't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }
      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        # add_from_file("#{$data_dir}bigshot.ui")
        add_from_string(Setup.ui)
        load_settings
        set_tooltips
        self['main'].keep_above = true
        self['main'].set_title "Big Shot: v#{BIGSHOT_VERSION}"
        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    def self.setup
      settings = UserVars.op.dup

      # convert the strings to symbol
      settings = settings.transform_keys(&:to_sym)

      # echo settings
      Setup.new(settings).start
    end

    def self.ui
      '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkWindow" id="main"><property name="can-focus">False</property><property name="title" translatable="yes">Bigshot Setup</property><property name="default-width">1050</property><property name="default-height">700</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkComboBoxText" id="profile_name"><property name="height-request">42</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">20</property><property name="has-entry">True</property><child internal-child="entry"><object class="GtkEntry"><property name="width-request">400</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="profile_button"><property name="label" translatable="yes">Load Profile</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">30</property><property name="margin-top">19</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">18</property><property name="margin-top">10</property><property name="label" translatable="yes">Current Profile:</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property>
      </packing></child><child><object class="GtkEntry" id="profile_current"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">18</property><property name="margin-bottom">10</property><property name="editable">False</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel" id="msg_label"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="label" translatable="yes">
      </property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="width">2</property><property name="height">3</property></packing></child><child><object class="GtkButton" id="save_current"><property name="label" translatable="yes">Update Profile</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Saves setting changes to the current profile.</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">30</property><property name="margin-bottom">15</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel" id="no_current_profile"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-bottom">10</property><property name="label" translatable="yes">label</property><attributes><attribute name="foreground" value="#a5a51d1d2d2d"/></attributes></object><packing><property name="left-attach">0</property><property name="top-attach">3</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Load Profile</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-bottom">5</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkButton" id="profile_save"><property name="label" translatable="yes">Save Current Settings as...</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">15</property><property name="margin-top">10</property><property name="margin-bottom">5</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="save_profile_name"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-bottom">15</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property>
      </packing></child><child><object class="GtkLabel" id="test_label"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">15</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="label" translatable="yes">label</property><attributes><attribute name="foreground" value="#a5a51d1d2d2d"/></attributes></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkButton" id="profile_overwrite"><property name="label" translatable="yes">Save Profile</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">15</property><property name="margin-end">15</property><property name="margin-top">20</property><property name="margin-bottom">13</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="profile_cancel"><property name="label" translatable="yes">Cancel</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-end">10</property><property name="margin-top">20</property><property name="margin-bottom">13</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Save Profile</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
      </packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Profiles</property></object><packing><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=1 n-rows=13 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="resting_room_id"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">*Resting Room ID:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="resting_commands"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Pre-rest Commands:</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="resting_scripts"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">41</property><property name="label" translatable="yes">Active Resting Scripts:</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkComboBoxText" id="fog_return"><property name="width-request">200</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="active">0</property><property name="has-entry">True</property><items><item id="0" translatable="yes">None</item><item id="1" translatable="yes">Spirit Guide (130)</item><item id="2" translatable="yes">Voln Symbol of Return</item><item id="3" translatable="yes">Travelers Song (1020)</item><item id="4" translatable="yes">GoS Sigil of Escape</item><item id="5" translatable="yes">Familiar Gate (930)</item>
      </items><child internal-child="entry"><object class="GtkEntry"><property name="can-focus">False</property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Fog Options</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property>
      </packing></child><child><object class="GtkCheckButton" id="fog_optional"><property name="label" translatable="yes"> Fog ONLY if wounded or encumbered</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">4</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Where to Rest</property>
      </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="height">6</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=6 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="fried"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">*when percentmind &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="overkill"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">and extra kills &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="lte_boost"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">and used lte boosts &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="oom"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">*or percentmana &lt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="encumbered"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">or percent encumbrance &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing>
      </child><child><object class="GtkEntry" id="wounded_eval"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">5</property><property name="width">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">or wounded eval:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">5</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">50</property><property name="margin-top">10</property><property name="label" translatable="yes">when creeping dread &gt;=</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="creeping_dread"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">when crushing dread &gt;=</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="crushing_dread"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkCheckButton" id="wot_poison"><property name="label" translatable="yes">Wall of Thorns Poison</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="margin-top">10</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property><property name="width">2</property>
      </packing></child><child><object class="GtkCheckButton" id="confusion"><property name="label" translatable="yes">Confusion Debuff</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="margin-top">10</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Should Rest?</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">6</property><property name="height">7</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object><packing><property name="position">1</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Resting</property></object><packing><property name="position">1</property><property name="tab-fill">False</property>
      </packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=4 n-rows=13 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="hunting_stance"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Attack Stance:</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">100</property><property name="margin-end">10</property><property name="margin-top">20</property><property name="label" translatable="yes">Note: Use nouns or name for targets.
      Mouse over society abilities field for more info.</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">12</property><property name="width">2</property></packing></child><child><object class="GtkEntry" id="hunting_prep_commands"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkEntry" id="hunting_scripts"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="signs"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="loot_script"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">4</property></packing></child><child><object class="GtkEntry" id="wracking_spirit"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">5</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Pre-hunt Commands:</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Active Hunting Scripts:</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">30</property><property name="label" translatable="yes">Society Abilities/Spells/Cmans:</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing>
      </child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Loot Script:</property><property name="single-line-mode">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Wracking Spirit &gt;=</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">5</property></packing></child><child><object class="GtkCheckButton" id="priority"><property name="label" translatable="yes">Priority Hunt</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">6</property></packing></child><child><object class="GtkCheckButton" id="delay_loot"><property name="label" translatable="yes">Delay Looting</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="troubadours_rally"><property name="label" translatable="yes">Troubadour\'s Rally</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="use_wracking"><property name="label" translatable="yes">Use sign of wracking/sigil of power/symbol of mana</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">6</property></packing></child><child><object class="GtkCheckButton" id="loot_stance"><property name="label" translatable="yes">Defensive stance before looting</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="pull"><property name="label" translatable="yes">Pull players to feet</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="deader"><property name="label" translatable="yes">Stop for dead players</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="valign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">9</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="hunting_room_id"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="rallypoint_room_id"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="hunting_boundaries"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">*Starting Room ID:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Rallypoint Room ID:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">35</property><property name="label" translatable="yes">*Boundary Room IDs:</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-end">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Note Bigshot will not enter boundary rooms.
      The goal is to pin yourself into a hunting area.</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Hunting Map</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property><property name="height">5</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="rest_till_exp"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">30</property><property name="margin-top">10</property><property name="label" translatable="yes">*when percentmind &lt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="rest_till_mana"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">*and percentmana &gt;=</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="rest_till_spirit"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">*and checkspirit &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Should Hunt?</property>
      </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">6</property><property name="width">2</property><property name="height">4</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/>
      </child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object><packing><property name="position">2</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Hunting</property>
      </object><packing><property name="position">2</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=15 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="ambush"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="archery_aim"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="flee_count"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Ambush aiming locations (head, etc):</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Archery aiming locations (head, etc):</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Flee if enemy count is &gt;</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">100</property><property name="margin-end">10</property><property name="margin-top">20</property><property name="label" translatable="yes">Note: Use nouns or name for flee info.
      Mouse over some hunting commands field for more info.</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">12</property><property name="width">2</property></packing></child><child><object class="GtkEntry" id="invalid_targets"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="always_flee_from"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkEntry" id="flee_message"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">5</property></packing></child><child><object class="GtkEntry" id="wander_wait"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">6</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">...but don\'t count these:</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">...and always flee from</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Flee from environmental message:</property></object><packing><property name="left-attach">0</property><property name="top-attach">5</property></packing>
      </child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Wait before wandering to another room</property></object><packing><property name="left-attach">0</property><property name="top-attach">6</property></packing></child><child><object class="GtkCheckButton" id="boon_flee_from"><property name="label" translatable="yes">Flee from Boon/Boss/Glamour creatures</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="lone_targets_only"><property name="label" translatable="yes">Approach Lone Targets Only</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="weapon_reaction"><property name="label" translatable="yes">Activate Weapon Reactions</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will initiate reactive strikes when the opportunity presents itself.</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">9</property></packing></child><child><object class="GtkCheckButton" id="bless"><property name="label" translatable="yes">Bless Weapon?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="flee_clouds"><property name="label" translatable="yes">Flee from Clouds</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="flee_vines"><property name="label" translatable="yes">Flee from Vines</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">9</property></packing></child><child><object class="GtkCheckButton" id="flee_webs"><property name="label" translatable="yes">Flee from Webs</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">10</property></packing></child><child><object class="GtkCheckButton" id="flee_voids"><property name="label" translatable="yes">Flee from Voids</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">11</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/>
      </child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
      </packing></child></object></child></object></child></object><packing><property name="position">3</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Attacking</property></object><packing><property name="position">3</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=4 n-rows=12 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="hunting_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="hunting_commands_b"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="hunting_commands_c"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (a):</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Hunting Commands (b):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (c):</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="hunting_commands_d"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="hunting_commands_e"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkEntry" id="hunting_commands_f"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">5</property></packing></child><child><object class="GtkEntry" id="hunting_commands_g"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">6</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (d):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (e):</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (f):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">5</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (g):</property></object><packing><property name="left-attach">0</property><property name="top-attach">6</property></packing></child><child><object class="GtkEntry" id="hunting_commands_h"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">7</property></packing></child><child><object class="GtkEntry" id="hunting_commands_i"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">8</property></packing></child><child><object class="GtkEntry" id="hunting_commands_j"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">9</property></packing></child><child><object class="GtkEntry" id="disable_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">5</property></packing></child><child><object class="GtkEntry" id="quick_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (h):</property></object><packing><property name="left-attach">0</property><property name="top-attach">7</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (i):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">8</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Hunting Commands (j):</property></object><packing><property name="left-attach">0</property><property name="top-attach">9</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Fried Commands:</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">5</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Quick Commands:</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="targets"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Valid Targets:</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="quickhunt_targets"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Quickhunt Targets:</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">3</property><property name="top-attach">4</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/>
      </child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object><packing><property name="position">4</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Commands</property></object><packing><property name="position">4</property><property name="tab-fill">False</property>
      </packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><!-- n-columns=4 n-rows=11 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">30</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="tier3"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">15</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">30</property><property name="label" translatable="yes">Tier 3 Attack:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="aim"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">11</property><property name="label" translatable="yes">Aim at location (head, etc):</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing>
      </child><child><object class="GtkCheckButton" id="uac_smite"><property name="label" translatable="yes">Use Voln SMITE?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">15</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkCheckButton" id="uac_mstrike"><property name="label" translatable="yes">Do Not Mstrike.</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">UAC</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property><property name="height">4</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">15</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="mstrike_stamina_cooldown"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">15</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">15</property><property name="label" translatable="yes">MStrike during cooldown stamina requirement:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="mstrike_stamina_quickstrike"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">QuickStrike stamina requirement:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="mstrike_mob"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Unfocused MStrike when Creatures &gt;=</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="mstrike_cooldown"><property name="label" translatable="yes">MStrike during cooldown</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">end</property><property name="margin-end">15</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="mstrike_quickstrike"><property name="label" translatable="yes">Use QuickStrike for MStrike</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">MStrike</property></object></child></object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="width">2</property><property name="height">4</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">30</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=7 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="ammo_container"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Find ammo in this container:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="ammo"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Use this ammo type:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="fresh_wand_container"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Fresh wand container</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="dead_wand_container"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Dead wand container</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="wand"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Use this wand type</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkCheckButton" id="hide_for_ammo"><property name="label" translatable="yes">Hide to pick up ammo</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">15</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">5</property></packing></child><child><object class="GtkCheckButton" id="wand_if_oom"><property name="label" translatable="yes">Use wands when out of mana</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">6</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Ammo/Wands</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">4</property><property name="width">2</property><property name="height">7</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">15</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="ma_looter"><property name="width-request">280</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">4</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">15</property><property name="label" translatable="yes">Character Name of Looter
      </property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">MA Grouping</property>
      </object></child></object><packing><property name="left-attach">2</property><property name="top-attach">4</property><property name="width">2</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/>
      </child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object></child></object></child></object><packing><property name="position">5</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object><packing><property name="position">5</property><property name="tab-fill">False</property>
      </packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=1 n-rows=6 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">20</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="monitor_interaction"><property name="label" translatable="yes">Monitor Interactions</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkFrame"><property name="width-request">600</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">50</property><property name="label-xalign">0</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><child><object class="GtkTextView" id="monitor_strings"><property name="visible">True</property><property name="can-focus">True</property><property name="wrap-mode">word</property>
      </object></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Watch for strings (or regexes) that contain</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkFrame"><property name="width-request">600</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">50</property><property name="label-xalign">0</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><child><object class="GtkTextView" id="monitor_safe_strings"><property name="visible">True</property><property name="can-focus">True</property><property name="wrap-mode">word</property>
      </object></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">....except if they also contain</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">5</property></packing></child><child><object class="GtkCheckButton" id="dead_man_switch"><property name="label" translatable="yes">Engage deadmans switch (Shattered Only)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="depart_switch"><property name="label" translatable="yes">Depart/rerun if dead</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="quiet_followers"><property name="label" translatable="yes">Quiet Followers</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object><packing><property name="position">6</property>
      </packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Monitoring</property></object><packing><property name="position">6</property><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">20</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes">To save properly, exit with the close button and not the X window. --&gt;</property><attributes><attribute name="style" value="italic"/>
      </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
      </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      self['no_current_profile'].hide
      self['test_label'].hide
      self['profile_save'].show
      self['save_profile_name'].show

      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::RadioButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::Button
          if obj.builder_name.to_s == "save_current"
            save_profile_changes
          end

          if obj.builder_name.to_s == "profile_button"
            on_profile_load
          end

          if obj.builder_name.to_s == "profile_save"
            save_profile
          end

          if obj.builder_name.to_s == "profile_overwrite"
            self['profile_overwrite'].hide
            self['profile_cancel'].hide
            File.write(@filename, @settings.to_yaml)
            self['test_label'].text = "The profile has been saved to \n#{@filename}"
            self['profile_current'].text = self['save_profile_name'].text
            self['save_profile_name'].text = ''
            self['test_label'].text = "The profile has been saved to #{@filename}"
            self['save_profile_name'].hide
            self['profile_save'].hide
            self['test_label'].show
          end

          if obj.builder_name.to_s == "profile_cancel"
            self['profile_overwrite'].hide
            self['profile_cancel'].hide
            self['test_label'].text = "The profile save has been canceled"
            self['save_profile_name'].text = ''
            self['profile_save'].show
          end

        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        #  echo "@settings[key]: #{@settings[key]} key: #{key} obj.text.strip: #{obj.text.strip}"
        elsif obj.class == Gtk::TextView
          @settings[key] = obj.buffer.text
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update
          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        elsif obj.class == Gtk::ComboBoxText
          if obj.builder_name.to_s == "fog_return"
            @settings[key] = obj.active_id
          else
            @settings[key] = obj.active_text
          end
        end
      end
    end

    def on_profile_load
      if @settings[:profile_name].empty?
        return
      end

      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")

      filename = @settings[:profile_name] + ".yaml"
      profile = File.join(dir, filename)
      from_file = YAML.load_file(profile)
      @settings = from_file.transform_keys(&:to_sym)
      self['profile_current'].text = self['profile_name'].active_text
      self['profile_name'].set_active(0)

      load_settings(false)
    end

    def on_drop_load
      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")

      self['profile_name'].remove_all
      self['profile_name'].append_text('')
      names = []
      Dir.foreach(dir) { |f| names.push(f) }
      names.each { |filename|
        next if filename == '.' || filename == '..'

        self['profile_name'].append_text("#{filename.sub(".yaml", "")}")
      }
    end

    def set_tooltips
      # Profile Tab

      # Message on Profile tab
      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
      msg = "This drop down shows profiles available at the new save location.\nThe location was changed to enable settings organized by character.\n\n"
      msg += "The new bigshot default profile location...\n#{dir}\n\n"
      msg += "The original location is here...\n#{File.join($script_dir, 'bigshot_profiles')}"
      self['msg_label'].text = msg
      # Profile dropdown
      self['profile_name'].tooltip_text = ''
      # Load Profile Button
      self['profile_button'].tooltip_text = ''
      # Current Profile Textbox
      self['profile_current'].tooltip_text = ''
      # Save Changes Button
      self['save_current'].tooltip_text = ''
      # Save Current Settings
      self['profile_save'].tooltip_text = ''
      # Save Current Textbox
      self['save_profile_name'].tooltip_text = ''
      # Save Profile Button
      self['profile_overwrite'].tooltip_text = ''
      # Cancel Button
      self['profile_cancel'].tooltip_text = ''

      # Resting Tab

      # Resting Room ID
      self['resting_room_id'].tooltip_text = "Supports traditional room numbers as well as uid's (ex u7000)"
      # Pre-rest Commands
      self['resting_commands'].tooltip_text = ''
      # Active Resting Scripts
      self['resting_scripts'].tooltip_text = ''
      # Fog Options
      fog_tooltip  = "None: Dont use any fog options when you return from a hunt\n\nSpirit Guide(130): Use 130 first, then if that fails Symbol of Return\n\n"
      fog_tooltip += "Voln Symbol of Return: Use Symbol of Return first, then if that fails 130\n\nTraveler's Song(1020): Use 1020 only\n\n"
      fog_tooltip += "GoS Sigil of Escape: Use Sigil of Escape\n\nFamiliar Gate(930): Summon familiar gate and go thru portal"
      self['fog_return'].tooltip_text = fog_tooltip
      # Fog Checkbox
      self['fog_optional'].tooltip_text = ''
      # when percentmind
      self['fried'].tooltip_text = "Percentage of your mind (0-100) after which you will stop hunting.\n   101  will hunt until mana/encumbrance/wounded\n   100  is fully fried"
      # and extra kills
      self['overkill'].tooltip_text = "This is the number of additional monsters to kill after reaching your fried threshold.\nLeave blank to not kill any extra monsters"
      # and used lte boosts
      self['lte_boost'].tooltip_text = ''
      # or percent mana
      self['oom'].tooltip_text = ''
      # or percentencumbrance
      self['encumbered'].tooltip_text = ''
      # or wound eval
      self['wounded_eval'].tooltip_text = ''

      # Hunting Tab

      # Starting Room ID
      self['hunting_room_id'].tooltip_text = "Supports traditional room numbers as well as uid's (ex u7000)"
      # Rally Point ID
      rally_tooltip  = "If left blank, will set to starting room ID.\n"
      rally_tooltip += "Set to a safe room BEFORE your hunting start point that you want to stop to cast your active hunting spells/signs/sigils/signs and start your active hunting scripts.\n\n"
      rally_tooltip += "If in a group, and this is the head, then will wait here for all tails before casting your active hunting spells/signs/sigils/signs and start your active hunting scripts.\n\n"
      rally_tooltip += "Use Case Example 1: You are hunting somewhere far away and dont want to cast Wall of Force before walking for half the duration.\n\n"
      rally_tooltip += "Use Case Example 2: You want to stop before your climb to start your sigils because there is a climb ahead."
      rally_tooltip += "Supports traditional room numbers as well as uid's (ex u7000)"
      self['rallypoint_room_id'].tooltip_text = rally_tooltip
      # Boundary Rooms
      self['hunting_boundaries'].tooltip_text = "Supports traditional room numbers as well as uid's (ex u7000)"
      # when percentmind
      self['rest_till_exp'].tooltip_text = "Accurately calculates percentmind now."
      # and percentmana
      self['rest_till_mana'].tooltip_text = ''
      # and checkspirit
      self['rest_till_spirit'].tooltip_text = ''
      # Attack Stance
      self['hunting_stance'].tooltip_text = ''
      # Pre-hunt Commands
      self['hunting_prep_commands'].tooltip_text = ''
      # Active Hunting Scripts
      self['hunting_scripts'].tooltip_text = ''
      # Society Abilities/Spells/Cmans
      signs_tooltip  = "Shadow Mastery - 9603\nSurge of Strength - 9605\n\nSigil of Contact - 9703\nSigil of Resolve - 9704\nSigil of Minor Bane - 9705\nSigil of Defense - 9707\nSigil of Offense - 9708\n"
      signs_tooltip += "Sigil of Minor Protection - 9710\nSigil of Focus - 9711\nSigil of Mending - 9713\nSigil of Concentration - 9714\nSigil of Major Bane - 9715\nSigil of Major Determination - 9716\nSigil of Major Protection - 9719\n\n"
      signs_tooltip += "Sign of Warding - 9903\nSign of Striking - 9904\nSign of Thought - 9906\nSign of Defending - 9907\nSign of Smiting - 9908\nSign of Staunching - 9909\nSign of Deflection - 9910\n"
      signs_tooltip += "Sign of Swords - 9912\nSign of Shields - 9913\nSign of Dissipation - 9914\nSign of Madness - 9916\n\n"
      signs_tooltip += "Symbol of Courage - 9805\nSymbol of Protection - 9806\nSymbol of Supremacy - 9816\n\nBarkskin - 605\n\nFasthr's Reward - 115"
      self['signs'].tooltip_text = signs_tooltip
      # Loot Script
      self['loot_script'].tooltip_text = ''
      # Wracking Spirit
      self['wracking_spirit'].tooltip_text = ''
      # Priority Hunt
      self['priority'].tooltip_text = "Priority is based on order of valid targets box on hunting tab.\nWill switch to highest priority in room when attacking."
      # Delay Looting
      self['delay_loot'].tooltip_text = ''
      # Troubadour's Rally
      self['troubadours_rally'].tooltip_text = "Shout 1040 when you or your group members are incapacitated."
      # Use Sign of Wracking/Sigil of Power/Symbol of Mana
      self['use_wracking'].tooltip_text = ''
      # Def Stance before Looting
      self['loot_stance'].tooltip_text = ''
      # Pull Players to Feet
      self['pull'].tooltip_text = ''
      # Stop for Deaders
      self['deader'].tooltip_text = ''

      # Attack Tab

      # Ambush aiming location
      self['ambush'].tooltip_text = ''
      # Archery aiming location
      self['archery_aim'].tooltip_text = ''
      # Flee enemy count
      self['flee_count'].tooltip_text = ''
      # but don't coint these
      self['invalid_targets'].tooltip_text = ''
      # Always flee from
      self['always_flee_from'].tooltip_text = ''
      # Flee from environmental msg
      flee_msg  = "Input any text that when the game sends you want to move out of the room...\n"
      flee_msg += 'like a Roa\'ter burrow attack \\"You feel a rumble come from beneath your feet."\\'
      flee_msg += "\nSeperate different messages with a | in between them.\nText compares to XML feed, not plain text."
      self['flee_message'].tooltip_text = flee_msg
      # Wait before wandering
      self['wander_wait'].tooltip_text = ''
      # Flee from boon/boss/glamour creatures
      self['boon_flee_from'].tooltip_text = ''
      # Flee from clouds
      self['flee_clouds'].tooltip_text = ''
      # Flee from vines
      self['flee_vines'].tooltip_text = ''
      # Flee from webs
      self['flee_webs'].tooltip_text = ''
      # Flee from voids
      self['flee_voids'].tooltip_text = ''
      # Approach lone targets only
      self['lone_targets_only'].tooltip_text = ''
      # Activate weapon reactions
      self['weapon_reaction'].tooltip_text = "Will initiate reactive strikes when the opportunity presents itself."
      # Bless Weapons
      self['bless'].tooltip_text = "If checked, will stop hunt when item's blesses run out.\nIf unchecked, will continue to hunt and remind to get blesses while resting."

      # Commands Tab

      # hunting_commands(a)
      hunting_tooltip  = "Example 1: 413 target, 903 target\nExample 2: 903 target(x2)\nExample 3: 903 target(xx)\nExample 4: 910 target(m50), 903 target\nExample 5: unarmed punch, wait 30\n\n"
      hunting_tooltip += "Example 1 will cast 413 then 903 on the target.\nExample 2 will cast 903 on the target twice.\nExample 3 will cast 903 on the target until the fight is over.\n"
      hunting_tooltip += "Example 4 will cast 910 if mana is at least 50, otherwise it will cast 903.\nExample 5 will start the unarmed routine with punch as the main attack. It will attack once, then wait 30 seconds for another attack to happen before attacking again.\n"
      hunting_tooltip += "Separate all commands with commas.\nMore examples available on the Wiki.\n\nNew feature: 'and'.\nFor example: stance def and 1615 target, kill target(xx)"
      self['hunting_commands'].tooltip_text = hunting_tooltip
      # hunting_commands_b
      self['hunting_commands_b'].tooltip_text = ''
      # hunting_commands_c
      self['hunting_commands_c'].tooltip_text = ''
      # hunting_commands_d
      self['hunting_commands_d'].tooltip_text = ''
      # hunting_commands_e
      self['hunting_commands_e'].tooltip_text = ''
      # hunting_commands_f
      self['hunting_commands_f'].tooltip_text = ''
      # hunting_commands_g
      self['hunting_commands_g'].tooltip_text = ''
      # hunting_commands_h
      self['hunting_commands_h'].tooltip_text = ''
      # hunting_commands_i
      self['hunting_commands_i'].tooltip_text = ''
      # hunting_commands_j
      self['hunting_commands_j'].tooltip_text = ''
      # Fried Hunting Commands
      fried_tooltip  = "If left blank and this character is in a bigshot group, character will continue to use standard hunting commands after mind is fried and overkill limit is reached.\n"
      fried_tooltip += "If row populated, and character is in a bigshot group, these commands will be used instead of standard hunting commands once fried and overkill limit reached.\n"
      fried_tooltip += "See Hunting Commands(a) tooltip for examples on what commands to use."
      self['disable_commands'].tooltip_text = fried_tooltip
      # Quick Hunting Commands
      self['quick_commands'].tooltip_text = ''
      # Valid Targets
      self['targets'].tooltip_text = ''
      # Quickhunt Targets
      self['quickhunt_targets'].tooltip_text = "Leave blank to target all critters."

      # Misc Tab

      # Tier 3 Attack
      self['tier3'].tooltip_text = ''
      # Aim at Location
      self['aim'].tooltip_text = "Leave blank if you don't want to aim at anything\n\nSuggest leaving chest as last thing to aim at so you will always have something to hit."
      # Use Voln Smite
      self['uac_smite'].tooltip_text = "Will SMITE a non-corporeal undead when tier is excellent during UAC Combat."
      # Do Not Mstrike
      self['uac_mstrike'].tooltip_text = "Enable check box to prevent mstrikes during unarmed attacks."
      # MStrike during cooldown
      mstrike_tooltip  = "Set this to the highest you want your stamina to be before you MSTRIKE.\n"
      mstrike_tooltip += "Important if MSTRIKEing during its cooldown or while using QUICKSTRIKE.\nLeave blank to only mstrike on cooldown with max stamina.\n"
      mstrike_tooltip += "Combination of QUICKSTRIKE and MSTRIKE during cooldown may pop muscles.\nIve done best I can to ensure it doesn't happen, but depends on what you set your MSTRIKE stamina to.\n\n"
      mstrike_tooltip += "Works in conjunction with MSTRIKE creature #, so if you meet the requirements for it and not this one you will MSTRIKE and visaversa."
      self['mstrike_stamina_cooldown'].tooltip_text = mstrike_tooltip
      # Quickstrike Stamina Requirements
      self['mstrike_stamina_quickstrike'].tooltip_text = ''
      # Unfocused MStrike when creature
      self['mstrike_mob'].tooltip_text = "How many creatures you want in the room before you perform an unfocused MSTRIKE.\nDefault is 2. Set to 1 to always do an unfocused MSTRIKE."
      # MStrike during cooldown
      self['mstrike_cooldown'].tooltip_text = ''
      # Use Quickstrike for Mstrike
      self['mstrike_quickstrike'].tooltip_text = ''
      # Find ammo in this container
      self['ammo_container'].tooltip_text = ''
      # Use this ammo type
      self['ammo'].tooltip_text = ''
      # Fresh wand container
      self['fresh_wand_container'].tooltip_text = ''
      # Dead wand container
      self['dead_wand_container'].tooltip_text = ''
      # Use this wand type
      self['wand'].tooltip_text = ''
      # Hide to pick up ammo
      self['hide_for_ammo'].tooltip_text = ''
      # Use wands when oom
      self['wand_if_oom'].tooltip_text = ''
      # Character Name of Looter
      self['ma_looter'].tooltip_text = "The lead (head) characters profile will set the looter.\nIf nothing is entered or that character isn't part of the group the lead will resume looting."

      # Monitoring Tab

      # Engage Deadman switch
      self['dead_man_switch'].tooltip_text = ''
      # Depart/rerun if dead
      self['depart_switch'].tooltip_text = ''
      # Quiet Followers
      self['quiet_followers'].tooltip_text = "Followers will wait until Leader is done with both actions and resting scripts to begin using their own.\n\nUse Case: Prevents you from looking like you have mindless bots following while selling loot."
      # Monitor Interactions
      self['monitor_interaction'].tooltip_text = ''
      # Watch for strings
      self['monitor_strings'].tooltip_text = ''
      # ...excpet if they also contain
      self['monitor_safe_strings'].tooltip_text = ''
    end

    def pre_save
      @settings.delete(:profile_name)
      @settings.delete(:profile_button)
      @settings.delete(:save_current)
      @settings.delete(:profile_save)
      @settings.delete(:profile_overwrite)
      @settings.delete(:profile_cancel)
      @settings.delete(:msg_label)
      @settings.delete(:no_current_profile)

      @settings = @settings.transform_keys(&:to_s)
    end

    def on_close_clicked
      pre_save
      UserVars.op = @settings

      @silent_exit = true
      Lich::Messaging.msg('plain', " Bigshot UI closed, saving any changes")

      self['main'].destroy
    end

    def on_destroy
      Gtk.queue {
        Lich::Messaging.msg('plain', " Bigshot UI closed WITHOUT saving any changes") unless @silent_exit
        # Load settings here
        @running = false
      }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings(connect = true)
      Gtk.queue do
        # echo @settings
        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym

          next if (setting = Setup.get_setting(key)).nil?

          self['save_profile_name'].text = ''
          self['profile_current'].text = @settings["save_profile_name"] unless @settings["save_profile_name"].nil?

          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) } if connect
          elsif obj.class == Gtk::RadioButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) } if connect
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].to_s.strip
            obj.signal_connect('changed') { on_update(obj) } if connect
          elsif obj.class == Gtk::Label
            # if obj.builder_name.to_s == "msg_label"

            # end
          elsif obj.class == Gtk::TextView
            obj.buffer.text = @settings[key].to_s.strip
            obj.signal_connect('focus-out-event') { on_update(obj) } if connect
          elsif obj.class == Gtk::SpinButton
            obj.value = @settings[key]
            obj.adjustment.value = @settings[key]
            obj.signal_connect('changed') { on_update(obj) } if connect
          elsif obj.class == Gtk::Button
            if obj.builder_name.to_s == "profile_button"
              on_drop_load
            end
            obj.signal_connect('clicked') { on_update(obj) } if connect
          elsif obj.class == Gtk::ComboBoxText

            if obj.builder_name.to_s == "fog_return"
              obj.set_active(@settings[key].to_i)
            end

            obj.signal_connect('changed') { on_update(obj) } if connect
          elsif obj.class == Gtk::TreeView
            if (store = self["#{key}_store"]).nil?
              respond "** failed to find store for treeview #{key}"
              next
            elsif setting[:load].nil?
              respond "** no :load defined #{key}"
              next
            end

            setting[:load].call(store, @settings[key])

            # setup the signals
            if (add = self["#{key}_add"]).nil?
              respond "** failed to find add for treeview #{key}"
              next
            elsif (delete = self["#{key}_delete"]).nil?
              respond "** failed to find delete for treeview #{key}"
              next
            elsif (entry = self["#{key}_entry"]).nil?
              respond "** failed to find entry for treeview #{key}"
              next
            end

            add.signal_connect('clicked') do
              if setting[:set].nil?
                respond "** no :set defined for #{key}"
                next
              elsif entry.text.empty?
                next
              end
              setting[:set].call(store, entry.text, @settings[key])
              setting[:load].call(store, @settings[key])
            end if connect

            delete.signal_connect('clicked') do
              if setting[:delete].nil?
                respond "** no :delete defined for #{key}"
                next
              elsif (selected = obj.selection.selected).nil?
                next
              end
              setting[:delete].call(store, selected, @settings[key])
              setting[:load].call(store, @settings[key])
            end if connect
          end
        end

        # checkboxes for array storage with id's <setting>:<value>
        # this is primarily used by the loot types
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)
          next unless obj.builder_name =~ /^([^:]+):(.*)$/i
          next unless obj.class == Gtk::CheckButton

          key = Regexp.last_match(1).to_sym
          value = Regexp.last_match(2).to_s
          # echo "key: #{key} value: #{value}"
          next if Setup.get_setting(key).nil?

          # echo @settings[key].include?(value)
          obj.active = @settings[key].include?(value)

          # add in hook
          obj.signal_connect('toggled') do
            @settings[key].delete(value)
            if obj.active?
              @settings[key].push(value)
              @settings[key].uniq!.sort!
            end
          end if connect
        end
      end
    end

    def save_profile
      self['test_label'].hide
      @filename = ''

      if self['save_profile_name'].text.empty?
        self['test_label'].text = "Please enter a name before saving the profile"
        self['test_label'].show
        return
      end

      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
      @filename = File.join(dir, "#{self['save_profile_name'].text}.yaml")
      pre_save

      if File.exist?("#{@filename}")
        self['profile_overwrite'].show
        self['profile_cancel'].show
        self['profile_save'].hide
        self['test_label'].text = "File already exists!\nIf you wish to overwrite, please click the save profile button or cancel --->"
        self['test_label'].show
        return
      end
      File.write(@filename, @settings.to_yaml)
      self['profile_current'].text = self['save_profile_name'].text
      self['save_profile_name'].text = ''

      on_drop_load

      self['profile_save'].hide
      self['save_profile_name'].hide
      self['test_label'].text = "The profile has been saved to #{@filename}"
      self['test_label'].show
    end

    def save_profile_changes
      self['no_current_profile'].hide
      @filename = ''

      if self['profile_current'].text.empty?
        self['no_current_profile'].text = "Please enter a name before saving the profile"
        self['no_current_profile'].show
        return
      end

      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
      @filename = File.join(dir, "#{self['profile_current'].text}.yaml")
      pre_save
      File.write(@filename, @settings.to_yaml)

      self['no_current_profile'].text = "#{self['profile_current'].text} has been saved with current settings."
      self['no_current_profile'].show
    end

    def start
      @running = true
      Gtk.queue {
        self['main'].show_all
        self['test_label'].hide
        self['no_current_profile'].hide
        self['profile_overwrite'].hide
        self['profile_cancel'].hide
      }

      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[general internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def self.update_setting(key, value)
      setting = Setup.get_setting(key)
      echo "** Setting #{key.inspect} does not exist" if setting.nil?
      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        echo " Reset #{key}"
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          echo " #{value.inspect} removed from #{key.inspect}"
        else
          @settings[key].push(value)
          echo " #{value.inspect} added to #{key.inspect}"
        end

        echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        echo "#{key.inspect} has been set to #{value.inspect}"
        @settings[key] = value
      end
    end
  end

  def self.profile(vars)
    if vars[2] =~ /load/i
      if vars[3] != nil
        dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
        filename = File.join(dir, "#{vars[3]}.yaml")
        if !File.exist?("#{filename}")
          respond ""
          respond " You are trying to load a profile that does not exist."
          respond ""
          respond "***************************"
          respond " Notice- your default Bigshot profiles folder has changed to:"
          respond " #{dir}"
          respond ""
          respond " The old location is here: #{File.join($script_dir, 'bigshot_profiles')}"
          respond " You can copy this folder or appropriate profiles into the relevant character directory in your operating system"
          respond "****************************"
          respond ""
        else
          from_file = YAML.load_file(filename)
          UserVars.op = from_file
          echo "Settings loaded from profile: #{filename}."
        end
      else
        echo "You forgot to name your profile you wish to load."
        echo "Syntax: ;bigshot profile load <NAME Here, no Spaces!>"
      end
    elsif vars[2] =~ /save/i
      if vars[3] != nil
        dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
        filename = File.join(dir, "#{vars[3]}.yaml")
        if File.exist?("#{filename}")
          echo "File already exists, if you wish to overwrite, please ;unpause bigshot."
          echo "Else ;kill bigshot and choose another filename."
          pause_script
        end
        File.write(filename, UserVars.op.to_yaml)
        echo "Settings saved to profile: #{filename}."
      else
        echo "You forgot to name your profile you wish to save."
        echo "Syntax: ;bigshot profile save <NAME Here, no Spaces!>"
      end
    end
  end
end

if (Script.current.vars[1].nil? || Script.current.vars[1] =~ /solo|(bounty)|quick|single/i)
  bounty_mode = $1
  if Script.current.vars[1] =~ /quick/i
    $bigshot_quick = true
  end

  if Script.current.vars[1] =~ /single/i
    $bigshot_single = true
  end

  bs = Bigshot.new(bounty_mode)
  bs.croak('Requires Lich V4') unless defined?(Gtk.queue) || defined?($bigshot_headless)
  bs.croak('Requires a mapped room.') if ((Room.current.id.nil? || Room.current.id == 4) && !$bigshot_quick)
  bs.lead()

elsif (Script.current.vars[1] =~ /setup/i)
  Bigshot::Setup.setup
elsif (Script.current.vars[1] =~ /profile/i)
  Bigshot.profile(Script.current.vars)

elsif (Script.current.vars[1] =~ /display/i)
  echo "Version: #{BIGSHOT_VERSION}"
  UserVars.op.each_pair { |k, v|
    echo "#{k}: #{v}" unless v.nil? || v.class.to_s == 'Array' || v =~ /^\s*$/
  }
  echo "Targetable Character Setting: #{CharSettings['targetable'].map { |c| c.downcase }.sort { |a, b| a.split(" ").last <=> b.split(" ").last }}"
  echo "Untargetable Character Setting: #{CharSettings['untargetable'].map { |c| c.downcase }.sort { |a, b| a.split(" ").last <=> b.split(" ").last }}"

elsif (Script.current.vars[1] =~ /reset/i)
  CharSettings['targetable'] = nil
  CharSettings['untargetable'] = nil
  echo "Character Settings for Targetable and Untargetable are now reset"

elsif (Script.current.vars[1] =~ /ranger|companion/i)
  $companion = nil
  echo "Ranger Companion reset"

elsif (Script.current.vars[1] =~ /head|lead/i)
  # launch DRb server
  DRb.start_service(nil, Bigshot::Group.new)
  uri = DRb.uri

  Thread.new { DRb.thread.join }

  # launch DRb client
  DRb.start_service()
  bs = Bigshot.new()

  # set leader
  my_group = DRbObject.new(nil, uri)
  my_group.set_leader(bs)

  # announce/go
  (1..RALLY_TIME).each { |_i| fput "whisper ooc group Bigshot rallying at #{uri}"; sleep(1); }
  echo "Waiting for members to join Bigshot rally..."
  wait_until { (my_group.size() > 0) }
  pause 3
  bs.lead(my_group)
elsif (Script.current.vars[1] =~ /tail|follow|link/i)
  # Watch for rally
  group = nil
  bs = nil
  uri = nil
  while (group.nil? && bs.nil?)
    if Script.current.vars[1] =~ /link/i && Script.current.vars[2].nil?
      echo "Must supply target URI when using LINK option"
      exit
    end
    echo "waiting for rally" if $bigshot_debug
    if Script.current.vars[1] =~ /link/i
      uri = Script.current.vars[2]
    end
    if (!uri.nil? || get =~ /rallying at (.*)\."$/)
      uri = uri.nil? ? Regexp.last_match(1) : uri
      fput "whisper ooc group Bigshot rallying at #{uri}" unless Script.current.vars[1] =~ /link/i
      # create group
      DRb.start_service()
      group = DRbObject.new(nil, uri)

      # create Bigshot
      bs = Bigshot.new()
      group.add_member(bs)
      bs.keep_awake()
      bs.CompanionCheck()
      bs.NPCRoomCheck()
    end
  end

  # Participate
  bs.message("yellow", " Joined group")
  leader = group.leader.name

  $bigshot_overkill_counter = 0

  bs.groupcheck() if !checkpcs.nil?
  echo " Groupcheck done" if $bigshot_debug
  throttle_mind_check = Time.now() + 5

  while (!dead?)

    begin
      bs.change_stance('defensive')
      bs.stand() if !standing? && $looting_inactive
      sleep(0.25)

      # grab event
      event = bs.event_stack.size == 0 ? nil : bs.grab_event
      next if event.nil?

      # Lets check our mind but throttle it a little ~ every 5 sec should be plenty
      if Time.now() > throttle_mind_check
        bs.check_mind
        throttle_mind_check = Time.now() + 5
      end

      # kertwang!
      if (event.type != :STAY_QUIET || event.type == :FOLLOW_NOW)
        until (checkpcs.include?(leader))
          break if Char.name == leader

          Script.run('go2', "#{group.room_id} --disable-confirm", { quiet: true })
          fput "join #{leader}"
          sleep(1)
        end
      end

      # process event
      bs.message("yellow", " Event: " + event.type.to_s) unless event.type == :FOLLOWER_OVERKILL || event.type == :PREP_REST
      if (event.type == :HUNTING_PREP_COMMANDS)
        bs.HUNTING_PREP_COMMANDS.each { |i|
          if i =~ /^script\s+(.*?)(\s|$)(.*)/i
            bs.cmd_run_script($1, $3)
          else
            fput(i)
          end
        }

      elsif (event.type == :STAY_QUIET)
        next if Char.name == leader

        # If they got left somewhere besides the resting room, put them in a known (and hopefully safe) location
        if (Room.current.id != group.resting_id)
          bs.goto(group.resting_id)
          wait_while { running?('go2') }
        end
        bs.message("yellow", "Waiting for Bigshot leader to finish running resting scripts")
        loop do
          break if Char.name == leader

          sleep(REST_INTERVAL)
          break if checkpcs.include?(leader) && Room.current.id == group.resting_id
        end
        fput "join #{leader}"

      elsif (event.type == :FOLLOWER_OVERKILL)
        bs.use_lte_boost()

      elsif (event.type == :CAST_SIGNS)
        bs.cast_signs()

      elsif (event.type == :HUNTING_SCRIPTS_START)
        bs.run_scripts(bs.HUNTING_SCRIPTS, false)

      elsif (event.type == :ATTACK)
        if (event.stale?) # consider timestamp and room_id
          bs.message("yellow", " Skipping attack because it's stale")
          next
        end

        stop_attack = false
        target = nil
        while (!stop_attack)
          stop_attack = event.stale?
          while ((target = bs.find_target(target)) && !stop_attack)
            if (bs.event_stack.any? { |a| a.type == :PREP_REST })
              bs.message("yellow", " Preparing to move, skipping attack")
              stop_attack = true
              break
            end

            target = bs.find_target(nil) if !$bigshot_bandits && @PRIORITY && !bs.priority(target)
            bs.attack(target)

            if target.status =~ /dead|gone/ && group.looter == Char.name
              $looting_inactive = false
              bs.loot
              # @followers.first_member if $ambusher_here == false
            end

            until (checkpcs.include?(leader))
              break if Char.name == leader

              Script.run('go2', "#{group.room_id} --disable-confirm", { quiet: true })
              fput "join #{leader}"
              sleep(1)
            end

            stop_attack = bs.should_rest?
          end
          break if stop_attack

          stop_attack = bs.event_stack.any? { |a| a.type == :PREP_REST }
          sleep(0.3)
        end

      elsif (event.type == :PREP_REST)
        bs.prepare_for_movement()

      elsif (event.type == :LOOT)

        if group.looter == Char.name
          $looting_inactive = false
          bs.loot
        end

      elsif (event.type == :HUNTING_SCRIPTS_STOP)
        bs.croak_scripts(bs.HUNTING_SCRIPTS)

      elsif (event.type == :RESTING_PREP_COMMANDS)
        $bigshot_should_rest = nil # need to reset this
        $bigshot_overkill_counter = 0
        next if Char.name == leader

        bs.RESTING_COMMANDS.each { |i| fput(i) }

      elsif (event.type == :RESTING_SCRIPTS_START)
        next if Char.name == leader

        bs.run_scripts(bs.RESTING_SCRIPTS, true)

      elsif (event.type == :DISPLAY_WATCH)
        next if Char.name == leader

        if (event.stale?)
          bs.message("yellow", " Skipping display_watch because it's stale")
          next
        end
        fput 'exp'
        bs.message("yellow", "Bigshot last rested because: #{$rest_reason}") if $rest_reason
        bs.message("yellow", "Bigshot isn't hunting because: #{$not_hunting_reason}") if $not_hunting_reason
        sleep(REST_INTERVAL / 10)

      elsif (event.type == :CUSTOM_PUT)
        bs.group_put(event.cmd_input)

      elsif (event.type == :CUSTOM_CMD)
        bs.group_cmd(event.cmd_input)

      elsif (event.type == :CUSTOM_DO_CLIENT)
        bs.group_do(event.cmd_input)

      elsif (event.type == :PUBLIC_SEND)
        echo "SENT: #{bs.public_send(event.cmd_input) if bs.respond_to? event.cmd_input}"
      end
    rescue
      fput 'leave group'
      if (bs.RESTING_ROOM_ID && bs.RESTING_ROOM_ID != 4)
        start_script('go2', [bs.RESTING_ROOM_ID, '_disable_confirm_'])
        wait_while { running?('go2') }
      end
      echo "Fatal exception!"
      echo $!.to_s
      echo $!.backtrace.join("\n")
      Script.self.kill
    end
  end
end
