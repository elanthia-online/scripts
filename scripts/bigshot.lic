=begin

  bigshot.lic: the new optimus prime

  hunting script for hunting

        author: elanthia-online
  contributors: SpiffyJr, Tillmen, Kalros, Hazado, Tysong, Athias, Falicor, Deysh, Nisugi
          game: Gemstone
          tags: hunting, bigshot, combat
       version: 5.10.0
      required: Lich >= 5.12.6

  Setup Instructions: https://gswiki.play.net/Script_Bigshot
      Full Changelog: https://gswiki.play.net/Script_Bigshot/Changelog
     Help Contribute: https://github.com/elanthia-online/scripts

  Version Control:
    Major_change.feature_addition.bugfix
  v5.10.0  (2025-10-31)
    - update BSAreaRooms
    - fix MA so leader has group open
    - tighten follower loop
    - MA lead can identify expected group number at startup eg ;bigshot head 3
    - head/tail can now be started in any order
    - removed old companion_check method
    - bugfix when using negative mana value in cmd_spell
    - refactor group class
    - bugfix for bigclaim when follower is hidden
    - update cmd sleep to not change stance
    - add command for valid creatures similiar to mob
    - bugfix in disarm if target has no weapon
    - add gemstone support
  v5.9.13  (2025-10-27)
    - fix for dhurl command to respect ambush settings and additional messaging
  v5.9.12  (2025-10-24)
    - bugfix for stance dancing for unarmed and force being respected with AND commands
  v5.9.11  (2025-10-11)
    - bugfix for encumbrance command check
  v5.9.10  (2025-10-03)
    - bugfix in cmd_spell targetting to send proper gameobj ID# string
  v5.9.9  (2025-10-02)
    - add missing $rest_reasons
  v5.9.8  (2025-09-30)
    - bugfix for cmd_rapid to use cooldown instead of penalty check
  v5.9.7  (2025-09-30)
    - bugfix when Spell[597].active? in cast_signs
  v5.9.6  (2025-09-09)
    - add support for 902 and 411 (doesn't work with UAC)
    - remove custom issue_command for Lich method
    - added cast_spell method
    - updated Society Abilities/Spells/CMan section to ignore rapidfire cool down: 515 (ignore) or rapidfire (ignore)
  v5.9.5  (2025-07-22)
    - remove companion_check calls as no longer needed with migration to GameObj.targets for valid creatures
    - add check_disks param to bigclaim? method
    - add claim check to attack_break and need_to_loot (ignoring disk check)
    - add coupdegrace buff check and command check
    - increase bs_move timeout from 2 to 5
  v5.9.4  (2025-07-08)
    - bugfix for leader final loot to only work if claim is true
  v5.9.3  (2025-07-02)
    - bugfix for shield bash if using CMan instead of shield
    - bugfix for FORCE cmd to stop checking older lines if it found a proper attack messaging but failed the match
    - bugfix for cmd_tether to end if link is broken
  v5.9.2  (2025-06-30)
    - bugfix in cmd_tether potential npc logic
  v5.9.1  (2025-06-27)
    - Fix for head/tails bs_wander groupcheck logic
  v5.9.0  (2025-04-03)
    - Convert over to use Group and Claim modules from core Lich5
    - bugfix in cmd_assaults for confusion
    - add additional logic to cmd_unravel for creature gone/dead
    - bugfix in bs_put for bleedthru numbers merged with wait time (EXP output: Level: 100...wait 1 seconds.)
    - bugfix in creeping_dread typo name
    - attempts as head to pull tail members to feet if not standing prior to returning to resting
    - adds cmd_depress for 1015/Song of Depression usage
    - adds cmd_phase for 704/Phase to purpose prep/cast with NPC as target due to special use of changing non-corp to corp undead
    - adds final room loot option for leader in head/tail
    - add disarm weapon to cmd_cman
    - bugfix break PSM loop early if not affordable after wait messaging
    - cleanup class detection logic to use is_a? logic instead
    - bugfix in cmd_force to search newest msg to oldest via reget reversing
    - add Feat support for Chastise & Excoriate
    - add Righteous Rebuke command check (rebuke)
    - add Ardor of the Scourge command check (scourge)
    - add Glorious Momentum command check (momentum)
    - fix depart monitor to use ewaggle instead of waggle
    - fix clean value setting for rest_till_exp & rest_till_mana
  v5.8.5  (2025-03-28)
    - bugfix for follower resting commands use running a script
    - add cooldown detection to cmd_spell and 140/919/211/215/219/1619/1650
  v5.8.4  (2025-03-19)
    - remove deprecated calls
  v5.8.3  (2025-03-10)
    - bugfix in run_script to use exact naming of script that was started
  v5.8.2  (2025-02-26)
    - bugfix in run_script needing EXACT match for Script.running? check. Script.start is not exact. Causing issues
    - bugfix in command_check split_check
  v5.8.1  (2025-02-26)
    - add garrote command to buffXX command check validity for Enh. Agility buff
    - add garrote command check for active buff check
    - cleanup command check regex to simplify
  v5.8.0  (2025-02-20)
    - add custom fog option
    - option to force resting if looting leaves a box in your hand
    - enable pre-rest commands to call scripts eg. script go2 place
    - bugfix in tether command
    - add ancient & !ancient command checks for grizzled/ancient creatures
    - add animate & !animate command checks for if you have an animate present or not
    - change command_checks to lamdas for optimization
  v5.7.10 (2025-02-18)
    - add option for cmd_tether to recast upon death and transfer of dots
  v5.7.9  (2025-02-15)
    - fix stand() to not stand if casting 608 and kneeling with a crossbow in hand
  v5.7.8  (2025-02-11)
    - update $bigshot_status to utilize :ready instead of :hunting when clear to hunt
    - update $bigshot_status to :hunting when arrived in do_hunt() and actually starts hunting
  v5.7.7  (2025-02-10)
    - bugfix in cmd_curse due to custom prep/curse logic
  v5.7.6  (2025-02-08)
    - bugfix where claims was including characters disk
  v5.7.5  (2025-01-30)
    - bugfix in resting method for fog_return
  v5.7.4  (2025-01-22)
    - adjust loop delay for efury and tether
    - bugfix for constant redefinition
    - bugfix in bs_wander when should_flee? is true
  v5.7.3  (2025-01-20)
    - added command tether to have spell 706 wait until completion
    - update to efury command
    - fix for constant redefinition Ruby warnings
  v5.7.2  (2025-01-15)
    - added implosion(720) cooldown
    - added check for voidweaver buff from 720
  v5.7.1  (2025-01-13)
    - added client input into debug file
  v5.7.0  (2025-01-12)
    - added debug logging to file
  v5.6.11 (2025-01-02)
    - added cmd_rapid for rapidfire/515 usage
    - added rapid/!rapid command check for current rapidfire buff
    - bugfix for room claim with disks if SET DESCRIPTION is off
  v5.6.10 (2024-12-22)
    - added optional stand-up stance selection
    - bugfix for surge in cmd_surge and command_check
    - bugfix for burst in command_check
  v5.6.9  (2024-12-09)
    - bugfix for group members in room claim
    - bugfix for weapon reactions to be done in @HUNTING_STANCE
  v5.6.8  (2024-12-06)
    - additional regex for rooted debuff
    - bugfix for leader waiting to regroup during rest cycle
  v5.6.7  (2024-12-06)
    - bugfix for follower not attacking
    - add cmd_wandolier (using fresh wand container and wand name)
  v5.6.6  (2024-12-02)
    - typo in load_settings: 'maxstamina' should be maxstamina
  v5.6.5  (2024-11-23)
    - added test method, usage: ;bigshot test <method> <arg1> <arg2> etc.
    - added ;bigshot list to display initialized values
    - bugfix for out of mana default not an integer
    - update to check_required_values
    - update to load_settings
    - bugfix to allow follower to sit when resting
    - bugfix updating spin button settings
    - $rest_reason wasn't being reset before next hunt
    - bugfix in profile sorting
    - bugfix for leader to wait for wounded follower
    - bugfix unnecessary groupcheck in pre_hunt method
  v5.6.4  (2024-11-18)
    - bugfix for ready_to_hunt stamina check when set to 100
  v5.6.3  (2024-11-14)
    - bugfix for the command check when rooted
  v5.6.2  (2024-11-13
    - prevent UAC from trying to kick when rooted
  v5.6.1  (2024-11-13)
    - bugfix in bandit tracking
    - bugfix in loot() method
    - add msg in class BSAreaRooms if open boundary
  v5.6.0  (2024-09-11)
    - new room claim process inspired by ;overwatch and Lich::Claim
    - additional targeting for bandits
    - bugfix on confusion status to confused
  v5.5.0  (2024-08-24)
    - rework of debug messaging
    - removed duplicate calls to methods
    - once command update for force
    - updated check_required_values for integer Use
    - set defaults for integer settings
    - support for worn items with wield command
  v5.4.5  (2024-08-20)
    - update spinButton to save properly when manually entered
  v5.4.4  (2024-08-19)
    - remove unused GUI elements
  v5.4.3  (2024-08-19)
    - updated wander wait to a spin button
    - bugfix for missing id on lte_boost
    - update OOM spin button to allow for negatives
    - updated OOM check for negative values
  v5.4.2  (2024-08-17)
    - bugfix in cmd_spell to set Spell's @@after_stance to prevent forced stance dancing when hunting_stance is offensive
  v5.4.1  (2024-08-14)
    - room command check logic correction
  v5.4.0  (2024-08-07)
    - UI updates
    - Notes section added on profiles tab
    - percent_stamina added as a should_hunt? parameter
    - wander stance added
  v5.3.17 (2024-08-05)
    - added 506/celerity check
    - fix for hunt_monitor not working for followers
  v5.3.16 (2024-08-04)
    - fix for ROOM being missed in command_check regex
  v5.3.15 (2024-07-25)
    - add ROOM command check, Performs the command a single time only per room, clears on room change
  v5.3.14 (2024-07-24)
    - bugfix for reset_variables
  v5.3.13 (2024-07-19)
    - bugfix for head/tail random looting
    - bugfix for smite tracking in a group
  v5.3.12 (2024-07-13)
    - update profile_current and save_profile_name when using CLI profile load/save
    - bugfix ready_to_rest? should_rest lambda logic
  v5.3.11 (2024-06-20)
    - fix to break from cmd_assault command on cooldown if loop repeated
  v5.3.10 (2024-06-15)
    - added support for Seanette's Shout in Society/Abilities/Spells/Cmans section of the hunting tab
  v5.3.9 (2024-05-29)
    - add additional missing cmd_assault regex matching
  v5.3.8 (2024-05-18)
    - remove superfluous check for escorts, not needed since they are not valid targets
  v5.3.7 (2024-05-01)
    - fix for Char.prof/Char.level to Stats.prof/Stats.level
  v5.3.6 (2024-04-28)
    - add additional custom disk noun
  v5.3.5 (2024-04-24)
    - handle all the new custom disk nouns
  v5.3.4 (2024-03-29)
    - fix to add Tangle Weed (610) status of "entangled" to the PRONE regex
    - fix for kweed command to use EVOKE instead of stancing
  v5.3.3 (2024-03-15)
    - fix for cmd_briar to use MEASURE instead of LOOK due to gamefeed issue with extended show descriptions
    - fix for cmd_briar to support UCS worn gear and two weapon combat
  v5.3.2 (2024-03-12)
    - bugfix in check_required_values
  v5.3.1 (2024-03-11)
    - bugfix for UIDs in boundary rooms and new boundary return outside of hunting area feature
    - added cmd_curse command for Sorcerer spell Curse 715
    - added cmd_store command to store left, right or both, but only if something is in those hands
  v5.3.0 (2023-11-29)
    - added boundary return if character ends up outside hunting area
    - added option to double cast on fog options when returning from the Rift
    - added support for warcry holler buff
    - fixed bug in stand method when command is an array
    - fixed command to standardize to downcase
    - fixed bug in head/tail looting where the leader wasn't waiting for the follower to loot
    - removed $bigshot_briar in favor of Spell[9105]
    - added toggle to check for favor before using voln symbol on hunting tab
    - expanded need_to_loot method for 1108 kills
    - added escape for temporal rift
    - added eachtarget command that attacks each creature in the room eg. (eachtarget force incant 917 until 101 (once), incant 903 (x10))
    - removed change log comments before 5.0.0 and updated wiki
  v5.2.2 (2023-11-21)
    - bugfix causing bs_wander to delay 0.5 seconds longer than needed
    - added Roa'ter and Ooze escape check in bs_wander
  v5.2.1 (2023-11-15)
    - add new efury, caststop, and wield cmd
    - redo unravel/barddispel cmd
  v5.2.0 (2023-10-02)
    - general adjustment to group hunting
    - additions to group looting for exclude individuals as well as allowing for changing looter based on encumbrance
    - changes to try and prevent leaving stray bandits
    - update to prevent targeting 709 arms
    - allows multiple rally rooms just separate with commas
    - added multiple return room waypoints
    - added support for ranger tracking. Usage ;bigshot <options> <creature> example: ;bigshot single giant rat
  v5.1.10 (2023-09-28)
    - bugfix for ;bigshot quick occassionally stopping when another character enters the room
    - changed BIGSHOT_VERSION variable to pull version from title block
    - bugfix for display output
  v5.1.9 (2023-09-24)
    - fix to debug variable being hard set at launch to false.
    - add CLI debug option to toggle debug value between true/false.
  v5.1.8 (2023-09-18)
    - add acid & steam to incant 518 allowances in cmd_spell
  v5.1.7 (2023-09-16)
    - bugfix wracking not considering active COL signs
    - added RT check for wand method
  v5.1.6 (2023-09-12)
    - bugfix for cmd_force when target has 115
  v5.1.5 (2023-08-30)
    - bugfix for calling escape_rooms for tail
  v5.1.4 (2023-08-30)
    - bugfix for Roa'ter and Ooze escape for head/tail
  v5.1.3 (2023-08-26)
    - add 335/Divine Wrath cooldown check in cmd_spell to not cast
    - change cmd_spell to use Spell.force_incant for incanted spells instead of bs_put
  v5.1.2 (2023-08-21)
    - fix incorrect regex match for mighty blow
  v5.1.1 (2023-08-14)
    - fix missing regex match for censer command check
  v5.1.0 (2023-08-07)
    - add ooze_escape for getting out of Ooze, Innards in HW.
  v5.0.0 (2023-07-19)
    - move method spell_is_selfcast? inside Bigshot class
    - corrected deadmans typo
    - moved Setup class outside main Bigshot block
    - renamed various methods to snake case
    - removed changlog notes older than 4.17.0 and updated changelog on wiki
    - bugfix for bearhug complete_regex and in the command check
    - retry RT commands for warrior and rogue guild cmans
    - added rooted to status check
    - bugfix in check_target_vitals
    - bugfix in cast_signs undefined method `=~' for false:FalseClass
=end
=begin
    To do:
      Add more messaging for ambush checks (snipe, etc.)
      Add Stun Relief (108)|Undisease (113)|Unpoison (114) option for stunned group members
      Add Hand of Tonis to dismiss clouds
      Group logic for familiars/companions
      UCS will frequently use the last '$bigshot_unarmed_followup_attack', needs to be cleared
      Need support for tracking multiple NPC positioning tiers for UCS
      Celerity (506) support from grouped wizards for MStrikes
=end
# Check version of Lich for compatibility
lich_gem_requires = Script.list.find { |x| x.name == Script.current.name }.inspect[/required: Lich >= (\d+\.\d+\.\d+)/i, 1]

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires)
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
    _respond "##" + "########################################"
  end
  exit
end

if UserVars
  # Create UserVars.op on first run
  UserVars.op ||= {}

  # First time running a version with monitor strings that can be specified, set up default values
  if UserVars.op["monitor_strings"].nil? || UserVars.op["monitor_strings"].empty?
    UserVars.op["monitor_strings"] = "SEND||POLICY||[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]||speaking to you||unresponsive||taps you||nods to you||lease respond||not in control||violation||lease speak||peak out loud||Y U SHOU D||whispers,||speaking to you||smiles at you||waves to you||grins at you||hugs you||takes hold your hand||grabs your hand||clasps your hand||trying to drag you"
  end

  if UserVars.op["monitor_safe_strings"].nil? || UserVars.op["monitor_safe_strings"].empty?
    UserVars.op["monitor_safe_strings"] = "\[(?!Private)\w*\]-GS(?:T|IV):||We've noted a troubling increase in bandit activity recently||inviting you to join||Dreavening"
  end

  UserVars.save
end

def get_script_version
  data = Script.list.find { |x| x.name == Script.current.name }.inspect
  return data[/version: (\d+\.\d+\.\d+)/i, 1]
end

# All Requirements
require 'yaml'
require 'drb'
require 'fileutils'
require 'logger'

# Make sure the directories exist for loading and saving profiles
FileUtils.mkdir_p(File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles"))

# Global Variables
$bigshot_version = get_script_version
$bigshot_rest_interval = 60
$bigshot_1614_list = []
$bigshot_703_list = []
$bigshot_adrenal_surge = Time.now + 301
$bigshot_aim = 0
$bigshot_ambush = 0
$bigshot_arcane_reflex = false
$bigshot_archery_aim = 0
$bigshot_archery_stuck_location = []
$bigshot_archery_location = nil
$bigshot_bandits = false
$bigshot_bless = []
$bigshot_bond_return = false
$bigshot_cast902 = false
$bigshot_cast411 = false
$bigshot_dislodge_target = nil
$bigshot_dislodge_location = []
$bigshot_debug = false
$bigshot_flee = false
$bigshot_group_status = {}
$bigshot_lte_boost_counter = 0
$bigshot_overkill_counter = 0
$bigshot_quick = false
$bigshot_reaction = nil
$bigshot_should_rest = false
$bigshot_smite_list = []
$bigshot_status = nil
$bigshot_swift_justice = 0
$bigshot_unarmed_followup = false
$bigshot_unarmed_followup_attack = ""
$bigshot_unarmed_tier = 1
$bigshot_rooted = false
$bigshot_wand = 0
$current_script_name = Script.current.name
$current_room_npcs = GameObj.npcs
$last_loot = nil
$looting_inactive = true
$not_hunting_reason = nil
$rest_reason = nil
$room_npcs_last_check = []
$mstrike_taken = false
$bigshot_single = false
$bigshot_sneaky_hunt = false

# debug file logger
class Bigshot
  class DebugLogger
    attr_accessor :logger, :log_file, :script_name

    def initialize
      @script_name = Script.current.name
      # Ensure the debug folder exists
      debug_dir = File.join(LOG_DIR, 'debug', "#{XMLData.game}-#{XMLData.name}")
      FileUtils.mkdir_p(debug_dir) unless Dir.exist?(debug_dir)

      # Set up logger
      @log_writer = Queue.new
      @log_file = File.join(debug_dir, "#{@script_name}.log")
      @logger = Logger.new(@log_file, 'daily')
      @logger.formatter = proc do |_, datetime, _, msg|
        formatted_time = datetime.strftime("%Y-%m-%d %H:%M:%S") # Excludes timezone
        "[#{formatted_time}]: #{msg}\n"
      end

      # Start logging automatically after initialization
      start_logging
    end

    def start_logging
      # Startup Message
      log("Starting up!")

      @worker_thread = Thread.new {
        UpstreamHook.add("debug_upstream_hook", proc { |data|
          @log_writer << ">#{data.sub(/^<c>/, '')}".strip
          data
        })

        DownstreamHook.add("debug_downstream_hook", proc { |data|
          @log_writer << data.strip
          data
        })

        loop do
          current_last = $_LASTUPSTREAM_
          @log_writer.push current_last.sub(/^<c>/, '').strip
          while current_last == $_LASTUPSTREAM_
            sleep 0.1
          end
        end
      }

      @writer_thread = Thread.new do
        loop do
          line = @log_writer.pop
          @logger.info(@script_name) { line } unless line.to_s.strip.empty?
        end
      end

      before_dying {
        @logger.info(@script_name) { "Closing up!" }

        respond("")
        Lich::Messaging.msg("bold", "You've started #{Script.current.name} with debug to file on.")
        Lich::Messaging.msg("bold", "Please remember to turn this option off once done needing to debug.")
        Lich::Messaging.msg("bold", "Currently debugging to #{@log_file}")
        Lich::Messaging.msg("bold", "To turn off, execute #{$clean_lich_char}#{Script.current.name} debug file")
        respond("")

        UpstreamHook.remove("debug_upstream_hook")
        DownstreamHook.remove("debug_downstream_hook")
        @worker_thread.kill
        @writer_thread.kill
        @logger.close
      }

      respond("")
      Lich::Messaging.msg("bold", "You've started #{Script.current.name} with debug to file on.")
      Lich::Messaging.msg("bold", "Please remember to turn this option off once done needing to debug.")
      Lich::Messaging.msg("bold", "Currently debugging to #{@log_file}")
      Lich::Messaging.msg("bold", "To turn off, execute #{$clean_lich_char}#{Script.current.name} debug file")
      respond("")
    end

    # Method to log a custom message
    def log(message)
      @log_writer << message
    end
  end
end

# Event class for grouping
class Bigshot
  class Event
    attr_accessor :type, :created_at, :room_id, :cmd_input

    @@RECOGNIZED = [:HUNTING_PREP_COMMANDS, :HUNTING_SCRIPTS_START, :CAST_SIGNS, :ATTACK, :PREP_REST,
                    :HUNTING_SCRIPTS_STOP, :RESTING_SCRIPTS_START, :RESTING_PREP_COMMANDS, :DISPLAY_WATCH, :START_WATCH, :STOP_WATCH, :SINGLE_STOP,
                    :FOLLOWER_OVERKILL, :STAY_QUIET, :FOLLOW_NOW, :LOOT, :CUSTOM_PUT, :CUSTOM_CMD, :CUSTOM_DO_CLIENT,
                    :PUBLIC_SEND, :GO2_WAYPOINTS, :GO2_RESTING_ROOM, :GO2_RALLY_ROOM, :GO2_HUNTING_ROOM, :CHECK_MIND, :JOIN_LEADER, :FOG_RETURN, :CHECK_SNEAKY,
                    :LEAVE_GROUP, :HUNT_MONITOR_START, :HUNT_MONITOR_STOP]

    def initialize(type, time_stamp, room_id, c_in = nil)
      raise "Event type not recognized" unless @@RECOGNIZED.include?(type)

      @type       = type
      @created_at = time_stamp
      @room_id    = room_id
      @cmd_input  = c_in
    end

    def stale?
      Room.current.id != @room_id || (Time.now.to_i - @created_at) > 15
    end
  end
end

# Check inside boundary class
class Bigshot
  class BSAreaRooms
    attr_reader :start_room, :boundaries, :area_rooms

    def initialize(hunting_room_id, hunting_boundaries)
      @start_room  = hunting_room_id.to_i
      @boundaries  = hunting_boundaries.map(&:to_i).to_set
      @area_rooms  = Set[@start_room]
      @location_changes = []
      @last_location = Room[@start_room]&.location
    end

    def get_valid_neighbors(room_id)
      room = Room[room_id]
      return Set[] unless room

      room.wayto.keys.map(&:to_i).to_set - @boundaries
    end

    def build
      frontier = Set[@start_room]
      visited  = Set[@start_room]
      depth    = 0

      until frontier.empty?
        next_frontier = Set.new

        frontier.each do |room_id|
          neighbors = get_valid_neighbors(room_id)
          new_rooms = neighbors - visited
          next_frontier.merge(new_rooms)

          # Track location changes (for debug)
          track_location_change(room_id)
        end

        break if next_frontier.empty?

        visited.merge(next_frontier)
        @area_rooms.merge(next_frontier)
        frontier = next_frontier
        depth += 1

        if @area_rooms.size >= 200
          boundary_break
        end
      end
    end

    def valid?(room_id = Room.current.id)
      @area_rooms.include?(room_id.to_i)
    end

    def track_location_change(room_id)
      room = Room[room_id]
      return unless room

      current_location = room.location
      if current_location && current_location != @last_location
        @last_location = current_location

        # Only log the first 3 unique changes
        if @location_changes.size < 3
          @location_changes << { id: room_id, location: current_location }
        end
      end
    end

    def boundary_break
      rows = @location_changes.map do |change|
        [change[:id], change[:location]]
      end

      table = Terminal::Table.new(
        title: "Possible Boundary Breaks\nRoom count (#{@area_rooms.size}) >= 200\nPlease review in Hunting tab",
        headings: ['Room ID', 'Location'],
        rows: rows
      )

      respond
      respond table.to_s
      respond
      exit
    end
  end
end

# Group class for head/tail
class Bigshot
  class Group
    include DRbUndumped
    attr_accessor :leader, :members

    def initialize
      @members = Hash.new
    end

    # Helper method to check for offline members
    def member_online
      @members.each do |name, member|
        begin
          yield(name, member)
        rescue
          helper_name = __method__.to_s
          caller_method = caller_locations(1, 20).map(&:label).find { |lbl| lbl !~ /^(block in|each|#{helper_name})/ }
          @leader.message("yellow", "Error in #{caller_method}. Removing #{name}!")
          @members.delete(name)
        end
      end
    end

    def set_leader(leader)
      @leader = leader
    end

    def leader_name
      @leader.name
    end

    def add_member(member)
      @members[member.name] = member
    end

    def size
      return @members.size + 1
    end

    def group_size
      return @members.size
    end

    def get_names
      return @members.keys + [@leader.name]
    end

    def room_id
      return @leader.room_id
    end

    def leader_claim?(**kwargs)
      @leader.bigclaim?(**kwargs)
    end

    def in_group?(name)
      @members.keys.include?(name)
    end

    def looting_done
      member_online do |_, member|
        return false if !member.looting_inactive?
      end

      return true
    end

    def set_group_looting_active
      @members[@leader.designated_looter].set_looting_active
    end

    def looter
      return @leader.designated_looter
    end

    def add_event(type, room = Room.current.id)
      member_online do |_, member|
        member.add_event(type, Time.now.to_i, room)
      end
    end

    # Fixme: this won't work. bounty? returns a string. See def cur_bounty
    def has_bounty?(bounty_regex)
      if !bounty_regex.is_a? Regexp
        @leader.message("yellow", "That's not a Regexp.  Killing Bigshot")
        client_do(";k bigshot")
      end

      @members.each do |name, member|
        begin
          return true if member.cur_bounty =~ bounty_regex
        rescue
          @leader.message("yellow", "Error polling member (has_bounty?). Removing #{name}!")
          @members.delete(name)
        end
      end

      return false
    end

    def group_assist(should_attack)
      member_online do |_, member|
        member.set_help_group(should_attack)
      end
    end

    def add_leader_event(event)
      @leader.add_event(Event.new(event)) unless @leader.event_stack.size > 5
    end

    def return_waypoints_ids
      return @leader.RETURN_WAYPOINT_IDS
    end

    def resting_id
      return @leader.RESTING_ROOM_ID
    end

    def hunting_id
      return @leader.HUNTING_ROOM_ID
    end

    def rally_ids
      return @leader.RALLYPOINT_ROOM_IDS
    end

    def roundtime?
      member_online do |_, member|
        return true if member.rt? > 0
      end

      return false
    end

    # Use this to perform combat actions
    def do_command(command_input)
      member_online do |_, member|
        member.add_event(:CUSTOM_CMD, Time.now.to_i, Room.current.id, command_input)
      end
    end

    # Use this to perform non-combat actions
    def do_put(command_input)
      member_online do |_, member|
        member.add_event(:CUSTOM_PUT, Time.now.to_i, Room.current.id, command_input)
      end
    end

    # Use this to perform actions as if they were typed through the client
    def client_do(command_input)
      member_online do |_, member|
        member.add_event(:CUSTOM_DO_CLIENT, Time.now.to_i, Room.current.id, command_input)
      end
    end

    # Use this to perform actions as if they were typed through the client
    def pub_send(command_input)
      member_online do |_, member|
        member.add_event(:PUBLIC_SEND, Time.now.to_i, Room.current.id, command_input)
      end
    end

    def clear_group_events()
      member_online do |_, member|
        member.clear_events()
      end
    end

    def group_should_hunt?
      if @leader.event_stack.shift
        @leader.clear_events
        return false
      end

      $bigshot_group_status = {}
      member_online do |name, member|
        reason = member.ready_to_hunt?
        $bigshot_group_status[name] = reason unless reason == "ready"
      end

      $bigshot_group_status.empty? ? ($bigshot_status = :ready; true) : false
    end

    def group_bandit_hunting(kill_bandits)
      member_online do |_, member|
        member.set_bandit_hunting(kill_bandits)
      end
    end

    def group_should_rest?
      $bigshot_group_status = {}

      member_online do |name, member|
        if (reason = member.ready_to_rest?)
          $bigshot_group_status[name] = reason
        end
      end

      return !$bigshot_group_status.empty?
    end

    def any_saturated?
      member_online do |_, member|
        return true if member.saturated?
      end

      return false
    end

    def group_encumbrance
      group_weight = {}

      member_online do |name, member|
        current, setting = member.encumbrance?
        group_weight[name] = (setting - current)
      end

      return group_weight
    end

    def need_sneaky?
      member_online do |_, member|
        return true if member.sneaky_hunt? && !member.player_hidden?
      end

      return false
    end

    def all_present?
      sleep(0.1) while Lich::Gemstone::Claim::Lock.locked?

      member_online do |name, member|
        member.ping
        return false unless checkpcs.include?(name)
        return false unless Lich::Gemstone::Group.members.map(&:noun).include?(name)
      end

      return true
    end

    def rest_prep_complete?
      member_online do |_, member|
        return false if !member.rest_prep_done?
      end

      return true
    end

    def emergency_rest?
      member_online do |_, member|
        return true if member.wounded?
      end

      return false
    end
  end
end

# Setup class for UI
class Bigshot
  class Setup < Gtk::Builder
    attr_accessor :settings

    @@categories = {
      general: {
        # Profiles
        profile_current: { default: '' },
        profile_name: { default: '' },
        profile_button: { default: '' },
        save_current: { default: '' },
        profile_save: { default: '' },
        save_profile_name: { default: '' },
        profile_overwrite: { default: '' },
        profile_cancel: { default: '' },
        msg_label: { default: '' },
        no_current_profile: { default: '' },
        notes: { default: '' },

        # Resting
        return_waypoint_ids: { default: '' },
        resting_room_id: { default: '' },
        resting_commands: { default: '' },
        resting_scripts: { default: '' },
        fog_return: { default: '' },
        fog_optional: { default: false },
        custom_fog: { default: '' },
        fog_rift: { default: false },
        fried: { default: '' },
        overkill: { default: '' },
        lte_boost: { default: '' },
        oom: { default: '' },
        encumbered: { default: 101 },
        wounded_eval: { default: '' },
        bounty_eval: { default: '' },
        crushing_dread: { default: '' },
        creeping_dread: { default: '' },
        wot_poison: { default: false },
        confusion: { default: false },
        box_in_hand: { default: false },

        # Hunting
        hunting_room_id: { default: '' },
        rallypoint_room_ids: { default: '' },
        hunting_boundaries: { default: '' },
        rest_till_exp: { default: '' },
        rest_till_mana: { default: '' },
        rest_till_spirit: { default: '' },
        rest_till_percentstamina: { default: '' },
        hunting_stance: { default: '' },
        wander_stance: { default: '' },
        stand_stance: { default: '' },
        hunting_prep_commands: { default: '' },
        hunting_scripts: { default: '' },
        signs: { default: '' },
        loot_script: { default: '' },
        wracking_spirit: { default: '' },
        priority: { default: false },
        delay_loot: { default: false },
        troubadours_rally: { default: false },
        sneaky_sneaky: { default: false },
        use_wracking: { default: false },
        loot_stance: { default: false },
        pull: { default: true },
        deader: { default: true },
        check_favor: { default: false },

        # Attacking
        ambush: { default: '' },
        archery_aim: { default: '' },
        flee_count: { default: 100 },
        invalid_targets: { default: '' },
        always_flee_from: { default: '' },
        flee_message: { default: '' },
        wander_wait: { default: 0.3 },
        boon_flee_from: { default: false },
        flee_clouds: { default: false },
        flee_vines: { default: false },
        flee_webs: { default: false },
        flee_voids: { default: false },
        lone_targets_only: { default: false },
        weapon_reaction: { default: true },
        bless: { default: false },

        # Commands
        hunting_commands: { default: '' },
        hunting_commands_b: { default: '' },
        hunting_commands_c: { default: '' },
        hunting_commands_d: { default: '' },
        hunting_commands_e: { default: '' },
        hunting_commands_f: { default: '' },
        hunting_commands_g: { default: '' },
        hunting_commands_h: { default: '' },
        hunting_commands_i: { default: '' },
        hunting_commands_j: { default: '' },
        disable_commands: { default: '' },
        quick_commands: { default: '' },
        targets: { default: '' },
        quickhunt_targets: { default: '' },

        # Misc
        tier3: { default: '' },
        aim: { default: '' },
        uac_smite: { default: false },
        uac_mstrike: { default: false },
        mstrike_stamina_cooldown: { default: '' },
        mstrike_stamina_quickstrike: { default: '' },
        mstrike_mob: { default: '' },
        mstrike_cooldown: { default: false },
        mstrike_quickstrike: { default: false },
        ammo_container: { default: '' },
        ammo: { default: '' },
        fresh_wand_container: { default: '' },
        dead_wand_container: { default: '' },
        wand: { default: '' },
        hide_for_ammo: { default: false },
        wand_if_oom: { default: false },
        independent_travel: { default: false },
        independent_return: { default: false },
        ma_looter: { default: '' },
        never_loot: { default: '' },
        random_loot: { default: false },
        final_loot: { default: false },

        # Monitoring
        dead_man_switch: { default: false },
        depart_switch: { default: false },
        quiet_followers: { default: true },
        monitor_interaction: { default: false },
        ignore_disks: { default: false },
        monitor_strings: { default: '' },
        monitor_safe_strings: { default: '' },
      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?

      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()
      @settings = settings
      @silent_exit = false

      # set default values if they don't exist
      @@categories.each do |_, data|
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end

      # remove settings that doesn't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }
      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        # add_from_file("#{$data_dir}bigshot_no_ring.ui")
        add_from_string(Setup.ui)
        load_settings
        set_tooltips
        self['main'].keep_above = true
        self['main'].set_title "Big Shot: v#{$bigshot_version}"

        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    def self.setup
      settings = UserVars.op.dup

      # convert the strings to symbol
      settings = settings.transform_keys(&:to_sym)

      # echo settings
      Setup.new(settings).start
    end

    def self.ui
      '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkAdjustment" id="creeping_dread_adjustment"><property name="upper">100</property><property name="step-increment">1</property><property name="page-increment">10</property>
      </object><object class="GtkAdjustment" id="crushing_dread_adjustment"><property name="upper">100</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="encumbered_adjustment"><property name="upper">101</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="flee_count_adjustment"><property name="upper">100</property><property name="step-increment">1</property><property name="page-increment">10</property>
      </object><object class="GtkAdjustment" id="fried_adjustment"><property name="lower">-50</property><property name="upper">150</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="lte_boost_adjustment"><property name="upper">100</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="oom_adjustment"><property name="lower">-100</property><property name="upper">100</property><property name="step-increment">1</property><property name="page-increment">10</property>
      </object><object class="GtkAdjustment" id="overkill_adjustment"><property name="upper">1000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="rest_till_exp_adjustment"><property name="lower">-50</property><property name="upper">150</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="rest_till_mana_adjustment"><property name="lower">-50</property><property name="upper">150</property><property name="step-increment">1</property><property name="page-increment">10</property>
      </object><object class="GtkAdjustment" id="rest_till_spirit_adjustment"><property name="lower">-50</property><property name="upper">150</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="rest_till_stamina"><property name="lower">-100</property><property name="upper">100</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="wander_wait_adjustment"><property name="upper">100</property><property name="step-increment">0.10</property><property name="page-increment">10</property>
      </object><object class="GtkAdjustment" id="wracking_spirit_adjustment"><property name="lower">-50</property><property name="upper">150</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkWindow" id="main"><property name="can-focus">False</property><property name="title" translatable="yes">Bigshot Setup</property><property name="default-width">1120</property><property name="default-height">750</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkComboBoxText" id="profile_name"><property name="height-request">42</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">20</property><property name="has-entry">True</property><child internal-child="entry"><object class="GtkEntry"><property name="width-request">400</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="profile_button"><property name="label" translatable="yes">Load Profile</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">30</property><property name="margin-top">19</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">18</property><property name="margin-top">10</property><property name="label" translatable="yes">Current Profile:</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property>
      </packing></child><child><object class="GtkEntry" id="profile_current"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">18</property><property name="margin-bottom">10</property><property name="editable">False</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel" id="msg_label"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-end">10</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="width">2</property><property name="height">3</property></packing></child><child><object class="GtkButton" id="save_current"><property name="label" translatable="yes">Update Profile</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Saves setting changes to the current profile.</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">30</property><property name="margin-bottom">15</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel" id="no_current_profile"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-bottom">10</property><property name="label" translatable="yes">label</property><attributes><attribute name="foreground" value="#a5a51d1d2d2d"/></attributes></object><packing><property name="left-attach">0</property><property name="top-attach">3</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Load Profile</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-bottom">5</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkButton" id="profile_save"><property name="label" translatable="yes">Save Current Settings as...</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">15</property><property name="margin-top">10</property><property name="margin-bottom">5</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="save_profile_name"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-bottom">15</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property>
      </packing></child><child><object class="GtkLabel" id="test_label"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">15</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="label" translatable="yes">label</property><attributes><attribute name="foreground" value="#a5a51d1d2d2d"/></attributes></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkButton" id="profile_overwrite"><property name="label" translatable="yes">Save Profile</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">15</property><property name="margin-end">15</property><property name="margin-top">20</property><property name="margin-bottom">13</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="profile_cancel"><property name="label" translatable="yes">Cancel</property><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-end">10</property><property name="margin-top">20</property><property name="margin-bottom">13</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Save Profile</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
      </packing></child><child><object class="GtkFrame"><property name="width-request">600</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="border-width">10</property><property name="label-xalign">0</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><child><object class="GtkTextView" id="notes"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-bottom">5</property><property name="wrap-mode">word</property>
      </object></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Notes</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property></packing></child><child><!-- n-columns=1 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="border-width">10</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Bigshot is designed to handle combat routines, including moving to and from hunting areas, defining creatures to hunt and accompanying attack routines
      Afk scripting on any server but Shattered is in violation of game policy.

      Additional details available on the Gemstone Wiki: &lt;a href="https://gswiki.play.net/Lich:Script_Bigshot" title="Bigshot Wiki"&gt;https://gswiki.play.net/Lich:Script_Bigshot&lt;/a&gt;</property><property name="use-markup">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">3</property></packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Profiles</property>
      </object><packing><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">20</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=8 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">percentmind &gt;=</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">extra kills &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">used lte boosts &gt;=</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">percentmana &lt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">percent encumbrance &gt;=</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">50</property><property name="margin-top">10</property><property name="label" translatable="yes">creeping dread &gt;=</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">crushing dread &gt;=</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="wot_poison"><property name="label" translatable="yes">Wall of Thorns Poison</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">45</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="confusion"><property name="label" translatable="yes">Confusion Debuff</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">45</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">3</property><property name="width">2</property></packing></child><child><object class="GtkFrame"><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">15</property><property name="label-xalign">0</property><child><object class="GtkTextView" id="wounded_eval"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-bottom">5</property><property name="border-width">0</property><property name="wrap-mode">word</property>
      </object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Wounded Eval</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">5</property><property name="width">4</property><property name="height">3</property></packing></child><child><object class="GtkSpinButton" id="fried"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="text" translatable="yes">0</property><property name="adjustment">fried_adjustment</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkSpinButton" id="overkill"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="text" translatable="yes">0</property><property name="adjustment">overkill_adjustment</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkSpinButton" id="lte_boost"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="text" translatable="yes">0</property><property name="adjustment">lte_boost_adjustment</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkSpinButton" id="oom"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="text" translatable="yes">0</property><property name="adjustment">oom_adjustment</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkSpinButton" id="encumbered"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="adjustment">encumbered_adjustment</property></object><packing><property name="left-attach">1</property><property name="top-attach">4</property>
      </packing></child><child><object class="GtkSpinButton" id="creeping_dread"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">10</property><property name="adjustment">creeping_dread_adjustment</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkSpinButton" id="crushing_dread"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">10</property><property name="text" translatable="yes">0</property><property name="adjustment">crushing_dread_adjustment</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="box_in_hand"><property name="label" translatable="yes">Box in hand after looting</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">45</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">4</property></packing></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Should Rest?</property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=13 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkComboBoxText" id="fog_return"><property name="width-request">200</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="active">0</property><property name="has-entry">True</property><items><item id="0" translatable="yes">None</item><item id="1" translatable="yes">Spirit Guide (130)</item><item id="2" translatable="yes">Voln Symbol of Return</item><item id="3" translatable="yes">Travelers Song (1020)</item><item id="4" translatable="yes">GoS Sigil of Escape</item><item id="5" translatable="yes">Familiar Gate (930)</item><item id="6" translatable="yes">Custom</item>
      </items><child internal-child="entry"><object class="GtkEntry"><property name="can-focus">False</property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Fog Options</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property>
      </packing></child><child><object class="GtkCheckButton" id="fog_optional"><property name="label" translatable="yes"> Fog ONLY if wounded or encumbered</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="fog_rift"><property name="label" translatable="yes"> Fog twice if returning from the rift</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">8</property></packing></child><child><object class="GtkEntry" id="resting_room_id"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Resting Room ID:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="resting_commands"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-bottom">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Pre-rest Commands:</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="resting_scripts"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Active Resting Scripts:</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Return Waypoint IDs:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="return_waypoint_ids"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">(optional list of rooms)</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="custom_fog"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">11</property><property name="placeholder-text" translatable="yes">Enter custom fog commands (enable in dropdown)</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">6</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object>
      </child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Where to Rest</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
      </packing></child></object></child></object></child></object><packing><property name="position">1</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Resting</property></object><packing><property name="position">1</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=5 n-rows=16 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Attack Stance:</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="hunting_prep_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property></object><packing><property name="left-attach">3</property><property name="top-attach">3</property><property name="width">2</property>
      </packing></child><child><object class="GtkEntry" id="hunting_scripts"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property></object><packing><property name="left-attach">3</property><property name="top-attach">4</property><property name="width">2</property></packing></child><child><object class="GtkEntry" id="signs"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="placeholder-text" translatable="yes">Mouse over for more info.</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">5</property><property name="width">2</property></packing></child><child><object class="GtkEntry" id="loot_script"><property name="width-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property></object><packing><property name="left-attach">3</property><property name="top-attach">6</property><property name="width">2</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Pre-hunt Commands:</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Active Hunting Scripts:</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">30</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Society Abilities/Spells/Cmans:</property></object><packing><property name="left-attach">2</property><property name="top-attach">5</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Loot Script:</property><property name="single-line-mode">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">6</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Wracking Spirit &gt;=</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="priority"><property name="label" translatable="yes">Priority Hunt</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">9</property></packing></child><child><object class="GtkCheckButton" id="delay_loot"><property name="label" translatable="yes">Delay Looting</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">10</property></packing></child><child><object class="GtkCheckButton" id="troubadours_rally"><property name="label" translatable="yes">Troubadour\'s Rally</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">12</property></packing></child><child><object class="GtkCheckButton" id="sneaky_sneaky"><property name="label" translatable="yes">Sneaky Sneaky</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">11</property></packing></child><child><object class="GtkCheckButton" id="use_wracking"><property name="label" translatable="yes">Use sign of wracking/sigil of power/symbol of mana</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">9</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="loot_stance"><property name="label" translatable="yes">Defensive stance before looting</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">10</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="pull"><property name="label" translatable="yes">Pull players to feet</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">11</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="deader"><property name="label" translatable="yes">Stop for dead players</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="valign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">12</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="check_favor"><property name="label" translatable="yes">Check favor before casting symbols</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">13</property><property name="width">2</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">30</property><property name="margin-top">5</property><property name="label" translatable="yes">when percentmind &lt;=</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">and percentmana &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">5</property><property name="label" translatable="yes">and checkspirit &gt;=</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkSpinButton" id="rest_till_exp"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-top">5</property><property name="text" translatable="yes">0</property><property name="adjustment">rest_till_exp_adjustment</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkSpinButton" id="rest_till_mana"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="text" translatable="yes">0</property><property name="adjustment">rest_till_mana_adjustment</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing>
      </child><child><object class="GtkSpinButton" id="rest_till_spirit"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-bottom">5</property><property name="text" translatable="yes">0</property><property name="adjustment">rest_till_spirit_adjustment</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkSpinButton" id="rest_till_percentstamina"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-bottom">5</property><property name="text" translatable="yes">0</property><property name="adjustment">rest_till_stamina</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">5</property><property name="label" translatable="yes">and percentstamina &gt;=</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child>
      </object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Should Hunt?</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">7</property><property name="height">7</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=6 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="hunting_room_id"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-bottom">5</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="rallypoint_room_ids"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkEntry" id="hunting_boundaries"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Starting Room ID:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Rallypoint Room IDs:</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">35</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Boundary Room IDs:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Bigshot will not enter boundary rooms.
            The goal is to pin yourself into a hunting area.</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property><property name="width">2</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Hunting Map</property>
      </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property><property name="height">7</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Wander Stance:</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkComboBoxText" id="attack_drop"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="has-entry">True</property><items><item id="Offensive" translatable="yes">Offensive</item><item id="Advance" translatable="yes">Advance</item><item id="Forward" translatable="yes">Forward</item><item id="Neutral" translatable="yes">Neutral</item><item id="Guarded" translatable="yes">Guarded</item><item translatable="yes">Defensive</item>
      </items><child internal-child="entry"><object class="GtkEntry" id="hunting_stance"><property name="can-focus">True</property></object></child></object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkComboBoxText" id="wander_drop"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="has-entry">True</property><items><item id="Offensive" translatable="yes">Offensive</item><item id="Advance" translatable="yes">Advance</item><item id="Forward" translatable="yes">Forward</item><item id="Neutral" translatable="yes">Neutral</item><item id="Guarded" translatable="yes">Guarded</item><item translatable="yes">Defensive</item>
      </items><child internal-child="entry"><object class="GtkEntry" id="wander_stance"><property name="can-focus">True</property></object></child></object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="wracking_spirit"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="text" translatable="yes">0</property><property name="adjustment">wracking_spirit_adjustment</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">8</property><property name="width">2</property></packing></child><child><object class="GtkComboBoxText" id="stand_drop"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="has-entry">True</property><items><item id="Offensive" translatable="yes">Offensive</item><item id="Advance" translatable="yes">Advance</item><item id="Forward" translatable="yes">Forward</item><item id="Neutral" translatable="yes">Neutral</item><item id="Guarded" translatable="yes">Guarded</item><item translatable="yes">Defensive</item>
      </items><child internal-child="entry"><object class="GtkEntry" id="stand_stance"><property name="can-focus">True</property></object></child></object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Stand-up Stance:</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/>
      </child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
      </packing></child></object></child></object></child></object><packing><property name="position">2</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Hunting</property></object><packing><property name="position">2</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=2 n-rows=13 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="ambush"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="archery_aim"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Ambush aiming locations (head, etc):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">Archery aiming locations (head, etc):</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing>
      </child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Flee if enemy count is &gt;</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">100</property><property name="margin-end">10</property><property name="label" translatable="yes">Note: Use nouns or name for flee info (case sensative).
      Mouse over some hunting commands field for more info.</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">11</property><property name="height">2</property></packing></child><child><object class="GtkEntry" id="invalid_targets"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
      </packing></child><child><object class="GtkEntry" id="always_flee_from"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkEntry" id="flee_message"><property name="width-request">400</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">5</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">...but don\'t count these:</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">...and always flee from</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Flee from environmental message:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">5</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Wait before wandering to another room</property></object><packing><property name="left-attach">0</property><property name="top-attach">6</property>
      </packing></child><child><object class="GtkCheckButton" id="boon_flee_from"><property name="label" translatable="yes">Flee from Boon/Boss/Glamour creatures</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="lone_targets_only"><property name="label" translatable="yes">Approach Lone Targets Only</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="weapon_reaction"><property name="label" translatable="yes">Activate Weapon Reactions</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will initiate reactive strikes when the opportunity presents itself.</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">9</property></packing></child><child><object class="GtkCheckButton" id="bless"><property name="label" translatable="yes">Bless Weapon?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">20</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">7</property></packing></child><child><object class="GtkCheckButton" id="flee_clouds"><property name="label" translatable="yes">Flee from Clouds</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">8</property></packing></child><child><object class="GtkCheckButton" id="flee_vines"><property name="label" translatable="yes">Flee from Vines</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">9</property></packing></child><child><object class="GtkCheckButton" id="flee_webs"><property name="label" translatable="yes">Flee from Webs</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">10</property></packing></child><child><object class="GtkCheckButton" id="flee_voids"><property name="label" translatable="yes">Flee from Voids</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">11</property></packing></child><child><object class="GtkSpinButton" id="flee_count"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="text" translatable="yes">0</property><property name="adjustment">flee_count_adjustment</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkSpinButton" id="wander_wait"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="text" translatable="yes">0.0</property><property name="adjustment">wander_wait_adjustment</property><property name="digits">1</property></object><packing><property name="left-attach">1</property><property name="top-attach">6</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object><packing><property name="position">3</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Attacking</property>
      </object><packing><property name="position">3</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=4 n-rows=10 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="hunting_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="hunting_commands_b"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkEntry" id="hunting_commands_c"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Hunting Commands (a):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">10</property><property name="label" translatable="yes">Hunting Commands (b):</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Hunting Commands (c):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="hunting_commands_d"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
      </packing></child><child><object class="GtkEntry" id="hunting_commands_e"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkEntry" id="hunting_commands_f"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">5</property></packing></child><child><object class="GtkEntry" id="hunting_commands_g"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">6</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Hunting Commands (d):</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Hunting Commands (e):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Hunting Commands (f):</property></object><packing><property name="left-attach">0</property><property name="top-attach">5</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Hunting Commands (g):</property></object><packing><property name="left-attach">0</property><property name="top-attach">6</property></packing></child><child><object class="GtkEntry" id="hunting_commands_h"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">7</property></packing></child><child><object class="GtkEntry" id="hunting_commands_i"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">8</property>
      </packing></child><child><object class="GtkEntry" id="hunting_commands_j"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">9</property></packing></child><child><object class="GtkEntry" id="disable_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">5</property></packing></child><child><object class="GtkEntry" id="quick_commands"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">3</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Hunting Commands (h):</property></object><packing><property name="left-attach">0</property><property name="top-attach">7</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Hunting Commands (i):</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">8</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Hunting Commands (j):</property></object><packing><property name="left-attach">0</property><property name="top-attach">9</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Fried Commands:</property></object><packing><property name="left-attach">2</property><property name="top-attach">5</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Quick Commands:</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="targets"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Valid Targets:</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="quickhunt_targets"><property name="width-request">350</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">65</property><property name="margin-top">10</property><property name="label" translatable="yes">Quickhunt Targets:</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">3</property><property name="top-attach">4</property></packing></child><child><placeholder/>
      </child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
      </packing></child></object></child></object></child></object><packing><property name="position">4</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Commands</property></object><packing><property name="position">4</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><!-- n-columns=4 n-rows=11 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">30</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="tier3"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">15</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-top">15</property><property name="label" translatable="yes">Tier 3 Attack:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="aim"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">11</property><property name="margin-top">10</property><property name="label" translatable="yes">Aim at location (head, etc):</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkCheckButton" id="uac_smite"><property name="label" translatable="yes">Use Voln SMITE?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">15</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkCheckButton" id="uac_mstrike"><property name="label" translatable="yes">Do Not Mstrike.</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">UAC</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property><property name="height">4</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">15</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="mstrike_stamina_cooldown"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">15</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">15</property><property name="label" translatable="yes">MStrike during cooldown stamina requirement:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="mstrike_stamina_quickstrike"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">QuickStrike stamina requirement:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="mstrike_mob"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Unfocused MStrike when Creatures &gt;=</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="mstrike_cooldown"><property name="label" translatable="yes">MStrike during cooldown</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">end</property><property name="margin-end">15</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="mstrike_quickstrike"><property name="label" translatable="yes">Use QuickStrike for MStrike</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">MStrike</property></object></child></object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="width">2</property><property name="height">4</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">30</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=7 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="ammo_container"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Find ammo in this container:</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="ammo"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Use this ammo type:</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="fresh_wand_container"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Fresh wand container</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="dead_wand_container"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Dead wand container</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="wand"><property name="width-request">30</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="label" translatable="yes">Use this wand type</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkCheckButton" id="hide_for_ammo"><property name="label" translatable="yes">Hide to pick up ammo</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">15</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">5</property></packing></child><child><object class="GtkCheckButton" id="wand_if_oom"><property name="label" translatable="yes">Use wands when out of mana</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">6</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Ammo/Wands</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">4</property><property name="width">2</property><property name="height">7</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-end">15</property><property name="margin-top">20</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=7 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkEntry" id="ma_looter"><property name="width-request">342</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="placeholder-text" translatable="yes">optional: Defaults to group leader</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="label" translatable="yes">List of Characters that should never loot</property></object><packing><property name="left-attach">0</property><property name="top-attach">5</property><property name="width">2</property>
      </packing></child><child><object class="GtkEntry" id="never_loot"><property name="width-request">280</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-end">10</property><property name="margin-top">4</property><property name="placeholder-text" translatable="yes">Character names separated by commas: Character1, Character2...</property></object><packing><property name="left-attach">0</property><property name="top-attach">6</property><property name="width">2</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">10</property><property name="label" translatable="yes">Primary Looter</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkCheckButton" id="random_loot"><property name="label" translatable="yes">Loot randomly based on lowest encumbrance</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="independent_travel"><property name="label" translatable="yes">Travel TO hunting grounds independently</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="independent_return"><property name="label" translatable="yes">Travel FROM hunting grounds independently</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="final_loot"><property name="label" translatable="yes">Leader performs a final loot before leaving the room</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property><property name="width">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">MA Grouping</property></object></child></object><packing><property name="left-attach">2</property><property name="top-attach">4</property><property name="width">2</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing>
      </child></object></child></object></child></object><packing><property name="position">5</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object><packing><property name="position">5</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=1 n-rows=7 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="monitor_interaction"><property name="label" translatable="yes">Monitor Interactions</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkFrame"><property name="width-request">600</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">50</property><property name="margin-top">10</property><property name="label-xalign">0</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><child><object class="GtkTextView" id="monitor_strings"><property name="visible">True</property><property name="can-focus">True</property><property name="wrap-mode">word</property>
      </object></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Watch for strings (or regexes) that contain</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">5</property></packing></child><child><object class="GtkFrame"><property name="width-request">600</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">50</property><property name="margin-top">10</property><property name="label-xalign">0</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><child><object class="GtkTextView" id="monitor_safe_strings"><property name="visible">True</property><property name="can-focus">True</property><property name="wrap-mode">word</property>
      </object></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">....except if they also contain</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">6</property></packing></child><child><object class="GtkCheckButton" id="dead_man_switch"><property name="label" translatable="yes">Engage dead man\'s switch (Shattered Only)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="depart_switch"><property name="label" translatable="yes">Depart/rerun if dead</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="quiet_followers"><property name="label" translatable="yes">Quiet Followers</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="ignore_disks"><property name="label" translatable="yes">Ignore disks without obvious hiders</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object><packing><property name="position">6</property>
      </packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Monitoring</property></object><packing><property name="position">6</property><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">20</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes">To save properly, exit with the close button and not the X window. --&gt;</property><attributes><attribute name="style" value="italic"/>
      </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
      </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      self['no_current_profile'].hide
      self['test_label'].hide
      self['profile_save'].show
      self['save_profile_name'].show

      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::RadioButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::Button
          if obj.builder_name.to_s == "save_current"
            save_profile_changes
          end

          if obj.builder_name.to_s == "profile_button"
            on_profile_load
          end

          if obj.builder_name.to_s == "profile_save"
            save_profile
          end

          if obj.builder_name.to_s == "profile_overwrite"
            self['profile_overwrite'].hide
            self['profile_cancel'].hide
            File.write(@filename, @settings.to_yaml)
            self['test_label'].text = "The profile has been saved to \n#{@filename}"
            self['profile_current'].text = self['save_profile_name'].text
            self['save_profile_name'].text = ''
            self['test_label'].text = "The profile has been saved to #{@filename}"
            self['save_profile_name'].hide
            self['profile_save'].hide
            self['test_label'].show
          end

          if obj.builder_name.to_s == "profile_cancel"
            self['profile_overwrite'].hide
            self['profile_cancel'].hide
            self['test_label'].text = "The profile save has been canceled"
            self['save_profile_name'].text = ''
            self['profile_save'].show
          end

        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        #  echo "@settings[key]: #{@settings[key]} key: #{key} obj.text.strip: #{obj.text.strip}"
        elsif obj.class == Gtk::TextView
          @settings[key] = obj.buffer.text
        elsif obj.class == Gtk::SpinButton
          @settings[key] = obj.buffer.text
        elsif obj.class == Gtk::ComboBoxText
          if obj.builder_name.to_s == "fog_return"
            @settings[key] = obj.active_id

            if obj.active_id.to_i == 6
              self['custom_fog'].set_sensitive(true)
            else
              self['custom_fog'].set_sensitive(false)
            end
          else
            @settings[key] = obj.active_text
          end
        end
      end
    end

    def on_profile_load
      if @settings[:profile_name].empty?
        return
      end

      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")

      filename = @settings[:profile_name] + ".yaml"
      profile = File.join(dir, filename)
      from_file = YAML.load_file(profile)
      @settings = from_file.transform_keys(&:to_sym)
      self['profile_current'].text = self['profile_name'].active_text
      self['profile_name'].set_active(0)

      load_settings(false)
    end

    def on_drop_load
      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")

      self['profile_name'].remove_all
      self['profile_name'].append_text('')

      names = Dir.children(dir).sort
      names.each { |filename|
        next unless filename =~ /.yaml/
        self['profile_name'].append_text("#{filename.sub(".yaml", "")}")
      }
    end

    def set_tooltips
      # Profile Tab

      # Message on Profile tab
      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
      msg = "This drop down shows profiles available at the new save location.\nThe location was changed to enable settings organized by character.\n\n"
      msg += "The new bigshot default profile location...\n#{dir}\n\n"
      msg += "The original location is here...\n#{File.join($script_dir, 'bigshot_profiles')}"
      self['msg_label'].text = msg
      # Profile dropdown
      self['profile_name'].tooltip_text = ''
      # Load Profile Button
      self['profile_button'].tooltip_text = ''
      # Current Profile Textbox
      self['profile_current'].tooltip_text = ''
      # Save Changes Button
      self['save_current'].tooltip_text = ''
      # Save Current Settings
      self['profile_save'].tooltip_text = ''
      # Save Current Textbox
      self['save_profile_name'].tooltip_text = ''
      # Save Profile Button
      self['profile_overwrite'].tooltip_text = ''
      # Cancel Button
      self['profile_cancel'].tooltip_text = ''
      # Notes
      self['notes'].tooltip_text = ''

      # Resting Tab

      # Resting Room ID
      self['return_waypoint_ids'].tooltip_text = ''
      self['resting_room_id'].tooltip_text = "Supports traditional room numbers as well as uid's (ex u7000)"
      # Pre-rest Commands
      self['resting_commands'].tooltip_text = ''
      # Active Resting Scripts
      self['resting_scripts'].tooltip_text = ''
      # Fog Options
      fog_tooltip  = "None: Dont use any fog options when you return from a hunt\n\nSpirit Guide(130): Use 130 first, then if that fails Symbol of Return\n\n"
      fog_tooltip += "Voln Symbol of Return: Use Symbol of Return first, then if that fails 130\n\n"
      fog_tooltip += "Traveler's Song(1020): Use 1020 only\n\n"
      fog_tooltip += "GoS Sigil of Escape: Use Sigil of Escape\n\nFamiliar Gate(930): Summon familiar gate and go thru portal\n\nCuston: performs commands in box below."
      self['fog_return'].tooltip_text = fog_tooltip
      # Custome fog
      self['custom_fog'].tooltip_text = "Ex1: script teleport 3\n\nEx2: get key from my cloak, turn my key, put key in my cloak\n\nEx3: script go2 <ring room>, remove my ring, wear my ring"
      # Fog Checkbox
      self['fog_optional'].tooltip_text = ''
      # Fog from Rift
      self['fog_rift'].tooltip_text = 'Only works for symbol of return and spell 130'
      # when percentmind
      self['fried'].tooltip_text = "Percentage of your mind (0-100) after which you will stop hunting.\n   101  will hunt until mana/encumbrance/wounded\n   100  is fully fried"
      # and extra kills
      self['overkill'].tooltip_text = "This is the number of additional monsters to kill after reaching your fried threshold.\nLeave blank to not kill any extra monsters"
      # and used lte boosts
      self['lte_boost'].tooltip_text = ''
      # or percent mana
      self['oom'].tooltip_text = ''
      # or Char.percent_encumbrance
      self['encumbered'].tooltip_text = ''
      # box in hand after looting
      self['box_in_hand'].tooltip_text = "When checked, will force resting mode if box is left in your hand after looting.\n\nLikely due to no space or to heavy of a box."
      # or wound eval
      self['wounded_eval'].tooltip_text = ''

      # Hunting Tab

      # Starting Room ID
      self['hunting_room_id'].tooltip_text = "Supports traditional room numbers as well as uid's (ex u7000)"
      # Rally Point ID
      rally_tooltip = "Supports an array of numbers - ex. 228, 227, 225 \n"
      rally_tooltip += "If left blank, will set to starting room ID.\n"
      rally_tooltip += "Set to a safe room BEFORE your hunting start point that you want to stop to cast your active hunting spells/signs/sigils/signs and start your active hunting scripts.\n\n"
      rally_tooltip += "If in a group, and this is the head, then will wait here for all tails before casting your active hunting spells/signs/sigils/signs and start your active hunting scripts.\n\n"
      rally_tooltip += "Use Case Example 1: You are hunting somewhere far away and dont want to cast Wall of Force before walking for half the duration.\n\n"
      rally_tooltip += "Use Case Example 2: You want to stop before your climb to start your sigils because there is a climb ahead."
      rally_tooltip += "Supports traditional room numbers as well as uid's (ex u7000)"
      self['rallypoint_room_ids'].tooltip_text = rally_tooltip
      # Boundary Rooms
      self['hunting_boundaries'].tooltip_text = "Supports traditional room numbers as well as uid's (ex u7000)"
      # when percentmind
      self['rest_till_exp'].tooltip_text = "Accurately calculates percentmind now."
      # and Char.percent_mana
      self['rest_till_mana'].tooltip_text = ''
      # and Char.spirit
      self['rest_till_spirit'].tooltip_text = ''
      # and Char.percent_stamina
      self['rest_till_percentstamina'].tooltip_text = ''
      # Attack Stance
      self['hunting_stance'].tooltip_text = ''
      # Wander stance
      self['wander_stance'].tooltip_text = ''
      # Pre-hunt Commands
      self['hunting_prep_commands'].tooltip_text = ''
      # Active Hunting Scripts
      self['hunting_scripts'].tooltip_text = ''
      # Society Abilities/Spells/Cmans
      signs_tooltip  = "Shadow Mastery - 9603\nSurge of Strength - 9605\n\nSigil of Contact - 9703\nSigil of Resolve - 9704\nSigil of Minor Bane - 9705\nSigil of Defense - 9707\nSigil of Offense - 9708\n"
      signs_tooltip += "Sigil of Minor Protection - 9710\nSigil of Focus - 9711\nSigil of Mending - 9713\nSigil of Concentration - 9714\nSigil of Major Bane - 9715\nSigil of Major Determination - 9716\nSigil of Major Protection - 9719\n\n"
      signs_tooltip += "Sign of Warding - 9903\nSign of Striking - 9904\nSign of Thought - 9906\nSign of Defending - 9907\nSign of Smiting - 9908\nSign of Staunching - 9909\nSign of Deflection - 9910\n"
      signs_tooltip += "Sign of Swords - 9912\nSign of Shields - 9913\nSign of Dissipation - 9914\nSign of Madness - 9916\n\n"
      signs_tooltip += "Symbol of Courage - 9805\nSymbol of Protection - 9806\nSymbol of Supremacy - 9816\n\nBarkskin - 605\nFasthr's Reward - 115\n\nSeanette's Shout - 122420\n\n"
      self['signs'].tooltip_text = signs_tooltip
      # Loot Script
      self['loot_script'].tooltip_text = ''
      # Wracking Spirit
      self['wracking_spirit'].tooltip_text = ''
      # Priority Hunt
      self['priority'].tooltip_text = "Priority is based on order of valid targets box on hunting tab.\nWill switch to highest priority in room when attacking."
      # SNEAKY_SNEAKY
      self['sneaky_sneaky'].tooltip_text = "Sneak around while hunting."
      # Delay Looting
      self['delay_loot'].tooltip_text = ''
      # Troubadour's Rally
      self['troubadours_rally'].tooltip_text = "Shout 1040 when you or your group members are incapacitated."
      # Use Sign of Wracking/Sigil of Power/Symbol of Mana
      self['use_wracking'].tooltip_text = ''
      # Def Stance before Looting
      self['loot_stance'].tooltip_text = ''
      # Pull Players to Feet
      self['pull'].tooltip_text = ''
      # Stop for Deaders
      self['deader'].tooltip_text = ''

      # Attack Tab

      # Ambush aiming location
      self['ambush'].tooltip_text = ''
      # Archery aiming location
      self['archery_aim'].tooltip_text = ''
      # Flee enemy count
      self['flee_count'].tooltip_text = ''
      # but don't coint these
      self['invalid_targets'].tooltip_text = ''
      # Always flee from
      self['always_flee_from'].tooltip_text = ''
      # Flee from environmental msg
      flee_msg  = "Input any text that when the game sends you want to move out of the room...\n"
      flee_msg += 'like a Roa\'ter burrow attack \\"You feel a rumble come from beneath your feet."\\'
      flee_msg += "\nSeperate different messages with a | in between them.\nText compares to XML feed, not plain text."
      self['flee_message'].tooltip_text = flee_msg
      # Wait before wandering
      self['wander_wait'].tooltip_text = ''
      # Flee from boon/boss/glamour creatures
      self['boon_flee_from'].tooltip_text = ''
      # Flee from clouds
      self['flee_clouds'].tooltip_text = ''
      # Flee from vines
      self['flee_vines'].tooltip_text = ''
      # Flee from webs
      self['flee_webs'].tooltip_text = ''
      # Flee from voids
      self['flee_voids'].tooltip_text = ''
      # Approach lone targets only
      self['lone_targets_only'].tooltip_text = ''
      # Activate weapon reactions
      self['weapon_reaction'].tooltip_text = "Will initiate reactive strikes when the opportunity presents itself."
      # Bless Weapons
      self['bless'].tooltip_text = "If checked, will stop hunt when item's blesses run out.\nIf unchecked, will continue to hunt and remind to get blesses while resting."

      # Commands Tab

      # hunting_commands(a)
      hunting_tooltip  = "Example 1: incant 413, incant 903\nExample 2: incant 903 (x2)\nExample 3: incant 903 (x5)\nExample 4: incant 910 (m50), incant 903\nExample 5: unarmed punch, wait 30\n\n"
      hunting_tooltip += "Example 1 will cast 413 then 903 on the target.\nExample 2 will cast 903 on the target twice.\nExample 3 will cast 903 on the target five times.\n"
      hunting_tooltip += "Example 4 will cast 910 if mana is at least 50, otherwise it will cast 903.\nExample 5 will start the unarmed routine with punch as the main attack. It will attack once, then wait 30 seconds for another attack to happen before attacking again.\n"
      hunting_tooltip += "Separate all commands with commas.\nMore examples available on the Wiki.\n\nNew feature: 'and'.\nFor example: stance def and 1615 target, kill (x5)"
      self['hunting_commands'].tooltip_text = hunting_tooltip
      # hunting_commands_b
      self['hunting_commands_b'].tooltip_text = ''
      # hunting_commands_c
      self['hunting_commands_c'].tooltip_text = ''
      # hunting_commands_d
      self['hunting_commands_d'].tooltip_text = ''
      # hunting_commands_e
      self['hunting_commands_e'].tooltip_text = ''
      # hunting_commands_f
      self['hunting_commands_f'].tooltip_text = ''
      # hunting_commands_g
      self['hunting_commands_g'].tooltip_text = ''
      # hunting_commands_h
      self['hunting_commands_h'].tooltip_text = ''
      # hunting_commands_i
      self['hunting_commands_i'].tooltip_text = ''
      # hunting_commands_j
      self['hunting_commands_j'].tooltip_text = ''
      # Fried Hunting Commands
      fried_tooltip  = "If left blank and this character is in a bigshot group, character will continue to use standard hunting commands after mind is fried and overkill limit is reached.\n"
      fried_tooltip += "If row populated, and character is in a bigshot group, these commands will be used instead of standard hunting commands once fried and overkill limit reached.\n"
      fried_tooltip += "See Hunting Commands(a) tooltip for examples on what commands to use."
      self['disable_commands'].tooltip_text = fried_tooltip
      # Quick Hunting Commands
      self['quick_commands'].tooltip_text = ''
      # Valid Targets
      self['targets'].tooltip_text = ''
      # Quickhunt Targets
      self['quickhunt_targets'].tooltip_text = "Leave blank to target all critters."

      # Misc Tab

      # Tier 3 Attack
      self['tier3'].tooltip_text = ''
      # Aim at Location
      self['aim'].tooltip_text = "Leave blank if you don't want to aim at anything\n\nSuggest leaving chest as last thing to aim at so you will always have something to hit."
      # Use Voln Smite
      self['uac_smite'].tooltip_text = "Will SMITE a non-corporeal undead when tier is excellent during UAC Combat."
      # Do Not Mstrike
      self['uac_mstrike'].tooltip_text = "Enable check box to prevent mstrikes during unarmed attacks."
      # MStrike during cooldown
      mstrike_tooltip  = "Set this to the highest you want your stamina to be before you MSTRIKE.\n"
      mstrike_tooltip += "Important if MSTRIKEing during its cooldown or while using QUICKSTRIKE.\nLeave blank to only mstrike on cooldown with max stamina.\n"
      mstrike_tooltip += "Combination of QUICKSTRIKE and MSTRIKE during cooldown may pop muscles.\nIve done best I can to ensure it doesn't happen, but depends on what you set your MSTRIKE stamina to.\n\n"
      mstrike_tooltip += "Works in conjunction with MSTRIKE creature #, so if you meet the requirements for it and not this one you will MSTRIKE and visaversa."
      self['mstrike_stamina_cooldown'].tooltip_text = mstrike_tooltip
      # Quickstrike Stamina Requirements
      self['mstrike_stamina_quickstrike'].tooltip_text = ''
      # Unfocused MStrike when creature
      self['mstrike_mob'].tooltip_text = "How many creatures you want in the room before you perform an unfocused MSTRIKE.\nDefault is 2. Set to 1 to always do an unfocused MSTRIKE."
      # MStrike during cooldown
      self['mstrike_cooldown'].tooltip_text = ''
      # Use Quickstrike for Mstrike
      self['mstrike_quickstrike'].tooltip_text = ''
      # Find ammo in this container
      self['ammo_container'].tooltip_text = ''
      # Use this ammo type
      self['ammo'].tooltip_text = ''
      # Fresh wand container
      self['fresh_wand_container'].tooltip_text = ''
      # Dead wand container
      self['dead_wand_container'].tooltip_text = ''
      # Use this wand type
      self['wand'].tooltip_text = ''
      # Hide to pick up ammo
      self['hide_for_ammo'].tooltip_text = ''
      # Use wands when oom
      self['wand_if_oom'].tooltip_text = ''
      # Group Travelers
      self['independent_travel'].tooltip_text = ''
      self['independent_return'].tooltip_text = ''
      # Character Name of Looter
      self['ma_looter'].tooltip_text = "The lead (head) characters profile will set the looter.\nIf nothing is entered or that character isn't part of the group the lead will resume looting."
      # List of characters that should never loot
      self['never_loot'].tooltip_text = 'List of characters that should never loot'
      # Random looting based on character with the lowest overall encumbrance
      self['random_loot'].tooltip_text = 'Random looting based on the character with the lowest overall encumbrance'

      # Monitoring Tab

      # Engage Deadman switch
      self['dead_man_switch'].tooltip_text = ''
      # Depart/rerun if dead
      self['depart_switch'].tooltip_text = ''
      # Quiet Followers
      self['quiet_followers'].tooltip_text = "Followers will wait until Leader is done with both actions and resting scripts to begin using their own.\n\nUse Case: Prevents you from looking like you have mindless bots following while selling loot."
      # Monitor Interactions
      self['monitor_interaction'].tooltip_text = ''
      # Monitor disks
      self['ignore_disks'].tooltip_text = ''
      # Watch for strings
      self['monitor_strings'].tooltip_text = ''
      # ...excpet if they also contain
      self['monitor_safe_strings'].tooltip_text = ''
    end

    def pre_save
      @settings.delete(:profile_name)
      @settings.delete(:profile_button)
      @settings.delete(:save_current)
      @settings.delete(:profile_save)
      @settings.delete(:profile_overwrite)
      @settings.delete(:profile_cancel)
      @settings.delete(:msg_label)
      @settings.delete(:no_current_profile)

      @settings = @settings.transform_keys(&:to_s)
    end

    def on_close_clicked
      pre_save
      UserVars.op = @settings

      @silent_exit = true
      Lich::Messaging.msg('plain', " Bigshot UI closed, saving any changes")

      self['main'].destroy
    end

    def on_destroy
      Gtk.queue {
        Lich::Messaging.msg('plain', " Bigshot UI closed WITHOUT saving any changes") unless @silent_exit
        # Load settings here
        @running = false
      }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings(connect = true)
      Gtk.queue do
        # echo @settings
        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym

          next if (setting = Setup.get_setting(key)).nil?

          self['save_profile_name'].text = ''
          self['profile_current'].text = @settings["save_profile_name"] unless @settings["save_profile_name"].nil?

          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) } if connect
          elsif obj.class == Gtk::RadioButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) } if connect
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].to_s.strip
            obj.signal_connect('changed') { on_update(obj) } if connect
          elsif obj.class == Gtk::Label
            # if obj.builder_name.to_s == "msg_label"

            # end
          elsif obj.class == Gtk::TextView
            obj.buffer.text = @settings[key].to_s.strip
            obj.signal_connect('focus-out-event') { on_update(obj) } if connect
          elsif obj.class == Gtk::SpinButton
            case key
            when :flee_count
              @settings[key] = @settings[key].to_i.zero? ? '100' : @settings[key]
            when :wander_wait
              @settings[key] = @settings[key].to_f.zero? ? '0.3' : @settings[key]
            when :encumbered
              @settings[key] = @settings[key].to_f.zero? ? '101' : @settings[key]
            end

            obj.value = @settings[key]
            obj.adjustment.value = @settings[key]
            obj.signal_connect('changed') { on_update(obj) } if connect
          elsif obj.class == Gtk::Button
            if obj.builder_name.to_s == "profile_button"
              on_drop_load
            end
            obj.signal_connect('clicked') { on_update(obj) } if connect
          elsif obj.class == Gtk::ComboBoxText
            if obj.builder_name.to_s == "fog_return"
              obj.set_active_id(@settings[key].to_s)

              unless @settings[key].to_i == 6
                self['custom_fog'].set_sensitive(false)
              end
            end

            obj.signal_connect('changed') { on_update(obj) } if connect
          elsif obj.class == Gtk::TreeView
            if (store = self["#{key}_store"]).nil?
              respond "** failed to find store for treeview #{key}"
              next
            elsif setting[:load].nil?
              respond "** no :load defined #{key}"
              next
            end

            setting[:load].call(store, @settings[key])

            # setup the signals
            if (add = self["#{key}_add"]).nil?
              respond "** failed to find add for treeview #{key}"
              next
            elsif (delete = self["#{key}_delete"]).nil?
              respond "** failed to find delete for treeview #{key}"
              next
            elsif (entry = self["#{key}_entry"]).nil?
              respond "** failed to find entry for treeview #{key}"
              next
            end

            add.signal_connect('clicked') do
              if setting[:set].nil?
                respond "** no :set defined for #{key}"
                next
              elsif entry.text.empty?
                next
              end
              setting[:set].call(store, entry.text, @settings[key])
              setting[:load].call(store, @settings[key])
            end if connect

            delete.signal_connect('clicked') do
              if setting[:delete].nil?
                respond "** no :delete defined for #{key}"
                next
              elsif (selected = obj.selection.selected).nil?
                next
              end
              setting[:delete].call(store, selected, @settings[key])
              setting[:load].call(store, @settings[key])
            end if connect
          end
        end

        # checkboxes for array storage with id's <setting>:<value>
        # this is primarily used by the loot types
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)
          next unless obj.builder_name =~ /^([^:]+):(.*)$/i
          next unless obj.class == Gtk::CheckButton

          key = Regexp.last_match(1).to_sym
          value = Regexp.last_match(2).to_s
          # echo "key: #{key} value: #{value}"
          next if Setup.get_setting(key).nil?

          # echo @settings[key].include?(value)
          obj.active = @settings[key].include?(value)

          # add in hook
          obj.signal_connect('toggled') do
            @settings[key].delete(value)
            if obj.active?
              @settings[key].push(value)
              @settings[key].uniq!.sort!
            end
          end if connect
        end
      end
    end

    def save_profile
      self['test_label'].hide
      @filename = ''

      if self['save_profile_name'].text.empty?
        self['test_label'].text = "Please enter a name before saving the profile"
        self['test_label'].show
        return
      end

      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
      @filename = File.join(dir, "#{self['save_profile_name'].text}.yaml")
      pre_save

      if File.exist?("#{@filename}")
        self['profile_overwrite'].show
        self['profile_cancel'].show
        self['profile_save'].hide
        self['test_label'].text = "File already exists!\nIf you wish to overwrite, please click the save profile button or cancel --->"
        self['test_label'].show
        return
      end
      File.write(@filename, @settings.to_yaml)
      self['profile_current'].text = self['save_profile_name'].text
      self['save_profile_name'].text = ''

      on_drop_load

      self['profile_save'].hide
      self['save_profile_name'].hide
      self['test_label'].text = "The profile has been saved to #{@filename}"
      self['test_label'].show
    end

    def save_profile_changes
      self['no_current_profile'].hide
      @filename = ''

      if self['profile_current'].text.empty?
        self['no_current_profile'].text = "Please enter a name before saving the profile"
        self['no_current_profile'].show
        return
      end

      dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
      @filename = File.join(dir, "#{self['profile_current'].text}.yaml")
      pre_save
      File.write(@filename, @settings.to_yaml)

      self['no_current_profile'].text = "#{self['profile_current'].text} has been saved with current settings."
      self['no_current_profile'].show
    end

    def start
      @running = true
      Gtk.queue {
        self['main'].show_all
        self['test_label'].hide
        self['no_current_profile'].hide
        self['profile_overwrite'].hide
        self['profile_cancel'].hide
      }

      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[general internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.is_a?(Array) ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def self.update_setting(key, value)
      setting = Setup.get_setting(key)
      echo "** Setting #{key.inspect} does not exist" if setting.nil?
      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        echo " Reset #{key}"
      elsif @settings[key].is_a?(Array)
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          echo " #{value.inspect} removed from #{key.inspect}"
        else
          @settings[key].push(value)
          echo " #{value.inspect} added to #{key.inspect}"
        end

        echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
      else
        if @settings[key].is_a?(FalseClass) || @settings[key].is_a?(TrueClass)
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].is_a?(Integer)
          value = value.to_i
        end

        echo "#{key.inspect} has been set to #{value.inspect}"
        @settings[key] = value
      end
    end
  end
end

# Main
class Bigshot
  include DRbUndumped
  attr_accessor :BIRTH_TIME, :START_TIME, :STORED_TIMES, :FRIED, :OOM,
                :SIGNS, :TARGETS, :INVALID_TARGETS, :FLEE_COUNT, :ALWAYS_FLEE_FROM,
                :USE_WRACKING, :AMMO, :AMMO_CONTAINER, :HIDE_FOR_AMMO, :BOON_FLEE_FROM,
                :REST_TILL_EXP, :REST_TILL_MANA, :USE_HERBS, :DEAD_MAN_SWITCH, :RETURN_WAYPOINT_IDS,
                :RESTING_ROOM_ID, :RESTING_COMMANDS, :RESTING_SCRIPTS, :HUNTING_ROOM_ID,
                :RALLYPOINT_ROOM_IDS, :HUNTING_BOUNDARIES, :HUNTING_SCRIPTS, :HUNTING_COMMANDS,
                :DISABLE_COMMANDS, :HUNTING_STANCE, :WANDER_STANCE, :STAND_STANCE, :HUNTING_PREP_COMMANDS,
                :MONITOR_INTERACTION, :FLEE_CLOUDS, :FLEE_VINES, :FLEE_WEBS, :FLEE_VOIDS, :WRACKING_SPIRIT,
                :REST_TILL_SPIRIT, :REST_TILL_PERCENTSTAMINA, :BOUNTY_MODE, :AMBUSH, :ARCHERY_AIM,
                :event_stack, :inbounds, :followers, :group, :leader, :BLESS, :AIM, :TIER3, :QUIET_FOLLOWERS, :IGNORE_DISKS,
                :MSTRIKE_COOLDOWN, :MSTRIKE_STAMINA_COOLDOWN, :MSTRIKE_MOB,
                :MSTRIKE_QUICKSTRIKE, :MSTRIKE_STAMINA_QUICKSTRIKE, :UAC_MSTRIKE,
                :WANDER_WAIT, :QUICK_COMMANDS, :PRIORITY, :TROUBADOURS_RALLY, :SNEAKY_SNEAKY,
                :QUICKHUNT_TARGETS, :UAC_SMITE, :FOG_RETURN, :FOG_OPTIONAL, :LOOT_STANCE,
                :DELAY_LOOT, :PULL, :OVERKILL, :LTE_BOOST, :HELP_GROUP_KILL, :WEAPON_REACTION, :DEADER, :CORRECT_PERCENT_MIND, :MA_LOOTER,
                :NEVER_LOOT, :RANDOM_LOOT, :BANDIT_HUNTING, :INDEPENDENT_TRAVEL, :INDEPENDENT_RETURN, :DESIGNATED_LOOTER, :CONTAINERS,
                :REMAINING_SKINS, :SKIN, :BUNDLE_SKIN, :GEM, :GEM_NUMBER, :TRACKING_CREATURE, :BOUNTY_EVAL, :CHECK_FAVOR,
                :DEBUG_COMBAT, :DEBUG_COMMANDS, :DEBUG_STATUS, :DEBUG_SYSTEM, :DEBUG_FILE, :debug_logger, :LAST_CALLED, :REST_PREP, :FINAL_LOOT

  PRONE ||= /sleeping|webbed|stunned|kneeling|sitting|^lying|prone|frozen|held in place|entangled/
  # Changed to gameobj-data.xml detection 4.12.2 update
  # No longer needed
  # BOON_LIST_ADJECTIVES = /^(?:adroit |afflicted |apt |barbed |belligerent |blurry |canny |combative |dazzling |deft |diseased |drab |dreary |ethereal |flashy |flexile |flickering |flinty |frenzied |ghastly |ghostly |gleaming |glittering |glorious |glowing |grotesque |hardy |illustrious |indistinct |keen |lanky |luminous |lustrous |muculent |nebulous |oozing |pestilent |radiant |raging |ready |resolute |robust |rune-covered |shadowy |shielded |shifting |shimmering |shining |sickly green |sinuous |slimy |sparkling |spindly |spiny |stalwart |steadfast |stout |tattooed |tenebrous |tough |twinkling |unflinching |unyielding |wavering |wispy )/

  def hunt_monitor(cur_action)
    bigshot_monitor = proc { |server_string|
      if !$bigshot_bandits && server_string =~ /<a exist="\d+" noun="([a-zA-Z]*?)">[a-zA-Z]*?<\/a> leaps from hiding to attack!/i
        temp = $1
        if !Lich::Gemstone::Group.members.map(&:noun).any? { |s| s =~ /#{temp}/i }
          $ambusher_here = true
        end
      elsif !$bigshot_bandits && server_string =~ /flies out of the shadows toward|A shadowy figure leaps from hiding to attack/i
        if Lich::Gemstone::Group.members.map(&:noun).size == 0
          $ambusher_here = true
        end
      elsif server_string =~ /^You could use this opportunity to <d cmd='WEAPON (\w+\s#\d+)'>.*<\/d>!/i
        $bigshot_reaction = $1
      elsif server_string =~ /^Vital energy infuses you, hastening your arcane reflexes!/i
        $bigshot_arcane_reflex = true
      elsif server_string =~ /^Nature's blessing of vitality departs as your arcane prowess returns to normal./i
        $bigshot_arcane_reflex = false
      elsif server_string =~ /crimson mist.*?surround.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:corporeal plane!|vulnerable!)/i
        $bigshot_smite_list.push($1)
      elsif server_string =~ /crimson mist.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:returns to an ethereal state.|appears less vulnerable.)/i
        $bigshot_smite_list.delete($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?is suddenly surrounded by a blood red haze./i
        $bigshot_703_list.push($1)
      elsif server_string =~ /The blood red haze dissipates from around.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?\./i
        $bigshot_703_list.delete($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:visibly struggling against|in awe of) your radiant aura!/i
        $bigshot_1614_list.push($1)
      elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?recovers from being rebuked/i
        $bigshot_1614_list.delete($1)
      elsif server_string =~ /The.*sticks in <pushBold\/>an? <a exist="(\d+)" noun="[^"]+">[^<]+<\/a><popBold\/>'s (?:left |right )?(.*)!/i
        $bigshot_archery_stuck_location.push($2)
        $bigshot_dislodge_location.push($2)
        $bigshot_dislodge_target = $1
      elsif server_string =~ /You're now aiming at the (.*) of/i
        $bigshot_archery_location = $1
      elsif server_string =~ /You're now no longer aiming at anything in particular/i
        $bigshot_archery_location = nil
      elsif server_string =~ /The <a exist="(.*?)" noun="(.*?)">.*?<\/a> strikes? true.* shrugs off some of the damage!/i
        my_id = $1.dup
        my_noun = $2.dup
        my_item = GameObj.inv.find { |i| i.id == "#{my_id}" }
        if @AMMO == "#{my_noun}" || my_item || (checkright || checkleft) == "#{my_noun}"
          $bigshot_bless.push(my_id) if !$bigshot_bless.include?(my_id)
        end
      elsif server_string =~ /Your <a exist="(.*?)" noun=".*?">.*?<\/a> returns? to normal\./i
        $bigshot_bless.push($1)
      elsif server_string =~ /^You bolt/i
        $ambusher_here = false
        $bigshot_smite_list = []
        $bigshot_aim = 0
        $bigshot_ambush = 0
        $bigshot_archery_aim = 0
        $bigshot_archery_stuck_location = []
        $bigshot_unarmed_tier = 1
        $bigshot_unarmed_followup = false
        $bigshot_unarmed_followup_attack = ""
        $bigshot_703_list = []
        $bigshot_1614_list = []
        $bigshot_flee = false
        $bigshot_reaction = nil
      elsif server_string =~ /#{UserVars.op["flee_message"]}/i && UserVars.op["flee_message"] != ""
        $bigshot_flee = true
      elsif server_string =~ /^\s+Strike leaves foe vulnerable to a followup (.*) attack!/
        $bigshot_unarmed_followup = true
        $bigshot_unarmed_followup_attack = $1
      elsif server_string =~ /^You have (decent|good|excellent) positioning against <pushBold\/>\w+ <a exist="\d+" noun=" ?\w+">[^<]+<\/a><popBold\/>\./
        tier = $1
        if tier =~ /decent/
          $bigshot_unarmed_tier = 1
        elsif tier =~ /good/
          $bigshot_unarmed_tier = 2
        elsif tier =~ /excellent/
          $bigshot_unarmed_tier = 3
        end
      elsif server_string =~ /^You (?:make a precise )?attempt to (\w+) <pushBold\/>\w+ <a exist="(\d+)" noun=" ?(\w+)">([^<]+)<\/a><popBold\/>!/
        if $bigshot_unarmed_followup && ($bigshot_unarmed_followup_attack.to_s == $1.to_s)
          assess_followup
        end
      elsif server_string =~ /^A[n]? (.*) rises out of the shadows and flies back to your waiting hand!/i
        $bigshot_bond_return = true
      elsif server_string =~ /Your Swift Justice charges are increased to (\d+)\./i
        $bigshot_swift_justice = $1.to_i
      elsif server_string =~ /Your Swift Justice surges through you! Its charges are reduced to (\d+)\./i
        $bigshot_swift_justice = $1.to_i
      elsif server_string =~ /You don't seem to be able to move(?: your legs)? to do that\.|You are unable to get out of the way as <pushBold\/>the <a exist="(\d+)" noun="snake">snake<\/a><popBold\/> coils tightly around you, holding you in place!/
        $bigshot_rooted = true
      elsif server_string =~ /You're finally able to break free of <pushBold\/>the <a exist="(\d+)" noun="snake">snake's<\/a><popBold\/> coils!/
        $bigshot_rooted = false
      elsif server_string =~ /Your <a exist="(.*?)" noun=".*?">.*?<\/a> stops glowing\./i
        $bigshot_cast902 = true
      elsif server_string =~ /The scintillating.*?light surrounding the <a exist=".*?" noun=".*?">.*?<\/a> fades away./i
        $bigshot_cast411 = true
      end
      server_string
    }

    DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    before_dying { DownstreamHook.remove("#{$current_script_name}_monitor") }

    if cur_action == "start"
      debug_msg(@DEBUG_SYSTEM, "starting bigshot_monitor | called by #{caller[0]}")
      DownstreamHook.add("#{$current_script_name}_monitor", bigshot_monitor)
    elsif cur_action == "stop"
      debug_msg(@DEBUG_SYSTEM, "removing bigshot_monitor | called by #{caller[0]}")
      DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    else
      debug_msg(@DEBUG_SYSTEM, "removing bigshot_monitor | called by #{caller[0]}")
      DownstreamHook.remove("#{$current_script_name}_monitor") # ensure monitor is removed
    end
  end

  def add_event(type, time_stamp, room_id, c_in = nil)
    debug_msg(@DEBUG_SYSTEM, "add_event | type: #{type} | called by #{caller[0]}")
    unless (@event_stack.size > 5 && type == :ATTACK)
      if (type == :FOLLOWER_OVERKILL)
        add_overkill()
        @event_stack.push(Event.new(type, time_stamp, room_id, c_in)) unless (@event_stack.any? { |a| a.type == type })
      else
        @event_stack.push(Event.new(type, time_stamp, room_id, c_in))
      end
    end
  end

  def clear_events()
    debug_msg(@DEBUG_SYSTEM, "clear_events | called by #{caller[0]}")
    @event_stack.clear
  end

  def grab_event()
    debug_msg(@DEBUG_SYSTEM, "grab_event | called by #{caller[0]}")
    @event_stack.shift()
  end

  def ping
    # checks if follower got disconnected
    return true
  end

  def remove_event(item)
    @event_stack.reject! { |event| event.type == item }
  end

  def self.debug_help
    if defined?(Terminal)
      rows = []
      rows << [{ value: "Debug options have changed to be more helpful.", colspan: 2, alignment: :left }]
      rows << :separator
      rows << [{ value: "#{$lich_char}#{Script.current.name} debug file", alignment: :left }, { value: "Toggles logging to a file <on/off>", alignment: :right }]
      rows << [{ value: "#{$lich_char}#{Script.current.name} debug all <true/false>", alignment: :left }, { value: "Toggles true/false all the things", alignment: :right }]
      rows << [{ value: "#{$lich_char}#{Script.current.name} debug check", alignment: :left }, { value: "Lists current debug settings", alignment: :right }]
      rows << [{ value: "#{$lich_char}#{Script.current.name} debug combat <true/false>", alignment: :left }, { value: "Combat and Creature Status", alignment: :right }]
      rows << [{ value: "#{$lich_char}#{Script.current.name} debug commands <true/false>", alignment: :left }, { value: "Attacking and Casting Commands", alignment: :right }]
      rows << [{ value: "#{$lich_char}#{Script.current.name} debug status <true/false>", alignment: :left }, { value: "Status Checks of your Character", alignment: :right }]
      rows << [{ value: "#{$lich_char}#{Script.current.name} debug system <true/false>", alignment: :left }, { value: "System processes", alignment: :right }]
      rows << [{ value: " ", alignment: :left }, { value: " ", alignment: :center }]
      rows << [{ value: "Options can be combined:", colspan: 2, alignment: :left }]
      rows << [{ value: "          #{$lich_char}#{Script.current.name} debug combat commands status <true/false>", colspan: 2, alignment: :left }]

      table = Terminal::Table.new :title => "#{Script.current.name.capitalize} Debug Help v#{$bigshot_version}", :rows => rows
      table.align_column(1, :right)
      respond
      respond table
      respond
    else
      respond ""
      respond "#############################################################################"
      respond ""
      respond "           #{Script.current.name.capitalize} Debug Help v#{$bigshot_version}"
      respond ""
      respond "     Debug options have changed to be more helpful."
      respond "------------------------------------------------------------"
      respond ""
      respond " #{$lich_char}#{Script.current.name} debug file                      Toggles logging to a file <on/off>"
      respond ""
      respond " #{$lich_char}#{Script.current.name} debug all <true/false>          Toggles true/false all the things"
      respond ""
      respond " #{$lich_char}#{Script.current.name} debug check                     Lists current debug settings"
      respond ""
      respond " #{$lich_char}#{Script.current.name} debug combat <true/false>       Combat and Creature Status"
      respond ""
      respond " #{$lich_char}#{Script.current.name} debug commands <true/false>     Attacking and Casting Commands"
      respond ""
      respond " #{$lich_char}#{Script.current.name} debug status <true/false>       Status Checks of your Character"
      respond ""
      respond " #{$lich_char}#{Script.current.name} debug system <true/false>       System processes"
      respond ""
      respond " Options can be combined:"
      respond "         #{$lich_char}#{Script.current.name} debug combat commands status <true/false>"
      respond ""
      respond "#############################################################################"
      respond ""
    end
  end

  def self.debug_update(updates)
    categories = ['debug_combat', 'debug_commands', 'debug_status', 'debug_system', 'debug_file']
    debug_array = updates.split(/[\s,|]+/)
    debug_array.shift

    case
    when debug_array.include?('help') || debug_array.empty?
      Bigshot.debug_help
    when debug_array.last =~ /check/i
      echo
      categories.each do |item|
        echo "#{item.gsub('_', ' ').ljust(16)} = #{!!CharSettings[item]}"
      end
      echo
    when debug_array.last =~ /file/i
      update_setting = !CharSettings['debug_file']
      categories.each do |item|
        CharSettings[item] = !!update_setting
      end
      debug_dir = File.join(LOG_DIR, 'debug', "#{XMLData.game}-#{XMLData.name}", "#{Script.current.name}.log")
      _respond
      _respond " #{update_setting == true ? "Logging" : "No longer logging"} debug messaging to #{debug_dir}"
      _respond
    when !['true', 'false'].include?(debug_array.last)
      echo
      echo "The debug parameters need to end with true or false"
      echo "#{$lich_char}#{Script.current.name} debug help for examples"
      echo
    else
      update_setting = debug_array.last.strip.downcase == "true"

      if debug_array.first =~ /all/i
        echo
        categories.each do |item|
          CharSettings[item] = !!update_setting
          echo "#{item.gsub('_', ' ').ljust(16)} = #{!!CharSettings[item]}"
        end
        echo
      else
        echo
        debug_array[0...-1].each do |item|
          item = "debug_#{item}"
          CharSettings[item] = update_setting
          echo "#{item.gsub('_', ' ').ljust(16)} = #{!!CharSettings[item]}"
        end
        echo
      end
    end
  end

  def debug_msg(type, msg)
    return unless $bigshot_debug
    return unless type

    if @DEBUG_FILE
      @debug_logger.log(msg)
    else
      echo msg
    end
  end

  def initialize(options = nil, group = nil)
    $bigshot = self

    @group = group
    @leader = @group.leader_name

    @HELP_GROUP_KILL = true

    UserVars.op ||= {}
    CharSettings['targetable']   ||= []
    CharSettings['untargetable'] ||= []
    CharSettings['untargetable'] = CharSettings['untargetable'].uniq
    @BIRTH_TIME   = Time.now.to_i
    @START_TIME   = 1
    @STORED_TIMES = []
    @COMMANDS_REGISTRY = {}
    @LAST_CALLED = {}
    @DEBUG_COMBAT     = CharSettings['debug_combat']
    @DEBUG_COMMANDS   = CharSettings['debug_commands']
    @DEBUG_STATUS     = CharSettings['debug_status']
    @DEBUG_SYSTEM     = CharSettings['debug_system']
    @DEBUG_FILE       = CharSettings['debug_file']

    if @DEBUG_FILE
      @debug_logger = DebugLogger.new
    end

    if [@DEBUG_COMBAT, @DEBUG_COMMANDS, @DEBUG_STATUS, @DEBUG_SYSTEM].any?(&:itself)
      echo "debug active for bigshot version #{$bigshot_version}"
      $bigshot_debug = true
    end
    debug_msg(@DEBUG_SYSTEM, "initialize | options: #{options} | called by #{caller[0]}")

    @followers = nil
    @event_stack = []

    check_required_values
    load_settings.each do |key, (clean, default)|
      set_value(key, clean, default)
    end

    convert_from_uid

    unless $bigshot_quick
      @inbounds = BSAreaRooms.new(@HUNTING_ROOM_ID, @HUNTING_BOUNDARIES)
      @inbounds.build
    end

    # initialize group module
    Lich::Util.quiet_command_xml("group", /You are/)

    instance_variable_set("@CORRECT_PERCENT_MIND", check_mind)

    @TRACKING_CREATURE = options[0].gsub(/(solo|bounty|quick|single|head|tail)\s*/i, '').strip
    @BANDIT_NOUN_REGEX = /bandit|brigand|robber|thug|thief|rogue|outlaw|mugger|marauder|highwayman/i

    if options.any? { |var| var =~ /bounty/i }
      @BOUNTY_MODE = true
      if checkbounty.include?("bandit")
        @BANDIT_HUNTING = true
      end
      set_bounty_eval()
    end

    dead_man_switch()

    before_dying {
      @HUNTING_SCRIPTS.each { |hs|
        # check for scripts with args passed
        hs_name = hs.split(/\s+/).first
        if running?(hs_name)
          echo "Cleaning up hunting scripts: #{hs_name}."
          stop_script(hs_name)
        end
      }
      fput("movement autosneak off") if $bigshot_sneaky_hunt
      echo "debug active for bigshot version #{$bigshot_version}" if $bigshot_debug
    }
  end

  def test_method(method_name, *args)
    # Turn on debug
    $bigshot_debug = true
    debug_settings = %i[@DEBUG_COMBAT @DEBUG_COMMANDS @DEBUG_STATUS @DEBUG_SYSTEM]
    debug_settings.each { |var| instance_variable_set(var, true) }

    # Create a group
    @followers = Group.new()

    # Track time and handle errors
    start_time = Time.now
    begin
      echo "Running #{method_name}..."
      result = send(method_name, *args)
      duration = Time.now - start_time
      echo "#{method_name} completed in #{'%.2f' % duration}s"
      echo "result: #{result}"
    rescue => e
      duration = Time.now - start_time
      echo "Error in #{method_name} after #{'%.2f' % duration}s"
      echo "   #{e.class}: #{e.message}"
      echo e.backtrace.first(5).map { |line| "   #{line}" }.join("\n")
      nil
    end
  end

  def time_between(method_name, gap)
    current_time = Time.now

    # Check if the method was previously called and if the time gap is satisfied
    if @LAST_CALLED[method_name]
      time_diff = current_time - @LAST_CALLED[method_name]
      return false if time_diff < gap
    end

    @LAST_CALLED[method_name] = current_time
    return true # Return true if either it's the first call or enough time has passed
  end

  def load_settings()
    {
      # Resting Tab - Where to Rest
      'return_waypoint_ids'         => ['split', Array.new],    # return waypoint room ids
      'resting_room_id'             => ['', 4],                 # resting room ID
      'resting_commands'            => ['split_xx', Array.new], # pre-rest commands
      'resting_scripts'             => ['split', Array.new],    # active resting scripts
      'fog_return'                  => ['', nil],               # fog options
      'custom_fog'                  => ['split_xx', Array.new], # custom fog
      'fog_optional'                => ['', false],             # fog only if wounded or encumbered
      'fog_rift'                    => ['', false],             # fog twice if returning from the rift

      # Resting Tab - Should Rest?
      'fried'                       => ['to_i', 100],           # when percentmind >=
      'overkill'                    => ['to_i', 0],             # and extra kills >=
      'lte_boost'                   => ['to_i', 0],             # and use lte boosts >=
      'oom'                         => ['to_i', 0],             # or Char.percent_mana <=
      'encumbered'                  => ['to_i', 101],           # or Char.percent_encumbrance
      'wounded_eval'                => ['', nil],               # or wounded eval
      'creeping_dread'              => ['to_i', 0],             # when creeping dread >=
      'crushing_dread'              => ['to_i', 0],             # when crushing dread >=
      'wot_poison'                  => ['', false],             # wall of thorns poison
      'confusion'                   => ['', false],             # confusion debuff
      'box_in_hand'                 => ['', false],             # box left in hand after looting

      # Hunting Tab - Hunting Map
      'hunting_room_id'             => ['', 4],                 # starting room ID
      'rallypoint_room_ids'         => ['split', Array.new],    # rallypoint room ids
      'hunting_boundaries'          => ['split', Array.new],    # boundary room ids_from_uid

      # Hunting Tab - Should Hunt?
      'rest_till_exp'               => ['to_i', 0],             # when percentmind <=
      'rest_till_mana'              => ['to_i', 0],             # and Char.percent_mana >=
      'rest_till_spirit'            => ['to_i', 0],             # and Char.spirit >=
      'rest_till_percentstamina'    => ['to_i', 0],             # and Char.percent_stamina >=

      # Hunting Tab - Right Side
      'hunting_stance'              => ['', 'defensive'],       # attack stance
      'wander_stance'               => ['', 'defensive'],       # wander stance
      'stand_stance'                => ['', 'defensive'],       # stand stance
      'hunting_prep_commands'       => ['split_xx', Array.new], # pre-hunt commands
      'hunting_scripts'             => ['split', Array.new],    # active hunting scripts
      'signs'                       => ['split', Array.new],    # society abilities/spells/cman
      'loot_script'                 => ['', nil],               # loot script
      'wracking_spirit'             => ['to_i', 0],             # wracking spirit >=

      # Hunting Tab - Right Side Toggles
      'priority'                    => ['', false],             # priority hunt
      'delay_loot'                  => ['', false],             # delay looting
      'troubadours_rally'           => ['', false],             # troubadours rally
      'use_wracking'                => ['', false],             # use sign of wracking/sigil of power/symbol of mana
      'loot_stance'                 => ['', false],             # defensive stance before looting
      'pull'                        => ['', true],              # pull players to feet
      'deader'                      => ['', false],             # stop for dead players
      'sneaky_sneaky'               => ['', false],             # sneak during hunts
      'check_favor'                 => ['', false],             # checks for favor before casting symbols

      # Attacking Tab
      'ambush'                      => ['split', Array.new],    # ambush aiming locations
      'archery_aim'                 => ['split', Array.new],    # archery aiming locations
      'flee_count'                  => ['to_i', 100],           # flee if enemy count is >
      'invalid_targets'             => ['split', Array.new],    # but don't count these
      'always_flee_from'            => ['split', Array.new],    # and always flee from
      'flee_message'                => ['', nil],               # flee from environmental message
      'wander_wait'                 => ['to_f', 0.3],           # wait before wandering to another room

      # Attack Tab - Toggles
      'boon_flee_from'              => ['', false],             # flee from boon/boss/glamour creatures
      'flee_clouds'                 => ['', false],             # flee from clouds
      'flee_vines'                  => ['', false],             # flee from vines
      'flee_webs'                   => ['', false],             # flee from webs
      'flee_voids'                  => ['', false],             # flee from voids
      'bless'                       => ['', nil],               # bless weapon
      'lone_targets_only'           => ['', false],             # approach lone targets only
      'weapon_reaction'             => ['', true],              # activate weapon reactions

      # Commands Tab - Left
      'hunting_commands'            => ['split_xx', nil],       # hunting commands(a)
      'hunting_commands_b'          => ['split_xx', Array.new], # hunting commands(b)
      'hunting_commands_c'          => ['split_xx', Array.new], # hunting commands(c)
      'hunting_commands_d'          => ['split_xx', Array.new], # hunting commands(d)
      'hunting_commands_e'          => ['split_xx', Array.new], # hunting commands(e)
      'hunting_commands_f'          => ['split_xx', Array.new], # hunting commands(f)
      'hunting_commands_g'          => ['split_xx', Array.new], # hunting commands(g)
      'hunting_commands_h'          => ['split_xx', Array.new], # hunting commands(h)
      'hunting_commands_i'          => ['split_xx', Array.new], # hunting commands(i)
      'hunting_commands_j'          => ['split_xx', Array.new], # hunting commands(j)

      # Commands Tab - Right
      'targets'                     => ['targets', nil],        # valid targets
      'quickhunt_targets'           => ['qtargets', nil],       # quickhunt targets
      'quick_commands'              => ['split_xx', Array.new], # quick commands
      'disable_commands'            => ['split_xx', Array.new], # fried commands

      # Misc Tab - UAC
      'tier3'                       => ['', 'punch'],           # tier 3 attack
      'aim'                         => ['split', Array.new],    # aim at location
      'uac_smite'                   => ['', false],             # use voln smite
      'uac_mstrike'                 => ['', false],             # do not mstrike

      # Misc Tab - Mstrike
      'mstrike_stamina_cooldown'    => ['to_i', Char.max_stamina],    # mstrike during cooldown stamina requirement
      'mstrike_stamina_quickstrike' => ['to_i', Char.max_stamina],    # quickstrike stamina requirement
      'mstrike_mob'                 => ['to_i', 2],             # unfocused mstrike when creature >=
      'mstrike_cooldown'            => ['', nil],               # mstrike during cooldown
      'mstrike_quickstrike'         => ['', nil],               # use quickstrike for mstrike

      # Misc Tab - Ammo/Wands
      'ammo_container'              => ['', nil],               # find ammo in this container
      'ammo'                        => ['', nil],               # use this ammo type
      'fresh_wand_container'        => ['', nil],               # fresh wand container
      'dead_wand_container'         => ['', nil],               # dead wand container
      'wand'                        => ['split', nil],          # use this wand type
      'hide_for_ammo'               => ['', nil],               # hide to pick up ammo
      'wand_if_oom'                 => ['', false],             # use wands when oom

      # Misc Tab - MA Grouping
      'independent_travel'          => ['', false],             # travel TO hunting grounds not as a group
      'independent_return'          => ['', false],             # travel FROM hunting grounds not as a group
      'ma_looter'                   => ['', nil],               # character name of looter
      'never_loot'                  => ['split_xx', Array.new], # no-looting list
      'random_loot'                 => ['', false],             # random looting based on encumbrance
      'final_loot'                  => ['', false],             # option to allow leader final loot before leaving a room

      # Monitoring Tab
      'dead_man_switch'             => ['', false],             # engage dead man's switch
      'depart_switch'               => ['', false],             # depart/rerun if dead
      'quiet_followers'             => ['', true],              # quiet followers
      'monitor_interaction'         => ['', false],             # monitor interactions
      'ignore_disks'                => ['', false],             # ignore disk objects
      'monitor_strings'             => ['split', Array.new],    # alerts for society honor quest creatures
      'monitor_safe_strings'        => ['split', Array.new],    # disable escape warnings

      # Internal
      'bounty_eval'                 => ['', nil], # used to set bounty rest parameters
    }
  end

  def clean_value(clean, value)
    if (clean == 'to_i')
      return value.to_i
    elsif (clean == 'to_f')
      return value.to_f
    elsif (clean == 'split')
      return value.split(/,\s*/)
    elsif (clean == 'split_xx')
      cleaned = Array.new
      value.split(/,\s*/).each { |i|
        rep = 1
        cmd = ''
        if (i =~ /(.*)\(x(\d+)\)$/i)
          rep = $2.to_i
          cmd = $1
        elsif (i =~ /(.*)\(xx\)/i)
          rep = 5
          cmd = $1
        else
          cmd = i
        end
        and_tokens = cmd.split(/\sand\s/)
        cmd = and_tokens.size == 1 ? and_tokens[0] : and_tokens
        rep.times do cleaned.push(cmd) end
      }
      return cleaned
    elsif (clean =~ /targets|qtargets/)
      targets = Hash.new
      tokens = value.split(/,/)
      tokens.each do |i|
        if (i =~ /(.*)\(([a|b|c|d|e|f|g|h|i|j|A|B|C|D|E|F|G|H|I|J])\)/)
          targets[$1.downcase.strip] = $2.downcase.strip
        else
          default = clean == "targets" ? 'a' : 'quick'
          targets[i.downcase.strip] = default
        end
      end
      return targets
    else
      return value
    end
  end

  def set_value(key, clean, default)
    if (!UserVars.op[key].nil? && UserVars.op[key].to_s !~ /^\s*$/)
      cleaned = clean_value(clean, UserVars.op[key])
      instance_variable_set("@#{key.upcase}", cleaned)
    else
      instance_variable_set("@#{key.upcase}", default)
    end
  end

  def convert_from_uid
    # provide support for uid's
    return if $bigshot_quick

    # Return Waypoint(s)
    @RETURN_WAYPOINT_IDS.map! { |place|
      uid_match(place.to_s).to_s
    }
    debug_msg(@DEBUG_SYSTEM, "convert_from_uid | @RETURN_WAYPOINT_IDS: #{@RETURN_WAYPOINT_IDS} | called by #{caller[0]}")

    # Hunting Room
    @HUNTING_ROOM_ID = uid_match(@HUNTING_ROOM_ID.to_s)
    debug_msg(@DEBUG_SYSTEM, "convert_from_uid | @HUNTING_ROOM_ID: #{@HUNTING_ROOM_ID} | called by #{caller[0]}")

    # Resting Room
    @RESTING_ROOM_ID = uid_match(@RESTING_ROOM_ID.to_s)
    debug_msg(@DEBUG_SYSTEM, "convert_from_uid | @RESTING_ROOM_ID: #{@RESTING_ROOM_ID} | called by #{caller[0]}")

    # Rally Room(s)
    @RALLYPOINT_ROOM_IDS.map! { |place|
      uid_match(place.to_s).to_s
    }
    debug_msg(@DEBUG_SYSTEM, "convert_from_uid | @RALLYPOINT_ROOM_IDS: #{@RALLYPOINT_ROOM_IDS} | called by #{caller[0]}")

    # Boundary Rooms
    @HUNTING_BOUNDARIES.map! { |place|
      uid_match(place.to_s).to_s
    }
    debug_msg(@DEBUG_SYSTEM, "convert_from_uid | @HUNTING_BOUNDARIES: #{@HUNTING_BOUNDARIES} | called by #{caller[0]}")
  end

  def uid_match(room)
    uid_pattern = /u(?<uid>\d+)/
    if (m = uid_pattern.match(room))
      uid = m[:uid].to_i
      lookup_id = Map.ids_from_uid(uid)
      if lookup_id.size > 0
        room = lookup_id[0]
      else
        echo "Not able to find #{room} in the map database! Exiting..."
        exit
      end
    end
    return room.to_i
  end

  def color(color, msg)
    if defined?(Lich::Messaging)
      Lich::Messaging.msg_format(color, msg)
    else
      msg
    end
  end

  def check_required_values
    if $bigshot_quick && !UserVars.op["quick_commands"].to_s.empty?
      return
    elsif !$bigshot_quick
      conditions = [
        # resting tab
        UserVars.op["resting_room_id"].to_s.empty?,
        !UserVars.op["fried"].to_i.positive?,

        # hunting tab
        UserVars.op["hunting_room_id"].to_s.empty?,
        UserVars.op["rest_till_exp"].to_i.negative?,
        !UserVars.op["rest_till_spirit"].to_i.positive?,

        # attacking tab
        !UserVars.op["flee_count"].to_i.positive? && !UserVars.op["flee_count"].empty?,

        # commands tab
        UserVars.op["hunting_commands"].to_s.empty?,
        UserVars.op["targets"].to_s.empty?
      ]

      return if conditions.none?(&:itself)
    end

    resting_tab = true
    hunting_tab = true
    attacking_tab = true
    commands_tab = true

    output = []
    output << "<output class='mono'/>"
    output << ""
    output << "   #{color("yellow", "There are required setting missing for Bigshot to function...")}"

    # Define the conditions and messages for easier maintenance
    conditions = [
      { condition: UserVars.op["resting_room_id"].to_s.empty?, message: "  Resting room id cannot be empty", tab: "resting" },
      { condition: !UserVars.op["fried"].to_i.positive?, message: "  when percentmind >= needs to be a positive number", tab: "resting" },
      { condition: UserVars.op["hunting_room_id"].to_s.empty?, message: "  starting room id cannot be empty", tab: "hunting" },
      { condition: UserVars.op["rest_till_exp"].to_i.negative?, message: "  when percent mind <= cannot be negative", tab: "hunting" },
      { condition: !UserVars.op["rest_till_spirit"].to_i.positive?, message: "  and Char.spirit >= needs to be a positive number", tab: "hunting" },
      { condition: !UserVars.op["flee_count"].to_i.positive?, message: "  Flee if enemy count is > needs to be a positive number", tab: "attacking" },
      { condition: UserVars.op["hunting_commands"].to_s.empty?, message: "  Hunting Commands (a) cannot be empty", tab: "commands" },
      { condition: UserVars.op["targets"].to_s.empty?, message: "  Valid Targets cannot be empty", tab: "commands" },
      { condition: UserVars.op["quick_commands"].to_s.empty?, message: "  Quick Hunting Commands cannot be empty", bs_quick: true, tab: "commands" }
    ]

    # Iterate through the conditions, checking for $bigshot_quick and the specific conditions
    conditions.each do |entry|
      if $bigshot_quick == (entry[:bs_quick] || false) && entry[:condition]
        case entry[:tab]
        when "resting"
          if resting_tab
            output << ""
            output << "   #{color("yellow", "Resting tab")}"
            resting_tab = false
          end
        when "hunting"
          if hunting_tab
            output << ""
            output << "   #{color("yellow", "Hunting tab")}"
            hunting_tab = false
          end
        when "attacking"
          if attacking_tab
            output << ""
            output << "   #{color("yellow", "Attacking tab")}"
            attacking_tab = false
          end
        when "commands"
          if commands_tab
            output << ""
            output << "   #{color("yellow", "Commands tab")}"
            commands_tab = false
          end
        end

        output << "   #{color("yellow", entry[:message])}"
      end
    end

    output << "<output class=''/>"
    output << ""

    results = []
    output.each { |line|
      new_line = line

      if $frontend =~ /^(?:wizard)$/
        sf_to_wiz(line)
        items = /<output class='mono'\/>|<output class=''\/>/
        new_line = new_line.gsub(items, "")
        new_line = new_line.gsub(/&lt;/, "<")
        new_line = new_line.gsub(/&gt;/, ">")
      else
        line.scan(/\<[^\]\<]*[^\/]>/).each { |item|
          next if item.include?("preset") ||
                  (new_line = new_line.gsub(item, item.encode(:xml => :text)))
        }
      end

      results.push(new_line)
    }

    _respond results

    Script.self.kill
  end

  def set_bounty_eval()
    set_bandit_hunting(true) if checkbounty =~ /suppress bandit activity/
    return unless @BOUNTY_EVAL.to_s.empty?

    @CONTAINERS = []
    GameObj.inv.each { |item|
      if GameObj.containers[item.id]
        @CONTAINERS.push(item)
      end
    }

    bounty_eval = %Q{!!(checkbounty =~ /^You.*?(succeeded|located|failed )|your task is failed/ && checkmind != 'saturated' && !$bigshot_bandits)} # non-bandit bounty complete
    bounty_eval += %Q{ || !!(checkbounty =~ /^You.*?(succeeded|located|failed )|your task is failed/ && $bigshot_bandits)} # bandit bounty complete
    bounty_eval += %Q{ || !!(checkbounty =~ /^You are not currently assigned / && !Effects::Cooldowns.to_h.include?('Next Bounty'))}


    if checkbounty =~ /A local divinist has had visions of the child fleeing/
      bounty_eval += %Q{ || !!(checkbounty =~ /^You have made contact with the child/ && GameObj.npcs.any? { |npc| npc.name =~ /\\bchild\\b/ })}
    elsif checkbounty =~ /You have been tasked to retrieve(.*)of at least/
      if checkbounty =~ /You have been tasked to retrieve (\d+) (.*?)(?:s)? of at/
        @REMAINING_SKINS = $1.to_i
        @SKIN = $2
      end
      @BUNDLE_SKIN = @SKIN.match(/(\w+)\s+(\w+)\s*\Z/)

      @SKIN = @SKIN.strip.downcase
                   .gsub(/s$/, "")
                   .gsub(/teeth/, "tooth")
                   .gsub(/hooves?/, "hoof")
                   .gsub(/ruffs?/, "ruff")

      bounty_eval += %Q{ || !!(count = 0;@CONTAINERS.each{|i| i.contents.each{ |k| if k.name =~ /bundle of #{@BUNDLE_SKIN}/ && !@BUNDLE_SKIN.to_s.empty? && !hidden?; lines = Lich::Util.quiet_command_xml("measure #"+k.id.to_s, /You glance through/);count += $1.to_i if lines.any?{ |l| l=~ /count a total of ([0-9]+) <a exist/};end;};};count >= @REMAINING_SKINS)}
      bounty_eval += %Q{ || !!(j=0;@CONTAINERS.each{|i| j += i.contents.count{|l| l.name =~ /#{@SKIN}/i && !@SKIN.to_s.empty?}.to_i }; j >= @REMAINING_SKINS)}
    elsif checkbounty =~ /The gem dealer/
      gem_regex = /The gem dealer in (?<town>[^,]+), [^,]+, has received orders from multiple customers requesting (?:an?|some) (?<gem>[^.]+)\.  You have been tasked to retrieve (?<number>\d+) (?:more\s+)?of them\./
      match_data = checkbounty.match(gem_regex)
      @GEM = match_data['gem']
      @GEM_NUMBER = match_data['number'].to_i

      bounty_eval += %Q{ || !!(t=0;@CONTAINERS.each{|k| t += k.contents.count{|v| v.name =~ /#{@GEM.strip}/i && !@GEM.to_s.empty?}.to_i}; t>= @GEM_NUMBER)}
    end

    @BOUNTY_EVAL = bounty_eval
  end

  def get_lines(command, regex)
    lines = []
    regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

    loop do
      lines = Lich::Util.issue_command(command, regex, usexml: true, silent: nil, quiet: true)
      debug_msg(@DEBUG_SYSTEM, "get_lines | lines: #{lines} | called by #{caller[0]}")
      break unless lines.grep(/(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

      wait_rt
    end

    return lines
  end

  def get_res(command, regex = nil)
    rt_regex = /(?:Roundtime:|\.\.\.wait|Wait) (\d+) [Ss]ec(?:onds?)?\.?/
    regex = regex.nil? ? Regexp.union(/.*?/, rt_regex) : Regexp.union(regex, rt_regex)
    result = nil
    loop do
      result = dothistimeout(command, 2, regex)
      debug_msg(@DEBUG_SYSTEM, "get_res | result: #{result} | called by #{caller[0]}")
      break unless result =~ rt_regex
      wait_rt
    end

    return result
  end

  def check_for_deaders_prone
    debug_msg(@DEBUG_COMMANDS, "check_for_deaders_prone | called by #{caller[0]}")
    return unless @PULL
    return if GameObj.pcs.nil?
    GameObj.pcs.each { |s| if s.status =~ /sitting|^lying|prone/ && s.status !~ /dead/; fput "pull #{s.noun}"; end; } if GameObj.targets.any? { |s| s.type =~ /aggressive npc/ }

    if GameObj.pcs.any? { |s| s.status =~ /dead/ } && @DEADER
      puts "#{monsterbold_start} Found a deader! #{monsterbold_end}"
      echo "PAUSING SCRIPT"
      echo ";u bigshot"
      echo "TO CONTINUE"
      pause_script
    end
  end

  def cmd(command, npc = nil, stance_dance = true)
    debug_msg(@DEBUG_COMMANDS, "cmd | command: #{command} | called by #{caller[0]}")

    check_for_deaders_prone

    original_command = command
    command = command.dup

    # Check for Roa'ter swallowing or Hinterwilds Ooze swallowing
    escape_rooms

    if command.is_a?(Array)
      stance_dance = false if command.any? { |j| j =~ /stance/ }
      command.each do |i|
        break if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }

        debug_msg(@DEBUG_COMMANDS, "cmd | command array[i]: #{i} | called by #{caller[0]}")
        cmd(i, npc, stance_dance)
      end
      return
    end

    if command =~ /\bkick\b/i && $bigshot_rooted
      command = command.gsub(/\bkick\b/i, "punch")
    end

    $bigshot_dislodge_location = [] if npc.status =~ /dead|gone/

    # waitrt/waitcastrt
    unless (command =~ /^nudgeweapons?|slipperymind/)
      waitrt?
      waitcastrt? unless command =~ /hide|cock/
    end

    # Check if the command meets all the right conditions
    return false if command_check(command, npc)

    if (command =~ /^force\s+(.*)\s+(?:till|until)\s+(\d+)/i)
      cmd_force($1, $2.to_i, npc, stance_dance)
      once_commands_register(npc, original_command)
      return
    end

    if (command =~ /^eachtarget\s+(.*)/i)
      cmd_eachtarget($1, npc)
      return
    end

    # sub id
    command.gsub!(/target/, "##{npc.id}") if !npc.nil?

    # Soothe routine - Minor Mental Spell circle
    if Spell[1201].known? && Spell[1201].affordable?
      if (Spell[201].active? || Spell[216].active? || Spell[1015].active? || Spell[1016].active? || Spell[1108].active? || Spell[1120].active?)
        waitrt?
        waitcastrt?
        Spell[1201].cast
      end
    end

    cmd_bless() if @BLESS && $bigshot_bless.count > 0

    # Celerity (506) routine
    if (command =~ /^(celerity|haste|506)\s+(.*)/i)
      command = $2

      spell = Spell[506]
      if !spell.active? || spell.timeleft <= 0.05
        waitrt?
        cmd_spell(id: 506, target: npc)
        waitcastrt?
      end
    end

    # Spirit Slayer (240) routine
    if (command =~ /^(slayer|240)\s+(.*)/i)
      command = $2
      if Spell[240].known? && Spell[240].affordable? && !Effects::Cooldowns.active?(Spell[240].name)
        if (Spell[240].active? && Spell[240].timeleft <= 0.05) || (!Spell[240].active?)
          Spell[240].cast
        end
      end
    end

    if (command =~ /^(tonis|1035)\s+(.*)/i)
      command = $2
      if Spell[1035].known? && Spell[1035].affordable?
        if (Spell[1035].active? && Spell[1035].timeleft <= 0.05) || (!Spell[1035].active?)
          Spell[1035].cast
        end
      end
    end

    # Condition check passed, drop the conditions from the command and lets do something
    command = command =~ /(.*)\((.*?)\)$/ ? $1.strip : command.strip
    command = command.downcase

    # Change_stance
    stand(command) if !standing?
    unless (command =~ /^(?:\d+|wait|sleep|wand|berserk|script|hide|nudgeweapon)/i)
      change_stance(@HUNTING_STANCE) if stance_dance
    end

    # Target gone or not priority? Then return
    return unless valid_target?(npc)
    return if @PRIORITY && !priority(npc)

    # Perform the command
    if (command =~ /^(incant)?\s?(\d+)\s?((?:open|closed)?\s?(?:cast|channel|evoke)?\s?(?:cast|channel|evoke)?\s?(?:open|closed)?\s?(?:acid|air|cold|earth|fire|lightning|steam|water)?)?.*$/i)
      cmd_spell(incant: $1, id: $2.to_i, extra: $3, target: npc)
    elsif (command =~ /^barrage|^flurry|^fury|^gthrusts|^pummel|^thrash/i)
      cmd_assault(npc, command)
    elsif (command =~ /^pindown|^cripple|^charge|^twinhammer|^dizzyingswing|^clash|^volley|^pulverize|^cyclone|^whirlwind|^wblade/i)
      cmd_weapons(npc, command)
    elsif (command =~ /^shield throw|^shield bash|^shield charge|^shield strike|^shield pin|^shield trample|^shield push/i)
      cmd_shields(npc, command)
    elsif (command =~ /^bullrush|^coupdegrace|^cpress|^dirtkick|^disarm|^exsanguinate|^feint|^gkick|^hamstring|^haymaker|^headbutt|^kifocus|^leapattack|^mblow|^sattack|^sbash|^sblow|^scleave|^sthieve|^sunder|^tackle|^trip|^truestrike|^vaultkick/i)
      cmd_cmans(npc, command)
    elsif (command =~ /^chastise|^excoriate/i)
      cmd_feats(npc, command)
    elsif (command =~ /^jewel (\w+)/i)
      cmd_jewel($1)
    elsif (command =~ /^bearhug/i)
      cmd_bearhug(npc, command)
    elsif (command =~ /^cutthroat|^divert|^shroud|^eviscerate|^eyepoke|^footstomp|^garrote|^kneebash|^mug|^nosetweak|^spunch|^subdue|^sweep|^swiftkick|^templeshot|^throatchop/i)
      cmd_rogue_cmans(npc, command)
    elsif (command =~ /^shout|^yowlp|^holler|^bellow|^growl|^cry/i)
      cmd_warrior_shouts(npc, command)
    elsif (command =~ /^throw/i)
      cmd_throw(npc)
    elsif (command =~ /^k?weed/i)
      cmd_weed(command, npc)
    elsif (command =~ /^wand\b/i)
      cmd_wand(npc)
    elsif (command =~ /^wandolier\s?(\w+)?/i)
      cmd_wandolier(npc, $1)
    elsif (command =~ /^hide\s?(\d+)?/i)
      cmd_hide($1.to_i)
    elsif (command =~ /^mstrike/i)
      cmd_mstrike(command, npc)
    elsif (command =~ /^fire/i)
      cmd_ranged(npc)
    elsif (command =~ /dislodge\s?(.*)/i)
      cmd_dislodge(npc, $1)
    elsif (command =~ /^burst/i)
      cmd_burst()
    elsif (command =~ /^surge/i)
      cmd_surge()
    elsif (command =~ /^berserk/i)
      cmd_berserk()
    elsif (command =~ /^script\s+(.*?)(\s|$)(.*)/i)
      cmd_run_script($1, $3)
    elsif (command =~ /^sleep\s+(\d+)( nostance)?/i)
      cmd_sleep($1, $2, npc)
    elsif (command =~ /^stance\s+(.*)/i)
      change_stance($1)
    elsif (command =~ /^wait\s+(\d+)/i)
      wait_for_swing($1.to_i, npc)
      $stop_wait = true
    elsif (command =~ /^nudgeweapons?\s*/i)
      cmd_nudge_weapons
    elsif (command =~ /^ambush\s?(.*)?/i)
      cmd_ambush($1, npc)
    elsif (command =~ /^unarmed\s+([a-z]*).?([a-z]*)?$/i)
      cmd_unarmed($1, npc, $2, stance_dance)
    elsif (command =~ /^smite/i)
      cmd_volnsmite(npc)
    elsif (command =~ /^caststop\s+(\d+)\s?(.*)?/i)
      cmd_caststop(npc, $1.to_i, $2)
    elsif (command =~ /^(?:unravel|barddispel)\s?(.*)?/i)
      cmd_unravel($1, npc)
    elsif (command =~ /^stomp/i)
      cmd_stomp()
    elsif (command =~ /^leech/i)
      cmd_leech()
    elsif (command =~ /^rapid(?:fire)?\s?(ignore)?/i)
      cmd_rapid($1)
    elsif (command =~ /^depress/i)
      cmd_depress(npc, original_command)
    elsif (command =~ /^phase/i)
      cmd_phase(npc)
    elsif (command =~ /^curse\s+(clumsy|weakness|darkness|itch|hex|pox|nightmare|star)$/i)
      cmd_curse(npc, $1)
    elsif (command =~ /^efury\s?(fire|cold)?/i)
      cmd_efury(npc, $1)
    elsif (command =~ /^dhurl\s?(.*)?/i)
      cmd_dhurl(npc, $1)
    elsif (command =~ /briar\s?(\w+)/i)
      cmd_briar($1)
    elsif (command =~ /^assume\s?(\w+)?\s?(\w+)?/i)
      cmd_assume($1, $2)
    elsif (command =~ /^wield\s+(\w+)\s?(left|right)?/i)
      cmd_wield($1, $2)
    elsif (command =~ /^store\s+(left|right|both)?/i)
      cmd_store($1)
    elsif (command =~ /^tether( recast)?/i)
      cmd_tether(npc, $1)
    else
      return if $ambusher_here

      debug_msg(@DEBUG_COMMANDS, "inside command | command: #{command} | called by #{caller[0]}")
      bs_put command
    end

    once_commands_register(npc, original_command)
  end

  def once_commands_register(npc, command)
    debug_msg(@DEBUG_COMMANDS, "once_commands_register | npc.id: #{npc.id} | command: #{command} | called by #{caller[0]}")

    if @COMMANDS_REGISTRY[npc.id].nil?
      @COMMANDS_REGISTRY[npc.id] = [command]
    elsif !@COMMANDS_REGISTRY[npc.id].include?(command)
      @COMMANDS_REGISTRY[npc.id].push(command)
    end
  end

  def cmd_eachtarget(command, npc)
    debug_msg(@DEBUG_COMMANDS, "cmd_eachtarget | npc: #{npc} | command: #{command} | called by #{caller[0]}")

    current_target = npc
    GameObj.targets.each { |target|
      next unless valid_target?(target)
      fput "target ##{target.id}" unless XMLData.current_target_id == target.id
      cmd(command, target)
    }
    fput "target ##{current_target.id}" unless XMLData.current_target_id == current_target.id
  end

  def command_check(command, npc)
    debug_msg(@DEBUG_COMMANDS, "command_check | npc: #{npc} | command: #{command} | called by #{caller[0]}")

    # should_return = false
    # check mana/stamina/health(percentage)/encumbrance/unarmed tiering/mobs in room/target not prone/target undead
    # ! means the inverse/opposite effect
    original_command = command
    if (command =~ /(.*)\((.*?(?:!?506|!?ancient|!?animate|!?barrage|!?bearhug|buff|!?burst|!?celerity|censer|!?coupdegrace|!?disease|!?e|!?frozen|!?flurry|!?flying|!?fury|!?garrote|!?h|!?hidden|!?holler|!?justice|!?k|!?m|!?mob|!?momentum|!?noncorporeal|once|!?outside|!?pcs|!?poison|!?prone|!?pummel|!?rapid|!?rebuke|!?reflex|room|!?rooted|!?s|!?scourge|!?shout|!?surge|!?tailwind|!?tier|!?tier1|!?tier2|!?tier3|!?thrash|!?undead|!?v|!?valid|!?vigor|!?voidweaver|!?yowlp).*?)\)$/i)
      command = $1.strip

      $2.split(" ").each { |s|
        if s =~ /((?:!?e|!?h|!?k|!?m|!?mob|!?s|!?tier|!?v|!?valid))(\d+)/i
          amount = $2.to_i
          split_item = $1.strip

          split_check = {
            'e'      => lambda { !(Char.percent_encumbrance >= amount) },
            '!e'     => lambda { Char.percent_encumbrance >= amount },
            'h'      => lambda { !(Char.percent_health >= amount) },
            '!h'     => lambda { Char.percent_health >= amount },
            'k'      => lambda { !checkkneeling },
            '!k'     => lambda { checkkneeling },
            'm'      => lambda { !(Char.mana >= amount) },
            '!m'     => lambda { Char.mana >= amount },
            'mob'    => lambda { gameobj_npc_check() < amount },
            '!mob'   => lambda { gameobj_npc_check() > amount },
            's'      => lambda { !(Char.stamina >= amount) },
            '!s'     => lambda { Char.stamina >= amount },
            'tier'   => lambda { $bigshot_unarmed_tier < amount },
            '!tier'  => lambda { $bigshot_unarmed_tier > amount },
            'v'      => lambda { !(Char.spirit >= amount) },
            '!v'     => lambda { Char.spirit >= amount },
            'valid'  => lambda { sort_npcs.count { |s| valid_target?(s) } < amount },
            '!valid' => lambda { sort_npcs.count { |s| valid_target?(s) } > amount },
          }

          debug_msg(@DEBUG_COMMANDS, "command_check section 1 | s: #{s} | split_item: #{split_item} | split_check[split_item]: #{result = split_check[split_item].call} | called by #{caller[0]}")
          return result if result
        end

        if s =~ /((?:buff))(\d+)/i
          amount = $2.to_i
          buff_check = {
            'barrage'     => lambda { !(Effects::Buffs.time_left("Enh. Dexterity (+10)") <= (amount / 60.to_f)) },
            'bearhug'     => lambda { !(Effects::Buffs.time_left("Enh. Strength (+10)") <= (amount / 60.to_f)) },
            'coupdegrace' => lambda { !(Effects::Buffs.time_left(/Empowered \(\+\d+\)/) <= (amount / 60.to_f)) },
            'flurry'      => lambda { !(Effects::Buffs.time_left("Slashing Strikes") <= (amount / 60.to_f)) },
            'fury'        => lambda { !(Effects::Buffs.time_left("Enh. Constitution (+10)") <= (amount / 60.to_f)) },
            'garrote'     => lambda { !(Effects::Buffs.time_left("Enh. Agility (+10)") <= (amount / 60.to_f)) },
            'kweed'       => lambda { !(Effects::Buffs.time_left("Tangleweed Vigor") <= (amount / 60.to_f)) },
            'pummel'      => lambda { !(Effects::Buffs.time_left("Concussive Blows") <= (amount / 60.to_f)) },
            'shout'       => lambda { !(Effects::Buffs.time_left("Empowered (+20)") <= (amount / 60.to_f)) },
            'thrash'      => lambda { !(Effects::Buffs.time_left("Forceful Blows") <= (amount / 60.to_f)) },
            'weed'        => lambda { !(Effects::Buffs.time_left("Tangleweed Vigor") <= (amount / 60.to_f)) },
            'yowlp'       => lambda { !(Effects::Buffs.time_left("Yertie's Yowlp") <= (amount / 60.to_f)) },
          }

          debug_msg(@DEBUG_COMMANDS, "command_check section 2 | s: #{s} | command: #{command} | buff_check[command]: #{result = buff_check[command].call} | called by #{caller[0]}")
          return result if result
        end

        if s =~ /((?:!?506|!?ancient|!?animate|!?barrage|!?bearhug|!?burst|!?celerity|censer|!?coupdegrace|!?disease|!?flurry|!?flying|!?frozen|!?fury|!?garrote|!?hidden|!?holler|!?justice|!?momentum|!?noncorporeal|once|!?outside|!?pcs|!?poison|!?prone|!?pummel|!?rapid|!?rebuke|!?reflex|room|!?rooted|!?scourge|!?shout|!?surge|!?tailwind|!?thrash|!?tier1|!?tier2|!?tier3|!?undead|!?vigor|!?voidweaver|!?yowlp))/i
          item = $1.strip
          other_checks = {
            '506'           => lambda { (!Spell[506].active?) },
            '!506'          => lambda { (Spell[506].active? && Spell[506].timeleft <= 0.05) },
            'ancient'       => lambda { npc.name !~ /^(?:grizzled|ancient) / || npc.name == 'ancient ghoul master' },
            '!ancient'      => lambda { npc.name =~ /^(?:grizzled|ancient) / && npc.name != 'ancient ghoul master' },
            'animate'       => lambda { !Effects::Spells.active?("Animate Dead") },
            '!animate'      => lambda { Effects::Spells.active?("Animate Dead") },
            'barrage'       => lambda { !Effects::Buffs.active?("Enh. Dexterity (+10)") },
            '!barrage'      => lambda { Effects::Buffs.active?("Enh. Dexterity (+10)") },
            'bearhug'       => lambda { (!Effects::Buffs.active?("Enh. Strength (+10)") && !Effects::Buffs.active?("Enh. Strength (+20)")) },
            '!bearhug'      => lambda { (Effects::Buffs.active?("Enh. Strength (+10)") || Effects::Buffs.active?("Enh. Strength (+20)")) },
            'burst'         => lambda { !Effects::Buffs.to_h.keys.grep(/Enh. Dexterity/).any? },
            '!burst'        => lambda { Effects::Cooldowns.active?("Burst of Swiftness") },
            'celerity'      => lambda { (!Spell[506].active?) },
            '!celerity'     => lambda { (Spell[506].active? && Spell[506].timeleft <= 0.05) },
            'coupdegrace'   => lambda { !Effects::Buffs.active?(/Empowered \(\+\d+\)/) },
            '!coupdegrace'  => lambda { Effects::Buffs.active?(/Empowered \(\+\d+\)/) },
            'disease'       => lambda { !checkdisease },
            '!disease'      => lambda { checkdisease },
            'flurry'        => lambda { !Effects::Buffs.active?("Slashing Strikes") },
            '!flurry'       => lambda { Effects::Buffs.active?("Slashing Strikes") },
            'flying'        => lambda { !npc.status.include?("flying") },
            '!flying'       => lambda { npc.status.include?("flying") },
            'frozen'        => lambda { npc.status =~ /frozen/i },
            '!frozen'       => lambda { npc.status !~ /frozen/i },
            'fury'          => lambda { !Effects::Buffs.active?("Enh. Constitution (+10)") },
            '!fury'         => lambda { Effects::Buffs.active?("Enh. Constitution (+10)") },
            'garrote'       => lambda { !Effects::Buffs.active?("Enh. Agility (+10)") },
            '!garrote'      => lambda { Effects::Buffs.active?("Enh. Agility (+10)") },
            'hidden'        => lambda { !hiding? },
            '!hidden'       => lambda { hiding? },
            'holler'        => lambda { !Effects::Buffs.active?('Enh. Health (+20)') },
            '!holler'       => lambda { Effects::Buffs.active?('Enh. Health (+20)') },
            'justice'       => lambda { $bigshot_swift_justice == 0 },
            '!justice'      => lambda { $bigshot_swift_justice >= 1 },
            'momentum'      => lambda { !Effects::Buffs.active?("Glorious Momentum") },
            '!momentum'     => lambda { Effects::Buffs.active?("Glorious Momentum") },
            'noncorporeal'  => lambda { !npc.type.split(',').any? { |a| a == "noncorporeal" } },
            '!noncorporeal' => lambda { npc.type.split(',').any? { |a| a == "noncorporeal" } },
            'once'          => lambda { @COMMANDS_REGISTRY[npc.id].include?(original_command) },
            'outside'       => lambda { !outside? },
            '!outside'      => lambda { outside? },
            'pcs'           => lambda { !((checkpcs - Lich::Gemstone::Group.members.map(&:noun)).count > 0) },
            '!pcs'          => lambda { ((checkpcs - Lich::Gemstone::Group.members.map(&:noun)).count > 0) },
            'poison'        => lambda { !checkpoison },
            '!poison'       => lambda { checkpoison },
            'prone'         => lambda { npc.status =~ PRONE },
            '!prone'        => lambda { npc.status !~ PRONE },
            'pummel'        => lambda { !Effects::Buffs.active?("Concussive Blows") },
            '!pummel'       => lambda { Effects::Buffs.active?("Concussive Blows") },
            'rapid'         => lambda { !Effects::Buffs.active?("Rapid Fire") },
            '!rapid'        => lambda { Effects::Buffs.active?("Rapid Fire") },
            'rebuke'        => lambda { !Effects::Buffs.active?("Righteous Rebuke") },
            '!rebuke'       => lambda { Effects::Buffs.active?("Righteous Rebuke") },
            'reflex'        => lambda { !$bigshot_arcane_reflex },
            '!reflex'       => lambda { $bigshot_arcane_reflex },
            'room'          => lambda { @COMMANDS_REGISTRY.any? { |_k, v| v.include?(original_command) } },
            'rooted'        => lambda { npc.status =~ /rooted/i },
            '!rooted'       => lambda { npc.status !~ /rooted/i },
            'scourge'       => lambda { !Effects::Buffs.active?("Ardor of the Scourge") },
            '!scourge'      => lambda { Effects::Buffs.active?("Ardor of the Scourge") },
            'shout'         => lambda { !Effects::Buffs.active?('Empowered (+20)') },
            '!shout'        => lambda { Effects::Buffs.active?('Empowered (+20)') },
            'surge'         => lambda { !Effects::Buffs.to_h.keys.grep(/Enh\. Strength/).any? },
            '!surge'        => lambda { Effects::Cooldowns.active?("Surge of Strength") },
            'tailwind'      => lambda { !Effects::Buffs.active?("Breeze Archery Tailwind") },
            '!tailwind'     => lambda { Effects::Buffs.active?("Breeze Archery Tailwind") },
            'thrash'        => lambda { !Effects::Buffs.active?("Forceful Blows") },
            '!thrash'       => lambda { Effects::Buffs.active?("Forceful Blows") },
            'tier1'         => lambda { $bigshot_unarmed_tier != 1 },
            '!tier1'        => lambda { $bigshot_unarmed_tier == 1 },
            'tier2'         => lambda { $bigshot_unarmed_tier != 2 },
            '!tier2'        => lambda { $bigshot_unarmed_tier == 2 },
            'tier3'         => lambda { $bigshot_unarmed_tier != 3 },
            '!tier3'        => lambda { $bigshot_unarmed_tier == 3 },
            'undead'        => lambda { !npc.type.split(',').any? { |a| a == "undead" } },
            '!undead'       => lambda { npc.type.split(',').any? { |a| a == "undead" } },
            'vigor'         => lambda { !Effects::Buffs.active?('Tangleweed Vigor') },
            '!vigor'        => lambda { Effects::Buffs.active?('Tangleweed Vigor') },
            'voidweaver'    => lambda { Effects::Buffs.to_h.keys.grep(/Voidweaver/).any? },
            '!voidweaver'   => lambda { !Effects::Buffs.to_h.keys.grep(/Voidweaver/).any? },
            'yowlp'         => lambda { !Effects::Buffs.active?("Yertie's Yowlp") },
            '!yowlp'        => lambda { Effects::Buffs.active?("Yertie's Yowlp") },
          }

          if (item == 'censer')
            if (command =~ /^(incant)?\s?(\d+)\s?((?:open|closed)?\s?(?:cast|channel|evoke)?\s?(?:cast|channel|evoke)?\s?(?:open|closed)?\s?(?:air|earth|fire|lightning|water|cold)?)?.*$/i)
              id = $2.to_i
              spell_cost = Spell[id].cost.to_i + Spell[320].cost.to_i
            else
              spell_cost = Spell[320].cost.to_i
            end

            if !Effects::Cooldowns.active?("Ethereal Censer") && Spell[320].known?
              Spell[320].cast if (Char.mana >= spell_cost)
            end
          else
            debug_msg(@DEBUG_COMMANDS, "command_check section 3 | s: #{s} | item: #{item} | other_checks[item]: #{result = other_checks[item].call} | called by #{caller[0]}")
            return result if result
          end

        end
      }

    end

    return false
  end

  def cmd_wield(noun, hand)
    debug_msg(@DEBUG_COMMANDS, "cmd_wield | noun: #{noun} | hand: #{hand} | called by #{caller[0]}")

    return if (hand.empty? || hand == 'right') && GameObj.right_hand.noun == "#{noun}"
    return if hand == 'left' && GameObj.left_hand.noun == "#{noun}"
    if hand.empty? || hand == 'right'
      fput('store right')
    else
      fput('store left')
    end
    if GameObj.inv.map { |item| item.noun }.include?(noun)
      fput("remove my #{noun}")
    else
      fput("get my #{noun}")
    end
  end

  def cmd_store(hand = 'both')
    debug_msg(@DEBUG_COMMANDS, "cmd_store | hand: #{hand} | called by #{caller[0]}")

    return if GameObj.right_hand.id.nil? && hand == 'right'
    return if GameObj.left_hand.id.nil? && hand == 'left'
    return if GameObj.left_hand.id.nil? && GameObj.right_hand.id.nil? && (hand == 'both' || hand.empty?)
    case hand
    when 'right'
      fput('store right')
    when 'left'
      fput('store left')
    else
      fput('store both')
    end
  end

  def cmd_assault(npc, cmd)
    debug_msg(@DEBUG_COMMANDS, "cmd_assault | npc: #{npc} | cmd: #{cmd} | called by #{caller[0]}")

    complete_regex = Regexp.union(
      /Distracted, you hesitate/i,
      /glides to its inevitable end with one final twirl/i,
      /You feel a fair amount more durable./i,
      /With a final snap of your wrist/i,
      /You complete your assault/i,
      /to the ready, your assault complete\./i,
      /Upon firing your last (?:arrow|bolt)/i,
      /With a final, explosive breath/i,
      /recentering yourself for the fight/i,
      /You don't seem to be able to move your legs to do that/i,
      /too injured/i,
      /already dead/i,
      /little bit late/i,
      /could not find/i,
    )

    error_regex = Regexp.union(
      /Barrage can not be used with attack as the attack type/i,
      /may not be activated within 60 seconds of a Multi-Strike\./i,
      /\.\.\.wait/i,
      /(?:Barrage|Flurry|Fury|Guardant Thrusts|Pummel|Thrash) is still in cooldown\./,
      /Your mind clouds with confusion and you glance around uncertainly\./i,
    )

    result_regex = Regexp.union(complete_regex, error_regex)

    commands = {
      "barrage"  => "Barrage",
      "flurry"   => "Flurry",
      "fury"     => "Fury",
      "gthrusts" => "Guardant Thrusts",
      "pummel"   => "Pummel",
      "thrash"   => "Thrash",
    }

    cmd_clean = cmd.split(' ').first
    return if !Weapon.available?(commands[cmd_clean])
    return unless Weapon.affordable?(commands[cmd_clean])
    if commands[cmd_clean] == "Fury" && $bigshot_unarmed_tier == 3
      cmd = commands[cmd_clean] + " " + @TIER3
    end

    waitrt?
    waitcastrt?

    break_out = Time.now() + 12
    loop {
      result = dothistimeout("weapon #{cmd} ##{npc.id}", 10, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        break unless Weapon.affordable?(commands[cmd_clean])
        next
      elsif result =~ /Barrage can not be used with attack as the attack type/i
        # Bow in the wrong hand
        fput "swap"
        next
      elsif result =~ /may not be activated within 60 seconds of a Multi-Strike\./i
        break
      elsif result =~ /(?:Barrage|Flurry|Fury|Guardant Thrusts|Pummel|Thrash) is still in cooldown\./i
        break
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result =~ /Your mind clouds with confusion and you glance around uncertainly\./i
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_curse(npc, type)
    debug_msg(@DEBUG_COMMANDS, "cmd_curse | npc: #{npc} | type: #{type} | called by #{caller[0]}")

    return if npc.status =~ /dead|gone/
    return if type == 'star' && Effects::Spells.time_left("Curse of the Star (bonus)") > 0.5
    timeout = Time.now + 10
    loop do
      break if checkprep == "Curse"
      return unless Spell[715].known? && Spell[715].affordable?
      waitrt?
      waitcastrt?
      fput('release') unless checkprep == "None"
      results = dothistimeout('prep 715', 2, /Your spell is ready\./)
      break if results
      return if npc.status =~ /dead|gone/
      return if Time.now > timeout
    end
    waitrt?
    waitcastrt?
    fput("curse ##{npc.id} #{type}") unless npc.status =~ /dead|gone/
  end

  def cmd_weapons(npc, cmd)
    debug_msg(@DEBUG_COMMANDS, "cmd_weapons | npc: #{npc} | cmd: #{cmd} | called by #{caller[0]}")

    complete_regex = Regexp.union(
      /You rush forward/i, # charge
      /Steeling yourself for a brawl/i, # clash
      /You reverse your grip/i, # cripple
      /a blurred cyclone/i, # cyclone
      /lash out in a strike/i, # dizzyingswing
      /You take quick assessment/i, # pindown
      /pulverize your foes/i, # pulverize
      /You raise your hands high/i, # twinhammer
      /filling the sky with a volley of deadly projectiles/i, # volley
      /With a broad flourish/i, # wblade
      /Twisting and spinning/i, # whirlwind
      /would be a rather awkward proposition/i,
      /is out of reach/i,
      /You don't seem to be able to move your legs to do that/i,
      /too injured/i,
      /already dead/i,
      /little bit late/i,
      /could not find/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "charge"        => "Charge",
      "clash"         => "Clash",
      "cripple"       => "Cripple",
      "cyclone"       => "Cyclone",
      "dizzyingswing" => "Dizzying Swing",
      "pindown"       => "Pin Down",
      "pulverize"     => "Pulverize",
      "twinhammer"    => "Twin Hammerfists",
      "volley"        => "Volley",
      "wblade"        => "Whirling Blade",
      "whirlwind"     => "Whirlwind",
    }

    cmd_clean = cmd.split(' ').first
    return if !Weapon.available?(commands[cmd_clean])
    return unless Weapon.affordable?(commands[cmd_clean])
    return if npc.status =~ PRONE && commands[cmd] =~ /Charge|Twin Hammerfists/

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("weapon #{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        break unless Weapon.affordable?(commands[cmd_clean])
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_shields(npc, cmd)
    debug_msg(@DEBUG_COMMANDS, "cmd_shields | npc: #{npc} | cmd: #{cmd} | called by #{caller[0]}")

    complete_regex = Regexp.union(
      /awkward proposition/i,
      /little bit late/i,
      /still stunned/i,
      /too injured/i,
      /what?/i,
      /You cannot/i,
      /Could not find/i,
      /seconds/i,
      /You snap your arm/i,
      /attempt a shield bash/i,
      /attempt a shield charge/i,
      /launch a quick bash/i,
      /diversionary shield bash/i,
      /charge headlong towards/i,
      /attempt to push/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "shield bash"    => "Shield Bash",
      "shield charge"  => "Shield Charge",
      "shield pin"     => "Shield Pin",
      "shield push"    => "Shield Push",
      "shield strike"  => "Shield Strike",
      "shield throw"   => "Shield Throw",
      "shield trample" => "Shield Trample",
    }

    # need to check if its the cman version or the shield version
    if cmd =~ /shield bash/ && CMan.available?("Shield Bash")
      return unless CMan.affordable?("Shield Bash")

      cmd = "cman sbash"
    else
      return if !Shield.available?(commands[cmd])
      return unless Shield.affordable?(commands[cmd])
    end

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("#{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        if cmd == "cman sbash"
          break unless CMan.affordable?("Shield Bash")
        else
          break unless Shield.affordable?(commands[cmd])
        end
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_caststop(npc, spell, extra)
    debug_msg(@DEBUG_COMMANDS, "cmd_caststop | npc: #{npc} | spell: #{spell} | extra: #{extra} | called by #{caller[0]}")
    return if npc.status.match?(/dead|gone/)
    return unless GameObj.targets.any? { |s| s.id == npc.id }
    return unless Spell[spell].known? and Spell[spell].affordable?
    waitrt?
    waitcastrt?
    Spell[spell].force_cast("##{npc.id}", "#{extra}")
    fput "stop #{spell}"
  end

  def cmd_depress(npc, original_command)
    debug_msg(@DEBUG_COMMANDS, "cmd_depress | npc: #{npc} | called by #{caller[0]}")

    return if npc.status.match?(/dead|gone/)
    return unless GameObj.targets.any? { |s| s.id == npc.id }
    return unless Spell[1015].known? && Spell[1015].affordable?

    if @COMMANDS_REGISTRY.any? { |_k, v| v.include?(original_command) }
      echo 'Room already affected!'
      return
    else
      waitrt?
      waitcastrt?
      result = dothistimeout 'renew 1015', 3, /Renewing "Song of Depression" for 6 mana.|But you are not singing that spellsong./
      if result =~ /But you are not singing that spellsong./
        Spell[1015].force_incant if Spell[1015].affordable?
      else
        echo("Did not match renew messaging, report above lines to Elanthia-Online")
      end
      waitrt?
      waitcastrt?
    end
  end

  def cmd_phase(npc)
    debug_msg(@DEBUG_COMMANDS, "cmd_phase | npc: #{npc} | called by #{caller[0]}")

    return if npc.status.match?(/dead|gone/)
    return unless GameObj.targets.any? { |s| s.id == npc.id }
    return unless Spell[704].known? && Spell[704].affordable?

    Spell[704].force_cast("##{npc.id}")
    waitrt?
    waitcastrt?
  end

  def cmd_unravel(cmd, npc)
    debug_msg(@DEBUG_COMMANDS, "cmd_unravel | npc: #{npc} | cmd: #{cmd} | called by #{caller[0]}")

    return if npc.status.match?(/dead|gone/)
    return unless GameObj.targets.any? { |s| s.id == npc.id }
    return unless Spell[1013].known? && Spell[1013].affordable?

    cast_results = Regexp.union(
      /You are already singing that spellsong\./,
      /The evanescent shield shrouding .* flares to life and absorbs the essence of the spell, dissipating it harmlessly\./,
      /You feel your song resonate around the .*, pulling at the threads of mana within\./,
      /The silvery tendril continues to wend its way away from the /,
      /You gain \d+ mana!/,
      /You feel your song echo around the .* as if it had entered a vast empty chamber\./,
      /The serpentine thread stretching between you and the (.*) fades, then disappears\./,
      /Your concentration on unravelling the threads of mana is broken\./,
      /A little bit late for that don't you think\?/,
      /What were you referring to\?/,
    )

    loop do
      waitrt?
      waitcastrt?
      result = Spell[1013].force_cast("##{npc.id}", "#{cmd || ''}", cast_results)
      case result
      when /You are already singing that spellsong\./
        fput('stop 1013')
      when /You feel your song resonate around the .*, pulling at the threads of mana within\.|You gain \d+ mana!/
        waitrt?
        waitcastrt?
        fput('stop 1013')
        break
      when /The silvery tendril continues to wend its way away from the .*\./
        fput('stop 1013')
      when /Your concentration on unravelling the threads of mana is broken\.|You feel your song echo around the .* as if it had entered a vast empty chamber\./
        break
      when /What were you referring to\?|A little bit late for that don't you think\?/
        fput 'release'
        break
      end
    end
  end

  def cmd_cmans(npc, cmd)
    debug_msg(@DEBUG_COMMANDS, "cmd_cmans | npc: #{npc} | cmd: #{cmd} | called by #{caller[0]}")

    complete_regex = Regexp.union(
      /awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|You cannot|Could not find|seconds/i,
      /attempt a shield bash/i,
      /release your grip/i,
      /feat of strength empowers/i,
      /your grasp/i,
      /leaving you flailing/i,
      /completely miss/i,
      /unable to complete/i,
      /dip your shoulder and rush/i,
      /intending to finish/i,
      /isn't injured enough/i,
      /thwarts your attempt/i,
      /You approach/i,
      /You maneuver in close/i,
      /try to maneuver/i,
      /can't manage to do that right now/i,
      /rooted in place/i,
      /foot and let it fly/i,
      /clump of dust/i,
      /blur of steel in your eagerness/i,
      /slows to a trickle and finally stops/i,
      /You let out a shrill yell and leap, spinning through the air/i,
      /is not bleeding/i,
      /You feint/i,
      /deliver a kick/i,
      /out of reach/i,
      /try to hamstring/i,
      /roundhouse punch/i,
      /attempt to headbutt/i,
      /leap into the air/i,
      /low enough for you to attack/i,
      /isn't flying/i,
      /with all(?: of)? your might/i,
      /with staggering might/i,
      /concentrate on the magical wards/i,
      /anti-magical equipment/i,
      /spinning leap towards/i,
      /split it asunder/i,
      /holding a shield/i,
      /You hurl yourself/i,
      /jerk the weapon sharply sideways/i,
      /will strike true/i,
      /vaulting kick/i,
      /is lying down/i,
      /concentrate on the magic/i,
      /anti-magical equipment/i,
      /summon your inner ki and focus it/i,
      /Choosing your opening, you attempt to disarm/i,
      /You haven't learned how to disarm without a weapon!/,
      /You swing your .+ at .+!/,
      /is not holding a weapon\./,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "bullrush"     => "Bull Rush",
      "coupdegrace"  => "Coup de Grace",
      "cpress"       => "Crowd Press",
      "dirtkick"     => "Dirtkick",
      "disarm"       => "Disarm Weapon",
      "exsanguinate" => "Exsanguinate",
      "feint"        => "Feint",
      "gkick"        => "Groin Kick",
      "hamstring"    => "Hamstring",
      "haymaker"     => "Haymaker",
      "headbutt"     => "Headbutt",
      "kifocus"      => "Ki Focus",
      "leapattack"   => "Leap Attack",
      "mblow"        => "Mighty Blow",
      "sattack"      => "Spin Attack",
      "sbash"        => "Shield Bash",
      "sblow"        => "Staggering Blow",
      "scleave"      => "Spell Cleave",
      "sthieve"      => "Spell Thieve",
      "sunder"       => "Sunder Shield",
      "tackle"       => "Tackle",
      "trip"         => "Trip",
      "truestrike"   => "True Strike",
      "vaultkick"    => "Vault Kick",
    }

    cmd_clean = cmd.split(' ').first
    return if !CMan.available?(commands[cmd_clean])
    return unless CMan.affordable?(commands[cmd_clean])
    return if npc.status =~ PRONE && cmd =~ /^bullrush/i
    return if Effects::Cooldowns.active?("Spell Cleave") && cmd =~ /^scleave/i
    return if Effects::Cooldowns.active?("Spell Thieve") && cmd =~ /^sthieve/i

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("cman #{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        break unless CMan.affordable?(commands[cmd_clean])
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_feats(npc, cmd)
    debug_msg(@DEBUG_COMMANDS, "cmd_feats | npc: #{npc} | cmd: #{cmd} | called by #{caller[0]}")

    complete_regex = Regexp.union(
      /awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|You cannot|Could not find|seconds/i,
      /as you lunge at .+? in a quick and vicious strike!$/,
      /You level your .+? at .+? and call down the excoriating power of .+? to smite (?:him|her|it)!/,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "chastise"  => "Chastise",
      "excoriate" => "Excoriate",
    }

    cmd_clean = cmd.split(' ').first
    return if !Feat.available?(commands[cmd_clean])
    return unless Feat.affordable?(commands[cmd_clean])

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("feat #{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        break unless Feat.affordable?(commands[cmd_clean])
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_jewel(mnemonic)
    debug_msg(@DEBUG_COMMANDS, "cmd_jewel | called by #{caller[0]} | mnemonic #{mnemonic}")

    complete_regex = Regexp.union(
      # General jewel messaging:
      /^That property isn't ready yet\./, # cooldown messaging, shouldn't actually see this due to cooldown check
      /^You don't have that property equipped\./, # jewel not equipped
      /^You fail to find a target\./, # no valid target to use gem on
      /^You have not yet unlocked Gemstones\./, # have not unlocked gemstones at all yet, wtf are you doing?

      # copied from Spell.cast @result_regex
      /^Cast Roundtime [0-9]+ Seconds?\.$/,
      /keeps? the spell from working\./,
      /^Be at peace my child, there is no need for spells of war in here\.$/,
      /Spells of War cannot be cast/,
      /^As you focus on your magic, your vision swims with a swirling haze of crimson\.$/,
      /^Your magic fizzles ineffectually\.$/,
      /^All you manage to do is cough up some blood\.$/,
      /^And give yourself away!  Never!$/,
      /^You are unable to do that right now\.$/,
      /leaving you casting at nothing but thin air!$/,
      /^You don't seem to be able to move to do that\.$/,
      /^Provoking a GameMaster is not such a good idea\.$/,
      /^You can't think clearly enough to prepare a spell!$/,
      /^You are too injured to make that dextrous of a movement/,
      /^You can't make that dextrous of a move!$/,
    )

    activated_jewels = {
      "bloodboil"       => "Blood Boil",
      "spellblade"      => "Spellblade's Fury",
      "arcascend"       => "Arcanist's Ascendancy",
      "geospite"        => "Geomancer's Spite",
      "forceofwill"     => "Force of Will",
      "arcaneintensity" => "Arcane Intensity",
      "arcaneopus"      => "Arcane Opus",
      "bloodsiphon"     => "Blood Siphon",
      "bloodwell"       => "Blood Wellspring",
      "epossess"        => "Evanescent Possession",
      "manawellspring"  => "Mana Wellspring",
      "spiritwell"      => "Spirit Wellspring",
      "stamwell"        => "Stamina Wellspring",
      "terrortribute"   => "Terror's Tribute",
      "arcblade"        => "Arcanist's Blade",
      "arcwill"         => "Arcanist's Will",
      "imaerabalm"      => "Imaera's Balm",
      "reckless"        => "Reckless Precision",
      "unearthchains"   => "Unearthly Chains",
      "witchhunt"       => "Witchhunter's Ascendancy",
      "manashield"      => "Mana Shield",
      "arcaneaegis"     => "Arcane Aegis",
    }

    unless activated_jewels.keys.include?(mnemonic)
      message("yellow", "Unknown gemstone jewel mnemonic: #{mnemonic}")
      message("yellow", "Please submit gemstone information to EO for addition.")
      message("yellow", "Include jewel name, mnemonic, and activation messaging.")
      return
    end
    return if Effects::Cooldowns.active?(activated_jewels[mnemonic])

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("gemstone activate #{mnemonic}", 2, complete_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      end
      sleep(0.25)
    }
  end

  def cmd_bearhug(npc, cmd)
    debug_msg(@DEBUG_COMMANDS, "cmd_bearhug | npc: #{npc} | cmd: #{cmd} | called by #{caller[0]}")

    complete_regex = Regexp.union(
      /You release your grip/i,
      /You feel a fair amount stronger./i,
      /avoids your grasp/i,
      /fend off your grasp/i,
      /leaving you flailing/i,
      /Your concentration lapses/i,
      /You don't seem to be able to move your legs to do that/i,
      /too injured/i,
      /already dead/i,
      /little bit late/i,
      /could not find/i,
      /but you stumble and completely miss/i,
      /is out of reach/i,
      /You cannot bearhug/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "bearhug" => "Bearhug"
    }

    cmd_clean = cmd.split(' ').first
    return if !CMan.available?(commands[cmd_clean])
    return unless CMan.affordable?(commands[cmd_clean])

    waitrt?
    waitcastrt?

    break_out = Time.now() + 17 # Up to 5 rounds at 3 sec each plus a little
    loop {
      result = dothistimeout("cman #{cmd} ##{npc.id}", 16, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        break unless CMan.affordable?(commands[cmd_clean])
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_rogue_cmans(npc, cmd)
    debug_msg(@DEBUG_COMMANDS, "cmd_rogue_cmans | npc: #{npc} | cmd: #{cmd} | called by #{caller[0]}")

    complete_regex = Regexp.union(
      /awkward proposition|You can't reach|little bit late|still stunned|too injured|what?|You cannot|Could not find|seconds/i,
      /attempt to slit/i,
      /Try hiding first/i,
      /kicking up as much dirt/i,
      /you're already out of sight/i,
      /Try hiding first/i,
      /prepare your diversion/i,
      /poised to eviscerate/i,
      /finger at the eye/i,
      /attempting to footstomp/i,
      /fling your wire around/i,
      /damage to yourself/i,
      /down at the knee/i,
      /boldly accost/i,
      /won't fall for that again/i,
      /reach out and grab/i,
      /stand up first/i,
      /spring from hiding/i,
      /You swing/i,
      /crouch and sweep/i,
      /attempting a swiftkick/i,
      /swing the blunt end/i,
      /You chop/i,
    )

    result_regex = Regexp.union(complete_regex, /\.\.\.wait/i)

    commands = {
      "cutthroat"  => "Cutthroat",
      "divert"     => "Divert",
      "shroud"     => "Dust Shroud",
      "eviscerate" => "Eviscerate",
      "eyepoke"    => "Eyepoke",
      "footstomp"  => "Footstomp",
      "garrote"    => "Garrote",
      "kneebash"   => "Kneebash",
      "mug"        => "Mug",
      "nosetweak"  => "Nosetweak",
      "subdue"     => "Subdue",
      "spunch"     => "Sucker Punch",
      "sweep"      => "Sweep",
      "swiftkick"  => "Swiftkick",
      "templeshot" => "Templeshot",
      "throatchop" => "Throatchop",

    }

    cmd_clean = cmd.split(' ').first
    return if !CMan.available?(commands[cmd_clean])
    return unless CMan.affordable?(commands[cmd_clean])

    waitrt?
    waitcastrt?

    break_out = Time.now() + 2
    loop {
      result = dothistimeout("cman #{cmd} ##{npc.id}", 1, result_regex)
      if result =~ /\.\.\.wait/i
        waitrt?
        break unless CMan.affordable?(commands[cmd_clean])
        next
      elsif result =~ complete_regex || Time.now() > break_out
        break
      elsif result == false
        $bigshot_should_rest = true
        $rest_reason = "Unknown result from #{cmd} routine: #{result}"
        break
      end
      sleep 0.25
    }
  end

  def cmd_warrior_shouts(npc, cmd)
    debug_msg(@DEBUG_COMMANDS, "cmd_warrior_shouts | npc: #{npc} | cmd: #{cmd} | called by #{caller[0]}")

    cmd = cmd.downcase

    return if Effects::Debuffs.active?("Overexerted")
    return if cmd == "shout"  && Char.stamina < 25
    return if cmd == "yowlp"  && Char.stamina < 11
    return if cmd == "holler" && Char.stamina < 31
    return if cmd == "bellow all" && Char.stamina < 21
    return if cmd == "bellow" && Char.stamina < 11
    return if cmd == "growl all" && Char.stamina < 15
    return if cmd == "growl" && Char.stamina < 8
    return if cmd == "cry all" && Char.stamina < 31
    return if cmd == "cry" && Char.stamina < 16

    result_regex = Regexp.union(
      /You let loose an echoing shout!/i,
      /You throw back your shoulders and let out a resounding yowlp!/i,
      /You throw back your head and let out a thundering holler!/i,
      /Your fighting spirit is bolstered!|round(time)?|seconds/i,
      /nerve-shattering bellow!/i,
      /round(time)?|seconds/i,
      /eerie, modulating cry/i,
      /You must be an active member/i,
    )

    waitrt?
    waitcastrt?

    if cmd.include?("all")
      result = dothistimeout("warcry #{cmd}", 2, result_regex)
    elsif cmd =~ /bellow|growl|cry/i
      result = dothistimeout("warcry #{cmd} ##{npc.id}", 2, result_regex)
    else
      result = dothistimeout("warcry #{cmd}", 2, result_regex)
    end

    if (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from #{cmd} routine: #{result}"
    end

    sleep(0.5)
  end

  def cmd_volnsmite(npc)
    debug_msg(@DEBUG_COMMANDS, "cmd_volnsmite | npc: #{npc} | called by #{caller[0]}")

    while !$bigshot_smite_list.any? { |a| a.to_i == npc.id.to_i } && npc.status !~ /dead|gone/ && GameObj.targets.any? { |s| s.id == npc.id } && !should_flee? && (npc.type.split(',').any? { |a| a == "undead" } || npc.type.split(',').any? { |a| a == "noncorporeal" })
      res = dothistimeout "smite ##{npc.id}", 1, /^Roundtime|^What were you referring to\?$|^It looks like somebody already did the job for you\.$/
      if res =~ /^It looks like somebody already did the job for you\.$/i
        $bigshot_smite_list.push(npc.id.to_i)
        break
      end

      if res =~ /^What were you referring to\?$/i
        break
      end

      sleep(1)
    end
  end

  def assess_followup
    follow_up_results = $_SERVERBUFFER_.dup.join("\n")
    follow_up_results = follow_up_results.split("\n").delete_if { |line| line.nil? or line.empty? or line =~ /^[\r\n\s\t]*$/ }
    follow_up_results = follow_up_results.find_all { |line| line =~ /UAF: -?\d+ vs UDF: -?\d+ = [\d\.]+(?: \(capped\))? \* MM: \d+ \+ d100: \d+ = (\d+)/ }
    if follow_up_results[-1] =~ /UAF: -?\d+ vs UDF: -?\d+ = [\d\.]+(?: \(capped\))? \* MM: \d+ \+ d100: \d+ = (\d+)/
      $bigshot_unarmed_followup = false if ($1.to_i > 100)
    end
  end

  def cmd_unarmed(command, npc, manualaim, stance_dance)
    debug_msg(@DEBUG_COMMANDS, "cmd_unarmed | npc: #{npc} | command: #{command} | manualaim: #{manualaim} | called by #{caller[0]}")

    return if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }

    $bigshot_aim = -1 if manualaim != "" && $bigshot_aim == 0
    $mstrike_taken = false
    cmd_volnsmite(npc) if !$bigshot_smite_list.any? { |a| a.to_i == npc.id.to_i } && npc.type.split(',').any? { |a| a == "noncorporeal" } && $bigshot_unarmed_tier == 3 && Spell[9821].known? && @UAC_SMITE
    # 9005 - Mstrike recovery
    # 9699 - popped muscles

    # mstrike using Tier3 and auto-tierup
    if @TIER3 && !@UAC_MSTRIKE
      cmd("mstrike #{@TIER3}", npc, stance_dance)
      sleep(0.3)
    elsif !@UAC_MSTRIKE
      cmd("mstrike #{command}", npc, stance_dance)
      sleep(0.3)
    end

    if (!$mstrike_taken)
      if $bigshot_unarmed_tier == 3 && $bigshot_unarmed_followup == false # command =~ /jab/ &&
        if manualaim != ""
          cmd("#{@TIER3} ##{npc.id} #{manualaim}", npc, stance_dance)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{@TIER3} ##{npc.id} #{@AIM[$bigshot_aim]}", npc, stance_dance)
        else
          cmd("#{@TIER3} ##{npc.id}", npc, stance_dance)
        end
      elsif $bigshot_unarmed_followup == true
        command = $bigshot_unarmed_followup_attack
        if manualaim != ""
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{manualaim}", npc, stance_dance)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{@AIM[$bigshot_aim]}", npc, stance_dance)
        else
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id}", npc, stance_dance)
        end
      else
        if manualaim != ""
          cmd("#{command} ##{npc.id} #{manualaim}", npc, stance_dance)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc, stance_dance)
        else
          cmd("#{command} ##{npc.id}", npc, stance_dance)
        end
      end
    end
    timeNow = Time.now + 5
    while (line = get)
      if line =~ /You have (decent|good|excellent) positioning/
        tier = $1
        if tier =~ /decent/
          $bigshot_unarmed_tier = 1
        elsif tier =~ /good/
          $bigshot_unarmed_tier = 2
        elsif tier =~ /excellent/
          $bigshot_unarmed_tier = 3
        end
      elsif line =~ /.* = .* d100: .* = \-?(\d+)$/ && $bigshot_unarmed_followup == true
        endroll = $1
        if endroll.to_i > 100
          $bigshot_unarmed_followup = false
        end
      elsif line =~ /Strike leaves foe vulnerable to a followup (.*) attack!/
        $bigshot_unarmed_followup = true
        $bigshot_unarmed_followup_attack = $1
      elsif line =~ /You fail to find an opening for your strike\./
        $bigshot_aim += 1
      elsif line =~ /You cannot aim that high!|is already missing that!/
        $bigshot_aim += 1
        cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc, stance_dance)
      elsif line =~ /does not have/
        $bigshot_aim += 1
        cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc, stance_dance)
      elsif line =~ /Roundtime:/i
        $bigshot_aim = 0
        break
      elsif line =~ /^Try standing up first\.$|[wW]ait \d+ sec.*|Sorry,|You can't do that while entangled in a web|You are still stunned|from here\.  Perhaps you should try throwing or shooting something at it\./
        break
      elsif line =~ /You don't seem to be able to move(?: your legs)? to do that\./
        $bigshot_rooted = true
        break
      elsif line =~ /You are unable to muster the will to attack anything\.|Your rage causes you to use all of your skill in an all out attack!/
        Spell[1201].cast if Spell[1201].known? && Spell[1201].affordable?
        break
      elsif npc.status =~ /dead|gone/ || !(GameObj.targets.any? { |s| s.id == npc.id }) || should_flee? || should_rest? || line =~ /You currently have no valid target\.  You will need to specify one\.|^It looks like somebody already did the job for you\.$|What were you referring to/
        $bigshot_unarmed_tier = 1
        $bigshot_unarmed_followup = false
        $bigshot_unarmed_followup_attack = ""
        break
      elsif timeNow < Time.now
        break
      end
    end
    $mstrike_taken = false
  end

  def cmd_bless()
    debug_msg(@DEBUG_COMMANDS, "cmd_bless | called by #{caller[0]}")
    while $bigshot_bless.count > 0
      if Spell[1604].known? && Spell[1604].affordable?
        waitrt?
        waitcastrt?
        next if Spell[1604].cast("##{$bigshot_bless[$bigshot_bless.count - 1]}", /A violet tongue of flame enfolds the/) =~ /A violet tongue of flame enfolds the/
      end
      if Spell[304].known? && Spell[304].affordable?
        waitrt?
        waitcastrt?
        Spell[304].cast("##{$bigshot_bless[$bigshot_bless.count - 1]}")
        $bigshot_bless.delete($bigshot_bless[$bigshot_bless.count - 1])
      elsif Spell[9802].known?
        waitrt?
        waitcastrt?
        fput "symbol bless ##{$bigshot_bless[$bigshot_bless.count - 1]}"
        $bigshot_bless.delete($bigshot_bless[$bigshot_bless.count - 1])
      else
        $bigshot_should_rest = true
        $rest_reason = "No blessing on weapon"
        $bigshot_bless = []
        return
      end
    end
  end

  def cmd_assume(aspect, extra)
    debug_msg(@DEBUG_COMMANDS, "cmd_assume | aspect: #{aspect} | extra: #{extra} | called by #{caller[0]}")

    return unless Spell[650].known?
    return if Spell["Aspect of the #{aspect.capitalize()} Cooldown"].active? && Spell["Aspect of the #{extra.capitalize()} Cooldown"].active?

    unless aspect =~ /^(?:jackal|wolf|lion|panther|hawk|owl|porcupine|rat|bear|burgee|mantis|serpent|spider|yierka)$/i
      message("yellow", "cmd_assume requires a proper aspect to assume. You used #{aspect}. They are:")
      message("yellow", "jackal, wolf, lion, panther, hawk, owl, porcupine, rat, bear, burgee, mantis, serpent, spider, yierka")
      message("yellow", "Please use the following for a command: assume <aspect1> <aspect2/evoke>")
      message("yellow", "Please use the following for society box: 650 <aspect1> <aspect2/evoke>")
      return
    end
    unless extra =~ /^(?:jackal|wolf|lion|panther|hawk|owl|porcupine|rat|bear|burgee|mantis|serpent|spider|yierka|evoke)$/i
      message("yellow", "Assume command requires to be given either two aspects or aspect + evoke")
      message("yellow", "Example:")
      message("yellow", "   Command - assume lion wolf")
      message("yellow", "   Command - assume lion evoke")
      message("yellow", "   Society - 650 lion wolf")
      message("yellow", "   Society - 650 lion evoke")
      message("yellow", "Due to improper above structure, wasting half of Assume Aspect ability")
    end

    unless Effects::Buffs.active?("Aspect of the #{aspect.capitalize()}") || Effects::Buffs.active?("Aspect of the #{extra.capitalize()}")

      if (checkprep != "None" and checkprep != "Assume Aspect")
        fput 'release'
      end

      waitrt?
      waitcastrt?
      first_aspect = false

      # Let's prep 650 if it's not already active
      unless Effects::Buffs.active?("Assume Aspect") || Effects::Buffs.active?("650") || checkprep == "Assume Aspect"
        Spell[650].force_evoke if ((extra =~ /evoke/i) && Spell[650].affordable?)
        waitcastrt?
        fput("prep 650") if ((extra !~ /evoke/i) && Spell[650].affordable?)
        first_aspect = true
      end
      return unless checkprep == "Assume Aspect" || Effects::Buffs.active?("Assume Aspect") || Effects::Buffs.active?("650")

      ttl = Time.now + 1
      if (!Spell["Aspect of the #{aspect.capitalize()} Cooldown"].active? && ((first_aspect == true) || (Char.mana >= 25)))
        dothistimeout("assume #{aspect}", 1, /^You concentrate your focus upon the Aspect|^You feel that you will not be able to fully concentrate upon the Aspect/i)
        wait_while { !Effects::Buffs.active?("Aspect of the #{aspect.capitalize()}") and Time.now < ttl }
        # first_aspect = false # useless assignment Rubocop
      elsif (!Spell["Aspect of the #{extra.capitalize()} Cooldown"].active? && ((first_aspect == true) || (Char.mana >= 25)))
        return if extra =~ /evoke/i
        dothistimeout("assume #{extra}", 1, /^You concentrate your focus upon the Aspect|^You feel that you will not be able to fully concentrate upon the Aspect/i)
        wait_while { !Effects::Buffs.active?("Aspect of the #{extra.capitalize()}") and Time.now < ttl }
        # first_aspect = false # useless assignment Rubocop
      elsif checkprep == "Assume Aspect"
        fput("cast") if Spell[650].affordable?
      end
    end
  end

  def cmd_briar(weapon)
    debug_msg(@DEBUG_COMMANDS, "cmd_briar | weapon: #{weapon.inspect} | called by #{caller[0]}")

    return if (weapon.nil? || Spell[9105].active?)
    briar_weapons = []
    briar_weapons.push(GameObj.right_hand) if GameObj.right_hand.to_s == weapon
    briar_weapons.push(GameObj.left_hand) if GameObj.left_hand.to_s == weapon
    GameObj.inv.each { |item|
      briar_weapons.push(item) if item.noun == weapon
    }
    return if briar_weapons.empty?

    briar_weapons.each { |briar_weapon|
      ready = false
      silence_me unless (undo_silence = silence_me)
      res = Lich::Util.quiet_command_xml("measure ##{briar_weapon.id}", /^You gaze intently|^Now, why are you trying to measure/, /<prompt time=/)
      if res.any? { |line| line =~ /to be about (\d+) percent\./i }
        ready = true if $1.to_i == 100
        sleep(0.2)
      end
      silence_me if undo_silence
      fput "raise ##{briar_weapon.id}" if ready == true
    }
  end

  def cmd_throw(npc)
    debug_msg(@DEBUG_COMMANDS, "cmd_throw | npc: #{npc} | called by #{caller[0]}")

    unless npc.status == 'lying down'
      empty_hands
      dothistimeout "throw ##{npc.id}", 1, /^You attempt to throw a .*\!$/
      waitrt?
      fill_hands
    end
  end

  def cmd_force(force_this, goal, npc, stance_dance)
    debug_msg(@DEBUG_COMMANDS, "cmd_force | force_this: #{force_this} | npc: #{npc} | goal: #{goal} | called by #{caller[0]}")

    result_regex = Regexp.union(
      /== \+(\d+)/,
      /^\[(?:Roll|SMR|SSR) result: (\d+)/,
    )

    failure_regex = Regexp.union(
      /^As you focus on your magic, your vision swims with a swirling haze of crimson/,
      /^You do not have enough stamina to attempt this maneuver\./,
      /^(?:.*) is lying down -- attempting to (?:.*) would be a rather awkward proposition\./,
      /^Your magic fizzles ineffectually\./,
      /^You are (?:still )?stunned\./,
    )

    start = Time.now
    loop do
      return if cmd(force_this, npc, stance_dance) == false

      sleep(0.1)
      buffer = reget(35).reverse

      buffer.each_with_index do |line, i|
        return false if line =~ failure_regex || muckled?

        if line =~ /^You.*(#{checknpcs.join('|')})|^You feint (high|low|(to the (left|right)))/
          if buffer[i - 3..i + 2].reverse.any? { |l| l =~ result_regex }
            captures = $~.captures.compact
            capture = captures.first # prioritize the first capture
            return true if capture.to_i >= goal # spell/swing/cman
            break
          end
        end
      end

      if (force_this =~ /^(\d+) / && !Spell[$1.to_i].affordable?)
        message("yellow", "Force ran out of mana. Giving up."); return;
      end
      return if GameObj.targets.size.nil? || gameobj_npc_check() == 0
      return if should_flee?
      return if should_rest?
      return if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }
      return if (Time.now - start) > 30
    end
  end

  def cmd_weed(command, target)
    debug_msg(@DEBUG_COMMANDS, "cmd_weed | command: #{command} | target: #{target} | called by #{caller[0]}")

    return if target.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == target.id }
    return if GameObj.loot.find { |loot| loot.name =~ /\b(?:vine|bramble|widgeonweed|vathor club|swallowwort|smilax|creeper|briar|ivy|tumbleweed)\b/ }
    return unless Spell[610].known? and Spell[610].affordable?

    waitcastrt?
    if command =~ /kweed/
      Spell[610].force_evoke("##{target.id}")
    else
      Spell[610].cast("##{target.id}")
    end
    waitcastrt?
  end

  def spell_is_selfcast?(spell_id) # used in cmd_spell
    [
      106, 109, 115, 117, 120, 130, 140,
      205, 206, 211, 213, 215, 218, 219, 220, 240,
      303, 307, 310, 313, 314, 319, 350,
      401, 402, 403, 404, 405, 406, 414, 418, 419, 425, 430,
      503, 506, 507, 508, 509, 511, 513, 515, 517, 520, 535, 540,
      601, 602, 604, 605, 606, 608, 612, 613, 617, 618, 620, 625, 630, 640, 650,
      707, 712,
      905, 911, 913, 916, 919,
      1003, 1006, 1007, 1009, 1010, 1011, 1012, 1014, 1017, 1018, 1019, 1020, 1025, 1035, 1040,
      1109, 1119, 1125, 1130, 1150,
      1202, 1204, 1208, 1213, 1214, 1215, 1216, 1220, 1235,
      1601, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1616, 1617, 1618, 1619, 1635
    ].include?(spell_id)
  end

  def cast_spell(spell_id: nil, target: nil, extra: nil, force: false, max_attempts: 3)
    attempts = 0

    loop do
      cast_result =
        if target
          Spell[spell_id].cast(target)
        elsif force
          Spell[spell_id].force_incant(extra)
        else
          Spell[spell_id].cast
        end

      case cast_result.to_s
      when /^Be at peace my child, there is no need for spells of war in here\.$/,
           /Spells of War cannot be cast/,
           /Cast at what/
        return :blocked
      when /^\[Spell Hindrance for/
        attempts += 1
        return :hindrance if attempts >= max_attempts
        # otherwise loop again
      else
        return :success
      end
    end
  end

  def cmd_spell(incant: nil, id: nil, extra: nil, target: nil)
    debug_msg(@DEBUG_COMMANDS, "cmd_spell | incant: #{incant} | id: #{id} | extra: #{extra} | target: #{target} | called by #{caller[0]}")

    selfcast = spell_is_selfcast?(id)

    if (checkprep != "None" && checkprep != Spell[id].name)
      fput 'release'
    end

    # There is a 5 mana penality if you ignore the 515 cooldown
    if Spell[597].active? && Spell[id].mana_cost.positive? && Spell[id].mana_cost + 5 > Char.mana
      return
    end

    return unless Spell[id].known?
    return if id == 506 && Spell[506].active?
    return if id == 9605 && Effects::Cooldowns.active?("Surge of Strength") # surge cooldown
    return if id == 9625 && Effects::Cooldowns.active?("Burst of Swiftness") # burst cooldown
    return if id == 335 && Effects::Cooldowns.active?(335) # Divine Wrath cooldown
    return if id == 608 && hiding?
    return if id == 703 && $bigshot_703_list.any? { |s| s == target.id }
    return if id == 1614 && $bigshot_1614_list.any? { |s| s == target.id }
    return if id.to_s !~ /902|411/ && (target.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == target.id })
    return if id == 720 && Effects::Cooldowns.active?("Implosion") # implosion cooldown
    # short duration buff cooldown check
    return if [140, 211, 215, 219, 919, 1619, 1650].include?(Spell[id].num) && Effects::Cooldowns.active?(Spell[id].name)

    unless (Spell[id].affordable?)
      if (@WAND_IF_OOM)
        cmd_wand(target); return;
      end
      if (@USE_WRACKING)
        wrack()
      end
    end

    if !Spell[id].affordable? && ![9605, 506, 902, 411].include?(id) && !@OOM.negative?
      $bigshot_should_rest = true
      $rest_reason = "out of mana"
    end
    return if !Spell[id].affordable?

    waitrt?
    waitcastrt?

    if incant.nil?
      if id.to_s =~ /506|902/
        cast_spell(spell_id: id)
      elsif selfcast
        cast_spell(spell_id: id, target: Char.name)
      else
        cast_spell(spell_id: id, target: "##{target.id}")
      end
    else
      if selfcast
        bs_put "target clear"
      end

      after_stance = Spell.class_variable_get(:@@after_stance)
      Spell.after_stance = Char.stance
      change_stance('offensive') if Spell[id].stance || (id.to_s =~ /1700/i && extra =~ /evoke/i)
      cast_spell(spell_id: id, extra: extra, force: true)
      change_stance(@HUNTING_STANCE)
      Spell.after_stance = after_stance

      if selfcast
        bs_put "target ##{target.id}"
      end
    end
  end

  def cmd_wand(target)
    debug_msg(@DEBUG_COMMANDS, "cmd_wand | target: #{target} | called by #{caller[0]}")

    if (@FRESH_WAND_CONTAINER)
      until ((GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s) =~ /#{@WAND[$bigshot_wand].split(' ').join('.*?')}/i)
        result = dothistimeout("get #{@WAND[$bigshot_wand]} from my #{@FRESH_WAND_CONTAINER}", 3, /You remove|You slip|Get what/)
        if (result =~ /Get what/)
          $bigshot_wand += 1
          if @WAND[$bigshot_wand].nil?
            message("yellow", "ERROR: Couldn't find fresh wand. Gonna rest.")
            $bigshot_should_rest = true
            $rest_reason = "No fresh wands!"
            return
          end
        elsif (result.nil?)
          message("yellow", "ERROR: Timed out looking for wand."); return;
        end
      end

      change_stance('offensive')
      result = get_res("wave my #{@WAND[$bigshot_wand]} at ##{target.id}", /d100|You hurl|is already dead|You do not see that here|You are in no condition|I could not find/)
      change_stance(@HUNTING_STANCE)

      if (result =~ /You are in no condition/)
        message("yellow", "ERROR: Wounded. Gonna rest.")
        $bigshot_should_rest = true
        $rest_reason = "Too injured to wave wands!"
        return
      elsif (result.nil?)
        if (@DEAD_WAND_CONTAINER)
          bs_put "put my #{@WAND[$bigshot_wand]} in my #{@DEAD_WAND_CONTAINER}"
        else
          bs_put "drop my #{@WAND[$bigshot_wand]}"
        end
      end
    else
      message("yellow", "ERROR: Wand command called but fresh wand container not defined.")
    end
  end

  def cmd_wandolier(target, stance)
    debug_msg(@DEBUG_COMMANDS, "cmd_wandolier | target: #{target} | stance: #{stance} | called by #{caller[0]}")
    if stance.empty? || stance.nil?
      stance = 'offensive'
    end
    if (@FRESH_WAND_CONTAINER)
      until ((GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s) =~ /#{@WAND[$bigshot_wand].split(' ').join('.*?')}/i)
        result = dothistimeout("get #{@WAND[$bigshot_wand]} from my #{@FRESH_WAND_CONTAINER}", 3, /You (?:remove|slip|slide)|Get what/)
        if (result =~ /Get what/)
          fput("rub my #{@FRESH_WAND_CONTAINER}")
        elsif (result.nil?)
          message("yellow", "ERROR: Timed out looking for wand."); return;
        end
      end

      change_stance(stance)
      # result = get_res("wave my #{@WAND[$bigshot_wand]} at ##{target.id}", /d100|You hurl|is already dead|You do not see that here|You are in no condition|I could not find/)
      result = get_res("wave my #{@WAND[$bigshot_wand]}", /d100|You hurl|is already dead|You do not see that here|You are in no condition|I could not find/)
      change_stance(@HUNTING_STANCE)

      if (result =~ /You are in no condition/)
        message("yellow", "ERROR: Wounded. Gonna rest.")
        $bigshot_should_rest = true
        $rest_reason = "Too injured to wave wands!"
        return
      end
    else
      message("yellow", "ERROR: Wandolier command called but fresh wand container not defined.")
    end
  end

  def cmd_stomp()
    debug_msg(@DEBUG_COMMANDS, "cmd_stomp | called by #{caller[0]}")

    return if !Spell[909].known?

    waitrt?
    waitcastrt?
    if Spell[909].active?
      fput "stomp" if Char.mana >= 5
    elsif Spell["909"].affordable?
      Spell["909"].force_channel
      waitcastrt?
      fput "stomp" if Char.mana >= 5
    end
  end

  def cmd_leech()
    debug_msg(@DEBUG_COMMANDS, "cmd_leech | called by #{caller[0]}")

    return if !Spell[516].known?

    if (Effects::Cooldowns.time_left("Mana Leech") < 15) && (Spell[516].affordable?)
      waitrt?
      waitcastrt?
      Spell[516].cast
    end
  end

  def cmd_rapid(ignore = "")
    debug_msg(@DEBUG_COMMANDS, "cmd_rapid | ignore: #{ignore} | called by #{caller[0]}")

    return unless Spell[515].known?
    return unless Spell[515].affordable?
    return if Effects::Buffs.active?("Rapid Fire") && Effects::Buffs.time_left("Rapid Fire") > 0.05
    return if Effects::Cooldowns.active?("Rapid Fire Recovery") && ignore.to_s.empty?

    waitrt?
    waitcastrt?
    Spell[515].cast
  end

  def cmd_efury(npc, extra)
    debug_msg(@DEBUG_COMMANDS, "cmd_efury | npc: #{npc} | extra: #{extra} | called by #{caller[0]}")

    return if npc.status =~ /dead|gone/
    return unless GameObj.targets.any? { |s| s.id == npc.id }
    return unless Spell[917].known? and Spell[917].affordable?

    spell_complete = false

    complete_regex = Regexp.union(
      /The (?:floor|ground) beneath .* suddenly calms\./,                  # normal completion
      /Heat rises from the ground near .* causing a brief swelter\./,      # target not in room - fire
      /An icy mist rises from the ground near .* as the ground rumbles\./, # target not in room - cold
      /The evanescent shield shrouding .* flares to life and absorbs the essence of the spell, dissipating it harmlessly\./ # soul ward (319)
    )

    waitrt?
    waitcastrt?
    time_out = Time.now + 12
    result = Spell[917].force_incant("#{extra}")
    return if result =~ complete_regex

    Thread.new do
      while (line = get)
        if line =~ complete_regex || Time.now > time_out
          spell_complete = true
          break
        end
      end
    end

    loop do
      break if Time.now > time_out
      break if should_flee?
      break if npc.status =~ /dead|gone/
      break unless GameObj.targets.any? { |s| s.id == npc.id }
      break if spell_complete
      stand unless standing?
      sleep(0.5)
    end
  end

  def cmd_hide(attempts)
    debug_msg(@DEBUG_COMMANDS, "cmd_hide | attempts: #{attempts} | called by #{caller[0]}")
    tries = 0
    attempts = 3 if attempts == 0
    until (hiding?)
      break if tries > attempts || should_flee?

      change_stance(@WANDER_STANCE)
      fput "hide"
      tries += 1
    end
  end

  def mstrike_spell_check()
    debug_msg(@DEBUG_COMMANDS, "mstrike_spell_check | called by #{caller[0]}")

    # Rejuvenation
    if (Spell[1607].known? && !Spell[1607].active? && Spell[1607].affordable? && (Char.stamina < (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
      if ((Char.stamina + (15 + (bonus = 0; [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190].each { |n| bonus += 1 if Skills.slblessings >= n }; bonus * 3))) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE))
        waitcastrt?
        Spell[1607].cast
      end
    end
    # Adrenal Surge
    if (Spell[1107].known? && Spell[1107].affordable? && !Spell[9010].active? && (Time.now >= $bigshot_adrenal_surge))
      if (Spell[9699].active? || ((Char.max_stamina if Skills.slblessings >= 65) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      elsif (Spell[9699].active? || ((Char.stamina + (Skills.slblessings >= 35 ? 50 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      elsif (Spell[9699].active? || ((Char.stamina + (Skills.slblessings >= 35 ? 25 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        Spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      end
    end
  end

  def cmd_mstrike(command, target)
    debug_msg(@DEBUG_COMMANDS, "cmd_mstrike | target: #{target} | command: #{command} | called by #{caller[0]}")

    mstrike_spell_check() if Stats.prof =~ /Paladin|Empath/i
    # Mstrike checks
    if Effects::Debuffs.active?("Overexerted") # TODO PoPped muscle check updates
      $mstrike_taken = false
      return
    end
    if Skills.multiopponentcombat >= 30 && GameObj.targets.all? { |i| i.noun !~ /nest/i }
      if (!Effects::Cooldowns.active?("Multi-Strike") || (@MSTRIKE_COOLDOWN && Char.stamina >= @MSTRIKE_STAMINA_COOLDOWN))
        if @MSTRIKE_QUICKSTRIKE && Char.stamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Effects::Debuffs.active?("Overexerted")
          if (gameobj_npc_check() >= @MSTRIKE_MOB || target.nil?)
            bs_put "quickstrike 1 #{command}"
          else
            bs_put "quickstrike 1 #{command} ##{target.id}"
          end
        else
          if (gameobj_npc_check() >= @MSTRIKE_MOB || target.nil?)
            bs_put "#{command}"
          else
            bs_put "#{command} ##{target.id}"
          end
        end
        $mstrike_taken = true
      end
    elsif Skills.multiopponentcombat >= 5 && GameObj.targets.all? { |i| i.noun !~ /nest/i } && gameobj_npc_check() >= @MSTRIKE_MOB
      if (!Effects::Cooldowns.active?("Multi-Strike") || (@MSTRIKE_COOLDOWN && Char.stamina >= @MSTRIKE_STAMINA_COOLDOWN))
        if @MSTRIKE_QUICKSTRIKE && Char.stamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Effects::Debuffs.active?("Overexerted")
          bs_put "quickstrike 1 #{command}"
        else
          bs_put "#{command}"
        end
        $mstrike_taken = true
      end
    end
  end

  def check_target_vitals(command, target, ranged = false)
    debug_msg(@DEBUG_COMBAT, "check_target_vitals | target: #{target} | command: #{command} | ranged: #{ranged} | called by #{caller[0]}")

    regex = /(?:he|she|it)<\/a><popBold\/> has (.*)/i
    woundinfo = nil

    # General logic for this taken from ;fire by Oweodry
    lines = get_lines("look ##{target.id}", /You see|I could not find/)

    # Find the line that matches the regex
    matching_line = lines.find { |line| line.match(regex) }

    if matching_line
      # Capture the relevant part of the matching line
      woundinfo = matching_line.match(regex)[1]
    end

    loc = (ranged) ? $bigshot_archery_aim : $bigshot_ambush
    if (command[loc] == "head" && woundinfo =~ /severe head trauma and bleeding from .* ears/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "neck" && woundinfo =~ /snapped bones and serious bleeding from .* neck/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "left eye" && woundinfo =~ /blinded left eye/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    elsif (command[loc] == "right eye" && woundinfo =~ /blinded right eye/)
      $bigshot_ambush += 1 if !ranged
      $bigshot_archery_aim += 1 if ranged
    end
  end

  def cmd_1040(target)
    debug_msg(@DEBUG_COMMANDS, "cmd_1040 | target: #{target} | called by #{caller[0]}")

    return if !Spell[1040].known?

    waitrt?
    waitcastrt?
    fput 'mana pulse' if !Spell[1040].affordable?
    if target != Char.name
      Spell[1040].cast if Spell[1040].affordable?
    elsif target == Char.name
      until !webbed? && !sleeping? && !stunned? && !frozen?
        Spell[1040].cast if Spell[1040].affordable?
        fput 'mana pulse' if !Spell[1040].affordable?
        waitcastrt?
      end
    end
  end

  def cmd_dhurl(target, command)
    debug_msg(@DEBUG_COMMANDS, "cmd_dhurl | called by #{caller[0]}")
    if target.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == target.id }
      $bigshot_ambush = 0
      return
    end
    command = @AMBUSH if !(@AMBUSH.empty?) && (command.nil? || command.empty?)
    command = [command] if command.is_a?(String)
    if command.is_a?(Array) && $bigshot_ambush >= command.length
      # If you have gotten here, there is nothing left to target on your list.
      $bigshot_ambush = 0
      command = ["chest"]
    end
    if ["head", "neck", "left eye", "right eye"].include?(command[$bigshot_ambush])
      check_target_vitals(command, target)
    end
    waitrt?
    waitcastrt?
    $bigshot_bond_return = false
    res = dothistimeout "hurl ##{target.id} #{command[$bigshot_ambush]}", 2, Regexp.union(
      /With a quick flick of your wrist\, you deftly send .+ into flight\./,
      /That's not going to do much.  Try using a weapon/,
      /You find nothing recoverable/,
      /^You throw/,
      /^You take aim and throw/,
    )
    if res.is_a?(String) && res =~ /You take aim and throw|You throw|With a quick flick of your wrist\, you deftly send .+ into flight\./
      $bigshot_ambush = 0
      weapon_hurled_room = Room.current.id
      hold = 6 - checkrt.to_f
      hold = 0 if hold.to_f <= 0
      waitrt?
      sleep(hold)
      if weapon_hurled_room != Room.current.id
        Script.run("go2", weapon_hurled_room)
      end
      cmd_recover
    elsif res.is_a?(String) && res =~ /That's not going to do much.  Try using a weapon|You find nothing recoverable/
      Script.run("go2", weapon_hurled_room)
      cmd_recover
      return
    end
  end

  def cmd_recover(weapon_lost = true)
    debug_msg(@DEBUG_COMMANDS, "cmd_recover | weapon_lost: #{weapon_lost} | called by #{caller[0]}")

    until weapon_lost.eql?(false)
      break if $bigshot_bond_return.eql?(true)

      waitrt?
      message("yellow", "RECOVERED: Attempting to recover weapon.")
      res = dothistimeout "recover hurl", 5, Regexp.union(
        /You know .+ is around here somewhere, but you don't see it./,
        /You spy a .+ and recover it/,
        /A .+ rises out of the shadows and flies back to your waiting hand!/,
        /In order to recover your hurled weapon, you'll need to have a free hand./,
        /You find nothing recoverable./,
      )
      if res.is_a?(String) && res =~ /You know .+ is around here somewhere, but you don't see it./
        sleep(0.5)
        message("yellow", "RECOVERED: Almost recovered")
      elsif res.is_a?(String) && res =~ /You spy a .+ and recover it|.+ rises out of the shadows and flies back to your waiting hand!/
        message("yellow", "RECOVERED: Yes - #{Room.current.id}")
        weapon_lost = false
      elsif res.is_a?(String) && res =~ /In order to recover your hurled weapon, you'll need to have a free hand.|You find nothing recoverable./
        message("yellow", "RECOVERED: No")
        weapon_lost = false
      end
    end
  end

  def cmd_ranged(npc)
    debug_msg(@DEBUG_COMMANDS, "cmd_ranged | npc: #{npc} | called by #{caller[0]}")

    if npc.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == npc.id }
      $bigshot_archery_aim = 0
      $bigshot_archery_stuck_location = []
      return
    end
    if !@ARCHERY_AIM[$bigshot_archery_aim].nil?
      if $bigshot_archery_stuck_location.any? { |s| s =~ /#{$bigshot_archery_location}/i }
        $bigshot_archery_aim += 1
      end
      if (@ARCHERY_AIM[$bigshot_archery_aim] == "head" || @ARCHERY_AIM[$bigshot_archery_aim] == "neck" || @ARCHERY_AIM[$bigshot_archery_aim] == "left eye" || @ARCHERY_AIM[$bigshot_archery_aim] == "right eye")
        check_target_vitals(@ARCHERY_AIM, npc, true)
      end
      if $bigshot_archery_aim > @ARCHERY_AIM.length
        $bigshot_archery_aim = 0
        $bigshot_archery_stuck_location = []
      end

      if @ARCHERY_AIM[$bigshot_archery_aim] !~ /#{$bigshot_archery_location}/i || $bigshot_archery_location.nil?
        fput "aim #{@ARCHERY_AIM[$bigshot_archery_aim]}"
      end
    end

    waitrt?
    waitcastrt?

    result = dothistimeout("fire ##{npc.id}", 2, /round(time)?|You cannot|Could not find|seconds|Get what?/i)
    if (result =~ /^Could not find/)
      # gather_ammo()#Not used since archery updates.
    elsif (result =~ /You cannot fire/)
      unless GameObj.right_hand.id.nil?
        line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
      end
    elsif (result =~ /but it has no effect/)
      $bigshot_should_rest = true
      $rest_reason = "Ammo had no effect (need blessed or magical)"
    elsif (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from fire routine: #{result}"
    elsif result =~ /round(time)?/i
      $bigshot_archery_aim = 0
      $bigshot_archery_stuck_location = []
    end
  end

  def cmd_dislodge(npc, location)
    debug_msg(@DEBUG_COMMANDS, "cmd_dislodge | npc: #{npc} | location: #{location} | called by #{caller[0]}")

    return if !CMan.available?("Dislodge")
    return if npc.id != $bigshot_dislodge_target

    target = nil
    location = location.split(/ /, 9) # [bigshot: ["eye", "head", "neck", "chest", "back", "abdomen", "arm", "leg", "hand"]]
    location.each { |loc|
      if $bigshot_dislodge_location.include?(loc)
        target = loc
        break
      end
    }
    return if target.nil?

    waitrt?
    waitcastrt?
    result = dothistimeout("cman dislodge ##{npc.id} #{target}", 2, /attempting to dislodge|suitable weapons lodged|You can't reach|awkward proposition|little bit late|still stunned|too injured|what?|round(time)?|You cannot|Could not find|seconds/i)
    if (result =~ /You manage to dislodge|You skillfully wrench/ && npc.status =~ /dead|gone/)
      $bigshot_dislodge_location = []
      $bigshot_dislodge_target = nil
    elsif (result =~ /You manage to dislodge|You skillfully wrench/)
      $bigshot_dislodge_location.delete(target)
      target = nil
    elsif (result == false)
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from dislodge routine: #{result}"
    end
  end

  def cmd_burst()
    debug_msg(@DEBUG_COMMANDS, "cmd_burst | called by #{caller[0]}")

    return unless CMan.known?("Burst of Swiftness")
    return if Effects::Buffs.to_h.keys.grep(/Enh. Dexterity/).any?
    return if Char.stamina < 30 && !Effects::Cooldowns.active?("Burst of Swiftness")
    return if Char.stamina < 60 && Effects::Cooldowns.active?("Burst of Swiftness")

    burst_regex = /^You feel (?:significantly|a great deal|a fair amount) more (?:agile|dextrous)\.$|^Your muscles ache much too badly to even think about attempting this maneuver\.$/
    rt_regex = /(?:Roundtime:|Wait|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i
    cmd_regex = Regexp.union(burst_regex, rt_regex)

    loop do
      waitrt?
      waitcastrt?
      result = dothistimeout("cman burst", 1, cmd_regex)
      break unless result =~ rt_regex
    end
  end

  def cmd_surge()
    debug_msg(@DEBUG_COMMANDS, "cmd_surge | called by #{caller[0]}")

    return unless CMan.known?("Surge of Strength")
    return if Effects::Buffs.to_h.keys.grep(/Enh\. Strength/).any?
    return if Char.stamina < 30 && !Effects::Cooldowns.active?("Surge of Strength")
    return if Char.stamina < 60 && Effects::Cooldowns.active?("Surge of Strength")

    surge_regex = /You feel a great deal stronger.|untapped sources of strength|still recent prior attempt|come from your muscles|ache much too badly/i
    rt_regex = /(?:Roundtime:|Wait|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i
    cmd_regex = Regexp.union(surge_regex, rt_regex)

    loop do
      waitrt?
      waitcastrt?
      result = dothistimeout("cman surge", 1, cmd_regex)
      break unless result =~ rt_regex
    end
  end

  def cmd_berserk()
    debug_msg(@DEBUG_COMMANDS, "cmd_berserk | called by #{caller[0]}")

    if (Char.stamina >= 20)
      change_stance(@WANDER_STANCE)
      Spell[9607].cast
      pause 5
      wait_until { !Spell[9607].active? }
    else
      bs_put 'target random'; bs_put 'kill';
    end
  end

  def cmd_run_script(name, args)
    debug_msg(@DEBUG_SYSTEM, "cmd_run_script | name: #{name} | args: #{args} | called by #{caller[0]}")

    if (args == nil || args =~ /^\s*$/)
      run_script(name, true)
    else
      run_script(name, true, args)
    end
  end

  def cmd_sleep(time, nostance, npc)
    debug_msg(@DEBUG_COMMANDS, "cmd_sleep | npc: #{npc} | time: #{time} | called by #{caller[0]}")

    change_stance(@WANDER_STANCE) unless nostance
    time.to_i.times do
      sleep(1)
      break if should_rest?
      break if npc && npc.status =~ /dead|gone/
    end
  end

  def cmd_ambush(command, target)
    debug_msg(@DEBUG_COMMANDS, "cmd_ambush | target: #{target} | command: #{command} | called by #{caller[0]}")

    if target.status =~ /dead|gone/ || !GameObj.targets.any? { |s| s.id == target.id }
      $bigshot_ambush = 0
      return
    end
    command = ["head", "right leg", "left leg", "chest"] if (command == "" || command.nil?) && @AMBUSH == []
    command = @AMBUSH if (command == "" || command == [] || command.nil?) && @AMBUSH != []
    command = [command] if command.is_a?(String)
    if ($bigshot_ambush >= command.length())
      # If you have gotten here, there is nothing left to target on your list.
      $bigshot_ambush = 0
      command = ["chest"]
    end
    if (command[$bigshot_ambush] == "head" || command[$bigshot_ambush] == "neck" || command[$bigshot_ambush] == "left eye" || command[$bigshot_ambush] == "right eye")
      check_target_vitals(command, target)
    end
    waitrt?
    ambush_or_attack = (hidden?) ? "ambush" : "attack"
    result = dothistimeout "#{ambush_or_attack} ##{target.id} #{command[$bigshot_ambush]}", 2, /round(time)?|You cannot aim that high!|does not have a head!|is already missing that!|does not have a .* leg!|does not have a .* arm!/i
    if result =~ /You cannot aim that high!|does not have a head!|is already missing that!|does not have a (?:right|left) leg!|does not have a (?:right|left) arm!/i
      $bigshot_ambush += 1
      cmd_ambush(nil, target)
    elsif result =~ /round(time)?/i
      $bigshot_ambush = 0
    end
  end

  def cmd_nudge_weapons()
    debug_msg(@DEBUG_COMMANDS, "cmd_nudge_weapons | called by #{caller[0]}")

    return if checkpaths.size == 0

    GameObj.loot.each { |i|
      next unless i.noun =~ /axe|scythe|pitchfork|falchion|sword|lance|sword|dagger|estoc|falchion|handaxe|katana|katar|gauche|rapier|scimitar|whip-blade|cudgel|crowbill|whip|mace|star|hammer|claidhmore|flail|flamberge|maul|pick|staff|mattock/

      change_stance(@WANDER_STANCE)

      sheathed = false
      unless (righthand.nil? || lefthand.nil?)
        sheathed = true
        fput 'sheath'
        unless (righthand.nil? || lefthand.nil?)
          message("yellow", "Unable to empty hands via sheath.")
          break
        end
      end

      # dirs = checkpaths
      dir  = checkpaths.shift
      fput "get ##{i.id}"
      put dir
      put "drop ##{i.id}"
      fput reverse_direction(dir)
      fput "gird" if sheathed
    }
  end

  def cmd_tether(npc, recast_on_transfer = false)
    debug_msg(@DEBUG_COMMANDS, "cmd_tether | called by #{caller[0]}")

    return if npc.status =~ /dead|gone/
    return unless GameObj.targets.any? { |s| s.id == npc.id }
    return unless Spell[706].known? and Spell[706].affordable?

    complete_line = /dissolve into black mist/
    broken_line = /^You struggle to maintain control of the dark force, but you feel it break away\!|^You feel your connection to the dark presence fade away\./
    tether_transferred = /^As the signs of life fade from an? [\w\s\-]+, the tenebrous chains binding [\w\s\-]+ begin to vibrate and emit a sinister thrum that emanates through the surrounding area\.$/

    waitrt?
    waitcastrt?
    time_out = Time.now + 12
    result = Spell[706].force_incant(nil, /dissolve into black mist\./)
    return if result =~ complete_line

    spell_complete = false

    Thread.new do
      while (line = get)
        if line =~ complete_line || line =~ broken_line || Time.now > time_out
          spell_complete = true
          break
        elsif line =~ tether_transferred
          break
        end
      end
    end

    loop do
      break if Time.now > time_out
      break if should_flee?
      break if npc.status =~ /dead|gone/
      break unless GameObj.targets.any? { |s| s.id == npc.id }
      break if spell_complete
      stand unless standing?
      sleep(0.5)
    end

    if recast_on_transfer
      return if spell_complete || Time.now > time_out || should_flee?

      # wait for XMLData.current_target_id to update if DOTs transferred
      if npc.status =~ /dead|gone/ && reget(10).any? { |line| line =~ tether_transferred }
        sleep(0.5)
      end

      # returns if npc died and DOTs didn't transfer
      return if npc.status =~ /dead|gone/ && npc.id == XMLData.current_target_id

      # update npc variable to new possible DOT transferred npc
      npc = GameObj.npcs.find { |potential_npc| potential_npc.id == XMLData.current_target_id && potential_npc.status !~ /dead|gone/ }
      return if npc.nil?                  # returns if no NPC found
      return if npc.status =~ /dead|gone/ # returns if NPC dead
      return unless valid_target?(npc)    # returns if NPC isn't valid
      cmd_tether(npc, recast_on_transfer) # recasts tether on new npc
    end
  end

  def group_status_ailments()
    debug_msg(@DEBUG_STATUS, "group_status_ailments | called by #{caller[0]}")

    if @TROUBADOURS_RALLY && Spell[1040].known?
      if webbed? || sleeping? || stunned? || frozen?
        cmd_1040(Char.name)
      end
      GameObj.pcs.each { |s|
        if s.status =~ /webbed|sleeping|stunned|frozen|immobilized|held in place|horrified|staggered/i && Lich::Gemstone::Group.members.map(&:noun).include?(s.noun)
          cmd_1040(s.noun)
          break
        end
      }
    end
  end

  def group_member_stunned?
    stunned = false
    if webbed? || sleeping? || stunned? || frozen?
      stunned = true
    end
    GameObj.pcs.each { |s|
      if s.status =~ /webbed|sleeping|stunned|frozen|immobilized|held in place|horrified|staggered/i && Lich::Gemstone::Group.members.map(&:noun).include?(s.noun)
        stunned = true
        break
      end
    }

    return stunned
  end

  def message(type = "info", text)
    # color options - set type to use
    # yellow, orange, teal, green, plain

    return if type == "debug" && !$bigshot_debug

    if text.is_a?(Hash)
      text = text.inspect.gsub("#<", "#")
    elsif text.is_a?(Array)
      text = text.to_s
    elsif text.is_a?(String)
      text = text.gsub("#<", "#")
    end

    Lich::Messaging.msg(type, text)
  end

  def dead_man_switch()
    debug_msg(@DEBUG_SYSTEM, "dead_man_switch | called by #{caller[0]}")

    if @DEAD_MAN_SWITCH && XMLData.game =~ /GSF/
      Thread.new {
        while (running?($current_script_name))
          if (dead? || Char.percent_health < 40)
            echo 'AUTOBOT ALERT: Your character is in trouble!'
            fput 'quit'
          end
          sleep(2)
        end
      };
    elsif @DEPART_SWITCH
      start_exec_script(<<-EOF
        while( running?($current_script_name) );
          if(dead?);
              stop_script($current_script_name);
              2.times { fput 'depart' };
              2.times { fput 'depart confirm' };
              Script.start('ewaggle');
              15.times { sleep(60); fput 'info'; };
              sleep(1) until Char.percent_spirit == 100 && !Script.running?('ewaggle');
              Script.start("#{$current_script_name}", 'solo');
              Script.self.kill;
          end;
          sleep(5);
        end;
      EOF
                       );
    else
      Thread.new {
        loop { Script.self.kill if dead?; sleep(5); }
      }
    end
  end

  def monitor_interaction()
    debug_msg(@DEBUG_SYSTEM, "monitor_interaction | called by #{caller[0]}")

    if @MONITOR_INTERACTION
      start_exec_script(<<-eos
        watch_list = /#{@monitor_strings.gsub("||", "|")}/io
        safe_strings = /#{@monitor_safe_strings.gsub("||", "|")}/io

        def show_window(line)
          window_title = Char.name + ':' + line
          Gtk.queue do
            $myWindow = Gtk::Window.new
            $myWindow.title = "Autobot Alert!"
            $myWindow.set_size_request(450, 25)
            label = Gtk::Label.new window_title
            $myWindow.add(label)
            $myWindow.show_all
          end
        end

        while(line = get)
          break unless running?($current_script_name)
          if watch_list.match?(line) && !safe_strings.match?(line)
            show_window(line)
            echo "AUTOBOT ALERT: " + line
          end
        end
      eos
                       )
    end
  end

  def gameobj_npc_check()
    npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| (npc.name =~ /animated/ && npc.name !~ /animated slush/) }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /^(?:arm|appendage|claw|limb|pincer|tentacle)s?$|^(?:palpus|palpi)$/i }

    debug_msg(@DEBUG_COMBAT, "gameobj_npc_check | npcs.size: #{npcs.size.to_i} | called by #{caller[0]}")
    return npcs.size.to_i
  end

  def npc_room_check()
    Thread.new {
      loop {
        $current_room_npcs = GameObj.npcs
        pause 0.5
      }
    }
  end

  def wrack()
    debug_msg(@DEBUG_COMMANDS, "wrack | called by #{caller[0]}")

    if Spell[9918].known? && !Spell[9012].active? && Char.spirit >= @WRACKING_SPIRIT && Char.spirit >= (6 + [9912, 9913, 9914, 9916, 9916, 9916].count { |num| Spell[num].active? })
      Spell[9918].cast
    elsif Spell[9718].known?
      (Char.stamina / 50).times { Spell[9718].cast }
    elsif Spell[9813].known? && !Effects::Cooldowns.active?("Symbol of Mana")
      Spell[9813].cast
    end
  end

  def cur_bounty()
    return bounty?
  end

  def set_bandit_hunting(kill_bandits)
    # Need to circumvent anti-poach and protections some to hunt bandits
    $bigshot_bandits = kill_bandits
  end

  def change_stance(new_stance, force = true)
    debug_msg(@DEBUG_COMMANDS, "change_stance | new_stance: #{new_stance} | force: #{force} | called by #{caller[0]}")
    return if Spell[216].active? || dead?
    return unless checkroom('Ooze, Innards').nil?
    new_stance = new_stance.downcase

    perfect_stance = nil
    if new_stance =~ /10|20|30|40|50|60|70|80|90|100/i
      perfect_stance = new_stance
      new_stance = "advance" if perfect_stance =~ /10|20/i
      new_stance = "forward" if perfect_stance =~ /30|40/i
      new_stance = "neutral" if perfect_stance =~ /50|60/i
      new_stance = "guarded" if perfect_stance =~ /70|80/i
      new_stance = "defensive" if perfect_stance =~ /90|100/i
    end
    if (Char.stance =~ /#{new_stance}/i)
      return
    elsif (checkcastrt() > 0 && new_stance =~ /def/i)
      return if Char.stance == 'guarded'
    end

    if ((force) && (perfect_stance != nil) && (CMan.known?("Stance Perfection")))
      dothistimeout("cman stance #{perfect_stance}", 3, /You are now in an?|You move into an?|You fall back into a|Cast Roundtime in effect|You are unable to change/)
    elsif (force)
      dothistimeout("stance #{new_stance}", 3, /You are now in an?|You move into an?|You fall back into a|Cast Roundtime in effect|You are unable to change/)
    else
      fput "stance #{new_stance}"
    end
  end

  def wait_for_swing(seconds, target = nil)
    debug_msg(@DEBUG_COMBAT, "wait_for_swing | target: #{target} | seconds: #{seconds} | called by #{caller[0]}")

    start = Time.now
    # swung = false
    $stop_wait = false
    $global_target = target.id
    $pcs = checkpcs ? ' you(\.|!|r? )|' + checkpcs.join('|') : 'you(\.|!|r? )'

    wait_for_swing_exec = <<-eos
        status_tags
        while line = get
            $stop_wait = true if line =~ /#{$global_target}.*#{$pcs}|The thorny barrier surrounding you blocks the attack from the .*#{$global_target}/ and line !~ /style id="".*style id="roomDesc"|(?:component|compDef) id='room objs'/
            break if $stop_wait
            break if !running?($current_script_name)
        end
        status_tags
    eos

    ExecScript.start(wait_for_swing_exec, :quiet => true)

    loop do
      change_stance(@WANDER_STANCE, false) unless target && target.status =~ PRONE
      stand() if !standing?
      break if $stop_wait
      break if GameObj.targets.size.nil? || gameobj_npc_check.zero?
      break if should_flee?
      break if target && target.status =~ PRONE
      break if (Time.now - start) > seconds

      sleep(0.25)
    end
  end

  def croak(message)
    debug_msg(@DEBUG_SYSTEM, "croak | message: #{message} | called by #{caller[0]}")

    message("yellow", message);
    croak_scripts(["#{$current_script_name}"])
  end

  def run_script(name, pause_bigshot = false, args = nil)
    debug_msg(@DEBUG_SYSTEM, "run_script | name: #{name} | pause_bigshot: #{pause_bigshot} | args: #{args} | called by #{caller[0]}")

    if Script.running.find { |s| s.name.downcase == name.downcase }.paused || Script.running?(name)
      Script.kill(name)
      wait_while { Script.running?(name) }
    end

    script_ran = Script.start(name, args)
    return if script_ran.nil?
    return unless script_ran.name.is_a?(String) && !script_ran.name.empty?
    if pause_bigshot
      if name == @LOOT_SCRIPT && @BOX_IN_HAND
        looting_watch(script_ran)
      else
        wait_until { !Script.running?(script_ran.name) }
      end
    end
  end

  def run_scripts(scripts, pause_bigshot = false)
    debug_msg(@DEBUG_SYSTEM, "run_scripts | scripts: #{scripts} | pause_bigshot: #{pause_bigshot} | called by #{caller[0]}")

    scripts.each do |i|
      tokens = i.split(/\s+/)
      if (tokens.size > 1)
        run_script(tokens[0], pause_bigshot, tokens[1..-1].join(" "))
      else
        run_script(tokens[0], pause_bigshot)
      end
    end
  end

  def croak_script(name)
    debug_msg(@DEBUG_SYSTEM, "croak_script | script: #{name} | called by #{caller[0]}")

    # check for script name string with args
    name = name.split(/\s+/).first
    kill_script(name) if running?(name)
  end

  def croak_scripts(scripts)
    debug_msg(@DEBUG_SYSTEM, "croak_script | scripts: #{scripts} | called by #{caller[0]}")

    scripts.each { |i| croak_script(i) }
  end

  def hunting_prep
    prep_and_rest_commands(@HUNTING_PREP_COMMANDS)
  end

  def resting_prep
    prep_and_rest_commands(@RESTING_COMMANDS)
  end

  def prep_and_rest_commands(commands)
    commands.each do |cmd|
      if cmd =~ /^script\s+(.*?)(\s|$)(.*)/i
        cmd_run_script($1, $3)
      else
        fput(cmd)
        sleep 0.3
      end
    end
  end

  def stand(stand_command = nil)
    debug_msg(@DEBUG_COMMANDS, "stand | stand_command: #{stand_command} | called by #{caller[0]}")

    return if Array(stand_command).any? { |cmd| cmd =~ /^(?:fire|kneel|hide)|^(?:incant )?608\b/i } && kneeling? && checkleft =~ /^(?:arbalest|kut'ziko|crossbow|kut'zikokra)$/

    original_stance = Char.stance
    until (standing?)
      return unless checkroom('Ooze, Innards').nil?
      change_stance(@STAND_STANCE)
      bs_put 'stand'
    end

    change_stance(original_stance)
  end

  def groupcheck()
    Lich::Gemstone::Group.check unless Lich::Gemstone::Group.checked? && !Lich::Gemstone::Group.broken?
    debug_msg(@DEBUG_STATUS, "groupcheck | Group.members.map(&:noun): #{Lich::Gemstone::Group.members.map(&:noun)} | called by #{caller[0]}")
  end

  def bigclaim?(check_disks: true)
    debug_msg(@DEBUG_STATUS, "bigclaim? | $bigshot_quick: #{$bigshot_quick} | Claim.mine?: #{Lich::Gemstone::Claim.mine?} | Disks: #{(Lich::Gemstone::Disk.all - Lich::Gemstone::Group.disks)} | called by #{caller[0]}")

    return true if $bigshot_quick
    return @group.leader_claim?(check_disks: check_disks) if Char.name != @leader
    return false unless Lich::Gemstone::Claim.mine?
    return false unless @IGNORE_DISKS || (!check_disks || (Lich::Gemstone::Disk.all - Lich::Gemstone::Group.disks).empty?)
    return true
  end

  def ma_looter
    looter = nil

    if solo?
      looter = Char.name
    elsif @RANDOM_LOOT
      encumbrance_hash = @followers.group_encumbrance
      encumbrance_hash[Char.name] = (@ENCUMBERED - Char.percent_encumbrance) # Add the leader
      encumbrance_hash.reject! { |key, _value| @NEVER_LOOT.include?(key) } # Remove any character in the no-loot list

      # Remove or handle nil values
      encumbrance_hash.compact!

      # Find the max
      max_value = encumbrance_hash.values.max

      # Find all party members with the same amount
      all_max_values = encumbrance_hash.select { |_key, value| value == max_value }.keys

      if all_max_values.include?(@MA_LOOTER) # favor the designated looter
        looter = @MA_LOOTER
      else
        looter = all_max_values.sample # otherwise just pick one at random
      end
    elsif !@MA_LOOTER.to_s.empty?
      looter = @followers.get_names.find { |name| name =~ /#{@MA_LOOTER}/i }
    else
      looter_list = @followers.get_names.reject { |element| @NEVER_LOOT.include?(element) }
      if looter_list.include?(@followers.leader_name)
        looter = @followers.leader_name
      else
        looter = looter_list.sample
      end
    end

    debug_msg(@DEBUG_STATUS, "ma_looter | looter: #{looter} | called by #{caller[0]}")
    return looter
  end

  def designated_looter
    @DESIGNATED_LOOTER
  end

  def lead(my_group = nil)
    debug_msg(@DEBUG_STATUS, "lead | called by #{caller[0]}")

    monitor_interaction()
    npc_room_check()
    @followers = my_group || Group.new()
    @leader = Char.name

    groupcheck() if !checkpcs.nil?

    should_rest? && !$bigshot_quick ? rest : hunt
  end

  def find_routine(target)
    debug_msg(@DEBUG_COMBAT, "find_routine | target: #{target} | @DISABLE_COMMANDS.size: #{@DISABLE_COMMANDS.size} | called by #{caller[0]}")

    if (!solo? && fried? && @DISABLE_COMMANDS.size > 0)
      return @DISABLE_COMMANDS
    else
      key = @TARGETS.keys.find { |k| target.name =~ /^#{k}$/i or target.noun =~ /^#{k}$/i }
      if key.nil?
        routine_letter = 'a'
      else
        routine_letter = @TARGETS[key]
      end

      if routine_letter == 'quick' || ($bigshot_quick && key.nil?)
        return @QUICK_COMMANDS unless @QUICK_COMMANDS.size == 0
      elsif routine_letter == 'j'
        return @HUNTING_COMMANDS_J unless @HUNTING_COMMANDS_J.size == 0
      elsif routine_letter == 'i'
        return @HUNTING_COMMANDS_I unless @HUNTING_COMMANDS_I.size == 0
      elsif routine_letter == 'h'
        return @HUNTING_COMMANDS_H unless @HUNTING_COMMANDS_H.size == 0
      elsif routine_letter == 'g'
        return @HUNTING_COMMANDS_G unless @HUNTING_COMMANDS_G.size == 0
      elsif routine_letter == 'f'
        return @HUNTING_COMMANDS_F unless @HUNTING_COMMANDS_F.size == 0
      elsif routine_letter == 'e'
        return @HUNTING_COMMANDS_E unless @HUNTING_COMMANDS_E.size == 0
      elsif routine_letter == 'd'
        return @HUNTING_COMMANDS_D unless @HUNTING_COMMANDS_D.size == 0
      elsif routine_letter == 'c'
        return @HUNTING_COMMANDS_C unless @HUNTING_COMMANDS_C.size == 0
      elsif routine_letter == 'b'
        return @HUNTING_COMMANDS_B unless @HUNTING_COMMANDS_B.size == 0
      end

      return @HUNTING_COMMANDS
    end
  end

  def solo?
    # tails wont have followers
    return @followers && @followers.size == 1
  end

  def leading?
    return !following?
  end

  def following?
    return @followers.nil?
  end

  def no_players_hunt()
    debug_msg(@DEBUG_COMBAT, "no_players_hunt | called by #{caller[0]}")
    return true if $bigshot_quick
    return false if $ambusher_here

    return true
  end

  def pre_hunt(manually_walking = false)
    debug_msg(@DEBUG_COMBAT, "pre_hunt | called by #{caller[0]}")

    if (!solo? && leading?)
      @followers.group_assist(true)
    end

    @followers.add_event(:HUNTING_PREP_COMMANDS)
    hunting_prep

    if !$bigshot_quick && !manually_walking
      unless @INDEPENDENT_TRAVEL
        @followers.add_event(:FOLLOW_NOW) # trigger rubber band
        @followers.add_event(:JOIN_LEADER)
        message("yellow", "Waiting for followers....") if !@followers.all_present?
        sleep(0.5) while (!@followers.all_present?)
      end

      prepare_for_movement(false) if @RALLYPOINT_ROOM_IDS.length.positive?

      if @INDEPENDENT_TRAVEL
        Lich::Util.quiet_command_xml("disband group", /You have no group to disband|You disband your group/)
        until Lich::Gemstone::Group.members.map(&:noun).empty?
          groupcheck()
        end
        @followers.add_event(:GO2_RALLY_ROOM)
        @RALLYPOINT_ROOM_IDS.each { |room| go2(room.to_i) }
      else
        @RALLYPOINT_ROOM_IDS.each { |room|
          go2(room.to_i)
          if !@followers.all_present?
            @followers.add_event(:FOLLOW_NOW) # trigger rubber band
            message("yellow", "Waiting for followers....")
            sleep(0.5) while (!@followers.all_present?)
          end
        }
      end
    end

    Lich::Util.quiet_command_xml("group open", /Your group status/)
    @followers.add_event(:FOLLOW_NOW) # trigger rubber band
    message("yellow", "Waiting for followers....") if !@followers.all_present?
    sleep 0.5 while (!@followers.all_present?)
    groupcheck

    prepare_for_movement()

    @followers.add_event(:HUNTING_SCRIPTS_START)
    run_scripts(@HUNTING_SCRIPTS, false)

    # Start bigshot hunting monitor
    @followers.add_event(:HUNT_MONITOR_START)
    hunt_monitor("start")

    if Stats.prof == "Paladin"
      # Sync charges of Swift Justice or other abilites for buff tracking.
      res = Lich::Util.quiet_command_xml("spell", /<output class="mono"\/>/, /<prompt time=/)
      $bigshot_swift_justice = $1.to_i if res.any? { |line| line =~ /You have stored (\d+) charges of Swift Justice./i }
    end

    if !$bigshot_quick && !manually_walking
      @followers.add_event(:GO2_HUNTING_ROOM) if @INDEPENDENT_TRAVEL
      goto(@HUNTING_ROOM_ID)
    end
    # set autosneak on if we're sneaking
    if @SNEAKY_SNEAKY
      fput("movement autosneak on")
      $bigshot_sneaky_hunt = true
    end

    if (!solo? && leading?)
      Lich::Util.quiet_command_xml("group open", /Your group status/)
      unless @followers.all_present? || !Lich::Gemstone::Group.broken?
        @followers.add_event(:FOLLOW_NOW) # trigger rubber band
        message("yellow", "Waiting for followers....") if !@followers.all_present?
        sleep 0.5 while (!@followers.all_present?)
        groupcheck
      end
      sleep 0.5

      check_for_deaders_prone

      @followers.add_event(:JOIN_LEADER)
      @followers.add_event(:CAST_SIGNS)

      # make sure we're hiding if we're sneaking
      if @followers.need_sneaky?
        message("yellow", "Waiting for followers to hide.")
        @followers.add_event(:CHECK_SNEAKY)
        wait_while { @followers.need_sneaky? }
        sleep 0.5
        wait_while { @followers.roundtime? }
        sleep 0.5
      end

      prepare_for_movement()
    end

    wait_rt

    if @SIGNS.any? { |s| ['902', '411'].include?(s) }
      check_902_411()
    end

    cast_signs()
  end

  def do_hunt() # Finds target and calls attack block
    debug_msg(@DEBUG_COMBAT, "do_hunt | called by #{caller[0]}")

    start_watch()
    message("yellow", 'Bigshot hunting')

    $bigshot_status = :hunting
    target = nil
    old_target = nil
    just_arrived = true
    reset_variables()
    return if should_rest?

    # Is there a target in the room? If not lets go find one.
    target = bs_wander() if !$bigshot_quick

    while true
      # Remove stale events to avoid stale ATTACK commands when entering a room
      @event_stack.reject!(&:stale?)

      while ((target = find_target(target, just_arrived)) && !should_rest? && no_players_hunt && !should_flee?)
        debug_msg(@DEBUG_COMBAT, "inside do_hunt loop | target: #{target}")

        if @PRIORITY && !priority(target)
          target = find_target(nil)
        end

        # Tell follower to attack if its a new target or its been 10 seconds
        if time_between(:last_attack, 10) || old_target != target
          @followers.add_event(:ATTACK)
          old_target = target
        end

        # if delayed looting, lets start the timer
        if @DELAY_LOOT
          time_between(:need_to_loot?, 15)
        end

        # Start the attack sequence
        attack(target)

        # no longer a new room
        just_arrived = false
      end

      # shouldn't be any creatures in the room at this point
      while group_member_stunned?
        sleep 0.5
      end

      # return or exit if needed
      return if should_rest?
      single_stop if $bigshot_quick

      # Go find a new target
      target = bs_wander(new_room: false)
      just_arrived = true
    end
  end

  # this is a leader method
  def hunt()
    debug_msg(@DEBUG_COMBAT, "hunt | called by #{caller[0]}")
    pre_hunt()
    do_hunt()
    rest()
  end

  # this is a leader method
  def rest()
    debug_msg(@DEBUG_COMBAT, "rest | called by #{caller[0]}")

    $bigshot_group_status[Char.name] = $rest_reason
    sorted_hash = $bigshot_group_status.sort_by { |key, _| [key == Char.name ? -1 : 0, key.to_s] }.to_h
    any_wounded = $bigshot_group_status.values.include?("wounded.")

    _respond
    sorted_hash.each { |name, reason|
      next if reason.nil?
      message("yellow", " #{name} resting: #{reason}")
    }
    _respond

    # Stop bigshot hunting monitor
    @followers.add_event(:HUNT_MONITOR_STOP)
    hunt_monitor("stop")

    if @BOUNTY_MODE && (GameObj.npcs.find { |n| n.name =~ /child/i } && checkbounty =~ /^You have made contact with the child you are to rescue/)
      msg = " Exiting: Bounty mode with child rescue."
      message("yellow", msg)
      @BOUNTY_EVAL = ''
      single_stop()
      @followers.add_event(:SINGLE_STOP)
    end

    stop_watch()

    # set autosneak off if we're sneaking
    if @SNEAKY_SNEAKY
      fput("movement autosneak off")
      $bigshot_sneaky_hunt = false
    end

    # reset hunting globals
    $bigshot_should_rest = false
    $bigshot_overkill_counter = 0
    $bigshot_lte_boost_counter = 0

    # Wait for follower to finish looting if needed
    while !@followers.looting_done
      $looting_inactive = @followers.looting_done
      sleep 0.5
    end

    wait_while { @followers.roundtime? }
    prepare_for_movement

    @followers.clear_group_events
    @followers.add_event(:HUNTING_SCRIPTS_STOP)
    croak_scripts(@HUNTING_SCRIPTS)

    if @INDEPENDENT_RETURN
      if Lich::Gemstone::Group.length.positive?
        @followers.add_event(:PREP_REST)
        @followers.add_event(:LEAVE_GROUP)
        @followers.add_event(:FOG_RETURN)
        @followers.add_event(:GO2_WAYPOINTS)
        @followers.add_event(:GO2_RESTING_ROOM)

        Lich::Util.quiet_command_xml("disband group", /You have no group to disband|You disband your group/)
        until Lich::Gemstone::Group.empty?
          groupcheck()
        end
      end

      fog_return
      @RETURN_WAYPOINT_IDS.each { |room| go2(room.to_i) }
      go2(@RESTING_ROOM_ID)
    else
      @followers.add_event(:FOLLOW_NOW)
      Lich::Gemstone::Group.members.each do |pc|
        if pc.status =~ /sitting|^lying|prone/ && pc.status !~ /dead/
          3.times do
            waitrt?
            fput "pull ##{pc.id}"
            break unless pc.status =~ /sitting|^lying|prone/
          end
        end
      end

      fog_return
      @RETURN_WAYPOINT_IDS.each { |room|
        go2(room.to_i)
        @followers.add_event(:FOLLOW_NOW)
        message("yellow", "Waiting for followers....") if !@followers.all_present?
        while (!@followers.all_present?)
          break if any_wounded
          message("yellow", "Waiting for followers....")
          sleep(0.5)
        end
      }

      go2(@RESTING_ROOM_ID)
    end

    escape_rooms

    if (@QUIET_FOLLOWERS) && !any_wounded
      Lich::Util.quiet_command_xml("group open", /Your group status/)
      @followers.add_event(:FOLLOW_NOW)
      message("yellow", "Waiting for followers....") if !@followers.all_present?
      while (!@followers.all_present?)
        break if any_wounded
        sleep(0.5)
      end
      sleep 2

      resting_prep
      run_scripts(@RESTING_SCRIPTS, true)

      @followers.add_event(:RESTING_PREP_COMMANDS)
      @followers.add_event(:RESTING_SCRIPTS_START)
    else
      @followers.add_event(:RESTING_PREP_COMMANDS)
      @followers.add_event(:RESTING_SCRIPTS_START)

      resting_prep
      run_scripts(@RESTING_SCRIPTS, true)
    end

    # join everyone back to the leader
    Lich::Util.quiet_command_xml("group open", /Your group status/)
    @followers.add_event(:JOIN_LEADER)
    message("yellow", "Waiting for followers....") if (!@followers.all_present? || @followers.roundtime? || !@followers.rest_prep_complete?)
    wait_while { !@followers.all_present? }
    wait_while { @followers.roundtime? }
    wait_while { !@followers.rest_prep_complete? }
    sleep 2

    if $bigshot_single || (@BOUNTY_MODE && ($rest_reason =~ /bounty complete/i || Script.running?('ebounty')))
      msg = $bigshot_single ? " Exiting Bigshot: Single loop complete" : " Exiting Bigshot: Bounty mode - #{$rest_reason}"
      respond
      message("yellow", msg)
      respond
      @followers.add_event(:SINGLE_STOP)
      single_stop()
    end

    # this doesn't seem to do anything? Custom bit for something?
    if (!solo? && leading?)
      @followers.group_assist(true)
    end

    until (should_hunt?)
      @followers.add_event(:DISPLAY_WATCH)
      fput 'exp'
      sleep 0.2
      display_watch()
      message("yellow", "Bigshot last rested because: #{$rest_reason}") unless $rest_reason.nil?

      $bigshot_group_status[Char.name] = $not_hunting_reason
      sorted_hash = $bigshot_group_status.sort_by { |key, _| [key == Char.name ? -1 : 0, key.to_s] }.to_h

      sorted_hash.each { |name, reason|
        next if reason.nil? || reason == "ready"
        message("yellow", "#{name} isn't hunting because: #{reason}")
      }
      _respond
      sleep($bigshot_rest_interval)
    end

    # make sure we get everyone recognized as part of the group
    groupcheck()
    wait_rt

    hunt()
  end

  def mana_pulse(spell_id)
    debug_msg(@DEBUG_COMMANDS, "mana_pulse | spell_id: #{spell_id} | called by #{caller[0]}")

    return unless Spell[spell_id].known? && !Spell[spell_id].affordable?

    mana_regex = Regexp.union(
      /An invigorating rush of mana pulses through you/i,
      /You are too mentally fatigued to attempt this ability/i,
      /You're already at full mana./i,
      /Your mana control skills are not yet advanced/i,
    )

    dothistimeout "mana pulse", 2, mana_regex
    sleep 0.2
  end

  def fog_return_spirit(from_voln = false)
    debug_msg(@DEBUG_COMBAT, "fog_return_spirit | from_voln: #{from_voln} | called by #{caller[0]}")

    current_room = Room.current.id
    mana_pulse(130)
    if Spell[130].known? && Spell[130].affordable?
      Spell[130].cast()
      sleep 0.5
      waitcastrt?
      if Room.current.id == 2635 && @FOG_RIFT && @RESTING_ROOM_ID != 2635 && current_room != Room.current.id
        mana_pulse(130)

        Spell[130].cast() if Spell[130].known? && Spell[130].affordable?
        sleep 0.5
        waitcastrt?
      end
    end

    # Something went wrong and 130 didn't work. Trying symbol of return
    if current_room == Room.current.id && Spell[9825].known? && !from_voln
      fog_return_voln(true)
    end
  end

  def fog_return_voln(from_130 = false)
    debug_msg(@DEBUG_COMBAT, "fog_return_voln | from_130: #{from_130} | called by #{caller[0]}")

    current_room = Room.current.id
    if Spell[9825].known?
      fput 'symbol of return'
      sleep(0.5)

      if current_room != Room.current.id && Room.current.id == 2635 && @FOG_RIFT && @RESTING_ROOM_ID != 2635
        fput 'symbol of return'
        sleep 0.5
      end
    end

    # Something went wrong and sym of return didn't work. Trying 130
    if current_room == Room.current.id && Spell[130].known? && !from_130
      fog_return_spirit(true)
    end
  end

  def fog_return
    debug_msg(@DEBUG_COMBAT, "fog_return | called by #{caller[0]}")

    return if @FOG_RETURN.to_i.zero?
    return if @FOG_OPTIONAL && $rest_reason !~ /wounded|encumbered/

    sleep(0.5)
    waitcastrt?
    waitrt?

    case @FOG_RETURN.to_i
    when 1 # Spirit Guide(130)
      fog_return_spirit
    when 2 # Symbol of Return
      fog_return_voln
    when 3 # Travelers Song(1020)
      mana_pulse(1020)
      sleep(0.2)
      Spell[1020].cast() if Spell[1020].known? && Spell[1020].affordable?
    when 4 # GoS - Sigil of Escape
      if Spell[9720].known? && Spell[9720].affordable?
        Spell[9720].cast()
        sleep(0.5)
        waitcastrt?
        waitrt?
      end
    when 5 # Familiar Gate
      mana_pulse(930)

      if Spell[930].known? && Spell[930].affordable?
        Spell[930].cast()
        fput 'go portal'
        sleep(0.5)
        waitcastrt?
        waitrt?
        escape_rooms
      end
    when 6 # Custom
      @CUSTOM_FOG.each do |i|
        if i =~ /^script\s+(.*?)(\s|$)(.*)/i
          cmd_run_script($1, $3)
        else
          fput(i)
          sleep(0.3)
        end
      end
    end
  end

  def attack_break(target)
    break_conditions = {
      "No Claim"                  => !bigclaim?(check_disks: false),
      "Invalid target"            => !valid_target?(target),
      "Should Rest"               => $bigshot_should_rest,
      "Ambusher present"          => $ambusher_here,
      "Should rest"               => should_rest?,
      "Priority target available" => !$bigshot_bandits && @PRIORITY && !priority(target),
      "Event stack has PREP_REST" => @event_stack.any? { |a| a.type == :PREP_REST }
    }

    break_conditions.each do |condition, result|
      if result
        debug_msg(@DEBUG_COMBAT, "attack_break| target: #{target} | returning true from attack_break | reason: #{condition}")
        return true
      end
    end

    return false
  end

  def attack(target) # Starts the process when a target is found
    commands = find_routine(target)
    debug_msg(@DEBUG_COMBAT, "attack | commands #{commands} | called by #{caller[0]}")

    if XMLData.current_target_id != target.id
      # Rest variables and retarget if target changed
      reset_variables(false)
      bs_put "target ##{target.id}" if target.status !~ /dead|gone/
    end

    # Make sure followers are attacking
    @followers.add_event(:ATTACK)

    commands.each do |i|
      break if attack_break(target)

      group_status_ailments() if @TROUBADOURS_RALLY && Spell[1040].known?
      stand(i) if !standing?
      cast_signs()

      debug_msg(@DEBUG_COMBAT, "reaction_check | $bigshot_reaction: #{$bigshot_reaction} | weapon reaction enabled: #{@WEAPON_REACTION}")
      perform_reaction if ($bigshot_reaction != nil) && @WEAPON_REACTION
      cmd(i, target)
    end

    # Check for Roa'ter swallowing or Hinterwilds Ooze swallowing
    escape_rooms

    # run loot check after every command set
    need_to_loot?
  end

  def need_to_loot?(final_loot = false)
    return unless bigclaim?(check_disks: false)
    return unless leading?
    return unless checkroom("Duskruin Arena, Dueling Sands").nil?
    return if should_flee?
    return if $ambusher_here
    return unless @followers.looting_done

    # if no deaders and valid targets just return
    dead_npcs = GameObj.npcs.find_all { |i| i.status == 'dead' && i.type !~ /escort/i }
    valid_targets = sort_npcs.any? { |s| valid_target?(s) }
    return if dead_npcs.length.to_i.zero? && valid_targets

    # check timer if delayed loot
    if @DELAY_LOOT && valid_targets && !final_loot
      return unless time_between(:need_to_loot?, 15)
    end

    # determine the looter
    @DESIGNATED_LOOTER = ma_looter

    debug_msg(@DEBUG_COMBAT, "need_to_loot | final_loot: #{final_loot} | @DESIGNATED_LOOTER: #{@DESIGNATED_LOOTER} | called by #{caller[0]}")

    $looting_inactive = false
    if Char.name == @DESIGNATED_LOOTER
      loot()
      $looting_inactive = true
    else
      @followers.set_group_looting_active
      @followers.add_event(:PREP_REST)
      @followers.add_event(:LOOT)
    end

    # update the experience bucket
    check_mind

    if @BOUNTY_MODE && (bounty_check?)
      $bigshot_should_rest = true
      $rest_reason = "Bounty should be complete/ready"
    end
  end

  def loot()
    debug_msg(@DEBUG_COMBAT, "loot | called by #{caller[0]}")

    # get a list of dead npcs
    dead_npcs = GameObj.npcs.find_all { |i| i.status == 'dead' && i.type !~ /escort/i }

    if gameobj_npc_check.positive? && @LOOT_STANCE
      change_stance('defensive')
    end

    # if no deaders just do a final loot
    if (dead_npcs.empty? || dead_npcs.nil?) && !GameObj.loot.nil?
      waitrt?
      if (@LOOT_SCRIPT)
        run_script(@LOOT_SCRIPT, true)
      else
        bs_put "loot room"
      end
    else
      dead_npcs.each do |i|
        next if i.status =~ /gone/
        waitrt?
        use_lte_boost()
        add_overkill()

        if (@LOOT_SCRIPT)
          run_script(@LOOT_SCRIPT, true)
        else
          bs_put "loot ##{i.id}"
          bs_put "loot room"
        end

        break unless GameObj.npcs.any? { |npc| npc.status == 'dead' && npc.type !~ /escort/i }
      end
    end
  end

  def looting_watch(script_ran)
    loop do
      break if Script.paused?(script_ran.name)
      break if !Script.running?(script_ran.name)
      sleep 0.1
    end

    box_in_hand = [GameObj.right_hand, GameObj.left_hand].find { |i| i.type =~ /box/ }
    if Script.paused?(script_ran.name) && box_in_hand
      $bigshot_should_rest = true
      $rest_reason = "Box in hand, couldn't store"
      Script.kill(script_ran.name)
    end
  end

  def go2(place)
    debug_msg(@DEBUG_COMMANDS, "go2 | place: #{place} | called by #{caller[0]}")

    fput('unhide') if (hidden? || invisible?)
    return if Room.current.id == place.to_i || Room.current.tags.include?(place)
    Script.run('go2', "#{place} --disable-confirm", { quiet: true })
  end

  def goto(id, cast_signs_moving = true)
    debug_msg(@DEBUG_COMMANDS, "goto | id: #{id} | cast_signs_moving: #{cast_signs_moving} | called by #{caller[0]}")

    prepare_for_movement(cast_signs_moving)

    until (Room.current.id == id)
      run_script('go2', true, "#{id} --disable-confirm")
    end
  end

  def start_watch()
    debug_msg(@DEBUG_SYSTEM, "start_watch | called by #{caller[0]}")

    @START_TIME = Time.now.to_i
    @followers.add_event(:START_WATCH)
  end

  def stop_watch()
    debug_msg(@DEBUG_SYSTEM, "stop_watch | called by #{caller[0]}")

    if (@START_TIME > 100)
      @STORED_TIMES.push(Time.now.to_i - @START_TIME)
      @followers.add_event(:STOP_WATCH)
    end
    @START_TIME = 0
  end

  def display_watch()
    debug_msg(@DEBUG_SYSTEM, "display_watch | called by #{caller[0]}")

    # current
    if (@STORED_TIMES.size > 0)
      seconds = @STORED_TIMES[-1]
      message("yellow", sprintf("Bigshot: Last Hunt: %d min. %0.2f secs.", seconds / 60, seconds % 60))
    end

    # average
    average = 0
    if (@STORED_TIMES.size == 1)
      average = @STORED_TIMES[0]
      message("yellow", sprintf("Bigshot: Average Hunt: %d min. %0.2f secs.", average / 60, average % 60))
    elsif (@STORED_TIMES.size > 1)
      @STORED_TIMES.each { |i| average += i }
      average /= @STORED_TIMES.size
      message("yellow", sprintf("Bigshot: Average Hunt: %d min. %0.2f secs.", average / 60, average % 60))
    end

    # total
    total = Time.now.to_i - @BIRTH_TIME
    message("yellow", sprintf("Bigshot: Total Time Running: %d min.  %0.2f secs.", total / 60, total % 60))
  end

  def display_items_for_blessing()
    debug_msg(@DEBUG_STATUS, "display_items_for_blessing | called by #{caller[0]}")

    $bigshot_bless = $bigshot_bless - ["", nil]
    bless_bundles = false
    if $bigshot_bless.count > 0
      message("yellow", "Bigshot: The following items should be blessed before next hunt")
      $bigshot_bless.each { |id|
        noun = GameObj.inv.find { |obj| obj.id == "#{id}" }
        if noun.nil? or noun.empty?
          bless_bundles = true
        else
          message("yellow", "Bigshot: #{noun}")
        end
      }
      message("yellow", "Bigshot: arrows or other bundled weapon-type") if bless_bundles
    end
    bless_bundles = false
  end

  def single_stop()
    debug_msg(@DEBUG_SYSTEM, "single_stop | called by #{caller[0]}")

    Script.self.kill
    sleep 0.5
  end

  def room_id()
    return Room.current.id()
  end

  def name()
    return Char.name
  end

  def perform_reaction()
    debug_msg(@DEBUG_COMBAT, "performing weapon reaction | $bigshot_reaction: #{$bigshot_reaction} | called by #{caller[0]}")
    original_stance = Char.stance
    change_stance(@HUNTING_STANCE)
    fput "weapon #{$bigshot_reaction}"
    change_stance(original_stance)
    $bigshot_reaction = nil
  end

  def get_grouplist()
    debug_msg(@DEBUG_STATUS, "get_grouplist | Group.members.map(&:noun): #{Lich::Gemstone::Group.members.map(&:noun)} | called by #{caller[0]}")

    return Lich::Gemstone::Group.members.map(&:noun)
  end

  def should_flee?(just_entered = false)
    debug_msg(@DEBUG_COMBAT, "should_flee | just_entered: #{just_entered} | called by #{caller[0]}")

    return false if $bigshot_quick
    return true if $bigshot_flee

    GameObj.loot.each do |i|
      return true if (@FLEE_CLOUDS && (i.noun =~ /cloud|breath/ || i.name == 'intense shimmering circle'))
      return true if (@FLEE_VINES && i.noun =~ /vine/)
      return true if (@FLEE_WEBS && i.noun =~ /web/)
      return true if (@FLEE_VOIDS && i.name =~ /black void/)
    end

    return true if GameObj.npcs.any?  { |i| @ALWAYS_FLEE_FROM.include?(i.noun) or @ALWAYS_FLEE_FROM.include?(i.name) }
    return true if checkpcs.any?      { |i| @ALWAYS_FLEE_FROM.include?(i) }

    return false if $bigshot_bandits

    return true if GameObj.targets.any? { |i| i.type =~ /boon/ } && @BOON_FLEE_FROM

    return true if !leading? && checkpcs.empty?

    npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| (@INVALID_TARGETS.include?(npc.name) or @INVALID_TARGETS.include?(npc.noun)) }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /^(?:arm|appendage|claw|limb|pincer|tentacle)s?$|^(?:palpus|palpi)$/i }
    npcs.delete_if { |npc| npc.noun =~ /^(?:grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i }
    npcs.delete_if { |npc| ['quickly growing troll king', 'severed troll arm', 'severed troll leg'].include?(npc.name) }
    npcs.delete_if { |npc| npc.type =~ /companion|familiar/i && npc.type !~ /aggressive npc/i }

    flee_count = (just_entered && @LONE_TARGETS_ONLY) ? 1 : @FLEE_COUNT

    return npcs.size > flee_count
  end

  def valid_target?(target, just_entered = false)
    debug_msg(@DEBUG_COMBAT, "valid_target? | target: #{target} | called by #{caller[0]}")

    # Initial set of invalid conditions
    invalid_conditions = {
      'target == nil || target == false'                         => !target,
      'should_flee?(just_entered)'                               => should_flee?(just_entered),
      'target.status =~ /dead|gone/'                             => target.status =~ /dead|gone/,
      'target gone from GameObj.targets collection'              => GameObj.targets.none? { |n| n.id == target.id },
      'target.name contains animated but not an animated slush/' => target.name =~ /animated/ && target.name !~ /animated slush/,
    }

    invalid_conditions.each do |condition, result|
      if result
        debug_msg(@DEBUG_COMBAT, "valid_target?| returning false for #{target.name} | reason: #{condition}")
        if target.name =~ /animated/ && target.name !~ /animated slush/ && target.status !~ /dead|gone/
          CharSettings['untargetable'].push(target.name)
        end

        return false
      end
    end

    # Still here? Make sure we can target it. If not add to CharSettings['untargetable']
    if (!CharSettings['targetable'].include?(target.name) && !CharSettings['untargetable'].include?(target.name) && target.status !~ /dead|gone/)
      result = dothistimeout("target ##{target.id}", 3, /^You are now targeting|^You can't target|^You discern that you are the origin|^You are unable to discern the origin/)
      if (result =~ /^You are now targeting/)
        CharSettings['targetable'].push(target.name) if target.status !~ /dead|gone/
      elsif (result =~ /^You can't target|^You discern that you are the origin|^You are unable to discern the origin/)
        CharSettings['untargetable'].push(target.name) if target.status !~ /dead|gone/
      end
    end

    if CharSettings['untargetable'].include?(target.name)
      debug_msg(@DEBUG_COMBAT, "valid_target? | returning false - untargetable | called by #{caller[0]}")
      return false
    end

    if (@TARGETS.nil? or @TARGETS.keys.any? { |i| target.name =~ /#{i}/i or target.noun =~ /#{i}/i })
      debug_msg(@DEBUG_COMBAT, "valid_target? | returning true for #{target.name} | called by #{caller[0]}")
      return true
    else
      debug_msg(@DEBUG_COMBAT, "valid_target? | not sure what this is. returning false for #{target.name} | called by #{caller[0]}")
      return false
    end
  end

  def sort_npcs()
    # If statement just figures out the target hash
    if $bigshot_quick || $bigshot_bandits
      targets = Hash.new

      # Initialize @QUICKHUNT_TARGETS only if it's nil
      @QUICKHUNT_TARGETS ||= Hash.new

      # Collect non-dead, non-gone NPCs
      npcs = GameObj.targets.reject { |i| i.status =~ /dead|gone/ }

      # Remove untargetable NPCs
      npcs.reject! { |npc| CharSettings['untargetable'].include?(npc.name) }

      # Further filter for bandits, if required
      if $bigshot_bandits
        npcs.reject! { |npc| npc.noun !~ @BANDIT_NOUN_REGEX }
      end

      # Collect unique NPC names
      tokens = npcs.map(&:name).uniq

      # Assign "quick" to each token if @QUICKHUNT_TARGETS is empty
      tokens.each { |i| targets[i] = "quick" } if @QUICKHUNT_TARGETS.empty?

      # Initialize and merge targets into @TARGETS
      @TARGETS ||= Hash.new
      @TARGETS.replace(@QUICKHUNT_TARGETS).merge!(targets)

      targets = @TARGETS
    else
      targets = @TARGETS
    end

    debug_msg(@DEBUG_COMBAT, "sort_npcs | npcs: #{targets.keys.flat_map { |target| GameObj.targets.select { |npc| npc.name =~ /^#{target}$/i || npc.noun =~ /^#{target}$/i } }} | called by #{caller[0]}")
    return targets.keys.flat_map { |target| GameObj.targets.select { |npc| npc.name =~ /^#{target}$/i || npc.noun =~ /^#{target}$/i } }
  end

  def priority(target)
    return true if (!$current_room_npcs.zip($room_npcs_last_check).map { |x, y| x.id == y.id }.any? { |s| s == false })

    $room_npcs_last_check = GameObj.npcs
    priority = false
    stoppriority = false
    npcs = GameObj.targets.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    @TARGETS.keys.each do |t|
      break if stoppriority == true

      npcs.each do |s|
        break if stoppriority == true

        if (s.name =~ /#{t}/i or s.noun =~ /#{t}/i)
          if s.name == target.name
            stoppriority = true
            priority = true
          else
            stoppriority = true
          end
        end
      end
    end

    debug_msg(@DEBUG_COMBAT, "priority check | target: #{target} | priority: #{priority} | called by #{caller[0]}")
    return priority
  end

  def find_target(target, just_entered = false)
    debug_msg(@DEBUG_COMBAT, "find_target | target: #{target} | just_entered: #{just_entered} | called by #{caller[0]}")

    tmp_valid = valid_target?(target, just_entered) # Exists solely for debug printout
    if tmp_valid
      debug_msg(@DEBUG_COMBAT, "find_target | returning target - valid target: #{target}")
      return target
    end

    if @PRIORITY && !$bigshot_bandits
      debug_msg(@DEBUG_COMBAT, "find_target | @PRIORITY: #{@PRIORITY} && !$bigshot_bandits")
      sort_npcs.each { |i| return i if valid_target?(i, just_entered) && priority(i) }
    else
      sort_npcs.each { |i| return i if valid_target?(i, just_entered) }
    end
    debug_msg(@DEBUG_COMBAT, "find_target | returning nil | called by #{caller[0]}")
    return nil
  end

  def rt?()
    return checkrt()
  end

  def rest_prep_done?
    @REST_PREP || false
  end

  def fried?()
    debug_msg(@DEBUG_STATUS, "fried? | @CORRECT_PERCENT_MIND: #{@CORRECT_PERCENT_MIND} | @FRIED: #{@FRIED} | called by #{caller[0]}")

    return false if $bigshot_quick || @FRIED > 100
    @CORRECT_PERCENT_MIND >= @FRIED
  end

  def oom?()
    debug_msg(@DEBUG_STATUS, "oom? | Char.percent_mana: #{Char.percent_mana} | @OOM: #{@OOM} | called by #{caller[0]}")

    return false if @OOM.negative?
    Char.percent_mana < @OOM
  end

  def player_hidden?
    return hidden?
  end

  def sneaky_hunt?
    return @SNEAKY_SNEAKY
  end

  def encumbrance?
    debug_msg(@DEBUG_STATUS, "encumbrance? | [Char.percent_encumbrance, @ENCUMBERED]: #{[Char.percent_encumbrance, @ENCUMBERED]} | called by #{caller[0]}")
    return [Char.percent_encumbrance, @ENCUMBERED]
  end

  def saturated?()
    debug_msg(@DEBUG_STATUS, "saturated? | checkmind =~ /saturated/: #{checkmind =~ /saturated/} | called by #{caller[0]}")
    checkmind =~ /saturated/
  end

  def overkill?()
    debug_msg(@DEBUG_STATUS, "overkill? | called by #{caller[0]}")
    $bigshot_overkill_counter >= @OVERKILL && lte_boost?
  end

  def set_help_group(keep_attacking)
    debug_msg(@DEBUG_COMBAT, "set_help_group | keep_attacking: #{keep_attacking} | called by #{caller[0]}")
    @HELP_GROUP_KILL = keep_attacking
  end

  def lte_boost?()
    debug_msg(@DEBUG_STATUS, "lte_boost? | called by #{caller[0]}")
    $bigshot_lte_boost_counter >= @LTE_BOOST
  end

  def use_lte_boost()
    debug_msg(@DEBUG_COMMANDS, "use_lte_boost | called by #{caller[0]}")

    if (fried? && !lte_boost?) # Need the check because of the race condition caused if you are a follower in RT when called
      boost_attempt = dothistimeout "boost longterm", 3, /You do not have any Long-Term Experience Boosts to redeem.|You have deducted 500 experience points from your field experience/
      if boost_attempt =~ /You do not have any Long-Term Experience Boosts to redeem./
        message("yellow", "No more LTE boosts available - Skipping")
        $bigshot_lte_boost_counter = @LTE_BOOST
        add_overkill()
      elsif boost_attempt =~ /You have deducted 500 experience points from your field experience/
        $bigshot_lte_boost_counter += 1
        message("yellow", "Used LTE Boost: #{$bigshot_lte_boost_counter} of #{@LTE_BOOST}")
        $bigshot_overkill_counter = 0
      end
    end
  end

  def check_mind
    @followers.add_event(:CHECK_MIND)
    if percentmind() < 100
      @CORRECT_PERCENT_MIND = percentmind()
      debug_msg(@DEBUG_STATUS, "check_mind | percentmind(): #{percentmind()} | called by #{caller[0]}")
    else
      lines = Lich::Util.quiet_command_xml("experience", /<output class="mono"\/>/)

      if lines.any? { |l| l =~ /Field Exp\:\s*([0-9,]+)\/([0-9,]+)/i }
        in_bucket = $1.delete(",").to_f
        max_bucket = $2.delete(",").to_f
      end

      actual_percent = (in_bucket / max_bucket) * 100
      if actual_percent.nil?
        @CORRECT_PERCENT_MIND = percentmind()
      else
        @CORRECT_PERCENT_MIND = actual_percent
      end
      debug_msg(@DEBUG_STATUS, "check_mind | in_bucket: #{in_bucket} | max_bucket: #{max_bucket} | actual_percent: #{actual_percent} | called by #{caller[0]}")
    end

    return @CORRECT_PERCENT_MIND
  end

  def ammo_on_ground(ammo) # Not used
    debug_msg(@DEBUG_COMBAT, "ammo_on_ground | ammo: #{ammo} | called by #{caller[0]}")
    return GameObj.loot.find { |i| i.name =~ /\b#{ammo}s?\b/i or i.noun =~ /^#{ammo}s?$/i }
  end

  def gather_ammo() # Not used
    debug_msg(@DEBUG_COMMANDS, "gather_ammo | called by #{caller[0]}")

    ammo = @AMMO
    container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
    hide = @HIDE_FOR_AMMO

    return if wounded?

    if ammo.nil? or ammo.empty?
      return
    end

    if ammo =~ /\b(arrow|bolt|dart)\b/i
      ammo_noun = $1
    else
      echo "failed to gather: invalid ammo type specified (use the full name)"
    end

    if container.nil?
      echo "failed to gather: you must specify an ammo container to use this feature"
      return
    end

    while (ammo_on_ground(ammo_noun))
      change_stance(@WANDER_STANCE)

      unless GameObj.right_hand.id.nil?
        line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
      end

      result = dothistimeout("gather #{ammo_noun}", 2, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/)

      if (result =~ /on the ground/)
        result = dothistimeout "get #{ammo_noun}s", 3, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/
      end

      if (result =~ /^You gather|^You pick up/)
        dothistimeout("put my #{ammo_noun} in my #{ammo_noun}s in my #{container.noun}", 2, /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/)
        bs_put "put my #{ammo_noun} in my ##{container.id}" if righthand?
      elsif (result =~ /You may only/)
        return
      elsif (result == false || result =~ /^I could not find|^What were you/)
        return
      elsif (result =~ /reach/)
        bs_put 'hide' if hide and not hidden?
        sleep(4)
      end
    end
  end

  def reset_variables(moved = true)
    debug_msg(@DEBUG_SYSTEM, "reset_variables | moved: #{moved} | called by #{caller[0]}")

    if moved
      $ambusher_here = false
      $bigshot_smite_list = []
      $bigshot_703_list = []
      $bigshot_1614_list = []
    end
    $bigshot_aim = 0
    $bigshot_ambush = 0
    $bigshot_archery_aim = 0
    $bigshot_archery_stuck_location = []
    $bigshot_dislodge_location = []
    $bigshot_unarmed_tier = 1
    $bigshot_unarmed_followup = false
    $bigshot_unarmed_followup_attack = ""
    $bigshot_reaction = nil
  end

  def wounded?()
    debug_msg(@DEBUG_STATUS, "wounded? | called by #{caller[0]}")

    return false if $bigshot_quick
    return eval(@WOUNDED_EVAL) if @WOUNDED_EVAL
    return false
  end

  def creeping_dread?
    debug_msg(@DEBUG_STATUS, "creeping_dread? | called by #{caller[0]}")

    Effects::Debuffs.to_h.keys.map(&:to_s).find { |k| k.include? "Creeping Dread" }.match(/\((\d+)\)/)[1].to_i
    counter = $1.to_i
    return counter >= @CREEPING_DREAD && @CREEPING_DREAD > 0
  end

  def crushing_dread?
    debug_msg(@DEBUG_STATUS, "crushing_dread? | called by #{caller[0]}")

    Effects::Debuffs.to_h.keys.map(&:to_s).find { |k| k.include? "Crushing Dread" }.match(/\((\d+)\)/)[1].to_i
    counter = $1.to_i
    return counter >= @CRUSHING_DREAD && @CRUSHING_DREAD > 0
  end

  def wot_poison?
    debug_msg(@DEBUG_STATUS, "wot_poison? | called by #{caller[0]}")

    poisoned = Effects::Debuffs.to_h.keys.any? { |key| key.to_s =~ /Wall of Thorns Poison/ }
    return poisoned && @WOT_POISON == true
  end

  def bounty_check?()
    return false unless @BOUNTY_MODE
    return false if @BANDIT_HUNTING && GameObj.targets.any? { |target| target.type =~ /bandit/ }

    if @BOUNTY_EVAL.to_s.empty?
      Lich::Messaging.msg('error', " Bigshot is running in bounty mode and bounty_eval is empty. Exiting...")
      exit
    end

    result = eval(@BOUNTY_EVAL)

    debug_msg(@DEBUG_STATUS, "bounty_check? | result: #{result} | called by #{caller[0]}")
    return result
  end

  def ready_to_hunt?
    debug_msg(@DEBUG_STATUS, "ready_to_hunt? | called by #{caller[0]}")

    $not_hunting_reason = nil
    not_hunting = {
      'wounded.'                           => lambda { wounded? },
      'encumbered.'                        => lambda { Char.percent_encumbrance >= @ENCUMBERED },
      'creeping dread active.'             => lambda { creeping_dread? },
      'crushing dread active.'             => lambda { crushing_dread? },
      'confusion debuff active.'           => lambda { Effects::Debuffs.active?("Confused") && @CONFUSION == true },
      'wall of thorns poison active.'      => lambda { wot_poison? },
      'resting scripts are still running.' => lambda { @RESTING_SCRIPTS.any? { |i| running?(i) } },
      'mind still above threshold.'        => lambda { @CORRECT_PERCENT_MIND > @REST_TILL_EXP },
      'mana still below threshold.'        => lambda { Char.percent_mana < @REST_TILL_MANA },
      'spirit still below threshold.'      => lambda { Char.spirit < @REST_TILL_SPIRIT },
      'stamina still below threshold.'     => lambda { Char.percent_stamina < @REST_TILL_PERCENTSTAMINA }
    }

    not_hunting.each do |reason, condition|
      if condition.call
        $not_hunting_reason = reason
        return reason
      end
    end

    return "ready"
  end

  def should_hunt?()
    debug_msg(@DEBUG_STATUS, "should_hunt? | called by #{caller[0]}")

    if @BOUNTY_MODE && (bounty_check?)
      message("yellow", " Bounty mode. Killing self. Reason: Bounty available or complete.")
      @BOUNTY_EVAL = ''
      $bigshot_status = :rest_stop
      exit
    end

    check_mind

    leader_reason = ready_to_hunt?
    group_reason = @followers.group_should_hunt?

    if (group_reason && leader_reason == "ready")
      $bigshot_status = :ready
      $rest_reason = nil
      return true
    else
      $not_hunting_reason = leader_reason
      return false
    end
  end

  def ready_to_rest?
    debug_msg(@DEBUG_STATUS, "ready_to_rest? | called by #{caller[0]}")
    return false if $bigshot_quick

    # Define rest_conditions with lambda functions representing conditions
    rest_conditions = {
      bounty_mode: lambda { @BOUNTY_MODE && $bigshot_should_rest },
      should_rest: lambda { $bigshot_should_rest },
      wounded: lambda { wounded? },
      percentencumbrance: lambda { Char.percent_encumbrance >= @ENCUMBERED },
      creeping_dread: lambda { creeping_dread? },
      crushing_dread: lambda { crushing_dread? },
      wot_poison: lambda { wot_poison? },
      confusion_debuff: lambda { @CONFUSION == true && Effects::Debuffs.active?("Confused") },
      fried_overkill_and_lte_boost: lambda { fried? && overkill? && lte_boost? },
      oom: lambda { oom? }
    }

    # Define rest_actions with lambda functions representing actions
    rest_actions = {
      bounty_mode: lambda { $rest_reason = 'bounty complete.' },
      should_rest: lambda { $rest_reason ? $rest_reason : $rest_reason = '$bigshot_should_rest was set to true.' },
      wounded: lambda { $rest_reason = 'wounded.' },
      percentencumbrance: lambda { $rest_reason = 'encumbered.' },
      creeping_dread: lambda { $rest_reason = 'creeping dread limit.' },
      crushing_dread: lambda { $rest_reason = 'crushing dread limit.' },
      wot_poison: lambda { $rest_reason = 'wall of thorns poison.' },
      confusion_debuff: lambda { $rest_reason = 'confusion debuff.' },
      fried_overkill_and_lte_boost: lambda { $rest_reason = 'fried.' },
      oom: lambda { wrack() if @USE_WRACKING; return false unless oom?; $rest_reason = 'out of mana.' }
    }

    # Iterate through rest_conditions and execute corresponding actions from rest_actions
    rest_conditions.each do |condition, lambda_function|
      if lambda_function.call
        if rest_actions[condition].call
          $bigshot_status = :resting
          return $rest_reason
        end
      end
    end
    return false
  end

  def should_rest?()
    debug_msg(@DEBUG_STATUS, "should_rest? | called by #{caller[0]}")

    group_rest = @followers.group_should_rest?
    leader_rest = ready_to_rest?

    # return false if no one needs to rest
    return false if !group_rest && !leader_rest

    # combine all the rest reasons
    rest_reasons = $bigshot_group_status.to_a.map { |_, reason| reason }.push($rest_reason)
    rest_reasons.compact!

    # return false if some are fried but others aren't and no other issues
    if rest_reasons.all? { |reason| reason =~ /fried/ } && (rest_reasons.length < @followers.size.to_i || @followers.size.to_i.zero?)
      return false
    end

    # wounded check
    if rest_reasons.any? { |reason| reason.match?(/wounded/) }
      return false if group_member_stunned?
    end

    # Otherwise we need to rest for some reason
    # call loot for certain situations but not if wounded
    if rest_reasons.any? { |reason| reason.match?(/dread limit|bounty complete|fried|out of mana|encumbered/) } && !$ambusher_here && bigclaim? && !rest_reasons.include?('wounded.')
      need_to_loot?(true)
    end
    # Fixme: wounded group members need to be mobile before leaving
    $bigshot_status = :resting
    return true
  end

  def add_overkill()
    debug_msg(@DEBUG_COMBAT, "add_overkill | called by #{caller[0]}")

    if (fried? && lte_boost?)
      $bigshot_overkill_counter += 1
      message("yellow", "Extra Kills currently at: #{$bigshot_overkill_counter} of #{@OVERKILL}") unless @OVERKILL == 0
    end

    if (!solo? && leading?)
      @followers.add_event(:FOLLOWER_OVERKILL)
    end
  end

  def bard_renewal()
    $bard_renewal_cost ||= 0
    $bard_renewal_check ||= (Time.now - 61)
    if Stats.prof == "Bard" && (Time.now - $bard_renewal_check).to_i > 60
      song_renewal_cost = Lich::Util.quiet_command_xml("song status", /currently singing:|not singing/, /<prompt time=/)
      if song_renewal_cost.any? { |line| line =~ /Your current renewal cost is (\d+) mana./i }
        $bard_renewal_cost = $1.to_i
      end
      $bard_renewal_check = Time.now
    end

    debug_msg(@DEBUG_STATUS, "bard_renewal | $bard_renewal_cost: #{$bard_renewal_cost} | called by #{caller[0]}")
    return $bard_renewal_cost
  end

  def voln_favor()
    current_favor = 0
    favor_pattern = /Voln Favor: (([,\d]+))/

    lines = Lich::Util.quiet_command_xml("resources", /<output class="mono"\/>/).join(" ")

    if lines =~ favor_pattern
      current_favor = $1.gsub(',', '').to_i;
    end

    debug_msg(@DEBUG_STATUS, "voln_favor | current_favor: #{current_favor} | called by #{caller[0]}")
    return current_favor
  end

  def cast902()
    if Spell[902].known? && Spell[902].affordable?
      waitrt?
      change_stance(@WANDER_STANCE) unless Effects::Buffs.active?("Rapid Fire")
      cmd_spell(id: 902)
      check_902_411()
      waitcastrt?
    end
  end

  def cast411()
    if Spell[411].known? && Spell[411].affordable?
      waitrt?
      change_stance(@WANDER_STANCE) unless Effects::Buffs.active?("Rapid Fire")
      cmd_spell(id: 411, target: GameObj.right_hand)
      check_902_411()
      waitcastrt?
    end
  end

  def check_902_411()
    lines = Lich::Util.quiet_command_xml("look at ##{GameObj.right_hand.id}", /You see nothing unusual.|I could not find|The <a exist="(.*?)" noun=".*?">.*?<\/a>/).join(" ")

    $bigshot_cast902 = !lines&.match?(/gleams faintly with inner light/)
    $bigshot_cast411 = !lines&.match?(/is surrounded by a scintillating/)
  end

  def cast_signs(single_cast = false)
    debug_msg(@DEBUG_COMMANDS, "cast_signs | single_cast: #{single_cast} | called by #{caller[0]}")

    @SIGNS.each do |i|
      if i =~ /\b650\s?(\w+)?\s?(\w+)?\s?/
        cmd_assume($1.to_s, $2.to_s)
        next
      end

      if i =~ /\b(?:515|rapid|rapidfire)(?:\s?\(?(\w+)\)?)?/
        ignore = $1
        cmd_rapid(ignore)
        next
      end

      # There is a 5 mana penality if you ignore the 515 cooldown
      if Spell[597].active? && Spell[i].mana_cost.positive? && Spell[i].mana_cost + 5 > Char.mana
        next
      end

      i = i.to_i
      next if [9903, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9912, 9913, 9914, 9918].include?(i) and Spell[9012].active?
      next if i == 9918
      next if (i == 9605 && Effects::Cooldowns.active?("Surge of Strength"))
      next if (i == 320 && Effects::Cooldowns.active?("Ethereal Censer"))
      next if (i == 605 && Effects::Cooldowns.active?("Barkskin"))
      next if (i == 9625 && Effects::Cooldowns.active?("Burst of Swiftness"))
      next if (i == 1035 && Effects::Buffs.active?("Song of Tonis"))
      next if (i == 902 && !$bigshot_cast902)
      next if (i == 411 && !$bigshot_cast411)

      if i == 122420
        next unless Warcry.available?("Seanette's Shout")
        next if !(Effects::Buffs.time_left("Empowered (+20)") <= (10 / 60.to_f))
        next if Char.stamina < 25

        wait_rt

        result_regex = Regexp.union(
          /You let loose an echoing shout!/i,
          /Your fighting spirit is bolstered!|round(time)?|seconds/i,
          /round(time)?|seconds/i,
          /You must be an active member/i,
        )

        rt_regex = /(?:Roundtime:|\.\.\.wait|Wait) (\d+) [Ss]ec(?:onds?)?\.?/
        regex = Regexp.union(result_regex, rt_regex)

        result = nil
        loop {
          wait_rt
          result = dothistimeout("warcry shout", 3, regex)
          break unless result =~ rt_regex
        }
        wait_rt
      end
      if i == 9605
        next if (!CMan.known?("Surge of Strength") || Effects::Debuffs.active?("Overexerted"))

        waitrt?
        waitcastrt?
        if (Char.stamina >= 30)
          result = dothistimeout("cman surge", 1, /You feel a great deal stronger.|untapped sources of strength|still recent prior attempt|come from your muscles|ache much too badly/i)
          if (result == false)
            $bigshot_should_rest = true
            $rest_reason = "Unknown result from surge routine: #{result}"
          end
          sleep 0.5
        end
        next
      end
      if i == 9625
        next if (!CMan.known?("Burst of Swiftness") || Effects::Debuffs.active?("Overexerted"))

        waitrt?
        waitcastrt?
        if (Char.stamina >= 30)
          result = dothistimeout("cman burst", 1, /You prepare yourself to move swiftly at a moment's notice|ache much too badly/i)
          if (result == false)
            $bigshot_should_rest = true
            $rest_reason = "Unknown result from burst routine: #{result}"
          end
          sleep 0.5
        end
        next
      end

      if i == 909
        if (Spell[909].known? && Spell[909].affordable? && !Spell[909].active?)
          waitrt?

          Spell[909].force_channel
          waitcastrt?
        end
        next
      end

      if i == 902
        cast902()
        next
      end

      if i == 411
        cast411()
        next
      end

      sign = Spell[i]
      next unless sign.known?
      next if [140, 211, 215, 219, 240, 919, 1619, 1650].include?(sign.num) && Effects::Cooldowns.active?(sign.name)

      if [9805, 9806, 9816].include?(sign.num) && !sign.active? && @CHECK_FAVOR
        current_favor = voln_favor()
        symbol_cost = { 9805 => 0.1, 9806 => 0.1, 9816 => 0.5 }

        # symbol of return cost from wiki (over estimates slightly)
        favor_cost = ((2161 / 97) * Stats.level) - (5222 / 97)
        sym_cost = favor_cost * symbol_cost[sign.num]

        next if sym_cost > current_favor
      end

      # wrack?
      mana_cost = sign.mana_cost > 1 ? sign.mana_cost : 0 # Many erroneously return 1
      wrack() if !sign.affordable? and mana_cost > Char.mana and @USE_WRACKING

      if (!sign.active? && sign.affordable?)
        next if (Stats.prof == "Bard" && !(Char.mana >= (bard_renewal + sign.mana_cost)))
        loop do
          result = sign.cast
          break if (result.to_s !~ /Spell Hindrance/ || !sign.affordable? || !(Char.mana >= (bard_renewal + sign.mana_cost)) || dead?)
        end
        break if single_cast
      end
    end
  end

  def looting_inactive?
    return $looting_inactive
  end

  def set_looting_active
    $looting_inactive = false
  end

  def prepare_for_movement(move_signs = true)
    debug_msg(@DEBUG_COMBAT, "prepare_for_movement| move_signs: #{move_signs} | called by #{caller[0]}")

    reset_variables()
    change_stance(@WANDER_STANCE)

    if (leading? && !solo?)
      @followers.add_event(:PREP_REST) if move_signs
      @followers.add_event(:FOLLOW_NOW) if !move_signs
      wait_while { @followers.roundtime? }
      sleep(0.3)
    end
    cmd_bless() if @BLESS && $bigshot_bless.count > 0
    cast_signs if move_signs
  end

  def wait_rt
    sleep 0.2
    waitcastrt?
    waitrt?
    sleep 0.2
  end

  def bs_move
    room = Room.current
    next_room_options = room.wayto.keys - @HUNTING_BOUNDARIES
    next_room_options.delete_if { |room_id| (room.timeto[room_id].is_a?(StringProc)) && room.timeto[room_id].call.nil? }
    next_room = next_room_options.find_all { |r| not $wander_rooms.include?(r) }
    if next_room.empty?
      next_room = $wander_rooms.find { |r| next_room_options.include?(r) }
    else
      next_room = next_room[rand(next_room.length)]
    end
    $wander_rooms.delete(next_room)
    $wander_rooms.push(next_room)
    way = room.wayto[next_room]
    if way.is_a?(String)
      move(way, 5) # attempts to move WAY with timeout of 5 seconds
    else
      way.call
    end

    check_for_deaders_prone
    cast_signs(true)
  end

  def bs_wander(new_room: true)
    debug_msg(@DEBUG_COMBAT, "bs_wander? | called by #{caller[0]}")

    $wander_rooms ||= Array.new
    @COMMANDS_REGISTRY = {}
    prepare_for_movement()
    check_for_deaders_prone
    fleeing = true

    while true # wander, check for players
      return if should_rest?

      # Check the room for creatures but only if it's our claim
      if (bigclaim? || !new_room) && !should_flee?(true)
        new_room = true
        sort_npcs.each { |i| return i if valid_target?(i, true) }

        # wait for @WANDER_WAIT time unless we need to flee
        sleep @WANDER_WAIT unless should_flee?(true)

        # check for creatures again after waiting
        unless should_flee?(true)
          fleeing = false
          sort_npcs.each { |i| return i if valid_target?(i, false) }
        end

        if $bigshot_bandits
          # One last look for bandits
          wait_rt
          bandit_track()
          wait_rt
          sort_npcs.each { |i| return i if valid_target?(i, false) }
        end
      end

      # If still here the rest is preping to move to the next room
      cast_signs unless fleeing
      new_room = true

      if !@followers.all_present? || Lich::Gemstone::Group.broken?
        @followers.add_event(:FOLLOW_NOW) # trigger rubber band
        message("yellow", "Waiting for followers....")
        sleep(0.5) while (!@followers.all_present?)
        groupcheck
      end

      # Wait for follower to finish looting if needed
      while !@followers.looting_done
        $looting_inactive = @followers.looting_done
        sleep 0.5
      end

      # Final room loot by leader for any missed items by follower
      if @FINAL_LOOT && leading? && !solo? && bigclaim?
        loot()
        $looting_inactive = true
      end

      # make sure we're hiding if we're sneaking
      @followers.add_event(:CHECK_SNEAKY)
      while @event_stack.any? { |a| a.type == :CHECK_SNEAKY }
        sleep 0.5
        wait_while { @followers.roundtime? }
        sleep 1
      end

      if $bigshot_sneaky_hunt
        cmd_hide(1) unless hidden
        wait_rt
      end

      wait_while { @followers.roundtime? }

      escape_rooms

      if (Stats.prof == "Ranger") && !Effects::Cooldowns.active?("Tracking") && !@TRACKING_CREATURE.empty? && !fleeing
        return if ranger_track # true we skip the wander.call, false, we perform the wander.call
      end

      unless @inbounds.valid?
        @followers.add_event(:GO2_HUNTING_ROOM)
        goto(@HUNTING_ROOM_ID)

        @followers.add_event(:JOIN_LEADER)
        message("yellow", "Waiting for followers....") if !@followers.all_present?
        sleep 0.5 while (!@followers.all_present?)
      else
        bs_move
      end
      sleep(0.1)
      $bigshot_flee = false
    end
  end

  def bandit_track()
    lines = Lich::Util.quiet_command_xml("look", /<resource picture/)
    debug_msg(@DEBUG_COMBAT, "bandit_track | quiet look: #{lines}")

    # regex to capture id, noun, and name
    regex = /<a exist="(.*?)" noun="(.*?)">(.*?)<\/a>/

    # Find a bandit match from the from the room line using the bandit regex
    bandit_match = lines.flat_map { |line| line.scan(regex) }.find { |_exist, noun, _name| noun =~ @BANDIT_NOUN_REGEX }

    debug_msg(@DEBUG_COMBAT, "bandit_track | bandit_match: #{bandit_match}")

    return if bandit_match.nil?

    unless GameObj.targets.any? { |npc| npc.id == bandit_match[0] }
      GameObj.new_npc(bandit_match[0], bandit_match[1], bandit_match[2].gsub(/  /, " "))
      debug_msg(@DEBUG_COMBAT, "#{bandit_match[0]} added to GameObj.npcs.")
    end
    unless XMLData.current_target_ids.include?(bandit_match[0])
      XMLData.current_target_ids.unshift(bandit_match[0])
      debug_msg(@DEBUG_COMBAT, "#{bandit_match[0]} added to XMLData.current_target_ids.")
    end

    debug_msg(@DEBUG_COMBAT, "GameObj.targets: #{GameObj.targets}")
  end

  def ranger_track # track bounty targets on cooldown
    debug_msg(@DEBUG_COMBAT, "ranger_track | called by #{caller[0]}")

    tracking_results = Regexp.union(
      /You don't have to go far\./, # target in the room, probably hidden.
      /Your keen eye spots the beginnings of a trail and you rush to follow it/, # success
      /was here, but the trail is clearly too old to be worth following\./, # failure
      /While you carefully study the area looking for tracks, you find no trace of what you are looking for\./, # wrong area
      /You don't know how to track creatures within town\./, # town
      /You haven't yet recovered from your previous tracking exploit\./ # cooldown
    )

    result = dothistimeout("track #{@TRACKING_CREATURE}", 1, tracking_results)
    case result
    when /Your keen eye spots the beginnings of a trail and you rush to follow it/ # success, new room, so we can go ahead
      uncover() if GameObj.targets.empty? # maybe remove - probably a lot bigger update to reveal hidden targets universally
      return true # return true to return out of wander and not change rooms again
    when /^You don't have to go far\./ # success, but target is hidden in the existing room
      if bigclaim?
        uncover() if GameObj.targets.empty? # probably remove - same as above
        return true # return true so wander doesn't move us
      elsif !bigclaim?
        return false # if room is claimed, we return false and let wander move us because track kept us in the same room which had to already been claimed
      end
    end
  end

  def uncover
    debug_msg(@DEBUG_COMBAT, "uncover | called by #{caller[0]}")

    waitrt?
    return unless GameObj.targets.empty?
    if Stats.prof == "Ranger" && Spell[609].known? && Spell[609].affordable?
      waitcastrt?
      fput("incant 609 open")
    else
      fput "search"
      waitrt?
    end
    waitcastrt?
    return
  end

  def escape_rooms
    # Used to escape from Roa'ter swallowing
    unless checkroom("The Belly of the Beast").nil?
      roater_escape()
    end

    # Used to escape from Hinterwilds Ooze swallowing
    unless checkroom("Ooze, Innards").nil?
      ooze_escape()
    end

    # Used to escape a Temporal Rift due to failed 930 casting
    unless checkroom("Temporal Rift").nil?
      temporal_escape()
    end
  end

  def roater_escape()
    debug_msg(@DEBUG_COMBAT, "roater_escape | called by #{caller[0]}")

    dagger_found = false
    container_ids = []
    empty_hands
    res = Lich::Util.quiet_command_xml("inventory containers", /Your worn items are:/, /<prompt time=/)
    res.each { |l|
      container_ids = l.scan(/<a exist=\"([^\"]+)\"/).flatten if (l =~ /<a exist=\"([^\"]+)\"/)
    }
    find_all_containers_var = container_ids.collect { |id| GameObj[id] }
    find_all_containers_var.each { |i|
      if i.contents.nil?
        res = Lich::Util.quiet_command_xml("look in ##{i.id}", /In the|There is nothing|This|is closed|shut too tightly/, /<prompt time=/)
        if res.any? { |line| line =~ /is closed|shut too tightly/i } # do we want it to open containers to look for daggers?
          Lich::Util.quiet_command_xml("open ##{i.id}", /<a exist=/, /<prompt time=/)
          Lich::Util.quiet_command_xml("look in ##{i.id}", /In the|There is nothing|This/, /<prompt time=/)
        end
      end
      i.contents.each { |s|
        if s.name =~ /alfange|basilard|bodkin|cinquedea|dagger|dirk|knife|kozuka|ice pick|misericord|parazonium|pavade|poignard|pugio|scramasax|sgian achlais|spike|stiletto|tanto|sidearm-of-Onar/i
          fput "_drag ##{s.id} right"
          dagger_found = true if (checkright =~ /#{s.noun}/)
          while !checkroom("The Belly of the Beast").nil?
            waitrt?
            fput "attack wall"
          end
          fput "_drag ##{s.id} ##{i.id}"
          break
        end
      }
      break if dagger_found
    }
    fill_hands
  end

  def ooze_escape
    debug_msg(@DEBUG_COMBAT, "ooze_escape | called by #{caller[0]}")

    weapon_found = false
    container_ids = []
    weapon_nouns = Regexp.union(
      # Blunt Weapons
      /\b(?:whip|bull whip|cat o' nine tails|signal whip|single-tail whip|training whip)\b/, # whip - crush
      # /\b(?:crowbill|hakapik|skull-piercer)\b/, # crowbill - puncture/crush
      /\b(?:cudgel|aklys|baculus|club|jo stick|lisan|periperiu|shillelagh|tambara|truncheon|waihaka|war club)\b/, # cudgel - crush
      /\b(?:mace|bulawa|dhara|flanged mace|knee-breaker|massuelle|mattina|nifa otti|ox mace|pernat|quadrelle|ridgemace|studded mace)\b/, # mace - crush
      /\b(?:ball and chain|binnol|goupillon|mace and chain)\b/, # ball and chain - crush
      # /\b(?:war hammer|fang|hammerbeak|hoolurge|horseman's hammer|skull-crusher|taavish)\b/, # war hammer - puncture/crush
      /\b(?:morning star|spiked mace|holy water sprinkler|spikestar)\b/, # morning star - crush/puncture
      # Brawling Weapons
      /\b(?:cestus)\b/, # cestus - crush
      /\b(?:knuckle-duster|knuckle guard|\w+ knuckles)\b/, # knuckle-duster - crush
      /\b(?:blackjack|bludgeon|sap)\b/, # blackjack - crush
      # Two-handed Weapons
      /\b(?:runestaff|asaya|crook|crosier|pastoral staff|rune staff|scepter|staff|staff-of-Lumnis|walking stick)\b/, # runestaff - crush
      /\b(?:quaterstaff|bo stick|toyak|walking staff|warstaff|yoribo)\b/, # quarterstaff - crush
      /\b(?:war mattock|mattock|oncin|pickaxe|sabar)\b/, # war mattock - crush
      /\b(?:maul|battle hammer|footman's hammer|sledgehammer|tetsubo)\b/, # maul - crush
    )
    waitrt?
    result = dothistimeout('kill organ', 3, /causing the ooze around you to convulse violently!|but the spongey amorphous organ is impervious to this kind of attack!/)
    case result
    when /causing the ooze around you to convulse violently!/
      while !checkroom('Ooze, Innards').nil?
        waitrt?
        fput 'kill organ'
      end
      return true
    when /but the spongey amorphous organ is impervious to this kind of attack!/
      empty_hands
    else
      echo "ooze_escape error, result: #{result}"
      echo "Please report issue and you're on your own for escaping for now!"
      sleep(0.5) until checkroom('Ooze, Innards').nil?
      return true
    end

    res = Lich::Util.quiet_command_xml("inventory containers", /Your worn items are:/, /<prompt time=/)
    res.each { |l|
      container_ids = l.scan(/<a exist=\"([^\"]+)\"/).flatten if (l =~ /<a exist=\"([^\"]+)\"/)
    }
    find_all_containers_var = container_ids.collect { |id| GameObj[id] }
    find_all_containers_var.each { |i|
      if i.contents.nil?
        res = Lich::Util.quiet_command_xml("look in ##{i.id}", /In the|There is nothing|This|is closed|shut too tightly/, /<prompt time=/)
        if res.any? { |line| line =~ /is closed|shut too tightly/i } # do we want it to open containers to look for daggers?
          Lich::Util.quiet_command_xml("open ##{i.id}", /<a exist=/, /<prompt time=/)
          Lich::Util.quiet_command_xml("look in ##{i.id}", /In the|There is nothing|This/, /<prompt time=/)
        end
      end
      i.contents.each { |s|
        if s.name =~ weapon_nouns
          fput "_drag ##{s.id} right"
          weapon_found = true if (checkright =~ /#{s.noun}/)
          while !checkroom('Ooze, Innards').nil?
            waitrt?
            fput 'kill organ'
          end
          fput "_drag ##{s.id} ##{i.id}"
          break
        end
      }
      break if weapon_found
    }
    fill_hands
  end

  def temporal_escape()
    debug_msg(@DEBUG_COMBAT, "temporal_escape | called by #{caller[0]}")

    while !checkroom("Temporal Rift").nil?
      move(checkpaths.sample)
      waitrt?
    end
  end

  def bs_put(message)
    debug_msg(@DEBUG_SYSTEM, "bs_put | message: #{message} | called by #{caller[0]}")

    unless (script = Script.self) then
      respond("--- waitfor: Unable to identify calling script. | script: #{script} Script.self: #{Script.self} message: #{message}")
      return false
    end
    clear
    put(message)

    while (string = get)
      if string =~ /(?:\.\.\.wait |Wait )(?<wait_time>[0-9]+)/
        hold_up = Regexp.last_match[:wait_time].to_i
        sleep(hold_up - 1) unless hold_up.nil? || hold_up == 1
        clear
        put(message)
        next
      elsif string =~ /struggle.+stand/
        clear
        bs_put("stand")
        next
      elsif string =~ /stunned|can't do that while|cannot seem|can't seem|don't seem|Sorry, you may only type ahead/
        if dead?
          echo("You're dead...! You can't do that!")
          sleep(0.25)
          script.downstream_buffer.unshift(string)
          return false
        elsif checkstunned
          while checkstunned
            sleep(0.25)
          end
        elsif checkwebbed
          while checkwebbed
            sleep(0.25)
          end
        else
          sleep(0.25)
        end
        clear
        put(message)
        next
      else
        script.downstream_buffer.unshift(string)
        return string
      end
    end
  end

  def group_put(message)
    debug_msg(@DEBUG_SYSTEM, "group_put | message: #{message} | called by #{caller[0]}")
    bs_put(message)
  end

  def group_cmd(message)
    debug_msg(@DEBUG_SYSTEM, "group_cmd | message: #{message} | called by #{caller[0]}")
    cmd(message)
  end

  def group_do(message)
    debug_msg(@DEBUG_SYSTEM, "group_do | message: #{message} | called by #{caller[0]}")
    do_client(message)
  end

  def self.profile(vars)
    if vars[2] =~ /load/i
      if vars[3] != nil
        dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
        filename = File.join(dir, "#{vars[3]}.yaml")
        if !File.exist?("#{filename}")
          respond ""
          respond " You are trying to load a profile that does not exist."
          respond ""
          respond "***************************"
          respond " Notice- your default Bigshot profiles folder has changed to:"
          respond " #{dir}"
          respond ""
          respond " The old location is here: #{File.join($script_dir, 'bigshot_profiles')}"
          respond " You can copy this folder or appropriate profiles into the relevant character directory in your operating system"
          respond "****************************"
          respond ""
        else
          from_file = YAML.load_file(filename)
          UserVars.op = from_file
          echo "Settings loaded from profile: #{filename}."
          UserVars.op["profile_current"] = vars[3]
          UserVars.op["save_profile_name"] = ""
        end
      else
        echo "You forgot to name your profile you wish to load."
        echo "Syntax: ;bigshot profile load <NAME Here, no Spaces!>"
      end
    elsif vars[2] =~ /save/i
      if vars[3] != nil
        dir = File.join($data_dir, XMLData.game, Char.name, "bigshot_profiles")
        filename = File.join(dir, "#{vars[3]}.yaml")
        if File.exist?("#{filename}")
          echo "File already exists, if you wish to overwrite, please ;unpause bigshot."
          echo "Else ;kill bigshot and choose another filename."
          pause_script
        end
        UserVars.op["save_profile_name"] = vars[3]
        UserVars.op["profile_current"] = vars[3]
        File.write(filename, UserVars.op.to_yaml)
        echo "Settings saved to profile: #{filename}."
      else
        echo "You forgot to name your profile you wish to save."
        echo "Syntax: ;bigshot profile save <NAME Here, no Spaces!>"
      end
    end
  end
end

if Script.current.vars.any? { |var| var =~ /single|once/i }
  $bigshot_single = true
end

if (Script.current.vars[1].nil? || Script.current.vars[1] =~ /solo|bounty|quick|single|once/i)
  if Script.current.vars[1] =~ /quick/i
    $bigshot_quick = true
  end

  bs = Bigshot.new(Script.current.vars)
  bs.croak('Requires Lich V4') unless defined?(Gtk.queue) || defined?($bigshot_headless)
  bs.croak('Requires a mapped room.') if ((Room.current.id.nil? || Room.current.id == 4) && !$bigshot_quick)
  bs.lead()
elsif (Script.current.vars[1] =~ /setup/i)
  Bigshot::Setup.setup
elsif (Script.current.vars[1] =~ /debug/i)
  Bigshot.debug_update(Script.current.vars[0])
elsif (Script.current.vars[1] =~ /profile/i)
  Bigshot.profile(Script.current.vars)
elsif (Script.current.vars[1] =~ /display/i)
  echo "Version: #{$bigshot_version}"
  UserVars.op.each_pair do |k, v|
    echo "#{k}: #{v}" unless v.nil? || v.is_a?(Array) || v.to_s =~ /^\s*$/
  end
  echo "Targetable Character Setting: #{CharSettings['targetable'].map { |c| c.downcase }.sort { |a, b| a.split(" ").last <=> b.split(" ").last }}"
  echo "Untargetable Character Setting: #{CharSettings['untargetable'].map { |c| c.downcase }.sort { |a, b| a.split(" ").last <=> b.split(" ").last }}"
elsif Script.current.vars[1] =~ /list/i
  bs = Bigshot.new(Script.current.vars)

  # Find attr_accessor attributes
  attrs = bs.class.instance_methods(false).select { |m| m.to_s.end_with?('=') }
  accessors = attrs.map { |m| m.to_s.chomp('=').to_sym }.sort_by(&:to_s)

  # Print names and values
  accessors.each do |attr|
    value = bs.send(attr)
    echo "#{attr}: #{value}"
  end
elsif Script.current.vars[1] =~ /test/i
  method = Script.current.vars[2].to_sym
  args = Script.current.vars[3..]

  unless Bigshot.method_defined?(method)
    echo "#{Script.current.vars[2]} is not a valid #{Script.current.name} method"
    exit
  end

  bs = Bigshot.new(Script.current.vars)
  bs.test_method(method, *args)
elsif (Script.current.vars[1] =~ /reset/i)
  CharSettings['targetable'] = nil
  CharSettings['untargetable'] = nil
  echo "Character Settings for Targetable and Untargetable are now reset"
elsif (Script.current.vars[1] =~ /head|lead/i)
  # Make sure group is open
  Lich::Util.quiet_command_xml("group open", /Your group status/)

  # launch DRb server
  DRb.start_service(nil, Bigshot::Group.new)

  uri = DRb.uri

  Thread.new { DRb.thread.join }

  # launch DRb client
  DRb.start_service()

  bs = Bigshot.new(Script.current.vars)

  group_count = Script.current.vars[1..].find { |el| el.to_s.match?(/\A-?\d+\z/) }

  start_time = Time.now
  group_started = false
  timeout = 60
  pause_time = 10
  short_pause = 3
  current_count = 0
  respond

  loop do
    Lich::Util.quiet_command_xml("group", /You are/)
    current_count = Lich::Gemstone::Group.length
    elapsed = Time.now - start_time

    case
    when group_count && current_count == group_count.to_i
      Lich::Messaging.msg("text", "Starting group #{current_count}/#{group_count.to_i} joined.")
      break
    when group_count && current_count > group_count.to_i # More group members than expected.
      Lich::Messaging.msg("text", "A group of #{current_count} found but only #{group_count.to_i} expected. Pausing #{pause_time} seconds before moving on.")
      sleep pause_time
      break
    when current_count.positive? && group_count.nil? # if there is a group assume everyone is joined if no count passed?
      if group_started
        Lich::Messaging.msg("text", "Group started up. Pausing #{pause_time} seconds for stragglers")
        Lich::Messaging.msg("text", "You can set expected followers with: ;bigshot head <number of followers>")
        sleep pause_time
      else
        Lich::Messaging.msg("text", "A group of #{current_count} found and no expected number of followers.")
        Lich::Messaging.msg("text", "You can set expected followers with: ;bigshot head <number of followers>")
      end
      respond

      break
    when elapsed > timeout
      msg = if group_count
              "Timeout: Only #{current_count}/#{group_count.to_i} joined after #{timeout} seconds. Exiting."
            else
              "Timeout: No group established after #{timeout} seconds. Exiting."
            end

      Lich::Messaging.msg("text", msg)
      exit
    when current_count.zero? # No group yet, sleeping a bit
      Lich::Messaging.msg("text", "No group currently. Pausing #{pause_time} seconds for characters to join.")
      respond
      sleep pause_time

      # Check if a group was started
      Lich::Util.quiet_command_xml("group", /You are/)
      current_count = Lich::Gemstone::Group.length
      group_started = current_count.positive?
    when group_count && current_count < group_count.to_i # user gave a group count and not everyone is joined yet
      respond
      Lich::Messaging.msg("text", "Waiting on group members: #{current_count}/#{group_count.to_i} joined.")
      sleep short_pause
    end
  end

  # set leader
  my_group = DRbObject.new(nil, uri)
  my_group.set_leader(bs)

  until my_group.size() > current_count
    # announce/go
    respond
    Lich::Util.issue_command("whisper ooc group Bigshot members (#{my_group.size - 1}/#{current_count}) rallying at #{uri}", /<pushStream id="speech"/, silent: true, quiet: false)
    respond
    sleep short_pause
  end

  Lich::Messaging.msg("text", " Group Members:")
  my_group.get_names.sort.each { |character| Lich::Messaging.msg("text", "  #{character}") }
  respond
  Lich::Messaging.msg("text", " Leaving in...")
  3.downto(1) { |num| Lich::Messaging.msg("text", "     #{num}"); sleep 1 }
  respond

  bs.lead(my_group)
elsif (Script.current.vars[1] =~ /tail|follow|link/i)
  group = nil
  bs = nil
  uri = nil

  max_attempts = 60
  retry_interval = 0.5
  attempts = 0

  # Watch for rally
  uri_status = proc { |server|
    if server.to_s =~ /rallying at (.*)\."/
      uri = Regexp.last_match(1)
    end
    server
  }
  DownstreamHook.add('uri_status', uri_status)

  if Script.current.vars[1] =~ /link/i
    if Script.current.vars[2].nil?
      Lich::Messaging.msg("text", "Must supply target URI when using LINK option")
      exit
    else
      uri = Script.current.vars[2]
    end
  end

  while group.nil? || bs.nil? || !(group.members&.keys&.include?(Char.name))
    # Resolve URI
    loop do
      if uri
        DownstreamHook.remove('uri_status')
        break
      end

      sleep retry_interval
    end

    Lich::Util.issue_command("whisper ooc group Joining group at #{uri}", /<pushStream id="speech"/, silent: true, quiet: false)

    begin
      DRb.start_service()

      group ||= DRbObject.new(nil, uri)
      bs ||= Bigshot.new(Script.current.vars, group)

      # Add member if not already included
      member_keys = group.members&.keys
      unless member_keys&.any? { |name| name == Char.name }
        begin
          group.add_member(bs)
        rescue => e
          Lich::Messaging.msg("yellow", "Failed to add character to group: #{e.message}")
        end
      end
    rescue DRb::DRbConnError => e
      Lich::Messaging.msg("yellow", "DRb connection failed: #{e.message}")
    rescue => e
      Lich::Messaging.msg("yellow", "Unexpected error: #{e.class} - #{e.message}")
    end

    attempts += 1
    if attempts >= max_attempts
      Lich::Messaging.msg("yellow", "Maximum join attempts reached. Exiting.")
      exit
    end

    sleep retry_interval
  end

  # Participate
  bs.message("yellow", " Successfully joined group")
  bs.npc_room_check()
  leader = group.leader.name

  bs.groupcheck unless checkpcs.nil?

  while (!dead?)
    begin
      bs.stand() if !standing? && $looting_inactive && $bigshot_status != :resting
      sleep(0.1)

      # grab event
      event = bs.event_stack.size == 0 ? nil : bs.grab_event
      next if event.nil?

      # kertwang!
      if [:FOLLOW_NOW, :ATTACK].include?(event.type) && Char.name != leader
        until Lich::Gemstone::Group.members.map(&:noun).include?(leader)
          bs.go2(group.room_id) until checkpcs.include?(leader)
          result = dothistimeout("join #{leader}", 3, /You are already a member|You join|What were you referring to/)
          bs.groupcheck unless result =~ /What were you referring to/
          sleep 0.1
        end
      end

      # process event
      events_to_skip = [:FOLLOWER_OVERKILL, :PREP_REST, :DISPLAY_WATCH, :START_WATCH, :STOP_WATCH, :CHECK_MIND, :FOLLOW_NOW, :GO2_RALLY_ROOM, :GO2_HUNTING_ROOM, :CHECK_SNEAKY]
      bs.message("yellow", " Event: " + event.type.to_s) unless events_to_skip.include?(event.type)
      if (event.type == :HUNTING_PREP_COMMANDS)
        bs.stand() if !standing?
        bs.hunting_prep
      elsif (event.type == :JOIN_LEADER)
        until Lich::Gemstone::Group.members.map(&:noun).include?(leader)
          bs.go2(group.room_id) until checkpcs.include?(leader)
          result = dothistimeout("join #{leader}", 3, /You are already a member|You join|What were you referring to/)
          bs.groupcheck unless result =~ /What were you referring to/
          sleep 0.1
        end
      elsif (event.type == :LEAVE_GROUP)
        dothistimeout('leave group', 1, /You leave|But you are not in a group/)
      elsif (event.type == :CHECK_SNEAKY)
        bs.cmd_hide(1) if bs.sneaky_hunt? && !hidden
      elsif (event.type == :GO2_RALLY_ROOM)
        rally_rooms = group.rally_ids
        rally_rooms.each do |place|
          bs.go2(place) until (Room.current.id == place.to_i)
        end
      elsif (event.type == :GO2_HUNTING_ROOM)
        until (Room.current.id == group.hunting_id)
          bs.go2(group.hunting_id)
        end
      elsif (event.type == :SINGLE_STOP)
        bs.message("yellow", " Stopping: Bigshot set to single loop")
        bs.single_stop()
      elsif (event.type == :HUNT_MONITOR_START)
        bs.hunt_monitor("start")
      elsif (event.type == :HUNT_MONITOR_STOP)
        bs.hunt_monitor("stop")
      elsif (event.type == :FOLLOWER_OVERKILL)
        bs.use_lte_boost()
      elsif (event.type == :CAST_SIGNS)
        bs.cast_signs()
      elsif (event.type == :HUNTING_SCRIPTS_START)
        bs.run_scripts(bs.HUNTING_SCRIPTS, false)
      elsif (event.type == :ATTACK)
        if (event.stale?) # consider timestamp and room_id
          bs.message("yellow", " Skipping attack because it's stale")
          next
        end

        stop_attack = false
        target = nil
        while (!stop_attack)
          stop_attack = event.stale?
          while ((target = bs.find_target(target)) && !stop_attack)
            if (bs.event_stack.any? { |a| a.type == :PREP_REST })
              bs.message("yellow", " Preparing to move, skipping attack")
              stop_attack = true
              break
            end

            if (bs.event_stack.any? { |a| a.type == :LOOT }) && group.looter == Char.name
              stop_attack = true
              break
            end

            if !$bigshot_bandits && @PRIORITY && !bs.priority(target)
              target = bs.find_target(nil)
            end

            bs.attack(target)
            bs.escape_rooms

            stop_attack = bs.should_rest?
          end
          break if stop_attack

          stop_attack = bs.event_stack.any? { |a| a.type == :PREP_REST }
          sleep(0.1)
        end

        # remove extra attacks in stack
        bs.remove_event(:ATTACK)
      elsif (event.type == :CHECK_MIND)
        bs.check_mind
      elsif (event.type == :PREP_REST)
        bs.prepare_for_movement()
      elsif (event.type == :FOG_RETURN)
        bs.fog_return
      elsif (event.type == :GO2_WAYPOINTS)
        fput('unhide') if (hidden? || invisible?)
        waypoint_rooms = group.return_waypoints_ids
        waypoint_rooms.each { |place|
          bs.go2(place) until (Room.current.id == place.to_i)
        }
      elsif (event.type == :GO2_RESTING_ROOM)
        until (Room.current.id == group.resting_id)
          bs.go2(group.resting_id)
        end
      elsif (event.type == :LOOT) && group.looter == Char.name
        $looting_inactive = false
        bs.loot
        sleep 0.5
        $looting_inactive = true
      elsif (event.type == :HUNTING_SCRIPTS_STOP)
        bs.croak_scripts(bs.HUNTING_SCRIPTS)
      elsif (event.type == :RESTING_PREP_COMMANDS)
        bs.REST_PREP = false
        $bigshot_should_rest = false
        $bigshot_overkill_counter = 0
        bs.resting_prep
      elsif (event.type == :RESTING_SCRIPTS_START)
        bs.run_scripts(bs.RESTING_SCRIPTS, true)
        bs.REST_PREP = true
      elsif (event.type == :START_WATCH)
        bs.START_TIME = Time.now.to_i
      elsif (event.type == :STOP_WATCH)
        bs.STORED_TIMES.push(Time.now.to_i - bs.START_TIME)
        bs.START_TIME = 0
      elsif (event.type == :DISPLAY_WATCH)
        if (event.stale?)
          bs.message("yellow", " Skipping display_watch because it's stale")
          next
        end
        fput 'exp'
        sleep 0.2

        bs.display_watch()
        bs.message("yellow", "Bigshot last rested because: #{$rest_reason}") if $rest_reason
        bs.message("yellow", "Bigshot isn't hunting because: #{$not_hunting_reason}") if $not_hunting_reason
        _respond
      elsif (event.type == :CUSTOM_PUT)
        bs.group_put(event.cmd_input)
      elsif (event.type == :CUSTOM_CMD)
        bs.group_cmd(event.cmd_input)
      elsif (event.type == :CUSTOM_DO_CLIENT)
        bs.group_do(event.cmd_input)
      elsif (event.type == :PUBLIC_SEND)
        echo "SENT: #{bs.public_send(event.cmd_input) if bs.respond_to? event.cmd_input}"
      end
    rescue
      fput 'leave group'
      if (bs.RESTING_ROOM_ID && bs.RESTING_ROOM_ID != 4)
        start_script('go2', [bs.RESTING_ROOM_ID, '_disable_confirm_'])
        wait_while { running?('go2') }
      end
      echo "Fatal exception!"
      echo $!.to_s
      echo $!.backtrace.join("\n")
      Script.self.kill
    end
  end
end
