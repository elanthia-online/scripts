=begin

  bigshot.lic: the new optimus prime

  hunting script for hunting

        author: elanthia-online
  contributers: SpiffyJr, Tillmen, Kalros, Hazado, Tysong, Athias, Falicor
          game: Gemstone
          tags: hunting
       version: 3.93

  Setup instructions: https://gswiki.play.net/Script_Bigshot
  To help contribute: https://github.com/elanthia-online/scripts
  Full Changelog: https://gswiki.play.net/Script_Bigshot_Changelog
  
  v3.93 (2020-08-13)
    -Fix for ambush (Head/Neck), no longer get stuck ambushing a head/neck over and over
    -Group logic changes 
       Followers can now stay in the resting area and wait to run scripts/commands until leader is done
         The above change can be toggled off (not recommended)
       Followers will now wait to cast signs until hunt is about to begin
       Leader will no longer begin hunt until all followers are present and ready to go
    -Updates to UCS Mstrike, should no longer do open mstrikes when at or below threshhold instead of targetted mstrike
    -UCS mstrike threshold merged with MStrike tab threshold
    -Minor UCS logic tweaks
  v3.92 (2020-07-08)
    -Added LTE support for followers, overkill support for followers, & fried hunting commands for followers
  v3.91 (2020-06-16)
    -Added longterm boost usage option
  v3.90 (2020-05-19)
    -Minor fix to add a delay to 130/sym of return/1020 return option case in RT
  v3.89 (2020-05-18)
    -Crude fix for archery update, BLANK out your ammo & ammo container setting to NOT attempt to get ammo any longer
  v3.88 (2020-03-28)
    -Fixed a bug with obvious_hiding_player detection (Probably, at least)
    -Fixed a bug with poaching when other players are present
    -Cleaned out changelog history after updating wiki
    -Re-organized global variables and requires statements (alphabetized)
    -Added a sleep between resting_commands and hunting_prep_commands to prevent issues
    -Replaced all pause commands with sleep
    -Updated all sleep commands to follow proper syntax
  v3.87 (2020-03-19)
    -Added overkill counter for extra killed monsters
    -Tooltip updates
    -Formatting changes to make script more easily read
  v3.86 (2020-03-11)
    -Added outside & !outside command checks
  v3.85 (2020-02-28)
    -Resolved `block in setup` error when running setup in Fedora
  v3.84 (2020-02-15)
    -Fix a bug with "obvious hiding" players detection
  v3.83 (2020-02-13)
    -Added check for "obvious hiding" players (SET ObviousHiding ON)
  v3.82 (2020-02-02)
    -Added a v & !v command checks for checking spirit
    -Possible fix for FOG_RETURN not loading when doing ;bigshot setup properly
    -Added ;bigshot profile support
      ;bigshot profile load <name here, no spaces>
      ;bigshot profile save <name here, no spaces>
      Allows saving of bigshot profiles as YAML files, saved in your LICH\scripts\bigshot_profiles folder
=end
=begin  
    To do:
      Add more messaging for ambush checks (snipe, etc.)
      Add Stun Relief (108)|Undisease (113)|Unpoison (114) option for stunned group members
      Add Hand of Tonis to dismiss clouds
      Group logic for familiars/companions
      UCS will frequently use the last '$bigshot_unarmed_followup_attack', needs to be cleared
      Need support for tracking multiple NPC positioning tiers for UCS
      Celerity (506) support from grouped wizards for MStrikes
=end

# Compatability for Older Ruby Versions
if $SAFE > 0
  echo "error: This script needs to be trusted to work. (;trust #{script.name})"
  exit
end

# Still used until all aspects of GameObjAdd are moved into GameObj.xml properly
unless Script.exists?('GameObjAdd')
  do_client(";repository download GameObjAdd.lic")
  wait_while { running?('repository') }
  do_client(";autostart add --global GameObjAdd")
  wait_while { running?('autostart') }
  sleep(0.5)
  do_client(";autostart add --global repository download-updates")
  wait_while { running?('autostart') }
  sleep(0.5)
  do_client(";repository set-updatable GameObjAdd.lic")
  wait_while { running?('repository') }
  sleep(0.5)
  do_client(";GameObjAdd")
  wait_while { running?('GameObjAdd') }
  sleep(0.5)
end

# All Requirements
require 'yaml'
require 'drb'

# Alphabetized Global Variables
BIGSHOT_VERSION = '3.93'
RALLY_TIME = 1
REST_INTERVAL = 60
$bigshot_1614_list = []
$bigshot_703_list = []
$bigshot_adrenal_surge = Time.now + 301
$bigshot_aim = 0
$bigshot_ambush = 0
$bigshot_archery_aim = 0
$bigshot_archery_stuck_location = []
$bigshot_archery_location = nil
$bigshot_bless = []
$bigshot_debug = false
$bigshot_flee = false
$bigshot_lte_boost_counter = 0
$bigshot_overkill_counter = 0
$bigshot_quick = false
$bigshot_should_rest = false
$bigshot_smite_list = []
$bigshot_status = nil
$bigshot_unarmed_followup = false
$bigshot_unarmed_followup_attack = ""
$bigshot_unarmed_tier = 1
$bigshot_wand = 0
$companion ||= nil
$current_script_name = script.name
$current_room_npcs = GameObj.npcs
$familiar = ""
$grouplist=[]
$last_loot=nil
$not_hunting_reason = nil
$rest_reason = nil
$room_npcs_last_check=[]

def spam
  def waitcastrt?
    return if Spell[515].active?
    if (XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
      sleep((XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f).abs)
    end
  end

  def waitrt?
    if (XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
      sleep((XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f).abs)
    end
  end
end

def unspam
  def waitcastrt?
    if (XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
      sleep((XMLData.cast_roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f + "0.6".to_f).abs)
    end
  end

  def waitrt?
    if (XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f) > 0
      sleep((XMLData.roundtime_end.to_f - Time.now.to_f + XMLData.server_time_offset.to_f + "0.6".to_f).abs)
    end
  end
end

bigshot_monitor = proc { |server_string|
  if server_string =~ /<a exist="\d+" noun="([a-zA-Z]*?)">[a-zA-Z]*?<\/a> leaps from hiding to attack!/i
    temp = $1
    if !$grouplist.any?{|s| s =~ /#{temp}/i}
      $ambusher_here = true
    end
  elsif server_string =~ /flies out of the shadows toward/i
    if server_string =~ /flies out of the shadows toward you/i
    elsif $grouplist.size == 0
      $ambusher_here = true
    end
  elsif server_string =~ /obvious signs of someone hiding/i
    $obvious_hiding_player = true
  elsif server_string =~ /crimson mist.*?surround.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:corporeal plane!|vulnerable!)/i
    $bigshot_smite_list.push($1)
  elsif server_string =~ /crimson mist.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:returns to an ethereal state.|appears less vulnerable.)/i
    $bigshot_smite_list.delete($1)
  elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?is suddenly surrounded by a blood red haze./i
    $bigshot_703_list.push($1)
  elsif server_string =~ /The blood red haze dissipates from around.*?<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?\./i
    $bigshot_703_list.delete($1)
  elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?(?:visibly struggling against|in awe of) your radiant aura!/i
    $bigshot_1614_list.push($1)
  elsif server_string =~ /<pushBold\/>.*?<a exist="(.*?)" noun=".*?">.*?<\/a><popBold\/>.*?recovers from being rebuked/i
    $bigshot_1614_list.delete($1)
  elsif server_string =~ /The.*sticks in.*\'s (.*)\!/i
    $bigshot_archery_stuck_location.push($1)
  elsif server_string =~ /You're now aiming at the (.*) of/i
    $bigshot_archery_location = $1
  elsif server_string =~ /You're now no longer aiming at anything in particular/i
    $bigshot_archery_location = nil
  elsif server_string =~ /but your attack has no effect!/i
    $bigshot_should_rest = true
    $rest_reason = "No blessing on weapon"
  elsif server_string =~ /Your <a exist="(.*?)" noun=".*?">.*?<\/a> returns to normal\./i
    $bigshot_bless.push($1)
  elsif server_string =~ /^You bolt/i
    $ambusher_here = false
    $bigshot_smite_list = []
    $bigshot_aim = 0
    $bigshot_ambush = 0
    $bigshot_archery_aim = 0
    $bigshot_archery_stuck_location = []
    $bigshot_unarmed_tier = 1
    $bigshot_unarmed_followup = false
    $bigshot_unarmed_followup_attack = ""
    $bigshot_703_list = []
    $bigshot_1614_list = []
    $bigshot_flee = false
    $obvious_hiding_player = false
  elsif server_string =~ /#{UserVars.op["flee_message"]}/i && UserVars.op["flee_message"] != ""
    $bigshot_flee = true
  end
  server_string
}
DownstreamHook.remove("#{script.name}_monitor")
DownstreamHook.add("#{script.name}_monitor", bigshot_monitor)
before_dying { DownstreamHook.remove("#{script.name}_monitor") }

before_dying { unspam() }
before_dying { $bigshot.gather_ammo }

class Event
  attr_accessor :type, :created_at, :room_id
  @@RECOGNIZED = [ :HUNTING_PREP_COMMANDS, :HUNTING_SCRIPTS_START, :CAST_SIGNS, :ATTACK, :PREP_REST, 
                   :HUNTING_SCRIPTS_STOP, :RESTING_SCRIPTS_START, :RESTING_PREP_COMMANDS, :DISPLAY_WATCH, 
                   :FOLLOWER_OVERKILL, :STAY_QUIET, :FOLLOW_NOW ]

  def initialize( type, time_stamp, room_id )
    raise "Event type not recognized" unless @@RECOGNIZED.include?(type)
    @type       = type
    @created_at = time_stamp
    @room_id    = room_id
  end

  def stale?
    if( Room.current.id != @room_id || Time.now.to_i - @created_at > 15 )
      return true
    else
      return false
    end
  end

  def type
    return @type
  end
end

class Group
  include DRbUndumped
  attr_accessor :leader, :members

  def initialize()
    @members = Hash.new
  end

  def set_leader(leader)
    @leader = leader
  end

  def add_member(member)
    @members[member.name()] = member
  end

  def size()
    return @members.size
  end

  def get_names
    return @members.keys + [@leader.name]
  end

  def room_id()
    return @leader.room_id()
  end

  def add_event(type)
    @members.each_pair { |k,v|
      begin
        v.add_event( type, Time.now.to_i, Room.current.id )
      rescue
        @leader.message("Error adding #{type.to_s} event to members stack: #{$!}")
        @leader.message($!.backtrace.join("\n"))
      end
    }
  end

  def group_assist( should_attack )
    @members.each_pair { |k,v|
      begin
        v.set_help_group( should_attack )
      rescue
        @leader.message("Error polling member. Removing!")
        @members.delete(k)
      end
    }
  end

  def add_leader_event(event)
    @leader.add_event( Event.new(event) ) unless @leader.event_stack.size > 5
  end

  def resting_id()
    return @leader.RESTING_ROOM_ID
  end

  def roundtime?()
    @members.each_pair { |k,v|
      begin
        return true if v.rt? > 0
      rescue
        @leader.message("Error polling member for RT. Removing!")
        @members.delete(k)
      end
    }
    return false
  end

  def should_hunt?()
    emergency = @leader.event_stack.size == 0 ? nil : @leader.event_stack.shift
    if(emergency)
      @leader.clear_events
      return false
    end

    @members.each_pair { |k,v|
      begin
        return false if !v.should_hunt?
      rescue
        @leader.message("Error polling member. Removing!")
        @members.delete(k)
      end
    }
    $bigshot_status = :hunting
    return true
  end

  def should_rest?()
    @members.each_pair { |k,v|
      begin
        return false if !v.should_rest?
      rescue
        @leader.message("Error polling member. Removing!")
        @members.delete(k)
      end
    }
    return true
  end

  
  def all_present?
    @members.each_pair { |k,v|
      begin
        return false if !checkpcs.include?(k)
      rescue
        @leader.message("Error polling member. Removing!")
        @members.delete(k)
      end
    }
    return true
  end

  def emergency_rest?()
    @members.each_pair { |k,v|
      begin
        return true if v.wounded?
      rescue
        @leader.message("Error polling member. Removing!")
        @members.delete(k)
      end
    }
    return false
  end
end

class Bigshot
  include DRbUndumped
  attr_accessor :BIRTH_TIME, :START_TIME, :STORED_TIMES, :FRIED, :OOM,
    :SIGNS, :TARGETS, :INVALID_TARGETS, :FLEE_COUNT, :ALWAYS_FLEE_FROM,
    :USE_WRACKING, :AMMO, :AMMO_CONTAINER, :HIDE_FOR_AMMO,
    :REST_TILL_EXP, :REST_TILL_MANA, :USE_HERBS, :DEAD_MAN_SWITCH,
    :RESTING_ROOM_ID, :RESTING_COMMANDS, :RESTING_SCRIPTS, :HUNTING_ROOM_ID,
    :HUNTING_BOUNDARIES, :HUNTING_SCRIPTS, :HUNTING_COMMANDS,
    :DISABLE_COMMANDS, :HUNTING_STANCE, :HUNTING_PREP_COMMANDS,
    :MONITOR_INTERACTION, :FLEE_CLOUDS, :FLEE_VINES, :FLEE_WEBS, :WRACKING_SPIRIT,
    :REST_TILL_SPIRIT, :BOUNTY_MODE, :AMBUSH, :ARCHERY_AIM,
    :event_stack, :followers, :BLESS, :AIM, :TIER3, :QUIET_FOLLOWERS,
    :MSTRIKE_COOLDOWN, :MSTRIKE_STAMINA_COOLDOWN, :MSTRIKE_MOB, 
    :MSTRIKE_QUICKSTRIKE, :MSTRIKE_STAMINA_QUICKSTRIKE,
    :UAC_MSTRIKE, :WANDER_WAIT, :QUICK_COMMANDS, :PRIORITY,
    :QUICKHUNT_TARGETS, :UAC_SMITE, :FOG_RETURN, :LOOT_STANCE,
    :DELAY_LOOT, :PULL, :OVERKILL, :LTE_BOOST, :help_group_kill

  PRONE = /sleeping|webbed|stunned|kneeling|sitting|^lying|prone|frozen|held in place/

  def add_event( type, time_stamp, room_id )
    echo "add_event" if $bigshot_debug
    unless( @event_stack.size > 5 && type == :ATTACK )
      if( type == :FOLLOWER_OVERKILL )
        add_overkill()
        @event_stack.push( Event.new( type, time_stamp, room_id ) ) unless( @event_stack.any? { |a| a.type == type} )
      else  
        @event_stack.push( Event.new( type, time_stamp, room_id ) )
      end  
    end
  end

  def grab_event()
    echo "grab_event" if $bigshot_debug
    @event_stack.shift()
  end

  def clear_events()
    echo "clear_events" if $bigshot_debug
    @event_stack.clear
  end

  def initialize(bounty_mode=nil)
    echo "initialize" if $bigshot_debug
    $bigshot = self
    @help_group_kill = true
    if bounty_mode
      @BOUNTY_MODE = true
    end

    UserVars.op ||= Hash.new
    CharSettings['targetable']   ||= Array.new
    CharSettings['untargetable'] ||= Array.new
    @BIRTH_TIME   = Time.now.to_i
    @START_TIME   = 1
    @STORED_TIMES = Array.new

    @followers = nil
    @event_stack = Array.new

    load_settings()
    dead_man_switch()

    # this is mainly for azbounty:
    before_dying {
      @HUNTING_SCRIPTS.each { |i|
        echo "Cleaning up hunting scripts: #{i}."
        stop_script(i) if running?(i)
      }
    }

  end

  def load_settings()
    set_value_required( 'hunting_commands',  'split_xx' )
    set_value_required( 'fried',             'to_i'     )
    set_value_required( 'oom',               'to_i'     )
    set_value_required( 'rest_till_mana',    'to_i'     )
    set_value_required( 'rest_till_exp',     'to_i'     )

    set_value( 'hunting_room_id',              'to_i',      4          )
    set_value( 'resting_room_id',              'to_i',      4          )
    set_value( 'hunting_boundaries',           'split',     Array.new  )
    set_value( 'hunting_commands_b',           'split_xx',  Array.new  )
    set_value( 'hunting_commands_c',           'split_xx',  Array.new  )
    set_value( 'hunting_commands_d',           'split_xx',  Array.new  )
    set_value( 'hunting_commands_e',           'split_xx',  Array.new  )
    set_value( 'hunting_commands_f',           'split_xx',  Array.new  )
    set_value( 'hunting_commands_g',           'split_xx',  Array.new  )
    set_value( 'hunting_commands_h',           'split_xx',  Array.new  )
    set_value( 'hunting_commands_i',           'split_xx',  Array.new  )
    set_value( 'hunting_commands_j',           'split_xx',  Array.new  )
    set_value( 'disable_commands',             'split_xx',  Array.new  )
    set_value( 'quick_commands',               'split_xx',  Array.new  )
    set_value( 'targets',                      'targets',   nil        )
    set_value( 'quickhunt_targets',            'targets',   nil        )
    set_value( 'dead_man_switch',              '',          false      )
    set_value( 'monitor_interaction',          '',          false      )
    set_value( 'depart_switch',                '',          false      )
    set_value( 'encumbered',                   'to_i',      200        )
    set_value( 'signs',                        'split',     Array.new  )
    set_value( 'spam',                         '',          true       )
    set_value( 'flee_count',                   'to_i',      10         )
    set_value( 'wracking_spirit',              'to_i',      0          )
    set_value( 'invalid_targets',              'split',     Array.new  )
    set_value( 'always_flee_from',             'split',     Array.new  )
    set_value( 'flee_message',                 '',          nil        )
    set_value( 'flee_clouds',                  '',          false      )
    set_value( 'flee_vines',                   '',          false      )
    set_value( 'flee_webs',                    '',          false      )
    set_value( 'use_wracking',                 '',          false      )
    set_value( 'lone_targets_only',            '',          false      )
    set_value( 'rest_till_spirit',             'to_i',      0          )
    set_value( 'ammo',                         '',          nil        )
    set_value( 'ammo_container',               '',          nil        )
    set_value( 'fresh_wand_container',         '',          nil        )
    set_value( 'dead_wand_container',          '',          nil        )
    set_value( 'wand',                         'split',     nil        )
    set_value( 'wand_if_oom',                  '',          false      )
    set_value( 'hide_for_ammo',                '',          nil        )
    set_value( 'wounded_eval',                 '',          nil        )
    set_value( 'resting_scripts',              'split',     Array.new  )
    set_value( 'hunting_scripts',              'split',     Array.new  )
    set_value( 'loot_script',                  '',          nil        )
    set_value( 'hunting_stance',               '',          'defensive')
    set_value( 'resting_commands',             'split_xx',  Array.new  )
    set_value( 'hunting_prep_commands',        'split_xx',  Array.new  )
    set_value( 'mstrike_mob',                  'to_i',      2          )
    set_value( 'mstrike_cooldown',             '',          nil        )
    set_value( 'mstrike_stamina_cooldown',     'to_i',      maxstamina )
    set_value( 'mstrike_quickstrike',          '',          nil        )
    set_value( 'mstrike_stamina_quickstrike',  'to_i',      maxstamina )
    set_value( 'aim',                          'split',     Array.new  )
    set_value( 'ambush',                       'split',     Array.new  )
    set_value( 'archery_aim',                  'split',     Array.new  )
    set_value( 'tier3',                        '',          'punch'    )
    set_value( 'bless',                        '',          nil        )
    set_value( 'uac_smite',                    '',          false      )
    set_value( 'wander_wait',                  'to_f',      0.3        )
    set_value( 'priority',                     '',          false      )
    set_value( 'fog_return',                   '',          nil        )
    set_value( 'loot_stance',                  '',          false      )
    set_value( 'delay_loot',                   '',          false      )
    set_value( 'pull',                         '',          true       )
    set_value( 'overkill',                     'to_i',      0          )
    set_value( 'lte_boost',                    'to_i',      0          )
    set_value( 'quiet_followers',              '',          true       )
  end

  def clean_value( clean, value )
    if( clean == 'to_i' )
      return value.to_i
    elsif ( clean == 'to_f' )
      return value.to_f
    elsif( clean == 'split' )
      return value.split(/,\s*/)
    elsif( clean == 'split_xx' )
      cleaned = Array.new
      value.split(/,\s*/).each { |i|
        rep = 1
        cmd = ''
        if( i =~ /(.*)\(x(\d+)\)$/i )
          rep = $2.to_i
          cmd = $1
        elsif( i =~ /(.*)\(xx\)/i )
          rep = 5
          cmd = $1
        else
          cmd = i
        end
        and_tokens = cmd.split(/\sand\s/)
        cmd = and_tokens.size == 1 ? and_tokens[0] : and_tokens
        rep.times do cleaned.push(cmd) end
      }
      return cleaned
    elsif( clean == 'targets' )
      targets = Hash.new
      tokens = value.split(/,/)
      tokens.each do |i|
        if( i =~ /(.*)\(([a|b|c|d|e|f|g|h|i|j|A|B|C|D|E|F|G|H|I|J])\)/ )
          targets[$1.downcase.strip] = $2.downcase.strip
        else
          targets[i.downcase.strip] = 'a'
        end
      end
      return targets
    else
      return value
    end
  end

  def set_value( key, clean, default )
    if( !UserVars.op[key].nil? && UserVars.op[key] !~ /^\s*$/ )
      cleaned = clean_value( clean, UserVars.op[key] )
      instance_variable_set( "@#{key.upcase}", cleaned )
    else
      instance_variable_set( "@#{key.upcase}", default )
    end
  end

  def set_value_required( key, clean )
    if( !UserVars.op[key].nil? && UserVars.op[key] !~ /^\s*$/ )
      set_value( key, clean, nil )
    else
      message("ERROR: Missing required setting: #{key}")
      message("  Current Settings:")
      message("               fried:\t#{@FRIED}")
      message("                 oom:\t#{@OOM}")
      message("      rest_till_mana:\t#{@REST_TILL_MANA}")
      message("       rest_till_exp:\t#{@REST_TILL_EXP}")
      message("    hunting_commands:\t#{@HUNTING_COMMANDS}")
      Script.self.kill
    end
  end

  def cmd( command, npc = nil, stance_dance = true )
    echo "cmd" if $bigshot_debug
    GameObj.pcs.each {|s| if s.status =~ /kneeling|sitting|^lying|prone/;fput "pull #{s.noun}";end;} if GameObj.npcs.any? {|s| s.type =~ /aggressive npc/} && @PULL
    command = command.dup

    #Used to escape from Roa'ter swallowing
    if !checkroom("The Belly of the Beast").nil?
      RoaterEscape()
    end

    if( command.class.to_s == 'Array' )
      stance_dance = false if command.any? { |j| j =~ /stance/ }
      command.each do |i|
        break if npc.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == npc.id}
        echo i if $bigshot_debug
        cmd( i, npc, stance_dance )
      end
      return
    end

    # check mana/stamina/health(percentage)/encumbrance/unarmed tiering/mobs in room/target not prone/target undead
    # ! means the inverse/opposite effect
    if( command =~ /(.*)\((.*?(?:s|!s|m|!m|h|!h|e|!e|v|!v|tier|!tier|mob|!mob|prone|!prone|undead|!undead|flying|!flying|hidden|!hidden|poison|!poison|disease|!disease|noncorporeal|!noncorporeal|pcs|!pcs|outside|!outside).*?)\)$/i )
      command = $1
      commandcheckreturn = false
      $2.split(" ").each{|s|
        if s =~ /((?:s|!s|m|!m|h|!h|e|!e|v|!v|tier|!tier|mob|!mob))(\d+)/i
          if( $1 == 's' )
            commandcheckreturn = true if !checkstamina($2.to_i)
          elsif( $1 == '!s' )
            commandcheckreturn = true if checkstamina($2.to_i)
          elsif( $1 == 'm' )
            commandcheckreturn = true if !checkmana($2.to_i)
          elsif( $1 == '!m' )
            commandcheckreturn = true if checkmana($2.to_i)
          elsif( $1 == 'v' )
            commandcheckreturn = true if !checkspirit($2.to_i)
          elsif( $1 == '!v' )
            commandcheckreturn = true if checkspirit($2.to_i)
          elsif( $1 == 'h' )
            commandcheckreturn = true if !percenthealth($2.to_i)
          elsif( $1 == '!h' )
            commandcheckreturn = true if percenthealth($2.to_i)
          elsif( $1 == 'e' )
            commandcheckreturn = true if !checkencumbrance($2.to_i)
          elsif( $1 == '!e' )
            commandcheckreturn = true if checkencumbrance($2.to_i)
          elsif( $1 == 'tier' )
            commandcheckreturn = true if $bigshot_unarmed_tier < $2.to_i
          elsif( $1 == '!tier' )
            commandcheckreturn = true if $bigshot_unarmed_tier > $2.to_i
          elsif ( $1 == 'mob' )
            mobcheck = $2
            commandcheckreturn = true if GameObjNpcCheck() < mobcheck.to_i
          elsif ( $1 == '!mob' )
            mobcheck = $2
            commandcheckreturn = true if GameObjNpcCheck() > mobcheck.to_i
          end
        elsif s =~ /((?:prone|!prone|undead|!undead|flying|!flying|hidden|!hidden|poison|!poison|disease|!disease|noncorporeal|!noncorporeal|pcs|!pcs|outside|!outside))/i
          if( $1 == 'prone' )
            commandcheckreturn = true if npc.status =~ PRONE
          elsif( $1 == '!prone' )
            commandcheckreturn = true if npc.status !~ PRONE
          elsif( $1 == 'undead' )
            commandcheckreturn = true if !npc.type.split(',').any?{|a| a == "undead"}
          elsif( $1 == '!undead' )
            commandcheckreturn = true if npc.type.split(',').any?{|a| a == "undead"}
          elsif( $1 == 'flying' )
            commandcheckreturn = true if !npc.status.include?("flying")
          elsif( $1 == '!flying' )
            commandcheckreturn = true if npc.status.include?("flying")
          elsif( $1 == 'hidden' )
            commandcheckreturn = true if !hiding?
          elsif( $1 == '!hidden' )
            commandcheckreturn = true if hiding?
          elsif( $1 == 'poison' )
            commandcheckreturn = true if !checkpoison?
          elsif( $1 == '!poison' )
            commandcheckreturn = true if checkpoison?
          elsif( $1 == 'disease' )
            commandcheckreturn = true if !checkdisease?
          elsif( $1 == '!disease' )
            commandcheckreturn = true if checkdisease?
          elsif( $1 == 'noncorporeal' )
            commandcheckreturn = true if !npc.type.split(',').any?{|a| a == "noncorporeal"}
          elsif( $1 == '!noncorporeal' )
            commandcheckreturn = true if npc.type.split(',').any?{|a| a == "noncorporeal"}
          elsif( $1 == 'pcs' )
            commandcheckreturn = true if !((checkpcs - $grouplist).count > 0)
          elsif( $1 == '!pcs' )
            commandcheckreturn = true if ((checkpcs - $grouplist).count > 0)
          elsif( $1 == 'outside' )
            commandcheckreturn = true if !outside?
          elsif( $1 == '!outside' )
            commandcheckreturn = true if outside?
          end
        end
      }
      return if commandcheckreturn
    end

    if( command =~ /force\s+(.*)\s+(?:till|until)\s+(\d+)/i )
      cmd_force( $1, $2.to_i, npc )
      return
    end

    # sub id
    command.gsub!( /target/, "##{npc.id}" ) if !npc.nil?

    # Soothe routine
    if Spell[1205].known? && Spell[1205].affordable?
      if (Spell[201].active? || Spell[216].active? || Spell[1015].active? || Spell[1016].active? || Spell[1108].active? || Spell[1120].active?)
        waitrt?
        waitcastrt?
        Spell[1205].cast
      end
    end

    cmd_bless() if @BLESS && $bigshot_bless.count > 0

    # waitrt/waitcastrt
    unless( command =~ /^nudgeweapons?/ )
      waitrt?
      waitcastrt? if command =~ /^\d+|incant/
    end

    # Celerity (506) routine
    if ( command =~ /^(celerity|haste|506)\s+(.*)/i )
      command = $2
      if Spell[506].known? and Spell[506].affordable?
        if (Spell[506].active? and Spell[506].timeleft <= 0.05) || (!Spell[506].active?)
          Spell[506].cast
        end
      end
    end

    # change_stance
    stand() if !standing?
    unless( command =~ /^(?:\d+|wait|sleep|wand|berserk|script|hide|nudgeweapon)/ )
      change_stance(@HUNTING_STANCE) if stance_dance
    end

    return if (npc && !valid_target?(npc)) or npc.status =~ /dead|gone/
    return if @PRIORITY && !priority(npc)

    if( command =~ /^(incant)?\s?(\d+)\s?((?:open|closed)?\s?(?:cast|channel|evoke)?\s?(?:cast|channel|evoke)?\s?(?:open|closed)?\s?(?:air|earth|fire|lightning|water|cold)?)?.*$/i )
      cmd_spell( $1, $2.to_i, $3, npc )
    elsif( command =~ /^throw/i )
      cmd_throw( npc )
    elsif( command =~ /^k?weed/i )
      cmd_weed( command, npc )
    elsif( command =~ /^wand/i )
      cmd_wand(npc)
    elsif( command =~ /^hide/i )
      cmd_hide()
    elsif( command =~ /^mstrike/i )
      cmd_mstrike( command, npc )
    elsif( command =~ /^fire/i )
      cmd_ranged(npc)
    elsif( command =~ /^berserk/i )
      cmd_berserk()
    elsif( command =~ /^script\s+(.*?)(\s|$)(.*)/i )
      cmd_run_script( $1, $3 )
    elsif( command =~ /^sleep\s+(\d+)/i )
      cmd_sleep( $1, npc )
    elsif( command =~ /^stance\s+(.*)/i )
      change_stance($1)
    elsif( command =~ /^wait\s+(\d+)/i )
      wait_for_swing( $1.to_i, npc )
      $stop_wait = true
    elsif( command =~ /^nudgeweapons?\s*/i )
      cmd_nudge_weapons
    elsif( command =~ /^ambush\s?(.*)?/i )
      cmd_ambush( $1, npc )
    elsif( command =~ /^unarmed\s+([a-z]*).?([a-z]*)?$/i )
      unarmed( $1, npc , $2)
    elsif( command =~ /^smite/i )
      volnsmite( npc )
    else
      return if $ambusher_here
      return if $obvious_hiding_player
      echo "inside cmd: #{command}" if $bigshot_debug
      bs_put command
    end
  end

  def volnsmite(npc)
    echo "volnsmite" if $bigshot_debug
    while !$bigshot_smite_list.any?{|a| a.to_i == npc.id.to_i} && npc.status !~ /dead|gone/ && GameObj.npcs.any? {|s| s.id == npc.id} && !should_flee? && (npc.type.split(',').any?{|a| a == "undead"} || npc.type.split(',').any?{|a| a == "noncorporeal"})
      res = dothistimeout "smite ##{npc.id}", 1, /^Roundtime|^What were you referring to\?$/
      if res =~ /^What were you referring to\?$/i
        break
      end
      sleep(1)
    end
  end

  def unarmed( command , npc, manualaim)
    echo "unarmed" if $bigshot_debug

    return if npc.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == npc.id}
    $bigshot_aim = -1 if manualaim != "" && $bigshot_aim == 0
    mstrike_taken = false
    volnsmite(npc) if !$bigshot_smite_list.any?{|a| a.to_i == npc.id.to_i} && npc.type.split(',').any?{|a| a == "noncorporeal"} && $bigshot_unarmed_tier == 3 && Spell[9821].known? && @UAC_SMITE
    mstrike_spell_check() if Char.prof =~ /Paladin|Empath/i && Skills.multiopponentcombat >= 5
    if Skills.multiopponentcombat >= 5 && GameObj.npcs.all? { |i| i.noun !~ /nest/i }
      #9005 - Mstrike recovery
      #9699 - popped muscles
      if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))        
        if (checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE ) && !Spell[9699].active?
          mstrike_taken = true
          if command =~ /jab/ && $bigshot_unarmed_tier == 3 && $bigshot_unarmed_followup == false
            cmd("mstrike #{@TIER3}", npc)
          elsif $bigshot_unarmed_followup == true
            cmd("mstrike #{$bigshot_unarmed_followup_attack}", npc)
          else
            cmd("mstrike #{command}", npc)     
          end
        end        
      end
    end
    if mstrike_taken == false
      if command =~ /jab/ && $bigshot_unarmed_tier == 3 && $bigshot_unarmed_followup == false
        if manualaim != ""
          cmd("#{@TIER3} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{@TIER3} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{@TIER3} ##{npc.id}", npc)
        end
      elsif $bigshot_unarmed_followup == true
        command = $bigshot_unarmed_followup_attack
        if manualaim != ""
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{$bigshot_unarmed_followup_attack} ##{npc.id}", npc)
        end
      else
        if manualaim != ""
          cmd("#{command} ##{npc.id} #{manualaim}", npc)
        elsif !@AIM[$bigshot_aim].nil?
          cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
        else
          cmd("#{command} ##{npc.id}", npc)
        end
      end
    end
    timeNow = Time.now + 5
    while line = get
      if line =~ /You have (decent|good|excellent) positioning/
        tier = $1
        if tier =~ /decent/
          $bigshot_unarmed_tier = 1
        elsif tier =~ /good/
          $bigshot_unarmed_tier = 2
        elsif tier =~ /excellent/
          $bigshot_unarmed_tier = 3
        end
      elsif line =~ /.* = .* d100: .* = \-?(\d+)$/ && $bigshot_unarmed_followup == true
        endroll = $1
        if endroll.to_i > 100
          $bigshot_unarmed_followup = false
        end
      elsif line =~ /Strike leaves foe vulnerable to a followup (.*) attack!/
        $bigshot_unarmed_followup = true
        $bigshot_unarmed_followup_attack = $1
      elsif line =~ /You fail to find an opening for your strike\./
        $bigshot_aim += 1
      elsif line =~ /You cannot aim that high!|is already missing that!/
        $bigshot_aim += 1
        cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
      elsif line =~ /does not have/
        $bigshot_aim += 10
        cmd("#{command} ##{npc.id} #{@AIM[$bigshot_aim]}", npc)
      elsif line =~ /Roundtime:/i
        $bigshot_aim = 0
        break
      elsif line =~ /^Try standing up first\.$|[wW]ait \d+ sec.*|You currently have no valid target\.  You will need to specify one\.|^It looks like somebody already did the job for you\.$|^What were you referring to\?$|Sorry,|You can't do that while entangled in a web|You are still stunned|from here\.  Perhaps you should try throwing or shooting something at it\./
        break
      elsif line =~ /You don't seem to be able to move to do that\./
        sleep(2)
        break
      elsif line =~ /You are unable to muster the will to attack anything\.|Your rage causes you to use all of your skill in an all out attack!/
        Spell[1205].cast if Spell[1205].known? && Spell[1205].affordable?
        break
      elsif npc.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == npc.id} || should_flee? || should_rest? || timeNow < Time.now
        $bigshot_unarmed_tier = 1
        $bigshot_unarmed_followup = false
        $bigshot_unarmed_followup_attack = ""
        break
      end
    end
    mstrike_taken = false
  end

  def cmd_bless()
    echo "cmd_bless" if $bigshot_debug
    while $bigshot_bless.count > 0
      if Spell[1604].known? && Spell[1604].affordable?
        waitrt?
        waitcastrt?
        Spell[1604].cast("##{$bigshot_bless[$bigshot_bless.count-1]}")
      end
      if Spell[304].known? && Spell[304].affordable?
        waitrt?
        waitcastrt?
        Spell[304].cast("##{$bigshot_bless[$bigshot_bless.count-1]}")
        $bigshot_bless.delete($bigshot_bless[$bigshot_bless.count-1])
      elsif Spell[9802].known?
        waitrt?
        waitcastrt?
        fput "symbol bless ##{$bigshot_bless[$bigshot_bless.count-1]}"
        $bigshot_bless.delete($bigshot_bless[$bigshot_bless.count-1])
      else
        $bigshot_should_rest = true
        $rest_reason = "No blessing on weapon"
        $bigshot_bless = []
        return
      end
    end
  end

  def cmd_throw( npc )
    echo "cmd_throw" if $bigshot_debug
    unless npc.status == 'lying down'
      empty_hands
      dothistimeout "throw ##{npc.id}", 1, /^You attempt to throw a .*\!$/
      waitrt?
      fill_hands
    end
  end

  def cmd_force( force_this, goal, npc )
    echo "cmd_force" if $bigshot_debug
    start = Time.now
    loop {
      cmd( force_this, npc )
      buffer = reget(20)
      buffer.each_with_index { |line, i|
        if( line =~ /^You.*(#{checknpcs.join('|')})(\.|!)|^You feint (high|low|(to the (left|right)))/ )
            if (buffer[i + 1] && buffer[i + 1] =~ /== \+(\d+)/) || (buffer[i + 2] && buffer[i + 2] =~ /== \+(\d+)/)
              return if $1.to_i >= goal # spell/swing
        elsif (buffer[i - 1] && buffer[i - 1] =~ /^\[Roll result: (\d+)/) || (buffer[i - 2] && buffer[i - 2] =~ /^\[Roll result: (\d+)/)
          return if $1.to_i >= goal # cman
        elsif (buffer[i + 1] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/) || (buffer[i + 2] =~ /^As you focus on your magic, your vision swims with a swirling haze of crimson/)
          return
        end
        elsif( line =~ /^You do not have enough stamina to attempt this maneuver\./ )
          return
        elsif( line =~ /^Your magic fizzles ineffectually\./ )
          return
        end
      }
      if ( force_this =~ /^(\d+) / && !Spell[$1.to_i].affordable? )
        message("Force ran out of mana. Giving up."); return;
      end
      return if GameObj.npcs.size.nil? || GameObjNpcCheck() == 0
      return if should_flee?
      return if should_rest?
      return if npc.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == npc.id}
      return if ( Time.now - start ) > 30
    }
  end

  def cmd_weed( command, target )
    echo "cmd_weed" if $bigshot_debug
    return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
    return if GameObj.loot.find { |loot| loot.name =~ /vine/ }
    return unless Spell[610].known? and Spell[610].affordable?

    waitcastrt?
    change_stance('offensive') if command == 'kweed'
    Spell[610].cast("##{target.id}")
    change_stance('guarded') if command == 'kweed'
    waitcastrt?
  end

  def cmd_spell( incant = nil, id, extra, target )
    echo "cmd_spell" if $bigshot_debug
    selfcast = false
    if ( checkprep != "None" and checkprep != Spell[id].name )
      fput 'release'
    end

    return if id == 506 and Spell[506].active?
    return if id == 9605 and Spell[9606].active? # surge cooldown
    return if id == 608 and hiding?
    return if id == 703 and $bigshot_703_list.any? {|s| s == target.id}
    return if id == 1614 and $bigshot_1614_list.any? {|s| s == target.id}
    return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
    unless( Spell[id].affordable? )
      if(@WAND_IF_OOM)
        cmd_wand(target); return;
      end
      if(@USE_WRACKING)
        wrack()
      end
    end

    if ( !Spell[id].affordable? and id != 9605 and id != 506 )
      $bigshot_should_rest = true
      $rest_reason = "out of mana"
    end
    selfcast = true if id.to_s =~ /^(?:106|109|115|117|120|130|140|205|206|211|213|215|218|219|220|240|303|307|310|313|314|319|350|401|402|403|404|405|406|414|418|419|425|430|503|506|507|508|509|511|513|515|517|520|535|540|601|602|603|604|605|606|608|611|612|613|617|618|620|625|630|640|650|707|712|905|911|913|916|919|1003|1006|1007|1009|1010|1011|1012|1014|1017|1018|1019|1020|1025|1035|1040|1109|1119|1125|1130|1150|1202|1204|1208|1213|1214|1215|1216|1220|1235|1601|1603|1605|1606|1607|1608|1609|1610|1611|1612|1613|1616|1617|1618|1619|1635)$/
    waitcastrt?
    if !incant.nil?
      if XMLData.current_target_id != target.id && selfcast == false
        fput "target ##{target.id}"
      end
      change_stance('offensive') if Spell[id].stance || (id.to_s =~ /1700/i && extra =~ /evoke/i)
      bs_put "incant #{id} #{extra}"
      change_stance(@HUNTING_STANCE)
    else
      if selfcast == false
        Spell[id].cast("##{target.id}")
      else
        Spell[id].cast(Char.name)
      end
    end
  end

  def cmd_wand(target)
    echo "cmd_wand" if $bigshot_debug
    if(@FRESH_WAND_CONTAINER)
      hands = GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s
      until( (GameObj.right_hand.name.to_s + GameObj.left_hand.name.to_s) =~ /#{@WAND[$bigshot_wand].split(' ').join('.*?')}/i)
        result = dothistimeout( "get #{@WAND[$bigshot_wand]} from my #{@FRESH_WAND_CONTAINER}", 3, /You remove|You slip|Get what/ )
        if( result =~ /Get what/ )
          $bigshot_wand += 1
          if @WAND[$bigshot_wand].nil?
            message("ERROR: Couldn't find fresh wand. Gonna rest."); $bigshot_should_rest = true; return;
          end
        elsif(result.nil?)
          message("ERROR: Timed out looking for wand."); return;
        end
      end

      change_stance('offensive')
      result = dothistimeout( "wave my #{@WAND[$bigshot_wand]} at ##{target.id}", 2, /d100|You hurl|is already dead|You do not see that here|You are in no condition|I could not find|Wait/ )
      change_stance(@HUNTING_STANCE)

      if( result =~ /You are in no condition/ )
        message("ERROR: Wounded. Gonna rest."); $bigshot_should_rest = true; return;
      elsif(result.nil?)
        if(@DEAD_WAND_CONTAINER)
          bs_put "put my #{@WAND[$bigshot_wand]} in my #{@DEAD_WAND_CONTAINER}"
        else
          bs_put "drop my #{@WAND[$bigshot_wand]}"
        end
      end
    else
      message("ERROR: Wand command called but fresh wand container not defined.")
    end
  end

  def cmd_hide()
    echo "cmd_hide" if $bigshot_debug
    tries = 0
    until(hiding?)
      break if tries > 3 || should_flee?
      change_stance('defensive')
      bs_put 'hide'; tries += 1;
    end
  end

  def mstrike_spell_check()
    echo "mstrike_spell_check" if $bigshot_debug
    #Rejuvenation
    if (Spell[1607].known? && !Spell[1607].active? && Spell[1607].affordable? && (checkstamina < (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
      if ((checkstamina + (15+(bonus=0;[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190].each { |n| bonus += 1 if Skills.slblessings >= n }; bonus*3))) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE))
        waitcastrt?
        Spell[1607].cast
      end
    end
    #Adrenal Surge
    if (Spell[1107].known? && Spell[1107].affordable? && !Spell[9010].active? && (Time.now >= $bigshot_adrenal_surge))
      if (Spell[9699].active? || ((maxstamina if Skills.slblessings >= 65 ) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      elsif (Spell[9699].active? || ((checkstamina + (Skills.slblessings >= 35 ? 50 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      elsif (Spell[9699].active? || ((checkstamina + (Skills.slblessings >= 35 ? 25 : 0)) >= (@MSTRIKE_STAMINA_COOLDOWN || @MSTRIKE_STAMINA_QUICKSTRIKE)))
        waitcastrt?
        spell[1107].cast
        $bigshot_adrenal_surge = Time.now + 301
      end
    end
  end


  def cmd_mstrike( command, target )
    echo "cmd_mstrike" if $bigshot_debug
    mstrike_spell_check() if Char.prof =~ /Paladin|Empath/i
    #Mstrike checks
    if Skills.multiopponentcombat >= 30 && GameObj.npcs.all? { |i| i.noun !~ /nest/i }
      if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
        if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Spell[9699].active?
          if( GameObjNpcCheck() >= @MSTRIKE_MOB || target.nil? )
            bs_put "quickstrike 1 #{command}"
          else
            bs_put "quickstrike 1 #{command} ##{target.id}"
          end
        else
          if( GameObjNpcCheck() >= @MSTRIKE_MOB || target.nil? )
            bs_put "#{command}"
          else
            bs_put "#{command} ##{target.id}"
          end
        end
      end
    elsif Skills.multiopponentcombat >= 5 && GameObj.npcs.all?{ |i| i.noun !~ /nest/i }
      if (!Spell[9005].active? || (@MSTRIKE_COOLDOWN && checkstamina >= @MSTRIKE_STAMINA_COOLDOWN))
        if @MSTRIKE_QUICKSTRIKE && checkstamina >= @MSTRIKE_STAMINA_QUICKSTRIKE && !Spell[9699].active?
          bs_put "quickstrike 1 #{command}"
        else
          bs_put "#{command}"
        end
      end
    end
  end

  def cmd_ranged(npc)
    echo "cmd_ranged" if $bigshot_debug
    if !@ARCHERY_AIM[$bigshot_archery_aim].nil?
      if $bigshot_archery_stuck_location.any? { |s| s =~ /#{$bigshot_archery_location}/i }
        $bigshot_archery_aim += 1
        if $bigshot_archery_aim > @ARCHERY_AIM.length
          $bigshot_archery_aim = 0
          $bigshot_archery_stuck_location = []
        end
      end
      if @ARCHERY_AIM[$bigshot_archery_aim] !~ /#{$bigshot_archery_location.to_s}/i || $bigshot_archery_location.nil?
        fput "aim #{@ARCHERY_AIM[$bigshot_archery_aim]}"
      end
    end

    waitrt?
    waitcastrt?

    if @AMMO
      result = dothistimeout "get 1 my #{@AMMO.sub(/s$/, '')}", 2, /You remove|Get what\?|You already/
      if( result =~ /Get what\?/ )
        $bigshot_should_rest = true
        $rest_reason = "Out of ammo"
        return
      end
    end

    result = dothistimeout("fire ##{npc.id}", 2, /You fire|You cannot|Could not find|seconds|Get what?/)
    if( result =~ /^Could not find/ )
      gather_ammo()
    elsif( result =~ /You cannot fire/ )
      unless GameObj.right_hand.id.nil?
        line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
      end
    elsif( result =~ /but it has no effect/ )
      $bigshot_should_rest = true
      $rest_reason = "Ammo had no effect (need blessed or magical)"
    elsif ( result == false )
      $bigshot_should_rest = true
      $rest_reason = "Unknown result from fire routine: #{result}"
    end
  end

  def cmd_berserk()
    echo "cmd_berserk" if $bigshot_debug
    if( checkstamina(20) )
      change_stance('defensive')
      Spell[9607].cast
      pause 5
      wait_until { !Spell[9607].active? }
    else
      bs_put 'target random'; bs_put 'kill';
    end
  end

  def cmd_run_script( name, args )
    echo "cmd_run_script" if $bigshot_debug
    if( args == nil || args =~ /^\s*$/ )
      run_script( name, true )
    else
      args = args.split(/ /)
      run_script( name, true, args )
    end
  end

  def cmd_sleep( time, npc )
    echo "cmd_sleep" if $bigshot_debug
    change_stance('defensive')
    time.to_i.times do
      sleep(1)
      break if should_rest?
      break if npc && npc.status =~ /dead|gone/
    end
  end

  def checkTargetVitals(command, target)
    #General logic for this taken from ;fire by Oweodry
    fput "look ##{target.id}"
	  woundinfo = matchtimeout(1, /(he|she|it) has .*/i)
    if ( command[$bigshot_ambush] == "head" && woundinfo =~ /severe head trauma and bleeding from .* ears/ )
      $bigshot_ambush += 1
    elsif ( command[$bigshot_ambush] == "neck" && woundinfo =~ /snapped bones and serious bleeding from .* neck/ )
      $bigshot_ambush += 1
    end
  end

  def cmd_ambush(command, target)
    echo "cmd_ambush" if $bigshot_debug
    return if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
    command = ["head", "right leg", "left leg", "chest"] if (command == "" || command.nil?) && @AMBUSH == []
    command = @AMBUSH if (command == "" || command == [] || command.nil?) && @AMBUSH != []
    command = [command] if command.class == String
    if ( $bigshot_ambush >=  command.length() )
      #If you have gotten here, there is nothing left to target on your list.
      $bigshot_ambush = 0 
      command = ["chest"]
    end
    if ( command[$bigshot_ambush] == "head" || command[$bigshot_ambush] == "neck" )
      checkTargetVitals(command, target)
    end  
    waitrt?
    result = dothistimeout "ambush ##{target.id} #{command[$bigshot_ambush]}", 2, /round(time)?|You cannot aim that high!|is already missing that!|does not have a .* leg!|does not have a .* arm!/i
    if result =~ /You cannot aim that high!|is already missing that!|does not have a .* leg!|does not have a .* arm!/i
      $bigshot_ambush += 1
      cmd_ambush(nil, target)
    elsif result =~ /round(time)?/i
      $bigshot_ambush = 0
    end
  end

  def cmd_nudge_weapons()
    echo "cmd_nudge_weapons" if $bigshot_debug
    return if checkpaths.size == 0

    GameObj.loot.each { |i|
      next unless i.noun =~ /axe|scythe|pitchfork|falchion|sword|lance|sword|dagger|estoc|falchion|handaxe|katana|katar|gauche|rapier|scimitar|whip-blade|cudgel|crowbill|whip|mace|star|hammer|claidhmore|flail|flamberge|maul|pick|staff|mattock/
      change_stance('defensive')

      sheathed = false
      unless( righthand.nil? || lefthand.nil? )
        sheathed = true
        fput 'sheath'
        unless( righthand.nil? || lefthand.nil? )
          message("Unable to empty hands via sheath.")
          return
        end
      end

      dirs = checkpaths
      dir  = checkpaths.shift
      fput "get ##{i.id}"
      put dir
      put "drop ##{i.id}"
      fput reverse_direction(dir)
      fput "gird" if sheathed
    }
  end

  def message(text)
    string = ''
    if $fake_stormfront then string.concat("\034GSL\r\n ") else string.concat("<pushBold\/>") end
    if( text.index('\n') )
      text.split('\n').each { |line| string.concat("| #{line}") }
    else
      string.concat('| ' + text)
    end
    if $fake_stormfront then string.concat("\034GSM\r\n ") else string.concat("<popBold\/>") end
    _respond string
  end

  def dead_man_switch()
    echo "dead_man_switch" if $bigshot_debug
    if @DEAD_MAN_SWITCH
      Thread.new {
        while( running?($current_script_name) )
          if( dead? ||  percenthealth < 40 )
            echo 'AUTOBOT ALERT: Your character is in trouble!'
            fput 'quit'
          end
          sleep(2)
        end
      };
    elsif @DEPART_SWITCH
      start_exec_script( <<-EOF
                while( running?($current_script_name) );
                    if(dead?);
                        stop_script($current_script_name);
                        fput 'depart'; fput 'depart';
                        fput 'depart confirm'; fput 'depart confirm';
                        start_script('waggle');
                        15.times { sleep(60); fput info; };
                        sleep(1) until percentspirit == 100 && !running?('waggle');
                        start_script( "#{$current_script_name}", ['solo'] );
                        Script.self.kill;
                    end;
                    sleep(5);
                end;
                        EOF
                       );
    else
      Thread.new {
        loop { Script.self.kill if dead?; sleep(5); }
      }
    end
  end

  def keep_awake()
    echo "keep_awake" if $bigshot_debug
    Thread.new {
      while( running?($current_script_name) )
        sleep(150); put 'look';
      end
    }
  end

  def monitor_interaction()
    echo "monitor_interaction" if $bigshot_debug
    if @MONITOR_INTERACTION
      start_exec_script( <<-eos
                def show_window(line);
                    window_title = Char.name + ':' + line;
                    Gtk.queue {
                        $myWindow = Gtk::Window.new;
                        $myWindow.title = "Autobot Alert!";
                        $myWindow.set_size_request(450, 25);
                        label = Gtk::Label.new window_title;
                        $myWindow.add(label);
                        $myWindow.show_all;
                    };
                end;
                while(line = get);
                    break unless running?($current_script_name);
                    if(line =~ /SEND|POLICY|[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]|peaking to you|unresponsive|taps you|nods to you|lease respond|not in control|character|violation|lease speak|peak out loud|Y U SHOU D|whispers,|speaking to you|smiles at you|waves to you|grins at you|hugs you|takes hold your hand|grabs your hand|clasps your hand|trying to drag you/);
                        unless(line =~ /LNet/);
                            show_window(line);
                            echo "AUTOBOT ALERT: " + line;
                        end;
                    end;
                end;
                        eos
                       )
    end
  end

  def GameObjNpcCheck()
    npcs = GameObj.npcs.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
    return npcs.size.to_i
  end

  def NPCRoomCheck()
    Thread.new{
      loop{
        $current_room_npcs = GameObj.npcs
        pause 0.5
      }
    }
  end

  def wrack()
    echo "wrack" if $bigshot_debug
    if Spell[9918].known? and not Spell[9012].active?
      Spell[9918].cast if checkspirit >= @WRACKING_SPIRIT
    elsif Spell[9718].known?
      ( checkstamina / 50 ).times { Spell[9718].cast }
    elsif Spell[9813].known? && !Spell[9048].active?
      Spell[9813].cast
    end
  end

  def change_stance( new_stance, force = true )
    return if Spell[1617].active? || Spell[216].active? || dead?

    if( stance() =~ /#{new_stance}/ )
      return
    elsif( checkcastrt() > 0 && new_stance =~ /def/ )
      return if stance() == 'guarded'
    end

    if(force)
      result = dothistimeout( "stance #{new_stance}", 3, /You are now in an?|Cast Round Time in effect|You are unable to change/ )
    else
      fput "stance #{new_stance}"
    end
  end

  def wait_for_swing( seconds, target = nil )
    echo "wait_for_swing" if $bigshot_debug
    start = Time.now
    swung = false
    $stop_wait = false
    $global_target = target.id
    $pcs = checkpcs ? ' you(\.|!|r? )|' + checkpcs.join('|') : 'you(\.|!|r? )'

    wait_for_swing_exec = <<-eos
        status_tags
        while line = get
            $stop_wait = true if line =~ /#{$global_target}.*#{$pcs}/ and line !~ /style id="".*style id="roomDesc"|(?:component|compDef) id='room objs'/
            break if $stop_wait
            break if !running?($current_script_name)
        end
        status_tags
    eos

    ExecScript.start(wait_for_swing_exec, :quiet => true)

    while(1)
      change_stance( 'defensive', false ) unless target && target.status =~ PRONE
      stand() if !standing?
      break if $stop_wait.call
      break if GameObj.npcs.size.nil? || GameObjNpcCheck() == 0
      break if should_flee?
      break if target && target.status =~ PRONE
      break if ( Time.now - start ) > seconds
      sleep(0.25)
    end
  end

  def croak(message)
    echo "croak" if $bigshot_debug
    message(message);
    croak_scripts( ["#{$current_script_name}"] )
  end

  def run_script( name, pause_bigshot = false, args = [] )
    echo "run_script" if $bigshot_debug
    if Script.running.find { |s| s.name.downcase == name.downcase }.paused or running? name
      stop_script name
      wait_while { running? name }
    end

    start_script name, args
    if pause_bigshot
      wait_until { !running? name }
    end
  end

  def run_scripts( scripts, pause_bigshot = false )
    echo "run_scripts" if $bigshot_debug
    scripts.each do |i|
      tokens = i.split(/\s+/)
      if( tokens.size > 1 )
        run_script( tokens[0], pause_bigshot, tokens[1..-1] )
      else
        run_script( tokens[0], pause_bigshot )
      end
    end
  end

  def croak_script(name)
    echo "croak_script" if $bigshot_debug
    kill_script(name) if running?(name)
  end

  def croak_scripts(scripts)
    echo "croak_scripts" if $bigshot_debug
    scripts.each { |i| croak_script(i) }
  end

  def stand()
    echo "stand" if $bigshot_debug
    until(standing?)
      change_stance('defensive')
      bs_put 'stand'
    end
  end

  def groupcheck()
    echo "groupcheck" if $bigshot_debug
    def checkgroupline(line)
      line =~ /exist="\-[0-9]+" noun=".*">(.*)<\/a> is (?:following you|the leader of your group|also a member of your group)/i
      if !$1.nil? then $grouplist.push($1); end
    end

    action = proc { |server_string|
      if checkgroupline(server_string) or server_string =~ /group status is currently|to set your group status|^.$|You are not currently in a group/m then nil
      else server_string
      end
    }
    DownstreamHook.add('grouphook',action)
    $_SERVER_.puts "group"
    waitfor "group status is currently", "to set your group status", "You are not currently in a group"
    pause 0.5
    DownstreamHook.remove('grouphook')
    echo $grouplist if $bigshot_debug
  end

  def lead( my_group = nil )
    echo "lead" if $bigshot_debug
    monitor_interaction()
    CompanionCheck()
    NPCRoomCheck()
    @followers = my_group || Group.new()
    if !checkpcs.nil?
      groupcheck()
    end

    if(should_rest? && !$bigshot_quick)
      rest()
    else
      hunt()
    end
  end

  def find_routine(target)
    echo "find_routine" if $bigshot_debug
    echo "@DISABLE_COMMANDS.size = #{@DISABLE_COMMANDS.size}" if $bigshot_debug
    if( !solo? && fried? && @DISABLE_COMMANDS.size > 0 )
      return @DISABLE_COMMANDS
    else
      key = @TARGETS.keys.find { |k| target.name =~ /^#{k}$/i or target.noun =~ /^#{k}$/i }
      if key.nil?
        routine_letter = 'a'
      else
        routine_letter = @TARGETS[key]
      end

      if routine_letter == 'quick'
        return @QUICK_COMMANDS unless @QUICK_COMMANDS.size == 0
      elsif routine_letter == 'j'
        return @HUNTING_COMMANDS_J unless @HUNTING_COMMANDS_J.size == 0
      elsif routine_letter == 'i'
        return @HUNTING_COMMANDS_I unless @HUNTING_COMMANDS_I.size == 0
      elsif routine_letter == 'h'
        return @HUNTING_COMMANDS_H unless @HUNTING_COMMANDS_H.size == 0
      elsif routine_letter == 'g'
        return @HUNTING_COMMANDS_G unless @HUNTING_COMMANDS_G.size == 0
      elsif routine_letter == 'f'
        return @HUNTING_COMMANDS_F unless @HUNTING_COMMANDS_F.size == 0
      elsif routine_letter == 'e'
        return @HUNTING_COMMANDS_E unless @HUNTING_COMMANDS_E.size == 0
      elsif routine_letter == 'd'
        return @HUNTING_COMMANDS_D unless @HUNTING_COMMANDS_D.size == 0
      elsif routine_letter == 'c'
        return @HUNTING_COMMANDS_C unless @HUNTING_COMMANDS_C.size == 0
      elsif routine_letter == 'b'
        return @HUNTING_COMMANDS_B unless @HUNTING_COMMANDS_B.size == 0
      end

      return @HUNTING_COMMANDS
    end
  end

  def solo?
    # tails wont have followers
    if( @followers && @followers.size == 0 )
      return true
    else
      return false
    end
  end

  def leading?
    return !following?
  end

  def following?
    return @followers.nil?
  end

  def no_players()
    if ((checkpcs - $grouplist).count > 0)
      return false
      echo "no_players: checkpcs present" if $bigshot_debug
    elsif GameObj.loot.find { |obj| obj.noun == 'disk' and obj.name !~ /#{Char.name}/}
      return false
      echo "no_players: GameObj disk present" if $bigshot_debug
    elsif $ambusher_here
      return false
    echo "no_players: Ambusher here" if $bigshot_debug
    elsif $obvious_hiding_player
      return false
      echo "no_players: Obvious Hiding Player here" if $bigshot_debug
    else
      return true
    end
  end

  def no_players_hunt()
    echo "no_players_hunt" if $bigshot_debug
    return false if $ambusher_here
    return false if $obvious_hiding_player
    return true
  end

  def pre_hunt()
    echo "pre_hunt" if $bigshot_debug
    if (!solo? && leading?)
      @followers.group_assist( true )
    end  
    # prep/go
    @followers.add_event(:HUNTING_PREP_COMMANDS)
    @HUNTING_PREP_COMMANDS.each { |i|
      if i =~ /^script\s+(.*?)(\s|$)(.*)/i
        cmd_run_script( $1, $3 )
      else
        fput(i)
        sleep(0.3)
      end
    }

    @followers.add_event(:CAST_SIGNS)
    cast_signs()

    @followers.add_event(:HUNTING_SCRIPTS_START)
    run_scripts( @HUNTING_SCRIPTS, false )

    if !$bigshot_quick
      goto(@HUNTING_ROOM_ID)
    end
    if( !solo? && leading? && !@followers.all_present? )
      @followers.add_event(:FOLLOW_NOW) # trigger rubber band
      while (!@followers.all_present?)
        message("Waiting for followers....")
        sleep(REST_INTERVAL/5)
      end
      GameObj.pcs.each {|s| if s.status =~ /kneeling|sitting|^lying|prone/;fput "pull #{s.noun}";end;} if GameObj.npcs.any? {|s| s.type =~ /aggressive npc/} && @PULL
      @followers.add_event(:CAST_SIGNS)
      prepare_for_movement()
    end
  end

  def do_hunt()
    echo "do_hunt" if $bigshot_debug
    spam() if UserVars.op['spam']

    start_watch()
    message('Bigshot hunting')

    # loop
    target = nil
    just_arrived = true
    last_attack = 0
    reset_variables()

    while true
      while( (target = find_target(target, just_arrived)) && !should_rest? && no_players_hunt == true && !$bigshot_flee)
        echo "inside do_hunt loop" if $bigshot_debug
        echo target if $bigshot_debug
        target = find_target(nil) if @PRIORITY && !priority(target)
        echo "Priority target switch to #{target}" if $bigshot_debug && @PRIORITY
        if( (Time.now.to_i - last_attack > 15) || just_arrived )
          @followers.add_event(:ATTACK)
          last_attack = Time.now.to_i
        end
        attack(target)
        just_arrived = false
        loot() if $ambusher_here == false
      end

      echo "Exiting attack loop" if $bigshot_debug
      gather_ammo()

      if(should_rest?)
        prepare_for_movement()
        break
      else
        prepare_for_movement()
        target = bs_wander()
        just_arrived = true
      end
    end

    unspam()
  end

  # this is a leader method
  def hunt()
    echo "hunt" if $bigshot_debug
    pre_hunt()
    do_hunt()
    rest()
  end

  # this is a leader method
  def rest()
    echo "rest" if $bigshot_debug
    message("Bigshot resting: #{$rest_reason}")
    $bigshot_should_rest = nil
    if @BOUNTY_MODE # bounty script should take over from here
      echo "Bounty mode. Killing self. Reason: #{$rest_reason}"
      exit
    end

    stop_watch()

    # prep/go
    prepare_for_movement()
    if (@FOG_RETURN.to_i != 0)
      sleep(0.5)
      waitcastrt?
      waitrt?
      if @FOG_RETURN.to_i == 1
        if Spell[130].known? && Spell[130].affordable?
          Spell[130].cast()
        elsif Spell[9825].known?
          sleep(0.5)
          waitcastrt?
          waitrt?
          fput "symbol of return"
        end
      elsif @FOG_RETURN.to_i == 2
        if Spell[9825].known?
          temproom = Room.current.id
          sleep(0.5)
          waitcastrt?
          waitrt?
          fput "symbol of return"
          sleep(0.5)
          if (Room.current.id == temproom && Spell[130].known? && Spell[130].affordable?)
            Spell[130].cast()
          end
        end
      elsif @FOG_RETURN.to_i == 3
        if Spell[1020].known? && Spell[1020].affordable?
          Spell[1020].cast()
        end
      end
    end
    
    # resetting overkill counter
    $bigshot_overkill_counter = 0

    # resetting lte_boost counter
    $bigshot_lte_boost_counter = 0

    @followers.add_event(:HUNTING_SCRIPTS_STOP)
    croak_scripts(@HUNTING_SCRIPTS)

    goto(@RESTING_ROOM_ID)
    if ( @QUIET_FOLLOWERS )
      @followers.add_event(:STAY_QUIET)
    else
      @followers.add_event(:FOLLOW_NOW)
    end
    while (!@followers.all_present?) 
      message("Waiting for followers....")
      sleep(REST_INTERVAL/5)
    end
    #Stops followers from doing things like using waggle while the leader is selling loot.
      

    @followers.add_event(:RESTING_PREP_COMMANDS)
    @RESTING_COMMANDS.each { |i| 
      fput(i)
      sleep(0.3)
    }

    @followers.add_event(:RESTING_SCRIPTS_START)
    run_scripts( @RESTING_SCRIPTS, true )

    if($rest_reason =~ /No blessing on weapon|Ammo had no effect \(need blessed or magical\)/i)
      echo "Need a blessing on weapon to continue hunting"
      Script.self.kill
    end

    if (!solo? && leading?)
      @followers.group_assist( true )
    end  
    # loop
    until(should_hunt?)
      @followers.add_event(:DISPLAY_WATCH)
      fput 'exp'
      display_watch_current()
      display_watch_average()
      display_watch_total()
      message( "Bigshot last rested because: #{$rest_reason}" ) if $rest_reason
      message( "Bigshot isn't hunting because: #{$not_hunting_reason}" ) if $not_hunting_reason
      sleep(REST_INTERVAL)
    end

    hunt()
  end

  def attack(target)
    echo "attack" if $bigshot_debug
    commands = find_routine(target)
    echo "Inside attack(target) #{commands}" if $bigshot_debug

    commands.each do |i|
      break unless valid_target?(target)
      break if wounded? || $bigshot_should_rest
      break if $ambusher_here
      break if $obvious_hiding_player
      break if target.status =~ /dead|gone/ || !GameObj.npcs.any? {|s| s.id == target.id}
      break if should_flee?
      break if should_rest?
      break if @PRIORITY && !priority(target)
      stand() if !standing?
      cast_signs()

      cmd( i, target )
    end
    echo  "commands.size = #{commands.size}" if $bigshot_debug
    #sleep 1 if commands.size == 0
  end

  def goto(id)
    echo "goto" if $bigshot_debug
    prepare_for_movement()
    until( Room.current.id == id )
      run_script( 'go2', true, [ id, '_disable_confirm_' ] )
    end
  end

  def start_watch()
    echo "start_watch" if $bigshot_debug
    @START_TIME = Time.now.to_i
  end

  def stop_watch()
    echo "stop_watch" if $bigshot_debug
    if( @START_TIME > 100 )
      @STORED_TIMES.push( Time.now.to_i - @START_TIME )
    end
    @START_TIME = 0
  end

  def display_watch_current()
    echo "display_watch_current" if $bigshot_debug
    if( @STORED_TIMES.size > 0 )
      seconds = @STORED_TIMES[-1]
      message( sprintf( "Bigshot: Last Hunt: %d min. %0.2f secs.",
                       seconds / 60, seconds % 60 ) )
    end
  end

  def display_watch_average()
    echo "display_watch_average" if $bigshot_debug
    average = 0
    if( @STORED_TIMES.size == 1 )
      average = @STORED_TIMES[0]
    elsif( @STORED_TIMES.size > 1 )
      @STORED_TIMES.each { |i| average += i }
      average /= @STORED_TIMES.size
    else
      return
    end
    message( sprintf( "Bigshot: Average Hunt: %d min. %0.2f secs.",
                     average / 60, average % 60 ) )
  end

  def display_watch_total()
    echo "display_watch_total" if $bigshot_debug
    total = Time.now.to_i - @BIRTH_TIME
    message( sprintf( "Bigshot: Total Time Running: %d min.  %0.2f secs.",
                     total / 60, total % 60 ) )
  end

  def room_id()
    echo "room_id" if $bigshot_debug
    return Room.current.id()
  end

  def name()
    return Char.name
  end

  def poaching?()
    echo "poaching?" if $bigshot_debug
    if($bigshot_quick && $grouplist.size > 0)
      return false
    elsif(leading?)
      (checkpcs - $grouplist).each { |i| return true unless @followers.get_names.include?(i) }
      if solo? && !$bigshot_quick
        GameObj.npcs.each { |i| return true if i.type =~ /companion/ && i.name !~ /#{$companion}/i } 
        GameObj.npcs.each { |i| return true if i.type =~ /familiar/ && i.name !~ /#{$familiar}/i }
      end
      return false
    else
      return false
    end
  end

  def should_flee?( just_entered = false )
    return false if $bigshot_quick
    return true if $bigshot_flee
    GameObj.loot.each { |i| return true if i.noun =~ /cloud|breath/ } if @FLEE_CLOUDS
    GameObj.loot.each { |i| return true if i.name == 'intense shimmering circle' } if @FLEE_CLOUDS
    GameObj.loot.each { |i| return true if i.noun =~ /vine/ } if @FLEE_VINES
    GameObj.loot.each { |i| return true if i.noun =~ /web/ } if @FLEE_WEBS
    return true if GameObj.npcs.any?  { |i| @ALWAYS_FLEE_FROM.include?(i.noun) or @ALWAYS_FLEE_FROM.include?(i.name) }
    return true if checkpcs.any?      { |i| @ALWAYS_FLEE_FROM.include?(i) }
    return true if !leading? && checkpcs.empty?

    npcs = GameObj.npcs.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| (@INVALID_TARGETS.include?(npc.name) or @INVALID_TARGETS.include?(npc.noun)) }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
    npcs.delete_if { |npc| npc.noun =~ /^(?:arm|arms|grik|grik'trak|grik'mlar|grik'pwal|grik'tval|verlok|verlok'asha|verlok'cina|verlok'ar|imp|abyran|abyran'a|abyran'sa|grantris|igaesha|haze|rouk|brume|haar|murk|nyle|mist|smoke|vapor|fog|aishan|shien|darkling|shadowling|arashan)$/i}
    npcs.delete_if { |npc| ['quickly growing troll king', 'severed troll arm', 'severed troll leg'].include?(npc.name) }
    npcs.delete_if { |npc| npc.type =~ /companion|familiar/i && npc.type !~ /aggressive npc/i }

    flee_count = (just_entered && @LONE_TARGETS_ONLY) ? 1 : @FLEE_COUNT
    if npcs.size > flee_count
      return true
    end
  end

  def valid_target?( target, just_entered = false )
    echo "valid_target?" if $bigshot_debug
    return false if target == nil || target == false
    return false if should_flee?(just_entered)
    return false if just_entered && poaching?
    return false if target.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && target.name !~ /ethereal|celestial|unworldly/i

    if( !CharSettings['targetable'].include?(target.name) && !CharSettings['untargetable'].include?(target.name) && target.status !~ /dead|gone/ )
      result = dothistimeout( "target ##{target.id}", 3, /^You are now targeting|^You can't target/ )
      if( result =~ /^You are now targeting/ )
        CharSettings['targetable'].push(target.name) if target.status !~ /dead|gone/
      elsif( result =~ /^You can't target/ )
        CharSettings['untargetable'].push(target.name) if target.status !~ /dead|gone/
      end
    end
    return false if CharSettings['untargetable'].include?(target.name)
    if (target.status !~ /dead|gone/) and GameObj.npcs.any? { |n| n.id == target.id } and (@TARGETS.nil? or @TARGETS.keys.any? { |i| target.name =~ /#{i}/i or target.noun =~ /#{i}/i })
      return true
    else
      return false
    end
  end

  def sort_npcs()
    echo "sort_npcs" if $bigshot_debug
    if $bigshot_quick
      targets = Hash.new
      tokens = []
      if @QUICKHUNT_TARGETS.nil?
        @QUICKHUNT_TARGETS = Hash.new 
        @QUICKHUNT_TARGETS["ZZTestZZ"]="ZZTestZZ"
      end
      npcs = GameObj.npcs.find_all { |i| i.status !~ /dead|gone/ }
      npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
      npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
      npcs.each {|i| tokens.push(i.name)}
      tokens.uniq.each {|i| 
        if i =~ /#{@QUICKHUNT_TARGETS.keys.join('|')}/i
          next
        else
          targets[i] = "quick"
        end
      }
      @TARGETS.replace(@QUICKHUNT_TARGETS)
      @TARGETS.merge!(targets)
      targets = @TARGETS
    else
      targets = @TARGETS
    end

    npcs = GameObj.npcs
    sorted = Array.new
    targets.keys.each { |target| sorted += npcs.find_all { |npc| (npc.name =~ /^#{target}$/i or npc.noun =~ /^#{target}$/i) }.to_a }
    sorted.flatten
  end

  def priority(target)
    echo "priority" if $bigshot_debug
    echo "priority check: #{(!$current_room_npcs.zip($room_npcs_last_check).map{|x,y| x.id==y.id}.any?{|s| s == false})}" if $bigshot_debug
    return true if (!$current_room_npcs.zip($room_npcs_last_check).map{|x,y| x.id==y.id}.any?{|s| s == false})
    $room_npcs_last_check = GameObj.npcs
    priority = false
    stoppriority = false
    npcs = GameObj.npcs.find_all { |i| i.status !~ /dead|gone/ }
    npcs.delete_if { |npc| CharSettings['untargetable'].include?(npc.name) }
    npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate/i && npc.name !~ /ethereal|celestial|unworldly/i }
    @TARGETS.keys.each{|t|
      break if stoppriority == true
      npcs.each{|s|
        break if stoppriority == true
        if (s.name =~ /#{t}/i or s.noun =~ /#{t}/i)
          if s.name == target.name
            stoppriority = true
            priority = true
          else
            stoppriority = true
          end
        end
      }
    }
    return priority
  end

  def find_target( target, just_entered = false )
    echo "find_target" if $bigshot_debug
    return target if valid_target?(target, just_entered)

    if @PRIORITY
      sort_npcs.each { |i| return i if valid_target?( i, just_entered ) && priority(i)  }
    else
      sort_npcs.each { |i| return i if valid_target?( i, just_entered ) }
    end
    return nil
  end

  def rt?()
    echo "rt?" if $bigshot_debug
    return checkrt()
  end

  def fried?()
    if( percentmind() >= @FRIED )
      return true
    end
    return false
  end

  def oom?()
    if( percentmana() < @OOM )
      return true
    end
    return false
  end

  def overkill?()
    if( $bigshot_overkill_counter >= @OVERKILL && lte_boost? )
      return true
    else
      return false
    end
  end

  def set_help_group( keep_attacking )
    @help_group_kill = keep_attacking
  end

  def lte_boost?()
    if( $bigshot_lte_boost_counter >= @LTE_BOOST )
      return true
    else
      return false
    end
  end

  def use_lte_boost()
    if(fried? && !lte_boost?) #Need the check because of the race condition caused if you are a follower in RT when called
      boost_attempt = dothistimeout "boost longterm", 3, /You do not have any Long-Term Experience Boosts to redeem.|You have deducted 500 experience points from your field experience/
        if boost_attempt =~ /You do not have any Long-Term Experience Boosts to redeem./
          message("No more LTE boosts available - Skipping")
          $bigshot_lte_boost_counter = @LTE_BOOST
          add_overkill()
        elsif boost_attempt =~ /You have deducted 500 experience points from your field experience/
          $bigshot_lte_boost_counter += 1
          message("Used LTE Boost: #{$bigshot_lte_boost_counter} of #{@LTE_BOOST}")
          $bigshot_overkill_counter = 0 
        end
    end  
  end

  def ammo_on_ground(ammo)
    echo "ammo_on_ground" if $bigshot_debug
    return GameObj.loot.find { |i| i.name =~ /\b#{ammo}s?\b/i or i.noun =~ /^#{ammo}s?$/i }
  end

  def gather_ammo()
    echo "gather_ammo" if $bigshot_debug
    ammo = @AMMO
    container = GameObj.inv.find { |obj| obj.name =~ /#{@AMMO_CONTAINER}/ }
    hide = @HIDE_FOR_AMMO

    return if wounded?

    if ammo.nil? or ammo.empty?
      return
    end

    if ammo =~ /\b(arrow|bolt|dart)\b/i
      ammo_noun = $1
    else
      echo "failed to gather: invalid ammo type specified (use the full name)"
    end

    if container.nil?
      echo "failed to gather: you must specify an ammo container to use this feature"
      return
    end

    while( ammo_on_ground(ammo_noun) )
      change_stance('defensive')

      unless GameObj.right_hand.id.nil?
        line = dothistimeout "stow ##{GameObj.right_hand.id}", 3, /put|closed/
        if line =~ /closed/
          fput "open my ##{container.id}"
          fput "put ##{GameObj.right_hand.id} in my ##{container.id}"
        end
      end

      result = dothistimeout( "gather #{ammo_noun}", 2, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/ )

      if( result =~ /on the ground/)
        result = dothistimeout "get #{ammo_noun}s", 3, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach|on the ground/
      end

      if( result =~ /^You gather|^You pick up/ )
        dothistimeout( "put my #{ammo_noun} in my #{ammo_noun}s in my #{container.noun}", 2, /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/ )
        bs_put "put my #{ammo_noun} in my ##{container.id}" if righthand?
      elsif( result =~ /You may only/ )
        return
      elsif( result == false || result =~ /^I could not find|^What were you/ )
        return
      elsif( result =~ /reach/ )
        bs_put 'hide' if hide and not hidden?
        sleep(4)
      end
    end
  end

  def reset_variables()
    echo "reset_variables" if $bigshot_debug
    $ambusher_here = false
    $bigshot_smite_list = []
    $bigshot_aim = 0
    $bigshot_ambush = 0
    $bigshot_archery_aim = 0
    $bigshot_archery_stuck_location = []
    $bigshot_unarmed_tier = 1
    $bigshot_unarmed_followup = false
    $bigshot_unarmed_followup_attack = ""
    $bigshot_703_list = []
    $bigshot_1614_list = []
  end

  def wounded?()
    if $bigshot_quick
      return false
    elsif(@WOUNDED_EVAL)
      return eval @WOUNDED_EVAL
    else
      return false
    end
  end

  def should_hunt?()
    echo "should_hunt?" if $bigshot_debug
    if(wounded?)
      $not_hunting_reason = 'wounded.'
      return false
    elsif( percentencumbrance >= @ENCUMBERED )
      $not_hunting_reason = 'encumbered.'
      return false
    elsif( @RESTING_SCRIPTS.any? { |i| running?(i) } )
      $not_hunting_reason = 'resting scripts still running.'
      return false
    end

    followers_should = (leading? && !solo?) ? @followers.should_hunt? : true
    if(followers_should)
      if( percentmind() > @REST_TILL_EXP )
        $not_hunting_reason = 'mind still above threshold.'
        return false
      elsif( percentmana() < @REST_TILL_MANA )
        $not_hunting_reason = 'mana still below threshold.'
        return false
      elsif( checkspirit() < @REST_TILL_SPIRIT )
        $not_hunting_reason = 'spirit still below threshold.'
        return false
      end
    else
      $not_hunting_reason = 'followers still need rest.'
      return false
    end
    $bigshot_status = :hunting
    return true
  end

  def should_rest?()
    echo "should_rest?" if $bigshot_debug
    if($bigshot_quick)
      return false
    elsif($bigshot_should_rest)
      $rest_reason = "$bigshot_should_rest was set to true." unless $rest_reason
      $bigshot_status = :resting
      return true
    elsif(wounded?)
      $rest_reason = "wounded."
      $bigshot_status = :resting
      return true
    elsif( percentencumbrance >= @ENCUMBERED )
      $rest_reason = "encumbered."
      $bigshot_status = :resting
      return true
    elsif( leading? && !solo? && @followers.emergency_rest? )
      $rest_reason = "emergency rest."
      $bigshot_status = :resting
      return true
    elsif ( !solo? && !leading? && @help_group_kill )
      return false if !oom?  
    end

    if (leading? && !solo? && fried? && overkill? && lte_boost? )
      @followers.group_assist( false )
    end

    followers_fried = (leading? && !solo?) ? ( @followers.should_rest? && overkill? && lte_boost? ) : true

    if(followers_fried)
      if(fried? && overkill? && lte_boost?)
        $rest_reason = "fried."
        $bigshot_status = :resting
        return true
      elsif(oom?)
        wrack() if @USE_WRACKING
        return false if !oom?

        $rest_reason = "out of mana."
        $bigshot_status = :resting
        return true
      end
    end

    $rest_reason = "none."
    if (!solo? && leading?)
      @followers.group_assist( true )
    end 
    return false
  end

  def add_overkill()
    if (fried? && lte_boost?)
      $bigshot_overkill_counter += 1
      message("Extra Kills currently at: #{$bigshot_overkill_counter} of #{@OVERKILL}")
    end
    
    if (!solo? && leading?)
      @followers.add_event(:FOLLOWER_OVERKILL)
    end  
  end  

  def cast_signs(single_cast = false)
    echo "cast_signs?" if $bigshot_debug
    @SIGNS.each do |i|
      i = i.to_i
      next if [ 9903,9904,9905,9906,9907,9908,9909,9910,9912,9913,9914,9918 ].include?(i) and Spell[9012].active?
      next if i == 9918
      next if i == 9603 && Spell[9604].active?
      next if i == 9605 && Spell[9606].active?
      sign = Spell[i]
      next unless sign.known?

      # wrack?
      mana_cost = sign.mana_cost > 1 ? sign.mana_cost : 0 # Many erroneously return 1
      wrack() if !sign.affordable? and mana_cost > checkmana and @USE_WRACKING

      if( !sign.active? && sign.affordable? )
        if( i  == 9805 )
          2.times { sign.cast }
        else
          while(1)
            result = sign.cast
            break if result !~ /Spell Hindrance/ || !sign.affordable? || dead?
          end
        end

        break if single_cast
      end
    end
  end

  def loot()
    echo "loot" if $bigshot_debug
    waitrt?
    if checkroom("Duskruin Arena, Dueling Sands").nil?
      dead_npcs = GameObj.npcs.find_all { |i| i.status == 'dead' && i.type !~ /escort/i }
      reset_variables() if !dead_npcs.nil? && dead_npcs != []
      if @DELAY_LOOT && sort_npcs.any? {|s| valid_target?(s)} && (!dead_npcs.nil? && dead_npcs != []) && !should_flee?
        if $last_loot.nil?
          $last_loot=Time.now + 15
        elsif $last_loot <= Time.now
          dead_npcs.each { |i|
            $last_loot = nil
            use_lte_boost()
            add_overkill()
            change_stance('defensive') if GameObjNpcCheck() > 0 && @LOOT_STANCE
            if(@LOOT_SCRIPT)
              run_script( @LOOT_SCRIPT, true )
              break
            else
              bs_put "loot ##{i.id}"
            end
          }
        end
      else
        dead_npcs.each { |i|
          $last_loot = nil
          use_lte_boost()
          add_overkill()
          change_stance('defensive') if GameObjNpcCheck() > 0 && @LOOT_STANCE
          if(@LOOT_SCRIPT)
            run_script( @LOOT_SCRIPT, true )
            break
          else
            bs_put "loot ##{i.id}"
          end
        }
      end
    end
  end

  def prepare_for_movement()
    echo "prepare_for_movement" if $bigshot_debug
    reset_variables()
    change_stance('defensive')
    if( leading? && !solo? )
      @followers.add_event(:PREP_REST)
      wait_while { @followers.roundtime? }
      sleep(0.3)
    end
    cmd_bless() if @BLESS && $bigshot_bless.count > 0
  end

  def bs_wander()
    echo "bs_wander" if $bigshot_debug
    $wander_rooms    ||= Array.new

    wander = proc {
      room = Room.current
      next_room_options = room.wayto.keys - @HUNTING_BOUNDARIES
      next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
      next_room = next_room_options.find_all { |r| not $wander_rooms.include?(r) }
      if next_room.empty?
        next_room = $wander_rooms.find { |r| next_room_options.include?(r) }
      else
        next_room = next_room[rand(next_room.length)]
      end
      $wander_rooms.delete(next_room)
      $wander_rooms.push(next_room)
      way = room.wayto[next_room]
      if way.class == String
        pause @WANDER_WAIT
        move(way)
      else
        way.call
      end
      GameObj.pcs.each {|s| if s.status =~ /kneeling|sitting|^lying|prone/;fput "pull #{s.noun}";end;} if GameObj.npcs.any? {|s| s.type =~ /aggressive npc/} && @PULL
      cast_signs(true)
    }

    while true  # wander, check for players
      reset_variables()
      change_stance('defensive')
      exit if $bigshot_quick
      npcs = GameObj.npcs
      npcs.delete_if { |npc| (npc.status =~ /dead|gone/) }
      sort_npcs.each{ |i| return i if valid_target?( i, true ) and no_players == true and (GameObjNpcCheck() > 0) }
      return if should_rest?
      $obvious_hiding_player = false
      wander.call
      sleep(0.1)
      $bigshot_flee = false
    end
  end

  def CompanionCheck() 
    if ( Char.prof =~ /Ranger/i && Spell[630].known? && GameObj.npcs.any?{|i| i.type =~ /companion/} && $companion == nil )
      npcs = GameObj.npcs.find_all { |i| i.type =~ /companion/i }
      npcs.each {|i| 
        res = dothistimeout "lean ##{i.id}", 1, /your direction in acknowledgement|rubbing.*gently|while it is flying|You lean toward/i
        if res =~ /rubbing.*gently/i
          $companion = i.name
          echo "Ranger Companion set to #{i.name}"
          break
        end
      }
    end
    if ( Char.prof =~ /Wizard/i && Spell[920].known? && GameObj.npcs.any?{|i| i.type =~ /familiar/} )
      res = dothistimeout "tell familiar to return", 1, /You sense understanding from your .*\.|You have no familiar at this time\./i
      if res =~ /You sense understanding from your/i
        res.sub!('You sense understanding from your ','')
        res.gsub!('.','')
        GameObj.npcs.each{|s|
          if s.name =~ /#{res}/i
            $familiar = s.name
            break
          end
        }
        echo "Familiar set as #{$familiar}"
      end
    end
  end

  def RoaterEscape()
    find_all_containers_var = nil
    empty_hands
    hp = proc { |ss| if ss =~ /^You are wearing/; DownstreamHook.remove('find_all_container_ids'); nil; else; ss; end }
    DownstreamHook.add('find_all_container_ids', hp)
    restore_silent = script.silent
    restore_want_downstream = script.want_downstream
    restore_want_downstream_xml = script.want_downstream_xml
    script.silent = true
    script.want_downstream = false
    script.want_downstream_xml = true
    clear
    put 'inventory containers'
    script.silent = restore_silent
    timeout = Time.now + 30
    container_ids = []
    while (Time.now < timeout) and (line = get)
      if line =~ /^You are wearing/
        container_ids = line.scan(/<a exist=\"([^\"]+)\"/).flatten
        break
      end
    end
    script.want_downstream = restore_want_downstream
    script.want_downstream_xml = restore_want_downstream_xml
    clear
    find_all_containers_var = container_ids.collect { |id| GameObj[id] }
    find_all_containers_var.each{|i| 
      if i.contents.nil?
        fput "look in ##{i.id}"
      end
      i.contents.each{|s| 
        if s.name =~ /alfange|basilard|bodkin|cinquedea|dagger|dirk|knife|kozuka|ice pick|misericord|parazonium|pavade|poignard|pugio|scramasax|sgian achlais|spike|stiletto|tanto|sidearm-of-Onar/i
          fput "_drag ##{s.id} right"
          while !checkroom("The Belly of the Beast").nil?
            waitrt?
            fput "attack wall"
          end
          fput "_drag ##{s.id} ##{i.id}"
          break
        end
      }
    }
    fill_hands
  end

  def bs_put(message)
    echo "bs_put" if $bigshot_debug
    unless script = Script.self then respond('--- waitfor: Unable to identify calling script.'); return false; end
    clear
    put(message)

    while string = get
      if string =~ /(?:\.\.\.wait |Wait )[0-9]+/
        hold_up = string.slice(/[0-9]+/).to_i
        sleep(hold_up - 1) unless hold_up.nil? || hold_up == 1
        clear
        put(message)
        next
      elsif string =~ /struggle.+stand/
        clear
        bs_put("stand")
        next
      elsif string =~ /stunned|can't do that while|cannot seem|can't seem|don't seem|Sorry, you may only type ahead/
        if dead?
          echo("You're dead...! You can't do that!")
          sleep(0.25)
          script.downstream_buffer.unshift(string)
          return false
        elsif checkstunned
          while checkstunned
            sleep(0.25)
          end
        elsif checkwebbed
          while checkwebbed
            sleep(0.25)
          end
        else
          sleep(0.25)
        end
        clear
        put(message)
        next
      else
        script.downstream_buffer.unshift(string)
        return string
      end
    end
  end

  # gui
  def self.setup
    Gtk.queue {
      $OP_WINDOW = Gtk::Window.new
      $OP_WINDOW.title = "Big Shot: v#{BIGSHOT_VERSION}"
      $OP_WINDOW.set_icon(@@default_icon)
      $OP_WINDOW.set_border_width(10)
      $OP_WINDOW.keep_above = true
      #$OP_BOX = Gtk::VBox.new(false)
      $OP_BOX = Gtk::Box.new(:vertical)
      $OP_BOX.set_border_width(5)

      #$OP_VERTICAL_BOX1 =  Gtk::VBox.new(false, 0)
      #$OP_VERTICAL_BOX2 =  Gtk::VBox.new(false, 0)
      #$OP_VERTICAL_BOX3 =  Gtk::VBox.new(false, 0)
      #$OP_VERTICAL_BOX4 =  Gtk::VBox.new(false, 0)
      #$OP_VERTICAL_BOX5 =  Gtk::VBox.new(false, 0)
      #$OP_VERTICAL_BOX6 =  Gtk::VBox.new(false, 0)
      #$OP_VERTICAL_BOX7 =  Gtk::VBox.new(false, 0)
      #$OP_VERTICAL_BOX8 =  Gtk::VBox.new(false, 0)
      #$OP_VERTICAL_BOX9 =  Gtk::VBox.new(false, 0)
      #$OP_VERTICAL_BOX10 = Gtk::VBox.new(false, 0)
      #$OP_VERTICAL_BOX11 = Gtk::VBox.new(false, 0)
      $OP_VERTICAL_BOX1 =  Gtk::Box.new(:vertical, 0)
      $OP_VERTICAL_BOX2 =  Gtk::Box.new(:vertical, 0)
      $OP_VERTICAL_BOX3 =  Gtk::Box.new(:vertical, 0)
      $OP_VERTICAL_BOX4 =  Gtk::Box.new(:vertical, 0)
      $OP_VERTICAL_BOX5 =  Gtk::Box.new(:vertical, 0)
      $OP_VERTICAL_BOX6 =  Gtk::Box.new(:vertical, 0)
      $OP_VERTICAL_BOX7 =  Gtk::Box.new(:vertical, 0)
      $OP_VERTICAL_BOX8 =  Gtk::Box.new(:vertical, 0)
      $OP_VERTICAL_BOX9 =  Gtk::Box.new(:vertical, 0)
      $OP_VERTICAL_BOX10 = Gtk::Box.new(:vertical, 0)
      $OP_VERTICAL_BOX11 = Gtk::Box.new(:vertical, 0)

      $OP_WINDOW.add($OP_BOX)
      $OP_NOTEBOOK = Gtk::Notebook.new
      $OP_NOTEBOOK.set_show_border(true)
      $OP_BOX.add($OP_NOTEBOOK)
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX1,  Gtk::Label.new('General'))
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX2,  Gtk::Label.new('Resting'))
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX3,  Gtk::Label.new('Hunting Map'))
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX4,  Gtk::Label.new('Hunting'))
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX5,  Gtk::Label.new('Attacking'))
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX6,  Gtk::Label.new('Commands'))
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX7,  Gtk::Label.new('UAC'))
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX8,  Gtk::Label.new('MSTRIKE'))
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX9,  Gtk::Label.new('Should_hunt?'))
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX10, Gtk::Label.new('Should_rest?'))
      $OP_NOTEBOOK.append_page($OP_VERTICAL_BOX11, Gtk::Label.new('Ammo/Wands'))

      $OP_ENTRY = Hash.new # For mapping entries to variables
      $OP_TABLE_SIZE = Hash.new # For mapping table sizes
    }

    Gtk.queue {
      $OP_TABLE1 = Gtk::Table.new(6, 3, false)
      $OP_TABLE1.row_spacings=3
      $OP_TABLE1.column_spacings=3
      #$OP_VERTICAL_BOX1.pack_start($OP_TABLE1, false, false, 0)
      $OP_VERTICAL_BOX1.pack_start($OP_TABLE1, :expand => false, :fill => false, :padding => 0)

      $OP_TABLE2 = Gtk::Table.new(6, 3, false)
      $OP_TABLE2.row_spacings=3
      $OP_TABLE2.column_spacings=3
      #$OP_VERTICAL_BOX2.pack_start($OP_TABLE2, false, false, 0)
      $OP_VERTICAL_BOX2.pack_start($OP_TABLE2, :expand => false, :fill => false, :padding => 0)

      $OP_TABLE3 = Gtk::Table.new(6, 3, false)
      $OP_TABLE3.row_spacings=3
      $OP_TABLE3.column_spacings=3
      #$OP_VERTICAL_BOX3.pack_start($OP_TABLE3, false, false, 0)
      $OP_VERTICAL_BOX3.pack_start($OP_TABLE3, :expand => false, :fill => false, :padding => 0)

      $OP_TABLE4 = Gtk::Table.new(6, 3, false)
      $OP_TABLE4.row_spacings=3
      $OP_TABLE4.column_spacings=3
      #$OP_VERTICAL_BOX4.pack_start($OP_TABLE4, false, false, 0)
      $OP_VERTICAL_BOX4.pack_start($OP_TABLE4, :expand => false, :fill => false, :padding => 0)

      $OP_TABLE5 = Gtk::Table.new(6, 3, false)
      $OP_TABLE5.row_spacings=3
      $OP_TABLE5.column_spacings=3
      #$OP_VERTICAL_BOX5.pack_start($OP_TABLE5, false, false, 0)
      $OP_VERTICAL_BOX5.pack_start($OP_TABLE5, :expand => false, :fill => false, :padding => 0)

      $OP_TABLE6 = Gtk::Table.new(6, 3, false)
      $OP_TABLE6.row_spacings=1
      $OP_TABLE6.column_spacings=1
      #$OP_VERTICAL_BOX6.pack_start($OP_TABLE6, false, false, 0)
      $OP_VERTICAL_BOX6.pack_start($OP_TABLE6, :expand => false, :fill => false, :padding => 0)

      $OP_TABLE7 = Gtk::Table.new(6, 3, false)
      $OP_TABLE7.row_spacings=3
      $OP_TABLE7.column_spacings=3
      #$OP_VERTICAL_BOX7.pack_start($OP_TABLE7, false, false, 0)
      $OP_VERTICAL_BOX7.pack_start($OP_TABLE7, :expand => false, :fill => false, :padding => 0)

      $OP_TABLE8 = Gtk::Table.new(6, 3, false)
      $OP_TABLE8.row_spacings=3
      $OP_TABLE8.column_spacings=3
      #$OP_VERTICAL_BOX8.pack_start($OP_TABLE8, false, false, 0)
      $OP_VERTICAL_BOX8.pack_start($OP_TABLE8, :expand => false, :fill => false, :padding => 0)

      $OP_TABLE9 = Gtk::Table.new(6, 3, false)
      $OP_TABLE9.row_spacings=3
      $OP_TABLE9.column_spacings=3
      #$OP_VERTICAL_BOX9.pack_start($OP_TABLE9, false, false, 0)
      $OP_VERTICAL_BOX9.pack_start($OP_TABLE9, :expand => false, :fill => false, :padding => 0)

      $OP_TABLE10 = Gtk::Table.new(6, 3, false)
      $OP_TABLE10.row_spacings=3
      $OP_TABLE10.column_spacings=3
      #$OP_VERTICAL_BOX10.pack_start($OP_TABLE10, false, false, 0)
      $OP_VERTICAL_BOX10.pack_start($OP_TABLE10, :expand => false, :fill => false, :padding => 0)

      $OP_TABLE11 = Gtk::Table.new(6, 3, false)
      $OP_TABLE11.row_spacings=3
      $OP_TABLE11.column_spacings=3
      #$OP_VERTICAL_BOX11.pack_start($OP_TABLE11, false, false, 0)
      $OP_VERTICAL_BOX11.pack_start($OP_TABLE11, :expand => false, :fill => false, :padding => 0)
    }

    def self.add_label_entry(table, label, variable)
      size = $OP_TABLE_SIZE[table] || 0

      label = Gtk::Label.new(label)
      align = Gtk::Alignment.new 1, 0, 0, 0
      align.set_padding(4, 0, 3, 4)
      align.add(label)
      table.attach(align, 0, 1, size, size + 1)

      entry = Gtk::Entry.new
      entry.text = UserVars.op[variable].to_s
      entry.set_width_request(157)
      table.attach(entry, 1, 2, size, size + 1)

      $OP_ENTRY[variable] = entry
      $OP_TABLE_SIZE[table] += 1
    end

    def self.add_dropdown(table, dropdown, variable, options)
      size = $OP_TABLE_SIZE[table] || 0
      i = 0
      label = Gtk::Label.new(dropdown)
      #dropdown = Gtk::ComboBox.new
      dropdown = Gtk::ComboBoxText.new
      options.split(',').each{|s|
        dropdown.append_text(s)
      }
      if UserVars.op[variable].nil?
        dropdown.set_active(0)
      else
        if UserVars.op[variable].class.to_s != "Fixnum" && UserVars.op[variable].class.to_s != "Integer"
          UserVars.op[variable] = 0
        end
        dropdown.set_active(UserVars.op[variable])
      end
      align = Gtk::Alignment.new 1, 0, 0, 0
      align2 = Gtk::Alignment.new 1, 0, 1, 0
      align.set_padding(4, 0, 3, 4)
      align2.set_padding(0, 0, 0, 0)
      align.add(label)
      align2.add(dropdown)
      table.attach(align, 0, 1, size, size + 1)
      table.attach(align2, 1, 2, size, size + 1)
      $OP_ENTRY[variable] = dropdown
      $OP_TABLE_SIZE[table] += 1
    end

    Gtk.queue {
      $OP_ENTRY = Hash.new
      add_label_entry($OP_TABLE2, "*room id:", 'resting_room_id')
      add_label_entry($OP_TABLE2, "pre-rest commands:", 'resting_commands')
      add_label_entry($OP_TABLE2, "active resting scripts:", 'resting_scripts')
      add_dropdown($OP_TABLE2, "Fog Options:", 'fog_return', 'None,Spirit Guide(130),Voln Symbol of Return,Traveler\'s Song(1020)')
      add_label_entry($OP_TABLE3, "*starting room ID:", 'hunting_room_id')
      add_label_entry($OP_TABLE3, "*boundary rooms:", 'hunting_boundaries')
      add_label_entry($OP_TABLE4, "valid targets:", 'targets')
      add_label_entry($OP_TABLE4, "quickhunt targets:", 'quickhunt_targets')
      add_label_entry($OP_TABLE4, "attack stance:", 'hunting_stance')
      add_label_entry($OP_TABLE4, "pre-hunt commands:", 'hunting_prep_commands')
      add_label_entry($OP_TABLE4, "active hunting scripts:", 'hunting_scripts')
      add_label_entry($OP_TABLE4, "society abilities/spells/cmans:", 'signs')
      add_label_entry($OP_TABLE4, "loot script:", 'loot_script')
      add_label_entry($OP_TABLE4, "wracking spirit >=", 'wracking_spirit')
      add_label_entry($OP_TABLE5, "Ambush aiming locations (head, etc):", 'ambush')
      add_label_entry($OP_TABLE5, "Archery aiming locations (head, etc):", 'archery_aim')
      add_label_entry($OP_TABLE5, "flee if enemy count is >", 'flee_count')
      add_label_entry($OP_TABLE5, "...but don't count these:", 'invalid_targets')
      add_label_entry($OP_TABLE5, "...and always flee from:", 'always_flee_from')
      add_label_entry($OP_TABLE5, "flee from environment message:", 'flee_message')
      add_label_entry($OP_TABLE5, "Wait before wandering to another room:", 'wander_wait')
      add_label_entry($OP_TABLE6, "hunting commands(a):", 'hunting_commands')
      add_label_entry($OP_TABLE6, "hunting commands(b):", 'hunting_commands_b')
      add_label_entry($OP_TABLE6, "hunting commands(c):", 'hunting_commands_c')
      add_label_entry($OP_TABLE6, "hunting commands(d):", 'hunting_commands_d')
      add_label_entry($OP_TABLE6, "hunting commands(e):", 'hunting_commands_e')
      add_label_entry($OP_TABLE6, "hunting commands(f):", 'hunting_commands_f')
      add_label_entry($OP_TABLE6, "hunting commands(g):", 'hunting_commands_g')
      add_label_entry($OP_TABLE6, "hunting commands(h):", 'hunting_commands_h')
      add_label_entry($OP_TABLE6, "hunting commands(i):", 'hunting_commands_i')
      add_label_entry($OP_TABLE6, "hunting commands(j):", 'hunting_commands_j')
      add_label_entry($OP_TABLE6, "fried hunting commands:", 'disable_commands')
      add_label_entry($OP_TABLE6, "quick hunting commands:", 'quick_commands')
      add_label_entry($OP_TABLE7, "Tier 3 Attack", 'tier3')
      add_label_entry($OP_TABLE7, "Aim at location (head, etc)", 'aim')
      add_label_entry($OP_TABLE8, "MSTRIKE during cooldown stamina requirement", 'mstrike_stamina_cooldown')
      add_label_entry($OP_TABLE8, "QUICKSTRIKE stamina requirement", 'mstrike_stamina_quickstrike')
      add_label_entry($OP_TABLE8, "Unfocused MSTRIKE when creatures equal or greater", 'mstrike_mob')
      add_label_entry($OP_TABLE9, "*when percentmind <=", 'rest_till_exp')
      add_label_entry($OP_TABLE9, "...*and percentmana >=", 'rest_till_mana')
      add_label_entry($OP_TABLE9, "...and CHECKspirit >=", 'rest_till_spirit')
      add_label_entry($OP_TABLE10, "*when percentmind >=", 'fried')
      add_label_entry($OP_TABLE10, "...and extra kills >=", 'overkill')
      add_label_entry($OP_TABLE10, "...and used lte boosts >=", 'lte_boost')
      add_label_entry($OP_TABLE10, "...*or percentmana <=", 'oom')
      add_label_entry($OP_TABLE10, "...or percentencumbrance >=", 'encumbered')
      add_label_entry($OP_TABLE10, "...or wounded eval:", 'wounded_eval')
      add_label_entry($OP_TABLE11, "find ammo in this container:", 'ammo_container')
      add_label_entry($OP_TABLE11, "use this ammo type:", 'ammo')
      add_label_entry($OP_TABLE11, "fresh wand container:", 'fresh_wand_container')
      add_label_entry($OP_TABLE11, "dead wand container:", 'dead_wand_container')
      add_label_entry($OP_TABLE11, "use this wand type:", 'wand')
    }

    def self.add_checkbox(table, x_pos, label, variable, default = false)
      size = $OP_TABLE_SIZE[table] || 0
      checkbox = Gtk::CheckButton.new label
      value = UserVars.op[variable].nil? ? default : UserVars.op[variable]
      checkbox.set_active(value)
      table.attach(checkbox, x_pos, x_pos + 1, size, size + 1)
      $OP_ENTRY[variable] = checkbox
      $OP_TABLE_SIZE[table] += 1 if x_pos == 1
    end

    Gtk.queue {
      add_checkbox($OP_TABLE1,  0, "Engage deadmans switch", 'dead_man_switch')
      add_checkbox($OP_TABLE1,  1, "Monitor interaction", 'monitor_interaction')
      add_checkbox($OP_TABLE1,  0, "Depart/rerun if dead", 'depart_switch')
      add_checkbox($OP_TABLE1,  1, "Flee from clouds", 'flee_clouds')
      add_checkbox($OP_TABLE1,  0, "Quiet followers", 'quiet_followers', true)
      add_checkbox($OP_TABLE1,  1, "Flee from vines", 'flee_vines')
      add_checkbox($OP_TABLE1,  1, "Flee from webs", 'flee_webs')
      add_checkbox($OP_TABLE4,  0, "Priority hunt", 'priority')
      add_checkbox($OP_TABLE4,  1, "Use sign of wracking/sigil of power/symbol of mana", 'use_wracking')
      add_checkbox($OP_TABLE4,  0, "Delay looting", 'delay_loot')
      add_checkbox($OP_TABLE4,  1, "Defensive stance before looting", 'loot_stance')
      add_checkbox($OP_TABLE4,  1, "Pull players to feet", 'pull', true)
      add_checkbox($OP_TABLE5,  1, "Spam attacks (recommended)", 'spam', true)
      add_checkbox($OP_TABLE5,  1, "Approach lone targets only", 'lone_targets_only', false)
      add_checkbox($OP_TABLE5,  1, "Bless weapon?", 'bless', false)
      add_checkbox($OP_TABLE7,  1, "Use Voln SMITE?", 'uac_smite', false)
      add_checkbox($OP_TABLE8,  1, "MSTRIKE during cooldown", 'mstrike_cooldown', false)
      add_checkbox($OP_TABLE8,  1, "Use QUICKSTRIKE for MSTRIKE", 'mstrike_quickstrike', false)
      add_checkbox($OP_TABLE11, 1, "Hide while waiting to pick up ammo", 'hide_for_ammo')
      add_checkbox($OP_TABLE11, 1, "Use wands when out of mana", 'wand_if_oom')
    }

    Gtk.queue {
      $OP_WINDOW.signal_connect("delete_event") {
        $OP_SETUP_COMPLETED = true
      }
    }

    Gtk.queue {
#      $OP_TOOLTIPS = Gtk::Tooltips.new.enable

      label = Gtk::Label.new
      label.set_markup("<i>Bigshot is the leader of the Battle Patrol.\nHe comes equipped with a gun as long as his entire superstructure.\nTakes the edge off.\n\n\n***Settings with * are required.***</i>")
      align = Gtk::Alignment.new(1, 0, 0, 0)
      align.set_padding(50, 0, 0, 40)
      align.add(label)
      $OP_TABLE1.attach(align, 1, 2, 8, 9)

      commands_tip =  "Example 1: 413 target, 903 target\nExample 2: 903 target(x2)\nExample 3: 903 target(xx)\nExample 4: 910 target(m50), 903 target\nExample 5: unarmed punch, wait 30\nExample 1 will cast 413 then 903 on the target. Example 2 will cast 903 on the target twice. Example 3 will cast 903 on the target until the fight is over. Example 4 will cast 910 if mana is at least 50, otherwise it will cast 903. Example 5 will start the unarmed routine with punch as the main attack. It will attack once, then wait 30 seconds for another attack to happen before attacking again.\nSeparate all commands with commas.\n\nNew feature: 'and'.\nFor example: stance def and 1615 target, kill target(xx)"
      disable_tip = "If left blank and this character is in a bigshot group, character will continue to use standard hunting commands after mind is fried and overkill limit is reached\nIf row populated, and character is in a bigshot group, these commands will be used instead of standard hunting commands once fried and overkill limit reached\nSee hunting commands tooltip for examples on what commands to use."
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['hunting_commands'], commands_tip, "")

#      $OP_TOOLTIPS.set_tip($OP_ENTRY['hunting_commands_g'], commands_tip, "")
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['disable_commands'], disable_tip, "")
      $OP_ENTRY['hunting_commands'].set_tooltip_text(commands_tip)
	    $OP_ENTRY['hunting_commands_g'].set_tooltip_text(commands_tip)
	    $OP_ENTRY['disable_commands'].set_tooltip_text(disable_tip)

      quiet_followers_tip = "Followers will wait until Leader is done with both actions and resting scripts to begin using their own\n\nUse Case: Prevents you from looking like you have mindless bots following while selling loot"
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['quiet_followers'], quiet_followers_tip, "")
      $OP_ENTRY['quiet_followers'].set_tooltip_text(quiet_followers_tip)

      signs_tip = "Shadow Mastery - 9603\nSurge of Strength - 9605\n\nSigil of Contact - 9703\nSigil of Resolve - 9704\nSigil of Minor Bane - 9705\nSigil of Defense - 9707\nSigil of Offense - 9708\nSigil of Minor Protection - 9710\nSigil of Focus - 9711\nSigil of Mending - 9713\nSigil of Concentration - 9714\nSigil of Major Bane - 9715\nSigil of Major Determination - 9716\nSigil of Major Protection - 9719\n\nSign of Warding - 9903\nSign of Striking - 9904\nSign of Thought - 9906\nSign of Defending - 9907\nSign of Smiting - 9908\nSign of Staunching - 9909\nSign of Deflection - 9910\nSign of Swords - 9912\nSign of Shields - 9913\nSign of Dissipation - 9914\nSign of Madness - 9916\n\nSymbol of Courage - 9805\nSymbol of Protection - 9806"
      #      $OP_TOOLTIPS.set_tip($OP_ENTRY['signs'], signs_tip, "")
      $OP_ENTRY['signs'].set_tooltip_text(signs_tip)

      aim_tip = "Leave blank if you don't want to aim at anything\n\nSuggest leaving chest as last thing to aim at so you will always have something to hit"
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['aim'], aim_tip, "")
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['archery_aim'], aim_tip, "")
      $OP_ENTRY['aim'].set_tooltip_text(aim_tip)
      $OP_ENTRY['archery_aim'].set_tooltip_text(aim_tip)
      mstrike_tip = "Set this to the highest you want your stamina to be before you MSTRIKE.\nImportant if MSTRIKEing during its cooldown or while using QUICKSTRIKE.\nLeave blank to use max stamina variable instead\nCombination of QUICKSTRIKE and MSTRIKE during cooldown may pop muscles.\nIve done best I can to ensure it doesn't happen, but depends on what you set your MSTRIKE stamina to.\n\nWorks in conjunction with MSTRIKE creature #, so if you meet the requirements for it and not this one you will MSTRIKE and visaversa."
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['mstrike_stamina_cooldown'], mstrike_tip, "")
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['mstrike_stamina_quickstrike'], mstrike_tip, "")
      $OP_ENTRY['mstrike_stamina_cooldown'].set_tooltip_text(mstrike_tip)
      $OP_ENTRY['mstrike_stamina_quickstrike'].set_tooltip_text(mstrike_tip)
      mstrike_mob_tip = "How many creatures you want in the room before you perform an unfocused MSTRIKE.\nDefault is 2. Set to 1 to always do an unfocused MSTRIKE."
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['mstrike_mob'], mstrike_mob_tip, "")
      $OP_ENTRY['mstrike_mob'].set_tooltip_text(mstrike_mob_tip)

      bless_tip = "Will bless whatever item ran out of blessing.\nWill do 304 if known or Symbol of Bless otherwise.\nIf you can do neither of those will rest and exit the script."
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['bless'], bless_tip, "")
      $OP_ENTRY['bless'].set_tooltip_text(bless_tip)

      priority_tip = "Priority is based on order of valid targets box on hunting tab. Will switch to highest priority in room when attacking."
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['priority'], priority_tip, "")
	    $OP_ENTRY['priority'].set_tooltip_text(priority_tip)

      smite_tip = "Will SMITE a non-corporeal undead when tier is excellent during UAC Combat"
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['uac_smite'], smite_tip, "")
      $OP_ENTRY['uac_smite'].set_tooltip_text(smite_tip)

      flee_tip = "Input any text that when the game sends you want to move out of the room from\nlike a Roa'ter burrow attack \"You feel a rumble come from beneath your feet.\"\nSeperate different messages with a | in between them."
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['flee_message'], flee_tip, "")
      $OP_ENTRY['flee_message'].set_tooltip_text(flee_tip)

      fog_tip = "None: Dont use any fog options when you return from a hunt\n\nSpirit Guide(130): Use 130 first, then if that fails Symbol of Return\n\nVoln Symbol of Return: Use Symbol of Return first, then if that fails 130\n\nTraveler's Song(1020): Use 1020 only"
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['fog_return'], fog_tip, "")
      $OP_ENTRY['fog_return'].set_tooltip_text(fog_tip)

      fried_tip = "Percentage of your mind (0-100) after which you will stop hunting.\n  101\t will hunt until mana/encumbrance/wounded\n  100\tis fully fried"
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['fried'], fried_tip, "")
      $OP_ENTRY['fried'].set_tooltip_text(fried_tip)

      overkill_tip = "This is the number of additional monsters to kill after reaching your fried threshold.\n  0    \tWill not kill extra monsters\n  3-5\trecommended to ensure true 100% fried state"
#      $OP_TOOLTIPS.set_tip($OP_ENTRY['overkill'], overkill_tip, "")
      $OP_ENTRY['overkill'].set_tooltip_text(overkill_tip)

      size = $OP_TABLE_SIZE[$OP_TABLE3]
      label = Gtk::Label.new
      label.set_markup("<i>Note: Big Shot will not enter boundary rooms. The goal is to pin yourself into a hunting area.</i>")
      align = Gtk::Alignment.new(1, 0, 0, 0)
      align.set_padding(75, 0, 0, 4)
      align.add(label)
      $OP_TABLE3.attach(align, 1, 2, size, size + 1)

      size = $OP_TABLE_SIZE[$OP_TABLE4]
      label = Gtk::Label.new
      label.set_markup("<i>Note: Use nouns or name for targets.\nMouse over society abilities field for more info.</i>")
      align = Gtk::Alignment.new(1, 0, 0, 0)
      align.set_padding(10, 0, 0, 300)
      align.add(label)
      $OP_TABLE4.attach(align, 1, 2, size, size + 1)

      size = $OP_TABLE_SIZE[$OP_TABLE5]
      label = Gtk::Label.new
      label.set_markup("<i>Note: Use noun or name for flee info.\nMouse over some hunting commands field for more info.</i>")
      align = Gtk::Alignment.new(1, 0, 0, 0)
      align.set_padding(10, 0, 0, 200)
      align.add(label)
      $OP_TABLE5.attach(align, 1, 2, size, size + 1)

      size = $OP_TABLE_SIZE[$OP_TABLE8]
      label = Gtk::Label.new
      label.set_markup("1107 and 1607 automatically cast if appropriate when using MSTRIKE\nEmpaths and Paladins rejoice!")
      align = Gtk::Alignment.new(1, 0, 0, 0)
      align.set_padding(75, 0, 0, 75)
      align.add(label)
      $OP_TABLE8.attach(align, 1, 2, size , size + 1)

      $OP_WINDOW.show_all
    }

    $OP_SETUP_COMPLETED = false
    until($OP_SETUP_COMPLETED)
      sleep(0.5)
    end

    UserVars.op ||= Hash.new
    $OP_ENTRY.keys.each { |key|
      echo "#{key} - #{$OP_ENTRY[key].class.to_s}" if $bigshot_debug
      if( $OP_ENTRY[key].class.to_s =~ /CheckButton/ )
        value = $OP_ENTRY[key].active?
        UserVars.op[key] = $OP_ENTRY[key].active?
      elsif ( $OP_ENTRY[key].class.to_s =~ /ComboBox/ )
        UserVars.op[key] = $OP_ENTRY[key].active
      else
        if(key == 'wounded_eval')
          UserVars.op[key] = $OP_ENTRY[key].text
        else
          UserVars.op[key] = $OP_ENTRY[key].text.strip.downcase
        end
      end
    }
    UserVars.save()

    Gtk.queue {
      $OP_WINDOW.destroy
    }
  end
  def self.profile(vars)
    if vars[2] =~ /load/i
      if vars[3] != nil
        dir = "#{$lich_dir}scripts/bigshot_profiles"
        filename = "#{dir}/#{vars[3]}.yaml"
        if !File.exists?("#{filename}")
          echo "Trying to load a profile that does not exist."
        else
          from_file = YAML.load_file(filename)
          UserVars.op = from_file
          echo "Settings loaded from profile: #{filename}."
        end
      else
        echo "You forgot to name your profile you wish to load."
        echo "Syntax: ;bigshot profile load <NAME Here, no Spaces!>"
      end
    elsif vars[2] =~ /save/i
      if vars[3] != nil
        Dir.mkdir("#{$lich_dir}scripts/bigshot_profiles") unless File.exists?("#{$lich_dir}scripts/bigshot_profiles")
        dir = "#{$lich_dir}scripts/bigshot_profiles"
        filename = "#{dir}/#{vars[3]}.yaml"
        if File.exists?("#{filename}")
          echo "File already exists, if you wish to overwrite, please ;unpause bigshot."
          echo "Else ;kill bigshot and choose another filename."
          pause_script
        end
        File.write(filename, UserVars.op.to_yaml)
        echo "Settings saved to profile: #{filename}."
      else
        echo "You forgot to name your profile you wish to save."
        echo "Syntax: ;bigshot profile save <NAME Here, no Spaces!>"
      end
    end
  end
end

if( script.vars[1].nil? || script.vars[1] =~ /solo|(bounty)|quick/i )
  bounty_mode = $1
  if script.vars[1] =~ /quick/i
    $bigshot_quick = true
  end

  bs = Bigshot.new(bounty_mode)
  bs.croak('Requires Lich V4') unless defined?(Gtk.queue) || defined?($bigshot_headless)
  bs.croak('Requires a mapped room.') if(( Room.current.id.nil? || Room.current.id == 4 ) && !$bigshot_quick)
  bs.lead()

elsif( script.vars[1] =~ /setup/i )
  Bigshot.setup()

elsif( script.vars[1] =~ /profile/i )
  Bigshot.profile(script.vars)

elsif( script.vars[1] =~ /display/i )
  echo "Version: #{BIGSHOT_VERSION}"
  UserVars.op.each_pair { |k, v|
    echo "#{k}: #{v}" unless v.nil? || v.class.to_s == 'Array' || v =~ /^\s*$/
  }
  echo "Targetable Character Setting: #{CharSettings['targetable'].map{|c| c.downcase}.sort{|a,b| a.split(" ").last <=> b.split(" ").last}}"
  echo "Untargetable Character Setting: #{CharSettings['untargetable'].map{|c| c.downcase}.sort{|a,b| a.split(" ").last <=> b.split(" ").last}}"

elsif( script.vars[1] =~ /reset/i )
  CharSettings['targetable'] = nil
  CharSettings['untargetable'] = nil
  echo "Character Settings for Targetable and Untargetable are now reset"

elsif( script.vars[1] =~ /ranger|companion/i )
  $companion = nil
  echo "Ranger Companion reset"

elsif( script.vars[1] =~ /head|lead/i )
  # launch DRb server
  DRb.start_service( nil, Group.new )
  uri = DRb.uri

  Thread.new { DRb.thread.join }

  # launch DRb client
  DRb.start_service()
  bs = Bigshot.new()

  # set leader
  my_group = DRbObject.new( nil, uri )
  my_group.set_leader(bs)

  # announce/go
  (1..RALLY_TIME).each { |i| fput "whisper ooc group Bigshot rallying at #{uri}"; sleep(1); }
  echo "Waiting for members to join Bigshot rally..."
  wait_until{(my_group.size() > 0)}
  pause 3
  bs.lead(my_group)

elsif( script.vars[1] =~ /tail|follow/i )
  # Watch for rally
  group = nil
  bs = nil
  while( group.nil? && bs.nil? )
    echo "waiting for rally" if $bigshot_debug
    if( get =~ /rallying at (.*)\."$/ )

      # create group
      DRb.start_service()
      group = DRbObject.new( nil, $1 )

      # create Bigshot
      bs = Bigshot.new()
      group.add_member(bs)
      bs.keep_awake()
      bs.CompanionCheck()
      bs.NPCRoomCheck()
    end
  end

  # Participate
  bs.message("Joined group")
  leader = group.leader.name
  $bigshot_overkill_counter = 0

  bs.groupcheck() if !checkpcs.nil?
  echo "Groupcheck done" if $bigshot_debug

  while(!dead?)
    begin
      bs.change_stance('defensive')
      bs.stand() if !standing?
      sleep(0.25)

      # grab event
      event = bs.event_stack.size == 0 ? nil : bs.grab_event
      next if event.nil?

      # kertwang!
      if ( event.type != :STAY_QUIET )
        until( checkpcs.include?(leader) )
          start_script( 'go2', [ group.room_id, '_disable_confirm_' ] )
          wait_while { running?('go2') }
          fput "join #{leader}"
          sleep(1)
        end
      end

      # process event
      bs.message("event: " + event.type.to_s) unless event.type == :FOLLOWER_OVERKILL
      if( event.type == :HUNTING_PREP_COMMANDS )
        bs.HUNTING_PREP_COMMANDS.each { |i|
          if i =~ /^script\s+(.*?)(\s|$)(.*)/i
            bs.cmd_run_script( $1, $3 )
          else
            fput(i)
          end
        }
      
      elsif( event.type == :STAY_QUIET )
        #If they got left somewhere besides the resting room, put them in a known (and hopefully safe) location
        if (Room.current.id != group.resting_id)
          bs.goto(group.resting_id)
          wait_while { running?('go2') }
        end
        bs.message("Waiting for Bigshot leader to finish running resting scripts")
        loop do
          sleep( REST_INTERVAL )
          break if checkpcs.include?(leader)   
        end
        fput "join #{leader}"

      elsif( event.type == :FOLLOWER_OVERKILL )
        bs.use_lte_boost()

      elsif( event.type == :CAST_SIGNS )
        bs.cast_signs()

      elsif( event.type == :HUNTING_SCRIPTS_START )
        bs.run_scripts( bs.HUNTING_SCRIPTS, false )

      elsif( event.type == :ATTACK )
        if( event.stale? ) # consider timestamp and room_id
          bs.message("skipping attack because it's stale")
          next
        end

        target = nil
        while( target = bs.find_target(target) )
          break if event.type == :PREP_REST

          target = bs.find_target(nil) if @PRIORITY && !bs.priority(target)
          bs.attack(target)
          
          until( checkpcs.include?(leader) )
            start_script( 'go2', [ group.room_id, '_disable_confirm_' ] )
            wait_while { running?('go2') }
            fput "join #{leader}"
            sleep(1)
          end

          break if bs.should_rest?
        end

      elsif( event.type == :HUNTING_SCRIPTS_STOP )
        bs.croak_scripts(bs.HUNTING_SCRIPTS)

      elsif( event.type == :RESTING_PREP_COMMANDS )
        $bigshot_should_rest = nil # need to reset this
        $bigshot_overkill_counter = 0
        bs.RESTING_COMMANDS.each { |i| fput(i) }

      elsif( event.type == :RESTING_SCRIPTS_START )
        bs.run_scripts( bs.RESTING_SCRIPTS, true )

      elsif( event.type == :DISPLAY_WATCH )
        if( event.stale? )
          bs.message("skipping display_watch because it's stale")
          next
        end
        fput 'exp'
        bs.message( "Bigshot last rested because: #{$rest_reason}" ) if $rest_reason
        bs.message( "Bigshot isn't hunting because: #{$not_hunting_reason}" ) if $not_hunting_reason
        sleep( REST_INTERVAL / 10 )
      end

    rescue
      fput 'leave group'
      if( bs.RESTING_ROOM_ID && bs.RESTING_ROOM_ID != 4 )
        start_script( 'go2', [ bs.RESTING_ROOM_ID, '_disable_confirm_' ] )
        wait_while { running?('go2') }
      end
      echo "Fatal exception!"
      echo $!.to_s
      echo $!.backtrace.join("\n")
      Script.self.kill
    end
  end
end
