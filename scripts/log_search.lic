=begin
  log_search.lic

  *** use log.lic to log. ;autostart add --global log --timestamp=\"%T\" --rnum ***

  Parse your logs to get search statistics for Gemstones, Dust, Idols, Klocks, Legendary and Feeder items.
  Creates two files in your Lich5/data/GSIV/CharName/ folder:
    searcharraylog.yaml      - log of every line it matched that can be used to verify results
    SearchDataFromLogs.yaml  - contains the count data

  ;log_search <folder> <options>
  ;log_search C:/Gemstone/Lich5/logs/GSIV-Nisugi/2024/08/ <options>

  options being:
    --reset           clears data in memory before run
    --no-timestamps   logs don't have timestamps at beginning of line
    --quest-complete  needed if your sybil kill to infuse is not in your logs.
    --txt             if you have wrayth/wizfe log files that end in .txt

        author: Nisugi
          game: Gemstone
          tags: hunting, combat, tracking, gemstones, jewels, dust, klocks, data
       version: 1.0

  Change Log:
  v1.0 (2025-03-23)
    - release
=end

module LogSearch
  ['yaml', 'terminal-table', 'time', 'tzinfo'].each(&method(:require))

  game_dir = File.join(DATA_DIR, XMLData.game)
  char_dir = File.join(game_dir, Char.name)
  @filename  = File.join(char_dir, "SearchDataFromLogs.yaml")
  @filename2 = File.join(char_dir, "searcharraylog.yaml")
  file_location = nil

  if Script.current.vars[0].nil?
    respond("You need to specify folder of the log you wish to parse such as:")
    respond(" ;log_search <directory> <options>")
    respond(" ;log_search C:/Users/xxxx/Desktop/Lich5/logs/GSIV-Nisugi/2024/08/")
    respond(" ;log_search C:/Users/xxxx/Desktop/Lich5/logs/GSIV-Nisugi/2024/08/ --reset --no-timestamps")
    exit
  else
    file_location = Script.current.vars[1].gsub('\\', '/') + '/*.log'
    file_location = Script.current.vars[1].gsub('\\','/') + '/*.txt' if Script.current.vars[0].include?('--txt')
  end
  exit if file_location.nil?

  if File.exist?(@filename)
    @scrape_data = YAML.load_file(@filename)
  end
  @scrape_data = {} if Script.current.vars[0] =~ /--reset/

  @scrape_data                              ||= {}
  @scrape_data[:silent]                     ||= true
  @scrape_data[:last_week_reset]            ||= nil
  @scrape_data[:creature]                   ||= "none"
  @scrape_data[:room]                       ||= nil
  @scrape_data[:uid]                        ||= nil
  @scrape_data[:total_searches]             ||= 0
  @scrape_data[:ascension_searches]         ||= 0
  @scrape_data[:weekly_ascension_searches]  ||= 0
  @scrape_data[:mutant_searches]            ||= 0
  @scrape_data[:searches_since_jewel]       ||= 0
  @scrape_data[:searches_since_dust]        ||= 0
  @scrape_data[:searches_since_idol]        ||= 0
  @scrape_data[:searches_since_lock_key]    ||= 0
  @scrape_data[:searches_since_feeder]      ||= 0
  @scrape_data[:searches_since_legendary]   ||= 0
  @scrape_data[:jewel_found]                ||= {}
  @scrape_data[:dust_found]                 ||= {}
  @scrape_data[:idol_found]                 ||= {}
  @scrape_data[:lock_key_found]             ||= {}
  @scrape_data[:feeder_found]               ||= {}
  @scrape_data[:legendary_found]            ||= {}
  @scrape_data[:quest_complete]             ||= false
  @has_timestamps                           = true
  @base_date                                = nil
  @next_reset                               = nil
  @default_tz                               = Time.now.zone

  @has_timestamps = false if Script.current.vars[0] =~ /--no-timestamps?/
  @scrape_data[:quest_complete] = true if Script.current.vars[0] =~ /--quest-complete/

  # SEARCH_CREATURE = %r{(?<timestamp>(?:\d{4}-\d{2}-\d{2}\s+)?\d{2}:\d{2}:\d{2}(?:\s+[-A-Za-z ]+)?): You search the (?<creature>[^<]+?)\.$}
  # EVIL_EYE_FLEE = %r{^(?<timestamp>(?:\d{4}-\d{2}-\d{2}\s+)?\d{2}:\d{2}:\d{2}(?:\s+[-A-Za-z ]+)?): The <pushBold/><a exist="\d+" noun="[^"]+">(?<creature>[^<]+)</a><popBold/> turns and runs screaming into the distance, never to be seen again.}
  SEARCH_CREATURE = %r{(?<timestamp>(?:\d{4}-\d{2}-\d{2}\s+)?\d{2}:\d{2}:\d{2}(?:\s+[-A-Za-z ]+)?)?:?\s*You search the (?:<.+?>)?(?<creature>[A-Za-z ]+)(?:<.+?>)?\.$}
  EVIL_EYE_FLEE   = %r{(?<timestamp>(?:\d{4}-\d{2}-\d{2}\s+)?\d{2}:\d{2}:\d{2}(?:\s+[-A-Za-z ]+)?)?:?\s*The (?:<.+?>)?(?<creature>[A-Za-z ]+)(?:<.+?>)? turns and runs screaming into the distance, never to be seen again.$}
  # ROOM_REGEX = %r{((?:\d{4}-\d{2}-\d{2}\s+)?\d{2}:\d{2}:\d{2}(?:\s+[A-Za-z ]+)?)?:?[\s]*\[[^\]]*-\s*(?<room>\d+)\](?:\s+\((?<uid>u\d+)\))?}
  ROOM_REGEX      = %r{\[[^\]]*-\s*(?<room>\d+)\](?:\s+\((?<uid>u\d+)\))?$}
  FEEDER_ITEM     = %r{\*\*\* A glint of light draws your attention to your latest find! \*\*\*$}
  LEGENDARY_ITEM  = %r{A prismatic display of color tints the air around you and arcs away, heralding your discovery of a legendary treasure!$}
  LOCK_KEY        = %r{A (?<name>.+?) appears on the ground!$}
  GEMSTONE_DUST   = %r{You notice a scintillating mote of gemstone dust on the ground and gather it quickly.$}
  GEMSTONE_JEWEL  = %r{\*\* A glint of light catches your eye, and you notice an? (?<name>.+?) at your feet! \*\*$}
  DRACONIC_IDOL   = %r{While rifling through the mutant's belongings, you find a silver-veined black draconic idol wrapped carefully in rags as if it were a precious trinket.$}
  ASCENSION_CREATURES = Regexp.union(
    %r{armored battle mastodon},
    %r{black valravn},
    %r{boreal undansormr},
    %r{crimson angargeist},
    %r{fork-tongued wendigo},
    %r{giant warg},
    %r{gigas berserker},
    %r{gigas disciple},
    %r{gigas shield-maiden},
    %r{gigas skald},
    %r{gold-bristled hinterboar},
    %r{gorefrost golem},
    %r{halfling bloodspeaker},
    %r{halfling cannibal},
    %r{reptilian mutant},
    %r{sanguine ooze},
    %r{shadow-cloaked draugr},
    %r{winged disir},
    %r{basalt grotesque},
    %r{death knight},
    %r{mist-wreathed banshee},
    %r{patrician vampire},
    %r{phantasmic conjurer},
    %r{skeletal dreadsteed},
    %r{tatterdemalion ghast},
    %r{hive thrall},
    %r{kiramon broodtender},
    %r{kiramon myrmidon},
    %r{kiramon stalker},
    %r{kiramon strandweaver},
    %r{kresh ravager}
  )

  def self.extract_base_date(filename)
    if filename =~ /^(\d{4}-\d{2}-\d{2})_/
      return $1
    else
      nil
    end
  end

  # Convert a timestamp from the log file into a Unix timestamp.
  # If the timestamp does not include a date, base_date (extracted from the filename) is used.
  # If no timezone is provided in the timestamp, default_tz is used.
  def self.convert_to_timestamp(log_time, file_date = nil)
    log_time = log_time.chomp(":").strip

    # Regex for timestamp with an optional full date and timezone
    if log_time =~ /^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})(?:\s+(.+))?$/
      date_str = $1
      time_str = $2
      tz_str   = $3
      tz_str = @default_tz if tz_str.nil? || tz_str.empty?
      if tz_str
        time_obj = Time.strptime("#{date_str} #{time_str} #{tz_str}", "%Y-%m-%d %H:%M:%S %Z")
      else
        time_obj = Time.strptime("#{date_str} #{time_str}", "%Y-%m-%d %H:%M:%S")
      end

    # Regex for timestamp with only time (no date)
    elsif log_time =~ /^(\d{2}:\d{2}:\d{2})(?:\s+(.+))?$/
      raise ArgumentError, "A base date is required if the timestamp doesn't include a date" if file_date.nil?
      time_str = $1
      tz_str   = $2
      tz_str = @default_tz if tz_str.nil? || tz_str.empty?
      if tz_str
        time_obj = Time.strptime("#{file_date} #{time_str} #{tz_str}", "%Y-%m-%d %H:%M:%S %Z")
      else
        time_obj = Time.strptime("#{file_date} #{time_str}", "%Y-%m-%d %H:%M:%S")
      end
    else
      raise ArgumentError, "Unrecognized timestamp format: #{log_time}"
    end

    time_obj.to_i
  end

  def self.initialize_next_reset(current_log_timestamp)
    eastern = TZInfo::Timezone.get('America/New_York')
    current_time_est = eastern.to_local(Time.at(current_log_timestamp))
  
    # Calculate the next Saturday.
    # In Ruby, Sunday is 0, so Saturday is 6.
    days_until_saturday = (6 - current_time_est.wday) % 7
    candidate_saturday = current_time_est.to_date + days_until_saturday
    
    # Build the desired reset time: Saturday at 23:01:01 local time.
    desired_reset = eastern.local_time(candidate_saturday.year, candidate_saturday.month, candidate_saturday.day, 23, 1, 1)
    
    # If current time is already past this Saturday reset, choose the Saturday of the following week.
    if current_time_est >= desired_reset
      candidate_saturday += 7
      desired_reset = eastern.local_time(candidate_saturday.year, candidate_saturday.month, candidate_saturday.day, 23, 1, 1)
    end
    
    reset_time = desired_reset.to_i
    respond("DEBUG: initialize_next_reset: current_log_timestamp=#{Time.at(current_time_est)}, computed reset_time=#{Time.at(desired_reset)}")
    reset_time
  end

  def self.maybe_reset_weekly_counter(current_log_timestamp)
    eastern = TZInfo::Timezone.get("America/New_York")
    @scrape_data[:weekly_counts] ||= {}

    if @next_reset.nil?
      @next_reset = initialize_next_reset(current_log_timestamp)
      respond("DEBUG: @next_reset initialized to #{Time.at(@next_reset)}")
    end
 
    while current_log_timestamp >= @next_reset
      # Compute finished week from the reset boundary (next_reset - 7 days),
      # then add 1 to correct the week number.
      finished_week = eastern.to_local(Time.at(@next_reset + 3600)).strftime("%U").to_i - 1
      respond("DEBUG: Resetting weekly counter at boundary #{Time.at(@next_reset)} for finished week #{Time.at(finished_week)}.")

      @scrape_data[:weekly_counts][:"week_#{finished_week}_ascension_searches"] = @scrape_data[:weekly_ascension_searches]
      @scrape_data[:weekly_ascension_searches] = 0
      @scrape_data[:last_week_reset] = @next_reset
      @next_reset += 7 * 86400
      respond("DEBUG: New reset boundary set to #{Time.at(@next_reset)}")
    end
  end

  $search_array_log = []
  respond("Parsing files.")

  Dir.glob(file_location).each do |file|

    file_date = File.basename(file).gsub(/_.+\.log/, "") if @has_timestamps
    buffer = File.readlines(file).map(&:chomp)
    respond("Parsing #{file}") if @debug

    buffer.each do |line|
      case line
      when %r{The fallen sybil's power lingers in the area, ready for the claiming.  Quickly, take your gemstone and INFUSE it while you still can!}
        @scrape_data[:quest_complete] = true

      when ROOM_REGEX
        # Capture the room number from the named capture 'room'
        if Regexp.last_match[:room]
          @scrape_data[:room] = Regexp.last_match[:room]
        end

        # Optionally, capture the user ID if it exists
        if Regexp.last_match[:uid]
          @scrape_data[:uid] = Regexp.last_match[:uid]
        end

      when GEMSTONE_JEWEL
        if @scrape_data[:quest_complete] && ASCENSION_CREATURES.match?(@scrape_data[:creature])
          name = Regexp.last_match[:name]
          key = @scrape_data[:timestamp].to_s if @has_timestamps
          key = @scrape_data[:ascension_searches].to_s if !@has_timestamps
          week = @scrape_data[:weekly_ascension_searches].to_s
          @scrape_data[:jewel_found][key] = { searches_since: @scrape_data[:searches_since_jewel], searches_week: week, name: name, room: @scrape_data[:room], creature: @scrape_data[:creature] }
          respond("jewel added: #{name} -searches_last: #{@scrape_data[:searches_since_jewel]} -searches_week: #{@scrape_data[:weekly_ascension_searches]} -room: #{@scrape_data[:room]} -creature: #{@scrape_data[:creature]}")
          @scrape_data[:searches_since_jewel] = 0
          $search_array_log.append(line)
        end

      when GEMSTONE_DUST
        if @scrape_data[:quest_complete] && ASCENSION_CREATURES.match?(@scrape_data[:creature])
          key = @scrape_data[:timestamp].to_s if @has_timestamps
          key = @scrape_data[:ascension_searches].to_s if !@has_timestamps
          @scrape_data[:dust_found][key] = { searches: @scrape_data[:searches_since_dust], name: "gemstone dust", room: @scrape_data[:room], creature: @scrape_data[:creature] }
          respond("dust added: -searches: #{@scrape_data[:searches_since_dust]} -room: #{@scrape_data[:room]} -creature: #{@scrape_data[:creature]}")
          @scrape_data[:searches_since_dust] = 0
          $search_array_log.append(line)
        end

      when DRACONIC_IDOL
        key = @scrape_data[:timestamp].to_s if @has_timestamps
        key = @scrape_data[:ascension_searches].to_s if !@has_timestamps
        @scrape_data[:idol_found][key] = { searches: @scrape_data[:searches_since_idol], name: "silver-veined black draconic idol", room: @scrape_data[:room], creature: @scrape_data[:creature] }
        respond("idol added: -searches: #{@scrape_data[:searches_since_idol]} -room: #{@scrape_data[:room]} -creature: #{@scrape_data[:creature]}")
        @scrape_data[:searches_since_idol] = 0
        @search_array_log.append(line)

      when LOCK_KEY
        name = Regexp.last_match[:name]
        key = @scrape_data[:timestamp].to_s if @has_timestamps
        key = @scrape_data[:total_searches].to_s if !@has_timestamps
        @scrape_data[:key_found][key] = { searches: @scrape_data[:searches_since_lock_key], name: name, room: @scrap_data[:room], creature: @scrape_data[:creature] }
        respond("lockandkey added: #{name} -searches: #{@scrape_data[:searches_since_lock_key]} -room: #{@scrape_data[:room]} -creature: #{@scrape_data[:creature]}")
        @scrape_data[:searches_since_key] = 0
        $search_array_log.append(line)

      when LEGENDARY_ITEM
        key = @scrape_data[:timestamp].to_s if @has_timestamps
        key = @scrape_data[:total_searches].to_s if !@has_timestamps
        @scrape_data[:legendary_found][key] = { searches: @scrape_data[:searches_since_legendary], name: "n/a", room: @scrap_data[:room], creature: @scrape_data[:creature] }
        respond("legendary added: -searches: #{@scrape_data[:searches_since_legendary]} -room: #{@scrape_data[:room]} -creature: #{@scrape_data[:creature]}")
        @scrape_data[:searches_since_legendary] = 0
        $search_array_log.append(line)

      when FEEDER_ITEM
        key = @scrape_data[:timestamp].to_s if @has_timestamps
        key = @scrape_data[:total_searches].to_s if !@has_timestamps
        @scrape_data[:feeder_found][key] = { searches: @scrape_data[:searches_since_feeder], name: "n/a", room: @scrap_data[:room], creature: @scrape_data[:creature] }
        respond("feeder added: -searches: #{@scrape_data[:searches_since_feeder]} -room: #{@scrape_data[:room]} -creature: #{@scrape_data[:creature]}")
        @scrape_data[:searches_since_feeder] = 0
        $search_array_log.append(line)

      when SEARCH_CREATURE, EVIL_EYE_FLEE
        name = Regexp.last_match[:creature]
        @scrape_data[:creature] = name
        log_time = Regexp.last_match[:timestamp] if @has_timestamps
        @scrape_data[:timestamp] = convert_to_timestamp(log_time, file_date) if @has_timestamps
        maybe_reset_weekly_counter(@scrape_data[:timestamp]) if @has_timestamps
        if ASCENSION_CREATURES.match?(name) && @scrape_data[:quest_complete]
          @scrape_data[:ascension_searches] += 1
          @scrape_data[:weekly_ascension_searches] += 1
          @scrape_data[:searches_since_jewel] += 1
          @scrape_data[:searches_since_dust] += 1
        end
        @scrape_data[:total_searches] += 1
        @scrape_data[:searches_since_lock_key] += 1
        @scrape_data[:searches_since_feeder] += 1
        @scrape_data[:searches_since_legendary] += 1
        if name =~ /mutant/
          @scrape_data[:searches_since_idol] += 1
          @scrape_data[:mutant_searches] += 1
        end
        $search_array_log.append(line)
      end
    end
  end
  File.write(@filename2, $search_array_log.to_yaml)
  # save data to file
  File.write(@filename, @scrape_data.to_yaml)
  respond("Parsing complete. Search data saved to file. #{@filename}")
end
