=begin
  purify gems

  ;puritan --help is useful

  Required: Lich 4.3.12
  Author: Ondreian
  Tags: util, gems, 1004, purify
  
=end
require 'benchmark'
require 'ostruct'
load "./scripts/hunting.rb" if Script.exists?("hunting.rb") and not Script.current.vars.include?("--help")

unless (Char.respond_to?(:total_wound_severity) and Char.respond_to?(:only_minor_wounds?)) and not Script.current.vars.include?("--polyfill")
  ##
  ## polyfill total wound severity check
  ##
  class Char
    INJURIES = Wounds.singleton_methods
      .map(&:to_s)
      .select do |m| m.downcase == m && m !~ /_/ end.map(&:to_sym)

    def Char.total_wound_severity()
      INJURIES
        .reduce(0) do |sum, method| sum + Wounds.send(method) end
    end

    def Char.only_minor_wounds?
      (INJURIES.find do |injury| Wounds.send(injury) > 1 end or 
      INJURIES.find do |injury| Scars.send(injury) > 1 end).nil?
    end
  end
end

module Puritan
  ##
  ## contextual logging
  ##
  module Log
    def self.bold(msg)
      _respond "<pushBold/>#{msg}<popBold/>"
    end
    
    def self.out(msg, label: :debug)
      #return unless Opts.debug

      if msg.is_a?(Exception)
        msg = %{
          #{msg.message}
          #{msg.backtrace.join("\n")}
        }
      end

      bold _view(msg, label)
    end

    def self._view(msg, label)
      label = [Script.current.name, label].flatten.compact.join(".")
      %{[#{label}] #{msg}}
    end

    def self.pp(msg, label = :debug)
      respond _view(msg, label)
    end

    def self.dump(*args)
      pp *args
    end
  end
end

module Puritan
  ##
  ## minimal options parser
  ##
  module Opts
    FLAG_PREFIX    = "--"
    
    def self.parse_command(h, c)
      h[c.to_sym] = true
    end

    def self.parse_flag(h, f)
      (name, val) = f[2..-1].split("=")
      if val.nil?
        h[name.to_sym] = true
      else
        val = val.split(",")

        h[name.to_sym] = val.size == 1 ? val.first : val
      end
    end

    def self.parse(args = Script.current.vars[1..-1])        
      OpenStruct.new(**args.to_a.reduce(Hash.new) do |opts, v|
        if v.start_with?(FLAG_PREFIX)
          Opts.parse_flag(opts, v)
        else
          Opts.parse_command(opts, v)
        end
        opts
      end)
    end

    def self.method_missing(method, *args)
      parse.send(method, *args)
    end
  end
end
##
## all singing outcomes
##
module Puritan
  module Outcomes
    ALL       = /what were you|cannot|must be holding|shatter|song misfires/i
    MAX       = /cannot be/
    SHATTERED = /shatter/
    STRAIN    = /you hear it crack loudly and strain/
    PURE      = /begins to twist and turn as the very essence flows into it filling the imperfections/
    IMPROVED  = /more perfect|what were you|improves somewhat|crack|shatter|cannot be|must be holding|smoother and more pure in color/
  end
end

module Puritan
  module Filter
    def self.is_gem()
      return -> item { item.type.include?("gem") }
    end
  end
end

module Puritan
  VERSION = "1.0.1"
  module Help
    MENU = <<-HELP
      \n
      ;puritan@#{Puritan::VERSION}

      options:

      --sung="crystal and gem sack"     where to put your sung gems
      --raw="blue satin backpack"       where to find your raw gems
      --skip_armor                      don't remove & rewear armor
      --silent                          skip sitrep reports
      \n
    HELP

    if Opts.help
      _respond MENU
      exit
    end
  end
end

module Puritan
  BLACKLIST = [
    %(star ruby)
  ]

  def self.find_container(param)
    GameObj.inv.find do |container|
      container.name =~ %r[#{param}]
    end or fail "could not find Container[name: #{param}]"
  end

  def self.container(param)
    container = find_container(param)
    fput "look in ##{container.id}" if container.contents.nil?
    return container
  end

  @sung_gems      = Opts.sung ? Puritan.container(Opts.sung) : fail("--sung= is required")
  @raw_gems       = Opts.raw ? Puritan.container(Opts.raw) : fail("--raw= is required")
  @start_time     = Time.now
  @starting_armor = GameObj.inv.select do |i| i.type.include?("armor") end
  @times          = []

  def self.uptime()
    Time.now - @start_time
  end

  def self.raw_gems()
    @raw_gems.contents.select(&Filter.is_gem).reject do |gem| BLACKLIST.include?(gem.name) end
  end

  def self.sung_gems()
    @sung_gems.contents.select(&Filter.is_gem)
  end

  @presung_count = sung_gems.size

  def self.try_or_fail(seconds: 5, command: nil)
    fput(command)
    expiry = Time.now + seconds
    wait_until do yield or Time.now > expiry end
    fail "Error[command: #{command}, seconds: #{seconds}]" if Time.now > expiry
  end
  
  def self.before_each_round()
    if defined?(Hunting)
      Hunting::Team.request_healing() if Char.total_wound_severity > 0
      Hunting::Team.request_mana()    if percentmana < 60
    end
    
    wait_while("waiting on stun")     do stunned? end
    wait_while("waiting on mana")     do checkmana < 20 end
    wait_until("waiting for healing") do Char.only_minor_wounds? end
  end

  def self.hold(gem)
    return if GameObj.right_hand.id.eql?(gem.id)
    try_or_fail(command: "_drag ##{gem.id} right") do 
      GameObj.right_hand.id.eql?(gem.id) 
    end
  end

  def self.outcome_of_1004(gem)
    waitcastrt?
    waitrt?
    Spell.lock_cast()
    multifput("prep 1004","sing ##{gem.id}")
    result = matchwait(
      "turn as the very essence",
      "gem becomes more perfect",
      "shatter",
      "crack",
      "must be holding",
      "what were you",
      "appearing smoother and more pure", 
      "improves somewhat",
      "cannot be", 
      "Sing Roundtime",
      "Wait",
      'Spell Hindrance',
      "song misfires")
    Spell.unlock_cast()
    return result
  end

  def self.sitrep(runtime)
    return if Opts.silent
    @times << runtime
    average = @times.reduce(&:+) / @times.size
    stats = <<-MESSAGE
    \n
               <b> raw: #{raw_gems.size}</b>
               <b>sung: #{sung_gems.size - @presung_count}</b>
               <b>last: #{runtime.floor}s</b>
               <b> avg: #{average.floor}s</b>
      <b>est remaining: #{(average * raw_gems.size / 60).as_time}</b>
             <b>uptime: #{(Puritan.uptime()/60).as_time}</b>
    \n
    MESSAGE
    Log.out(stats, label: %i[stats])
  end

  def self.purify_gem(gem, round: 0)
    return Puritan.add_to_sung_bag(GameObj.right_hand) if Opts.max_rounds and round.eql?(Opts.max_rounds.to_i)

    fmap(:before_each_round, 
      [:hold, gem])
    case outcome_of_1004(gem)
    when Outcomes::MAX, Outcomes::STRAIN, Outcomes::PURE
      return Puritan.add_to_sung_bag(GameObj.right_hand)
    when Outcomes::SHATTERED
      return [:err, :healing]
    else
      purify_gem(GameObj.right_hand, round: round + 1)
    end
  end

  def self.add_to_sung_bag(gem)
    try_or_fail(command: "_drag ##{gem.id} ##{@sung_gems.id}") do 
      [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.empty? and
      @sung_gems.contents.to_a.map(&:id).include?(gem.id)
    end
  end

  def self.remove_armor()
    @starting_armor.each do |piece|
      try_or_fail(command: "remove ##{piece.id}") do GameObj.right_hand.id.eql?(piece.id) end
      try_or_fail(command: "stow ##{piece.id}") do GameObj.right_hand.id.nil? end
    end
  end

  def self.wear_armor()
    @starting_armor.each do |piece|
      try_or_fail(command: "get ##{piece.id}") do [GameObj.right_hand, GameObj.left_hand].map(&:id).include?(piece.id) end
      try_or_fail(command: "wear ##{piece.id}") do not [GameObj.right_hand, GameObj.left_hand].map(&:id).include?(piece.id) end
      waitrt?
    end
  end

  def self.fmap(*methods)
    methods.each do |method|
      if method.is_a?(Array)
        method, *args = method
        Puritan.send(method, *args)
      else
        Puritan.send(method)
      end
    end
    self
  end

  def self.main()
    empty_hands

    unless Opts.skip_armor or XMLData.active_spells.fetch("Song of Peace", false)
      fmap(:remove_armor)
      before_dying do fmap(:wear_armor) end
    end
  
    raw_gems.each do |gem| 
      fmap([:sitrep, 
        Benchmark.realtime do Puritan.fmap([:purify_gem, gem]) end])
    end

    fill_hands
  end

  Puritan.main()
end