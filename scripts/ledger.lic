=begin
  ledger which tracks:
    1. silvers
    2. bounty points

  todo:
    - experience
    - bloodscrip

         author: elanthia-online
   contributors: Ondreian, Tysong
           game: Gemstone
           tags: silver, bounty, ledger, bank
        version: 1.4.0
   requirements:
    - sequel gem
    - terminal-table
    - (optional) ascii_charts gem for graphical hourly charts

  Help Contribute: https://github.com/elanthia-online/scripts
  Version Control:
  Major_change.feature_addition.bugfix
    v1.4.0 - 2026-01-19
      - Add comprehensive YARD documentation
      - Add terminal-table based hourly chart as alternative
      - Add YAML-based settings persistence
      - Add CLI argument parsing with on/off support
      - Centralize settings management
      - Settings persist across script runs
      - Add optional fee tracking, use --report-fees flag
    v1.3.4 - 2023-09-18
      - Add tracking of note withdrawal (Withdrawing 2 or more notes rapidly before first note is tracked will cause notes to be missed)
    v1.3.3 - 2023-09-17
      - Fix to bounty point tracking (broken in 1.3.2)
    v1.3.2 - 2023-09-06
      - Code cleanup, no functional changes
    v1.3.1 - 2023-09-01
      - fix to prevent other peoples debts from triggering withdrawals
      - fix to prevent partial debt repayment from triggering withdrawal of entire debt
      - fix to match debts in mist harbor.
    v1.3.0 - 2023-08-01
      - fix for lootcap estimate SQL statement
      - add ability to pass year, month, character, game to Ledger::Character.estimate_loot_cap
    v1.2.0 - 2023-07-01
      - add lootcap estimator for --report-character flag
    v1.1.1 - 2023-02-23
      - fix for mono output
    v1.1.0 - 2023-02-22
      - fix reports by game code
      - add --report-character flag
    v1.0.1 - 2023-01-26
      - Force monospaced output for BANK output
      - Add safety checks for gem loading
=end
=begin
 Known issues
 -  If 2 more more rapid note withdrawals only the first will be tracked
 -  Pinefar depositing/withdrawing money can not be reliably tracked as no messaging
      Smiling greedily, Hurshal takes your silvers and says, "Heh, I'll put dese in ye 'Mule bank account right quick."
      Hurshal looks at you and says, "Hmm, looks like ye could be a'usin' me services there, lad.  I guarantee I'll get a good bit of ye silver to the 'Mule fer ye.  Ask me about me service if ye interested."
=end

# Load required gems with safety checks
gems_to_load = ["sequel", "terminal-table"]
optional_gems = ["ascii_charts"]
failed_to_load = []

gems_to_load.each do |gem|
  unless Gem::Dependency.new(gem).matching_specs.max_by(&:version).nil?
    require gem
  else
    failed_to_load.push(gem)
  end
end

unless failed_to_load.empty?
  echo "Requires Ruby gems: #{failed_to_load.join(", ")}"
  echo "Please install the above gem(s) to run ;ledger"
  exit
end

# Try to load optional gems
optional_gems.each do |gem|
  begin
    require gem unless Gem::Dependency.new(gem).matching_specs.max_by(&:version).nil?
  rescue LoadError
    # Silently continue if optional gems aren't available
  end
end

require 'yaml'

# The Ledger module provides comprehensive tracking of in-game financial transactions
# including silver, bounty points, and locksmith fees for GemStone IV.
#
# @author elanthia-online
# @since 1.0.0
module Ledger
  # Records a transaction into the ledger database
  #
  # @param amount [Integer] the amount of the transaction (positive or negative)
  # @param type [String] the type of transaction ('silver', 'bounty', or 'fee')
  # @return [void]
  # @example Record a silver deposit
  #   Ledger.record_transaction(amount: 1000, type: 'silver')
  def self.record_transaction(amount:, type:)
    Ledger::History.record_transaction(amount: amount, type: type)
  end

  # Settings management module for persistent configuration storage
  #
  # Handles loading, saving, and parsing of user preferences stored in YAML format.
  # Settings persist across script runs and can be overridden via CLI arguments.
  #
  # @since 1.5.0
  module Settings
    @settings_file = File.join(DATA_DIR, 'ledger.yaml')
    @defaults = {
      'report_character' => false,
      'report_fees'      => false
    }
    @settings = nil

    # Loads settings from YAML file or creates default settings
    #
    # @return [Hash] the loaded or default settings
    # @note Falls back to defaults if file doesn't exist or is corrupted
    def self.load_settings
      if File.exist?(@settings_file)
        begin
          loaded = YAML.load_file(@settings_file) || {}
          @settings = @defaults.merge(loaded)
        rescue => e
          echo "Warning: Failed to load settings from #{@settings_file}: #{e.message}"
          echo "Using default settings."
          @settings = @defaults.dup
        end
      else
        @settings = @defaults.dup
      end
    end

    # Saves current settings to YAML file
    #
    # @return [void]
    def self.save_settings
      begin
        File.open(@settings_file, 'w') do |file|
          file.write(YAML.dump(@settings))
        end
      rescue => e
        echo "Warning: Failed to save settings to #{@settings_file}: #{e.message}"
      end
    end

    # Parses command-line arguments and updates settings
    #
    # Supports flexible argument formats:
    # - --report-character, --report_character, -reportcharacter
    # - --report-fees, --report_fees, --report-fee
    # - With values: --report-character=on, --report-character=off
    #
    # @param args [Array<String>] array of command-line arguments
    # @return [void]
    def self.parse_cli_args(args)
      args.each do |arg|
        case arg
        when /^-?-?report[-_]?character(?:=(.+))?$/i
          value = $1
          @settings['report_character'] = parse_boolean_value(value, true)
        when /^-?-?report[-_]?fees?(?:=(.+))?$/i
          value = $1
          @settings['report_fees'] = parse_boolean_value(value, true)
        when /^-?-?help$/i
          display_help
          exit
        end
      end
      save_settings
    end

    # Parses a boolean value from string input
    #
    # @param value [String, nil] the value to parse
    # @param default_true [Boolean] the default value if input is nil or empty
    # @return [Boolean] the parsed boolean value
    # @example
    #   parse_boolean_value("on")     #=> true
    #   parse_boolean_value("false")  #=> false
    #   parse_boolean_value(nil)      #=> true (if default_true is true)
    def self.parse_boolean_value(value, default_true = true)
      return default_true if value.nil? || value.empty?

      case value.downcase
      when 'true', 'on', '1', 'yes', 'y'
        true
      when 'false', 'off', '0', 'no', 'n'
        false
      else
        echo "Warning: Invalid boolean value '#{value}', using #{default_true}"
        default_true
      end
    end

    # Displays help text with current settings and usage examples
    #
    # @return [void]
    def self.display_help
      help_text = <<~HELP
        Ledger Script - Track silver, bounty points, and fees

        Usage: ;ledger [options]

        Options:
          --report-character[=<on|off>]   Show per-character statistics        (default: #{@defaults['report_character']})
          --report-fees[=<on|off>]        Track and report locksmith pool fees (default: #{@defaults['report_fees']})
          --help                          Display this help message

        Examples:
          ;ledger --report-character                # Enable character reporting
          ;ledger --report-character=on             # Enable character reporting (explicit)
          ;ledger --report-character=off            # Disable character reporting
          ;ledger --report-fees --report-character  # Enable both options

        Settings are saved to: #{@settings_file}
        Settings persist across script runs unless overridden by CLI arguments.

        Current Settings:
          report_character: #{@settings['report_character']}
          report_fees:      #{@settings['report_fees']}
      HELP
      respond help_text
    end

    # Retrieves a setting value by key
    #
    # @param key [String] the setting key
    # @return [Object] the setting value
    def self.[](key)
      @settings[key]
    end

    # Sets a setting value by key
    #
    # @param key [String] the setting key
    # @param value [Object] the value to set
    # @return [Object] the value that was set
    def self.[]=(key, value)
      @settings[key] = value
    end

    # Checks if a setting is enabled (true)
    #
    # @param key [String] the setting key
    # @return [Boolean] true if the setting is enabled
    def self.enabled?(key)
      @settings[key] == true
    end

    # Initialize settings on module load
    load_settings
    parse_cli_args(Script.current.vars[1..-1])
  end

  # Character-specific transaction queries
  #
  # Provides methods to query transactions for the current character
  # across different time periods (hourly, daily, monthly, yearly, total).
  #
  # @since 1.0.0
  module Character
    # Gets yearly transaction sum for current character
    #
    # @param type [String] transaction type ('silver', 'bounty', 'fee')
    # @return [Integer] sum of transactions for the year
    def self.yearly(type: "silver")
      Ledger::History::Transactions
        .where(year: Time.now.year, type: type, character: Char.name, game: XMLData.game)
        .sum(:amount) || 0
    end

    # Gets monthly transaction sum for current character
    #
    # @param type [String] transaction type ('silver', 'bounty', 'fee')
    # @return [Integer] sum of transactions for the month
    def self.monthly(type: "silver")
      Ledger::History::Transactions
        .where(year: Time.now.year, month: Time.now.month, type: type, character: Char.name, game: XMLData.game)
        .sum(:amount) || 0
    end

    # Gets daily transaction sum for current character
    #
    # @param type [String] transaction type ('silver', 'bounty', 'fee')
    # @return [Integer] sum of transactions for the day
    def self.daily(type: "silver")
      Ledger::History::Transactions
        .where(year: Time.now.year, month: Time.now.month, day: Time.now.day, type: type, character: Char.name, game: XMLData.game)
        .sum(:amount) || 0
    end

    # Gets hourly transaction sum for current character
    #
    # @param type [String] transaction type ('silver', 'bounty', 'fee')
    # @return [Integer] sum of transactions for the current hour
    def self.hourly(type: "silver")
      Ledger::History::Transactions
        .where(year: Time.now.year, month: Time.now.month, day: Time.now.day, hour: Time.now.hour, type: type, character: Char.name, game: XMLData.game)
        .sum(:amount) || 0
    end

    # Gets total transaction sum for current character (all time)
    #
    # @param type [String] transaction type ('silver', 'bounty', 'fee')
    # @return [Integer] sum of all transactions
    def self.total(type: "silver")
      Ledger::History::Transactions
        .where(type: type, character: Char.name, game: XMLData.game)
        .sum(:amount) || 0
    end

    # Estimates loot cap earnings for a given month
    #
    # Calculates silver gained from creature kills (excluding large deposits/withdrawals)
    # to estimate progress toward the monthly loot cap.
    #
    # @param year [Integer] the year to query (default: current year)
    # @param month [Integer] the month to query (default: current month)
    # @param character [String] character name (default: current character)
    # @param game [String] game code (default: current game)
    # @return [Integer] estimated loot cap earnings
    # @note Filters out transactions over 1,000,000 silver (likely bank transactions)
    def self.estimate_loot_cap(year: Time.now.year, month: Time.now.month, character: Char.name, game: XMLData.game)
      Ledger::History::Transactions
        .where(year: year, month: month, type: "silver", character: character, game: game)
        .where { amount < 1_000_000 }
        .where { amount > 0 }
        .sum(:amount) || 0
    end
  end

  # Utility methods for parsing game output
  #
  # @since 1.0.0
  module Utility
    # Retrieves the value of a promissory note by reading it
    #
    # @param note_id [String, Integer] the game object ID of the note
    # @return [Integer, nil] the silver value of the note, or nil if parsing fails
    def self.get_note_value(note_id)
      line = Lich::Util::quiet_command_xml("read ##{note_id}", /has a value of (?:[\d,]+) silver and reads/, /<prompt/, false, 3).last
      if /has a value of (?<silver>[\d,]+) silver/ =~ line
        return silver.delete(',').to_i
      end
    end

    # Strips XML tags from game output lines
    #
    # Removes various XML elements including streams, components, and HTML entities
    # to get clean text for regex matching.
    #
    # @param line [String] the XML-formatted line to clean
    # @return [String] the cleaned line without XML tags
    # @note This method modifies the input string in place
    def self.strip_xml(line)
      line.gsub!(/<pushStream id=["'](?:spellfront|inv|bounty|society)["'][^>]*\/>.*?<popStream[^>]*>/m, '')
      line.gsub!(/<stream id="Spells">.*?<\/stream>/m, '')
      line.gsub!(/<(compDef|inv|component|right|left|spell|prompt)[^>]*>.*?<\/\1>/m, '')
      line.gsub!(/<[^>]+>/, '')
      line.gsub!('&gt;', '>')
      line.gsub!('&lt;', '<')
      return line
    end
  end

  # Transaction history database and tracking logic
  #
  # Manages the SQLite database, defines transaction patterns, and handles
  # the main event loop for monitoring and recording game transactions.
  #
  # @since 1.0.0
  module History
    @file = File.join(DATA_DIR, "ledger.db")
    Self = Sequel.sqlite(@file)

    # Regex patterns for matching withdrawal messages
    @withdraw_silver_regex = Regexp.union(
      /I have a (?<debt>bill) of (?<silver>[\d,]+) silvers? (?:presented by your creditors|that I suggest you pay immediately)/,
      /Very well, a withdrawal of (?<silver>[\d,]+) silver/,
      /teller scribbles the transaction into a book and hands you (?<silver>[\d,]+) silver/,
      /teller carefully records the transaction, (?:and then )?hands you (?<silver>[\d,]+) silver/,
    )

    # Regex for Teras Isle note withdrawals (fee and silver amount both available)
    @withdraw_notes_regex = /scrip for (?<silver>[\d,]+) silvers?, with a (?<fee>[\d,]+) silvers? fee for the scrip/

    # Regex for other town note withdrawals (need to read note for silver amount)
    @withdraw_notes_xml_regex = /The teller purses her lips and says, "Hmm, we will have to give you an? <a exist="(?<note_id>\d+)" noun="(?:note|chit)">(?:\w+(?:'s)? )?(?:promissory note|mining chit|salt-stained kraken chit|City-States promissory note)<\/a> for that amount\."  The teller makes some marks on a blank <a exist="(?:\d+)" noun="(?:note|chit)">(?:\w+(?:'s)? )?(?:chit|note)<\/a> and hands it to you, saying "That is a (?<fee>[\d,]+) silvers? surcharge.  Have a nice day\."/

    # Regex for locksmith pool fees
    @locksmith_pool_fee_regex = /takes your (?:box|coffer|chest|strongbox|trunk) and says, .+ (?<fee>[\d,]+) silvers? fee has been collected\./

    # Regex patterns for matching deposit messages
    @deposit_regex = Regexp.union(
      /You deposit (?<silver>[\d,]+) silvers? into your account/,
      /That's a total of (?<silver>[\d,]+) silver/,
      /That's (?<silver>[\d,]+) silver|silvers? to your account/,
      /You deposit your note worth (?<silver>[\d,]+) into your account/,
      /You hand your notes to the teller, who glances over each one and scribbles the amounts in a book.  She says, "They add up to (?<silver>[\d,]+) (?:silver|silvers)/,
    )

    # Database schema definition
    Self.create_table?(:transactions) do
      primary_key :id
      String  :character
      String  :type
      Integer :amount
      Date    :created_at
      Integer :year
      Integer :month
      Integer :day
      Integer :hour
      String  :game
    end

    # Alias for easier access to transactions table
    Transactions = Self[:transactions]

    # Placeholder for database migrations
    module Migrations
    end

    # Query methods for aggregate transaction data
    #
    # Provides methods to query transactions across all characters in the current game
    # for different time periods.
    #
    # @since 1.0.0
    module Query
      # Gets yearly transaction sum across all characters
      #
      # @param year [Integer] the year to query (default: current year)
      # @param type [String] transaction type ('silver', 'bounty', 'fee')
      # @return [Integer] sum of transactions for the year
      def self.yearly_gain_loss(year: Time.now.year, type:)
        Transactions
          .where(year: year, type: type, game: XMLData.game)
          .sum(:amount) || 0
      end

      # Gets monthly transaction sum across all characters
      #
      # @param month [Integer] the month to query (default: current month)
      # @param year [Integer] the year to query (default: current year)
      # @param type [String] transaction type ('silver', 'bounty', 'fee')
      # @return [Integer] sum of transactions for the month
      def self.monthly_gain_loss(month: Time.now.month, year: Time.now.year, type:)
        Transactions
          .where(month: month, year: year, type: type, game: XMLData.game)
          .sum(:amount) || 0
      end

      # Gets daily transaction sum across all characters
      #
      # @param day [Integer] the day to query (default: current day)
      # @param month [Integer] the month to query (default: current month)
      # @param year [Integer] the year to query (default: current year)
      # @param type [String] transaction type ('silver', 'bounty', 'fee')
      # @return [Integer] sum of transactions for the day
      def self.daily_gain_loss(day: Time.now.day, month: Time.now.month, year: Time.now.year, type:)
        Transactions
          .where(month: month, year: year, day: day, type: type, game: XMLData.game)
          .sum(:amount) || 0
      end

      # Gets hourly transaction sum across all characters
      #
      # @param hour [Integer] the hour to query (default: current hour)
      # @param day [Integer] the day to query (default: current day)
      # @param month [Integer] the month to query (default: current month)
      # @param year [Integer] the year to query (default: current year)
      # @param type [String] transaction type ('silver', 'bounty', 'fee')
      # @return [Integer] sum of transactions for the hour
      def self.hourly_gain_loss(hour: Time.now.hour, day: Time.now.day, month: Time.now.month, year: Time.now.year, type:)
        Transactions
          .where(month: month, year: year, day: day, hour: hour, type: type, game: XMLData.game)
          .sum(:amount) || 0
      end
    end

    # Returns the allowed transaction types
    #
    # @param include_fee [Boolean] whether to include 'fee' type (default: false)
    # @return [Array<String>] array of allowed transaction types
    def self.allowed_types(include_fee: false)
      if include_fee
        %w(silver bounty fee)
      else
        %w(silver bounty)
      end
    end

    # Records a transaction to the database
    #
    # @param amount [Integer] the transaction amount (positive or negative)
    # @param type [String] the transaction type ('silver', 'bounty', or 'fee')
    # @return [Integer, nil] the ID of the inserted transaction, or nil if invalid type
    def self.record_transaction(amount:, type:)
      return echo("type=%s is not an allowed resource: {%s}" % [type, allowed_types.join(',')]) unless allowed_types(include_fee: true).include?(type)

      transaction              = {}
      now                      = Time.now
      # info fields
      transaction[:character]  = Char.name
      transaction[:amount]     = amount
      transaction[:type]       = type
      transaction[:game]       = XMLData.game
      # timestamp fields
      transaction[:created_at] = now
      transaction[:year]       = now.year
      transaction[:month]      = now.month
      transaction[:day]        = now.day
      transaction[:hour]       = now.hour
      @last_transaction_id     = Transactions.insert(transaction)
    end

    # Generates an hourly activity chart using ascii_charts gem if available,
    # otherwise falls back to a terminal-table based chart
    #
    # @param type [String] transaction type to chart (default: 'silver')
    # @param from [Time] starting time for the chart (default: current time)
    # @param number [Integer] number of hours to display (default: 6)
    # @return [void]
    def self.hourly_chart(type: "silver", from: Time.now, number: 6)
      initial_hour = from.hour
      initial_day  = from.day

      hours = (0...number).to_a.map { |offset|
        position = initial_hour - offset
        # handle underflow
        hour = position < 1 ? 24 + position : position
        [hour, Query.hourly_gain_loss(type: type, hour: hour, day: initial_day)]
      }.reverse

      # Try to use ascii_charts if available
      if defined?(AsciiCharts)
        _respond AsciiCharts::Cartesian.new(hours, title: "hourly #{type}", bar: true).draw
      else
        # Fallback to terminal-table based chart
        max_value = hours.map(&:last).max
        return _respond "No #{type} activity in the past #{number} hours." if max_value.zero?

        max_bar_width = 40
        rows = hours.map do |hour, amount|
          bar_width = max_value > 0 ? (amount.to_f / max_value * max_bar_width).round : 0
          bar = 'â–“' * bar_width
          formatted_amount = with_commas(amount)

          [sprintf("%02d:00", hour), "#{bar} #{formatted_amount}"]
        end

        chart = Terminal::Table.new(
          title: "Hourly #{type.capitalize} Activity",
          headings: ['Hour', 'Amount'],
          rows: rows
        )

        _respond "<output class=\"mono\"/>\n" + chart.to_s + "\n<output class=\"\"/>"
      end
    end

    # Formats a number with comma separators
    #
    # @param str [String, Integer] the number to format
    # @return [String] the formatted number with commas
    # @example
    #   with_commas(1000)    #=> "1,000"
    #   with_commas(1234567) #=> "1,234,567"
    def self.with_commas(str)
      str.to_s.reverse
         .gsub(/(\d{3})(?=\d)/, '\\1,')
         .reverse
    end

    # Generates table data for the main transaction report
    #
    # @return [Array<Array>] array of rows for the terminal table
    # @note Each row contains [type, hourly, daily, monthly, yearly]
    def self.table
      self.allowed_types(include_fee: Settings.enabled?('report_fees')).map { |resource|
        [resource,
         with_commas(Query.hourly_gain_loss(type: resource)),
         with_commas(Query.daily_gain_loss(type: resource)),
         with_commas(Query.monthly_gain_loss(type: resource)),
         with_commas(Query.yearly_gain_loss(type: resource))]
      }
    end

    # Prints the transaction summary tables
    #
    # Displays:
    # - Main table with all-character totals by game
    # - Optional per-character table (if --report-character is enabled)
    # - Optional fee summary (if --report-fees is enabled)
    #
    # @return [void]
    def self.print()
      table = Terminal::Table.new(
        headings: [XMLData.game] + %w(hourly daily monthly yearly),
        rows: self.table
      )

      _respond "<output class=\"mono\"/>\n" + table.to_s + "\n<output class=\"\"/>"

      if Settings.enabled?('report_character')
        character_info = self.allowed_types(include_fee: Settings.enabled?('report_fees')).map { |resource|
          cols = [resource,
                  with_commas(Character.hourly(type: resource)),
                  with_commas(Character.daily(type: resource)),
                  with_commas(Character.monthly(type: resource)),
                  with_commas(Character.yearly(type: resource)),]
          if resource.eql?("silver")
            cols << with_commas(Character.estimate_loot_cap)
          else
            cols << ""
          end
          cols
        }

        character_table = Terminal::Table.new(
          headings: [Char.name] + %w(hourly daily monthly yearly ~lootcap),
          rows: character_info
        )

        _respond "<output class=\"mono\"/>\n" + character_table.to_s + "\n<output class=\"\"/>"
      end

      if Settings.enabled?('report_fees')
        _respond "\n<output class=\"mono\"/>"
        _respond "Monthly Locksmith Fees: #{with_commas(Character.monthly(type: "fee"))} silvers"
        _respond "Total Locksmith Fees: #{with_commas(Character.total(type: "fee"))} silvers"
        _respond "<output class=\"\"/>"
      end
    end

    # Main event loop that monitors game output for transactions
    #
    # Continuously reads game output and matches against transaction patterns.
    # When a match is found, records the transaction to the database.
    #
    # @return [void]
    # @note This method runs indefinitely until the script is stopped
    def self.main()
      status_tags
      while (xml_line = get)
        line = Ledger::Utility.strip_xml(xml_line.dup)
        # todo: bloodscrip tracking deposit/withdraw

        # Handle silver withdrawals (including debt collector)
        if (match = line.match(@withdraw_silver_regex))
          silver = match[:silver].delete(',').to_i
          if match[:debt]
            # 5 lines is the min, using 10 for safety. Very unlikely of a false positive
            next unless reget 10, "The local debt collector suddenly enters and walks toward you purposely."

            if /owe (?<debtsilver>[\d,]+) silver/ =~ reget(10, "The debt collector reminds you that you still owe").last
              # If you deposit but do not have enough to cover debt will take what it can,
              # without this was recording the full fine silver as withdrawn
              silver -= debtsilver.delete(',').to_i
            end
          end
          echo "recorded.withdraw : #{silver}"
          self.record_transaction(amount: -silver, type: "silver")

        # Handle deposits
        elsif (match = line.match(@deposit_regex))
          silver = match[:silver].delete(',').to_i
          echo "recorded.deposit : #{silver}"
          self.record_transaction(amount: silver, type: "silver")

        # Handle Teras Isle note withdrawals (fee visible in message)
        elsif (match = line.match(@withdraw_notes_regex))
          silver = match[:silver].delete(',').to_i
          fee = match[:fee].delete(',').to_i
          total_withdrawal = silver + fee
          echo "recorded.withdraw : #{total_withdrawal}"
          self.record_transaction(amount: -total_withdrawal, type: "silver")

        # Handle other town note withdrawals (need to read note)
        elsif (match = xml_line.match(@withdraw_notes_xml_regex))
          fee = match[:fee].delete(',').to_i
          silver = Ledger::Utility.get_note_value(match[:note_id])

          unless silver && fee
            echo "Failed to get value of withdrawn note."
            next
          end

          total_withdrawal = silver + fee
          echo "recorded.withdraw : #{total_withdrawal}"
          self.record_transaction(amount: -total_withdrawal, type: "silver")

        # Handle bounty points
        elsif /\[You have earned (?<amount>[\d,]+) bounty points/ =~ line
          self.record_transaction(amount: amount.delete(',').to_i, type: "bounty")

        # Handle locksmith pool fees
        elsif (match = line.match(@locksmith_pool_fee_regex))
          silver = match[:fee].delete(',').to_i
          echo "recorded.fee : #{silver}" if Settings.enabled?('report_fees')
          self.record_transaction(amount: silver, type: "fee")

        # Trigger report display when at bank
        elsif line =~ /inter-town bank transfer options? available/
          self.print()
        end
      end
    end

    # Start the main event loop
    self.main()
  end
end
