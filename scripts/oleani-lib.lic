require "set"
require "forwardable"

=begin

  This script provides quality of life code for multiple projects.

  Currently:
    Utilities
      CommandMonitor          - Easy Upstream command hooking
      send_formatted          - Color formatting - from foreach.lic
      Command Options Parsing - Slop
    Timers                    - Periodic task timers

  Roadmap:
    Documentation and examples

     author: elanthia-online
       game: Gemstone
       tags: library
    version: 0.0.10

   changelog:
      0.0.10:
        Fixed invalid method signature to quiet_command and anon_hook
      0.0.9:
        Scope restructure
        Added in Transit code for assisting moving around.
        Added in Command wrappers for assisting with dothistimeout
        Added in Retriable for assisting in commands that need to retry
      0.0.8 (2020-09-26):
        Pushed to Elanthia-Online
        Split Slop Command Library off
        Fixed for commas
        Moved more common use functions over
      0.0.7 (2020-08-09):
        Added helper functions for managing silver
        Added Hash except function from Rails
      0.0.6 (2020-07-07):
        Fixed issue with CommandMonitor sharing the same upstream hook.
      0.0.5 (2020-06-29):
        Set formatting to only occur on Stormfront FE (for now)
      0.0.4 (2020-06-29):
        Added number formatter
        Fixed module name
      0.0.3 (2020-06-25):
        Added Command Argument Parser (Slop)
      0.0.2 (2020-06-25):
        Minor bug fixes
      0.0.1 (2020-06-25):
        Initial Release

=end
module Oleani
  VERSION = "0.0.10"

  def self.version
    Gem::Version.new(VERSION)
  end
end

module Oleani
  module Timers
    VERSION = "4.3.0"
    class Group
      include Enumerable

      extend Forwardable
      def_delegators :@timers, :each, :empty?

      def initialize
        @events = Events.new

        @timers = Set.new
        @paused_timers = Set.new

        @interval = Interval.new
        @interval.start
      end

      # Scheduled events:
      attr_reader :events

      # Active timers:
      attr_reader :timers

      # Paused timers:
      attr_reader :paused_timers

      # Call the given block after the given interval. The first argument will be
      # the time at which the group was asked to fire timers for.
      def after(interval, &block)
        Timer.new(self, interval, false, &block)
      end

      # Call the given block immediately, and then after the given interval. The first
      # argument will be the time at which the group was asked to fire timers for.
      def now_and_after(interval, &block)
        yield
        after(interval, &block)
      end

      # Call the given block periodically at the given interval. The first
      # argument will be the time at which the group was asked to fire timers for.
      def every(interval, recur = true, &block)
        Timer.new(self, interval, recur, &block)
      end

      # Call the given block immediately, and then periodically at the given interval. The first
      # argument will be the time at which the group was asked to fire timers for.
      def now_and_every(interval, recur = true, &block)
        yield
        every(interval, recur, &block)
      end

      # Wait for the next timer and fire it. Can take a block, which should behave
      # like sleep(n), except that n may be nil (sleep forever) or a negative
      # number (fire immediately after return).
      def wait
        if block_given?
          yield wait_interval

          while (interval = wait_interval) && interval > 0
            yield interval
          end
        else
          while (interval = wait_interval) && interval > 0
            # We cannot assume that sleep will wait for the specified time, it might be +/- a bit.
            sleep interval
          end
        end

        fire
      end

      # Interval to wait until when the next timer will fire.
      # - nil: no timers
      # - -ve: timers expired already
      # -   0: timers ready to fire
      # - +ve: timers waiting to fire
      def wait_interval(offset = current_offset)
        handle = @events.first
        handle.time - Float(offset) if handle
      end

      # Fire all timers that are ready.
      def fire(offset = current_offset)
        @events.fire(offset)
      end

      # Pause all timers.
      def pause
        @timers.dup.each(&:pause)
      end

      # Resume all timers.
      def resume
        @paused_timers.dup.each(&:resume)
      end

      alias continue resume

      # Delay all timers.
      def delay(seconds)
        @timers.each do |timer|
          timer.delay(seconds)
        end
      end

      # Cancel all timers.
      def cancel
        @timers.dup.each(&:cancel)
      end

      # The group's current time.
      def current_offset
        @interval.to_f
      end
    end

    class Wait
      def self.for(duration, &block)
        if duration
          timeout = new(duration)

          timeout.while_time_remaining(&block)
        else
          loop do
            yield(nil)
          end
        end
      end

      def initialize(duration)
        @duration = duration
        @remaining = true
      end

      attr_reader :duration
      attr_reader :remaining

      # Yields while time remains for work to be done:
      def while_time_remaining
        @interval = Interval.new
        @interval.start

        yield @remaining while time_remaining?
      ensure
        @interval.stop
        @interval = nil
      end

      private

      def time_remaining?
        @remaining = (@duration - @interval.to_f)

        @remaining > 0
      end
    end

    class Events
      # Represents a cancellable handle for a specific timer event.
      class Handle
        def initialize(time, callback)
          @time = time
          @callback = callback
        end

        # The absolute time that the handle should be fired at.
        attr_reader :time

        # Cancel this timer, O(1).
        def cancel!
          # The simplest way to keep track of cancelled status is to nullify the
          # callback. This should also be optimal for garbage collection.
          @callback = nil
        end

        # Has this timer been cancelled? Cancelled timer's don't fire.
        def cancelled?
          @callback.nil?
        end

        def > other
          @time > other.to_f
        end

        def >= other
          @time >= other.to_f
        end

        def to_f
          @time
        end

        # Fire the callback if not cancelled with the given time parameter.
        def fire(time)
          @callback.call(time) if @callback
        end
      end

      def initialize
        # A sequence of handles, maintained in sorted order, future to present.
        # @sequence.last is the next event to be fired.
        @sequence = []
        @queue = []
      end

      # Add an event at the given time.
      def schedule(time, callback)
        handle = Handle.new(time.to_f, callback)

        @queue << handle

        return handle
      end

      # Returns the first non-cancelled handle.
      def first
        merge!

        while (handle = @sequence.last)
          return handle unless handle.cancelled?
          @sequence.pop
        end
      end

      # Returns the number of pending (possibly cancelled) events.
      def size
        @sequence.size + @queue.size
      end

      # Fire all handles for which Handle#time is less than the given time.
      def fire(time)
        merge!

        while handle = @sequence.last and handle.time <= time
          @sequence.pop
          handle.fire(time)
        end
      end

      private

      def merge!
        while handle = @queue.pop
          next if handle.cancelled?

          index = bisect_right(@sequence, handle)

          if current_handle = @sequence[index] and current_handle.cancelled?
            # puts "Replacing handle at index: #{index} due to cancellation in array containing #{@sequence.size} item(s)."
            @sequence[index] = handle
          else
            # puts "Inserting handle at index: #{index} in array containing #{@sequence.size} item(s)."
            @sequence.insert(index, handle)
          end
        end
      end

      # Return the right-most index where to insert item e, in a list a, assuming
      # a is sorted in descending order.
      def bisect_right(a, e, l = 0, u = a.length)
        while l < u
          m = l + (u - l).div(2)

          if a[m] >= e
            l = m + 1
          else
            u = m
          end
        end

        l
      end
    end

    class Interval
      # Get the current elapsed monotonic time.
      def initialize
        @total = 0.0
        @current = nil
      end

      def start
        return if @current

        @current = now
      end

      def stop
        return unless @current

        @total += duration

        @current = nil
      end

      def to_f
        @total + duration
      end

      protected def duration
        now - @current
      end

      protected def now
        ::Process.clock_gettime(::Process::CLOCK_MONOTONIC)
      end
    end
    class Timer
      include Comparable
      attr_reader :interval, :offset, :recurring

      def initialize(group, interval, recurring = false, offset = nil, &block)
        @group = group

        @interval = interval
        @recurring = recurring
        @block = block
        @offset = offset

        @handle = nil

        # If a start offset was supplied, use that, otherwise use the current timers offset.
        reset(@offset || @group.current_offset)
      end

      def paused?
        @group.paused_timers.include? self
      end

      def pause
        return if paused?

        @group.timers.delete self
        @group.paused_timers.add self

        @handle.cancel! if @handle
        @handle = nil
      end

      def resume
        return unless paused?

        @group.paused_timers.delete self

        # This will add us back to the group:
        reset
      end

      alias continue resume

      # Extend this timer
      def delay(seconds, max = 0)
        @handle.cancel! if @handle

        @offset += seconds

        @offset = @offset > max ? max : @offset

        @handle = @group.events.schedule(@offset, self)
      end

      # Cancel this timer. Do not call while paused.
      def cancel
        return unless @handle

        @handle.cancel! if @handle
        @handle = nil

        # This timer is no longer valid:
        @group.timers.delete self if @group
      end

      # Reset this timer. Do not call while paused.
      # @param offset [Numeric] the duration to add to the timer.
      def reset(offset = @group.current_offset)
        # This logic allows us to minimise the interaction with @group.timers.
        # A timer with a handle is always registered with the group.
        if @handle

          @handle.cancel!
        else

          @group.timers << self
        end

        @offset = Float(offset) + @interval

        @handle = @group.events.schedule(@offset, self)

      end

      # Fire the block.
      def fire(offset = @group.current_offset)
        if recurring == :strict
          # ... make the next interval strictly the last offset + the interval:
          reset(@offset)
        elsif recurring
          reset(offset)
        else
          @offset = offset
        end

        @block.call(offset, self)

        cancel unless recurring
      end

      alias call fire

      # Number of seconds until next fire / since last fire
      def fires_in
        @offset - @group.current_offset if @offset
      end

      # Inspect a timer
      def inspect
        str = "#{to_s[0..-2]} ".dup

        if @offset
          str << if fires_in >= 0
                   "fires in #{fires_in} seconds"
                 else
                   "fired #{fires_in.abs} seconds ago"
                 end

          str << ", recurs every #{interval}" if recurring
        else
          str << "dead"
        end

        str << ">"
      end
    end
  end

  module Transit

    class Travel

      def initialize(target)
        @target = target
        @previous = Room.current.id
      end

      def step_back
        way = Room.current.wayto[@previous.to_s]

        echo "Unable to step back!  No way found" if way.nil?

        Transit.step_to(way) unless way.nil?
      end

      def step_forward

        path = Room.current.path_to(@target)

        next_path = path.first
        way = Room.current.wayto[next_path.to_s]

        Transit.step_to(way)
      end

      def go
        Script.run('go2', @target.to_s)
      end

    end

    def self.get_boundry_list(location)
      Room.list.find_all {|r| r.location =~ /#{location}/i}.collect {|r| r.id}
    end

    def self.return_after(&block)
      starting_room = Room.current.id

      begin
        block.call
      ensure
        to(starting_room).go
      end
    end


    def self.set_groupmove(flag)
      fput "flag GroupMovement #{flag}"
    end

    def self.to_location(target)
      boundry = Room.list.find_all {|r| r.location =~ /#{target}/i}.collect {|r| r.id}
      room_id = Room.current.find_nearest(boundry)
      Travel.new(room_id)
    end

    def self.to(target)
      Travel.new(target)
    end

    def self.step_to(location, whiny = false)
      current_room = Room.current.id

      begin
        Timeout::timeout(4, Interrupt) {
          if location.class == String
            move(location)
          else
            location.call
          end

          raise FailedToMove if whiny && current_room == Room.current.id

          true
        }
      rescue
        raise if whiny

        false
      end
    end
  end

  class ItemMatcher
    attr_accessor :first, :after, :unique, :sorted, :reversed, :item_filter
    attr_reader :total_items, :status_filter
    attr_reader :container_names, :container_contents

    HELP_URL = "https://github.com/dewiniaid/gs4-lich-scripts/blob/master/Foreach.md"
    UNREGISTERED = 1 << 0
    REGISTERED = 1 << 1
    UNMARKED = 1 << 2
    MARKED = 1 << 3

    INVFULL_PATTERN = /^( {2,})([^<]*)<a exist="(-?\d+)" noun="([^"]*)">([^<]*)<\/a>(?: ([^(]*)(?:$|(?= \()))?(?: (\(.*\)))?$/
    # Matches: 1 = leading space, 2 = prename, 3 = id, 4 = noun, 5 = name, 6 = postname, 7 = registered/marked attributes
    # You are carrying nothing at this time.  -- no inventory

    # INV_PATTERN = /(?:(?:Peering into|[IO]n) .* <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>,? you see )|(?:[OI]n the <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>:\s*$)|(There is nothing [io]n the|That is closed.|I could not find what you were referring to\.)/
    INV_PATTERN = /(?:(?:Peering into|In|On|Under|Behind) .* <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>,? you see )|(?:[OI]n the <a exist="(-?\d+)"[^>]*>([^<]*)<\/a>:\s*$)|(There is nothing (?:in|on|under|behind) the|That is closed.|I could not find what you were referring to\.)|^You see <a.*?<\/a>\.\s+Looking at the <a.*?<\/a>, you see (.*)\.\s*$/
    LOCKER_PATTERNS = {
        :start => /^(?:(Looking in front of you, you see)|Thinking back, you recall) the contents of your locker/,
        :end => /^Obvious items:|^There are no items in this locker./,
        :container => /^<pushBold\/>[IO]n .* <a .* noun="(.*)">/,
        :item => /^(?:<popBold\/>)? {6}(?! )([^<]*)<a exist="(-?\d+)" noun="([^"]*)">([^<]*)<\/a>(?: ([^(]*)(?:$|(?= \()))?(?: (\(.*\)))?$/,
        :town_locales => /(Landing|Illistim|Vaalor|Mist Harbor|Kharam|Teras|Icemule|Solhaven|River's Rest)/
    }

    def initialize(first: nil, after: nil, unique: false, sorted: false, reversed: false, marked: nil, registered: nil)
      @first = first
      @after = after
      @unique = unique
      @sorted = sorted
      @reversed = reversed

      @item_filter = nil
      @status_filter = 0

      self.marked = marked
      self.registered = registered

      @container_names = {}
      @container_contents = {}
      @item_statuses = {}

      @pending_ingests = {}

      @scanned_inv = false
      @scanned_hands = false
      @scanned_locker = false

      @seen_ids = Set.new

      @total_items = nil

      @command_cache = {}
    end

    def add_item!(item, container, container_name = nil, status_text = nil)
      return unless @seen_ids.add?(item.id)
      (@container_contents[container] ||= []) << item
      @container_names[container] ||= container_name

      @item_statuses[item.id] = ItemMatcher.status_from_text(status_text) if status_text

      return item
    end

    def add_item(item, container_id, container_name = nil, status_text = nil)
      return nil if @item_filter and not @item_filter.call(item)
      return add_item!(item, container_id, container_name, status_text)
    end

    def marked
      return true if (@status_filter & MARKED) != 0
      return false if (@status_filter & UNMARKED) != 0
      return nil
    end

    def marked=(v)
      @status_filter &= (MARKED | UNMARKED)
      @status_filter |= MARKED if v == true
      @status_filter |= UNMARKED if v == false
    end

    def registered
      return true if (@status_filter & REGISTERED) != 0
      return false if (@status_filter & UNREGISTERED) != 0
      return nil
    end

    def registered=(v)
      @status_filter &= (REGISTERED | UNREGISTERED)
      @status_filter |= REGISTERED if v == true
      @status_filter |= UNREGISTERED if v == false
    end

    def self.status_from_text(text)
      value = 0
      return UNREGISTERED | UNMARKED unless text
      if text =~ /registered/i
        value |= REGISTERED
      else
        value |= UNREGISTERED
      end

      if text =~ /marked/i
        value |= MARKED
      else
        value |= UNMARKED
      end
    end

    def _get_inventory(command)
      return @command_cache[command] unless @command_cache[command].nil?

      lines = Oleani::Helpers.quiet_command(
          command,
          /^(?:You are carrying nothing at this time|You are currently (?:wearing and )?carrying)/,
          /(?:<prompt)|(?:.*items? displayed\.\)$)/,
          # /(?:<prompt)|(?:items displayed.\)\b)/,
          true,
          5
      )

      unless lines
        echo "Inventory request timed out."
        exit
      end
      return (@command_cache[command] = lines)
    end

    def _get_locker_containers
      containers = {}
      GameObj.loot.each do |item|
        containers[item.noun] = item if ForeachScript::PREMIUM_LOCKER_CONTAINERS[item.full_name]
      end
      return containers if containers.length == ForeachScript::PREMIUM_LOCKER_CONTAINERS.length
    end

    def _get_locker_town
      if Room.current and Room.current.id
        loc = Room.current.location
      else
        loc = Map.get_location
      end

      unless loc
        echo "Unable to determine what location this locker is in."
        return nil
      end

      unless loc =~ LOCKER_PATTERNS[:town_locales]
        echo "Location of this room is not familiar.  Unable to determine what town this locker is in."
        return nil
      end

      return $1
    end

    def _get_locker_manifest
      return @command_cache[:locker_manifest] if @command_cache[:locker_manifest]
      @scanned_locker = true
      locker_containers = _get_locker_containers
      return nil unless locker_containers
      return nil unless (town = _get_locker_town)
      manifest_command = "locker manifest #{town}"
      lines = Oleani::Helpers.quiet_command(manifest_command, LOCKER_PATTERNS[:start])
      unless lines
        echo "Locker manifest request timed out."
        exit
      end
      to_return = []
      lines.each do |line|
        if line =~ LOCKER_PATTERNS[:start]
          unless $1 # Remote locker, not local locker
            echo "Location of this room appears to be incorrect, or your locker is not open."
            return nil
          end
        elsif line =~ LOCKER_PATTERNS[:end]
          return @command_cache[:locker_manifest] = to_return
        elsif line =~ LOCKER_PATTERNS[:container] or line =~ LOCKER_PATTERNS[:item]
          to_return << line
        end
      end
      echo "Locker manifest read was incomplete"
      return nil
    end

    def ingest_locker_from_manifest
      finished = false
      locker_containers = _get_locker_containers
      container_id = container_name = nil
      lines = _get_locker_manifest
      return false unless lines
      lines.each do |line|
        if line =~ LOCKER_PATTERNS[:container]
          unless (t = locker_containers[$1])
            echo "Unrecognized container noun: #{$1}"
            return nil
          end
          container_id = t.id
          container_name = t.full_name
        elsif line =~ LOCKER_PATTERNS[:item]
          unless container_id
            manifest_command = "locker manifest #{town}"
            echo "I found an item in a container before I found my first container.  This shouldn't happen."
            echo "Please save a copy of #{manifest_command.upcase} and contact LostRanger"
            exit
          end

          add_item(
              GameObj.new($2.dup, $3.dup, $4.dup, $1.dup, $5.dup),
              container_id, container_name, $6 || ''
          )
        end
      end
      return true
    end

    def _ingest_inventory(command)
      container_id = container_name = nil
      _get_inventory(command).each do |line|
        next unless line =~ INVFULL_PATTERN
        case $1.length
        when 2
          container_id = $3
          container_name = $5
          @item_statuses[container_id] = ItemMatcher.status_from_text($7)
        when 6
          unless container_id
            echo "I found an item in a container before I found my first container.  This shouldn't happen."
            echo "Please save a copy of INV FULL and contact LostRanger"
            exit
          end
          add_item(
              GameObj.new($3.dup, $4.dup, $5.dup, $2.dup, $6.dup),
              container_id, container_name, ($7 || '')
          )
        else
          next
        end
      end
      return true
    end

    def ingest_inventory
      @scanned_inv = true
      return _ingest_inventory('inventory full')
    end

    def ingest_hands
      @scanned_hands = true
      add_item(GameObj.right_hand, "_righthand", "In your right hand") unless GameObj.right_hand.nil?
      add_item(GameObj.left_hand, "_lefthand", "In your left hand") unless GameObj.left_hand.nil?
      return true
    end

    def _status_from_inventory(command)
      _get_inventory(command).each do |line|
        next unless line =~ INVFULL_PATTERN
        @item_statuses[$3] = ItemMatcher.status_from_text($7 || '')
      end
    end

    def status_from_inventory
      return if @scanned_inv
      _status_from_inventory('inventory full')
    end

    def status_from_hands
      return if @scanned_hands
      _status_from_inventory('inventory hands full')
    end

    def ingest_container(container_id, container_name, items)
      items.each {|item| add_item(item, container_id, container_name)}
    end

    def schedule_container(container, location = 'in')
      h = (@pending_ingests[container.id] ||= {})
      h[:item] ||= container
      (h[:locations] ||= Set.new).add(location)
      return h
    end

    def ingest_legacy_locker
      GameObj.loot.each {|x|
        if (loc = ForeachScript::PREMIUM_LOCKER_CONTAINERS[x.full_name])
          schedule_container(x, loc)
        end
      }
    end

    def ingest_loot(location = 'in')
      # @pending_ingests += GameObj.loot.map{|item| item.id}
      GameObj.loot.each {|x| schedule_container(x, location)}
    end

    def ingest_desc
      # @pending_ingests += GameObj.loot.map{|item| item.id}
      GameObj.room_desc.each do |item|
        add_item(item, "_desc", "In the room")
      end
    end

    def ingest_ground
      GameObj.loot.each do |item|
        add_item(item, "_ground", "On the ground")
      end
    end

    def ingest_worn
      GameObj.inv.each do |item|
        add_item(item, "_worn", "On your person")
      end
    end

    def ingest_previous(other)
      other.container_contents.each do |container_id, items|
        container_name = other.container_names[container_id]
        items.each {|item| add_item(item, container_id, container_name)}
      end
    end

    def self.quiet_inv_scan_hook(xml)
      if @in_sorted_view
        @in_sorted_view = false if xml =~ /Total items: \d+$/
        return nil
      end

      return nil if xml =~ /^<prompt|^s*$/
      return xml unless xml =~ INV_PATTERN
      @in_sorted_view = true if $3
      return nil
      #
      # (xml =~ INV_PATTERN or xml =~ /^<prompt/ or xml =~ /^\s*$/) ? nil : xml
    end

    def maybe_fetch_status_data(exist)
      return true if @status_filter == 0
      return true if @item_statuses[exist]
      return fetch_status_data(exist)
    end

    def fetch_status_data(exist)
      if GameObj.right_hand.id == exist or GameObj.left_hand.id == exist
        status_from_hands
      else
        status_from_inventory
        status_from_hands unless @item_statuses[exist]
      end
      return @item_statuses[exist] && true
    end

    def ingest_from_name(target, position = 'in', allow_errors = false)
      begin
        #ForeachScript.stop_scripts
        xml = dothistimeout("look #{position} #{target}", 15, INV_PATTERN)
        unless xml =~ INV_PATTERN
          echo "Timed out waiting for inventory command."
          exit
        end
        collection = $6
        error = $5
        exist = ($1 or $3)
        name = ($2 or $4)
      ensure
        #ForeachScript.resume_scripts
      end
      if error
        if error.start_with?("There") # is nothing in there
          echo "Container '#{target}' is empty."
          return false # Not a hard error.
        elsif error.start_with?("That") # is closed
          echo "Container '#{target}' is closed."
          return false if allow_errors
          exit
        else
          echo "Container '#{target}' was not found."
          return false if allow_errors
          exit
        end
      end
      if collection
        # Collection of items
        items = collection.split(/(?:\s*,\s*)|(?:\s+and\s+(?=[^,]*<a))/)
        items.each {|item|
          next unless item =~ /^(?:(.+)\s+)?<a exist="(-?\d+)" noun="([^"]*)">([^<]*)<\/a>(?:\s+(.+))?/
          ingest_from_name("##{$2}", position)
        }
        return
      end
      unless exist
        echo "Item ID for container '#{target}' could not be determined."
        exit
      end
      unless GameObj.containers[exist]
        echo "Inventory for container '#{target}' was not available."
        exit
      end
      ingest_container(exist, name, GameObj.containers[exist] || [])
      unless maybe_fetch_status_data(exist)
        echo "The container '#{container_names[exist]}' does not appear to be in your inventory, which means that marked/registered information cannot be obtained from it."
        exit
      end
    end

    def ingest_all_pending
      return if @pending_ingests.length == 0
      begin
        #ForeachScript.stop_scripts
        remaining = @pending_ingests.length
        echo "Scanning #{remaining} inventor#{remaining == 1 ? 'y' : 'ies'}, please wait..." # if $SAFE == 0
        hook = Helpers.anon_hook
        @in_sorted_view = false
        DownstreamHook.add(hook, proc {|xml| ItemMatcher.quiet_inv_scan_hook(xml)})
        @pending_ingests.each do |id, ingest|
          container = ingest[:item]
          if remaining != @pending_ingests.length and remaining % ForeachScript::CONTAINER_UPDATE_INTERVAL == 0
            echo "Still scanning #{remaining} inventor#{remaining == 1 ? 'y' : 'ies'}, please wait..." # if $SAFE == 0
          end
          ingest[:locations].each {|location| fput "look #{location} ##{container.id}"}
          remaining -= 1
        end
        waitfor '<prompt'

        @pending_ingests.each do |id, ingest|
          ingest_container(id, ingest[:item].full_name, GameObj.containers[id] || [])
          unless maybe_fetch_status_data(id)
            echo "The container '#{container_names[id]}' does not appear to be in your inventory, which means that marked/registered information cannot be obtained from it."
            exit
          end
        end
        @pending_ingests.clear
      ensure
        #ForeachScript.resume_scripts
      end
    end

    def finalize
      ingest_all_pending

      seen_names = @unique && Set.new || nil
      skip = @after || 0
      first = @first

      final_contents = {}
      final_names = {}
      total_items = 0

      @container_contents.each do |container, contents|
        # Filter by status/uniqueness
        if @status_filter > 0
          contents.each {|item|
            unless maybe_fetch_status_data(item.id)
              echo "Failed to retrieve marked/registered info for '#{item.full_name}'.  Most likely this is because it is in a container not in your inventory."
              exit
            end
          }
          if @unique
            contents.select! {|item| ((@item_statuses[item.id] & @status_filter) == @status_filter) && seen_names.add?(item.full_name)}
          else
            contents.select! {|item| (@item_statuses[item.id] & @status_filter) == @status_filter}
          end
        elsif @unique
          contents.select! {|item| seen_names.add?(item.full_name)}
        end

        # Sort
        if @sorted == :noun
          contents.sort_by! {|x| "#{x.noun.downcase}#{x.full_name.gsub(/^(a|an|some|the)\s+/, '').downcase}"}
        elsif @sorted
          contents.sort_by! {|x| x.full_name.gsub(/^(a|an|some|the)\s+/, '').downcase} if @sorted
        end

        # Reverse
        contents.reverse! if @reversed

        # Handle skips
        if skip >= contents.length
          skip -= contents.length
          next
        elsif skip > 0
          contents = contents.drop(skip)
          skip = 0
        end

        if first
          if first >= contents.length
            first -= contents.length
          else
            contents = contents.first(first)
            first = 0
          end
        end

        final_contents[container] = contents
        final_names[container] = @container_names[container]
        total_items += contents.length
      end

      @container_contents = final_contents
      @container_names = final_names
      @total_items = total_items
      @command_cache.clear
      @seen_ids.clear
      return total_items > 0
    end
  end

  class CommandMonitor

    def cleanup
      UpstreamHook.remove(@hook_id)

      begin
        @watcher_thread.stop?
      ensure
        @watcher_thread = nil
      end

    end

    def stop
      cleanup
    end

    def is_running?
      @watcher_thread && @watcher_thread.status != false
    end

    def sethook
      hook_proc = proc {|client_string|
        begin

          if client_string =~ /^(?:<c>)?(#{@patterns.join("|")})(.*)/i
            cmd = $1.downcase
            @que.enq({"cmd" => cmd, "args" => $2}, true)

            key = @commands.keys.find {|s| s.include?(cmd)}
            command = @commands[key]

            command[:suppress] ? nil : client_string

          else
            client_string
          end
        rescue
          respond $!
          respond $!.backtrace
          UpstreamHook.remove(@hook_id)
          client_string
        end
      }

      UpstreamHook.add(@hook_id, hook_proc)
    end

    def setwatcherthread
      @watcher_thread = Thread.new {
        loop {
          sleep(0.1)
          command = @que.pop
          process_command(command["cmd"], command["args"])
        }
      }
    end

    #Do not catch exceptions here.  Let them bubble up.
    def start
      ## Make sure we aren't currently running
      #if @watcher_thread && @watcher_thread.status != false
      #  raise "Attempted to run new Watcher Thread while one is alive."
      #end
      sethook
      setwatcherthread
    end

    def process_command(command, args)
      begin
        key = @commands.keys.find {|s| s.include?(command)}
        command = @commands[key]
        command[:block].call(args)
      rescue
        respond $!
        respond $!.backtrace
      end
    end

    def on(command, regex = nil, suppress = true, &block)
      regex = command if regex.nil?

      if is_running?
        echo "Currently running"
        return false
      end

      unless block.class == Proc
        echo "Block not a Proc (#{block})"
        return false
      end

      @commands[command] = {:block => block, :suppress => suppress}
      @patterns << regex
    end

    def initialize()
      @hook_id = SecureRandom.hex(10)
      @commands ||= Hash.new
      @patterns = []
      @que = SizedQueue.new(5)
      @watcher_thread = nil

      before_dying {cleanup}
    end
  end

  module Retriable

    module_function

    class RetryError < StandardError;
    end

    # These errors will be handled automatically
    DEFAULT_ERROR_CLASSES = [
        Retriable::RetryError,
        StandardError
    ]

    def retry_with(opts = {}, &blk)
      fail("Block is required") if blk.nil?

      classes = [opts[:errors] || DEFAULT_ERROR_CLASSES].flatten
      attempts = opts[:attempts] || 2
      delay = opts[:delay] || 1
      delay_sleep = opts[:sleep] == true
      pausescript = opts[:pausescript] == true

      # We need to handle our own retry method
      classes << Retriable::RetryError

      1.upto(attempts) do |i|
        begin
          blk.call
          return
        rescue Exception => err
          Oleani::IO.send("!! [NOTICE]  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  [NOTICE] !!")
          Oleani::IO.send(err.message)
          Oleani::IO.send("\nWhen you are ready to proceed unpause poolparty - @@;unpause poolparty@@")
          Oleani::IO.send("Or if you do not want to continue simply  - @@;kill poolparty@@")

          if (classes & err.class.ancestors).any?
            sleep(delay) if delay_sleep
            pause_script if pausescript
          else
            fail(err)
          end

          Script.run('go2', 'locksmith pool')
        end
      end

      fail "Retry attempts exhausted (#{attempts} total)"
    end

    def try_again
      fail(RetryError)
    end
  end
end

module Oleani
  class Command
    attr_accessor :whiny, :timeout

    def self.create(command, timeout = 2)
      command = new(command, timeout)
      if block_given?
        yield(command)
      else
        command
      end
    end

    def initialize(command, timeout = 2)
      @command = command
      @timeout = timeout
      @whiny = false
      @timeout = timeout
      @success_patterns = Hash[]
      @failure_patterns = Hash[]
      @blank_proc = @nomatch_proc = Proc.new {}
    end

    def success(pattern, &block)

      if block_given?
        proc = block
      else
        proc = @blank_proc
      end

      @success_patterns[pattern] = proc

      self
    end

    def failure(pattern, exception = nil, &block)

      if block_given?
        proc = block
      elsif !exception.nil?
        proc = Proc.new {raise exception} unless exception.nil?
      else
        proc = @blank_proc
      end

      @failure_patterns[pattern] = proc

      self
    end

    def nomatch(exception = nil, &block)
      if exception.nil?
        proc = block
      else
        proc = Proc.new {raise exception} unless exception.nil?
      end

      @nomatch_proc = proc

      self
    end

    class Result
      attr_accessor :raw_result, :exception, :success

      def initialize
        @success = false
      end

    end

    def run(**args)

      @all_patterns = Regexp.union(@success_patterns.keys.concat(@failure_patterns.keys)) if @all_patterns.nil?
      result = Result.new
      begin

        result.raw_result = dothistimeout(@command % args, @timeout, @all_patterns)

        res = @success_patterns.find {|key, value|
          if key =~ result.raw_result
            value.call
            true
          end
        }

        res = @failure_patterns.find {|key, value|
          if key =~ result.raw_result
            value.call
            true
          end
        } if res.nil?

        if res.nil?
          result.success = false
          @nomatch_proc.call
        else
          result.success = true
        end

      rescue => e
        result.exception = e
        result.success = false

        raise if @whiny
      ensure
        result
      end
    end
  end
end

module Oleani
  module Helpers
    def self.check_for_disk

      disk = nil
      notified = false
      25.times {
        break if (disk = GameObj[/^.*#{Char.name} (?:disk|coffin)$/])
        sleep 0.2
        unless notified

          Oleani::IO.send("  `Waiting on your disk to arrive`")
          notified = true
        end
      }

      disk
    end

    def self.find_sack(base = 'lootsack')
      # Adapted from ;loot
      sack = nil
      var = "#{base}"
      name = Vars[var].strip
      return sack unless name.length > 0
      if name =~ /^my\s+(.*)$/i
        name = $1
      end
      pattern = Regexp::escape(name)
      sack = nil
      [/\b#{pattern}$/i, /\b#{pattern.sub(' ', '.*')}$/i, /\b#{pattern.sub(' ', '.*')}/i].each {|pattern|
        sack = GameObj.inv.find {|obj| obj.name =~ pattern}
        break if sack
      }
      if sack
        sack
      else
        echo "warning: failed to find #{var} '#{name}'"
      end
    end

    def self.quiet_command(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout = 5)

      result = []
      name = Helpers.anon_hook
      filter = false

      begin
        Timeout::timeout(timeout, Interrupt) {
          DownstreamHook.add(name, proc {|xml|
            if filter
              if xml =~ end_pattern
                DownstreamHook.remove(name)
                filter = false
                # result << xml.rstrip if include_end
                # thread.raise(Interrupt)
                # next(include_end ? nil : xml)
              else
                # result << xml.rstrip
                next(nil)
              end
            elsif xml =~ start_pattern
              filter = true
              # result << xml.rstrip
              next(nil)
            else
              xml
            end
          })
          fput command

          until (xml = get) =~ start_pattern; end
          result << xml.rstrip
          until (xml = get) =~ end_pattern
            result << xml.rstrip
          end
          if include_end
            result << xml.rstrip
          end
        }
      rescue Interrupt
        nil
      end
      return result
    end

    def self.check_silvers

      echo "Checking current silvers"

      res = self.quiet_command("info", /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/, /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+[0-9,]+/)

      info = res.join('\n')
      info =~ /Silver: ([0-9,]*)/

      $1.delete(',').to_i
    end

    def self.anon_hook(prefix = '')
      now = Time.now
      "AnonHook::#{prefix}-#{now.tv_sec}.#{now.tv_usec}-#{Random.rand(10000)}"
    end

    def self.withdraw(withdraw_amount)
      Script.run('go2', 'bank --disable-confirm')

      if XMLData.room_title == '[Pinefar, Depository]'
        if GameObj.npcs.any? {|npc| npc.noun == 'banker'}
          fput "ask banker for #{[withdraw_amount.to_i, 20].max} silvers"
          # The banker nods and says, "Alright, here ye go.  Ye understand I be takin' a little more than that from ye account in the 'Mule.  I don't works for free!"
          # The banker looks at you suspiciously and says, "Hmm, I don't think ye be havin' enough in ye account to cover that and my fee.  Ye tryin' to pull one over on me?"
        else
          if (icemule_bank = Room.list.find {|room| room.location == 'Icemule Trace' and room.tags.include?('bank')})
            Script.run('go2', icemule_bank.id.to_s)
            result = dothistimeout "withdraw #{withdraw_amount} silvers", 1, /debt collector/
            if result =~ /debt collector/
              fput "withdraw #{withdraw_amount} silvers"
            end
          else
            echo 'waiting for banker...'
            wait_until {GameObj.npcs.any? {|npc| npc.noun == 'banker'}}
            fput "ask banker for #{[withdraw_amount.to_i, 20].max} silvers"
          end
        end
      else
        result = dothistimeout "withdraw #{withdraw_amount} silvers", 1, /debt collector/
        if result =~ /debt collector/
          fput "withdraw #{withdraw_amount} silvers"
        end
      end
    end

    def self.deposit_silver(amount)
      Script.run('go2', 'bank --disable-confirm')
      if XMLData.room_title == '[Pinefar, Depository]'
        if GameObj.npcs.any? {|npc| npc.noun == 'banker'}
          fput "give banker #{amount} silvers"
        end
      else
        fput "deposit #{amount}"
      end
    end

    def self.format_number(number, delimiter = ",")
      number.to_s.reverse.gsub(/(\d{3})(?=\d)/, "\\1#{delimiter}").reverse
    end
  end
end

module Oleani

=begin
module Record
  module Bubbles

    def attribute(key)

      define_method(key) do
        CharSettings[key.to_s]
      end

      define_method("#{key}=") do |v|
        CharSettings[key.to_s] = v
      end
    end

  end

  def self.included(o)
    o.extend(Bubbles)
  end
end
=end

  # Beginning of some class level support code
  # Currently this adds the ability to easily add errors to a class
  # Working on nice record binding to the script settings
  module Support
    module Bubbles
      def error(name, message = "")
        klass = Class.new(StandardError) do
          define_method :message do
            message
          end
        end

        self.const_set(name.to_s, klass)
      end
=begin
      def attribute(key)

        define_method(key) do
          CharSettings[key.to_s]
        end

        define_method("#{key}=") do |v|
          CharSettings[key.to_s] = v
        end
      end
=end
    end

    def self.included(o)
      o.extend(Bubbles)
    end
  end
end

module Oleani
  module Objects
    class LichObject
      def initialize(item)
        @item = item
      end

      def id
        @item.id
      end

      def noun
        @item.noun
      end

      def name
        @item.name
      end

      def type
        @item.type
      end

      def is_valid?
        !@item.id.nil?
      end

    end

    class Container < LichObject
      def initialize(container)
        super container
      end

      def open
        fput "open ##{@item.id}"
      end
    end

    class Box < LichObject

      def initialize(item)
        super item
        @open_verb = @item.type == "box" ? "open" : "pluck"
      end

      def self.wrap(item)
        Box.new(item)
      end

      def open
        fput "#{@open_verb} ##{@item.id}"
        waitrt?
      end

      def loot_coins
        fput "get coins from ##{@item.id}"
        waitrt?
      end

      def loot
        fput "loot ##{@item.id}"
        waitrt?
      end

      def self.get(id)
        fput "get ##{id}"
        waitrt?

        if GameObj.right_hand.id == id
          Box.new GameObj.right_hand

        elsif GameObj.left_hand.id == id
          Box.new GameObj.left_hand

        else
          nil

        end

      end

      def empty_into(location)
        res = dothistimeout "empty ##{@item.id} in ##{location.id}", 5, /but nothing will fit\.|but you can't quite get|but nothing comes out\.|leaving the rest in/

        raise "Inventory appears to be full.  Please empty your loot sack." if res =~ /but nothing will fit|leaving the rest in|but you can't quite get one item to come out/

        waitrt?
      end

      def move_to(location)
        fput "put ##{@item.id} in ##{location.id}"

        raise "Unable to move box to #{location.name}.  Please check if it is full." unless GameObj.right_hand.id.nil? && GameObj.left_hand.id.nil?
      end
    end

  end
end

module Oleani
  module IO
    def self.send(msg, formatted=true)
      if $frontend == 'stormfront' && formatted
        msg = REXML::Text.new(msg, respect_whitespace: true).to_s
        msg.gsub!(/@@(.*?)@@/, '<pushBold/>\1<popBold/>')
        msg.gsub!(/!!(.*?)!!/, '<preset id="thought">\1</preset>')
        msg.gsub!(/\*\*(.*?)\*\*/, '<preset id="whisper">\1</preset>')
        msg.gsub!(/`(.*?)`/, '<preset id="speech">\1</preset>')
        msg = "<output class=\"mono\" />\n#{msg}\n<output class=\"\" />"
        puts msg
      else
        msg.gsub!('**', '')
        msg.gsub!('`', '')
        msg.gsub!('!!', '')
        msg.gsub!('@@', '')
        respond msg
      end
    end
  end
end

