=begin

	Spellup script for yourself and others

	;waggle help

	This script is a rewrite of ultrawaggle from SpiffyJr, which is
	a heavily modified version of spellup from Shaelun and Blueland. 

	I have made a few edits to make this script more bard friendly adding in options for sonic armor, sonic weapons, and sonic shields


	Tenzle
=end

start_at          = CharSettings['start_at']          || 180
stop_at           = CharSettings['stop_at']           || 180
stop_at           = [stop_at,250].min
stop_before       = CharSettings['stop_before']       || 250
unstackable_min   = CharSettings['unstackable_min']   ||  15
use_wracking      = CharSettings['use_wracking']      || false
wander_to_wrack   = CharSettings['wander_to_wrack']   || false
use_power         = CharSettings['use_power']         || false
use_concentration = CharSettings['use_concentration'] || false
skip_jerks        = CharSettings['skip_jerks']        ||  false
ASG 			        = CharSettings['ASG']
sonic_weapon	    = CharSettings['sonic_weapon']
sonic_shield	    = CharSettings['sonic_shield']
retribution_spell = CharSettings['retribution_spell']


cast_list         = CharSettings['cast_list']         || [ 101, 102, 103, 107, 115, 120, 202, 211, 215, 219, 303, 307, 310, 313, 401, 406, 414, 425, 430, 503, 507, 508, 509, 513, 520, 601, 602, 606, 613, 617, 618, 625, 640, 712, 905, 911, 913, 920, 1109, 1119, 1125, 1130, 1601, 1603, 1606, 1610, 1611, 1612, 1616 ]

if setting = script.vars.find { |var| var =~ /^\-\-start[_\-]at=[0-9]+$/ }
	start_at = setting.slice(/[0-9]+/).to_i
	script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-stop[_\-]at=[0-9]+$/ }
	stop_at = [setting.slice(/[0-9]+/).to_i,250].min
	script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-stop[_\-]before=[0-9]+$/ }
	stop_before = setting.slice(/[0-9]+/).to_i
	script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-unstackable[_\-]min=[0-9]+$/ }
	unstackable_min = setting.slice(/[0-9]+/).to_i
	script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-cast[_\-]list=[0-9,]+$/ }
	cast_list = setting.split(',').collect { |num| num.to_i }
	script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-use[_\-]wracking=(?:on|off)$/ }
	fix_setting = { 'on' => true, 'off' => false }
	use_wracking = fix_setting[setting.slice(/on|off/)]
	script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-wander[_\-]to[_\-]wrack=(?:on|off)$/ }
	fix_setting = { 'on' => true, 'off' => false }
	wander_to_wrack = fix_setting[setting.slice(/on|off/)]
	script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-use[_\-]power=(?:on|off)$/ }
	fix_setting = { 'on' => true, 'off' => false }
	use_power = fix_setting[setting.slice(/on|off/)]
	script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-use[_\-]concentration=(?:on|off)$/ }
	fix_setting = { 'on' => true, 'off' => false }
	use_concentration = fix_setting[setting.slice(/on|off/)]
	script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-skip[_\-]jerks=(?:on|off)$/ }
	fix_setting = { 'on' => true, 'off' => false }
	skip_jerks = fix_setting[setting.slice(/on|off/)]
	script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-asg=[0-9]+$/ }
		ASG = setting.slice(/[0-9]+/).to_i
		script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-sonic[_\-]weapon=(.+)$/ }
		sonic_weapon = $1
		script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-sonic[_\-]shield=(?:on|off)$/ }
		sonic_shield = $1
		script.vars.delete(setting)
end
if setting = script.vars.find { |var| var =~ /^\-\-retribution[_\-]spell=(?:[0-9]+|off)$/ }
	if setting =~ /^\-\-retribution[_\-]spell=off$/
		retribution_spell = nil
	elsif setting =~ /^\-\-retribution[_\-]spell=([0-9]+)$/
		retribution_spell = $1.to_i
	end.
	script.vars.delete(setting)
end
if script.vars.include?('--save')
	CharSettings['use_wracking']      = use_wracking
	CharSettings['wander_to_wrack']   = wander_to_wrack
	CharSettings['use_power']         = use_power
	CharSettings['use_concentration'] = use_concentration
	CharSettings['skip_jerks']        = skip_jerks
	CharSettings['start_at']          = start_at
	CharSettings['stop_at']           = stop_at
	CharSettings['stop_before']       = stop_before
	CharSettings['unstackable_min']   = unstackable_min
	CharSettings['retribution_spell'] = retribution_spell
	CharSettings['cast_list']         = cast_list
	CharSettings['ASG']				  = ASG
	CharSettings['sonic_weapon']      = sonic_weapon
	CharSettings['sonic_shield']      = sonic_shield
	exit
end

known_spells      = Spells.known.collect { |spell| spell.num }
cast_list.delete_if { |spell| !(known_spells.include?(spell) and Spell[spell].time_per > 0) }
list_mode         = false

if script.vars.empty?
	target_list = [ Char.name ]
elsif script.vars[1].downcase == 'help'
	respond
	respond 'Usage:'
	respond "   #{$clean_lich_char}#{script.name} help                        show this message"
	respond "   #{$clean_lich_char}#{script.name} setup                       show setup window"
	respond "   #{$clean_lich_char}#{script.name} list                        show current settings"
	respond
	respond "   #{$clean_lich_char}#{script.name} add [spell#]                add one or more spells to the cast list"
	respond "   #{$clean_lich_char}#{script.name} delete [spell#]             delete one or more spells from the cast list"
	respond
	respond "   #{$clean_lich_char}#{script.name} start-at [minutes]          stackable spells will be cast if they have less than (start_at) minutes remaining"
	respond "   #{$clean_lich_char}#{script.name} stop-at [minutes]             when the script starts, and will be cast while the time left is less than"
	respond "   #{$clean_lich_char}#{script.name} stop-before [minutes]         (stop_at) and the time left after another cast would be less than (stop before)"
	respond
	respond "   #{$clean_lich_char}#{script.name} unstackable-min [minutes]   minimum time for non-stacking spells"
	respond
	respond "   #{$clean_lich_char}#{script.name} wracking [on/off]           use sign of wracking when out of mana"
	respond "   #{$clean_lich_char}#{script.name} wander [on/off]             wander up to 20 rooms to find an empty room to wrack in and return"
	respond "   #{$clean_lich_char}#{script.name} power [on/off]              use sigil of power when out of mana"
	respond "   #{$clean_lich_char}#{script.name} concentration [on/off]      use sigil of power when out of mana"
	respond "   #{$clean_lich_char}#{script.name} skip-jerks [on/off]         skip targets that don't share their current spell durations"
	respond "   #{$clean_lich_char}#{script.name} retribution-spell [#|none]  spell number for chant retribution after casting cloak of shadows"
	respond	""
	respond "   #{$clean_lich_char}#{script.name} asg [ASG#]  			      ASG of the armor type you wish to use with 1014"
	respond "   #{$clean_lich_char}#{script.name} sonic-weapon [wepon type]   weapon type to be used with 1012"
	respond "   #{$clean_lich_char}#{script.name} sonic-shield [shield type]  shield type to use with 1009"
	respond ""
	respond "   #{$clean_lich_char}#{script.name}                             spell yourself up"
	respond "   #{$clean_lich_char}#{script.name} [name1] [name2] ...         spell up the given people (may include your own name)"
	respond "   #{$clean_lich_char}#{script.name} info                        show what will be cast and how much it will cost"
	respond "   #{$clean_lich_char}#{script.name} info [name1] [name2]        ''"
	respond ""
	respond "   Any or all saved options can be overridden on the command line without being saved using the following syntax:"
	respond ""
	respond "   #{$clean_lich_char}#{script.name} --spell-list=401,406,503 --start-at=60 --stop-at=120 --stop-before=250 --unstackable-min=10 --use-wracking=on --wander-to-wrack=on --use-power=off --use-concentration=off --skip-jerks=on --retribution-spell=717 Jim Joe Bob"
	respond
	exit
elsif script.vars[1] =~ /^setup$|^options$/i
	if HAVE_GTK and defined?(Gtk.queue)
		window = window_action = nil
		window_width  = CharSettings['window_width'] || 445
		window_height = CharSettings['window_height'] || 490
		Gtk.queue {
			nocast_label = Gtk::Label.new('Spells not to Cast')
			cast_label = Gtk::Label.new('Spells to Cast')

			label_box = Gtk::Box.new(:horizontal, 5)
			label_box.pack_start(nocast_label, :expand => true, :fill => true, :padding => 0)
			label_box.pack_start(cast_label, :expand => true, :fill => true, :padding => 0)

			renderer = Gtk::CellRendererText.new
			renderer.background = 'white'

			nocast_ls = Gtk::ListStore.new(String, String)
			nocast_ls.set_sort_column_id(0, :ascending)
			nocast_tv = Gtk::TreeView.new(nocast_ls)
			nocast_tv.headers_visible = false
			nocast_tv.height_request = 150
			nocast_tv.append_column(Gtk::TreeViewColumn.new('', renderer, :text => 0, :background_set => 2))
			nocast_tv.append_column(Gtk::TreeViewColumn.new('', renderer, :text => 1, :background_set => 2))
			nocast_sw = Gtk::ScrolledWindow.new
			nocast_sw.set_policy(:automatic, :always)
			nocast_sw.add(nocast_tv)

			cast_ls = Gtk::ListStore.new(String, String)
			cast_ls.set_sort_column_id(0, :ascending)
			cast_tv = Gtk::TreeView.new(cast_ls)
			cast_tv.headers_visible = false
			cast_tv.height_request = 150
			cast_tv.append_column(Gtk::TreeViewColumn.new('', renderer, :text => 0, :background_set => 2))
			cast_tv.append_column(Gtk::TreeViewColumn.new('', renderer, :text => 1, :background_set => 2))
			cast_sw = Gtk::ScrolledWindow.new
			cast_sw.set_policy(:automatic, :always)
			cast_sw.add(cast_tv)

			tree_box = Gtk::Box.new(:horizontal, 5)
			tree_box.pack_start(nocast_sw, :expand => true, :fill => true, :padding => 0)
			tree_box.pack_start(cast_sw, :expand => true, :fill => true, :padding => 0)

			start_at_label = Gtk::Label.new('start casting if below:')
			start_at_entry = Gtk::Entry.new
			start_at_entry.text = start_at.to_s
			start_at_entry.width_request = 50
			stop_at_label = Gtk::Label.new('stop casting at:')
			stop_at_entry = Gtk::Entry.new
			stop_at_entry.text = stop_at.to_s
			stop_at_entry.width_request = 50
			stop_before_label = Gtk::Label.new("don't cast over:")
			stop_before_entry = Gtk::Entry.new
			stop_before_entry.text = stop_before.to_s
			stop_before_entry.width_request = 50

			stack_box = Gtk::Box.new(:vertical, 0)
			temp_box = Gtk::Box.new(:horizontal, 0)
			temp_box.pack_end(start_at_entry, :expand => false, :fill => false, :padding => 5)
			temp_box.pack_end(start_at_label, :expand => false, :fill => false, :padding => 5)
			stack_box.pack_start(temp_box, :expand => false, :fill => false, :padding => 5)
			temp_box = Gtk::Box.new(:horizontal, 0)
			temp_box.pack_end(stop_at_entry, :expand => false, :fill => false, :padding => 5)
			temp_box.pack_end(stop_at_label, :expand => false, :fill => false, :padding => 5)
			stack_box.pack_start(temp_box, :expand => false, :fill => false, :padding => 5)
			temp_box = Gtk::Box.new(:horizontal, 0)
			temp_box.pack_end(stop_before_entry, :expand => false, :fill => false, :padding => 5)
			temp_box.pack_end(stop_before_label, :expand => false, :fill => false, :padding => 5)
			stack_box.pack_start(temp_box, :expand => false, :fill => false, :padding => 5)
			stack_frame = Gtk::Frame.new('Stackable Spells')
			stack_box_spacer = Gtk::Box.new(:vertical)
			stack_box_spacer.pack_start(stack_box, :expand => false, :fill => false, :padding => 4)
			stack_frame.add(stack_box_spacer)

			nonstack_min_label = Gtk::Label.new('   Minimum:')
			nonstack_min_entry = Gtk::Entry.new
			nonstack_min_entry.text = unstackable_min.to_s
			nonstack_min_entry.width_request = 50

			nonstack_box = Gtk::Box.new(:horizontal, 0)
			nonstack_box.pack_end(nonstack_min_entry, :expand => false, :fill => false, :padding => 4)
			nonstack_box.pack_end(nonstack_min_label, :expand => false, :fill => false, :padding => 4)
			nonstack_box_spacer = Gtk::Box.new(:vertical)
			nonstack_box_spacer.pack_start(nonstack_box, :expand => false, :fill => false, :padding => 4)
			nonstack_frame = Gtk::Frame.new('Non-stackable Spells')
			nonstack_frame.add(nonstack_box_spacer)

			left_box = Gtk::Box.new(:vertical, 0)
			left_box.pack_start(stack_frame, :expand => false, :fill => false, :padding => 5)
			left_box.pack_start(nonstack_frame, :expand => false, :fill => false, :padding => 5)

			use_wracking_option = Gtk::CheckButton.new('wracking')
			use_wracking_option.active = use_wracking
			wander_to_wrack_option = Gtk::CheckButton.new('wander to wrack')
			wander_to_wrack_option.active = wander_to_wrack
			use_power_option = Gtk::CheckButton.new('power')
			use_power_option.active = use_power
			use_concentration_option = Gtk::CheckButton.new('concentration')
			use_concentration_option.active = use_concentration
			skip_jerks_option = Gtk::CheckButton.new('skip jerks')
			skip_jerks_option.active = skip_jerks

			option_box = Gtk::Box.new(:vertical, 0)
			option_box.pack_start(use_wracking_option, :expand => false, :fill => false, :padding => 4)
			option_box.pack_start(wander_to_wrack_option, :expand => false, :fill => false, :padding => 4)
			option_box.pack_start(use_power_option, :expand => false, :fill => false, :padding => 4)
			option_box.pack_start(use_concentration_option, :expand => false, :fill => false, :padding => 4)
			option_box.pack_start(skip_jerks_option, :expand => false, :fill => false, :padding => 4)

			retribution_spell_label = Gtk::Label.new('retribution spell:')
			retribution_spell_entry = Gtk::Entry.new
			retribution_spell_entry.text = retribution_spell.to_s
			retribution_spell_entry.width_request = 50
			temp_box = Gtk::Box.new(:horizontal, 0)
			temp_box.pack_end(retribution_spell_entry, :expand => false, :fill => false, :padding => 5)
			temp_box.pack_end(retribution_spell_label, :expand => false, :fill => false, :padding => 5)
			option_box.pack_start(temp_box, :expand => false, :fill => false, :padding => 5)

			ASG_label = Gtk::Label.new('ASG:')
			ASG_entry = Gtk::Entry.new
			ASG_entry.text = ASG.to_s
			ASG_entry.width_request = 50
			temp_box = Gtk::Box.new(:horizontal, 0)
			temp_box.pack_end(ASG_entry, :expand => false, :fill => false, :padding => 5)
			temp_box.pack_end(ASG_label, :expand => false, :fill => false, :padding => 5)
			option_box.pack_start(temp_box, :expand => false, :fill => false, :padding => 4)

			sonic_weapon_label = Gtk::Label.new('Sonic Weapon Type:')
			sonic_weapon_entry = Gtk::Entry.new
			sonic_weapon_entry.text = sonic_weapon.to_s
			sonic_weapon_entry.width_request = 100
			temp_box = Gtk::Box.new(:horizontal, 0)
			temp_box.pack_end(sonic_weapon_entry, :expand => false, :fill => false, :padding => 5)
			temp_box.pack_end(sonic_weapon_label, :expand => false, :fill => false, :padding => 5)
			option_box.pack_start(temp_box, :expand => false, :fill => false, :padding => 5)

			sonic_shield_label = Gtk::Label.new('Sonic Shield Type:')
			sonic_shield_entry = Gtk::Entry.new
			sonic_shield_entry.text = sonic_shield.to_s
			sonic_shield_entry.width_request = 100
			temp_box = Gtk::Box.new(:horizontal, 0)
			temp_box.pack_end(sonic_shield_entry, :expand => false, :fill => false, :padding => 5)
			temp_box.pack_end(sonic_shield_label, :expand => false, :fill => false, :padding => 5)
			option_box.pack_start(temp_box, :expand => false, :fill => false, :padding => 4)


			option_box_spacer = Gtk::Box.new(:vertical)
			option_box_spacer.pack_start(option_box, :expand => false, :fill => false, :padding => 4)

			option_frame = Gtk::Frame.new('Options')
			option_frame.add(option_box_spacer)

			columns = Gtk::Box.new(:horizontal, 0)

			columns.pack_start(left_box, :expand => false, :fill => false, :padding => 0)
			columns.pack_start(option_frame, :expand => false, :fill => false, :padding => 0)

			save_button = Gtk::Button.new(:label => 'Ok')
			save_button.width_request = 75
			cancel_button = Gtk::Button.new(:label => 'Cancel')
			cancel_button.width_request = 75
			button_box = Gtk::Box.new(:horizontal, 3)
			button_box.pack_end(save_button, :expand => false, :fill => false, :padding => 4)
			button_box.pack_end(cancel_button, :expand => false, :fill => false, :padding => 4)

			main_box = Gtk::Box.new(:vertical, 4)
			main_box.pack_start(label_box, :expand => false, :fill => false, :padding => 0)
			main_box.pack_start(tree_box, :expand => true, :fill => true, :padding => 0)
			main_box.pack_start(columns, :expand => false, :fill => false, :padding => 0)
			main_box.pack_start(button_box, :expand => false, :fill => false, :padding => 0)

			window = Gtk::Window.new
			window.set_icon(@default_icon)
			window.title = 'waggle setup'
			window.border_width = 5
			window.add(main_box)
			window.resize(window_width, window_height)

			Spells.known.each { |spell|
				next unless (Spell[spell].time_per > 0)
				if cast_list.include?(spell.num)
					iter = cast_ls.append
					iter[0] = spell.num.to_s
					iter[1] = spell.name
				else
					iter = nocast_ls.append
					iter[0] = spell.num.to_s
					iter[1] = spell.name
				end
			}

			cast_tv.drag_source_set(:button1_mask, [ [ 'text/plain', :same_app, 0 ] ], :move)
			cast_tv.drag_dest_set(:all, [ [ 'text/plain', :same_app, 0 ] ], :move)
			nocast_tv.drag_source_set(:button1_mask, [ [ 'text/plain', :same_app, 0 ] ], :move)
			nocast_tv.drag_dest_set(:all, [ [ 'text/plain', :same_app, 0 ] ], :move)

			cast_tv.signal_connect('drag-data-get') { |who, drag_context, data|
				data.text = who.selection.selected[0] if who.selection.selected
			}
			cast_tv.signal_connect('drag-data-received') { |who, drag_context, x, y, data, info, time|
				nocast_ls.each { |model,path,iter|
					if iter[0] == data.text
						new_iter = cast_ls.append
						new_iter[0] = iter[0]
						new_iter[1] = iter[1]
						nocast_ls.remove(iter)
						break
					end
				}
			}
			cast_tv.signal_connect('button-press-event') { |who, event|
				if (event.event_type == Gdk::Event::BUTTON2_PRESS) and (source_iter = cast_tv.selection.selected)
					dest_iter = nocast_ls.append
					dest_iter[0] = source_iter[0]
					dest_iter[1] = source_iter[1]
					cast_ls.remove(source_iter)
				end
			}
			nocast_tv.signal_connect('drag-data-get') { |who, drag_context, data|
				data.text = who.selection.selected[0] if who.selection.selected
			}
			nocast_tv.signal_connect('drag-data-received') { |who, drag_context, x, y, data, info, time|
				cast_ls.each { |model,path,iter|
					if iter[0] == data.text
						new_iter = nocast_ls.append
						new_iter[0] = iter[0]
						new_iter[1] = iter[1]
						cast_ls.remove(iter)
						break
					end
				}
			}
			nocast_tv.signal_connect('button-press-event') { |who, event|
				if (event.event_type == :button2_press) and (source_iter = nocast_tv.selection.selected)
					dest_iter = cast_ls.append
					dest_iter[0] = source_iter[0]
					dest_iter[1] = source_iter[1]
					nocast_ls.remove(source_iter)
				end
			}
			cancel_button.signal_connect('clicked') {
				window_width = window.allocation.width
				window_height = window.allocation.height
				window_action = :cancel
			}
			save_button.signal_connect('clicked') {
				Gtk.queue {
					cast_list = Array.new
					cast_ls.each { |model,path,iter| cast_list.push(iter[0].to_i) }
					if start_at_entry.text =~ /^[0-9]+$/i
						start_at = start_at_entry.text.to_i
					else
						respond "[waggle: ignoring invalid entry: #{start_at_entry.text}]"
					end
					if stop_at_entry.text =~ /^[0-9]+$/i
						stop_at = stop_at_entry.text.to_i
					else
						respond "[waggle: ignoring invalid entry: #{stop_at_entry.text}]"
					end
					if stop_before_entry.text =~ /^[0-9]+$/i
						stop_before = stop_before_entry.text.to_i
					else
						respond "[waggle: ignoring invalid entry: #{stop_before_entry.text}]"
					end
					if nonstack_min_entry.text =~ /^[0-9]+$/i
						unstackable_min = nonstack_min_entry.text.to_i
					else
						respond "[waggle: ignoring invalid entry: #{nonstack_min_entry.text}]"
					end
					if retribution_spell_entry.text =~ /^[0-9]+$/i
						retribution_spell = retribution_spell_entry.text
					elsif retribution_spell_entry.text.empty? or retribution_spell_entry.text =~ /none|off/
						retribution_spell = nil
					else
						respond "[waggle: ignoring invalid entry: #{retribution_spell_entry.text}]"
					end
					if ASG_entry.text =~ /^[0-9]+$/i
						ASG = ASG_entry.text
					elsif ASG_entry.text.empty? or ASG_entry.text =~ /none|off/
						ASG = nil
					else
						respond "[waggle: ignoring invalid entry: #{ASG_entry.text}]"
					end
					if sonic_weapon_entry.text =~ /^.+$/i
						sonic_weapon = sonic_weapon_entry.text
					elsif sonic_weapon_entry.text.empty? or sonic_weapon_entry.text =~ /none|off/
						sonic_weapon = nil
					end
					if sonic_shield_entry.text =~ /^.+$/i
						sonic_shield = sonic_shield_entry.text
					elsif sonic_shield_entry.text.empty? or sonic_shield_entry.text =~ /none|off/
						sonic_shield = nil
					end
					use_wracking = use_wracking_option.active?
					wander_to_wrack = wander_to_wrack_option.active?
					use_power = use_power_option.active?
					use_concentration = use_concentration_option.active?
					skip_jerks = skip_jerks_option.active?
					window_width = window.allocation.width
					window_height = window.allocation.height
					window_action = :save
				}
			}
			window.signal_connect('delete_event') {
				window_width = window.allocation.width
				window_height = window.allocation.height
				window_action = :cancel
			}

			window.show_all
		}
		before_dying { Gtk.queue { window.destroy } }
		wait_while { window_action.nil? }
		undo_before_dying
		Gtk.queue { window.destroy }
		CharSettings['window_width']  = window_width
		CharSettings['window_height'] = window_height
		if window_action == :save
			CharSettings['use_wracking']      = use_wracking
			CharSettings['wander_to_wrack']   = wander_to_wrack
			CharSettings['use_power']         = use_power
			CharSettings['use_concentration'] = use_concentration
			CharSettings['skip_jerks']        = skip_jerks
			CharSettings['start_at']          = start_at
			CharSettings['stop_at']           = stop_at
			CharSettings['stop_before']       = stop_before
			CharSettings['unstackable_min']   = unstackable_min
			CharSettings['retribution_spell'] = retribution_spell
			CharSettings['ASG']				  = ASG
			CharSettings['sonic_weapon']	  = sonic_weapon
			CharSettings['sonic_shield']	  = sonic_shield
			CharSettings['cast_list']         = cast_list
		end
	else
		unless defined?(Gtk.queue)
			echo "GUI setup requires Lich v4.  For command-line setup, see #{$clean_lich_char}#{script.name} help"
		end
		unless HAVE_GTK
			echo 'GTK bindings are not installed or failed to load.'
		end
	end
	exit
elsif script.vars[1].downcase == 'add'
	add_list = script.vars[2..-1].collect { |spell| spell.to_i }
	add_list.each { |spell|
		cast_list.push(spell.to_i) unless cast_list.include?(spell.to_i)
	}
	echo "added these spells to the cast list: #{add_list.join(', ')}"
	CharSettings['cast_list'] = cast_list
	exit
elsif script.vars[1] =~ /^rem(?:ove)?$|^del(?:ete)?$/i
	del_list = script.vars[2..-1].collect { |spell| spell.to_i }
	del_list.each { |spell|
		if cast_list.delete(spell)
			echo "removed #{spell} from the cast list"
		else
			echo "did not find #{spell} in the cast list"
		end
	}
	CharSettings['cast_list'] = cast_list
	exit
elsif script.vars[1] =~ /^list$|^show$/i
	fix_setting = { true => 'on', false => 'off' }
	respond
	respond "             cast list: #{cast_list.join(', ')}"
	respond "              start at: #{start_at}"
	respond "               stop at: #{stop_at}"
	respond "           stop before: #{stop_before}"
	respond "       unstackable min: #{unstackable_min}"
	respond "      sign of wracking: #{fix_setting[use_wracking]}"
	respond "       wander to wrack: #{fix_setting[wander_to_wrack]}"
	respond "        sigil of power: #{fix_setting[use_power]}"
	respond "sigil of concentration: #{fix_setting[use_concentration]}"
	respond "            skip jerks: #{fix_setting[skip_jerks]}"
	respond "         ASG: #{ASG || 'none'}"
	respond "         sonic_weapon: #{sonic_weapon || 'none'}"
	respond "         sonic_shield: #{sonic_shield || 'none'}"
	respond "         retribution spell: #{retribution_spell || 'none'}"
	respond
	exit
elsif script.vars[1].downcase == /^start[_\-]at$/
	if script.vars[2] =~ /^[0-9]+$/
		CharSettings['start_at'] = script.vars[2].to_i
		echo "stackable spells with less than #{CharSettings['start_at']} minutes remaining when the script starts will be skipped"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^stop[_\-]at$/
	if script.vars[2] =~ /^[0-9]+$/
		CharSettings['stop_at'] = script.vars[2].to_i
		echo "stackable spells will be cast until they have #{CharSettings['stop_at']} minutes remaining"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^stop[_\-]before$/
	if script.vars[2] =~ /^[0-9]+$/
		CharSettings['stop_before'] = script.vars[2].to_i
		echo "stackable spells will not be cast if it would cause the spell to have more than #{CharSettings['stop_before']} minutes remaing"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase == /^unstackable[_\-]?min$/
	if script.vars[2] =~ /^[0-9]+$/
		CharSettings['unstackable_min'] = script.vars[2].to_i
		echo "non-stackable spells will be cast if they have less than #{CharSettings['unstackable_min']} minutes remaining"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^(?:use[_\-])?wracking$/
	if script.vars[2].downcase == 'on'
		CharSettings['use_wracking'] = true
		echo "sign of wracking will be used"
	elsif script.vars[2].downcase == 'off'
		CharSettings['use_wracking'] = false
		echo "sign of wracking will not be used"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^wander(?:[_\-]to[_\-]wrack)?$/
	if script.vars[2].downcase == 'on'
		CharSettings['wander_to_wrack'] = true
		echo "wander will be used to wrack"
	elsif script.vars[2].downcase == 'off'
		CharSettings['wander_to_wrack'] = false
		echo "wander will not be used to wrack"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^(?:use[_\-])?power$/
	if script.vars[2].downcase == 'on'
		CharSettings['use_power'] = true
		echo "sigil of power will be used"
	elsif script.vars[2].downcase == 'off'
		CharSettings['use_power'] = false
		echo "sigil of power will not be used"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^(?:use[_\-])?concentration$/
	if script.vars[2].downcase == 'on'
		CharSettings['use_concentration'] = true
		echo "sigil of concentration will be used"
	elsif script.vars[2].downcase == 'off'
		CharSettings['use_concentration'] = false
		echo "sigil of concentration will not be used"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^skip[_\-]jerks$/
	if script.vars[2].downcase == 'on'
		CharSettings['skip_jerks'] = true
		echo "jerks that don't share spell durations will be skipped"
	elsif script.vars[2].downcase == 'off'
		CharSettings['skip_jerks'] = false
		echo "jerks that don't share spell durations will not be skipped"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^retribution[_\-]spell$/
	if script.vars[2].downcase =~ /^(?:off|none)$/
		CharSettings['retribution_spell'] = nil
		echo "retribution spell cleared"
	elsif script.vars[2] =~ /^[0-9]+$/
		CharSettings['retribution_spell'] = script.vars[2]
		echo "retribution spell set to #{script.vars[2]}"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^asg$/
	if script.vars[2].downcase =~ /^(?:off|none)$/
		CharSettings['ASG'] = nil
		echo "ASG cleared"
	elsif script.vars[2] =~ /^[0-9]+$/
		CharSettings['ASG'] = script.vars[2]
		echo "ASG set to #{script.vars[2]}"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^sonic[_\-]weapon$/
	if script.vars[2].downcase =~ /^(?:off|none)$/
		CharSettings['sonic_weapon'] = nil
		echo "Sonic Weapon cleared"
	elsif script.vars[2] =~ /^.+$/
		CharSettings['sonic_weapon'] = script.vars[2]
		echo "Sonic Weapon set to #{script.vars[2]}"
	else
		echo "You're doing it wrong..."
	end
	exit
elsif script.vars[1].downcase =~ /^sonic[_\-]shield$/
	if script.vars[2].downcase =~ /^(?:off|none)$/
		CharSettings['sonic_shield'] = nil
		echo "Sonic Shield cleared"
	elsif script.vars[2] =~ /^.+$/
		CharSettings['sonic_shield'] = script.vars[2]
		echo "Sonic shield set to #{script.vars[2]}"
	else
		echo "You're doing it wrong..."
	end
	exit
else
	if script.vars[1].downcase == 'info'
		list_mode = true
		target_list = script.vars[2..-1]
		target_list = [ Char.name ] if target_list.empty?
	else
		target_list = script.vars[1..-1]
		target_list = [ Char.name ] if target_list.empty?
	end
end

fix_spell = proc { |spell|
	if (spell.class == Fixnum) or (spell.class == String and spell =~ /^[0-9]+$/)
		spell = Spell[spell.to_i]
	end
	unless spell.class == Spell
		echo 'error: missing spell information'
		exit
	end
	spell
}

wander_rooms = Array.new
wander = proc {
	room = Room.current
	next_room_options = room.wayto.keys
	next_room = next_room_options.find_all { |r| not wander_rooms.include?(r) }
	if next_room.empty?
		next_room = wander_rooms.find { |r| next_room_options.include?(r) }
	else
		next_room = next_room[rand(next_room.length)]
	end
	wander_rooms.delete(next_room)
	wander_rooms.push(next_room)
	way = room.wayto[next_room]
	if way.class == String
		move(way)
	else
		way.call
	end
}

check_mana = proc { |spell|
	unless spell.affordable?
		sigil_of_power = Spell[9718]
		sign_of_wracking = Spell[9918]
		punishment = Spell[9012]
		if use_power and sigil_of_power.known? and (spell.mana_cost > 0) and (spell.stamina_cost == 0)
			until spell.affordable?
				if sigil_of_power.affordable?
					sigil_of_power.cast
					sleep 0.2
				else
					fput 'release' unless checkprep == 'None'
					echo 'waiting for mana or stamina...'
					wait_until { spell.affordable? or sigil_of_power.affordable? }
				end
			end
		elsif use_wracking and sign_of_wracking.known? and not punishment.active? and (spell.mana_cost > 0)
			until spell.affordable?
				waitrt?
				waitcastrt?
				if sign_of_wracking.affordable? and not punishment.active?
					if invisible? or hidden? or not checkpcs
						sign_of_wracking.cast if checkspirit(6)
					else
						status_tags
						evil_pcs = checkpcs
						result = dothistimeout 'sign of recognition', 5, /^You (?:touch|scratch|rub|tap|point to) your (?:right|left) (?:eyebrow|nostril|earlobe|shoulder|cheek) with your (?:right|left) (?:pinky|forefinger|thumb|index finger)\.$/
						unless result.nil?
							while (line = get) and (line !~ /<prompt/)
								if line =~ /<a.*?>([A-Z][a-z]+)<\/a> acknowledges your sign/
									evil_pcs.delete($1)
								end
							end
						end
						status_tags
						if sign_of_wracking.affordable? and (evil_pcs.nil? or evil_pcs.empty?)
							sign_of_wracking.cast if checkspirit(6)
						elsif sign_of_wracking.affordable? and wander_to_wrack
							start_room = Room.current
							20.times {
								break if checkpcs.nil? or invisible?
								wander.call
							}
							if checkpcs.nil? and checkspirit(6)
								sign_of_wracking.cast
								unless start_room == Room.current
									start_script 'go2', [ start_room.id.to_s ]
									wait_while { running?('go2') }
								end
							else
								unless start_room == Room.current
									start_script 'go2', [ start_room.id.to_s ]
									wait_while { running?('go2') }
								end
								fput 'release' unless checkprep == 'None'
								echo 'waiting on mana... or evil people to go away...'
								wait_until { spell.affordable? or hidden? or invisible? or not checkpcs.to_a.any? { |pc| evil_pcs.include?(pc) } }
							end
						else
							fput 'release' unless checkprep == 'None'
							echo 'waiting on mana... or evil people to go away...'
							wait_until { spell.affordable? or hidden? or invisible? or not checkpcs.to_a.any? { |pc| evil_pcs.include?(pc) } }
						end
					end
				else
					fput 'release' unless checkprep == 'None'
					echo 'waiting for mana or spirit...'
					wait_until { spell.affordable? or sign_of_wracking.affordable? }
				end
			end
		else
			fput 'release' unless checkprep == 'None'
			echo 'waiting for mana...'
			wait_until { spell.affordable? }
		end
	end
}

release_spell = proc {
	unless checkprep == 'None'
		dothistimeout 'release', 5, /^You feel the magic of your spell rush away from you\.$|^You don't have a prepared spell to release!$/
	end
}

cast_spell = proc { |spell, target|
	spell = fix_spell.call(spell)
	result = nil
	loop {
		check_mana.call(spell)
		if target == Char.name.downcase
			if spell.num == 1014 and ASG != nil
				cast_result = spell.cast("#{ASG}")
			elsif spell.num == 1009 and sonic_shield != nil
				cast_result = spell.cast("#{sonic_shield}")
			elsif spell.num == 1012 and sonic_weapon != nil
				cast_result = spell.cast("#{sonic_weapon}")
			else
				cast_result = spell.cast();
			end
		else
			cast_result = spell.cast("at #{target}")
		end
		if cast_result =~ /^Be at peace my child, there is no need for spells of war in here\.$|Spells of War cannot be cast/
			result = :bad_spell
			break
		elsif cast_result == 'Cast at what?'
			result = :bad_target
			break
		elsif cast_result =~ /^\[Spell Hindrance for/
			nil # try again
		else
			result = :success
			break
		end
	}
	result
}

get_target_info = proc { |target|
	if defined?(LNet.get_data)
		LNet.get_data(target, 'spells')
	else
		nil
	end
}

#
# gather current spell info for the targets
#
target_info = Hash.new
target_list.each { |name|
	if name.downcase == Char.name.downcase
		target_info[Char.name.downcase] = Hash.new
		Spell.active.each { |spell| target_info[Char.name.downcase][spell.num.to_s] = spell.timeleft }
	elsif skip_jerks
		spell_info = get_target_info.call(name)
		if spell_info.nil?
			echo "skipping #{name}: spell info refused"
		elsif spell_info == false
			echo "skipping #{name}: spell info failure"
		else
			target_info[name.downcase] = spell_info
		end
	else
		target_info[name.downcase] = get_target_info.call(name) || Hash.new
	end
}

if list_mode
	dry_run = Hash.new
	max_spell_name = 0
	cast_list.each { |spell|
		spell = fix_spell.call(spell)
		next unless spell.stacks
		max_spell_name = [ max_spell_name, spell.name.length ].max
		target_info.keys.each { |name|
			next if (spell.num == 1601) and (name != Char.name.downcase)
			next if spell.selfonly and (name != Char.name.downcase)
			next if (name == Char.name.downcase) and (spell.circlename == 'Bard') and spell.active?
			target_info[name][spell.num.to_s] ||= 0
			dry_run[name] ||= Hash.new
			if target_info[name][spell.num.to_s] < start_at
				while ( (target_info[name][spell.num.to_s] < stop_at) and (target_info[name][spell.num.to_s] + spell.time_per) < stop_before )
					dry_run[name][spell.num.to_s] = dry_run[name][spell.num.to_s] + 1
					target_info[name][spell.num.to_s] += spell.time_per
				end
			end
		}
	}
	cast_list.each { |spell|
		spell = fix_spell.call(spell)
		next if spell.stacks and (spell.num != 1601)
		max_spell_name = [ max_spell_name, spell.name.length ].max
		target_info.keys.each { |name|
			next if (spell.num == 1601) and (name != Char.name.downcase)
			next if spell.selfonly and (name != Char.name.downcase)
			next if (name == Char.name.downcase) and (spell.num >= 1001) and (spell.num <= 1050) and spell.active?
			target_info[name][spell.num.to_s] ||= 0
			if (target_info[name][spell.num.to_s] < unstackable_min)
				dry_run[name][spell.num.to_s] = dry_run[name][spell.num.to_s] + 1
			end
		}
	}
	get_bonus_string = proc { |spell|
		bonus_list = Array.new
		bonus_list.push "#{'+' if spell.bolt_as > 0}#{spell.bolt_as} bAS" unless spell.bolt_as.zero?
		bonus_list.push "#{'+' if spell.physical_as > 0}#{spell.physical_as} pAS" unless spell.physical_as.zero?
		bonus_list.push "#{'+' if spell.bolt_ds > 0}#{spell.bolt_ds} bDS" unless spell.bolt_ds.zero?
		bonus_list.push "#{'+' if spell.physical_ds > 0}#{spell.physical_ds} pDS" unless spell.physical_ds.zero?
		bonus_list.push "#{'+' if spell.elemental_cs > 0}#{spell.elemental_cs} eCS" unless spell.elemental_cs.zero?
		bonus_list.push "#{'+' if spell.spirit_cs > 0}#{spell.spirit_cs} spCS" unless spell.spirit_cs.zero?
		bonus_list.push "#{'+' if spell.sorcerer_cs > 0}#{spell.sorcerer_cs} soCS" unless spell.sorcerer_cs.zero?
		bonus_list.push "#{'+' if spell.elemental_td > 0}#{spell.elemental_td} eTD" unless spell.elemental_td.zero?
		bonus_list.push "#{'+' if spell.spirit_td > 0}#{spell.spirit_td} spTD" unless spell.spirit_td.zero?
		bonus_list.push "#{'+' if spell.sorcerer_td > 0}#{spell.sorcerer_td} soTD" unless spell.sorcerer_td.zero?
		bonus_list.push "#{'+' if spell.strength.to_i > 0}#{spell.strength} str" unless spell.strength.to_i.zero?
		bonus_list.push "#{'+' if spell.dodging.to_i > 0}#{spell.dodging} dodge" unless spell.dodging.to_i.zero?
		bonus_list.join(', ')
	}
	total_casts = 0
	total_mana  = 0
	output = "\n"
	for name,hash in dry_run
		if hash.empty?
			output.concat "#{name.capitalize}: no spells needed\n"
		else
			output.concat "#{(name.capitalize + ':').ljust(8+max_spell_name)}casts  mana  duration  bonus\n"
			for spell,casts in hash
				spell = Spell[spell]
				total_casts += casts
				total_mana += casts * spell.mana_cost
				output.concat "#{spell.num.to_s.rjust(4)}  #{spell.name.ljust(max_spell_name)}  #{casts.to_s.rjust(5)}  #{(spell.mana_cost*casts).to_s.rjust(4)}   #{(spell.time_per*casts).as_time}  #{get_bonus_string.call(spell)}\n"
			end
		end
		output.concat "\n"
	end
	output.concat "#{''.ljust(max_spell_name)}   total: #{total_casts.to_s.rjust(3)}  #{total_mana.to_s.rjust(4)}\n\n" unless total_casts.zero?
	respond output
else
	if cast_list.include?(625) and target_info.keys.include?(Char.name.downcase)
		name = Char.name.downcase
		target_info[name]['625'] ||= 0
		if (target_info[name]['625'] < unstackable_min)
			cast_spell.call(625, name)
		end
	end
	skip_targets = Array.new
	skip_spells = Array.new
	#
	# cast stackable spells
	#
	cast_list.each { |spell|
		next if spell == 625
		if use_concentration and (sigil_of_concentration = Spell[9714])
			sigil_of_concentration.cast if sigil_of_concentration.known? and sigil_of_concentration.affordable? and not sigil_of_concentration.active?
		end
		spell = fix_spell.call(spell)
		next unless spell.stacks
		target_info.keys.each { |name|
			next if (spell.num == 1601) and (name != Char.name.downcase)
			next if spell.selfonly and (name != Char.name.downcase)
			next if skip_targets.include?(name) or skip_spells.include?(spell.num)
			next if (name == Char.name.downcase) and (spell.circlename == 'Bard') and spell.active?
			target_info[name][spell.num.to_s] ||= 0
			if target_info[name][spell.num.to_s] < start_at
				need_chant = false
				while ( (target_info[name][spell.num.to_s] < stop_at) and (target_info[name][spell.num.to_s] + spell.time_per) < stop_before )
					need_chant = true if (spell.num == 712) and (name == Char.name.downcase)
					cast_result = cast_spell.call(spell, name)
					if cast_result == :bad_spell
						skip_spells.push(spell.num)
						break
					elsif cast_result == :bad_target
						skip_targets.push(name)
						break
					end
					target_info[name][spell.num.to_s] += spell.time_per
				end
				if need_chant and retribution_spell
					fput "chant retribution #{retribution_spell}"
				end
			end
		}
		release_spell.call
	}

	#
	# cast non-stacking spells
	#
	cast_list.each { |spell|
		next if spell == 625
		if use_concentration and (sigil_of_concentration = Spell[9714])
			sigil_of_concentration.cast if sigil_of_concentration.known? and sigil_of_concentration.affordable? and not sigil_of_concentration.active?
		end
		spell = fix_spell.call(spell)
		next if (spell.stacks and spell.num != 1601) or skip_spells.include?(spell.num)
		target_info.keys.each { |name|
			next if (spell.num == 1601) and (name == Char.name.downcase)
			next if spell.selfonly and (name != Char.name.downcase)
			next if skip_targets.include?(name) or skip_spells.include?(spell.num)
			next if (name == Char.name.downcase) and (spell.num >= 1001) and (spell.num <= 1050) and spell.active?
			target_info[name][spell.num.to_s] ||= 0
			if (target_info[name][spell.num.to_s] < unstackable_min)
				cast_result = cast_spell.call(spell, name)
				if cast_result == :bad_spell
					skip_spells.push(spell.num)
					break
				elsif cast_result == :bad_target
					skip_targets.push(name)
				end
			end
		}
		release_spell.call
	}

	echo 'done'
end
