=begin
  MechFire by Nisugi

  author: Nisugi
    name: MechFire
    tags: ranged crossbow mechanical combat
   version: 3.1


   This is a highly configurable combat script for use with a mechanical crossbow.

   It is designed with the sniper in mind. Depending on your settings, it will kneel
   hide, and kill every critter in the room until the room is cleared or it reaches
   the amount of kills you set to come out of hiding and loot. It will jump back in
   hiding and resume killing after looting.

   If you disable looting I recommend enabling single kill mode to prevent losing any
   corpses to decay from the room swarming.

   For more information please run ;mechfire help
=end


UserVars.mf                     ||= {}
UserVars.mf[:cocked]                = false       if UserVars.mf[:cocked].nil?
UserVars.mf[:ammo_count]              = 0         if UserVars.mf[:ammo_count].nil?
UserVars.mf[:kill_total]              = 0         if UserVars.mf[:kill_total].nil?

settings_info = {
  :quiver => 'Name of your quiver. \"leather quiver\" or \"thigh-quiver\"',
  :weapon => 'Noun of your weapon. \"longbow\" or \"crossbow\"',
  :targets => 'Targets you wish to attack. \"Thunder Troll, Zombie, ect.\"',
  :loot_script => 'Script you use for looting. \"sloot\", \"slootbeta\"',
  :heal_room => 'Room you want to use herbs in. Default: \"3824\"',
  :ammo_name => 'Name of your ammo. \"a faewood arrow\"',

  :ammo => 'Type of ammo your weapon uses. \"arrow\", \"heavy bolt\"',
  :ammo_max => 'Maximum number of rounds your magazine will hold.',
  :reload => 'Reload magazine when you reach this many rounds.',
  :hide_max => 'Maximum number of times to attempt hiding. Default: \"2\"',
  :heal_town => 'Go to town and healup if this many critters in the room.',
  :loot_kill => 'Pause combat and loot dead critters after killing this many.',

  :hide => 'Enables hiding.',
  :camo => 'Enables camouflage.',
  :kneel => 'Enables kneeling.',
  :gather => 'Enables basic gathering of ammo',
  :useherbs => 'Enables the use of ;useherbs to heal up.',
  :panic => 'Enables running to town and logging off if in trouble.',
  :debug => 'Enables debug messages.',
  :silence => 'Enables silent operation of script.',
  :loot => 'Enables mechfire to handle looting.',
  :killstreak => 'Enables kill streak messages.',
  :bundling_quiver => 'Enable if you have a bundling quiver and wish to let mechfire gather ammo.',
  :prep => 'Reload and cock crossbow at the end of combat.',

}

settings = CharSettings.to_hash

if settings[:silence]
  silence_me
end

rounds = {
  0 => 'Select one',
  1 => '1 round',
  2 => '2 rounds',
  3 => '3 rounds',
  4   => '4 rounds',
  5 => '5 rounds',
}
ammo_types = {
  0 => 'arrow',
  1 => 'light bolt',
  2 => 'heavy bolt',
  3 => 'self-ammo cb',
}
attempts = {
  0 => 'Select one',
  1 => '1 attempt',
  2 => '2 attempts',
  3 => '3 attempts',
  4   => '4 attempts',
  5 => '5 attempts',
}
critters = {
  0 => 'Select one',
  1 => '1 critter',
  2 => '2 critters',
  3 => '3 critters',
  4   => '4 critters',
  5 => '5 critters',
}
kills = {
  0 => 'Select one',
  1 => '1 kill',
  2 => '2 kills',
  3 => '3 kills',
  4   => '4 kills',
  5 => '5 kills',
  6 => '6 kills',
  7 => '7 kills',
  8 => '8 kills',
  9 => '9 kills',
  10  => '10 kills',
  11  => '11 kills',
  12  => '12 kills',
  13  => '13 kills',
  14  => '14 kills',
  15  => '15 kills',
  16  => '16 kills',
  17  => '17 kills',
  18  => '18 kills',
  19  => '19 kills',
  20  => '20 kills',
  21  => '21 kills',
  22  => '22 kills',
  23  => '23 kills',
  24  => '24 kills',
  25  => '25 kills',
}

quiver      = GameObj[settings[:quiver]]
npcs      = Hash.new
valid_targets = Hash.new
bundles     = Hash.new
need_heals    = nil
start_room    = nil
ammo      = nil
ammo_max    = nil
reload      = nil
threats     = nil
tokens      = nil
weapon      = nil
hide_fail   = nil
hide_max    = nil
go_camo     = nil
no_camo     = nil
no_hide     = nil
target      = nil
gkt       = nil
kill_count    = nil
kill_total    = nil
attack_count  = nil


fix_injury = proc{

  if settings[:debug]
    echo "fix_injury"
  end

  waitrt?
  fput "stand" until standing?
  fput "stance defensive" until checkstance == "defensive"

  if settings[:useherbs]
    Script.pause('mechfire')
    threats = GameObj.npcs.find_all {|i| i.status !~ /dead/}
    if threats.length > settings[:heal_town].to_i
      start_room = Room.current.id
      Script.run('go2', settings[:heal_room.to_s])
      Script.run('useherbs')
      Script.run('go2', start_room.to_s)
    else
      Script.run('useherbs', '--buy=off')
    end
  end

  need_heals = false

  if (Wounds.head > 0) || (Wounds.neck > 0) || (Wounds.abs > 0) || (Wounds.lhand > 0) || (Wounds.rhand > 0) || (Wounds.larm > 0) || (Wounds.rarm > 0) || (Wounds.chest > 0) || (Wounds.back > 0) || (Wounds.rleg > 0) || (Wounds.lleg > 0) || (Wounds.nerves > 0) || (Scars.head > 0) || (Scars.neck > 0) || (Scars.abs > 0) || (Scars.lhand > 0) || (Scars.rhand > 0) || (Scars.larm > 0) || (Scars.rarm > 0) || (Scars.chest > 0) || (Scars.back > 0) || (Scars.rleg > 0) || (Scars.lleg > 0) || (Scars.nerves > 0) || (percenthealth < 50)
    need_heals = true
  end

  if need_heals
    Script.pause('bigshot') if running? "bigshot"
    if settings[:panic]
      Script.run('go2', settings[:heal_room].to_s)
    end
    echo "***  Healing failed. Seek assistance.  ***"
    echo "***           Pausing Script           ***"
    Script.pause('mechfire')
  end

}

get_target = proc{

  if settings[:debug] == true
    echo "get_target"
  end

  tokens = settings[:targets].split(/,/)
  tokens.each do |i|
    if( i =~ /(.*)\(([a|b|c|d|e|f|g|h|i|j|A|B|C|D|E|F|G|H|I|J])\)/ )
      valid_targets[$1.downcase.strip] = $2.downcase.strip
    else
      valid_targets[i.downcase.strip] = 'a'
    end
  end

  npcs = GameObj.npcs.find_all { |i| i.status !~ /dead/ }
  if settings[:targets].length > 0
    npcs.delete_if { |npc| !valid_targets.include?(npc.name) }
  end
  npcs.delete_if { |npc| npc.noun =~ /child|traveller|scribe|merchant|dignitary|official|magistrate|jock/i && npc.name !~ /ethereal|celestial|unworldly/i }

  if (target == nil) && npcs.size > 0
    target = npcs.find { |npc| (npc.name =~ //)  && (npc.status !~ /dead|gone/) }
    (target = nil) if (target.name =~ /grizzled|ancient/) && (checkbounty !~ /hunt down and kill a particularly dangerous/)
    #(target = nil) if (target.type !~ /\baggressive\b/)
    attack_count = 0
  end

}

check_position = proc{

  if settings[:debug]
    echo "check_position"
  end

  if !checkleft
    fput "ready range"
  end

  if checkleft && GameObj.left_hand.name !~ /#{settings[:weapon]}/
    fput "stow left" until !checkleft
    fput "ready range"
  elsif checkleft && GameObj.left_hand.name =~ /#{settings[:weapon]}/
    weapon = GameObj.left_hand
  end

  if !checkleft
    echo "Cannot find your weapon."
    Script.pause('mechfire')
  end

  if checkright && (settings[:ammo].to_i != 0)
    fput "stow right"
  end

  while !checkkneeling && !checkstanding && !checkhidden
    sleep 0.1
    waitrt?
    fput "stand" until standing?
    fput "stance defensive" until checkstance == "defensive"
  end

}

check_kneel = proc{

  if settings[:debug] == true
    echo "check_kneel"
  end

  sleep 0.1
  waitrt?

  if (settings[:kneel] == true) && (checkkneeling != true)
    fput "kneel" until kneeling?
  end

}

check_hide = proc{

  if settings[:debug]
    echo "check_hide"
  end

  hide_fail = 0
  hide_max = settings[:hide_max].to_i
  go_camo = false

  if checkoutside || (!checkoutside && Spell[625].active?)
    go_camo = true
  end

  fput "stance defensive" if checkstance != "defensive" && !checkhidden

=begin
  while !checkhidden && settings[:hide] && (hide_fail < hide_max)
    if settings[:camo] && Spell[608].affordable? && !Spell[608].active? && Spell[608].known? && go_camo && !no_camo
      sleep 0.1
      waitcastrt?
      waitrt?
      fput "incant 608"

      while line = get
        if line =~ /^You are unable to call the power to camouflage yourself here\.$|but can\'t see anywhere to hide/
          no_camo = true
          break
        elsif line =~ /notices your attempt to hide\!$|^You don't have a spell prepared\!$|^Your armor prevents the spell from working correctly\.$/
          hide_fail += 1
          break
        elsif line =~ /^You blend into invisibility among the surroundings\.$/
          break
        end
      end

    elsif !checkhidden && !no_hide
      sleep 0.1
      waitrt?
      fput "hide"

      while line = get
        if line =~ /^You look around\, but can\'t see anywhere to hide\./
          no_hide = true
          break
        elsif line =~ /notices your attempt to hide\!$|^You fail to slip into hiding\.$/
          hide_fail += 1
          break
        elsif line =~ /^You attempt to blend with the surroundings\, and feel confident that no one has noticed your doing so\.$/
          break
        end
      end

    end
  end
=end


  while !checkhidden && settings[:hide] && (hide_fail < hide_max)
    if settings[:camo] && Spell[608].affordable? && !Spell[608].active? && Spell[608].known? && go_camo && !no_camo
        waitcastrt?
        waitrt?
        res = dothistimeout "incant 608", 2, /^You are unable to call the power to camouflage yourself here\.$|^You look around\, but can\'t see anywhere to hide|^You attempt to blend with the surroundings\, and feel confident that no one has noticed your doing so\.$|You blend into invisibility among the surroundings\.$|^Your armor prevents the spell from working correctly\.$|notices your attempt to hide\!$|^You don't have a spell prepared\!$/
        if res =~ /^You are unable to call the power to camouflage yourself here\.$|but can\'t see anywhere to hide/
          echo "Can't camouflage here, moving on"
          no_camo = true
        elsif res =~ /notices your attempt to hide\!$|^You don't have a spell prepared\!$/
          hide_fail += 1
        end
    elsif !checkhidden && settings[:hide] && !no_hide
      res = dothistimeout "hide", 2, /^You are unable to call the power to camouflage yourself here\.$|^You look around\, but can\'t see anywhere to hide|^You attempt to blend with the surroundings\, and feel confident that no one has noticed your doing so\.$|You blend into invisibility among the surroundings\.$|^Your armor prevents the spell from working correctly\.$|notices your attempt to hide\!$|^You fail to slip into hiding\.$/
      if res =~ /but can\'t see anywhere to hide/
        echo "Can't hide here, moving on"
        no_hide = true
        break
      elsif res =~ /notices your attempt to hide\!$|^You fail to slip into hiding\.$/
        hide_fail += 1
      end
    end
  end


  if hide_fail >= hide_max
    echo "Perceptive creature preventing hide attempt. Increase max hide attempts if you want to attempt to hide more than #{settings[:hide_max]} times."
  end

}

check_reload = proc{

  if settings[:debug] == true
    echo "check_reload"
  end

  ammo = UserVars.mf[:ammo_count].to_i
  ammo_max = settings[:ammo_max].to_i
  reload = settings[:reload].to_i
  waitrt?

  if ammo <= reload
    while ammo < ammo_max
      sleep 0.1
      waitrt?
      fput "get 1 #{ammo_types[settings[:ammo]]} from ##{quiver.id}"
      while line = get
        if line =~ /^Get what\?$/
          echo "Out of ammo, Please restock."
          Script.pause('mechfire')
        elsif line =~ /^You get|^You remove/
          break
        end
      end

      sleep 0.1
      fput "load my #{weapon}"
      while line = get
        if line =~ /^You flip open the stock of your .+? and load .+? into it\./
          ammo += 1
          break
        elsif line =~ /^But your .+? can only hold up to .+?\!$/
          ammo = ammo_max
          fput "stow right" until !checkright
          break
        elsif line =~ /^You must be holding something to load into your .+?\.$/
          echo "Cannot find your ammo, Please restock."
          Script.pause('mechfire')
        end
      end
    end
  end

  UserVars.mf[:ammo_count] = ammo

}

check_cock = proc{

  if settings[:debug] == true
    echo "check_cock"
  end

  if UserVars.mf[:cocked] != true
    waitrt?
    fput "stance offensive" if checkstance != "offensive"
    res = dothistimeout "cock my #{weapon}", 2, /^You draw back on the bowstring of your .+? to whirl\, lifting .+? from the interior and snapping it into place\.|You cock your .+?\.$|^You must be holding .+? to cock it\.$|^The .+? is already cocked\.$/

    if res =~ /^You draw back on the bowstring of your .+? to whirl\, lifting .+? from the interior and snapping it into place\.|You cock your .+?\.$/
      UserVars.mf[:cocked] = true

    elsif res =~ /^You must be holding .+? to cock it\.$/
      echo "investigate how you got to check_cock without #{weapon} in hand."
      echo "*** Pausing Script ***"
      Script.pause('mechfire')
      #second attempt at cocking to added later
      #fput "stow left" if checkleft !~ /#{weapon}/
      #fput "ready ##{weapon.id}"
      #res2 = dothistimeout "cock my #{weapon}", 2, /^You draw back on the bowstring of your .+? to whirl\, lifting .+? from the interior and snapping it into place\.|You cock your .+?\.$|^You must be holding .+? to cock it\.$|^The .+? is already cocked\.$/

      #if res2 =~ /^You draw back on the bowstring of your .+? to whirl\, lifting .+? from the interior and snapping it into place\.|You cock your .+?\.$/
      # UserVars.mf[:cocked] = true
      #elsif res2 =~ /^The .+? is already cocked\.$/
      # UserVars.mf[:cocked] = true
      # echo "Error cc-1: Please send log to investigate how you ended up here. @Getho#5573 on discord."
      #elsif res2 =~ /^You must be holding .+? to cock it\.$/
      # echo "Cannot find your #{weapon}. Pausing."
      # Script.pause('mechfire')
      #end

    elsif res =~ /^The .+? is already cocked\.$/
      UserVars.mf[:cocked] = true
      echo "Error cc-1: Please send log to investigate how you ended up here. @Getho#5573 on discord."
    end
  end

}

attack_target = proc{

  if settings[:debug]
    echo "attack_target"
  end

  fput "stance offensive" if checkstance != "offensive"
  if settings[:ammo] == 1 || settings[:ammo] == 2
    fput "fire ##{target.id}" if target != nil

    while line = get
      if line =~ /^You fire .+? at .+?\!$/
        UserVars.mf[:ammo_count] -= 1
        UserVars.mf[:cocked] = false
        attack_count += 1
        break
      elsif line =~ /^You dry fire your .+?\.$/
        UserVars.mf[:ammo_count] = 0
        UserVars.mf[:cocked] = false
        break
      elsif line =~ /\.\.\.wait .+? seconds\.$/
        break
      elsif line =~ /^But your .+? is not cocked\!$/
        UserVars.mf[:cocked] = false
        break
      elsif line =~ /^You do not currently have a target\.$|^I could not find what you were referring to\.$|^A .+? is quite dead already\.$/
        target = nil
        break
      elsif line =~ /^You are too injured to fire that\!$/
        fix_injury.call
        break
      end
    end

  elsif settings[:ammo] == 3
    fput "fire ##{target.id}" if target != nil

    while line = get
      if line =~ /^You fire .+? at .+?\!$/
        #UserVars.mf[:ammo_count] -= 1
        UserVars.mf[:cocked] = false
        attack_count += 1
        break
      elsif line =~ /^You dry fire your .+?\.$/
        #UserVars.mf[:ammo_count] = 0
        UserVars.mf[:cocked] = false
        break
      elsif line =~ /\.\.\.wait .+? seconds\.$/
        break
      elsif line =~ /^But your .+? is not cocked\!$/
        UserVars.mf[:cocked] = false
        break
      elsif line =~ /^You do not currently have a target\.$|^I could not find what you were referring to\.$|^A .+? is quite dead already\.$/
        target = nil
        break
      elsif line =~ /^You are too injured to fire that\!$/
        fix_injury.call
        break
      end
    end

  elsif settings[:ammo] == 0
    multifput "get 1 #{ammo_types[settings[:ammo]]} from ##{quiver.id}", "fire ##{target.id}"

    while line = get
      if line =~ /^Get what\?$/
        echo "Out of ammo, Please restock."
        Script.pause('mechfire')
        break
      elsif line =~ /^You fire .+? at .+?\!$/
        attack_count += 1
        break
      elsif line =~ /^You do not currently have a target\.$|^I could not find what you were referring to\.$|^A .+? is quite dead already\.$/
        target = nil
        break
      elsif line =~ /\.\.\.wait .+? seconds\.$/
        pause 0.1
        waitrt?
        check_position.call
        break
      elsif line =~ /^You are too injured to fire that\!$/
        fix_injury.call
        break
      end
    end
  end
  waitrt?

}

gather_ammo = proc{

  if settings[:debug]
    echo "gather_ammo"
  end

  if quiver.contents == nil
    fput "look in ##{quiver.id}"
  end

  quiver.contents.each do |b|
    if bundles[:b1] == nil
      bundles[:b1] = [b.id, b.noun]
    elsif bundles[:b2] == nil
      bundles[:b2] = [b.id, b.noun]
    elsif bundles[:b3] == nil
      bundles[:b3] = [b.id, b.noun]
    elsif bundles[:b4] == nil
      bundles[:b4] = [b.id, b.noun]
    elsif bundles[:b5] == nil
      bundles[:b5] = [b.id, b.noun]
    end
  end

  ammo = GameObj.loot.to_a.find do |l|
    l.type =~ /ammo/
  end

  if ammo.nil?
    exit
  end

  loop do
    res = dothistimeout "gather #{ammo_types[settings[:ammo]]}", 2, /out of your reach\.|^You gather \d+ (.*) into a bundle on the ground\.$|^You pick up the (.*), but can find no others like it\.$|^You gather \d+ (.*) into a bundle\.$|You may not combine/

    if res =~ /^You gather \d+ (.*) into a bundle on the ground\.$/
      fput "_drag ##{ammo.id} ##{bundles[:b1][0]}"
      break

    elsif res =~ /^You gather \d+ (.*) into a bundle\.$|^You pick up the (.*), but can find no others like it\.$/
      fput "put ##{GameObj.right_hand.id} in ##{bundles[:b1][0]}"
      break

    elsif res =~ /out of your/
      sleep 1
    end

  end


}

gather_ammo_quiver = proc{

  if settings[:debug]
    echo "gather_ammo_quiver"
  end

  ammo = GameObj.loot.to_a.find do |l|
    l.type =~ /ammo/
  end

  if ammo.nil?
    exit
  end

  loop do
    res = dothistimeout "gather #{ammo_types[settings[:ammo]]}", 2, /out of your reach\.|^You gather \d+ (.*) into a bundle on the ground\.$|^You pick up the (.*), but can find no others like it\.$|^You gather \d+ (.*) into a bundle\.$|You may not combine/

    if res =~ /^You gather \d+ (.*) into a bundle on the ground\.$/
      fput "_drag ##{ammo.id} #{quiver}"
      break

    elsif res =~ /^You gather \d+ (.*) into a bundle\.$|^You pick up the (.*), but can find no others like it\.$/
      fput "put #{GameObj.right_hand} in my #{quiver}"
      break

    elsif res =~ /out of your/
      sleep 1
    end

  end

}

kill_streak = proc{

  if settings[:debug]
    echo "kill_streak"
  end

  if kill_total == 5
    echo "** 5 KILL STREAK **"
  elsif kill_total == 10
    echo "** 10 KILL STREAK **"
  elsif kill_total == 15
    echo "** 15 KILL STREAK **"
  elsif kill_total == 20
    echo "** 20 KILL STREAK **"
  elsif kill_total == 25
    echo "** 25 KILL STREAK **"
  elsif kill_total == 50
    echo "** 50 KILL STREAK **"
  elsif kill_total == 75
    echo "** 75 KILL STREAK **"
  elsif kill_total == 100
    echo "** 100 KILL STREAK **"
  end

}

setup = proc{

  gtk_locals = Hash.new
  window = window_action = nil

  Gtk.queue{
#   ttips = Gtk::Tooltips.new.enable
    ttips_text = {
      :quiver => 'Name of the quiver you wish to use. ie, ebonwood thigh-quiver or leather quiver',
      :weapon => 'Noun of your weapon. ie, crossbow or longbow',
      :targets => 'Targets you wish to kill. Leave blank to clear entire room. If using bigshot, put the same targets in this box to only kill specific targets.',
      :loot_script => 'Script you use to loot with. ie, sloot or slootbeta',
      :heal_room => 'Room in town you want to ;useherbs in.',
      :ammo_name => 'Name of the ammo you wish to use. ie, a faewood bolt',

      :ammo => 'Type of ammo you are using. ie, arrow, light bolt, heavy bolt',
      :ammo_max => 'Maximum ammo your magazine will hold. Please select a value even if you\'re not using a mechanical crossbow.',
      :reload => 'Reload when your magazine reaches this number of rounds. Please select a value even if you\'re not using a mechanical crossbow.',
      :hide_max => 'Maximum attempts to hide before skipping. Please select a value even if you\'re not hiding.',
      :heal_town => 'Will go to town to heal if injured and there are this many creatures in your room. Please select a value even if you\'re not using the useherbs option.',
      :loot_kill => 'Will pause combat to loot corpses after killing this many creatures. Set low if you are slow to kill and do not want corpses decaying. Please select a high value if you don\'t enable the looting option.',

      :hide => 'Enables hiding.',
      :camo => 'Enables camouflage.',
      :kneel => 'Enables kneeling.',
      :gather => 'Enables basic ammo gathering and bundling. You can break your bundle up into bundles of 24 inside a warrior quiver for weightless bundles. This option will keep the bundles seperate. Multiple types of ammo in the same quiver can cause problems.',
      :useherbs => 'Enables using ;useherbs to heal.',
      :panic => 'Enables running back to town if you get in trouble.',
      :debug => 'Enables debug messages.',
      :silence => 'Enables silent mode.',
      :loot => 'Enables allowing mechfire to handle looting using your prefered loot script.',
      :killstreak => 'Enables kill streak messaging',
      :bundling_quiver => 'Enable if you have an auto bundling quiver and wish to allow mechfire to gather your ammo. Must also enable Gather Ammo.',
      :prep => 'Enables reloading and cocking of crossbow at end of combat.',
      :solo => 'Enables killing a single target and ending script.',
      :meh => 'Placeholder to make interface look nice.',
      :meh2 => 'Placeholder to make interface look nice',
    }

    gtk_locals[:quiver] = Gtk::Entry.new; gtk_locals[:quiver].text = (settings[:quiver] ||= "")
    gtk_locals[:weapon] = Gtk::Entry.new; gtk_locals[:weapon].text = (settings[:weapon] ||= "")
    gtk_locals[:targets] = Gtk::Entry.new; gtk_locals[:targets].text = (settings[:targets] ||= "")
    gtk_locals[:loot_script] = Gtk::Entry.new; gtk_locals[:loot_script].text = (settings[:loot_script] ||= "")
    gtk_locals[:heal_room] = Gtk::Entry.new; gtk_locals[:heal_room].text = (settings[:heal_room] ||= "")
    gtk_locals[:ammo_name] = Gtk::Entry.new; gtk_locals[:ammo_name].text = (settings[:ammo_name] ||= "")

    gtk_locals[:ammo] = gtk_locals[:ammo_max] = gtk_locals[:reload] = gtk_locals[:hide_max] = gtk_locals[:heal_town] = gtk_locals[:loot_kill] = Gtk::ComboBoxText.new()

    gtk_locals[:hide] = Gtk::CheckButton.new('Hide'); gtk_locals[:hide].active = (settings[:hide] ||= false)
    gtk_locals[:camo] = Gtk::CheckButton.new('Camouflage'); gtk_locals[:camo].active = (settings[:camo] ||= false)
    gtk_locals[:kneel] = Gtk::CheckButton.new('Kneel'); gtk_locals[:kneel].active = (settings[:kneel] ||= false)
    gtk_locals[:gather] = Gtk::CheckButton.new('Gather Ammo'); gtk_locals[:gather].active = (settings[:gather] ||= false)
    gtk_locals[:useherbs] = Gtk::CheckButton.new('Useherbs'); gtk_locals[:useherbs].active = (settings[:useherbs] ||= false)
    gtk_locals[:panic] = Gtk::CheckButton.new('Panic Mode'); gtk_locals[:panic].active = (settings[:panic] ||= false)
    gtk_locals[:debug] = Gtk::CheckButton.new('Debug Mode'); gtk_locals[:debug].active = (settings[:debug] ||= false)
    gtk_locals[:silence] = Gtk::CheckButton.new('Silence'); gtk_locals[:silence].active = (settings[:silence] ||= false)
    gtk_locals[:loot] = Gtk::CheckButton.new('Loot'); gtk_locals[:loot].active = (settings[:loot] ||= false)
    gtk_locals[:killstreak] = Gtk::CheckButton.new('Kill Streak'); gtk_locals[:killstreak].active = (settings[:killstreak] ||= false)
    gtk_locals[:bundling_quiver] = Gtk::CheckButton.new('Bundling Quiv'); gtk_locals[:bundling_quiver].active = (settings[:bundling_quiver] ||= false)
    gtk_locals[:prep] = Gtk::CheckButton.new('Prep'); gtk_locals[:prep].active = (settings[:prep] ||= false)
    gtk_locals[:solo] = Gtk::CheckButton.new('Single'); gtk_locals[:solo].active = (settings[:solo] ||= false)
    gtk_locals[:meh] = Gtk::CheckButton.new('TBD'); gtk_locals[:meh].active = (settings[:meh] ||= false)
    gtk_locals[:meh2] = Gtk::CheckButton.new('TBD'); gtk_locals[:meh2].active = (settings[:meh2] ||= false)

    x = 0
    while x < ammo_types.length
      gtk_locals[:ammo].append_text(ammo_types[x])
      x += 1
    end
    x = 0
    while x < rounds.length
      gtk_locals[:ammo_max].append_text(rounds[x])
      gtk_locals[:reload].append_text(rounds[x])
      x += 1
    end
    x = 0
    while x < attempts.length
      gtk_locals[:hide_max].append_text(attempts[x])
      x += 1
    end
    x = 0
    while x < critters.length
      gtk_locals[:heal_town].append_text(critters[x])
      x += 1
    end
    x = 0
    while x < kills.length
      gtk_locals[:loot_kill].append_text(kills[x])
      x += 1
    end
    gtk_locals[:ammo].active = (settings[:ammo].to_i)
    gtk_locals[:ammo_max].active = (settings[:ammo_max].to_i)
    gtk_locals[:reload].active = (settings[:reload].to_i)
    gtk_locals[:hide_max].active = (settings[:hide_max].to_i)
    gtk_locals[:heal_town].active = (settings[:heal_town].to_i)
    gtk_locals[:loot_kill].active = (settings[:loot_kill].to_i)

    ttips_text.each_pair { |widget, tip|
      if widget = gtk_locals[widget]
        widget.set_tooltip_text(tip).has_tooltip = true
      end
    }

    #Primary window
    window = Gtk::Window.new
    window.title = "MechFire"
    window.border_width = 3
    window.resizable = true

    #Notebook for tabs
    nb = Gtk::Notebook.new.set_show_border(true)

    #Notbeook 1
    vb_pg1 = Gtk::Box.new(:vertical, 1).set_border_width(3)

    #Page 1, Frame 1
    vb_pg1_1 = Gtk::Box.new(:vertical, 1).set_border_width(3)
    fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Settings</b></big>'))
    fr_pg1_1.add(vb_pg1_1)
    vb_pg1.pack_start(fr_pg1_1,:expand => false, :fill => false, :padding => 0)

    #Add label if wanted
    #lbl = Gtk::Label.new.set_markup("SLoot features sorting of loot by allowing you to specify " +
    #        "a sack for each type of loot. Use the fields below to set the sack(s) for " +
    #        "each loot type.")
    #    lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
    #    vb_pg1_1.pack_start(lbl,false)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Ammo Type: ')).set_width_request(75))
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:ammo].set_width_request(100)))
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Quiver: ')).set_width_request(70))
    hb.pack_start(gtk_locals[:quiver],:expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal,1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Max Ammo: ')).set_width_request(75))
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:ammo_max].set_width_request(100)))
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Weapon: ')).set_width_request(70))
    hb.pack_start(gtk_locals[:weapon], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Reload at: ')).set_width_request(75))
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:reload].set_width_request(100)))
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Ammo: ')).set_width_request(70))
    hb.pack_start(gtk_locals[:ammo_name], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Targets: ')).set_width_request(80))
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:targets].set_width_request(342)))
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Max Hide: ')).set_width_request(60))
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:hide_max].set_width_request(100)))
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:hide].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:camo].set_width_request(120)), :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:meh].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:solo].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:prep].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:kneel].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

    #Page 1, Frame 2
    vb_pg1_2 = Gtk::Box.new(:vertical, 1).set_border_width(3)
    fr_pg1_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Looting</b></big>'))
    fr_pg1_2.add(vb_pg1_2)
    vb_pg1.pack_start(fr_pg1_2,:expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:loot].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:gather].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:bundling_quiver].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:meh2].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:vertical, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Loot After: ')).set_width_request(80), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:loot_kill].set_width_request(100)))
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Loot Script: ')).set_width_request(70), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals[:loot_script], :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    #Page 1, Frame 3
    vb_pg1_3 = Gtk::Box.new(:vertical, 1).set_border_width(3)
    fr_pg1_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Healing</b></big>'))
    fr_pg1_3.add(vb_pg1_3)
    vb_pg1.pack_start(fr_pg1_3, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:useherbs].set_width_request(129)), :expand => false, :fill => false, :padding => 0)
    vb_pg1_3.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Heal In Town: ')).set_width_request(80), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:heal_town].set_width_request(100)))
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Heal Room: ')).set_width_request(70), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals[:heal_room], :expand => false, :fill => false, :padding => 0)
    vb_pg1_3.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    #Page 1, Frame 4
    vb_pg1_4 = Gtk::Box.new(:vertical, 1).set_border_width(3)
    fr_pg1_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced</b></big>'))
    fr_pg1_4.add(vb_pg1_4)
    vb_pg1.pack_start(fr_pg1_4, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:debug].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:silence].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:killstreak].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals[:panic].set_width_request(100)), :expand => false, :fill => false, :padding => 0)
    vb_pg1_4.pack_start(hb, :expand => false, :fill => false, :padding => 0)




    nb.append_page(vb_pg1,Gtk::Label.new('Settings'))

    #Save/Close buttons
    hb_saveclose = Gtk::Box.new(:horizontal)
    save = Gtk::Button.new(:label => '_Save & Close')
    close = Gtk::Button.new(:label => 'E_xit')

    save.signal_connect('clicked') { window_action = :save }
    close.signal_connect('clicked') { window_action = :done }

    hb_saveclose.pack_start(save, :expand => false, :fill => false, :padding => 0)
    hb_saveclose.pack_start(close, :expand => false, :fill => false, :padding => 0)

    vb_main = Gtk::Box.new(:vertical, 5)
    vb_main.border_width = 3
    vb_main.pack_start(nb, :expand => false, :fill => false, :padding => 0)
    vb_main.pack_start(Gtk::Alignment.new(1,0,0,0).add(hb_saveclose), :expand => false, :fill => false, :padding => 0)

    window.signal_connect('delete_event') { window_action = :exit }

    window.add(vb_main)
    window.show_all
    window.keep_above = true

  }

  before_dying { Gtk::queue { window.destroy} }
  wait_while { window_action.nil? }

  if window_action == :save
    gtk_locals.each_pair {|k,v|
      if v.class == Gtk::CheckButton
        settings[k] = v.active?
      elsif v.class == Gtk::ComboBoxText
        settings[k] = v.active
      elsif v.class == Gtk::Entry
        settings[k] = v.text.strip.downcase
      else
        echo "error: unknown local settings #{k} [#{v.class}]"
      end
    }
    echo 'settings saved'
  else
    echo 'closed without saving'
  end

}

post_combat = proc{

  if settings[:debug]
    echo "post_combat"
  end

  sleep 0.1
  waitrt?
  fput "stand" if !checkstanding

  if settings[:loot]
    Script.run(settings[:loot_script])
  end

  if settings[:gather]
    if settings[:bundling_quiver]
      gather_ammo_quiver.call
    else
      gather_ammo.call
    end
  end

  if settings[:prep] && settings[:ammo] != 0
    check_reload.call if settings[:ammo] != 3
    check_cock.call
  end

  waitrt?
  fput "stance defensive" if checkstance != "defensive"

  gkt = UserVars.mf[:kill_total]
  gkt += kill_total
  UserVars.mf[:kill_total] = gkt

  if settings[:killstreak]
    echo "You have killed #{kill_total} critters this run!"
    echo "You have a lifetime kill total of #{gkt}!"
  end

  exit

}

if script.vars[1] == 'setup'
  setup.call
  exit

elsif variable[1].downcase == "help"

  print_option = proc do |option, msg, eg = "", pad = 2|
        if eg != ""
            msg = sprintf("%-20s #{$lich_char}#{script.name} #{eg}", msg)
        end

        respond(sprintf("  %s%-20s %s", " " * pad, option, msg))
    end

    respond("MechFire v2.0 by Getho")
    respond("")
    respond("MechFire is a combat script designed to be used with mechanical crossbows")
    respond("")
    respond("Basic usage: #{$lich_char}#{script.name}")
    respond("")
    respond("Extra commands:")
    print_option.call("help", "show this help message")
  print_option.call("setup", "GUI for setup")
    print_option.call("list", "list current settings")
    #print_option.call("stats", "displays your lifetime kills")
  #print_option.call("reload", "force a reload before you go into a big fight")
  #print_option.call("strike", "use blue crystal in holder on each first attack")
  #print_option.call("reset", "resets your settings back to nothing")
  #print_option.call("reset all", "resets global script variables used for tracking")
    respond("")
    respond("Available settings:")
  print_option.call("<option>", "<value>", "")
  respond ("")
    settings_info.each do |k, v|
        print_option.call(k, v)
    end
    respond("")

  exit

elsif script.vars[1] == 'list'

    respond('=======================')
    respond('   MechFire settings   ')
    respond('=======================')
  settings.each do |k, v|
    #if k !~ /is_cocked|death_count_total|need_crystal|ammo_count/
      puts("#{monsterbold_start}#{k}#{monsterbold_end}: #{v}")
    #end
  end
  exit

elsif script.vars[1] == 'test'

  settings.delete_if {|k,v| (k != nil) || (v != nil)}
  UserVars.mechfire.delete_if {|k,v| (k != nil) || (v != nil)}
  UserVars.mf.delete_if {|k,v| (k != nil) || (v != nil)}

  exit

end

warning_count = 0

if settings[:reload] == 0 && (settings[:ammo] != 0 || settings[:ammo] != 3)
  echo "Warning: Please run ;mechfire setup and select a value to reload at."
  warning_count += 1
end
if settings[:loot_kill] == 0 && settings[:loot]
  echo "Warning: Please run ;mechfire setup and select a value to loot at."
  warning_count += 1
end
if settings[:ammo_max] == 0 && (settings[:ammo] != 0 || settings[:ammo] != 3)
  echo "Warning: Please run ;mechfire setup and select a value for your maximum ammo."
  warning_count += 1
end
if settings[:hide_max] == 0 && settings[:hide]
  echo "Warning: Please run ;mechfire setup and select a value for your maximum hide attempts."
  warning_count += 1
end
if settings[:heal_town] == 0 && settings[:useherbs]
  echo "Warning: Please run ;mechfire setup and select a value for how many creatures will cause you to run to town if you need to heal."
  warning_count += 1
end
if warning_count > 0
  echo "Error: Please fix warnings."
  exit
end

  if checkleft && GameObj.left_hand.name !~ /#{settings[:weapon]}/
    fput "stow left" until !checkleft
    fput "ready range"
  elsif checkleft && GameObj.left_hand.name =~ /#{settings[:weapon]}/
    weapon = GameObj.left_hand
  end

  no_camo = false
  no_hide = false
  kill_count = 0
  kill_total = 0
  get_target.call

  while target != nil
    check_position.call
    check_kneel.call if (target != nil) && settings[:ammo] != 0
    check_hide.call if (target != nil)
    sleep 0.1
    waitrt?
    check_reload.call if (target != nil) && settings[:ammo] != 0 && settings[:ammo] != 3
    check_cock.call if (target != nil) && settings[:ammo] != 0
    sleep 0.1
    waitcastrt?
    waitrt?
    attack_target.call if (target != nil) && (target.status !~ /dead|gone/)

    if target.status =~ /dead|gone/
      if target.status =~ /dead/
        if attack_count > 0
          kill_count += 1
          kill_total += 1
        end
        if settings[:solo]
          post_combat.call
          exit
        end
        if settings[:killstreak]
          kill_streak.call
        end
        if kill_count >= settings[:loot_kill].to_i && settings[:loot]
          fput "stance defensive" if checkstance != "defensive"
          Script.run(settings[:loot_script])
          kill_count = 0
        end
      end

      target = nil
    end

    get_target.call if (target == nil)
  end

  post_combat.call








exit
=begin
:heal_room = "318"  #room you want to use herbs in back at town
:heal_town = 2    #how many creatures need to be in the room to run to town instead of healing on the spot.
:panic = false    #takes you back to your healing room in case of emergency.
:useherbs = true  #when hurt will ;useherbs.
:debug = false    #Debug messages
:weapon = ""    #choice of bow
:quiver = ""    #quiver
:reload = 2     #reload when down to this number
:ammo_max = 5   #number of rounds clip holds
:ammo = 2     #type of ammo 0 - arrow, 1 - light bolt, 2 - heavy bolt.
:targets = ""   #targets to attack, leave blank to kill anything in the room.
:hide = false
:hide_max = 2
:camo = false
:kneel = false
:gather = false
=end
=begin
  fput "stance offensive" if checkstance != "offensive"
  if settings[:ammo].to_i == 1 || settings[:ammo].to_i == 2
    res = dothistimeout "fire ##{target.id}", 2, /^You fire .+? at .+?\!$|^You are too injured to fire that\!$|^You dry fire your .+?\.$|^You do not currently have a target\.$|^I could not find what you were referring to\.$|^A .+? is quite dead already\.$|^But your .+? is not cocked\!$|^\.\.\.wait .+? seconds\.$/

    if res =~ /^You fire .+? at .+?\!$/
      UserVars.mf[:ammo_count] -= 1
      UserVars.mf[:cocked] = false

    elsif res =~ /^But your .+? is not cocked\!$/
      UserVars.mf[:cocked] = false
      check_cock.call

    elsif res =~ /^You dry fire your .+?\.$/
      UserVars.mf[:ammo_count] = 0
      UserVars.mf[:cocked] = false
      fput "stance defensive" if checkstance != "defensive"
      check_reload.call

    elsif res =~ /\.\.\.wait .+? seconds\.$/
      pause 0.2
      waitrt?
      check_position.call

    elsif res =~ /^You do not currently have a target\.$|^I could not find what you were reffering to\.$|^A .+? is quite dead already\.$/
      target = nil

    elsif res =~ /^You are too injured to fire that\!$/
      fix_injury.call

    elsif res.nil?
      echo "*** Something is screwy in attack (1.1) ***"
      exit

    end
  elsif settings[:ammo].to_i == 0


    res = dothistimeout "get 1 #{ammo_types[settings[:ammo]]} from ##{quiver.id}", 1, /^You remove|^You get|^Get what\?$/

    if res =~ /^Get what\?$/
      echo "Out of ammo, Please restock."
      Script.pause('mechfire')
    elsif res.nil?
      echo "Error at-1: Please send log to investigate how you ended up here. @Getho#5573 on discord."
    end

    res = dothistimeout "fire ##{target.id}", 2, /^You fire .+? at .+?\!$|^You are too injured to fire that\!$|^You do not currently have a target\.$|^I could not find what you were referring to\.$|^A .+? is quite dead already\.$|^\.\.\.wait .+? seconds\.$/

    if res =~ /^You are too injured to fire that\!$/
      fix_injury.call

    elsif res =~ /\.\.\.wait .+? seconds\.$/
      pause 0.2
      waitrt?
      check_position.call

    elsif res =~ /^You do not currently have a target\.$|^I could not find what you were reffering to\.$|^A .+? is quite dead already\.$/
      target = nil

    elsif res =~ /^You fire .+? at .+?\!$/

    elsif res.nil?
      echo "*** Something is screwy in attack (1.1) ***"
      exit

    end

  end
=end
=begin
res = dothistimeout "get 1 #{ammo_types[settings[:ammo]]} from ##{quiver.id}", 1, /^You remove|^You get|^Get what\?$/
      if res =~ /^Get what\?$/
        echo "Out of ammo, Please restock."
        Script.pause('mechfire')
      elsif res.nil?
        echo "Error cr-1: Please send log to investigate how you ended up here. @Getho#5573 on discord."
      end

      res = dothistimeout "load my #{weapon}", 1, /^But your .+? can only hold up to .+?\!$|^You flip open the stock of your .+? and load .+? into it\.|You must be holding something to load into your .+?\.$/
      if res =~ /^You must be holding something to load into your .+?\.$/
        echo "Cannot find your ammo, Please restock."
        echo "Error cr-2: Please send log to investigate how you ended up here. @Getho#5573 on discord."
        Script.pause('mechfire')
      elsif res =~ /^But your .+? can only hold up to .+?\!$/
        ammo = ammo_max
        fput "stow right" until !checkright
      elsif res =~ /^You flip open the stock of your .+? and load .+? into it\./
        ammo += 1
      elsif res.nil?
        echo "Error cr-3: Please send log to investigate how you ended up here. @Getho#5573 on discord."
      end
=end
