=begin
  attunecheck.lic:
  Help find all the items that are attuned.
  Currently checks worn items and items in worn containers.
  Does not check items in nested containers.

        author: elanthia-online
          game: Gemstone
          tags: items, attuned
       version: 1.0.0

     Help Contribute: https://github.com/elanthia-online/scripts

  Version Control:
    Major_change.feature_addition.bugfix
  v1.0.0  (2026-01-06)
    - initial release

=end

module AttuneDetect
  # Main scanner class for detecting attuned items
  class Scanner
    ATTUNED_PATTERN = /^    This item is restricted to use by /
    ACCOUNT_RESTRICTED_PATTERN = / is restricted to this account\./
    LORESONG_PATTERN = /^It has a permanently unlocked loresong by /
    RECALL_RESPONSES = /^You are unable to recall |^As you recall /
    ANALYZE_RESPONSES = /^You analyze /

    CONTAINER_OPEN_RESPONSES = /<exposeContainer|That is already open|<container|There doesn't seem to be any way to do that\.|You/
    CONTAINER_LOOK_RESPONSES = /<exposeContainer|<dialogData|<container|you glance|There is nothing/i
    CONTAINER_INVALID_TYPES = /jewelry|weapon|armor|uncommon/
    CONTAINER_SKIP_TYPES = /gem|box/

    attr_reader :attuned_items

    def initialize
      @attuned_items = []
    end

    # Main execution method
    def scan
      scan_inventory
      populate_containers
      scan_containers
      display_results
    end

    private

    # Scan items in player's inventory
    def scan_inventory
      echo("Scanning #{GameObj.inv.count} inventory items...")

      GameObj.inv.each do |item|
        check_item_attunement(item) if item
      end
    end

    # Populate GameObj.containers by opening closed containers
    def populate_containers
      echo("Populating containers...")

      GameObj.inv.each do |item|
        next if container_already_populated?(item)
        next if skip_container?(item)

        open_and_inspect_container(item)
      end

      echo("Containers populated!")
    end

    # Scan items within containers
    def scan_containers
      GameObj.containers.each do |container_id, contents|
        next unless container_in_inventory?(container_id)

        scan_container_contents(container_id, contents)
      end
    end

    # Check if an item is attuned using recall/analyze
    def check_item_attunement(item)
      return if check_recall_attunement(item)
      check_analyze_attunement(item)
    end

    # Check attunement via recall command
    def check_recall_attunement(item)
      results = issue_recall_command(item)

      if attuned_response?(results)
        add_attuned_item(item)
        return true
      end

      loresong_response?(results)
    end

    # Check attunement via analyze command
    def check_analyze_attunement(item)
      results = issue_analyze_command(item)

      if account_restricted_response?(results)
        add_attuned_item(item)
        true
      else
        false
      end
    end

    # Issue recall command and return results
    def issue_recall_command(item)
      Lich::Util.issue_command(
        "recall ##{item.id}",
        RECALL_RESPONSES,
        usexml: true,
        quiet: true,
        silent: true
      )
    end

    # Issue analyze command and return results
    def issue_analyze_command(item)
      Lich::Util.issue_command(
        "analyze ##{item.id}",
        ANALYZE_RESPONSES,
        usexml: true,
        quiet: true,
        silent: true
      )
    end

    # Check if container is already populated
    def container_already_populated?(item)
      GameObj.containers.keys.include?(item.id) && item.contents.is_a?(Array)
    end

    # Check if container should be skipped
    def skip_container?(item)
      return true if item.type.nil?
      return true if item.type =~ CONTAINER_INVALID_TYPES
      false
    end

    # Open and inspect a container
    def open_and_inspect_container(item)
      return unless open_container(item)

      look_in_container(item)
      wait_for_container_population(item)
    end

    # Attempt to open a container
    def open_container(item)
      lines = Lich::Util.issue_command(
        "open ##{item.id}",
        CONTAINER_OPEN_RESPONSES,
        usexml: true,
        silent: true,
        quiet: true
      )

      !lines.any? { |line| line =~ /There doesn't seem to be any way to do that\./ }
    end

    # Look inside a container
    def look_in_container(item)
      lines = Lich::Util.issue_command(
        "look in ##{item.id}",
        CONTAINER_LOOK_RESPONSES,
        usexml: true,
        silent: true,
        quiet: true
      )

      lines.any? { |line| line !~ /You glance|There is nothing/i }
    end

    # Wait for container contents to be populated
    def wait_for_container_population(item, max_attempts = 20)
      max_attempts.times do
        break if container_already_populated?(item)
        sleep 0.1
      end
    end

    # Check if container is in player's inventory
    def container_in_inventory?(container_id)
      GameObj.inv.any? { |item| item.id == container_id }
    end

    # Scan contents of a specific container
    def scan_container_contents(container_id, contents)
      container_name = GameObj[container_id].name
      echo("Scanning #{contents.count} items in #{container_name}...")

      contents.each do |item|
        next if skip_container_item?(item)

        check_item_attunement(item)
      end
    end

    # Check if container item should be skipped
    def skip_container_item?(item)
      item.type =~ CONTAINER_SKIP_TYPES
    end

    # Check if results indicate attuned item
    def attuned_response?(results)
      results.any? { |line| line =~ ATTUNED_PATTERN }
    end

    # Check if results indicate loresong (skip these)
    def loresong_response?(results)
      results.any? { |line| line =~ LORESONG_PATTERN }
    end

    # Check if results indicate account-restricted item
    def account_restricted_response?(results)
      results.any? { |line| line =~ ACCOUNT_RESTRICTED_PATTERN }
    end

    # Add item to attuned items list
    def add_attuned_item(item)
      @attuned_items << item unless @attuned_items.include?(item)
    end

    # Display results to user
    def display_results
      echo("Found #{@attuned_items.count} attuned item(s):")

      @attuned_items.each do |item|
        display_item(item)
      end
    end

    # Display individual attuned item with command link
    def display_item(item)
      if GameObj.inv.include?(item)
        _respond("Attuned: #{item.name} - <d cmd='remove ##{item.id}'>remove</d>")
      else
        _respond("Attuned: #{item.name} - <d cmd='get ##{item.id}'>get</d>")
      end
    end
  end
end

# Execute the scanner
AttuneDetect::Scanner.new.scan
