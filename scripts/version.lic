=begin
  Reports versions of Lich, Ruby, and other important builtins, as well as other diagnostic information.
  Can also be used to show version of an installed script.
  
  Usage:
    ;version            - Will show general Ruby & Lich diagnostic info
    ;version <FILENAME> - Will show version info for the name given that is detected in install.

        author: elanthia-online
  contributors: LostRanger, Tysong, Doug
          game: gs
          tags: utility, version
      required: Lich > 5.0.1
       version: 0.57

  changelog:
    version 0.57 (2023-02-20)
      * Syntax & Style updates for Rubocop compliance
      
    version 0.56 (2023-01-23)
      * Update for Ruby v3 compatibility
      
    version 0.55 (2022-11-24)
      * removed references to $SAFE

    version 0.54 (2022-03-10)
      * add support for lib and ui folder.

    version 0.53 (2021-03-07)
      * fix ruby location report to RbConfig.bindir and rubyw 
      * detection to avoid special gem directory kerfuffles
  
    version 0.52 (2021-03-04)
      * fix ruby location report to Gem.bindir for cross platform use

    version 0.51 (2020-12-19)
      * add core engine algorithm to detect Cabal and LICH
      * add json to regex for file extension naming

    version 0.5 (2020-03-19)
      * Fix our exception handling not actually working.
      * Fix GTK version reporting, particularly w/ GTK3

    version 0.4 (2019-11-17)
      * Minor improvements.

    version 0.3 (2019-10-13)
      * ;version SCRIPT reports the currently-installed version of the specified script, if available.
        SCRIPT may be a partial name or 'all' for all installed scripts.

    version 0.2 (2019-10-07)
      * Now reports where the Ruby interpreter is.

    version 0.1 (2019-07-09)
      * First release.
=end

def const_get(sym, parent: Object, missing: 'not installed')
  return missing unless parent.const_defined?(sym)

  parent.const_get(sym).to_s
end

def module_version(sym)
  
  return 'not installed' unless Object.const_defined?(sym)

  o = Object.const_get(sym)
  return 'unknown' unless o.const_defined?(:VERSION)

  v = o::VERSION
  return v.join('.') if v.is_a?(Array)

  v.to_s
rescue StandardError
  'error'
  
end

def gtk_version
  
  return 'not installed' unless Object.const_defined?(:Gtk)
  return 'unknown' unless Gtk.const_defined?(:Version)

  Gtk::Version::STRING
rescue StandardError
  'error'
  
end

def format_report(report, width)
  report.map { |k, v| "#{k.ljust(width, '.')}: #{v}" }
end

def get_script_version(filename)
  data = File.open(filename, 'r').read
  if data =~ /^=begin\r?\n?(.+?)^=end/m
    comments = Regexp.last_match(1).split("\n")
  else
    comments = []
    data.split("\n").each do |line|
      if line =~ /^[\t\s]*#/
        comments.push(line)
      elsif line !~ /^[\t\s]*$/
        break
      end
    end
  end

  comments.each do |line|
    return Regexp.last_match(1).sub(/\s\(.*?\)/, '').strip if line =~ /^[\s\t#]*version:[\s\t]*([\w,\s.\d]+)/i
  end

  nil
end

def reward_source_divers
  first = true
  loop do
    5.times do |x|
      case x
      when 0
        next if first # Doesn't happen the first time around.

        _respond "It's a badger"
        sleep 0.4
      when 1
        _respond 'Badger'
        sleep 0.4
      end

      11.times do |y|
        if y.zero? && (x > 1)
          _respond 'A badger'
        else
          _respond 'Badger'
        end
        sleep 0.4
      end

      if x <= 2
        2.times do
          respond 'Mushroom'
          sleep 0.7
        end
      elsif x == 3
        respond 'Mush-'
        sleep 0.3
        respond '-Mushroom'
        sleep 0.7
      end
    end

    2.times do 
      _respond 'A...'
      sleep 0.2
      _respond 'snake'
      sleep 0.3
    end
    _respond 'Snaaake!'
    sleep 0.5
    _respond 'A snaaaake'
    sleep 0.5
    _respond "Oooh, it's a snake"
    sleep 3
    _respond "[You can stop this at any time with ;kill #{Script.current.name}]"
  end
end

if script.vars[1]
  if (script.vars[1].downcase == script.name) && (script.vars[2].downcase == script.name)
    reward_source_divers
    exit
  end

  if script.vars[1] =~ /^(?:all|full|details?)$/i
    show_report = true
    scripts_to_check = Dir["#{SCRIPT_DIR}/*"].find_all { |x| x =~ /\.lic$/i }
  else
    show_report = false
    scripts_to_check = Set.new
    script.vars[1..-1].each do |prefix|
      scripts = Dir["#{SCRIPT_DIR}/#{prefix}*"].find_all { |x| x =~ /\.lic$/i }
      scripts += Dir["#{LICH_DIR}/lib/#{prefix}*"].find_all { |x| x =~ /\.rb$/i }
      echo "#{prefix}: No matching scripts found!" if scripts.empty?
      scripts.each { |x| scripts_to_check << x }
    end
    scripts_to_check = scripts_to_check.to_a
    scripts_to_check.sort!
  end
else
  show_report = true
  scripts_to_check = []
end

msg = []

if show_report
  msg << '```'
  report = {
    'Ruby version' => const_get(:RUBY_VERSION, missing: 'unknown'),
    'Ruby platform' => const_get(:RUBY_PLATFORM, missing: 'unknown'),
    'Ruby engine' => const_get(:RUBY_ENGINE, missing: 'unknown'),
    'Lich version' => const_get(:LICH_VERSION, missing: 'unknown'),
    'SQLite3 version' => module_version(:SQLite3),
    'Gtk version' => gtk_version,
    'Cairo version' => module_version(:Cairo),
    "#{$lich_char}version Version" => '0.53'
  }

  msg += format_report(report, 20)
  msg << ''
  report = {}
  %i[LICH_DIR SCRIPT_DIR DATA_DIR TEMP_DIR LOG_DIR MAP_DIR BACKUP_DIR].each do |sym|
    report[sym.to_s] = const_get(sym, missing: 'unknown')
  end

  begin
    report['Ruby location'] = "#{RbConfig::CONFIG['bindir']}/#{RbConfig::CONFIG['RUBYW_INSTALL_NAME'].empty? ? RbConfig::CONFIG['RUBY_INSTALL_NAME'] : RbConfig::CONFIG['RUBYW_INSTALL_NAME']}#{RbConfig::CONFIG['EXEEXT']}"
  rescue StandardError
    report['Ruby location'] = 'error'
  end

  msg += format_report(report, 20)
  msg << ''

  report = {}
  begin
    fn = Dir.entries("#{DATA_DIR}/#{XMLData.game}").find_all { |filename| filename =~ /^map-[0-9]+\.(?:dat|xml|json)$/ }.collect { |filename| "#{DATA_DIR}/#{XMLData.game}/#{filename}" }.max
    if fn
      report['MapDB filename'] = File.basename(fn)
      report['MapDB last modified'] = File.mtime(fn).to_s
    else
      report['MapDB filename'] = 'not found'
    end
  rescue StandardError
    report['MapDB filename'] = 'error'
  end

  %w[gameobj-data spell-list].each do |file|
    time = nil
    [DATA_DIR, SCRIPT_DIR].each do |dir|
      
      fn = "#{dir}/#{file}.xml"
      time = File.mtime(fn) if File.exist?(fn)
      break
    rescue StandardError
      time = nil
      
    end
    time = time.to_s if time
    time ||= 'unknown'
    report["#{file} last modified"] = time
  end
  msg += format_report(report, 30)
  msg << ''

  report = {
    'Running scripts' => Script.list.map(&:name).join(', '),
    'Downstream hooks' => DownstreamHook.list.join(', '),
    'Upstream hooks' => UpstreamHook.list.join(', '),
    'Current threads' => Thread.list.length.to_s
  }

  msg += format_report(report, 20)
  msg << '```'
end

unless scripts_to_check.empty?
  msg << '```'
  known_versions = []
  unknown_versions = []
  error_versions = []

  if scripts_to_check.length > 20
    echo "Checking the versions of #{scripts_to_check.length} scripts.  This may take a moment..."
    echo '... or several moments, depending on just how many scripts you have and the speed of your PC...' if scripts_to_check.length > 100
  end

  scripts_to_check.each do |filename|
    name = File.basename(filename)
    name.gsub!(/\.lic$/i, '')

    begin
      version = get_script_version(filename)
      if version
        known_versions << "#{name}==#{version}"
      else
        unknown_versions << name
      end
    rescue StandardError
      error_versions << name
    end
  end

  msg << "Installed script versions: #{known_versions.join(', ')}" unless known_versions.empty?
  msg << "Unknown script versions: #{unknown_versions.join(', ')}" unless unknown_versions.empty?
  msg << "Failed to retrieve data for: #{error_versions.join(', ')}" unless error_versions.empty?
  msg << '```'
end

if scripts_to_check.empty?
  msg << 'Use `;version SCRIPT [SCRIPT2 [SCRIPT3...]]` to report the installed versions of one or more Lich scripts.'
  msg << 'Use `;version ALL` to report the installed versions of ALL downloaded Lich scripts.'
end

respond msg
