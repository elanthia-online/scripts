=begin
  Package Manager

  ** THIS SCRIPT REQUIRES RUBY 2.3+ **

  https://gswiki.play.net/Lich_(software)/Installation

  A modern, federated package manager for Lich. This script provides similiar
  functionality to the ;repository, but aims to make it much easier to share
  updates to scripts and avoid relying anyone as a single point-of-failure.
  Instead of a single server, jinx supports multiple repositories to be more
  resilient against infrastructure outages or players leaving the community.

   author: elanthia-online
     tags: utility, util, repository, repo, update, upgrade, meta, ruby, development
  version: 0.8.0

  Changelog:
  0.8.0 (2026-01-08)
    add GUI code from Nisugi's jinxgui script

  0.7.3 (2025-12-14)
    require pathname gem explicitly incase not loaded as part of Ruby std library

  0.7.2 (2025-12-05)
    prevent script running when load called on file
    add new GS/DR mapdb-backup repositories

  0.7.1 (2025-08-15)
    Add auto-update command for bulk updates:
    - New ;jinx auto-update command to check and update all installed assets
    - Tracks installed assets via metadata files
    - Shows progress during bulk updates
    - Add --dry-run flag to preview updates without installing
    - Excludes engine assets from auto-update for safety
    - Detailed reporting of successful and failed updates

  0.7.0 (2025-08-14)
    Major ergonomic improvements:
    - Add smart asset type detection - no need to specify script/data/engine
    - New unified commands: ;jinx install/update/info/search/list <asset>
    - Automatic routing based on asset type from manifest
    - Better error messages with helpful suggestions
    - Backward compatibility maintained for all existing commands
    - Add --type flag to force specific asset type when needed

  0.6.4 (2024-05-05)
    Fix helper text if file exists to append --force to command
  0.6.3 (2023-05-17)
    Add ability to refresh spell data with new effect-list.xml
    rubocop cleanup
  0.6.2 (2023-01-23)
    Update for Ruby v3 compatibility
  0.6.1 (2022-04-07)
    Fix to prevent downloading data files as script and script files as data.

  0.6.0 (2021-12-12)
    Added pruning for deprecated repos

=end

require 'fileutils'
require 'ostruct'
require 'yaml'
require 'json'
require 'net/https'
require 'net/http'
require 'open-uri'
require 'cgi'
require 'pathname'

module ::Lich
  module Common
    module Jinx
      # our app specific error that we can catch for Jinx errors
      class Error < StandardError; end

      def self.urnon?()
        defined?(Urnon)
      end

      def self.mode()
        urnon? ? :urnon : :lich
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Log
        def self.out(msg, label: :debug)
          return _write _view(msg, label) unless msg.is_a?(StandardError)
          ## pretty-print exception
          _write _view(msg.message, label)
          msg.backtrace.to_a.slice(0..5).each do |frame| _write _view(frame, label) end
        end

        def self._write(line)
          # maybe headless env
          if not defined?(:_respond)
            $stdout.write(line + "\n")
          elsif line.include?("<") and line.include?(">")
            respond(line)
          else
            _respond Preset.as(:debug, line)
          end
        end

        def self._env()
          return "jinx" unless defined?(Script)
          return Script.current.name
        end

        def self._view(msg, label)
          label = [_env, label].flatten.compact.join(".")
          safe = msg.inspect
          # safe = safe.gsub("<", "&lt;").gsub(">", "&gt;") if safe.include?("<") and safe.include?(">")
          "[#{label}] #{safe}"
        end

        def self.pp(msg, label = :debug)
          respond _view(msg, label)
        end

        def self.dump(*args)
          pp(*args)
        end

        def self.mono(text)
          _respond %[<output class="mono"/>]
          _respond text
          _respond %[<output class=""/>]
        end

        module Preset
          def self.as(kind, body)
            %[<preset id="#{kind}">#{body}</preset>]
          end
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Opts
        FLAG_PREFIX = "--"

        def self.parse_command(h, c)
          h[c.to_sym] = true
        end

        def self.parse_flag(h, f)
          (name, val) = f[2..-1].split("=")
          # Convert hyphens to underscores for consistent access
          name = name.gsub("-", "_")
          if val.nil?
            h[name.to_sym] = true
          else
            val = val.split(",")

            h[name.to_sym] = val.size == 1 ? val.first : val
          end
        end

        def self.parse(args = Script.current.vars[1..-1])
          OpenStruct.new(**args.to_a.reduce(Hash.new) do |opts, v|
            if v.start_with?(FLAG_PREFIX)
              Opts.parse_flag(opts, v)
            else
              Opts.parse_command(opts, v)
            end
            opts
          end)
        end

        def self.method_missing(method, *args)
          parse.send(method, *args)
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Util
        def self.parse_json(str)
          begin
            [:ok, JSON.parse(str, symbolize_names: true)]
          rescue => exception
            return [:err, exception]
          end
        end

        def self.fmt_time(seconds)
          days    = (seconds / 86_400).floor
          seconds = seconds - (days * 86_400)
          hours   = (seconds / 3_600).floor
          seconds = seconds - (hours * 3_600)
          minutes = (seconds / 60).floor
          seconds = (seconds - (minutes * 60)).floor

          [days, hours, minutes, seconds]
            .zip(%w(d h m s))
            .select { |f| f.first > 0 }
            .map { |f| f.first.to_s.rjust(2, "0") + f.last }
            .reduce("") { |acc, col| acc + " " + col }
            .strip
        end

        def self.ago(epoc_time)
          fmt_time(Time.now.to_i - epoc_time)
        end

        def self.unwrap()
          begin
            yield
          rescue Jinx::Error => exception
            Log.mono <<~ERROR
          <b>Jinx::Error:</b>

          #{exception.message}
        ERROR
          end
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Seed
        # deprecated - replaced by elanthia-online extras repo
        ElanthiaOnlineCore = {
          name: "core",
          url: %[https://repo.elanthia.online]
        }

        ElanthiaOnlineExtras = {
          name: "elanthia-online",
          url: %[https://extras.repo.elanthia.online]
        }

        FFNGLichRepoArchiveMirror = {
          name: "mirror",
          url: %[https://ffnglichrepoarchive.netlify.app]
        }

        # deprecated
        Gtk3ScriptUpdates = {
          name: "gtk3",
          url: %[https://gtk3.elanthia.online]
        }

        MapdbBackupGS = {
          name: "mapdb-backup-gs",
          url: %[https://elanthia-online.github.io/mapdb-backup-gs]
        }

        MapdbBackupDR = {
          name: "mapdb-backup-dr",
          url: %[https://elanthia-online.github.io/mapdb-backup-dr]
        }
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Folder
        LOCK = Mutex.new
        # dynamic reference to the $data_dir/_jinx folder
        # this will be useful for testing
        def self.jinx_data_dir()
          File.join(data_dir, "_jinx")
        end

        def self.data_dir()
          $data_dir.is_a?(String) or fail Jinx::Error, "$data_dir is not String"
          $data_dir
        end

        def self.script_dir()
          $script_dir.is_a?(String) or fail Jinx::Error, "$script_dir is not String"
          $script_dir
        end

        def self.engine_dir()
          $lich_dir.is_a?(String) or fail Jinx::Error, "$lich_dir is not String"
          $lich_dir
        end

        def self.path(*args)
          File.join(jinx_data_dir, *args.map(&:to_s))
        end

        def self.read(*args)
          File.read path(*args)
        end

        def self.write(file, data)
          File.write(
            path(file),
            data
          )
        end

        def self.read_yaml(*args)
          YAML.load(read(*args)) || {}
        end

        def self.write_yaml(file, data)
          Folder.write(file, data.to_yaml)
        end

        def self.glob(*args)
          Dir.glob path(*args)
        end

        def self.mkdir(*args)
          folder = Pathname.new(*args)
          folder.mkpath
        end

        def self.atomic(path)
          LOCK.synchronize {
            current_state = Folder.read_yaml(path)
            return current_state unless block_given?
            updated_state = yield(current_state)
            Folder.write_yaml(path,
                              updated_state.is_a?(Hash) ? updated_state : current_state)
          }
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Repo
        class << self
          include Enumerable

          FILE = "repos.yaml"

          def atomic()
            Folder.atomic(FILE) { |repos| yield(repos) }
          end

          def header(repo, script)
            uri = URI(repo[:url] + script[:header])
            begin
              Net::HTTP.get(uri)
            rescue => err
              return err.message
            end
          end

          def manifest(repo)
            uri = URI(repo[:url] + "/manifest.json")
            begin
              fetched = Net::HTTP.get(uri)
            rescue => err
              return repo.merge({ err: err.message, available: [] })
            end
            res, decoded = Util.parse_json fetched
            return repo.merge!(decoded) if res.eql?(:ok) && decoded[:available].is_a?(Array)

            # Handle errors but don't return nil
            if decoded.is_a?(Hash)
              Log.out(decoded[:error] || "repo is misconfigured", label: %i(repo error))
            else
              Log.out(decoded.message, label: %i(repo error))
              Log.out(decoded.backtrace, label: %i(repo error))
            end

            # Always return a valid hash, even on error
            repo.merge({ available: [] })
          end

          def each()
            Repo.atomic { |repos|
              repos.each { |repo|
                (name, info) = repo
                yield({ name: name }.merge(info))
              }
            }
          end

          def lookup(repo_name)
            Repo.find { |repo|
              repo[:name].eql?(repo_name.to_sym)
            } or fail Jinx::Error, "repo(%s) is not known" % repo_name
          end

          def exists?(repo_name)
            any? { |repo| repo[:name].eql?(repo_name.to_sym) }
          end

          def create(**argv)
            name = argv.fetch(:name).to_sym
            fail "repo(%s) requires a url" % name unless argv[:url].is_a?(String)
            Repo.atomic { |repos|
              fail "repo(%s) already exists" % name if repos[name]
              argv.delete(:name)
              Log.out("registering repo(%s) at %s" % [name, argv[:url]], label: %i(repo create))
              Folder.mkdir(name.to_s)
              repos[name] = argv
              repos
            }
          end

          def remove(**argv)
            repo_name = argv.fetch(:name).to_sym
            repo = Repo.lookup(repo_name)
            Repo.atomic { |repos|
              repos.delete(repo[:name])
              Log.mono("<b>repo(%s) has been removed</b>" % repo_name)
              repos
            }
          end

          def assets_in(repo)
            repo.fetch(:available, [])
          end

          def scripts(repo)
            assets_in(repo).select { |f| f[:type].nil? || f[:type] == "script" }
          end

          def data(repo)
            assets_in(repo).select { |f| f[:type] == "data" }
          end

          def engines(repo)
            assets_in(repo).select { |f| f[:type] == "engine" }
          end

          def print_info(script, i)
            Log.mono("%s&gt; %s %s" % [
              (i + 1).to_s.rjust(4),
              File.basename(script[:file]).ljust(20),
              "(modified: %s ago)" % Util.ago(script[:last_commit])
            ])
          end

          def print_numbered_list(entries)
            entries
              .sort { |a, b| b[:last_commit] - a[:last_commit] }
              .each_with_index(&method(:print_info))
          end

          def dump(repo, scripts: false, data: false, engines: false)
            Log.mono "<b>%s:</b>" % repo[:name]
            Log.mono "url=".rjust(10) + repo[:url]
            Log.mono "error=".rjust(10) + repo[:err] if repo[:err]
            Log.mono "updated=".rjust(10) + "%s ago" % Util.ago(repo[:last_updated]) if repo[:last_updated]
            if engines && self.engines(repo).any?
              Log.mono "engines:".rjust(10)
              print_numbered_list engines(repo)
            end
            if scripts && self.scripts(repo).any?
              Log.mono "scripts:".rjust(10)
              print_numbered_list scripts(repo)
            end
            if data && self.data(repo).any?
              Log.mono "data:".rjust(7)
              print_numbered_list data(repo)
            end
          end
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Lookup
        class << self
          def find_asset_in(repo, name)
            repo[:available].find do |asset|
              CGI.unescape(File.basename(asset[:file])).eql?(name)
            end
          end

          def find_asset_across_repos(name, repos)
            normalized_name = Installer.normalize_filename(name)
            results = []

            repos.each do |repo|
              Repo.manifest(repo) unless repo[:available].is_a?(Array)
              next unless repo[:available].is_a?(Array)

              asset = find_asset_in(repo, normalized_name)
              results << { repo: repo, asset: asset } if asset
            end

            results
          end

          def detect_asset_type(name, repos)
            matches = find_asset_across_repos(name, repos)

            return nil if matches.empty?
            return matches.first[:asset][:type] if matches.size == 1

            # Check if all matches have the same type
            types = matches.map { |m| m[:asset][:type] }.uniq
            return types.first if types.size == 1

            # Multiple types found
            :ambiguous
          end
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Metadata
        module Base
          include Enumerable

          def atomic()
            Folder.atomic(@file) { |entries| yield(entries) }
          end

          def update(repo, asset)
            name = File.basename(asset.fetch(:file))
            repo_name = repo.fetch(:name)
            Log.out("updating %s file metadata for %s from %s" % [asset[:type], name, repo_name], label: %i(metadata update))
            create(**{ name: name, repo: repo_name, digest: asset.fetch(:md5) })
          end

          def each
            self.atomic { |entries|
              entries.each { |entry|
                yield(entry)
              }
            }
          end

          def find_for_asset(asset)
            name = File.basename(asset.fetch(:file)).to_s
            self.atomic do |entries|
              return entries[name]
            end
          end

          def create(**argv)
            name = argv.fetch(:name).to_s
            repo = argv.fetch(:repo).to_s
            fail "metadata record(%s) requires a name" % name unless argv[:name].is_a?(String)
            fail "metadata record(%s) requires a repo" % repo unless argv[:repo].is_a?(Symbol)
            self.atomic { |entries|
              argv.delete(:name)
              entries[name] = argv
              entries
            }
          end

          def remove(name)
            name = name.to_s
            self.atomic { |entries|
              entries.delete(name)
              entries
            }
          end
        end

        class << self
          def class_for(asset)
            case asset[:type]
            when "script", :script, nil
              ScriptMetadata
            when "data", :data
              DatafileMetadata
            when "engine", :engine
              EngineMetadata
            else
              fail Jinx::Error, "don't recognize #{asset[:type]} type for #{asset[:file]}"
            end
          end

          def update(repo, asset)
            class_for(asset).update(repo, asset)
          end

          def for(asset)
            class_for(asset).find_for_asset(asset)
          end

          def all_installed
            installed = []

            # Gather all installed scripts
            ScriptMetadata.each do |name, metadata|
              installed << { name: name, type: "script", metadata: metadata }
            end

            # Gather all installed data files
            DatafileMetadata.each do |name, metadata|
              installed << { name: name, type: "data", metadata: metadata }
            end

            # Explicitly exclude engines from auto-update for safety

            installed
          end
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module DatafileMetadata
        extend Metadata::Base

        @file = "data.yaml"
      end

      module ScriptMetadata
        extend Metadata::Base

        @file = "scripts.yaml"
      end

      module EngineMetadata
        extend Metadata::Base

        @file = "engine.yaml"
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Installer
        # ensure an installer command is specific enough that
        # there is exactly 1 script that matches
        def self.ensure_specific(file_name, sources)
          file_name = normalize_filename(file_name)

          advertised = sources.select { |repo|
            unless repo[:available].is_a?(Array)
              updated_repo = Repo.manifest(repo)
              if updated_repo.is_a?(Hash)
                repo.merge!(updated_repo)
              end
            end
            repo[:available].is_a?(Array) && Jinx::Lookup.find_asset_in(repo, file_name)
          }

          if sources.size.eql?(1) && advertised.size.eql?(0)
            fail Jinx::Error, <<~ERROR
          repo(#{sources.first[:name]}) does not advertise asset(#{file_name})
        ERROR
          end

          if advertised.size > 1
            fail Jinx::Error, <<~ERROR
          more than one repo has asset(#{file_name})

          please be more specific by adding --repo={name}

          available from:\n#{advertised.map { |repo| "- %s".rjust(10) % repo[:name] }.join("\n")}
        ERROR
          end

          if advertised.size.eql?(0)
            fail Jinx::Error, <<~ERROR
          no known repos have asset(#{file_name}) available
        ERROR
          end

          return advertised.first
        end

        def self.normalize_filename(script)
          return script if script.include?(".")
          return "%s.lic" % script
        end

        def self.open(resource, &block)
          # modern ruby
          return URI.parse(resource).open(&block) if defined?(URI) && URI.respond_to?(:open) && URI.respond_to?(:parse)
          # older rubies where URI.open/2 doesn't exist
          return Kernel::open(resource, &block)
        end

        def self.download(repo, asset, local_location)
          remote_location = repo[:url] + asset[:file]
          self.open(remote_location) { |remote|
            File.open(local_location, "wb") { |local|
              local.write(remote.read)
            }
          }
          Log.out("file downloaded to %s" % local_location,
                  label: %i(install download))
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module AutoUpdater
        def self.check_for_updates
          installed = Metadata.all_installed

          if installed.empty?
            _respond "No jinx-installed assets found to update."
            return []
          end

          updates_available = []
          errors = []
          cleaned_up = []

          installed.each do |item|
            begin
              # Find the asset in its original repo
              repo = Repo.lookup(item[:metadata][:repo])
              Repo.manifest(repo) unless repo[:available].is_a?(Array)

              asset = Lookup.find_asset_in(repo, item[:name])

              if asset.nil?
                errors << "#{item[:name]} (no longer available in repo:#{item[:metadata][:repo]})"
                next
              end

              # Check if update is needed by comparing the current local file digest
              # with the remote digest, not just the stored metadata
              local_file_path = case item[:type]
                                when "script"
                                  File.join(Folder.script_dir, item[:name])
                                when "data"
                                  File.join(Folder.data_dir, item[:name])
                                end

              if local_file_path && File.exist?(local_file_path)
                # Calculate current file digest
                source = File.read(local_file_path)
                digest = Digest::SHA1.new
                digest.update(source)
                current_digest = digest.base64digest

                # Only consider it an update if the remote differs from current local file
                if asset[:md5] != current_digest
                  updates_available << {
                    name: item[:name],
                    type: item[:type],
                    repo: repo,
                    asset: asset,
                    old_digest: current_digest,
                    new_digest: asset[:md5]
                  }
                end
              else
                # File doesn't exist locally - user must have deleted it
                # Remove the metadata so we don't keep trying to update it
                case item[:type]
                when "script"
                  ScriptMetadata.remove(item[:name])
                when "data"
                  DatafileMetadata.remove(item[:name])
                end
                cleaned_up << item[:name]
              end
            rescue => e
              errors << "#{item[:name]} (error: #{e.message})"
            end
          end

          # Report findings
          if updates_available.empty? && errors.empty? && cleaned_up.empty?
            _respond "Checked #{installed.size} assets - all up to date!"
          else
            parts = []
            parts << "Checked #{installed.size} assets"
            if updates_available.any?
              update_list = updates_available.map { |u| "#{u[:name]}(#{u[:type]})" }.join(", ")
              parts << "#{updates_available.size} updates: #{update_list}"
            end
            if cleaned_up.any?
              parts << "#{cleaned_up.size} removed from tracking: #{cleaned_up.join(", ")}"
            end
            _respond parts.join(" - ")

            if errors.any?
              _respond "#{errors.size} errors: #{errors.join(", ")}"
            end
          end

          updates_available
        end

        def self.update_all(force: false, dry_run: false)
          updates = check_for_updates

          return if updates.empty?

          if dry_run
            _respond "Dry run - no changes will be made"
            return
          end

          successful = []
          failed = []
          progress_parts = []

          updates.each_with_index do |update, idx|
            progress_parts << "[#{idx + 1}/#{updates.size}] #{update[:name]}"

            begin
              case update[:type]
              when "script"
                env = defined?(Urnon) ? Jinx::UrnonScript : Jinx::LichScript
                env.install(update[:name], [update[:repo]], overwrite: true, force: force)
              when "data"
                env = defined?(Urnon) ? Jinx::UrnonData : Jinx::LichData
                env.install(update[:name], [update[:repo]], overwrite: true, force: force)
              end
              successful << update[:name]
              progress_parts[-1] += "+"
            rescue => e
              # Clean up the error message - remove escaped newlines and excessive detail
              clean_error = e.message.gsub("\\n", " ").gsub("\n", " ").strip
              # Simplify common error messages
              if clean_error.include?("has been modified since last download")
                clean_error = "locally modified"
              elsif clean_error.include?("already exists")
                clean_error = "file exists"
              end

              failed << { name: update[:name], error: clean_error }
              progress_parts[-1] += "-"
            end
          end

          # Final consolidated report
          if successful.any? && failed.empty?
            _respond "+ Updated all #{successful.size} assets: #{successful.join(", ")}"
          elsif failed.any? && successful.empty?
            _respond "- Failed to update all #{failed.size} assets"
            failed.each do |f|
              _respond "- <b>#{f[:name]}</b>: #{f[:error]} - try `;jinx update #{f[:name]} --force`"
            end
          elsif successful.any? || failed.any?
            parts = []
            if successful.any?
              parts << "+ Updated: #{successful.join(", ")}"
            end
            if failed.any?
              parts << "- Failed: #{failed.map { |f| f[:name] }.join(", ")}"
            end
            _respond parts.join(" | ")

            if failed.any?
              failed.each do |f|
                _respond "- <b>#{f[:name]}</b>: #{f[:error]} - try `;jinx update #{f[:name]} --force`"
              end
            end
          end
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module SmartInstaller
        def self.install(asset_name, sources, overwrite: false, force: false, type: nil)
          # If type is explicitly provided, use the traditional installers
          if type
            case type.to_s
            when "script"
              env = defined?(Urnon) ? Jinx::UrnonScript : Jinx::LichScript
              return env.install(asset_name, sources, overwrite: overwrite, force: force)
            when "data"
              env = defined?(Urnon) ? Jinx::UrnonData : Jinx::LichData
              return env.install(asset_name, sources, overwrite: overwrite, force: force)
            when "engine"
              return LichEngine.install(asset_name, sources, overwrite: overwrite, force: force)
            else
              fail Jinx::Error, "Unknown asset type: #{type}"
            end
          end

          # Auto-detect type from manifests
          detected_type = Lookup.detect_asset_type(asset_name, sources)

          if detected_type.nil?
            fail Jinx::Error, <<~ERROR
          No asset named '#{asset_name}' found in any repository.

          Try one of:
          - ;jinx list              to see all available assets
          - ;jinx search #{asset_name}    to search for similar names
        ERROR
          end

          if detected_type == :ambiguous
            matches = Lookup.find_asset_across_repos(asset_name, sources)
            types_by_repo = matches.map { |m| "#{m[:repo][:name]}: #{m[:asset][:type] || 'script'}" }

            fail Jinx::Error, <<~ERROR
          Asset '#{asset_name}' exists with different types in multiple repositories:
          #{types_by_repo.map { |t| "  - #{t}" }.join("\n")}

          Please specify the type explicitly:
          - ;jinx install #{asset_name} --type=script
          - ;jinx install #{asset_name} --type=data
          - ;jinx install #{asset_name} --type=engine

          Or specify the repository:
          - ;jinx install #{asset_name} --repo=<repo_name>
        ERROR
          end

          # Route to appropriate installer based on detected type
          case detected_type
          when "script", nil # nil type defaults to script for backward compatibility
            env = defined?(Urnon) ? Jinx::UrnonScript : Jinx::LichScript
            env.install(asset_name, sources, overwrite: overwrite, force: force)
          when "data"
            env = defined?(Urnon) ? Jinx::UrnonData : Jinx::LichData
            env.install(asset_name, sources, overwrite: overwrite, force: force)
          when "engine"
            LichEngine.install(asset_name, sources, overwrite: overwrite, force: force)
          else
            fail Jinx::Error, "Unknown asset type: #{detected_type}"
          end
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module LichInstaller
        def self.install(remote_name, sources, local_asset_directory, local_asset_name = nil, overwrite: false, force: false, asset_type: nil)
          remote_name = Installer.normalize_filename(remote_name)
          sources = sources.map { |source| Repo.manifest(source) }
          repo = Installer.ensure_specific(remote_name, sources)
          asset = Jinx::Lookup.find_asset_in(repo, remote_name)
          if !asset_type.nil? && asset[:type] != asset_type
            fail Jinx::Error, <<~ERROR
          Attempted to download #{remote_name} as type: #{asset_type.upcase} instead of #{asset[:type].upcase}.
          Please use proper syntax for downloading scripts or data.

          ;jinx script install {script:name}                     attempt to install a script
          ;jinx script update  {script:name}                     attempts to update an installed script

          ;jinx data install {datafile:name}                     attempt to install a data file
          ;jinx data update  {datafile:name}                     attempts to update an installed data file

        ERROR
          end
          local_asset_name = CGI.unescape(File.basename(local_asset_name || asset[:file]))

          if local_asset_name.eql?("mapdb.json")
            local_asset_name = Pathname.new(XMLData.game).join(
              "map-#{asset[:last_commit]}.json"
            )
          end

          local_asset = File.join(local_asset_directory, local_asset_name)
          if !force && File.exist?(local_asset)
            source = File.read(local_asset)
            digest = Digest::SHA1.new
            digest.update(source)

            if digest.base64digest == asset[:md5]
              Log.out("%s from repo:%s already installed with md5(%s) at %s" % [remote_name, repo[:name], asset[:md5], local_asset],
                      label: %i(install env lich))
              return
            elsif !overwrite
              fail Jinx::Error, <<~ALREADY_EXISTS
            #{local_asset} already exists

            if the overwrite is intentional rerun as:
              ;jinx #{Jinx::Service.vars[0].gsub(" install ", " update ")} --force
          ALREADY_EXISTS
            elsif (metadata = Metadata.for(asset))
              if digest.base64digest != metadata[:digest]
                fail Jinx::Error, <<~LOCALLY_MODIFIED
              #{local_asset} has been modified since last download.

              if the overwrite is intentional rerun as:
                ;jinx #{Jinx::Service.vars[0]} --force
            LOCALLY_MODIFIED
              end
            end
          end
          Log.out("installing %s from repo:%s with md5(%s)" % [remote_name, repo[:name], asset[:md5]],
                  label: %i(install env lich))
          Installer.download(repo, asset, local_asset)
          PostInstall.run(repo, asset, local_asset)
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module PostInstall
        module MapImages
          def self.download_missing(repo)
            ensure_map_directory_exists
            return if missing_images.none?
            Log.out("downloading missing map images", label: %i(install env lich map image))
            missing_images.each do |image|
              if (asset = Jinx::Lookup.find_asset_in(repo, image))
                Jinx::Installer.download(repo, asset, map_dir.join(image))
              else
                Log.out("no asset found for #{image}", label: %i(install env lich map image))
              end
            end
          end

          def self.images_in_mapdb
            Map.list.map(&:image).compact.sort.uniq
          end

          def self.missing_images
            images_in_mapdb.reject do |image|
              map_dir.join(image).exist?
            end
          end

          def self.ensure_map_directory_exists
            unless map_dir.exist?
              Log.out("creating map directory at %s" % map_dir,
                      label: %i(install env lich map directory))
              map_dir.mkdir
            end
          end

          def self.map_dir
            Pathname.new($lich_dir).join("maps")
          end
        end

        HOOKS = {
          lich: {
            "gameobj-data.xml" => proc { GameObj.load_data },
            "spell-list.xml"   => proc { Spell.load },
            "effect-list.xml"  => proc { Spell.load },
            "mapdb.json"       => proc do |repo|
              Map.reload
              MapImages.download_missing(repo)
            end
          }.freeze,
          urnon: {}.freeze,
        }.freeze

        def self.run(repo, asset, local_asset)
          if (h = hook_for(asset))
            Log.out("running #{Jinx.mode} post-install hooks for %s" % [File.basename(asset[:file])], label: %i(postinstall hook))
            h.call(repo, asset, local_asset)
          end
          Metadata.update(repo, asset)
        end

        def self.hook_for(asset)
          f = asset[:file]
          hooks = HOOKS.fetch(Jinx.mode, {})
          hooks[f] || hooks[File.basename(f)]
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module LichScript
        def self.install(script, sources, overwrite: false, force: false)
          LichInstaller.install(script, sources, Folder.script_dir, overwrite: overwrite, force: force, asset_type: "script")
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module LichData
        def self.install(data_file, sources, overwrite: false, force: false)
          LichInstaller.install(data_file, sources, Folder.data_dir, overwrite: overwrite, force: force, asset_type: "data")
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module LichEngine
        DEFAULT_ENGINE = "lich.rb"

        def self.install(engine, sources, overwrite: false, force: false)
          LichInstaller.install(
            normalize_name(engine),
            sources,
            Folder.engine_dir,
            current_engine,
            overwrite: overwrite, force: force,
          )
        end

        def self.normalize_name(raw_engine_name)
          raw_engine_name ||= DEFAULT_ENGINE
          case raw_engine_name.chomp.downcase
          when /^$/, /^lich[.]rbw?$/, /^lich$/
            DEFAULT_ENGINE
          else
            raw_engine_name
          end
        end

        def self.current_engine
          File.basename($PROGRAM_NAME)
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module UrnonInstaller
        ##
        # Urnon allows for nested script dirs, this ensures local scripts are namespace by repo
        # ex: $script_dir/core/do_the_thing -> ;core/do_the_thing
        #
        def self.ensure_local_repo_dir(script, sources)
          script  = Installer.normalize_filename(script)
          sources = sources.map { |source| Repo.manifest(source) }
          repo = Installer.ensure_specific(script, sources)
          local_repo_dir = File.join(Folder.script_dir, repo[:name].to_s)
          unless Dir.exist?(local_repo_dir)
            Log.out("creating local repo directory at %s" % local_repo_dir,
                    label: %i(repo setup))
            Dir.mkdir(local_repo_dir)
          end

          return local_repo_dir
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module UrnonScript
        def self.install(script, sources, overwrite: false, force: true)
          local_repo_dir = UrnonInstaller.ensure_local_repo_dir(script, sources)
          # we normalized it for the LichInstaller module now
          LichInstaller.install(script, sources, local_repo_dir, overwrite: overwrite, force: force, asset_type: "script")
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module UrnonData
        ##
        # Urnon uses the same api for data as lich currently
        #
        def self.install(script, sources, overwrite: false, force: false)
          LichInstaller.install(script, sources, Folder.data_dir, overwrite: overwrite, force: force, asset_type: "data")
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Setup
        def self.apply()
          # setup jinx folder
          unless Dir.exist?(Folder.jinx_data_dir)
            Log.out("creating %s" % Folder.jinx_data_dir, label: %i(setup))
            Dir.mkdir(Folder.jinx_data_dir)
          end
          # setup repo source list
          unless File.exist? Folder.path("repos.yaml")
            Log.out("creating %s" % Folder.path("repos.yaml"), label: %i(setup))
            FileUtils.touch Folder.path("repos.yaml")
          end
          # seed core repos
          repos_to_seed = [Seed::ElanthiaOnlineExtras, Seed::FFNGLichRepoArchiveMirror]
          case XMLData.game
          when /^GS/
            repos_to_seed.push(Seed::MapdbBackupGS)
          when /^DR/
            repos_to_seed.push(Seed::MapdbBackupDR)
          end

          repos_to_seed.each { |repo|
            Repo.create(**repo) unless Repo.exists?(repo[:name])
          }

          # prune deprecated repos
          repos_to_prune = [Seed::Gtk3ScriptUpdates, Seed::ElanthiaOnlineCore]
          case XMLData.game
          when /^GS/
            repos_to_prune.push(Seed::MapdbBackupDR)
          when /^DR/
            repos_to_prune.push(Seed::MapdbBackupGS)
          end

          repos_to_prune.each { |repo|
            Repo.remove(**repo) if Repo.exists?(repo[:name])
          }
          # setup script metadata
          unless File.exist? Folder.path("scripts.yaml")
            Log.out("creating %s" % Folder.path("scripts.yaml"), label: %i(setup scripts))
            FileUtils.touch Folder.path("scripts.yaml")
          end
          # setup data file metadata
          unless File.exist? Folder.path("data.yaml")
            Log.out("creating %s" % Folder.path("data.yaml"), label: %i(setup data))
            FileUtils.touch Folder.path("data.yaml")
          end
          # setup engine metadata
          unless File.exist? Folder.path("engine.yaml")
            Log.out("creating %s" % Folder.path("engine.yaml"), label: %i(setup engine))
            FileUtils.touch Folder.path("engine.yaml")
          end
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module Service
        # for runnign in non-lich envs easier
        def self.vars()
          if defined?(Script)
            Script.current.vars
          else
            vars = (@vars || [])
            [vars.join(" "), *vars]
          end
        end

        # for running string commands
        def self.run(cmd)
          main cmd.split(" ")
        end

        # main cli entry-point
        def self.main(args)
          @vars = args
          argv = Opts.parse(args)
          # prune flags
          args = args.reject { |arg| arg.start_with?("--") }

          # help
          if (argv.help.eql?(true) && args.length.eql?(1)) || args.empty?
            return CLI.help()
          end

          # === ORIGINAL NAMESPACED COMMANDS (backward compatibility) ===
          # Check these FIRST to maintain backward compatibility

          # repo list
          if argv.repo.eql?(true) && argv.list.eql?(true)
            return CLI.repo_list()
          end
          # repo info <repo_name>
          if argv.repo.eql?(true) && argv.info.eql?(true)
            return CLI.repo_info(args.last)
          end
          # repo add <repo_name> <repo_url>

          if argv.repo.eql?(true) && argv.add.eql?(true)
            url = args.at(-1)
            repo_name = args.at(-2)
            unless url.start_with?("http://") or url.start_with?("https://")
              fail Jinx::Error,
                   "invalid scheme only http/https supported\nurl=%s" % url
            end
            return CLI.repo_add(repo_name, url)
          end

          if argv.repo.eql?(true) && argv.change.eql?(true)
            url = args.at(-1)
            repo_name = args.at(-2)
            (url.start_with?("http://") or url.start_with?("https://") or
              fail Jinx::Error,
                   "invalid scheme only http/https supported\nurl=%s" % url)

            return CLI.repo_change(repo_name, url)
          end

          # repo rm <repo_name>
          if argv.repo.eql?(true) && argv.rm.eql?(true)
            repo_name = args.at(-1)
            return CLI.repo_rm(repo_name)
          end
          # script list
          if argv.script.eql?(true) && argv.list.eql?(true)
            return CLI.script_list(argv.repo)
          end
          # script info <script_name>
          if argv.script.eql?(true) && argv.info.eql?(true)
            return CLI.script_info(args.last, argv.repo)
          end
          # script install <script_name>
          if argv.script.eql?(true) && argv.install.eql?(true)
            return CLI.script_install(args.last, argv.repo, force: argv.force)
          end
          # script update <script_name>
          if argv.script.eql?(true) && argv.update.eql?(true)
            return CLI.script_update(args.last, argv.repo, force: argv.force)
          end
          # script search <substring>
          if argv.script.eql?(true) && argv.search.eql?(true)
            return CLI.script_search(args.last, argv.repo)
          end
          # data list
          if argv.data.eql?(true) && argv.list.eql?(true)
            return CLI.data_list(argv.repo)
          end
          # data info <data_name>
          if argv.data.eql?(true) && argv.info.eql?(true)
            return CLI.data_info(args.last, argv.repo)
          end
          # data install <data_name>
          if argv.data.eql?(true) && argv.install.eql?(true)
            return CLI.data_install(args.last, argv.repo, force: argv.force)
          end
          # data update <data_name>
          if argv.data.eql?(true) && argv.update.eql?(true)
            return CLI.data_update(args.last, argv.repo, force: argv.force)
          end
          # engine list
          if argv.engine.eql?(true) && argv.list.eql?(true)
            return CLI.engine_list(argv.repo)
          end
          # engine update <engine_name>
          if argv.engine.eql?(true) && argv.update.eql?(true)
            return CLI.engine_update(args[2], argv.repo, force: argv.force)
          end

          # === NEW UNIFIED COMMANDS (no namespace required) ===
          # These only trigger if no namespaced command matched

          # jinx list - show all assets
          if argv.list.eql?(true) && args.length.eql?(1)
            return CLI.list_all(argv.repo)
          end

          # jinx info <asset_name> - smart info detection
          if argv.info.eql?(true) && args.length.eql?(2)
            return CLI.smart_info(args.last, argv.repo)
          end

          # jinx install <asset_name> - smart install
          if argv.install.eql?(true) && args.length.eql?(2)
            return CLI.smart_install(args.last, argv.repo, force: argv.force, type: argv.type)
          end

          # jinx update <asset_name> - smart update
          if argv.update.eql?(true) && args.length.eql?(2)
            return CLI.smart_update(args.last, argv.repo, force: argv.force, type: argv.type)
          end

          # jinx search <pattern> - search all asset types
          if argv.search.eql?(true) && args.length.eql?(2)
            return CLI.search_all(args.last, argv.repo)
          end

          # jinx auto-update - check and update all installed assets
          if argv.auto_update.eql?(true) || (argv.auto.eql?(true) && argv.update.eql?(true)) || args.include?("auto-update")
            return CLI.auto_update(force: argv.force, dry_run: argv.dry_run || argv.dry)
          end

          # jinx gui - launch GUI interface
          if argv.gui.eql?(true)
            begin
              require 'gtk3'
              return ::Lich::Common::Jinx::GUI.start!
            rescue LoadError
              Log.mono <<~ERROR
          <b>GTK3 not available</b>

          The GUI requires GTK3. Please install it!
        ERROR
              return
            rescue => e
              Log.out(e, label: %i(gui error))
              return
            end
          end

          Log.out("unknown command", label: %i(cli))
          CLI.help()
        end
      end
    end
  end
end

module ::Lich
  module Common
    module Jinx
      module CLI
        def self.help()
          Log.mono <<~HELP

        <b>jinx(mode=#{Jinx.mode})</b>

        A federated script repository manager

        Usage: ;jinx &lt;subcommand&gt; [&lt;args&gt;...] [options]

        Asset Commands:
          list                                             list all available assets
          info    &lt;name&gt;                                  show details about an asset
          install &lt;name&gt;                                  install an asset
          update  &lt;name&gt;                                  update an installed asset
          search  &lt;pattern&gt;                               search for assets by name pattern
          auto-update                                      check and update all installed assets
          gui                                              launch graphical user interface

        Repository Commands:
          repo list                                        list all configured repositories
          repo add    &lt;name&gt; &lt;url&gt;                        add a new repository
          repo info   &lt;name&gt;                              show repository details
          repo rm     &lt;name&gt;                              remove a repository
          repo change &lt;name&gt; &lt;url&gt;                        change repository URL

        Options:
          --repo=&lt;name&gt;                                   target a specific repository
          --type={script|data|engine}                      override auto-detected asset type
          --force                                           overwrite without confirmation
          --dry-run                                         check for updates without installing

        Examples:
          ;jinx gui                                        launch graphical interface
          ;jinx install go2                                install the go2 script
          ;jinx update spell-list.xml                      update spell data file
          ;jinx search map                                 find all assets with "map" in the name
          ;jinx install go2 --repo=core                    install from specific repository
          ;jinx auto-update                                check and update all installed assets
          ;jinx auto-update --dry-run                      preview available updates without installing

        Notes:
          - Asset type (script/data/engine) is automatically detected from repository metadata
          - Use --type flag only when you need to override the auto-detection
          - Use --repo flag when the same asset exists in multiple repositories
          - Legacy namespaced commands (script/data/engine) are still supported for compatibility

        HELP
        end

        def self.repo_list()
          Repo.each { |repo| Repo.dump(repo) }
        end

        def self.repo_add(repo_name, repo_url)
          Repo.create(name: repo_name, url: repo_url)
        end

        def self.repo_info(repo_name)
          repo = Repo.lookup(repo_name)
          Repo.dump(
            Repo.manifest(repo),
            scripts: true, data: true, engines: true
          )
        end

        def self.repo_rm(repo_name)
          Repo.remove(name: repo_name)
        end

        def self.repo_change(repo_name, repo_url)
          repo = Repo.lookup(repo_name)
          Repo.atomic { |repos|
            repos[repo[:name]] = repo.merge({ url: repo_url })
            Log.mono("<b>repo(%s) has been changed from</b>\nold=%s\nnew=%s" % [
              repo_name,
              repo[:url],
              repo_url
            ])
            repos
          }
        end

        def self.script_list(repo_name = nil)
          # Log.out(repo_name, label: %i(script_list))
          Repo
            .select { |repo| repo_name.nil? or repo[:name].eql?(repo_name.to_sym) }
            .map    { |repo| repo.merge(Repo.manifest(repo)) }
            .each   { |repo| Repo.dump(repo, scripts: true) }
        end

        def self.script_info(script_name, repo_name = nil)
          repos = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          repo = Installer.ensure_specific(script_name, repos)
          script_metadata = Repo.scripts(repo).find { |asset|
            File.basename(asset[:file])
                .eql?(Installer.normalize_filename(script_name))
          }

          Log.mono("<b>%s (repo: %s, modified: %s)</b>" %
            [script_name, repo[:name],
             Util.ago(script_metadata[:last_commit]) + " ago"])
          if script_metadata[:header]
            Log.mono Repo.header(repo, script_metadata)
          else
            Log.mono "no documentation"
          end
        end

        def self.script_install(script, repo_name = nil, force: false)
          sources = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          env = defined?(Urnon) ? Jinx::UrnonScript : Jinx::LichScript
          env.install(script, sources, overwrite: force, force: force)
        end

        def self.script_update(script, repo_name = nil, force: false)
          sources = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          env = defined?(Urnon) ? Jinx::UrnonScript : Jinx::LichScript
          env.install(script, sources, overwrite: true, force: force)
        end

        def self.script_search(pattern, repo_name)
          pattern = Regexp.compile(pattern)
          candidate_repos = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          matches = candidate_repos
                    .each { |repo| Repo.manifest(repo) }
                    .select { |repo| repo[:available].is_a?(Array) }
                    .map { |repo| Repo.scripts(repo).map { |script| script.merge({ repo: repo[:name] }) } }
                    .flatten(1)
                    .select { |script| File.basename(script[:file]) =~ pattern }

          Log.mono "<b>found %s #{matches.size == 1 ? "match" : "matches"}</b>" % matches.size
          matches.each { |script|
            Log.mono "%s> %s (last updated: %s ago)" % [
              script[:repo].to_s.rjust(15),
              File.basename(script[:file]).rjust(20),
              Util.ago(script[:last_commit])
            ]
          }
        end

        def self.data_list(repo_name = nil)
          Log.out(repo_name, label: %i(data_list))
          Repo
            .select { |repo| repo_name.nil? or repo[:name].eql?(repo_name.to_sym) }
            .map    { |repo| repo.merge(Repo.manifest(repo)) }
            .each   { |repo| Repo.dump(repo, data: true) }
        end

        def self.data_info(datafile_name, repo_name = nil)
          repos = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          repo = Installer.ensure_specific(datafile_name, repos)
          datafile_metadata = Repo.data(repo).find { |asset|
            File.basename(asset[:file])
                .eql?(Installer.normalize_filename(datafile_name))
          }

          Log.mono("<b>%s (repo: %s, modified: %s)</b>" %
            [datafile_name, repo[:name],
             Util.ago(datafile_metadata[:last_commit]) + " ago"])
          if datafile_metadata[:header]
            Log.mono Repo.header(repo, datafile_metadata)
          else
            Log.mono "no documentation"
          end
        end

        def self.data_install(datafile, repo_name = nil, force: false)
          sources = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          env = defined?(Urnon) ? Jinx::UrnonData : Jinx::LichData
          env.install(datafile, sources, overwrite: force, force: force)
        end

        def self.data_update(datafile, repo_name = nil, force: false)
          sources = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          env = defined?(Urnon) ? Jinx::UrnonData : Jinx::LichData
          env.install(datafile, sources, overwrite: true, force: force)
        end

        def self.engine_list(repo_name = nil)
          Log.out(repo_name, label: %i(engine_list)) if repo_name
          Repo
            .select { |repo| repo_name.nil? or repo[:name].eql?(repo_name.to_sym) }
            .map    { |repo| repo.merge(Repo.manifest(repo)) }
            .each   { |repo| Repo.dump(repo, engines: true) }
        end

        def self.engine_update(engine, repo_name = nil, force: false)
          sources = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          env = defined?(Urnon) ? Jinx::UrnonEngine : Jinx::LichEngine
          env.install(engine, sources, overwrite: true, force: force)
        end

        # === NEW UNIFIED COMMAND IMPLEMENTATIONS ===

        def self.list_all(repo_name = nil)
          Repo
            .select { |repo| repo_name.nil? or repo[:name].eql?(repo_name.to_sym) }
            .map    { |repo| repo.merge(Repo.manifest(repo)) }
            .each   { |repo|
              Repo.dump(repo, scripts: true, data: true, engines: true)
            }
        end

        def self.smart_info(asset_name, repo_name = nil)
          repos = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          matches = Lookup.find_asset_across_repos(asset_name, repos)

          if matches.empty?
            Log.mono <<~ERROR
          No asset named '#{asset_name}' found.

          Try:
          - ;jinx search #{asset_name}    to find similar names
          - ;jinx list                    to see all available assets
        ERROR
            return
          end

          if matches.size > 1 && repo_name.nil?
            Log.mono "<b>Asset '#{asset_name}' found in multiple repositories:</b>"
            matches.each do |match|
              type_str = match[:asset][:type] || "script"
              Log.mono "  #{match[:repo][:name]} (type: #{type_str})"
            end
            Log.mono "\nSpecify a repository with --repo=<name> to see specific info"
            return
          end

          match = matches.first
          asset = match[:asset]
          repo = match[:repo]
          type_str = asset[:type] || "script"

          Log.mono("<b>%s (repo: %s, type: %s, modified: %s)</b>" %
            [asset_name, repo[:name], type_str,
             Util.ago(asset[:last_commit]) + " ago"])

          if asset[:header]
            Log.mono Repo.header(repo, asset)
          else
            Log.mono "no documentation"
          end
        end

        def self.smart_install(asset_name, repo_name = nil, force: false, type: nil)
          sources = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          SmartInstaller.install(asset_name, sources, overwrite: false, force: force, type: type)
        end

        def self.smart_update(asset_name, repo_name = nil, force: false, type: nil)
          sources = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]
          SmartInstaller.install(asset_name, sources, overwrite: true, force: force, type: type)
        end

        def self.search_all(pattern, repo_name = nil)
          pattern = Regexp.compile(pattern)
          candidate_repos = repo_name.nil? ? Repo.to_a : [Repo.lookup(repo_name)]

          all_matches = []

          candidate_repos.each do |repo|
            Repo.manifest(repo)
            next unless repo[:available].is_a?(Array)

            repo[:available].each do |asset|
              if File.basename(asset[:file]) =~ pattern
                type_str = asset[:type] || "script"
                all_matches << {
                  repo: repo[:name],
                  file: File.basename(asset[:file]),
                  type: type_str,
                  last_commit: asset[:last_commit]
                }
              end
            end
          end

          if all_matches.empty?
            Log.mono "<b>No matches found for pattern: #{pattern.source}</b>"
            return
          end

          # Group by type
          by_type = all_matches.group_by { |m| m[:type] }

          Log.mono "<b>Found #{all_matches.size} #{all_matches.size == 1 ? "match" : "matches"}:</b>"

          by_type.each do |type, matches|
            Log.mono "\n<b>#{type.capitalize}s:</b>"
            matches.sort_by { |m| m[:file] }.each do |match|
              Log.mono "%s> %s (updated: %s ago)" % [
                match[:repo].to_s.rjust(15),
                match[:file].ljust(25),
                Util.ago(match[:last_commit])
              ]
            end
          end
        end

        def self.auto_update(force: false, dry_run: false)
          AutoUpdater.update_all(force: force, dry_run: dry_run)
        end
      end
    end
  end
end

# ===========================
# GUI MODULE
# ===========================

module ::Lich
  module Common
    module Jinx
      module GUI
        extend self

        # =====================
        # Cache for performance
        # =====================
        @manifest_cache = {}
        @manifest_cache_mutex = Mutex.new
        @full_asset_lists = { script: [], data: [] }
        @is_loading = false
        @alive = false
        @model_mutex = Mutex.new
        @refresh_threads = {}

        # =====================
        # Thread/UI helper
        # =====================
        def ui(&blk)
          return unless @alive
          if Gtk.respond_to?(:queue)
            Gtk.queue { blk.call if @alive }
          else
            GLib::Idle.add { @alive ? blk.call : false; false }
          end
        end

        # =====================
        # Time helper
        # =====================
        def safe_ago(ts)
          return '-' if ts.nil?
          ::Lich::Common::Jinx::Util.ago(ts) rescue '-'
        end

        # =====================
        # Log bridge
        # =====================
        def install_log_bridge!
          return unless defined?(::Lich::Common::Jinx::Log)
          log_class = ::Lich::Common::Jinx::Log.singleton_class

          # Hook Log.out once
          if log_class.method_defined?(:out) && !log_class.method_defined?(:out__orig)
            log_class.send(:alias_method, :out__orig, :out)
            log_class.send(:define_method, :out) do |msg, label: :debug|
              if defined?(::Lich::Common::Jinx::GUI) && ::Lich::Common::Jinx::GUI.alive?
                if msg.is_a?(StandardError)
                  ::Lich::Common::Jinx::GUI.append_log("[#{label}] #{msg.message}")
                  msg.backtrace.to_a.slice(0..5).each { |frame| ::Lich::Common::Jinx::GUI.append_log(frame) }
                else
                  ::Lich::Common::Jinx::GUI.append_log("[#{label}] #{msg}")
                end
              end
              out__orig(msg, label: label)
            end
          end

          # Hook Log.mono once
          if log_class.method_defined?(:mono) && !log_class.method_defined?(:mono__orig)
            log_class.send(:alias_method, :mono__orig, :mono)
            log_class.send(:define_method, :mono) do |text|
              if defined?(::Lich::Common::Jinx::GUI) && ::Lich::Common::Jinx::GUI.alive?
                # Strip HTML tags and log to GUI safely
                clean_text = text.to_s.gsub(/<[^>]+>/, '')
                ::Lich::Common::Jinx::GUI.append_log(clean_text)
                # Don't call the original mono which would try to use _respond
                nil
              else
                mono__orig(text)
              end
            end
          end
        end

        # =====================
        # App bootstrap
        # =====================
        def start!
          @alive = true
          install_log_bridge!

          # Setup cleanup handler
          if defined?(before_dying)
            before_dying { cleanup! }
          end

          ui do
            @win = Gtk::Window.new(Gtk::Window::TOPLEVEL)
            @win.title = 'Jinx - Package Manager'
            @win.set_default_size(1100, 700)
            @win.signal_connect('destroy') {
              @alive = false
            }

            notebook = Gtk::Notebook.new
            notebook.tab_pos = Gtk::PositionType::TOP

            # Build tabs
            log_tab = build_log_tab
            @repos_model,   repos_tab   = build_repos_tab
            @scripts_model, scripts_tab = build_assets_tab(:script)
            @data_model,    data_tab    = build_assets_tab(:data)

            # Add Log tab first for better initial UX
            notebook.append_page(log_tab,     Gtk::Label.new('Log'))
            notebook.append_page(repos_tab,   Gtk::Label.new('Repos'))
            notebook.append_page(scripts_tab, Gtk::Label.new('Scripts'))
            notebook.append_page(data_tab,    Gtk::Label.new('Data'))

            @win.add(notebook)
            @win.show_all

            # Show loading message immediately
            append_log("[jinx.gui] Starting up...")
            append_log("[jinx.gui] Loading repository data, this may take 20-30 seconds...")

            # Set loading indicators
            ui do
              @model_mutex.synchronize do
                @repos_model.clear
                iter = @repos_model.append
                iter[0] = "Loading repositories..."
                iter[1] = "Please wait..."
                iter[2] = "Fetching manifests..."

                [@scripts_model, @data_model].each do |model|
                  model.clear
                  iter = model.append
                  iter[0] = "Loading..."
                  iter[1] = "Please wait..."
                end
              end
            end

            # Start initial refresh
            initial_refresh
          end

          # Keep the main script thread alive while GUI is running
          while @alive
            sleep 0.1
          end

          # Clean exit
          Log.out("GUI closed", label: %i(jinx gui))
        end

        # =====================
        # Initial refresh with caching
        # =====================
        def initial_refresh
          Thread.new do
            return unless @alive
            @is_loading = true
            append_log("[jinx.gui] Fetching repository manifests...")
            refresh_repos(cache_only: false) do
              if @alive
                append_log("[jinx.gui] Initial load complete!")
                @is_loading = false
              end
            end
          end
        end

        # =====================
        # Repos Tab (name, url, status)
        # =====================
        def build_repos_tab
          model = Gtk::ListStore.new(String, String, String)
          view  = Gtk::TreeView.new(model)
          view.enable_grid_lines = :both
          add_text_column(view, 'Name',   0, sortable: true)
          add_text_column(view, 'URL',    1, sortable: true)
          add_text_column(view, 'Status', 2, sortable: true)

          name_entry = Gtk::Entry.new; name_entry.placeholder_text = 'repo name'
          url_entry  = Gtk::Entry.new; url_entry.placeholder_text  = 'https://...'

          add_btn     = Gtk::Button.new(label: 'Add')
          rm_btn      = Gtk::Button.new(label: 'Remove')
          chg_btn     = Gtk::Button.new(label: 'Change URL')
          refresh_btn = Gtk::Button.new(label: 'Refresh Manifests')

          add_btn.signal_connect('clicked') do
            name = name_entry.text.to_s.strip
            url  = url_entry.text.to_s.strip
            next if name.empty? || url.empty?
            Thread.new do
              begin
                ::Lich::Common::Jinx::CLI.repo_add(name, url)
                clear_all_caches! # Clear cache when repos change
              rescue => e
                append_log("[repo add] #{e.message}")
              ensure
                refresh_repos(cache_only: false)
              end
            end
          end

          rm_btn.signal_connect('clicked') do
            iter = selected_iter(view); next unless iter
            repo = iter[0]
            Thread.new do
              begin
                ::Lich::Common::Jinx::CLI.repo_rm(repo)
                clear_all_caches! # Clear cache when repos change
              rescue => e
                append_log("[repo rm] #{e.message}")
              ensure
                refresh_repos(cache_only: false)
              end
            end
          end

          chg_btn.signal_connect('clicked') do
            iter = selected_iter(view); next unless iter
            repo = iter[0]
            new_url = url_entry.text.to_s.strip; next if new_url.empty?
            Thread.new do
              begin
                ::Lich::Common::Jinx::CLI.repo_change(repo, new_url)
                clear_all_caches! # Clear cache when repos change
              rescue => e
                append_log("[repo change] #{e.message}")
              ensure
                refresh_repos(cache_only: false)
              end
            end
          end

          refresh_btn.signal_connect('clicked') do
            Thread.new do
              clear_all_caches!
              refresh_repos(cache_only: false)
            end
          end

          scroller = Gtk::ScrolledWindow.new; scroller.add(view)
          ctrls = Gtk::Box.new(:horizontal, 6)
          ctrls.pack_start(name_entry,  expand: true,  fill: true,  padding: 0)
          ctrls.pack_start(url_entry,   expand: true,  fill: true,  padding: 0)
          ctrls.pack_start(add_btn,     expand: false, fill: false, padding: 0)
          ctrls.pack_start(chg_btn,     expand: false, fill: false, padding: 0)
          ctrls.pack_start(rm_btn,      expand: false, fill: false, padding: 0)
          ctrls.pack_start(refresh_btn, expand: false, fill: false, padding: 0)

          box = Gtk::Box.new(:vertical, 8); box.margin = 8
          box.pack_start(ctrls, expand: false, fill: false, padding: 0)
          box.pack_start(scroller, expand: true, fill: true, padding: 0)

          @repos_view = view
          [model, box]
        end

        def refresh_repos(cache_only: false, &callback)
          Thread.new do
            return unless @alive # Exit early if shutting down
            append_log("[jinx.gui] Refreshing repositories#{cache_only ? ' (from cache)' : ''}...")
            repos = begin ::Lich::Common::Jinx::Repo.to_a rescue [] end
            rows  = []
            repos.each do |r|
              break unless @alive # Check if still alive
              name, url, status = r[:name].to_s, r[:url].to_s, 'ok'
              begin
                if cache_only
                  @manifest_cache_mutex.synchronize do
                    @manifest_cache[name] ||= manifest_with_retries(r)
                  end
                else
                  m = manifest_with_retries(r)
                  @manifest_cache_mutex.synchronize { @manifest_cache[name] = m }
                end
              rescue => e
                status = "error: #{e.message}"
                append_log("[WARN] Failed to fetch manifest for #{name}: #{e.message}")
              end
              rows << [name, url, status]
            end

            return unless @alive # Don't update UI if shutting down
            ui do
              return unless @repos_model && @alive
              @model_mutex.synchronize do
                @repos_model.clear
                rows.sort_by! { |row| row[0].to_s }
                rows.each do |r|
                  it = @repos_model.append
                  (0..2).each { |i| it[i] = r[i] }
                end
              end
            end
            append_log("[jinx.gui] Repositories refreshed")

            # If not caching, also refresh the asset lists
            unless cache_only
              clear_asset_cache! # Only clear asset lists, keep manifests
              refresh_assets(:script, filter: nil, use_cache: false)
              refresh_assets(:data, filter: nil, use_cache: false)
            end

            callback.call if callback
          end
        end

        # =====================
        # Scripts/Data Tabs (name, repo, installed, modified, updated)
        # =====================
        def build_assets_tab(kind)
          model = Gtk::ListStore.new(String, String, String, String, String)
          view  = Gtk::TreeView.new(model)

          view.selection.mode = :browse
          view.activate_on_single_click = true rescue nil
          view.signal_connect('button-press-event') do |w, event|
            begin
              if event.button == 1
                path, col, _cx, _cy = w.get_path_at_pos(event.x.to_i, event.y.to_i)
                if path
                  w.selection.select_path(path)
                  w.set_cursor(path, col, false)
                end
              end
            rescue => e
              append_log("[DEBUG] click-select failed: #{e.message}")
            end
            false
          end
          view.signal_connect('row-activated') { |w, path, _| w.selection.select_path(path) }
          view.enable_grid_lines = :both

          add_text_column(view, 'Name',         0, sortable: true)
          add_text_column(view, 'Repo',         1, sortable: true)
          add_text_column(view, 'Installed',    2, sortable: true)
          add_text_column(view, 'Modified',     3, sortable: true)
          add_text_column(view, 'Updated (ago)', 4, sortable: true)

          # --- Controls (button-driven search; no auto-run) ---
          search = Gtk::SearchEntry.new
          search.placeholder_text = 'search by name... (empty = show all)'

          search_btn  = Gtk::Button.new(label: 'Search')
          clear_btn   = Gtk::Button.new(label: 'Clear')
          info_btn    = Gtk::Button.new(label: 'Info')
          install_btn = Gtk::Button.new(label: 'Install')
          update_btn  = Gtk::Button.new(label: 'Update')

          force_toggle = Gtk::CheckButton.new
          force_toggle.label = 'Force overwrite'

          # Define search action as a proc to avoid duplication
          perform_search = proc do
            search_text = search.text.to_s.strip

            # Update info panel
            ui do
              t = (kind == :script) ? @script_info_text : @data_info_text
              if t && !t.destroyed?
                if search_text.empty?
                  t.buffer.text = "Showing all #{kind}s..."
                else
                  t.buffer.text = "Searching for '#{search_text}'..."
                end
              end
            end

            # Empty search = show all
            filter = search_text.empty? ? nil : search_text
            refresh_assets(kind, filter: filter, use_cache: true)
          end

          # Search with caching - much faster!
          search_btn.signal_connect('clicked', &perform_search)

          # Also trigger search when Enter is pressed in the search box
          search.signal_connect('activate', &perform_search)
          # Clear button
          clear_btn.signal_connect('clicked') do
            search.text = ''
            ui do
              t = (kind == :script) ? @script_info_text : @data_info_text
              t.buffer.text = "Showing all #{kind}s..." if t && !t.destroyed?
            end
            refresh_assets(kind, filter: nil, use_cache: true)
          end

          # Info button - thread-safe capture without global Log.mono override
          local_view = view
          info_btn.signal_connect('clicked') do
            iter = selected_iter(local_view)
            unless iter
              append_log("[jinx.gui] No item selected ..."); next
            end

            keep_name = iter[0].to_s
            keep_repo = iter[1].to_s
            name      = keep_name
            repo      = keep_repo

            ui do
              t = (kind == :script) ? @script_info_text : @data_info_text
              t.buffer.text = "Fetching info for #{name}..." if t && !t.destroyed?
            end

            Thread.new do
              captured = []

              # Create a temporary capturing logger
              capture_logger = Object.new
              capture_logger.define_singleton_method(:mono) do |text|
                clean = text.to_s.gsub(/<[^>]+>/, '')
                captured << clean
                nil
              end

              # Store original logger
              original_log = ::Lich::Common::Jinx::Log rescue nil

              begin
                # Temporarily replace the Log module with our capturing version
                # This is thread-local and won't affect other threads
                if original_log
                  ::Lich::Common::Jinx.send(:remove_const, :Log)
                  ::Lich::Common::Jinx.const_set(:Log, capture_logger)
                end

                if kind == :script
                  ::Lich::Common::Jinx::CLI.script_info(name, repo)
                else
                  ::Lich::Common::Jinx::CLI.data_info(name, repo)
                end
              rescue => e
                captured << "Error: #{e.message}"
              ensure
                # Restore original Log module
                if original_log
                  ::Lich::Common::Jinx.send(:remove_const, :Log)
                  ::Lich::Common::Jinx.const_set(:Log, original_log)
                end
              end

              ui do
                # Update side panel
                t = (kind == :script) ? @script_info_text : @data_info_text
                if t && !t.destroyed?
                  t.buffer.text = (captured.any? ? captured.join("\n") : "No info available")
                end

                # Restore selection to the same (name, repo) row if still present
                model = (kind == :script) ? @scripts_model : @data_model
                view  = (kind == :script) ? @scripts_view  : @data_view
                if model && view && !view.destroyed?
                  @model_mutex.synchronize do
                    it = model.iter_first
                    while it
                      if it[0].to_s == keep_name && it[1].to_s == keep_repo
                        path = it.path
                        view.selection.select_path(path)
                        view.set_cursor(path, view.columns.first, false)
                        break
                      end
                      break unless it.next!
                    end
                  end
                end
              end
            end
          end

          # Install button
          install_btn.signal_connect('clicked') do
            iter = selected_iter(local_view)
            unless iter
              append_log("[jinx.gui] No item selected for install"); next
            end

            name = iter[0].to_s
            repo = iter[1].to_s
            force = force_toggle.active?

            Thread.new do
              begin
                if kind == :script
                  ::Lich::Common::Jinx::CLI.script_install(name, repo, force: force)
                else
                  ::Lich::Common::Jinx::CLI.data_install(name, repo, force: force)
                end
                # Refresh just this asset type after install
                refresh_assets(kind, filter: nil, use_cache: true)
              rescue => e
                append_log("[install] #{e.message}")
              end
            end
          end

          # Update button
          update_btn.signal_connect('clicked') do
            iter = selected_iter(local_view)
            unless iter
              append_log("[jinx.gui] No item selected for update"); next
            end

            name = iter[0].to_s
            repo = iter[1].to_s
            force = force_toggle.active?

            Thread.new do
              begin
                if kind == :script
                  ::Lich::Common::Jinx::CLI.script_update(name, repo, force: force)
                else
                  ::Lich::Common::Jinx::CLI.data_update(name, repo, force: force)
                end
                # Refresh just this asset type after update
                refresh_assets(kind, filter: nil, use_cache: true)
              rescue => e
                append_log("[update] #{e.message}")
              end
            end
          end

          # Layout
          paned = Gtk::Paned.new(:horizontal)
          scroller = Gtk::ScrolledWindow.new; scroller.add(view)

          info_frame = Gtk::Frame.new("Information")
          info_text = Gtk::TextView.new
          info_text.editable = false
          info_text.wrap_mode = :word
          info_text.buffer.text = "Select an item and click Info to see details"
          info_scroller = Gtk::ScrolledWindow.new; info_scroller.add(info_text)
          info_frame.add(info_scroller)

          if kind == :script
            @script_info_text = info_text
            @scripts_view     = view
          else
            @data_info_text   = info_text
            @data_view        = view
          end

          paned.pack1(scroller, true, false)
          paned.pack2(info_frame, false, true)
          paned.position = 700

          ctrls = Gtk::Box.new(:horizontal, 6)
          ctrls.pack_start(search,       expand: true,  fill: true,  padding: 0)
          ctrls.pack_start(search_btn,   expand: false, fill: false, padding: 0)
          ctrls.pack_start(clear_btn,    expand: false, fill: false, padding: 0)
          ctrls.pack_start(info_btn,     expand: false, fill: false, padding: 0)
          ctrls.pack_start(install_btn,  expand: false, fill: false, padding: 0)
          ctrls.pack_start(update_btn,   expand: false, fill: false, padding: 0)
          ctrls.pack_start(force_toggle, expand: false, fill: false, padding: 0)

          box = Gtk::Box.new(:vertical, 8)
          box.margin = 8
          box.pack_start(ctrls,  expand: false, fill: false, padding: 0)
          box.pack_start(paned,  expand: true,  fill: true,  padding: 0)

          [model, box]
        end

        def refresh_assets(kind, filter: nil, use_cache: true)
          # Cancel any existing refresh for this kind
          if @refresh_threads[kind]&.alive?
            @refresh_threads[kind].kill rescue nil
          end

          @refresh_threads[kind] = Thread.new do
            return unless @alive # Exit early if shutting down

            # Remember current selection to restore after repopulating
            view   = (kind == :script) ? @scripts_view : @data_view
            model  = (kind == :script) ? @scripts_model : @data_model
            prev_name = prev_repo = nil

            if view && !view.destroyed?
              @model_mutex.synchronize do
                if (it = selected_iter(view))
                  prev_name = it[0].to_s
                  prev_repo = it[1].to_s
                end
              end
            end

            rows = []

            if use_cache && @full_asset_lists[kind].any?
              # Use cached data and just filter it
              append_log("[jinx.gui] Using cached #{kind} data for search...")
              rows = @full_asset_lists[kind]

              # Apply filter if present
              if filter && !filter.empty?
                pattern = Regexp.new(Regexp.escape(filter), Regexp::IGNORECASE)
                rows = rows.select { |r| r[0] =~ pattern }
                append_log("[jinx.gui] Found #{rows.size} #{kind}(s) matching '#{filter}'")
              else
                append_log("[jinx.gui] Showing all #{rows.size} #{kind}(s)")
              end
            else
              # Full refresh - fetch from repos
              append_log("[jinx.gui] Building #{kind} list from repositories...")
              pattern = filter && !filter.empty? ? Regexp.new(Regexp.escape(filter), Regexp::IGNORECASE) : nil

              repos = begin ::Lich::Common::Jinx::Repo.to_a rescue [] end
              successful_repos = 0

              repos.each do |repo|
                break unless @alive # Check if still alive
                # Use cached manifest if available
                m = @manifest_cache_mutex.synchronize { @manifest_cache[repo[:name].to_s] }
                if m.nil?
                  begin
                    append_log("[jinx.gui] Fetching manifest for #{repo[:name]}...")
                    m = manifest_with_retries(repo)
                    @manifest_cache_mutex.synchronize { @manifest_cache[repo[:name].to_s] = m }
                  rescue => e
                    append_log("[ERROR] Failed to load #{repo[:name]}: #{e.message}")
                    m = (repo || {}).dup
                    m[:available] = []
                  end
                end

                # Check if manifest has an error
                if m[:err]
                  append_log("[WARN] #{repo[:name]} has error: #{m[:err]}")
                end

                assets = (kind == :script) ? safe_repo_scripts(m) : safe_repo_data(m)
                if assets.any?
                  successful_repos += 1
                  append_log("[jinx.gui] Found #{assets.size} #{kind}(s) in #{repo[:name]}")
                elsif m[:available].is_a?(Array) && m[:available].empty?
                  append_log("[INFO] #{repo[:name]} has no #{kind}s available")
                elsif !m[:available].is_a?(Array)
                  append_log("[WARN] #{repo[:name]} has invalid manifest structure")
                else
                  # Repository has items but none of this type
                  other_count = m[:available].size
                  append_log("[INFO] #{repo[:name]} has #{other_count} total assets but no #{kind}s")
                end

                assets.each do |asset|
                  fname = File.basename(CGI.unescape(asset[:file].to_s))
                  next if fname.empty?

                  installed = installed_status(kind, fname)
                  modified  = modified_status(kind, fname, asset)
                  updated   = safe_ago(asset[:last_commit])

                  row = [fname, m[:name].to_s, installed, modified, updated]
                  rows << row
                end
              end

              append_log("[jinx.gui] Successfully loaded #{kind}s from #{successful_repos}/#{repos.size} repositories")

              # Cache the full list
              @full_asset_lists[kind] = rows

              # Apply filter if present
              if pattern
                rows = rows.select { |r| r[0] =~ pattern }
                append_log("[jinx.gui] Found #{rows.size} #{kind}(s) matching '#{filter}'")
              else
                append_log("[jinx.gui] Total: #{rows.size} #{kind}(s)")
              end
            end

            return unless @alive # Don't update UI if shutting down
            ui do
              return unless model && view && @alive
              begin
                @model_mutex.synchronize do
                  model.clear
                  # Sort by Name, then Repo (keeps identical names adjacent but separate by repo)
                  rows.sort_by! { |r| [r[0].to_s, r[1].to_s] }
                  rows.each { |r| it = model.append; (0..4).each { |i| it[i] = r[i] } }

                  # Restore previous selection if possible
                  if prev_name && prev_repo && view && !view.destroyed?
                    it = model.iter_first
                    while it
                      if it[0].to_s == prev_name && it[1].to_s == prev_repo
                        path = it.path
                        view.selection.select_path(path)
                        view.set_cursor(path, view.columns.first, false)
                        break
                      end
                      break unless it.next!
                    end
                  end
                end

                # Update info panel if search completed
                if filter
                  t = (kind == :script) ? @script_info_text : @data_info_text
                  if t && !t.destroyed?
                    if rows.empty?
                      t.buffer.text = "No #{kind}s found matching '#{filter}'"
                    else
                      t.buffer.text = "Found #{rows.size} #{kind}(s) matching '#{filter}'\n\nSelect an item and click Info to see details"
                    end
                  end
                end
              rescue
                # Silently ignore errors during shutdown
              end
            end
          end
        end

        # Clear only asset cache (keep manifests)
        def clear_asset_cache!
          @full_asset_lists = { script: [], data: [] }
          append_log("[jinx.gui] Asset cache cleared")
        end

        # Clear all caches (manifests and assets)
        def clear_all_caches!
          @manifest_cache_mutex.synchronize { @manifest_cache.clear }
          @full_asset_lists = { script: [], data: [] }
          append_log("[jinx.gui] All caches cleared")
        end

        # Retry wrapper for manifest fetches
        def manifest_with_retries(repo, attempts: 3, delay: 1.0)
          last_e = nil
          attempts.times do |i|
            begin
              append_log("[DEBUG] Attempt #{i + 1}/#{attempts} to fetch manifest for #{repo[:name]}...")
              m = ::Lich::Common::Jinx::Repo.manifest(repo)

              # Check if it's actually a valid manifest
              if m.is_a?(Hash)
                if m[:err]
                  # Repo.manifest returns error in :err field
                  append_log("[DEBUG] #{repo[:name]} returned error: #{m[:err]}")
                  return m # Return it anyway so we can handle it properly
                elsif m[:available].is_a?(Array)
                  append_log("[DEBUG] #{repo[:name]} manifest loaded successfully with #{m[:available].size} assets")
                  return m
                else
                  append_log("[DEBUG] #{repo[:name]} manifest missing :available array")
                  raise "invalid manifest structure - no :available array"
                end
              else
                append_log("[DEBUG] #{repo[:name]} returned non-Hash: #{m.class}")
                raise "manifest is not a Hash: #{m.class}"
              end
            rescue => e
              last_e = e
              append_log("[DEBUG] Attempt #{i + 1} failed: #{e.message}")
              sleep(delay) if i < attempts - 1
            end
          end
          append_log("[ERROR] All #{attempts} attempts failed for #{repo[:name]}")
          raise(last_e || "manifest failed after #{attempts} attempts")
        end

        def installed_status(kind, filename)
          dir =
            if kind == :script
              ::Lich::Common::Jinx::Folder.script_dir rescue nil
            else
              ::Lich::Common::Jinx::Folder.data_dir rescue nil
            end
          return 'unknown' unless dir.is_a?(String) && !dir.empty?
          File.exist?(File.join(dir, filename)) ? 'yes' : 'no'
        end

        def modified_status(kind, filename, asset)
          require 'digest/sha1'
          dir =
            if kind == :script
              ::Lich::Common::Jinx::Folder.script_dir rescue nil
            else
              ::Lich::Common::Jinx::Folder.data_dir rescue nil
            end
          return '-' unless dir.is_a?(String) && !dir.empty?
          path = File.join(dir, filename)
          return '-' unless File.exist?(path)
          begin
            remote_b64 = asset[:md5].to_s # upstream digest field is :md5 (base64 SHA1)
            return 'unknown' if remote_b64.empty?
            local_b64 = Digest::SHA1.base64digest(File.binread(path))
            (local_b64 == remote_b64) ? 'clean' : 'modified'
          rescue
            'unknown'
          end
        end

        # =====================
        # Log Tab with size limit
        # =====================
        MAX_LOG_LINES = 10000

        def build_log_tab
          @log_view = Gtk::TextView.new
          @log_view.editable = false
          @log_view.wrap_mode = :word_char
          @log_buffer = @log_view.buffer
          @log_buffer.text = "Jinx GUI initialized at #{Time.now}\n"

          clear_btn = Gtk::Button.new(label: 'Clear Log')
          clear_btn.signal_connect('clicked') do
            ui {
              @log_buffer.text = "Log cleared at #{Time.now}\n" if @log_buffer && !@log_view.destroyed?
            }
          end

          scroller = Gtk::ScrolledWindow.new; scroller.add(@log_view)
          box = Gtk::Box.new(:vertical, 8); box.margin = 8
          box.pack_start(clear_btn, expand: false, fill: false, padding: 0)
          box.pack_start(scroller, expand: true, fill: true, padding: 0)
          box
        end

        def append_log(line)
          # Filter out noisy non-Jinx output
          return if line.to_s =~ /uberbar|dialogData|progressBar|anchor_left|Target Window|label id=/i
          return if line.to_s.strip.empty?
          return unless @alive # Don't try to update if shutting down

          ui do
            return unless @log_buffer && @log_view && @alive
            begin
              # Trim if too large
              line_count = @log_buffer.line_count
              if line_count > MAX_LOG_LINES
                start_iter = @log_buffer.start_iter
                end_iter = @log_buffer.get_iter_at_line(line_count - MAX_LOG_LINES + 100)
                @log_buffer.delete(start_iter, end_iter)
              end

              it = @log_buffer.end_iter
              @log_buffer.insert(it, line.to_s + "\n")
              # Auto-scroll
              mark = @log_buffer.create_mark(nil, it, false)
              @log_view.scroll_mark_onscreen(mark) if @log_view && !@log_view.destroyed?
              @log_buffer.delete_mark(mark) if mark
            rescue
              # Silently ignore errors during shutdown
            end
          end
        end

        # =====================
        # Shared widget helpers
        # =====================
        def add_text_column(view, title, idx, sortable: false)
          renderer = Gtk::CellRendererText.new
          col = Gtk::TreeViewColumn.new(title, renderer, text: idx)
          col.resizable = true
          col.sort_column_id = idx if sortable
          view.append_column(col)
        end

        def selected_iter(view)
          return nil unless view && !view.destroyed?
          sel  = view.selection
          res  = sel.selected
          iter = res.is_a?(Array) ? res[1] : res
          if iter.nil?
            begin
              path, _col = view.cursor
              iter = view.model.get_iter(path) if path
            rescue => e
              append_log("[DEBUG] selected_iter: cursor fallback err: #{e.message}")
            end
          end
          iter
        end

        # =====================
        # Safe wrappers (tolerate older Jinx)
        # =====================
        def safe_repo_scripts(repo)
          ::Lich::Common::Jinx::Repo.respond_to?(:scripts) ? ::Lich::Common::Jinx::Repo.scripts(repo) : (repo[:scripts] || [])
        end

        def safe_repo_data(repo)
          ::Lich::Common::Jinx::Repo.respond_to?(:data) ? ::Lich::Common::Jinx::Repo.data(repo) : (repo[:data] || [])
        end

        # =====================
        # Keep-alive check
        # =====================
        def alive?
          @alive
        end

        # =====================
        # Cleanup method
        # =====================
        def cleanup!
          @alive = false

          # Cancel all refresh threads
          @refresh_threads.each_value do |thread|
            thread.kill if thread&.alive?
          end rescue nil

          # Destroy window
          ui {
            @win.destroy if @win && !@win.destroyed?
          } rescue nil
        end
      end
    end
  end
end

if defined?(Lich::Util) or defined?(Urnon)
  ::Lich::Common::Jinx::Setup.apply()
  ::Lich::Common::Jinx::Util.unwrap {
    ::Lich::Common::Jinx::Service.main(Script.current.vars.slice(1..-1))
  } if defined?(script.name)
end
