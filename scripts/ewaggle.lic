=begin

  ewaggle.lic:  Spellup script for yourself and others.  This script is a rewrite of ultrawaggle from SpiffyJr, which is a heavily modified version of spellup from Shaelun and Blueland.
    ;ewaggle help

        author: elanthia-online
  contributors: Tillmen, Tysong, Deysh
          game: gs
          tags: magic, utility, spell
      required: Lich >= 5.9.0
       version: 2.1.5

  Version Control:
    Major_change.feature_addition.bugfix
  2.1.5 (2025-11-25)
    - add disk casting support
  2.1.4 (2025-10-16)
    - bugfix in logic bad target/spell
  2.1.3 (2025-04-24)
    - bugfix in --cast-list regex
  2.1.2 (2025-04-23)
    - bugfix for info['sharing']
  2.1.1 (2025-03-03)
    - remove additional deprecated Lich calls
  2.1.0 (2025-03-03)
    - added option to skip characters not sharing spell info
  2.0.5 (2025-03-02)
    - bugfix in cast_solid code
  2.0.4 (2025-02-19)
    - bugfix for CLI variable of the wrong type
  2.0.3 (2025-02-19)
    - bugfix --useoptions to have the use be optional for CLI usage
  2.0.2 (2025-02-18)
    - bugfix in check_mana returning due to unnecessary stamina_cost check
  2.0.1 (2025-02-17)
    - bump minimum version to 5.8 due to PSM bug in 5.7
    - add --skip-armor flag for avoid overwriting existing
    - bugfix for mana bread
  2.0.0 (2025-02-06)
    Refactor code now requires Lich 5.7.0 or better
    converted to use yaml profiles
    uses terminal-table for info, list, and help output
    added support for armor buffs
    added support for sonic gear
    added option for self when buffing a group instead of your name. Ex ;ewaggle Bil Joe self
    removed dont_cast_over parameter since its obsolete
  1.0.5 (2024-12-31):
    Bugfix in sorting of spells in cast_list and in GTK setup window
  1.0.4 (2024-07-09):
    Fix to Symbol of Mana to not spam if out of favor
  1.0.3 (2024-05-01):
    Change Char.prof to Stats.prof
  1.0.2 (2024-02-14):
    removal of CONSTANT to cleanup log output
  1.0.1 (2022-04-07):
    bugfix for reget in GTK queue
    update default cast_list for new configs
  1.0.0 (2022-04-07):
    rename waggle -> ewaggle
    Add bail mode

=end
=begin
waggle.lic prior release notes
  0.18.4 (2023-04-05):
    Update wander proc for FalseClass error
    Rubocop cleanup
    Change script.vars to Script.current.vars
  0.18.3 (2022-03-15):
    Replaced squelching of SPELL ACTIVE using Lich::Util.quiet_command_xml
  0.18.2 (2022-03-09):
    Fix for Lich 5.4.0 and Effects symbol of mana
  0.18.1 (2021-08-21):
    Updated to account for Monk and Feat mental acuity
  0.17.0 (2021-08-12):
    updated with new SPELL ACTIVE format
    updated header information for standardization
  0.16 (2020-08-21):
    added squelching of spell active output (using quiet_command from Lostranger scripts)
  0.15 (2020-08-20):
    hacked in using new SPELL ACTIVE <target> functionality
  0.14 (2019-05-11):
    fix --reserve-mana (austin-j)
  0.13 (2019-03-03):
    set refreshable_min value from CLI if present (sandersch)
  0.12 (2018-04-20):
    fix --refreshable-min command line option

=end

# fixme: option to cast high level spells first

# Check version of Lich for compatibility
lich_gem_requires = Script.list.find { |x| x.name == Script.current.name }.inspect[/required: Lich >= (\d+\.\d+\.\d+)/i, 1]

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires)
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
    _respond "##" + "########################################"
  end
  exit
end

require 'yaml'
require 'terminal-table'

# Data
module Ewaggle
  class Data
    attr_accessor :settings, :known_spells, :did_something, :short_spell_time, :cast_list, :wander, :skip_spells, :skip_targets, :revert,
                  :options, :cli_options, :armor_list, :original_settings

    def initialize(settings)
      @settings = settings
      @did_something = false
      @short_spell_time = 3
      @cast_list = @settings[:cast_list].reject { |entry| entry =~ /armor/i && entry !~ /sonic|mage/i }.map { |entry| entry[/^\d+/].to_i }.reject(&:zero?)
      @armor_list = @settings[:cast_list].select { |item| item =~ /Armor/i && item !~ /sonic|mage/i }
      @wander = []
      @skip_spells = []
      @skip_targets = []
      @revert = false
      @original_settings = nil

      @cli_options = {
        /^\-\-start[_\-]at=(\d+)(?=\s--\w+|$)/                          => :start_at,
        /^\-\-stop[_\-]at=(\d+)(?=\s--\w+|$)/                           => :stop_at,
        /^\-\-\b(?:unstackable|refreshable)[_\-]min=(\d+)(?=\s--\w+|$)/ => :refreshable_min,
        /^\-\-cast[_\-]list=([^\s]+)(?=\s--\w+|$)/                      => :cast_list,
        /^\-\-(?:use[_\-])?multicast=(on|off)(?=\s--\w+|$)/             => :use_multicast,
        /^\-\-(?:use[_\-])?wracking=(on|off)(?=\s--\w+|$)/              => :use_wracking,
        /^\-\-wander[_\-]to[_\-]wrack=(on|off)(?=\s--\w+|$)/            => :wander_to_wrack,
        /^\-\-(?:use[_\-])?power=(on|off)(?=\s--\w+|$)/                 => :use_power,
        /^\-\-(?:use[_\-])?mana=(on|off)(?=\s--\w+|$)/                  => :use_mana,
        /^\-\-(?:use[_\-])?concentration=(on|off)(?=\s--\w+|$)/         => :use_concentration,
        /^\-\-bail=(on|off)(?=\s--\w+|$)/                               => :bail_no_mana,
        /^\-\-skip[_\-]short(?:[_\-]spells)?=(on|off)(?=\s--\w+|$)/     => :skip_short_spell,
        /^\-\-retribution[_\-]spell=(on|off|none)(?=\s--\w+|$)/         => :retribution_spell,
        /^\-\-reserve[_\-]mana=(\d+)(?=\s--\w+|$)/                      => :reserve_mana,
        /^\-\-(?:use[_\-])?203=(on|off)(?=\s--\w+|$)/                   => :use_203,
        /^\-\-(?:use[_\-])?515=(on|off)(?=\s--\w+|$)/                   => :use_515,
        /^\-\-skip[_\-]not[_\-]sharing=(on|off)(?=\s--\w+|$)/           => :skip_not_sharing,
        /^\-\-skip[_\-]armor(?=\s--\w+|$)/                              => :skip_armor,
        /^\-\-save$/                                                    => :save
      }

      @options = {
        /add\b/i                                   => :cast_list,
        /^rem(?:ove)?\b|^del(?:ete)?\b/i           => :cast_list,
        /^start[_\-]at\b/i                         => :start_at,
        /^stop[_\-]at\b/i                          => :stop_at,
        /^(?:unstackable|refreshable)[_\-]?min\b/i => :unstackable_min,
        /^(?:use[_\-])?multicast\b/i               => :use_multicast,
        /^(?:use[_\-])?wracking\b/i                => :use_wracking,
        /^bail\b/i                                 => :bail_no_mana,
        /^wander(?:[_\-]to[_\-]wrack)?\b/i         => :wander_to_wrack,
        /^(?:use[_\-])?power\b/i                   => :use_power,
        /^(?:use[_\-])?concentration\b/i           => :use_concentration,
        /^(?:use[_\-])?mana\b/i                    => :use_mana,
        /^skip[_\-]short(?:[_\-]spells)\b/i        => :skip_short_spells,
        /^reserve[_\-]mana\b/i                     => :reserve_mana,
        /^(?:use[_\-])?203\b/i                     => :use_203,
        /^(?:use[_\-])?515\b/i                     => :use_515,
        /^skip[_\-]not(?:[_\-]sharing)\b/i         => :skip_not_sharing,
        /^retribution(?:[_\-]spell)?\b/i           => :retribution_spell
      }

      valid_retribution_spells = [
        '701', '702', '703', '705', '706', '708', '711', '713', '715', '716', '717', '718', '719', '740',
        '102', '106', '110', '111', '118', '119', '130',
        '409', '412', '413', '415', '417'
      ]

      if !valid_retribution_spells.include?(@settings[:retribution_spell]) && !@settings[:retribution_spell].to_s.empty?
        respond " #{@settings[:retribution_spell]} #{Spell[@settings[:retribution_spell]]} is not a valid retribution spell."
        respond " Please visit https://gswiki.play.net/Cloak_of_Shadows_(712) for a complete list"
        @settings[:retribution_spell] = ""
      end
    end
  end
end

# Setup
if defined?(Gtk)
  module Ewaggle
    class Setup < Gtk::Builder
      attr_accessor :settings

      @@categories = {
        general: {
          not_to_cast: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text.to_s
              end
            end
          },
          cast_list: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text.to_s
              end
            end
          },
          start_at: { default: 180 },
          stop_at: { default: 180 },
          refreshable_min: { default: 15 },
          armor_min: { default: 15 },
          use_multicast: { default: true },
          use_wracking: { default: false },
          wander_to_wrack: { default: false },
          use_power: { default: false },
          use_mana: { default: false },
          use_concentration: { default: false },
          skip_not_sharing: { default: false },
          skip_short_spells: { default: false },
          bail_no_mana: { default: false },
          reserve_mana: { default: 0 },
          retribution_spell: { default: "" },
          use_203: { default: false },
          use_515: { default: false },
          sonic_weapon: { default: "" },
          sonic_shield: { default: "" },
          sonic_armor: { default: "" },
        },
        internal: {
          debug: { default: false },
        },
      }

      def start
        @drag_key = nil
        @running = true
        Gtk.queue do
          self['main'].show_all

          # selectively hide things based on class/knowledge
          # Sorcerer and 712
          self['retribution_label'].visible = false unless Spell[712].known?
          self['retribution_spell'].visible = false unless Spell[712].known?

          # Bard and Sonic Gear
          self['sonic_weapon_label'].visible = false unless Spell[1012].known?
          self['sonic_weapon'].visible = false unless Spell[1012].known?
          self['sonic_shield_label'].visible = false unless Spell[1009].known?
          self['sonic_shield'].visible = false unless Spell[1009].known?
          self['sonic_armor_label'].visible = false unless Spell[1014].known?
          self['sonic_armor'].visible = false unless Spell[1014].known?

          # Society Options
          self['options_grid'].children.each do |widget|
            next if widget.builder_name =~ /use_multicast|skip_short_spells|bail_no_mana/
            if widget.is_a?(Gtk::CheckButton)
              self['options_grid'].remove(widget)
            end
          end

          # Check column 1
          row = 3
          if Spell[203].known?
            self['options_grid'].attach(self['use_203'], 0, row, 1, 1)
            row += 1
          end

          if Spell[515].known?
            self['options_grid'].attach(self['use_515'], 0, row, 1, 1)
          end

          # Check Column #2
          if Society.member == 'Council of Light'
            self['options_grid'].attach(self['use_wracking'], 1, 0, 1, 1)
            self['options_grid'].attach(self['wander_to_wrack'], 1, 1, 1, 1)
          elsif Society.member == 'Guardians of Sunfist'
            self['options_grid'].attach(self['use_power'], 1, 0, 1, 1)
            self['options_grid'].attach(self['use_concentration'], 1, 1, 1, 1)
          elsif Society.member == 'Order of Voln'
            self['options_grid'].attach(self['use_mana'], 1, 0, 1, 1)
          end
        end
        wait_while { @running }
      end

      def self.get_category(key)
        @@categories.each { |category, data| return category unless data[key].nil? }
        nil
      end

      def self.get_setting(key)
        cat = Setup.get_category(key)
        return nil if cat.nil?

        @@categories[cat].each { |setting, data| return data if setting == key }
        nil
      end

      def initialize(settings)
        super()
        @original = settings.dup
        @silent_exit = false
        @settings = settings
        @script_name = Script.current.name.capitalize

        # Not_to_cast list needs reset if using CLI.
        reset_no_cast

        # Get script version
        version = Ewaggle.get_script_version

        # set default values if they don't exist
        @@categories.each do |_key, data|
          data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
        end

        # remove settings that don't exist
        @settings.delete_if { |key, _| next Setup.get_category(key).nil? }

        # use a GTK Builder to setup all the basics of the window then expand on that base
        return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

        Gtk.queue do
          # add_from_file("#{$data_dir}ewaggle.ui")
          add_from_string(Setup.ewaggle_ui)
          load_settings

          self['main'].keep_above = true
          self['main'].set_title "Ewaggle Setup v#{version}"
          # connect signals after settings are loaded to a bunch of handlers don't trigger
          connect_signals { |handler| method(handler) }
        end
      end

      def reset_no_cast
        @settings[:not_to_cast] = []

        # Remove spells from casting list character doesn't know
        @settings[:cast_list].reject! do |entry|
          number = entry[/^\d+/].to_i # Extract leading digits and convert to integer
          if entry =~ /armor/i && entry !~ /sonic|mage/i
            !Armor.known?(entry.gsub(/^\d+\s*/, ''))
          else
            !Spell[number].known?
          end
        end

        gtk_spells = []
        Spell.list.each { |spell| gtk_spells.push(spell) if (spell.known? && spell.time_per > 0 && spell.num.to_s =~ /(?:[1-4][0-9]|50|0[1-9])$/) }
        gtk_spells.push(Spell[511]) if Spell[511].known?
        gtk_spells.sort_by!(&:num)

        # Rebuild the not to cast list
        gtk_spells.each do |spell|
          next if @settings[:cast_list].include?("#{spell.num}  #{spell.name}")
          @settings[:not_to_cast] << "#{spell.num}  #{spell.name}"
        end

        Ewaggle.armor_spells.each { |name, number|
          next unless Armor.known?(name)
          next if @settings[:cast_list].any? { |word| word =~ /armor/i }
          @settings[:not_to_cast] << "#{number} #{name}"
        }

        @settings[:not_to_cast].uniq!
      end

      def on_close_clicked
        # Need to update the spells
        Ewaggle.data.settings[:cast_list] = []
        self["cast_list_store"].each do |_model, _path, iter|
          Ewaggle.data.settings[:cast_list] << iter[0]
        end

        Ewaggle.data.settings[:not_to_cast] = []
        self["not_to_cast_store"].each do |_model, _path, iter|
          Ewaggle.data.settings[:not_to_cast] << iter[0]
        end

        Ewaggle.save_profile

        @silent_exit = true
        self['main'].destroy
      end

      def on_destroy
        Gtk.queue {
          unless @silent_exit
            respond
            Lich::Messaging.msg('plain', " #{@script_name} UI closed WITHOUT saving any changes")
            Lich::Messaging.msg('plain', " Be sure to use the close button to save changes")
            respond
          end
          @running = false
        }
      end

      # iterate all objects and for any that match a setting name directly we set the default
      def load_settings
        Gtk.queue do
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)

            key = obj.builder_name.to_sym
            builder_name = obj.builder_name.to_s
            next if (setting = Setup.get_setting(key)).nil?

            conditions = {
              "retribution_spell" => !Spell[712].known?,
              "use_wracking"      => !(Society.member == 'Council of Light' && Society.rank >= 18),
              "wander_to_wrack"   => !(Society.member == 'Council of Light' && Society.rank >= 18),
              "use_power"         => !(Society.member == 'Guardians of Sunfist' && Society.rank >= 18),
              "use_concentration" => !(Society.member == 'Guardians of Sunfist' && Society.rank >= 14),
              "use_mana"          => !(Society.member == 'Order of Voln' && Society.rank >= 13),
              "use_203"           => !Spell[203].known?,
              "use_515"           => !Spell[515].known?
            }

            # disable options and set them to false if the character can't do them
            if conditions[builder_name]
              obj.set_sensitive(false)
              @settings[key] = builder_name == "retribution_spell" ? "" : false
            end

            if obj.class == Gtk::CheckButton
              obj.active = @settings[key]
              obj.signal_connect('toggled') do
                @settings[key] = obj.active?
              end
            elsif obj.class == Gtk::Entry
              obj.text = @settings[key].strip
              obj.signal_connect('changed') do
                @settings[key] = obj.text.strip
              end
            elsif obj.class == Gtk::SpinButton
              obj.adjustment.value = @settings[key]
              obj.signal_connect("value-changed") do
                @settings[key] = obj.value.to_i
                obj.update
              end
            elsif obj.class == Gtk::ComboBoxText
              obj.set_active_id(@settings[key].to_s)
              obj.signal_connect('changed') do
                @settings[key] = obj.active_id
              end
            elsif obj.class == Gtk::TreeView
              if (store = self["#{key}_store"]).nil?
                respond "** failed to find store for treeview #{key}"
                next
              elsif setting[:load].nil?
                respond "** no :load defined #{key}"
                next
              end

              @settings[key].sort_by! { |str| str.to_i }

              setting[:load].call(store, @settings[key])

              # Add Drag & Drop Support
              enable_drag_and_drop(obj, key)
            end
          end
        end
      end

      def enable_drag_and_drop(tree_view, key)
        tree_view.enable_model_drag_source(Gdk::ModifierType::BUTTON1_MASK, [Gtk::TargetEntry.new("STRING", Gtk::TargetFlags::SAME_APP, 0)], Gdk::DragAction::MOVE)

        tree_view.enable_model_drag_dest([Gtk::TargetEntry.new("STRING", Gtk::TargetFlags::SAME_APP, 0)], Gdk::DragAction::MOVE)

        tree_view.signal_connect("drag-data-get") do |widget, _drag_context, data, _info, _time|
          iter = widget.selection.selected
          next if iter.nil?

          @drag_key = key
          spell_name = iter[0].strip # Get the full string value (ID + Name)

          data.set(Gdk::Selection::TYPE_STRING, spell_name.to_s)
        end

        tree_view.signal_connect("drag-data-received") do |_widget, drag_context, _x, _y, data, _info, _time|
          dropped_spell = data.text.strip # Ensure there are no extra spaces

          next if dropped_spell.nil? || dropped_spell.empty?

          # Ensure the correct key is being used
          src_key = key == :not_to_cast ? "cast_list" : "not_to_cast"
          dst_key = key == :not_to_cast ? "not_to_cast" : "cast_list"

          # Get the actual stores for source and destination
          src_store = self["#{src_key}_store"]
          dst_store = self["#{dst_key}_store"]

          if @drag_key.to_s == dst_key.to_s
            dst_iter = dst_store.append
            dst_iter.set_value(0, dropped_spell)
          else
            # Remove the dropped spell from source store
            found = false
            src_store.each do |_model, _path, iter|
              spell_id_name = iter[0].strip # Get the full ID + Name

              if spell_id_name.eql?(dropped_spell)
                src_store.remove(iter)
                found = true
                break
              end
            end

            # Add the dropped spell to destination store
            if found
              dst_iter = dst_store.append
              dst_iter.set_value(0, dropped_spell)
            end
          end

          # Confirm drag is done
          drag_context.finish(:success => true, :delete => false, :time => Gdk::CURRENT_TIME)

          # Clear selection after the drag event
          self[src_key].selection.unselect_all
          self[dst_key].selection.unselect_all

          # Sort both source and destination stores
          src_store.set_sort_column_id(0, Gtk::SortType::ASCENDING)
          dst_store.set_sort_column_id(0, Gtk::SortType::ASCENDING)
        end

        # Handle double-click to move item
        tree_view.signal_connect("row-activated") do |widget, path, _column|
          model = widget.model
          iter = model.get_iter(path)
          next if iter.nil?

          spell_name = iter[0].strip
          move_spell_between_lists(spell_name, key)

          widget.selection.unselect_all
        end
      end

      def move_spell_between_lists(spell_name, key)
        # Determine source and destination lists
        src_key = key == :not_to_cast ? "not_to_cast_store" : "cast_list_store"
        dst_key = key == :not_to_cast ? "cast_list_store" : "not_to_cast_store"

        src_store = self[src_key]
        dst_store = self[dst_key]

        # Remove from source store
        found = false
        src_store.each do |_model, _path, iter|
          if iter[0].strip == spell_name
            src_store.remove(iter)
            found = true
            break
          end
        end

        # Add to destination store
        if found
          dst_iter = dst_store.append
          dst_iter.set_value(0, spell_name)
        end

        # Sort after event
        src_store.set_sort_column_id(0, Gtk::SortType::ASCENDING)
        dst_store.set_sort_column_id(0, Gtk::SortType::ASCENDING)
      end

      def self.ewaggle_ui
        '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkAdjustment" id="armor_adjustment"><property name="upper">410</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="cast_list_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/>
        </columns></object><object class="GtkAdjustment" id="dont_cast_adjustment"><property name="upper">250</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="minimum_adjustment"><property name="upper">250</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="not_to_cast_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/>
        </columns></object><object class="GtkAdjustment" id="reserve_adjustment"><property name="upper">1000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="start_casting_adjustment"><property name="upper">250</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="stop_casting_adjustment"><property name="upper">250</property><property name="step-increment">1</property><property name="page-increment">10</property>
        </object><object class="GtkWindow" id="main"><property name="width-request">730</property><property name="height-request">800</property><property name="can-focus">False</property><property name="title" translatable="yes">Ewaggle Setup</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=2 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkScrolledWindow"><property name="height-request">250</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="cast_list"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">cast_list_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">250</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="not_to_cast"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">not_to_cast_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Spells Not to Cast</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Spells to cast</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="width-request">280</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">15</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Start Casting Below:</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Stop Casting at:</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="start_at"><property name="width-request">132</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">start_casting_adjustment</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkSpinButton" id="stop_at"><property name="width-request">132</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">stop_casting_adjustment</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Stackable Spells</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkFrame"><property name="width-request">220</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=11 --><object class="GtkGrid" id="options_grid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><child><object class="GtkCheckButton" id="use_multicast"><property name="label" translatable="yes">Multicast</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_wracking"><property name="label" translatable="yes">Sign of Wracking</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="wander_to_wrack"><property name="label" translatable="yes">Wander to Wrack</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_power"><property name="label" translatable="yes">Sigil of Power</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="use_concentration"><property name="label" translatable="yes">Sigil of Concentration</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="use_mana"><property name="label" translatable="yes">Symbol of Mana</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkCheckButton" id="skip_short_spells"><property name="label" translatable="yes">Skip Short Spells on Others</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="bail_no_mana"><property name="label" translatable="yes">Bail on No More Resources</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="use_203"><property name="label" translatable="yes">Use Mana Bread (203)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="use_515"><property name="label" translatable="yes">Use Rapid Fire (515)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel" id="sonic_weapon_label"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">20</property><property name="label" translatable="yes">Sonic Weapon: (&lt;a href="https://gswiki.play.net/Weapon"&gt;gswiki.play.net/Weapon&lt;/a&gt;)</property><property name="use-markup">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">5</property><property name="width">2</property></packing></child><child><object class="GtkEntry" id="sonic_weapon"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Notable exceptions: Katana, Naginata, Claidhmore, and Missile Weapons.</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="placeholder-text" translatable="yes">Name of sonic weapon (follow link for options)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">6</property><property name="width">2</property></packing></child><child><object class="GtkLabel" id="sonic_shield_label"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Sonic Shield: (&lt;a href="https://gswiki.play.net/Sonic_Shield_Song_(1009)"&gt;gswiki.play.net/Sonic Shield Song&lt;/a&gt;)</property><property name="use-markup">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">7</property><property name="width">2</property></packing></child><child><object class="GtkEntry" id="sonic_shield"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-end">20</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="placeholder-text" translatable="yes">Name of sonic weapon (follow link for options)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">8</property><property name="width">2</property></packing></child><child><object class="GtkLabel" id="sonic_armor_label"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Sonic Armor:  (&lt;a href="https://gswiki.play.net/Sonic_Armor_(1014)"&gt;https://gswiki.play.net/Sonic Armor&lt;/a&gt;)</property><property name="use-markup">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">9</property><property name="width">2</property></packing></child><child><object class="GtkComboBoxText" id="sonic_armor"><property name="width-request">200</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="has-entry">True</property><items><item id="Robes" translatable="yes">Robes (1)</item><item id="Light Leather" translatable="yes">Light Leather (5)</item><item id="Full Leather" translatable="yes">Full Leather (6)</item><item id="Reinforced Leather" translatable="yes">Reinforced Leather (7)</item><item id="Double Leather" translatable="yes">Double Leather (8)</item><item id="Leather Breastplate" translatable="yes">Leather Breastplate (9)</item><item id="Cuirbouilli Leather" translatable="yes">Cuirbouilli Leather (10)</item><item id="Studded Leather" translatable="yes">Studded Leather (11)</item><item id="Brigandine Armor" translatable="yes">Brigandine Armor (12)</item><item id="Chain mail" translatable="yes">Chain Mail (13)</item><item id="Double Chain" translatable="yes">Double Chain (14)</item><item id="Augmented Chain" translatable="yes">Augmented Chain (15)</item><item id="Chain Hauberk" translatable="yes">Chain Hauberk (16)</item><item id="Metal Breastplate" translatable="yes">Metal Breastplate (17)</item><item id="Augmented Plate" translatable="yes">Augmented Plate (18)</item><item id="Half Plate" translatable="yes">Half Plate (19)</item><item id="Full Plate" translatable="yes">Full Plate (20)</item>
        </items><child internal-child="entry"><object class="GtkEntry"><property name="can-focus">True</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">10</property><property name="width">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Options</property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">2</property><property name="height">3</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Spells above this time will NOT be cast</property><property name="halign">end</property><property name="margin-start">20</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Minimum Time(?): </property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkSpinButton" id="refreshable_min"><property name="width-request">132</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">minimum_adjustment</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Armor buffs above this time will NOT be cast</property><property name="halign">end</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Armor Buffs(?): </property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkSpinButton" id="armor_min"><property name="width-request">132</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="adjustment">armor_adjustment</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object>
        </child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Non-Stackable Spells</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><child><object class="GtkLabel" id="retribution_label"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Retribution Spell:</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">40</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Reserve Mana:</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkSpinButton" id="reserve_mana"><property name="width-request">132</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">reserve_adjustment</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkEntry" id="retribution_spell"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="width-chars">19</property><property name="placeholder-text" translatable="yes">Spell Number Only</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="skip_not_sharing"><property name="label" translatable="yes">Skip characters not sharing spell info</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="margin-start">40</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object>
        </child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property></object><packing><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes">To save properly, exit with the close button and not the X window --&gt;</property><attributes><attribute name="style" value="italic"/>
        </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
        </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
      end
    end
  end
end

# Profile loading/saving
module Ewaggle
  @@data ||= nil

  def self.data
    @@data
  end

  def self.armor_spells
    {
      "Armor Blessing"      => '9510',
      "Armored Casting"     => '9506',
      "Armored Evasion"     => '9505',
      "Armored Fluidity"    => '9507',
      "Armor Reinforcement" => '9509',
      "Armored Stealth"     => '9508',
      "Armor Support"       => '9504'
    }
  end

  def self.get_script_version
    data = Script.list.find { |x| x.name == Script.current.name }.inspect
    return data[/version: (\d+\.\d+\.\d+)/i, 1]
  end

  def self.load(settings)
    @@data = Data.new(settings)
  end

  def self.load_defaults()
    default_no_cast = []
    default_cast = []

    cast_list = [
      101, 102, 103, 107, 115, 120,
      202, 211, 215, 219,
      303, 307, 310, 313, 314, 319, 320,
      401, 406, 414, 425, 430,
      503, 507, 508, 509, 513, 520, 535,
      601, 602, 604, 605, 606, 612, 613, 617, 618, 620, 625, 640,
      704, 712, 716,
      905, 911, 913, 920,
      1003, 1006, 1007, 1010, 1019,
      1109, 1119, 1125, 1130,
      1202, 1204, 1208, 1214, 1215, 1220,
      1601, 1603, 1606, 1610, 1611, 1612, 1616
    ]

    cast_list.delete_if { |spell| !(Spell[spell].known? && Spell[spell].time_per > 0) }

    gtk_spells = []
    Spell.list.each { |spell| gtk_spells.push(spell) if (spell.known? && spell.time_per > 0 && spell.num.to_s =~ /(?:[1-4][0-9]|50|0[1-9])$/) }
    gtk_spells.push(Spell[511]) if Spell[511].known?
    gtk_spells.sort_by!(&:num)

    gtk_spells.each do |spell|
      if cast_list.include?(spell.num)
        default_cast << "#{spell.num}  #{spell.name}"
      else
        default_no_cast << "#{spell.num}  #{spell.name}"
      end
    end

    Ewaggle.armor_spells.each { |name, number|
      next unless Armor.known?(name)
      if name =~ /Blessing/ && Spell[9510].known?.nil?
        Lich::Messaging.msg('yellow', " The effect-list.xml is out of date.")
        Lich::Messaging.msg('yellow', " Update with ;repository download effect-list.xml")
        exit
      end
      default_no_cast << "#{number} #{name}"
    }

    # set up cast_list for the new format
    new_cast_list = []
    CharSettings['cast_list'].each do |spell|
      new_cast_list << "#{spell}  #{Spell[spell].name}"
    end

    default_cast_list = new_cast_list.length.positive? ? new_cast_list : default_cast

    default_hash = {
      :start_at          => CharSettings['start_at'] || 180,
      :stop_at           => [CharSettings['stop_at'] || 180, 250].min,
      :refreshable_min   => CharSettings['unstackable_min'] || 15,
      :armor_min         => 15,
      :use_multicast     => CharSettings['use_multicast'] || true,
      :use_wracking      => CharSettings['use_wracking'] || false,
      :wander_to_wrack   => CharSettings['wander_to_wrack'] || false,
      :use_power         => CharSettings['use_power'] || false,
      :use_mana          => CharSettings['use_mana'] || false,
      :use_concentration => CharSettings['use_concentration'] || false,
      :skip_not_sharing  => false,
      :skip_short_spells => CharSettings['skip_short_spells'] || false,
      :bail_no_mana      => CharSettings['bail_no_mana'] || false,
      :reserve_mana      => CharSettings['reserve_mana'] || 0,
      :retribution_spell => CharSettings['retribution_spell'] || "",
      :cast_list         => default_cast_list,
      :not_to_cast       => default_no_cast
    }

    return default_hash
  end

  def self.load_profile
    filename = File.join(DATA_DIR, XMLData.game, Char.name, 'ewaggle.yaml')

    if File.exist?(filename)
      settings_hash = YAML.load_file(filename)
    else
      settings_hash = Ewaggle.load_defaults
    end

    settings_hash
  end

  def self.save_profile
    if Ewaggle.data.settings == Ewaggle.data.original_settings
      respond
      Lich::Messaging.msg('plain', " Nothing to save. No changes were made.")
      respond
    else
      filename = File.join(DATA_DIR, XMLData.game, Char.name, 'ewaggle.yaml')
      File.write(filename, Ewaggle.data.settings.to_yaml)
      respond
      Lich::Messaging.msg('plain', " Settings saved to file: #{filename}.")
      respond
      Ewaggle.data.original_settings = Marshal.load(Marshal.dump(Ewaggle.data.settings))
    end
  end

  def self.test
    echo "test"
    # target_list = Ewaggle.target_list(Script.current.vars)
    # target_info = Ewaggle.target_info(target_list)
    # echo target_list
  end
end

# Misc Utility methods
module Ewaggle
  def self.determine_bonus(spell)
    bonus_list = []
    bonus_list.push "#{'+' if spell.bolt_as > 0}#{spell.bolt_as} bAS" unless spell.bolt_as.zero?
    bonus_list.push "#{'+' if spell.physical_as > 0}#{spell.physical_as} pAS" unless spell.physical_as.zero?
    bonus_list.push "#{'+' if spell.bolt_ds > 0}#{spell.bolt_ds} bDS" unless spell.bolt_ds.zero?
    bonus_list.push "#{'+' if spell.physical_ds > 0}#{spell.physical_ds} pDS" unless spell.physical_ds.zero?
    bonus_list.push "#{'+' if spell.elemental_cs > 0}#{spell.elemental_cs} eCS" unless spell.elemental_cs.zero?
    bonus_list.push "#{'+' if spell.spirit_cs > 0}#{spell.spirit_cs} spCS" unless spell.spirit_cs.zero?
    bonus_list.push "#{'+' if spell.sorcerer_cs > 0}#{spell.sorcerer_cs} soCS" unless spell.sorcerer_cs.zero?
    bonus_list.push "#{'+' if spell.elemental_td > 0}#{spell.elemental_td} eTD" unless spell.elemental_td.zero?
    bonus_list.push "#{'+' if spell.spirit_td > 0}#{spell.spirit_td} spTD" unless spell.spirit_td.zero?
    bonus_list.push "#{'+' if spell.sorcerer_td > 0}#{spell.sorcerer_td} soTD" unless spell.sorcerer_td.zero?
    bonus_list.push "#{'+' if spell.strength.to_i > 0}#{spell.strength} str" unless spell.strength.to_i.zero?
    bonus_list.push "#{'+' if spell.dodging.to_i > 0}#{spell.dodging} dodge" unless spell.dodging.to_i.zero?
    bonus_list.push 'Utility' if spell.num == 511

    # Armor buffs
    bonus_list.push 'Can prevent further wounds from magical attacks.' if spell.num == 9510
    bonus_list.push 'Can better recover from a failed spell casting attempt.' if spell.num == 9506
    bonus_list.push 'Better fitting for dodging attacks.' if spell.num == 9505
    bonus_list.push 'Can cast spells more easily while wearing the armor.' if spell.num == 9507
    bonus_list.push 'Better protects against repeated blows.' if spell.num == 9509
    bonus_list.push 'Can help mask characters movements.' if spell.num == 9508
    bonus_list.push 'Better supports the weight of the armor.' if spell.num == 9504

    bonus_list.join(', ')
  end

  def self.eat_bread(bypass_check: false)
    return unless Ewaggle.data.settings[:use_203] || bypass_check
    return if Effects::Spells.time_left("Manna") > 10

    empty_hand

    Casting.cast_spell(Spell[203], Char.name)

    bread = [GameObj.right_hand, GameObj.left_hand].find do |obj|
      obj.noun =~ /^(?:flatbread|teacake|crisps|cake|waybread|biscuit|oatcake|fritter|loaf|ball|cornmeal|wheatberries|cracker|dumpling|bread|tart|dough|seeds)$/
    end

    while [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(bread.id)
      fput "gobble ##{bread.id}"
      sleep 0.2
    end

    20.times {
      break if Effects::Spells.time_left("Manna").positive?
      sleep 0.1
    }

    fill_hand
  end

  def self.fix_spell(spell)
    if (spell.class == Integer) or (spell.class == String and spell =~ /^[0-9]+$/)
      spell = Spell[spell.to_i]
    end
    unless spell.class == Spell
      echo "error: missing spell information for #{spell}"
      exit
    end
    spell
  end

  def self.get_target_info(target)
    res = Lich::Util.quiet_command_xml("spell active #{target}", /currently has the following active effects|has spell sharing disabled\./)

    target_info = {}
    unless res.any?(/has spell sharing disabled/)
      res.each do |line|
        # Parsing from Infomon
        if line =~ /\s+([A-z0-9\s\'\(\)\-]+) \.* (([0-9]+)\:([0-9]+)\:([0-9]+)|Indefinite)$/
          spell_name = $1
          if $2 == 'Indefinite'
            spell_time = 599.0
          else
            spell_time = ($3.to_i * 60) + $4.to_i + ($5.to_i / 60.0)
          end
          if spell_name == 'Raise Dead Recovery'
            # fixme
            spell_name = 'Raise Dead Cooldown'
          elsif spell_name =~ /Mage Armor \- /
            spell_name = 'Mage Armor'
          elsif spell_name =~ /Cloak of Shadows \- /
            spell_name = 'Cloak of Shadows'
          end
          if (spell = Spell.list.find { |s| s.name == spell_name.strip() or s.num.to_s == spell_name.strip() })
            target_info[spell.num.to_s] = spell_time
          else
            echo "no spell matches #{spell_name}" if $infomon_debug
          end
        end
      end
      target_info['sharing'] = true
      target_info
    else
      target_info['sharing'] = false

      if Ewaggle.data.settings[:skip_not_sharing]
        return nil
      else
        respond
        Lich::Messaging.msg('plain', "#{target.capitalize} is not sharing spell information using SPELL PRIVACY")
        Lich::Messaging.msg('plain', "A single cast of each spell will be used instead.")
        Lich::Messaging.msg('plain', "To skip characters that don't share, toggle the 'skip not sharing' in the UI or CLI")
        respond

        return target_info
      end
    end
  end

  def self.help
    script_name = "#{$clean_lich_char}#{Script.current.name}"

    help_item = {
      "help"                       => "show this message",
      "setup"                      => "show setup window",
      "list"                       => "show current settings",
      "info"                       => "show what will be cast and how much it will cost",
      "info [name1] [name2]"       => "shows info for each character",
      "separator1"                 => "",
      "add [spell#]"               => "add one or more spells to the cast list",
      "delete [spell#]"            => "delete one or more spells from the cast list",
      "separator2"                 => "",
      "start-at [minutes]"         => "start casting stackable spells when there is (start_at) or less minutes remaining",
      "stop-at [minutes]"          => "stop casting if spell duration is above (stop_at)",
      "refreshable-min [minutes]"  => "minimum time less before casing for non-stacking spells",
      "separator3"                 => "",
      "multicast [on/off]"         => "use multicast",
      "wracking [on/off]"          => "use sign of wracking when out of mana",
      "wander [on/off]"            => "wander up to 20 rooms to find an empty room to wrack, then return",
      "power [on/off]"             => "use sigil of power when out of mana",
      "concentration [on/off]"     => "use sigil of concentration when out of mana",
      "mana [on/off]"              => "use symbol of mana when out of mana",
      "skip-short-spells [on/off]" => "don't cast spells with a duration less than #{Ewaggle.data.short_spell_time} minutes on others",
      "bail [on/off]"              => "stop casting if run out of mana/resource",
      "use_203 [on/off]"           => "cast/eat mana bread if 203 is known",
      "use_515 [on/off]"           => "cast 515 if know",
      "skip_not_sharing [on/off]"  => "skip characters not sharing spell information",
      "retribution-spell [#|none]" => "spell number for chant retribution after casting cloak of shadows",
      "separator4"                 => "",
      "just_script_name"           => "spell yourself up",
      "[name1] [name2] ..."        => "spell up the given people (may include your own name or word self)",
      "separator5"                 => "",
      "combined1"                  => { value: "Any or all saved options can be overridden on the command line without being saved using the following syntax:", colspan: 2 },
      "combined2"                  => { value: "#{script_name} --cast-list=401,406,503 --start-at=60 --stop-at=120 --retribution-spell=717 Jim Joe Bob", colspan: 2 },
      "combined3"                  => { value: "--skip-armor will skip casting any armor buffs.", colspan: 2 },
      "combined4"                  => { value: "--save as the last item will save command line entries to your profile.", colspan: 2 },
      "separator6"                 => "",
      "combined5"                  => { value: 'Sonic gear can be cast using --cast_list=1009("tower shield") or just --cast_list=1009 for the default.', colspan: 2 },
      "combined6"                  => { value: "*** Sonic Gear requires parentheses like: #{script_name} add 1009(\"tower shield\") ***", colspan: 2 },
    }

    rows = []
    help_item.each do |key, value|
      if key =~ /separator/
        rows << :separator
      elsif key =~ /combine/
        rows << [value]
      elsif key =~ /just_script_name/
        rows << ["#{script_name}", value]
      else
        rows << ["#{script_name} #{key}", value]
      end
    end

    table = Terminal::Table.new(
      title: "#{Script.current.name.capitalize} v#{Ewaggle.get_script_version} Help",
      rows: rows,
    )

    respond
    respond table
    respond

    exit
  end

  def self.info(target_info)
    dry_run = {}
    max_spell_name = 0

    # Stackable
    Ewaggle.data.cast_list.each do |spell|
      spell = Ewaggle.fix_spell(spell)
      max_spell_name = [max_spell_name, spell.name.length].max
      target_info.keys.each do |name|
        next unless spell.stackable?(:target => name)
        next unless spell.available?(:target => name)
        next unless spell.time_per(:target => name) > Ewaggle.data.short_spell_time
        next if (name == Char.name) && (spell.circlename == 'Bard') && spell.active?

        dry_run[name] ||= Hash.new
        existing_duration = target_info[name][spell.num.to_s] ||= 0
        if existing_duration < Ewaggle.data.settings[:start_at]
          while existing_duration < Ewaggle.data.settings[:stop_at]
            dry_run[name][spell.num.to_s] = dry_run[name][spell.num.to_s] + 1
            existing_duration += spell.time_per(:target => name)
            break unless target_info['sharing']
          end
        end
      end
    end

    # Refreshable
    Ewaggle.data.cast_list.each do |spell|
      spell = Ewaggle.fix_spell(spell)
      target_info.keys.each do |name|
        next unless spell.refreshable?(:target => name)
        next unless spell.available?(:target => name)
        next unless spell.time_per(:target => name) > Ewaggle.data.short_spell_time
        next if (name == Char.name) && (spell.circlename == 'Bard') && spell.active?

        dry_run[name] ||= Hash.new
        existing_duration = target_info[name][spell.num.to_s] ||= 0
        if (existing_duration < Ewaggle.data.settings[:refreshable_min])
          dry_run[name][spell.num.to_s] = dry_run[name][spell.num.to_s] + 1
        end
      end
    end

    # Armor Support
    Ewaggle.data.armor_list.each do |buff|
      spell = Ewaggle.fix_spell(buff[/^\d+/].to_i)

      target_info.keys.each do |name|
        dry_run[name] ||= Hash.new
        existing_duration = target_info[name][spell.num.to_s] ||= 0
        if (existing_duration < Ewaggle.data.settings[:armor_min])
          dry_run[name][spell.num.to_s] = dry_run[name][spell.num.to_s] + 1
        end
      end
    end

    # Solid Block
    Ewaggle.data.cast_list.each do |spell|
      spell = Ewaggle.fix_spell(spell)
      target_info.keys.each do |name|
        next if spell.stackable?(:target => name) or spell.refreshable?(:target => name)
        next unless spell.available?(:target => name)
        next unless spell.time_per(:target => name) > Ewaggle.data.short_spell_time
        next if (name == Char.name) && (spell.circlename == 'Bard') && spell.active?

        dry_run[name] ||= Hash.new
        existing_duration = target_info[name][spell.num.to_s] ||= 0
        unless existing_duration > 0
          dry_run[name][spell.num.to_s] = dry_run[name][spell.num.to_s] + 1
        end
      end
    end

    # Disk
    Ewaggle.data.cast_list.each do |spell|
      spell = Ewaggle.fix_spell(spell)
      target_info.keys.each do |name|
        next unless spell.num == 511

        disk_nouns_regex = /\b(?:bassinet|cassone|chest|coffer|coffin|coffret|disk|hamper|saucer|sphere|trunk|tureen)\b/
        disk = GameObj.loot.find { |l| l.name =~ /#{name} #{disk_nouns_regex}\b/ }

        unless disk
          dry_run[name] ||= Hash.new
          dry_run[name][spell.num.to_s] = dry_run[name][spell.num.to_s] + 1
        end
      end
    end

    dry_run.each do |name, hash|
      if hash.empty?
        respond
        Lich::Messaging.msg('plain', " #{name.capitalize}: No spells needed.")
        respond
      else
        total_casts = 0
        total_mana  = 0

        rows = []
        rows << ["#{name.capitalize}:", "Casts", "Mana", "Duration", "Bonus"]
        rows << :separator

        for spell, casts in hash
          spell = Spell[spell]
          total_casts += casts
          total_mana += casts * spell.mana_cost

          if spell.num == 511
            spell_time = "Indef"
          else
            spell_duration = (spell.time_per(target: name) * casts * 60).to_i
            spell_time = "%d:%02d" % [spell_duration / 3600, (spell_duration % 3600) / 60]
          end

          rows << ["#{spell.num} #{spell.name}", { value: casts, alignment: :right }, { value: spell.mana_cost * casts, alignment: :right }, { value: spell_time, alignment: :right }, Ewaggle.determine_bonus(spell)]
        end

        rows << :separator
        rows << [{ value: "Total:", alignment: :right }, { value: total_casts, alignment: :right }, { value: total_mana, alignment: :right }, "", ""]

        table = Terminal::Table.new :title => "#{Script.current.name.capitalize} v#{Ewaggle.get_script_version}", :rows => rows

        respond
        respond table
        respond
      end
    end
  end

  def self.list
    rows = []
    rows << ["Parameters", "Values"]
    rows << :separator
    rows << ["start at", Ewaggle.data.settings[:start_at]]
    rows << ["stop at", Ewaggle.data.settings[:stop_at]]
    rows << ["refreshable min", Ewaggle.data.settings[:refreshable_min]]
    rows << ["multicast", Ewaggle.data.settings[:use_multicast]]
    rows << ["sign of wracking", Ewaggle.data.settings[:use_wracking]]
    rows << ["wander to wrack", Ewaggle.data.settings[:wander_to_wrack]]
    rows << ["sigil of power", Ewaggle.data.settings[:use_power]]
    rows << ["sigil of concen", Ewaggle.data.settings[:use_concentration]]
    rows << ["symbol of mana", Ewaggle.data.settings[:use_mana]]
    rows << ["skip short spells", Ewaggle.data.settings[:skip_short_spells]]
    rows << ["reserve mana", Ewaggle.data.settings[:reserve_mana]]
    rows << ["bail no resources", Ewaggle.data.settings[:bail_no_mana]]
    rows << ["use mana bread (203)", Ewaggle.data.settings[:use_203]]
    rows << ["use rapid fire (515)", Ewaggle.data.settings[:use_515]]

    retribution = Ewaggle.data.settings[:retribution_spell].to_s.empty? ? 'none' : "#{Ewaggle.data.settings[:retribution_spell]} #{Spell[Ewaggle.data.settings[:retribution_spell]]}"
    rows << ["retribution spell", retribution]
    rows << ["armor list", Ewaggle.data.armor_list.join(', ')] unless Ewaggle.data.armor_list.empty?
    rows << ["cast list", Ewaggle.word_wrap(Ewaggle.data.cast_list.join(', '), 30)]

    table = Terminal::Table.new(
      title: "#{Script.current.name.capitalize} v#{Ewaggle.get_script_version} Settings",
      rows: rows,
    )

    table.align_column 0, :right

    respond
    respond table
    respond
  end

  def self.manage_sonic(item)
    number, parameter = item.match(/^(\d+)\(([\w\s\-\'\"]+)\)$/).captures

    if number == "1009"
      Ewaggle.data.settings[:sonic_shield] = parameter.gsub(/^"|"$/, '')
    elsif number == "1012"
      Ewaggle.data.settings[:sonic_weapon] = parameter.gsub(/^"|"$/, '')
    elsif number == "1014"
      Ewaggle.data.settings[:sonic_armor] = parameter.gsub(/^"|"$/, '')
    else
      respond
      Lich::Messaging.msg('yellow', " This isn't sonic gear #{item}")
    end

    return number
  end

  def self.mana_bread(target)
    if target == Char.name
      Ewaggle.eat_bread(bypass_check: true)
    else
      empty_hand

      Casting.cast_spell(Spell[203], Char.name)

      bread = [GameObj.right_hand, GameObj.left_hand].find do |obj|
        obj.noun =~ /^(?:flatbread|teacake|crisps|cake|waybread|biscuit|oatcake|fritter|loaf|ball|cornmeal|wheatberries|cracker|dumpling|bread|tart|dough|seeds)$/
      end

      while [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(bread.id)
        fput "drop ##{bread.id}"
        sleep 0.2
      end

      fill_hand
    end
  end

  def self.process_cli(pattern, key)
    return unless (setting = Script.current.vars.map { |var| var.match(pattern) }.compact.first&.to_s)

    fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false, 'none' => false }
    value = setting.split("=").last.strip

    # Determine the value
    if fix_option.key?(value.downcase)
      value = fix_option[value.downcase] # Convert to boolean
    elsif value.include?(",") && value.match?(/^\d+(,\d+)*$/)
      value.split(",").map(&:to_i) # Convert to an array of integers
    elsif value.include?(",") && value.match?(/\(\w.*?\)|\d+/)
      value.split(/(?<=\))?,/)
    elsif value.match?(/^(\d+)\(([\w\s\-\'\"]+)\)$|^(\d+)$/)
      [value]
    elsif value !~ /--save|--skip-armor/
      Lich::Messaging.msg('yellow', " Wasn't able to match #{value}")
    end

    # Adjust a couple of them
    if key == :retribution_spell && value.is_a?(FalseClass)
      Ewaggle.data.settings[key] = ''
    elsif key == :cast_list
      Ewaggle.data.settings[key] = []
      Ewaggle.data.cast_list = []
      items = value.split(",")
      items.each do |spell|
        if spell.match?(/^(\d+)\(([\w\s\-\'\"]+)\)$/)
          spell = Ewaggle.manage_sonic(spell)
        end

        next unless Ewaggle.valid_spell?(spell)

        if Ewaggle.armor_spells.values.include?(spell)
          Ewaggle.data.settings[key] << "#{Spell[spell].num} #{Spell[spell].name}"
          Ewaggle.data.armor_list << "#{Spell[spell].num} #{Spell[spell].name}"
        else
          Ewaggle.data.settings[key] << "#{Spell[spell].num}  #{Spell[spell].name}"
          Ewaggle.data.cast_list << Spell[spell].num
        end
      end
    elsif value == "--skip-armor"
      Ewaggle.data.armor_list = []
      Ewaggle.data.settings[:cast_list].reject! do |entry|
        Ewaggle.armor_spells.values.any? { |spell_num| entry.start_with?("#{spell_num} ") }
      end
    elsif value == "--save"
      Ewaggle.data.settings[:cast_list].sort_by! { |str| str.to_i }
      Ewaggle.save_profile
      Ewaggle.load(Ewaggle.load_profile())
    elsif ['false', 'true'].include?(value.to_s)
      Ewaggle.data.settings[key] = value
    else
      Ewaggle.data.settings[key] = value.to_i
    end

    Script.current.vars.delete(setting)
  end

  def self.process_options
    msg_array = []
    need_save = false
    fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false, 'none' => false }
    item = Script.current.vars[1]
    value = Script.current.vars[2]
    matched_key = Ewaggle.data.options.keys.find { |pattern| Script.current.vars[1].match?(pattern) }
    data_key = Ewaggle.data.options[matched_key]

    case
    when fix_option.key?(value.downcase)
      value = fix_option[value.downcase] # Convert to boolean

      if Ewaggle.data.settings[data_key] == value
        msg_array << " #{data_key} is already set to #{value}"
      else
        Ewaggle.data.settings[data_key] = value

        msg_array << " #{data_key} has been set to #{value}"
        need_save = true
      end
    when value.match?(/^\d+$/) && data_key != :cast_list
      if Ewaggle.data.settings[data_key].to_s =~ /#{value}/
        msg_array << " #{data_key} is already set to #{value}"
      else
        Ewaggle.data.settings[data_key] = data_key == :retribution_spell ? value.to_s : value.to_i

        msg_array << " #{data_key} has been set to #{value}"
        need_save = true
      end
    when data_key == :retribution_spell && value.is_a?(FalseClass)
      Ewaggle.data.settings[data_key] = ''

      msg_array << " #{item} has been removed"
      need_save = true
    when item =~ /add/i
      values = Script.current.vars[0].split("add").last.strip
      add_array = values.split(/(?:,\s*|\s+)(?=\d+(?:\(|$))/)

      add_array.each do |spell|
        if spell.match?(/^(\d+)\(([\w\s\-\'\"]+)\)$/)
          spell = Ewaggle.manage_sonic(spell)
        end

        next unless Ewaggle.valid_spell?(spell)

        if Ewaggle.data.cast_list.include?(spell.to_i) || Ewaggle.data.armor_list.include?("#{Spell[spell].num} #{Spell[spell].name}")
          msg_array << " #{spell} #{Spell[spell].name} is already in the casting list."
        elsif Ewaggle.armor_spells.values.include?(spell)
          Ewaggle.data.settings[:cast_list] << "#{Spell[spell].num} #{Spell[spell].name}"

          msg_array << " #{spell} #{Spell[spell].name} has been added to the casting list"
          need_save = true
        else
          Ewaggle.data.settings[:cast_list] << "#{Spell[spell].num}  #{Spell[spell].name}"

          msg_array << " #{spell} #{Spell[spell].name} has been added to the casting list"
          need_save = true
        end
      end
    when item =~ /remove/i
      values = Script.current.vars[0].split("remove").last.strip
      del_array = values.split(/(?:,\s*|\s+)(?=\d+(?:\(|$))/)

      del_array.each do |spell|
        if spell.match?(/^(\d+)\(([\w\s\-\'\"]+)\)$/)
          spell = Ewaggle.manage_sonic(spell)
        end

        if Ewaggle.data.cast_list.include?(spell.to_i) || Ewaggle.data.armor_list.include?("#{Spell[spell].num} #{Spell[spell].name}")
          Ewaggle.data.settings[:cast_list].reject! { |entry| entry.start_with?("#{Spell[spell].num} ") }

          msg_array << " #{spell} #{Spell[spell].name} has been removed from the casting list."
          need_save = true
        else
          msg_array << " #{spell} #{Spell[spell].name} was NOT found in the casting list."
        end
      end
    end

    respond
    msg_array.each do |msg|
      Lich::Messaging.msg('yellow', msg)
    end
    respond

    if need_save
      Ewaggle.data.settings[:cast_list].sort_by! { |str| str.to_i }
      Ewaggle.save_profile
      Ewaggle.load(Ewaggle.load_profile())
    end
  end

  def self.target_info(target_list)
    target_info = Hash.new
    target_list.each do |name|
      if name == Char.name
        target_info[Char.name] = Hash.new
        Spell.active.each { |spell| target_info[Char.name][spell.num.to_s] = spell.timeleft }
      else
        spell_info = Ewaggle.get_target_info(name)
        target_info[name] = spell_info unless spell_info.nil?
      end
    end

    return target_info
  end

  def self.target_list(vars)
    target_list = []
    check_vars = vars[1] =~ /info/i ? vars[2] : vars[1]

    if check_vars
      Script.current.vars[1..-1].each do |bad_name|
        if (pc = GameObj.pcs.find { |gameobj_pc| gameobj_pc.noun =~ /^#{bad_name}/i })
          target_list.push(pc.noun)
        elsif Char.name =~ /^#{bad_name}/i || bad_name =~ /self/i
          target_list.push(Char.name)
        else
          unless bad_name == 'info'
            respond
            Lich::Messaging.msg('plain', " Bad Target: #{bad_name.capitalize}")
            respond
          end
        end
      end
    else
      target_list = [Char.name]
    end

    return target_list
  end

  def self.valid_spell?(spell)
    unless (Spell[spell] && Spell[spell].known? && Spell[spell].time_per > 0) || (Spell[spell].name =~ /Armor/i && Spell[spell].name !~ /sonic|mage/i && Armor.known?(Spell[spell].name) || (Spell[spell].num == 511 && Spell[spell].known?))
      respond
      if Spell[spell].known?
        Lich::Messaging.msg('plain', "#{Spell[spell].num} #{Spell[spell].name} is not a buff spell.")
      else
        Lich::Messaging.msg('plain', "#{Spell[spell].num} #{Spell[spell].name} is an unknown spell.")
      end
      return false
    end

    return true
  end

  def self.word_wrap(text, width = 60)
    text.gsub(/(.{1,#{width}})(\s+|\Z)/, "\\1\n").strip
  end
end

# Casting methods
module Ewaggle
  module Casting
    def self.cast_spell(spell, target, num_multicast = 1)
      result = nil

      unless Ewaggle.valid_spell?(spell)
        return :bad_spell
      end

      loop {
        if Object.const_defined?(:Feat) && Feat.known?(:mental_acuity)
          Casting.check_stamina(spell, num_multicast)
        else
          Casting.check_mana(spell, num_multicast)
        end

        if target == Char.name
          if spell.num == 1009
            cast_result = spell.cast(Ewaggle.data.settings[:sonic_shield])
          elsif spell.num == 1012
            cast_result = spell.cast(Ewaggle.data.settings[:sonic_weapon])
          elsif spell.num == 1014
            cast_result = spell.cast(Ewaggle.data.settings[:sonic_armor])
          elsif num_multicast > 1
            cast_result = spell.cast("#{num_multicast}")
          else
            cast_result = spell.cast
          end
        else
          if num_multicast > 1
            cast_result = spell.cast("at #{target} #{num_multicast}")
          else
            cast_result = spell.cast("at #{target}")
          end
        end

        if cast_result.to_s =~ /^Be at peace my child, there is no need for spells of war in here\.$|Spells of War cannot be cast/
          result = :bad_spell
          break
        elsif cast_result.to_s == 'Cast at what?'
          result = :bad_target
          break
        elsif cast_result.to_s =~ /^\[Spell Hindrance for/
          nil # try again
        else
          result = :success
          break
        end
      }
      result
    end

    def self.cast_support
      if Ewaggle.data.settings[:use_concentration] && Spell[9714].affordable? && !Spell[9714].active?
        Spell[9714].cast
      end

      if Ewaggle.data.settings[:use_203] && Spell[203].affordable?
        Ewaggle.eat_bread
      end

      if Ewaggle.data.settings[:use_515] && Spell[515].affordable? && !Spell[515].active?
        Spell[515].cast
      end
    end

    def self.cast_refreshable(target, info)
      Ewaggle.data.cast_list.each do |spell|
        spell = Ewaggle.fix_spell(spell)

        next if spell.stackable?(:target => target)
        next unless spell.available?(:target => target)
        next unless spell.time_per(:target => target) > Ewaggle.data.short_spell_time
        next if Ewaggle.data.skip_targets.include?(target) || Ewaggle.data.skip_spells.include?(spell.num)
        next if (target == Char.name) && (spell.circlename == 'Bard') and spell.active?

        existing_duration = info[spell.num.to_s] ||= 0
        next if existing_duration > Ewaggle.data.settings[:refreshable_min]

        Casting.cast_support

        cast_result = Casting.cast_spell(spell, target)
        if cast_result == :bad_spell
          Ewaggle.data.skip_spells.push(spell.num)
        elsif cast_result == :bad_target
          Ewaggle.data.skip_targets.push(target)
        end
      end

      # Armor Support
      Ewaggle.data.armor_list.each do |buff|
        spell_no = buff[/^\d+/]
        spell = Ewaggle.fix_spell(spell_no)
        buff_name = buff.sub(/^\d+\s*/, '')

        Casting.check_stamina(spell, 1)

        existing_duration = info[spell_no] ||= 0
        next if existing_duration > Ewaggle.data.settings[:armor_min]

        Armor.use(buff_name, target)
      end
    end

    def self.cast_solid(target, info)
      Ewaggle.data.cast_list.each do |spell|
        spell = Ewaggle.fix_spell(spell)

        next if spell.stackable?(:target => target) || spell.refreshable?(:target => target)
        next unless spell.available?(:target => target)
        next unless spell.time_per(:target => target) > Ewaggle.data.short_spell_time
        next if (target == Char.name) && (spell.circlename == 'Bard') && spell.active?
        next if Ewaggle.data.skip_targets.include?(target) || Ewaggle.data.skip_spells.include?(spell.num)

        existing_duration = info[spell.num.to_s] ||= 0
        next unless existing_duration.zero?

        Casting.cast_support

        cast_result = Casting.cast_spell(spell, target)
        if cast_result == :bad_spell
          Ewaggle.data.skip_spells.push(spell.num)
        elsif cast_result == :bad_target
          Ewaggle.data.skip_targets.push(target)
        end
      end
    end

    def self.cast_stackable(target, info)
      Ewaggle.data.cast_list = Ewaggle.data.cast_list.sort_by { |n| n == 625 ? 0 : n }
      Ewaggle.data.cast_list.each do |spell|
        spell = Ewaggle.fix_spell(spell)

        next unless spell.stackable?(:target => target)
        next unless spell.available?(:target => target) || spell.num == 203
        next unless spell.time_per(:target => target) > Ewaggle.data.short_spell_time || spell.num == 203
        next if (target == Char.name) && (spell.circlename == 'Bard') && spell.active?

        existing_duration = info[spell.num.to_s] ||= 0
        next if existing_duration > Ewaggle.data.settings[:start_at] && spell.num != 203
        max_multicast = Casting.max_multicast(spell)

        Casting.cast_support

        if spell.num == 203
          Ewaggle.mana_bread(target)
        else
          while info[spell.num.to_s] < Ewaggle.data.settings[:stop_at] && !Ewaggle.data.skip_targets.include?(target) && !Ewaggle.data.skip_spells.include?(spell.num)
            # Adjust number_casts if needed to stay within stop_at
            remaining_time = Ewaggle.data.settings[:stop_at] - info[spell.num.to_s]
            min_needed_casts = (remaining_time.to_f / spell.time_per(target: target)).ceil
            number_casts = [min_needed_casts, max_multicast].min

            break unless number_casts.positive? # Prevents unnecessary casting

            number_casts = 1 unless Ewaggle.data.settings[:use_multicast] && spell.multicastable? && (info['sharing'] || target == Char.name)

            cast_result = Casting.cast_spell(spell, target, number_casts)

            case cast_result
            when :bad_spell
              Ewaggle.data.skip_spells.push(spell.num)
              break
            when :bad_target
              Ewaggle.data.skip_targets.push(target)
              break
            else
              info[spell.num.to_s] += spell.time_per(target: target) * number_casts
            end

            break if !info['sharing']
          end
        end

        # Add the retribution spell
        if spell.num == 712 && target == Char.name && !Ewaggle.data.settings[:retribution_spell].empty?
          fput "chant retribution #{Ewaggle.data.settings[:retribution_spell]}"
        end
      end
    end

    def self.cast_disk(target)
      return unless Ewaggle.data.cast_list.include?(511)

      spell = Ewaggle.fix_spell(511)

      disk_nouns_regex = /\b(?:bassinet|cassone|chest|coffer|coffin|coffret|disk|hamper|saucer|sphere|trunk|tureen)\b/
      disk = GameObj.loot.find { |l| l.name =~ /#{target} #{disk_nouns_regex}\b/ }

      return if disk

      cast_result = Casting.cast_spell(spell, target)
      if cast_result == :bad_spell
        Ewaggle.data.skip_spells.push(spell.num)
      elsif cast_result == :bad_target
        Ewaggle.data.skip_targets.push(target)
      end
    end

    def self.check_mana(spell, num_multicast)
      spell_cost = spell.mana_cost(:multicast => num_multicast) + Ewaggle.data.settings[:reserve_mana]
      return true if spell.affordable?(:multicast => num_multicast) && ((spell.mana_cost == 0) || (Char.mana >= spell_cost))
      # return true if spell.stamina_cost.zero? # not needed, was causing false returns due to all spells costing zero stamina
      return true unless spell.mana_cost > 0

      case
      when Ewaggle.data.settings[:use_wracking] # Wracking - COL
        Casting.check_mana_col(spell, num_multicast, spell_cost)
      when Ewaggle.data.settings[:use_power] # Sigil of Power - GOS
        Casting.check_mana_gos(spell, num_multicast, spell_cost)
      when Ewaggle.data.settings[:use_mana] # Symbol of Mana - Voln
        Casting.check_mana_voln(spell, num_multicast, spell_cost)
      else
        fput 'release' unless checkprep == 'None'
        echo 'waiting for mana...'
        if Ewaggle.data.settings[:bail_no_mana]
          echo 'out of resource, bailing out!'
          exit
        end
        wait_until { spell.affordable?(:multicast => num_multicast) && (spell.mana_cost == 0 || Char.mana >= spell_cost) }
      end
    end

    def self.check_mana_col(spell, num_multicast, spell_cost)
      sign_of_wracking = Spell[9918]
      punishment = Spell[9012]

      until spell.affordable?(:multicast => num_multicast) && (Char.mana >= spell_cost)
        waitrt?
        waitcastrt?
        if sign_of_wracking.affordable? && !punishment.active?
          if (invisible? || hidden? || !checkpcs || Casting.safe_to_wrack) && !Room.current.tags.include?('no-magic')
            sign_of_wracking.cast if sign_of_wracking.affordable? && !punishment.active?
          elsif Ewaggle.data.settings[:wander_to_wrack]
            Ewaggle.data.wander = []
            start_room = Room.current

            20.times {
              break if Casting.safe_to_wrack && !Room.current.tags.include?('no-magic')
              Casting.col_move
            }

            sign_of_wracking.cast if sign_of_wracking.affordable? && !punishment.active?

            Script.run('go2', "#{start_room.id} --disable-confirm", { quiet: true }) unless start_room.id == Room.current.id
          end
        else
          fput 'release' unless checkprep == 'None'
          echo 'waiting for mana or spirit...'
          if Ewaggle.data.settings[:bail_no_mana]
            echo 'out of resource, bailing out!'
            exit
          end
          wait_until { (spell.affordable?(:multicast => num_multicast) && (Char.mana >= spell_cost)) || sign_of_wracking.affordable? }
        end
      end
    end

    def self.col_move
      room = Room.current
      next_room_options = room.wayto.keys
      next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) && room.timeto[room_id].call.nil? }
      next_room = next_room_options.find_all { |r| !Ewaggle.data.wander.include?(r) }
      if next_room.empty?
        next_room = Ewaggle.data.wander.find { |r| next_room_options.include?(r) }
      else
        next_room = next_room[rand(next_room.length)]
      end
      Ewaggle.data.wander.delete(next_room)
      Ewaggle.data.wander.push(next_room)
      way = room.wayto[next_room]
      if way.class == String
        move(way)
      else
        way.call
      end
    end

    def self.safe_to_wrack
      # Lets check player characters and see if we can wrack
      col_pattern = /^You (?:touch|scratch|rub|tap|point to) your (?:right|left) (?:eyebrow|nostril|earlobe|shoulder|cheek) with your (?:right|left) (?:pinky|forefinger|thumb|index finger)/
      lines = Lich::Util.issue_command("sign of recognition", col_pattern, usexml: true, silent: true, quiet: true)
      acknowledgers = lines.filter_map { |line| line[/noun=\"(.*?)\">.*?acknowledges your sign/, 1] }
      !(checkpcs - acknowledgers).count.positive?
    end

    def self.check_mana_gos(spell, num_multicast, spell_cost)
      sigil_of_power = Spell[9718]
      until spell.affordable?(:multicast => num_multicast) && (Char.mana >= spell_cost)
        if sigil_of_power.affordable?
          sigil_of_power.cast
          sleep 0.2
        else
          fput 'release' unless checkprep == 'None'
          echo 'waiting for mana...'
          if Ewaggle.data.settings[:bail_no_mana]
            echo 'out of resource, bailing out!'
            exit
          end
          wait_until { (spell.affordable?(:multicast => num_multicast) && (Char.mana >= spell_cost)) || sigil_of_power.affordable? }
        end
      end
    end

    def self.check_mana_voln(spell, num_multicast, spell_cost)
      until spell.affordable?(:multicast => num_multicast) && (Char.mana >= spell_cost)
        waitrt?
        waitcastrt?
        if !Effects::Cooldowns.active?("Symbol of Mana")
          result = Spell[9813].cast
          if result =~ /^You strain to perform the symbol/
            echo("You're out of favor! Disabling symbol of mana usage.")
            Ewaggle.data.settings[:use_mana] = false
            break
          end
          sleep 0.2
        else
          fput 'release' unless checkprep == 'None'
          echo 'waiting for mana or mana cooldown...'
          if Ewaggle.data.settings[:bail_no_mana]
            echo 'out of resource, bailing out!'
            exit
          end
          wait_until { (spell.affordable?(:multicast => num_multicast) && (Char.mana >= spell_cost)) || !Effects::Cooldowns.active?("Symbol of Mana") }
        end
      end
    end

    def self.check_stamina(spell, num_multicast)
      unless spell.affordable?(:multicast => num_multicast) && ((spell.mana_cost == 0) || (Char.stamina >= (spell.mana_cost(:multicast => num_multicast) * 2) + Ewaggle.data.settings[:reserve_mana]))
        echo 'waiting for stamina...'
        if Ewaggle.data.settings[:bail_no_mana]
          echo 'out of resource, bailing out!'
          exit
        end
        wait_until { spell.affordable?(:multicast => num_multicast) && ((spell.mana_cost == 0) || (Char.stamina >= (spell.mana_cost(:multicast => num_multicast) * 2) + Ewaggle.data.settings[:reserve_mana])) }
      end
    end

    def self.max_multicast(spell)
      ranks = 0
      if Stats.prof == 'Wizard'
        ranks = Skills.emc
      elsif Stats.prof =~ /^Cleric$|^Ranger$|^Paladin$/
        ranks = Skills.smc
      elsif Stats.prof =~ /^Empath$|^Monk$|^Bard$/
        if [1, 2].include?(spell.circle.to_i)
          ranks = Skills.smc + (Skills.mmc / 2)
        elsif spell.circle.to_i == 11
          ranks = [Skills.mmc, Skills.smc].max + ([Skills.mmc, Skills.smc].min / 2)
        elsif spell.circle.to_i == 12
          ranks = Skills.mmc + (Skills.smc / 2)
        elsif spell.circle.to_i == 4
          ranks = Skills.emc + (Skills.mmc / 2)
        end
      elsif Stats.prof =~ /^Sorcerer$|^Warrior$|^Rogue$/
        if spell.circle.to_i == 4
          ranks = Skills.emc + (Skills.smc / 2)
        elsif spell.circle.to_i == 1
          ranks = Skills.smc + (Skills.emc / 2)
        elsif spell.circle.to_i == 7
          ranks = [Skills.emc, Skills.smc].max + ([Skills.emc, Skills.smc].min / 2)
        end
      end
      (ranks / 25) + 1
    end
  end
end

# Startup
module Ewaggle
  # Load profile if needed
  unless Ewaggle.data
    Ewaggle.load(Ewaggle.load_profile())
  end

  # Capture starting settings
  Ewaggle.data.original_settings = Marshal.load(Marshal.dump(Ewaggle.data.settings))

  # Process any CLI options
  Ewaggle.data.cli_options.each { |pattern, key| Ewaggle.process_cli(pattern, key) }

  before_dying {
    # In case temp changes were made with CLI
    Ewaggle.load(Ewaggle.load_profile())
  }

  case Script.current.vars[0]
  when Regexp.union(Ewaggle.data.options.keys)
    Ewaggle.process_options
  when /^load$/i
    Ewaggle.load(Ewaggle.load_profile())
  when /^setup$/i
    if defined?(Gtk)
      Ewaggle::Setup.new(Ewaggle.data.settings).start
      Ewaggle.load(Ewaggle.load_profile)
    else
      respond
      Lich::Messaging.msg('plain', 'GTK bindings are not installed or failed to load.')
      Lich::Messaging.msg('plain', "For command-line setup, see #{$clean_lich_char}#{Script.current.name} help")
      respond
    end
  when /^help$/i
    Ewaggle.help
  when /^list$|^show$/i
    Ewaggle.list
  when /^info/
    target_list = Ewaggle.target_list(Script.current.vars)
    target_info = Ewaggle.target_info(target_list)
    Ewaggle.info(target_info)
  when /^test/i
    Ewaggle.test
  when Script.current.vars[0] || nil
    Ewaggle.data.skip_spells = []
    Ewaggle.data.skip_targets = []

    target_list = Ewaggle.target_list(Script.current.vars)
    target_info = Ewaggle.target_info(target_list)

    target_info.each do |target, info|
      Casting.cast_stackable(target, info)
      Casting.cast_refreshable(target, info)
      Casting.cast_solid(target, info)
      Casting.cast_disk(target)
    end
  end
end
