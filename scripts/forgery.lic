=begin

     help:                    ;forgery ?
     current Settings:        ;forgery display
     gui:                     ;forgery setup

    ;forgery will start it if you have it set up right

  IMPORTANT (READ THIS DAMNIT):
     ~Oil type (if needed) will auto-determined.
     ~Leaving the Average and Scrap settings BLANK will cause those pieces to be discarded.
     ~Block, Slab, Keeper, and Scrap containers MUST be different, although the last one is optional.
     ~'Average' & 'Keeper' containers should be different as finished pieces are identical-looking.
     ~To make HANDLES, set handle order # for glyph, and wood OR metal for material.
     ~This script DOES NOT COMBINE/VISE the pieces for you...thats the fun part!!

 Forge-perfects authors: Moredin (forging stuff) & Tillek (GUI, squelching, iron-making.)
 Forgery author: Gnomad

 Category: Artisan
 Tags: forging, forge, craft, artisan, perfect
 Version: 17

 October 2015: Forked by Gnomad
 December 2015: Various bugfixes, began internal testing (v2, internal)
 January 2016: MARK perfect items as unsellable (v3, internal) forged perfect hammer, began OHE work
 February 2016: Added rank mode that trashes perfects, minor bugfixes (v4, internal) reached OHE 497 with script
 March 2016: Added no-exp mode that drops intead of using a trash bin (v5, internal) mastered OHE, oil and polishing bugfixes (v6),
      fixed a scrap bug, polish bug, settings bug, and a few other things (v7)
      Fixed another polish bug (v8)
 April 2016: Addes some internal features (v9), had a baby (v9.5), fixed a spear-forging bug and migrated settings,
       to be per-character (v10), a hang when your glyph runs out (v11), added results tracking and some internal changes (v12)
 May 2016: AFK tweaks (v13)
 LOL March 2017: (See the had a baby thing) Bugfixes(v14, v15), killed the gift/trash options for lumnis change(v15)
 July 2017: Quit Gemstone, probably for good. Sorry. My health won't let me play much any more.
 April 2018: Fixed a dumb bug where average pieces were mixed in the container with keepers (v16).
 December 2018: Fixed a dumb oil bug. Again? (v17)


=end

# Pre-Gnomad changelog:
#  UPDATES:
#  Early 2011 -> heavily modified Dalem's dforge script.
#  Sept 2011  -> fixed measuring the stand-alone hammerhead glyph for forging hammer heads.
#  Jan 2012   -> fixed citizenship buying bug
#  Mar 2012   -> fixed forging-hammer hang bugs.  thanks to Kuirit
#       -> broke buying for non-citizens by accident when i fixed it for citizens.  error gone now and should work fine.  my bad!
#       -> fixed a problem with the oil section of the script, and cleaned it up a little bit.  also added the oil type for rare metal slabs...props to Gizmo!
#       -> fixed more bugs.  thanks to Gizmo for pointin em out.
#  03/29/12 -> fixed and reworked the scrap-selling part which I dont think many people actually used because it only activates if the scrap_container fills up.



# #Attuning to hammer: You feel as if you've become accustomed to the balance and heft of this forging-hammer.

if Settings.to_hash.size > 0  and CharSettings.to_hash.size == 0
  echo 'Migrating settings, one moment. This should only happen once per character.'
  Settings.to_hash.each do |setting, value|
    CharSettings[setting] = value
  end
end

oil_trough = {
  "water" => "some water",
  "tempering oil" => "some oil",
  "enchanted oil" => "some iridescent oil",
  "twice-enchanted oil" => "some opalescent oil",
  "ensorcelled oil" => "some dimly glowing oil"
}

material_oil = {
  "bronze" => "water",
  "iron" => "water",
  "steel" => "tempering oil",
  "invar" => "tempering oil",
  "faenor" => "enchanted oil",
  "mithril" =>  "enchanted oil",
  "ora" => "enchanted oil",
  "drakar" => "enchanted oil",
  "gornar" => "enchanted oil",
  "rhimar" => "enchanted oil",
  "zorchar" => "enchanted oil",
  "kelyn" => "enchanted oil",
  "imflass" => "twice-enchanted oil",
  "razern" => "twice-enchanted oil",
  "eahnor" => "ensorcelled oil",
  "mithglin" => "ensorcelled oil",
  "vaalorn" => "ensorcelled oil",
  "vultite" => "ensorcelled oil",
  "rolaren" => "ensorcelled oil",
  "veil iron" => "ensorcelled oil",
  "eonake" => "ensorcelled oil",
  "golvern" => "ensorcelled oil"
}

oil_order = {
  "tempering oil" => 5,
  "enchanted oil" => 6,
  "twice-enchanted oil" => 7,
  "ensorcelled oil" => 8
}

CharSettings.load
before_dying { CharSettings.save }

forger = Object.new
settings          = CharSettings.to_hash

setup = proc {
# gtk_globals = Hash.new
  gtk_locals = Hash.new

  window = window_action = nil
  Gtk.queue {
# ttips = Gtk::Tooltip.new
    ttips_text = {
      'average_container' => "Container that will contain all your completed pieces that are not perfect\nIf left blank, average pieces will be trashed instead\n\nAverage and Keeper containers must be different!",
      'keeper_container'  => "Container that will contain all your perfect pieces\n\nAverage and Keeper containers must be different!",
      'oil_container'   => "Container that will contain your oil\n\nCan be left blank if you are using bronze or iron for your forging material",
      'block_container' => "Container that will contain your cut slab pieces\n\nMust be different than Fresh and Leftover containers",
      'slab_container'  => "Container that will contain your fresh slabs\n\nMust be different than Cut and Leftover containers",
      'scrap_container' => "Container that will contain your leftover cut pieces\nIf left blank, leftover cut pieces will be trashed instead\n\nMust be different than Fresh and Cut containers",
      'glyph_container' => "Container that will contain your forging glyph",
      'material_noun'   => "Noun of your forging material\nExample: bar",
      'material_name'   => "Name of your forging material\nExample: bronze",
      'material_no'   => "Order number of your forging material\nExample: 2",
      'glyph_name'    => "Name of your forging glyph\nExample: blade-glyph\n\nWhen making forging hammers, use head-glyph, etc.",
      'glyph_no'      => "The order number for the forging glyph\nExample: 44\n\nIf using the forging-hammer glyphs, leave BLANK\nOtherwise: Put 99 here.",
      'glyph_material'  => "Custom Material of your forging glyph\nExample: wax\n\nNot applicable to forging-hammer glyphs",
      'make_hammers'    => "Will make hammer-heads and hammer-handles from the workshop glyphs.\nSpecify handle-glyph or head-glyph above!\n\nOther glyph fields are ignored.",
      'surge'       => "Will perform the Combat Manuever \"Surge of Strength\" at the appropriate places while forging",
      'squelch'     => "Will remove the annoying screen scroll that happens when you perform forging actions\n\nCourtesy of Gibreficul\nTHANKS GIB!",
      'make_iron'     => "Makes iron in kobold mines rather than buying it\nREQUIRES Iron.lic script.",
      'unsafe_keepers'    => "Forgery MARKSs best pieces as unsellable by default.\nUnchek this box if you want to live dangerously (or are ranking up).",
      # 'trash_gift'    => "DROP junk, toss it in the bin, or decide based on your Lumnis status.\nUse LUMNIS INFO if Lich is wrong about your Gift status.",
    }

    gtk_locals['average_container']   = Gtk::Entry.new; gtk_locals['average_container'].text = (settings['average_container'] ||= "")
    gtk_locals['keeper_container']    = Gtk::Entry.new; gtk_locals['keeper_container'].text = (settings['keeper_container'] ||= "")
    gtk_locals['oil_container']     = Gtk::Entry.new; gtk_locals['oil_container'].text = (settings['oil_container'] ||= "")
    gtk_locals['block_container']     = Gtk::Entry.new; gtk_locals['block_container'].text = (settings['block_container'] ||= "")
    gtk_locals['slab_container']    = Gtk::Entry.new; gtk_locals['slab_container'].text = (settings['slab_container'] ||= "")
    gtk_locals['scrap_container']     = Gtk::Entry.new; gtk_locals['scrap_container'].text = (settings['scrap_container'] ||= "")
    gtk_locals['glyph_container']     = Gtk::Entry.new; gtk_locals['glyph_container'].text = (settings['glyph_container'] ||= "")
    gtk_locals['material_noun']     = Gtk::Entry.new; gtk_locals['material_noun'].text = (settings['material_noun'] ||= "")
    gtk_locals['material_name']     = Gtk::Entry.new; gtk_locals['material_name'].text = (settings['material_name'] ||= "")
    gtk_locals['material_no']       = Gtk::Entry.new; gtk_locals['material_no'].text = (settings['material_no'] ||= "")
    gtk_locals['glyph_name']      = Gtk::Entry.new; gtk_locals['glyph_name'].text = (settings['glyph_name'] ||= "")
    gtk_locals['glyph_no']        = Gtk::Entry.new; gtk_locals['glyph_no'].text = (settings['glyph_no'] ||= "")
    gtk_locals['glyph_material']    = Gtk::Entry.new; gtk_locals['glyph_material'].text = (settings['glyph_material'] ||= "")
    gtk_locals['make_hammers']      = Gtk::CheckButton.new('Make FORGING-HAMMER pieces with the free glyph'); gtk_locals['make_hammers'].active = (settings['make_hammers'] ||= false)
    gtk_locals['surge']         = Gtk::CheckButton.new('Use CMan Surge of Strength'); gtk_locals['surge'].active = (settings['surge'] ||= false)
    gtk_locals['squelch']         = Gtk::CheckButton.new('Squelch Forging Screen Scroll'); gtk_locals['squelch'].active = (settings['squelch'] ||= false)
    gtk_locals['make_iron']       = Gtk::CheckButton.new('Make Iron in Kobold Mines'); gtk_locals['make_iron'].active = (settings['make_iron'] ||= false)
    gtk_locals['safe_keepers']      = Gtk::CheckButton.new('MARK Best Pieces as Unsellable'); gtk_locals['safe_keepers'].active = (settings['safe_keepers'] ||= false)
    #gtk_locals['drop_it']        = Gtk::CheckButton.new('DROP junk instead of trashing it');gtk_locals['drop_it'].active = (settings['drop_it'] ||= false)
    #gtk_locals['trash_drop']     = Gtk::RadioButton.new('Drop junk'); gtk_locals['trash_drop'].active = (settings['trash_drop'] ||= false)
    #gtk_locals['trash_bin']        = Gtk::RadioButton.new(gtk_locals['trash_drop'], 'Bin junk'); gtk_locals['trash_bin'].active = (settings['trash_bin'] ||= false)
    #gtk_locals['trash_gift']     = Gtk::RadioButton.new(gtk_locals['trash_bin'], 'Auto'); gtk_locals['trash_gift'].active = (settings['trash_gift'] ||= false)

    # Add tooltips
    ttips_text.each_pair { |widget,tip|
#     if widget = gtk_globals[widget] || gtk_locals[widget]
      if widget = gtk_locals[widget]
        widget.set_tooltip_text(tip).has_tooltip = true
      end
    }

    # Primary Window
      window = Gtk::Window.new
      window.title = "Forgery"
      window.border_width = 3
      window.resizable = false
      #window.resize(600, 300)

      # Notebooks for tabs at the top
      nb = Gtk::Notebook.new.set_show_border(true) #deprecated - .set_tab_border(3)

      #
      # Notebook Page 1 - Sacks
      #
      big_box = Gtk::Box.new(:horizontal,1).set_border_width(3)

      vb_pg1a = Gtk::Box.new(:vertical,1).set_border_width(3)
      vb_pg1b = Gtk::Box.new(:vertical,1).set_border_width(3)
      big_box.pack_start(vb_pg1a, :expand => false, :fill => false, :padding => 0)
      big_box.pack_start(vb_pg1b, :expand => false, :fill => false, :padding => 0)

      #
      # Page 1, Frame 1 - Sacks
      #
      vb_pg1_1 = Gtk::Box.new(:vertical,1).set_border_width(3)
      fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('Storage Options'))
      fr_pg1_1.add(vb_pg1_1)
      vb_pg1a.pack_start(fr_pg1_1, :expand => false, :fill => false, :padding => 0)

      lbl = Gtk::Label.new.set_markup("<b>*MOUSE OVER FIELDS FOR INFORMATION*</b>")
      lbl.set_wrap(true).set_width_request(250).set_padding(0,0)
      vb_pg1_1.pack_start(lbl, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Average Container:')), :expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['average_container'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Keeper Container:')), :expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['keeper_container'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Oil Container:')),:expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['oil_container'],:expand => false, :fill => false, :padding => 0)
      vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Cut Slab Container:')),:expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['block_container'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Fresh Slab Container:')),:expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['slab_container'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Leftover Cut Slabs Container:')),:expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['scrap_container'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Glyph Container:')), :expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['glyph_container'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(gtk_locals['safe_keepers'].set_width_request(300), :expand => false, :fill => false, :padding => 0)
      vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      # hb = Gtk::Box.new(:horizontal,1)
      # # hb.pack_start(gtk_locals['drop_it'].set_width_request(300), :expand => false, :fill => false, :padding => 0)
      # hb.pack_start(gtk_locals['trash_drop'], :expand => false, :fill => false, :padding => 0)
      # hb.pack_start(gtk_locals['trash_bin'], :expand => false, :fill => false, :padding => 0)
      # hb.pack_start(gtk_locals['trash_gift'], :expand => false, :fill => false, :padding => 0)
      # vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      vb_pg1_2 = Gtk::Box.new(:vertical,1).set_border_width(3)
      fr_pg1_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('Forging Options'))
      fr_pg1_2.add(vb_pg1_2)
      vb_pg1b.pack_start(fr_pg1_2, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Material Name:')),:expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['material_name'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Material Noun:')), :expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['material_noun'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Material Order #:')), :expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['material_no'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      # vb_pg1_3 = Gtk::Box.new(:vertical,1).set_border_width(3)
      # fr_pg1_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('Glyph Order Options'))
      # fr_pg1_3.add(vb_pg1_3)
      # vb_pg1b.pack_start(fr_pg1_3, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Glyph Name:')), :expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['glyph_name'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Glyph Material:')), :expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['glyph_material'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Glyph Order #:')), :expand => true, :fill => false, :padding => 0)
      hb.pack_start(gtk_locals['glyph_no'], :expand => false, :fill => false, :padding => 0)
      vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(gtk_locals['make_hammers'].set_width_request(300), :expand => false, :fill => false, :padding => 0)
      vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      # vb_pg1_4 = Gtk::Box.new(:vertical,1).set_border_width(3)
      # fr_pg1_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('Miscellaneous Options'))
      # fr_pg1_4.add(vb_pg1_4)
      # vb_pg1b.pack_start(fr_pg1_4, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(gtk_locals['surge'].set_width_request(300), :expand => false, :fill => false, :padding => 0)
      vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(gtk_locals['squelch'].set_width_request(300), :expand => false, :fill => false, :padding => 0)
      vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      hb = Gtk::Box.new(:horizontal,1)
      hb.pack_start(gtk_locals['make_iron'].set_width_request(300), :expand => false, :fill => false, :padding => 0)
      vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

      nb.append_page(big_box,Gtk::Label.new('Setup'))


    # Save/Close buttons
    hb_saveclose = Gtk::Box.new(:horizontal, 0)
    save = Gtk::Button.new(:label => '_Save & Close')
    close = Gtk::Button.new(:label => 'E_xit')

    save.signal_connect('clicked') { window_action = :save }
    close.signal_connect('clicked') { window_action = :done }

    hb_saveclose.pack_start(save, :expand => false, :fill => false, :padding => 0)
    hb_saveclose.pack_start(close, :expand => false, :fill => false, :padding => 0)

    # Primary VerticalBox to split up Notebook and Save/Close buttons
    vb_main = Gtk::Box.new(:vertical,5)
    vb_main.border_width = 3

    vb_main.pack_start(nb, :expand => false, :fill => false, :padding => 0)
    vb_main.pack_start(Gtk::Alignment.new(1,0,0,0).add(hb_saveclose), :expand => false, :fill => false, :padding => 0)

    window.signal_connect('delete_event') { window_action = :exit } #respond window.allocation.width;

    window.add(vb_main)
    window.show_all
    window.keep_above = true # On windows keep_above is required AFTER show_all
  }

  before_dying { Gtk.queue { window.destroy } }
  wait_while { window_action.nil? }
  undo_before_dying # Don't ask me what this does - I stripped it from Tillmen's code
  Gtk.queue { window.destroy }

  clean_entry = proc { |entry|
    entry.text = entry.text.strip
    if entry.text.empty?
      entry.text = ""
    end

    entry.text
  }

  if window_action == :save
    gtk_locals.each_pair { |option,widget|
      if widget.class == Gtk::CheckButton or widget.class == Gtk::RadioButton
        CharSettings[option] = widget.active?
      elsif widget.class == Gtk::Entry
        CharSettings[option] = clean_entry.call(widget)
      else
        echo "error: unknown local widget #{option} [#{widget.class}]"
      end
    }

    echo 'Settings saved'
  else
    echo 'Closed without saving'
  end
  exit
}

class << forger
  attr_accessor :keeper_container, :oil_container,
  :wastebin, :block_container, :material_no, :last_msg, :last_count,
  :material_name, :slab_container, :glyph_no, :glyph_name,
  :glyph_material, :scrap_container, :size, :keepers, :average_container,
  :DEBUG, :rank, :afk, :afk_count, :reps, :successes, :failures, :major_failures, :trash_choice

  #@@ANNOUNCE = Script.exists?('slack')

  #@DEBUG = true

  Rent = 300

  Targets = {
    "Ta'Illistim" => {
      'town'    =>   188,
      'wastebin'  => 'bin'
    },
    "Wehnimer's Landing" => {
      'town'    =>   228,
      'wastebin'  => 'bin'
    },
    'Solhaven' => {
      'town'    =>  1438,
      'wastebin'  => 'bin'
    },
    'Icemule Trace' => {
      'town'    =>  2300,
      'wastebin'  => 'bin'
    },
    'Teras Isle' => {
      'town'    =>  1932,
      'wastebin'  => 'barrel'
    },
    "River's Rest" => {
      'town'    => 10861,
      'wastebin'  => 'bin'
    },
    'Zul Logoth' => {
      'town'    =>  1005,
      'wastebin'  => 'barrel'
    },
    "Ta'Vaalor" => {
      'town'    =>  3519,
      'wastebin'  => 'bin'
    }
  }

  def find_wastebin
    target_list = Array.new
    Targets.each_value { |town| target_list += [ town['town'] ] }

    previous, shortest_distances = Map.dijkstra(Room.current, target_list)
    @wastebin = least_time = nil
    for town in Targets.values
      next unless shortest_distances[ town['town'] ]
      est_time = shortest_distances[ town['town'] ]
      if !est_time.nil? and (least_time.nil? or least_time > est_time)
        @wastebin = town['wastebin']
        least_time = est_time
      end
    end
  end

  def squelch
    forgeaction  = proc { |server_string|
      if server_string.strip.length == 0
        nil
        next
      end
      case server_string
      when /begin pumping to set the wheel spinning|you press it against the spinning stone|dust rises from the spinning wheel as you grind|internal strength fully recovers|begin to lose touch with your internal sources|You swap|you feel pleased with yourself at having cleaned|may order a .*? of this item|for your patronage|ask about the price|silvers you offer in payment|Sold for \d+ silvers|sparks leap from the spinning wheel|around you see a grinder that may suit your|focus deep within yourself, searching for untapped sources|feel a great deal stronger|feel fully energetic|you still have some time remaining, the clerk directs you|press it against the spinning wheel|hum of the spinning wheel and the scent|reducing areas of roughness to a polished|pause to press a tube of diamond dust paste|straighten up from working at the polishing wheel|#{Char.name} is using the polisher right|pause to examine both pieces closely|pick up a file and file|decide the safest thing to do now is to|you get to your feet|cost you \d+ silvers|you set to work assembling your|dip some rendered rolton fat from a small|upon fitting the two pieces together/
        nil
      when /around you see a trough and a pair of tongs|need it in order to set the temper in the weapon when you're done|pull the drain plug from the tempering trough|the tempering trough is empty nothing happens|lift the bucket from its hook and dip a bucket|take the mithril tongs from their place on the anvil|dull orange glow filling the gaps between the coals pulses|darkens with perspiration as the newly awakened heat floods|takes on the glow from the surrounding|you begin to shape it with your forging|reddish sparks fly in all directions as you hammer away|hammer until the glow has faded|waiting for.*?to heat up again|from the forge and resume your work|fall about the base of the anvil|toward its final form as beads of perspiration form|you realize that the scribed pattern is gone|wipe sweat from your forehead with the back of your hand|waiting for.*?coloring of workable|sparks fly in all directions as you hammer|dozens of the blue sparks strike the chain webbing overhead\.  As each spark touches a mithril link it winks out of existence, but in its place a blue nimbus forms around the link|spinning wheel as you grind away/
        nil
      when /(<roundTime value=\'.*\'\/>)(?:You carefully trace|You begin to trace)/
        $1
      else
        server_string
      end
    }
    DownstreamHook.remove('forgesquelch')
    DownstreamHook.add('forgesquelch', forgeaction)
  end

  def location
    fput "citizenship"
    location_check = dothistimeout "location", 7, /You carefully survey your surroundings/
    if location_check =~ /your current location is (.*) or somewhere close to it/
      forge_location = $1.to_s
      if forge_location =~ /Kharam Dzu/
        $forge_town = "Teras Isle"
      else
        $forge_town = forge_location
      end
    else
      echo "Error: did not recognize location response"
    end
  end

  def setup
    if CharSettings["average_container"] == ""
      CharSettings["average_container"] = nil
    end
    if CharSettings["keeper_container"] == ""
      CharSettings["keeper_container"] = nil
    end
    if CharSettings["oil_container"] == ""
      CharSettings["oil_container"] = nil
    end
    if CharSettings["block_container"] == ""
      CharSettings["block_container"] = nil
    end
    if CharSettings["slab_container"] == ""
      CharSettings["slab_container"] = nil
    end
    if CharSettings["scrap_container"] == ""
      CharSettings["scrap_container"] = nil
    end
    if CharSettings["glyph_container"] == ""
      CharSettings["glyph_container"] = nil
    end
    if CharSettings["material_noun"] == ""
      CharSettings["material_noun"] = nil
    end
    if CharSettings["material_name"] == ""
      CharSettings["material_name"] = nil
    end
    if CharSettings["material_no"] == ""
      CharSettings["material_no"] = nil
    end
    if CharSettings["glyph_name"] == ""
      CharSettings["glyph_name"] = nil
    end
    if CharSettings["glyph_no"] == ""
      CharSettings["glyph_no"] = nil
    end
    if CharSettings["glyph_material"] == ""
      CharSettings["glyph_material"] = nil
    end

    @average_container  = CharSettings["average_container"]
    @keeper_container   = CharSettings["keeper_container"]
    @oil_container    = CharSettings["oil_container"]
    @block_container  = CharSettings["block_container"]
    @slab_container   = CharSettings["slab_container"]
    @scrap_container  = CharSettings["scrap_container"]
    @glyph_container  = CharSettings["glyph_container"]
    @material_noun    = CharSettings["material_noun"]
    @material_name    = CharSettings["material_name"]
    @material_no    = CharSettings["material_no"].to_i
    @glyph_name     = CharSettings["glyph_name"]
    @glyph_no     = CharSettings["glyph_no"].to_i
    @glyph_material   = CharSettings["glyph_material"]
    @make_hammers   = CharSettings["make_hammers"]
    @keepers      = 0
    @successes      = 0
    @failures       = 0
    @major_failures   = 0
    @reps               = 0
    @last_msg       = Time.now
    @last_count     = 0
    @surge        = CharSettings["surge"]
    @squelch      = CharSettings["squelch"]
    @make_iron      = CharSettings["make_iron"]
    @unsafe_keepers   = !CharSettings['safe_keepers']

    # if CharSettings['trash_gift']
    #   @trash_choice = :gift
    # elsif CharSettings['trash_bin']
    #   @trash_choice = :bin
    # elsif CharSettings['trash_drop']
    #   @trash_choice = :drop
    # elsif !CharSettings['drop_it'].nil? && CharSettings['drop_it']
    #   @trash_choice = :drop
    #   echo '','Trash settings have changed. Please run setup.',''
    # elsif !CharSettings['drop_it'].nil? && !CharSettings['drop_it']
    #   @trash_choice = :bin
    #   echo '','Trash settings have changed. Please run setup.',''
    # else
    #   @trash_choice = :gift
    #   echo '','You have not chosen a trash setting. Please run setup.',''
    # end
    #@drop_it     = CharSettings['drop_it']

    if @squelch
      squelch
      echo "Squelch Successful"
      before_dying {DownstreamHook.remove('forgesquelch')}
    end
    before_dying { breakdown }
    find_wastebin
    wear_apron
    empty_hands
    rent
  end

  # def announce(msg)
  #   output = "channel forgery :hammer_and_pick: #gemstone #{Char.name}: #{msg}"
  #   Script.start('slack', output)
  # end

  def withdraw(x)
    multifput "deposit all", "withdraw #{x} silver"
    exit if (waitfor "makes a few marks", "carefully records the transaction", "you don't seem to have that much in the account.\"") =~ /sorry/
  end

  def bank(amt)
    waitrt?
    start_script "go2", [ "bank"]
    wait_while {running?('go2')}
    withdraw(amt)
    start_script "go2", [ "forge"]
    wait_while {running?('go2')}
  end

  def use_surge
    if Spell[9606].active?
      fput "cman surge" unless checkstamina < 61
    else
      fput "cman surge" unless checkstamina < 31
    end
  end

  def get_glyph
    if @glyph_container && @glyph_no && @glyph_name && @glyph_material
      move "out"
      buy(@glyph_no, @glyph_material)
      you_put(@glyph_name, @glyph_container)
      rent
    elsif @glyph_container && @glyph_name
      rent
    end
    if @size == nil
      measure   ##measures the glyph size and saves for later...IMPORTANT
    end
  end

  def buy(item, material=nil)
    line = ""
    until line =~ /hands you/
      if $forge_town == nil
        location
      end
      if material
        if Char.citizenship == $forge_town
          cost = dothis "order #{item} material #{material}", /a citizen of this town, I\'ll drop the price to (\d+)\./
        else
          cost = dothis "order #{item} material #{material}", /(\d+) silvers/
        end
        cost = cost.slice(/[0-9]+/).to_i
      else
        if Char.citizenship == $forge_town
          cost = dothis "order #{item}", /a citizen of this town, I\'ll drop the price to (\d+)\./
        else
          cost = dothis "order #{item}", /(\d+) silvers/
        end
        cost = cost.slice(/[0-9]+/).to_i
      end
      fput "buy"
      line = waitfor "buckle under", "hands you", "do not have"
      exit if line =~ /buckle under/
      if line =~ /do not have/
        bank(cost+Rent)
      end
    end
  end

  def hammer_time
    waitrt?
    fput "swap" if checkleft =~ /forging-hammer/
    until checkright =~ /forging-hammer/
      #command = "get my forging" if GameObj.inv.find {|i| i.contents == "forging-hammer"} ### Contents be annoying as heck, y'all
      #command = "remove forging" if GameObj.inv.find {|i| i.noun == "forging-hammer"}
      command = GameObj.inv.find {|i| i.noun == "forging-hammer"} ? 'remove my forging-hammer' : 'get my forging-hammer'
      fput "stow right" if checkright
      fput command unless checkright =~ /forging-hammer/
    end
  end

  def rent
    if checkroom !~ /Workshop\]/
      fput "go workshop"
      if (waitfor "rentals", "remaining", "collects") =~ /You don\'t have enough silver, rentals are 300 silver\./ ## what's the message when you are too poor?
        bank(Rent)
        move "go workshop"
      end
    end
  end

  def afk_wait
    if @reps > 0 and @reps % @afk_count == 0
      puts '',"#{monsterbold_start}[#{Script.self} * Waiting on user input. Hit EXPERIENCE.]#{monsterbold_end}",''
      waitfor 'Physical TPs:'
    end
  end

  def tongs
    waitrt?
    move "go door"
    oil
    done = false
    line = ""
    until done
      if Spell[9605].timeleft < 1 and @surge
        use_surge
      end
      hammer_time
      fput "get tongs"      # "grinding wheel chews" <--- wtf?
      line = waitfor "tempering trough is empty", "will be ruined if you try to set the temper with", "tongs on the anvil", "tongs to the anvil", "need to be holding", "material you want to work", "expired", "has not been scribed", "hanging crystal and spreads", "into the tempering trough", "anvil as you shake your head and ", "hammer in your right", "this would be a real waste"
      echo line if @DEBUG
      waitrt?
      afk_wait if @afk and line =~ /best work|into the tempering trough|hanging crystal and spreads|tongs on the anvil|tongs to the anvil|anvil as you shake your head/
      ## more return handlers
      done = line =~ /shake your head and /
      exit if line =~ /need to be holding|material you want to work/
      if line =~ /this would be a real waste|will be ruined if you try to set the temper with|trough is empty/
        oil
      elsif line =~ /hammer in your right/
        hammer_time
      elsif line =~ /tongs to the anvil|has not been scribed/
        done = true
        move "go door"
        fput "wear my forging"
        glyph
      elsif line =~ /expired/
        multimove "go door", "out"
        rent
        move "go door"
      elsif line =~ /best work/
        @reps += 1
        done = true
        fput "wear my forging"
        move "go door"
        if @rank
          trash(checkleft)
        else
          keeper
        end
      elsif line =~ /into the tempering trough/
        @reps += 1
        done = true
        fput "wear my forging"
        move "go door"
        if @rank
          trash(checkleft)
        else
          average
        end
      elsif line =~ /hanging crystal and spreads/ # |grinding wheel chews/ ????
        @reps += 1
        @failures += 1
        fput "wear my forging"
        move "go door"
        trash(checkleft)
        done = true
      else
        @reps += 1
      end
    end

    if line !~ /hanging crystal and spreads across|into the tempering trough|grinding wheel chews into|best work|tongs to the anvil/
      fput "wear forging"
      move "go door"
    end
  end

  def buy_oil
    waitrt?
    fput "wear forging" if checkright =~ /forging-hammer/ && !(checkleft and checkright).nil?
    multimove "go door", "out"
    if @oil_container
      buy(oil_order[material_oil[@material_name]])
      you_put("oil", @oil_container)
      rent
      move "go door"
    else
      echo "No oil container set. Run ;forgery setup."
      exit
    end
  end

  def oil
    waitrt?
    fput "wear forging" if checkright =~ /forging-hammer/ && !(checkleft and checkright).nil?
    oil = Material_oil[@material_name]
    res = dothistimeout "look in trough", 10, /In the trough/
    unless res =~ /#{oil_trough[oil]}/    #ie.. unless you already have the oil you need in the trough
      if res =~ /oil|water/
        fput "pull plug"
        if @oil_container and (checkright =~ /oil/ or checkleft =~ /oil/)
          you_put("oil", @oil_container)
        elsif checkright =~ /oil/
          empty_right_hand
        elsif checkleft =~ /oil/
          empty_left_hand
        end
      end
      if oil != "water"
        if you_get(oil, @oil_container)
          fput "pour oil in trough" until !(checkright =~ /oil/ or checkleft =~ /oil/)
        elsif @oil_container
          buy_oil
        else
          echo "No oil container set. Run ;forgery setup."
          exit
        end
      else
        fput "get bucket"
        waitrt?
      end
    end
  end

  def salvage_oil
    res = dothistimeout "look in trough", 10, /In the trough/
    if res =~ /oil/
      fput "pull plug"
      if @oil_container and (checkright =~ /oil/ or checkleft =~ /oil/)
        you_put("oil", @oil_container)
      elsif checkright =~ /oil/
        empty_right_hand
      elsif checkleft =~ /oil/
        empty_left_hand
      end
    end
  end

  def prepare     ##sees if you have/gets a cut slab...(if not, then an uncut slab), then sees if you have/gets/measures the glyph to make a note of how big your cut slabs (bars) need to be, then puts the raw slab back in the slab container
    unless you_get(@material_noun, @block_container)
      if @slab_container
        get_slab
        measure   ##measures the glyph size and saves for later...IMPORTANT
        you_put(@material_noun, @slab_container)
      end
    end
  end

  def get_slab    ##gets a raw slab from container (or merchant) and puts it in your left hand
    echo "getting slab" if @DEBUG
    unless you_get(@material_noun, @slab_container)
      if @material_name == "iron" && @make_iron
        you_get("iron", @slab_container)
      end
      if checkright != "iron"
        echo "buying slab" if @DEBUG
        move "out"
        if @material_name == "iron" && @make_iron
          start_script('iron');
          wait_while{ running?('iron') }
          rent
          4.times{multifput "get my iron", "swap", "stare head-glyph"
              waitfor "Roundtime"
              pause "1s"
              waitrt?
              pause "1s"
              fput "stow my slab"}
          fput "get my slab"
        else
          buy(@material_no)
          rent
        end
      end
    end
    fput "swap"
    waitfor "You swap"
  end

  def you_get(item, container)
    echo "getting" if @DEBUG
    if container
      echo "container exists" if @DEBUG
      closed = false
      line = nil
      until line && !(line =~ /It's closed/)
        fput "get #{item} from #{container}"
        line = waitfor "You remove", "It's closed", "Get what"
        closed = closed || line =~ /It's closed./
      end
      fput "close #{container}" if closed
    else
      echo "container doesn't exist" if @DEBUG
      fput "get my #{item}"
      line = waitfor "You remove", "It's closed", "Get what"
    end
    return line =~ /You remove/
  end

  def measure
    if @make_hammers
      res = dothistimeout "measure #{glyph_name}", 5, /you determine it|What were|You can\'t seem/
    else
      res = dothistimeout "measure my #{glyph_name}", 5, /you determine it|What were|You can\'t seem/
    end
      if res =~ /necessary to have (\d+) pounds of/
        @size = $1.to_i
        echo ""
        echo "Your glyph requires #{@size} pound blocks.  saving info..."
        echo ""
      elsif res =~ /You can't seem to get a good measurement without holding the metal you intend to use in your left hand/
        get_bar
        measure
      else
        get_glyph
    end
  end

  def you_put(item, container)
    closed = false
    line = nil
    until line =~ /You put/
      fput "put #{item} in #{container}"
      line = waitfor "You put", "It's closed.", "won't fit"
      exit if line =~ /won't fit/
      closed = closed || line =~ /It's closed./
      fput "open #{container}" if closed
    end
    fput "close #{container}" if closed
  end

  def forge
    get_bar
    glyph
  end

  def get_bar     ##sees if you have correct sized BLOCKs (cut slabs in your @block_container) and puts in your left hand
            ##if NOT, it gets a raw slab from slab container, CUTs it to needed size, and puts it in your left hand
    unless checkleft(@material_noun) or checkright(@material_noun)
      unless you_get(@material_noun, @block_container)
        exit unless @slab_container
        get_slab    ##gets a raw slab from container (or merchant) and puts it in your left hand, returns to workshop if you had to buy it
        if @size == nil
          measure   ##measures the glyph size and saves for later...IMPORTANT
        end
        cut(@size)    ##goes to workshop if you're not already, cuts slab into right sized blocks
        exit unless you_get(@material_noun, @block_container)
      end
    end
    until checkleft =~/#{@material_noun}/
      fput "swap"
      pause 0.5
    end
  end

  def cut(target_size, pieces=nil)      ##target_size is @size variable saved from earlier when measuring glyph
    rent unless checkroom =~ /Workshop/
    left = right = 0
    if pieces         ##ONLY true when using the manual ;forgery cut <#>
      pieces.times { left, right = cut_once(target_size, left, right) }
    else
      until checkleft.nil?  ##when forging automatically with ;forgery
        if @material_noun =~ /block/
          left = 10
        elsif @material_noun =~ /bar/
          left = 15
        elsif @material_noun =~ /slab/
          left = 25
        end
        left, right = cut_once(target_size, left, right)
      end
    end
    scrap(GameObj.left_hand) if checkleft
  end

  def cut_once(target_size, left, right)
    if left == target_size || (left/2) < target_size        ##no need to cut if you can't get at least 2 pieces out of it (e.g. greatsword blade =13 lbs)
      you_put("left", @block_container)
    else
      fput "poke slab-cutter"         ##checks the starting position "proposed" cut sizes
                          #As you prepare to slide your bronze bar down a bit, you realize that any further adjustment will cause it to fall out of the slab-cutter!
      line = waitfor("You've just set", "You slide your", "You've just reset", "You really can't accomplish much", "too small to cut in two!","further adjustment will cause it to fall out of the slab-cutter!")
      if line =~ /reset/
        right = left = left/2
      elsif line =~ /into a (\d+)lb. piece and a (\d+)lb. piece/
        left, right = $1.to_i, $2.to_i
        echo "#{left} #{right} #{$1} #{$2}" if @DEBUG
      elsif line =~ /too small to cut in two/
        left = 1
        right = 0
      elsif line =~ /further adjustment will cause it to fall out of the slab-cutter!/
        left = 2
        right = 0
      else
        get_slab unless checkleft
        #redo
      end
      if left + right == target_size          ##if the 'proposed' cut sizes exactly add up to the desired size, then left IS ALREADY the desired size
        you_put("left", @block_container)
      elsif left + right < target_size && left + right > 0    ##if proposed cut sizes added together are less than the desired size, it's useless.
        scrap(GameObj.left_hand)
      else
        until left == target_size || right == target_size   ##until EITHER proposed size is a correct match, push cutter into other measurements
          fput "push slab-cutter"
          (waitfor "You slide") =~ /cut it into a (\d+)lb. piece and a (\d+)lb. piece/
          if ($1.to_i + $2.to_i) == (target_size*2)
            fput "poke slab-"
            left, right = target_size, target_size
          else
            left, right = $1.to_i, $2.to_i
          end
        end
        fput "pull slab-cutter"       ##when proposed cut size is correctly reached by the "until" condition above
        if left == target_size && right == target_size
          you_put("right", @block_container)
          you_put("left", @block_container)
          left = right = nil
        elsif right == target_size
          you_put("right", @block_container)
          if left < target_size
            scrap(GameObj.left_hand)
            left = right = nil
          end
        elsif left == target_size
          you_put("left", @block_container)
          if right < target_size
            scrap(GameObj.left_hand)
          else
            fput "swap"
            left = right
            right = nil
          end
        end
      end
    end
  pause "0.5s"
  return left, right                  ##does right need to be nil now?
  end

  def glyph
    waitrt?
    if @make_hammers
      fput "stare #{@glyph_name}"
    else
      fput "stare my #{@glyph_name}"
    end
    done = false
    while !done
      line = get


  ###  What the fuck is this for?  I dont remember adding this....
  # if line !~ /Your left hand is empty|realize it is too small|What were you referring to/
  #   line2 = matchwait /Your left hand is empty|grinder that may suit|door to the forging chamber|need to shape it somehow|realize it is too small|What were you referring to|Roundtime:/
  # end
      if line =~ /Your left hand is empty/
        done = true
        waitrt?
        fput "swap"
        get_bar if (waitfor "swap" =~ /have anything to swap/)
      elsif line =~ /grinder that may suit/
        done = true
        waitrt?
        grind
      elsif line =~ /door to the forging chamber/
        done = true
        waitrt?
        tongs
      elsif line =~ /has already been worked on, it cannot be scribed./
        done = true
        waitrt?
      tongs
      elsif line =~ /Roundtime: 30 sec./ #didn't glance at the grinder or the door; time to do this manually
        done = true
        waitrt?
        if @make_hammers
          grind
        elsif checkleft == "block"
          grind
        elsif GameObj.left_hand.noun =~ /slab|bar/ and GameObj.left_hand.name =~ /haft|handle|hilt|shaft/
          grind
        elsif checkleft =~ /slab|bar/
          tongs
        else
          echo 'Please send me the details of what you\'re forging; the script cannot figure out what machine to use.'
        end
      elsif line =~ /realize it is too small/
        done = true
        waitrt?
        trash(checkleft)
      elsif line =~ /What were you referring to/
        done = true
        waitrt?
        you_put(@material_noun, @block_container)
        get_glyph
      elsif line =~ /The material in your left hand is not in a form that the glyph will work on./
        done = true
        waitrt?
        echo '','Something weird is in your left hand.','This shouldn\'t have happened.',''
        empty_left_hand
        get_bar
        glyph
      end
    end
  end

  def polish
    container = GameObj.inv.find { |box|  box.noun =~ /#{@keeper_container}/ }
    unfinished = container.contents.select { |obj| obj.name =~ /rough|polished/ && obj.noun.include?("-") && (obj.type == 'uncommon' || !obj.type) && container }.each { |item|

      echo ""
      echo "It looks like #{item.name} needs polishing."
      echo ""
      unless checkroom =~ /Workshop/
        move "go door"
      end
      fput "get ##{item.id} from ##{container.id}"
      fput "swap"
      fput "lean polisher"
      line = waitfor "rent on this workshop has expired", "You give the polishing wheel a shove"
      waitrt?
      if line =~ /rent on this workshop has expired/
        move "out"
        rent
        fput "lean polisher"
        waitfor "You straighten up from working at the polishing wheel"
      elsif line =~ /You give the polishing wheel a shove/
        waitfor "You straighten up from working at the polishing wheel"
      end
      waitrt?
      fput "_drag ##{item.id} ##{container.id}"
    }
    sleep 1
  end

  def wear_apron
    if !GameObj.inv.find {|i| i.noun == "apron"}
      multifput("get my apron", "wear my apron")
      get_apron unless GameObj.inv.find {|i| i.noun == "apron"}
      multifput("get my apron", "wear my apron") unless GameObj.inv.find {|i| i.noun == "apron"}
    end
  end

  def get_apron
    fput "stow all"
    bank(1000)
    buy(1)
  end

  def grind
    fput "wear forging" if checkright =~ /forging-hammer/
    if Spell[9605].timeleft < 1 and @surge
      use_surge
    end
    waitrt?
    fput "turn grinder"
    line = waitfor "doesn't budge!", "Resignedly", "you need to hold it in your", "satisfied with the piece", "vindictive", "very best"
    waitrt?
    afk_wait if @afk unless line == 'The grinding wheel doesn\'t budge!  Most likely the rent on this workshop has expired.'
    if line =~ /doesn't budge!/
      you_put(@material_noun, @block_container)
      move "out"
      rent
    elsif line =~ /Resignedly, you get/
      @failures += 1
      @reps += 1
      glyph
    elsif line =~ /you need to hold it in your/
      fput "swap"
    elsif line =~ /very best/
      @reps += 1
      if @rank
        trash(checkleft)
      else
        keeper
      end
      if checkright(@material_noun)
        scrap(GameObj.right_hand)
      end
    elsif line =~ /satisfied with the piece/
      @reps += 1
      if @rank
        trash(checkleft)
      else
        average
      end
      if checkright(@material_noun)
        scrap(GameObj.right_hand)
      end
    elsif line =~ /vindictive/
      @reps += 1
      @major_failures += 1
      trash(checkleft)
      if checkright(@material_noun)
        scrap(GameObj.right_hand)
      end
    end
  end

  def keeper
    fput "mark my #{checkleft}" unless @unsafe_keepers #Don't sell/trash it!
    @keepers += 1
    if @keeper_container
      # announce("Made a best #{checkleft}!") if @@ANNOUNCE
      you_put(checkleft, @keeper_container)
    else
      echo "No keeper container set!  Aborting..."
      exit
    end
  end

  def average
    @successes += 1
    # if @@ANNOUNCE and (Time.now - @last_msg > 20*60)
    #   announce("Made #{@successes - @last_count} okay #{checkleft}s.")
    #   @last_count = @successes
    #   @last_msg = Time.now
    # end
    if @average_container
      you_put(checkleft, @average_container)
    else
      trash(checkleft)
    end
  end

  def trash(item)
    if checkname =~ /Forge/
      move "go door"
      # if trash_choice == :drop or (trash_choice == :gift and Gift.remaining > 0 and check_mind(0))
      #   fput "drop #{item}" # https://www.youtube.com/watch?v=gAYL5H46QnQ
      # else
        fput "put #{item} in #{@wastebin}"
      # end
      move "go door"
    else
      # if trash_choice == :drop or (trash_choice == :gift and Gift.remaining > 0 and check_mind(0))
      #   fput "drop #{item}"
      # else
        fput "put #{item} in #{@wastebin}"
      # end
    end
  end

  def scrap(item)
    if @scrap_container
      closed = false
      donescrapping = false
      until donescrapping == true
        line = nil
        fput "put ##{item.id} in #{@scrap_container}"
        line = waitfor "You put", "It's closed", "won't fit"
        if line =~ /fit/
          fput "look in my #{@scrap_container}"
          unless checkroom =~ /Workshop/
            move "go door"
          end
          move "out"
          start_script "go2", [ "pawnshop"]; wait_while {running?('go2')}
          fput "sell ##{item.id}"
          line = waitfor "then hands you", "basically worthless here", "hands it back to you"
          if line =~ /then hands you/
            box = GameObj.inv.find { |container| container.noun =~ /#{@scrap_container}/ }
            box.contents.select { |obj| obj.name =~ /#{@material_name} slab/ }.each { |obj| multifput "get ##{obj.id}", "sell ##{obj.id}" }

            donescrapping = true
            start_script "go2", [ "forge"]; wait_while {running?('go2')}
            rent
          elsif line =~ /worthless|hands it back to you/
            fput "drop ##{item.id}"
            echo ""
            echo "Don't save worthless scraps!"
            echo ""
            exit
          end
        elsif line =~ /closed/
          closed = true
          fput "open my #{@scrap_container}"
        elsif line =~ /You put/
          donescrapping = true
        end
      end
      fput "close #{container}" if closed
    else
      trash(item)
    end
  end

  def breakdown
    salvage_oil if checkroom =~ /Forge\]/
    puts "#{monsterbold_start}#{Script.self} session stats:#{monsterbold_end}",
    "  Best pieces:    #{@keepers}",
    "  Average pieces: #{@successes}",
    "  Minor failures: #{@failures}",
    "  Major failures: #{@major_failures}","" if !@rank && (@keepers + @successes + @failures + @major_failures > 0)
  end

  def usage
    respond "",
    "#{Script.self} SETUP:                                                                                   ",
    "  #{$clean_lich_char}#{Script.self} set average <container>   <= container for average pieces  (will TRASH them if left blank) ",
    "  #{$clean_lich_char}#{Script.self} set oil <container>       <= container for tempering oil                                   ",
    "  #{$clean_lich_char}#{Script.self} set keepers <container>   <= container for keepers (perfect pieces)                        ",
    "  #{$clean_lich_char}#{Script.self} set slabs <container>     <= container for raw slabs                             (REQUIRED)",
    "  #{$clean_lich_char}#{Script.self} set blocks <container>    <= container for the measured and cut slab blocks      (REQUIRED)",
    "  #{$clean_lich_char}#{Script.self} set scraps <container>    <= container for material scraps  (will TRASH them if left blank)",
    "  #{$clean_lich_char}#{Script.self} set glyph <name> <container> <#> <material> <=e.g.[blade-glyph backpack 14 wax] (SEE NOTE*)",
    "  #{$clean_lich_char}#{Script.self} set material <material> <noun> <order #>    <=e.g.[steel slab 4][maoral block 3] (REQUIRED)",
    "  #{$clean_lich_char}#{Script.self} set make_hammers <true/false>  <= make forging hammer-heads/handles with workshop glyphs   ",
    "  #{$clean_lich_char}#{Script.self} set surge <true/false>        <= toggles use of Cman Surge of Strength for relevant steps  ",
    "  #{$clean_lich_char}#{Script.self} set squelch <true/false>  <= squelches screen scroll for forging actions                   ",
    "  #{$clean_lich_char}#{Script.self} set make_iron <true/false><= makes iron in kobold mines (Requires iron.lic!)               ",
    "  #{$clean_lich_char}#{Script.self} set <name>                <= will clear that setting                                       ",
    "  #{$clean_lich_char}#{Script.self} display                   <= display the current Settings                                  ",
    "                                                                                                       ",
    "IMPORTANT NOTES ABOUT SETUP:                                                                           ",
    "  Block, Slab, Scrap, Keeper containers MUST be different.                                             ",
    "  If keeping 'Average' pieces, container should be different from 'Keeper' container.                  ",
    "  Do NOT use commas in when entering Settings for glyph and material                                   ",
    "  *To use your own glyphs (e.g. Maul/Lance), do NOT set order # or material. e.g.[blade-glyph backpack]",
    "",
    "#{Script.self} USAGE",
    "  #{$clean_lich_char}#{Script.self}                  <= Begin forging and polishing best pieces",
    "  #{$clean_lich_char}#{Script.self} setup            <= Will open a gui to setup your options",
    "  #{$clean_lich_char}#{Script.self} cut <size> <#>   <= cuts as many of # size as it can from one slab",
    "  #{$clean_lich_char}#{Script.self} keepers <#>      <= stop when # of keepers have been forged",
    "  #{$clean_lich_char}#{Script.self} forge [#]        <= does the forge routine [optionally, # times]",
    "  #{$clean_lich_char}#{Script.self} polish           <= polishes rough hilt/blade pieces found in your containers",
    "  #{$clean_lich_char}#{Script.self} rank             <= Forge away to rank up, DOES NOT KEEP ANY BEST PIECES",
    ""
  end
end

case script.vars[1].downcase
when nil, 'afk'
  if script.vars[1].downcase == 'afk'
    forger.afk = true
    forger.afk_count = script.vars[2].to_i > 0 ? script.vars[2].to_i : 2
  end
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    start_script "go2", [ "forge"]
    wait_while {running?('go2')}
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  forger.prepare
  fput "look in my #{@average_container}" if @average_container
  fput "look in my #{@keeper_container}" if @keeper_container
  fput "inventory"
  loop {
    forger.forge
    forger.polish
  }
when 'rank'
  forger.rank = true
  if script.vars[2].downcase == 'afk'
    forger.afk = true
    forger.afk_count = script.vars[3].to_i > 0 ? script.vars[3].to_i : 2
  end
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    start_script "go2", [ "forge"]
    wait_while {running?('go2')}
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  forger.prepare
  fput "look in my #{@average_container}" if @average_container
  fput "look in my #{@keeper_container}" if @keeper_container
  fput "inventory"
  loop {
    forger.forge
  }
when "forge"
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    start_script "go2", [ "forge"]
    wait_while {running?('go2')}
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  forger.prepare
  fput "look in my #{@average_container}" if @average_container
  fput "look in my #{@keeper_container}" if @keeper_container
  fput "inventory"
  if script.vars[2].to_i
    script.vars[2].to_i.times {
      forger.forge
    }
  else
    loop {
      forger.forge
    }
  end
when "polish"
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    start_script "go2", [ "forge"]
    wait_while {running?('go2')}
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  fput "look in my #{@average_container}" if @average_container
  fput "look in my #{@keeper_container}" if @keeper_container
  fput "inventory"
  forger.rent
  forger.polish
when "cut"
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    start_script "go2", [ "forge"]
    wait_while {running?('go2')}
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  fput "inventory"
  forger.cut(script.vars[2].to_i, script.vars[3].to_i)
when "keepers"
  unless CharSettings["keeper_container"]
    respond "You must first set a keeper container."
    exit
  end
  fput "look in my #{@average_container}" if @average_container
  fput "look in my #{@keeper_container}" if @keeper_container
  fput "inventory"
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    start_script "go2", [ "forge"]
    wait_while {running?('go2')}
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  forger.prepare
  while forger.keepers < script.vars[2].to_i
    forger.forge
    forger.polish
  end
when "display"
  respond  "Current Forger Settings:",
  "average             =>  #{CharSettings["average_container"]}   ",
  "oil                 =>  #{CharSettings["oil_container"]}       ",
  "keepers             =>  #{CharSettings["keeper_container"]}    ",
  "slabs               =>  #{CharSettings["slab_container"]}      ",
  "blocks  (slab cuts) =>  #{CharSettings["block_container"]}     ",
  "scraps              =>  #{CharSettings["scrap_container"]}     ",
  "glyph (name, container, order #, order material)  =>  #{CharSettings["glyph_name"]} #{CharSettings["glyph_container"]} #{CharSettings["glyph_no"]} #{CharSettings["glyph_material"]}  ",
  "material  (material type, material noun, order #) =>  #{CharSettings["material_name"]} #{CharSettings["material_noun"]} #{CharSettings["material_no"]}  ",
  "make_hammers        =>  #{CharSettings["make_hammers"]}        ",
  "surge               =>  #{CharSettings["surge"]}               ",
  "squelch             =>  #{CharSettings["squelch"]}             ",
  "make_iron           =>  #{CharSettings["make_iron"]}           ",
  "                                                           ",
  "IMPORTANT:",
  "   #{$clean_lich_char}#{Script.self} set <setting> <whatever>    for details type  #{$clean_lich_char}#{Script.self} help",
  "   Keepers, slabs, blocks, and scraps container must be different, but only the first 3 are required.",
  "   Leaving the average and scrap CharSettings blank will cause those things to be thrown away!   ",
  ""
when "set"
  case script.vars[2]
  when "average"
    CharSettings["average_container"] = script.vars[3]
    echo "Settings saved!"
  when "keepers"
    CharSettings["keeper_container"] = script.vars[3]
    echo "Settings saved!"
  when "blocks"
    CharSettings["block_container"] = script.vars[3]
    echo "Settings saved!"
  when "oil"
    CharSettings["oil_container"] = script.vars[3]
    echo "Settings saved!"
  when "slabs"
    CharSettings["slab_container"] = script.vars[3]
    echo "Settings saved!"
  when "material"
    CharSettings["material_name"] = script.vars[3]
    CharSettings["material_noun"] = script.vars[4]
    CharSettings["material_no"] = script.vars[5]
    echo "Settings saved!"
  when "glyph"
    CharSettings["glyph_name"] = script.vars[3]
    CharSettings["glyph_container"] = script.vars[4]
    CharSettings["glyph_no"] = script.vars[5]
    CharSettings["glyph_material"] = script.vars[6]
    echo "Settings saved!"
  when "make_hammers"
    CharSettings["make_hammers"] = script.vars[3]
    echo "Settings saved!"
  when "scraps"
    CharSettings["scrap_container"] = script.vars[3]
    echo "Settings saved!"
  when "surge"
    CharSettings["surge"] = script.vars[3]
    echo "Settings saved!"
  when "squelch"
    CharSettings["squelch"] = script.vars[3]
    echo "Settings saved!"
  when "make_iron"
    CharSettings["make_iron"] = script.vars[3]
    echo "Settings saved!"
  else
    forger.usage
  end
when "setup"
  setup.call
when "settings"
  setup.call
else
  forger.usage
end
