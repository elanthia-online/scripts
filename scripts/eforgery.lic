=begin

     help:                    ;eforgery ?
     current Settings:        ;eforgery display
     gui:                     ;eforgery setup

    ;eforgery will start it if you have it set up right

  IMPORTANT (READ THIS DAMNIT):
     ~Oil type (if needed) will auto-determined.
     ~Leaving the Average and Scrap settings BLANK will cause those pieces to be discarded.
     ~Block, Slab, Keeper, and Scrap containers MUST be different, although the last one is optional.
     ~'Average' & 'Keeper' containers should be different as finished pieces are identical-looking.
     ~To make HANDLES, set handle order # for glyph, and wood OR metal for material.
     ~This script DOES NOT COMBINE/VISE the pieces for you...thats the fun part!!

       Author: elanthia-online
 Contributors: Moredin, Tillek, Gnomad, Tysong, Dissonance
     Category: Artisan
         Tags: forging, forge, craft, artisan, perfect
      Version: 1.2.4

  Version Control:
    Major_change.feature_addition.bugfix

  v1.2.4 (2025-12-26)
    Removed deposit all from withdrawal routine, since it deposits the note we have and resets that
    Further improved silver handling to avoid unnecessary bank trips
    Fixed processing of slabs/blocks where they are already the correct size
    Reworked messaging to use Lich::Messaging instead of puts/respond/echo
    Significantly expanded in-line documentation
  v1.2.3 (2025-11-15)
    bugfix in get note to deposit existing note
    change to using Script.run instead of start_script/wait_while
  v1.2.2 (2025-05-23)
    Remove CharSettings.load - not used
  v1.2.1 (2025-05-07)
    Change from CharSettings.save to Settings.save
  v1.2.0 (2025-03-22)
    Will uses notes on you instead of running to the bank every action. Thanks to Deyesh as I have heavily borrowed from his work for this.
    Modified the trashing routine to use the "trash" verb
    Modified the trash barrel location for Ta'Vaalor to be closer to the forge
    Some cosmetic formatting updates for readability.
    Added the important read this info at the top and a script pause for the first run.
    Added debugging code.
  v1.1.0 (2023-07-11)
    Remove support for making iron slabs via ;iron script as not working and labor/time intensive
  v1.0.5 (2023-06-26)
    Fix for ClimateWear containers
    Fix for missing glyph
    Fix for grind/tongs RT check
  v1.0.4 (2023-06-03)
    Fix for vaalor material oil
    Rubocop cleanup
  v1.0.3 (2022-05-03)
    Bugfix for variables outside of class.
  v1.0.2 (2022-05-02)
    Bugfix for regex match
  v1.0.1 (2022-04-29)
    Fix for commageddon. Combine buy regex, remove location check
  v1.0.0 (2022-03-29)
    Rename to eforgery from forgery for ease of distribution
    Change versioning to semantic system
  v19    (2022-03-29)
    Bugfix for material_oil typo
  v18    (2021-10-12)
    Updated to support GTK3

=end
=begin
  Pre-Elanthia Online Notes
  Pre-Gnomad changelog:
    Early 2011
      heavily modified Dalem's dforge script.
    Sep 2011
      fixed measuring the stand-alone hammerhead glyph for forging hammer heads.
    Jan 2012
      fixed citizenship buying bug
    Mar 2012
      fixed forging-hammer hang bugs.  thanks to Kuirit
      broke buying for non-citizens by accident when i fixed it for citizens.  error gone now and should work fine.  my bad!
      fixed a problem with the oil section of the script, and cleaned it up a little bit.  also added the oil type for rare metal slabs...props to Gizmo!
      fixed more bugs.  thanks to Gizmo for pointin em out.
    Mar 2012
      fixed and reworked the scrap-selling part which I dont think many people actually used because it only activates if the scrap_container fills up.
  Gnomad changelog:
    Oct 2015
      Forked by Gnomad
    Dec 2015:
      Various bugfixes
      began internal testing (v2, internal)
    Jan 2016
      MARK perfect items as unsellable (v3, internal)
      forged perfect hammer
      began OHE work
    Feb 2016
      Added rank mode that trashes perfects
      minor bugfixes (v4, internal)
      reached OHE 497 with script
    Mar 2016
      Added no-exp mode that drops intead of using a trash bin (v5, internal)
      mastered OHE, oil and polishing bugfixes (v6),
      fixed a scrap bug, polish bug, settings bug, and a few other things (v7)
      Fixed another polish bug (v8)
    Apr 2016
      Addes some internal features (v9)
      fixed a spear-forging bug and migrated settings,
      to be per-character (v10), a hang when your glyph runs out (v11), added results tracking and some internal changes (v12)
    May 2016
      AFK tweaks (v13)
    Mar 2017
      Killed the gift/trash options for lumnis change(v15)
    Apr 2018
      Fixed a dumb bug where average pieces were mixed in the container with keepers
    Dec 2018
      Fixed a dumb oil bug. Again?
=end

# Attuning to hammer: You feel as if you've become accustomed to the balance and heft of this forging-hammer.

# Migrate old global settings to character/script specific settings, if needed
if Settings.to_hash.size > 0 and CharSettings.to_hash.size == 0
  Lich::Messaging.msg("info", "Migrating settings, one moment. This should only happen once per character.")
  Settings.to_hash.each do |setting, value|
    CharSettings[setting] = value
  end
end

# Make sure that settings get saved before the script exits
before_dying { Settings.save }

forger = Object.new
settings = CharSettings.to_hash

# give the user some info if it's the first time they've run this script.
if CharSettings["first_run"] == nil then
  Lich::Messaging.msg("warn", "IMPORTANT (READ THIS!):  (Displayed on First Run Only)")
  Lich::Messaging.msg("warn", "~Oil type (if needed) will auto-determined.")
  Lich::Messaging.msg("warn", "~Leaving the Average and Scrap settings BLANK will cause those pieces to be discarded.")
  Lich::Messaging.msg("warn", "~Block, Slab, Keeper, and Scrap containers MUST be different, although the last one is optional.")
  Lich::Messaging.msg("warn", "~'Average' & 'Keeper' containers should be different as finished pieces are identical-looking.")
  Lich::Messaging.msg("warn", "~To make HANDLES, set handle order # for glyph, and wood OR metal for material.")
  Lich::Messaging.msg("warn", "~This script DOES NOT COMBINE/VISE the pieces for you...thats the fun part!!")
  Lich::Messaging.msg("warn", "")
  Lich::Messaging.msg("warn", "For help type  #{$clean_lich_char}#{Script.self} help")
  Lich::Messaging.msg("warn", "")
  Lich::Messaging.msg("warn", "Continuing in 10 seconds...")

  CharSettings["first_run"] = false

  sleep 10
end

# build the GUI setup page and handle it
setup = proc {
  gtk_locals = Hash.new

  window = window_action = nil
  Gtk.queue {
    # define the tooltips for the GUI items
    ttips_text = {
      'average_container' => "Container that will contain all your completed pieces that are not perfect\nIf left blank, average pieces will be trashed instead\n\nAverage and Keeper containers must be different!",
      'keeper_container'  => "Container that will contain all your perfect pieces\n\nAverage and Keeper containers must be different!",
      'oil_container'     => "Container that will contain your oil\n\nCan be left blank if you are using bronze or iron for your forging material",
      'block_container'   => "Container that will contain your cut slab pieces\n\nMust be different than Fresh and Leftover containers",
      'slab_container'    => "Container that will contain your fresh slabs\n\nMust be different than Cut and Leftover containers",
      'scrap_container'   => "Container that will contain your leftover cut pieces\nIf left blank, leftover cut pieces will be trashed instead\n\nMust be different than Fresh and Cut containers",
      'glyph_container'   => "Container that will contain your forging glyph",
      'material_noun'     => "Noun of your forging material\nExample: bar",
      'material_name'     => "Name of your forging material\nExample: bronze",
      'material_no'       => "Order number of your forging material\nExample: 2",
      'glyph_name'        => "Name of your forging glyph\nExample: blade-glyph\n\nWhen making forging hammers, use head-glyph, etc.",
      'glyph_no'          => "The order number for the forging glyph\nExample: 44\n\nIf using the forging-hammer glyphs, leave BLANK\nOtherwise: Put 99 here.",
      'glyph_material'    => "Custom Material of your forging glyph\nExample: wax\n\nNot applicable to forging-hammer glyphs",
      'make_hammers'      => "Will make hammer-heads and hammer-handles from the workshop glyphs.\nSpecify handle-glyph or head-glyph above!\n\nOther glyph fields are ignored.",
      'surge'             => "Will perform the Combat Manuever \"Surge of Strength\" at the appropriate places while forging",
      'squelch'           => "Will remove the annoying screen scroll that happens when you perform forging actions\n\nCourtesy of Gibreficul\nTHANKS GIB!",
      'unsafe_keepers'    => "eforgery MARKSs best pieces as unsellable by default.\nUnchek this box if you want to live dangerously (or are ranking up).",
    }

    # Create the GUI widgets and set the default values to current settings
    gtk_locals['average_container'] = Gtk::Entry.new; gtk_locals['average_container'].text = (settings['average_container'] ||= "")
    gtk_locals['keeper_container'] = Gtk::Entry.new; gtk_locals['keeper_container'].text = (settings['keeper_container'] ||= "")
    gtk_locals['oil_container'] = Gtk::Entry.new; gtk_locals['oil_container'].text = (settings['oil_container'] ||= "")
    gtk_locals['block_container'] = Gtk::Entry.new; gtk_locals['block_container'].text = (settings['block_container'] ||= "")
    gtk_locals['slab_container'] = Gtk::Entry.new; gtk_locals['slab_container'].text = (settings['slab_container'] ||= "")
    gtk_locals['scrap_container'] = Gtk::Entry.new; gtk_locals['scrap_container'].text = (settings['scrap_container'] ||= "")
    gtk_locals['glyph_container'] = Gtk::Entry.new; gtk_locals['glyph_container'].text = (settings['glyph_container'] ||= "")
    gtk_locals['material_noun'] = Gtk::Entry.new; gtk_locals['material_noun'].text = (settings['material_noun'] ||= "")
    gtk_locals['material_name'] = Gtk::Entry.new; gtk_locals['material_name'].text = (settings['material_name'] ||= "")
    gtk_locals['material_no'] = Gtk::Entry.new; gtk_locals['material_no'].text = (settings['material_no'] ||= "")
    gtk_locals['glyph_name'] = Gtk::Entry.new; gtk_locals['glyph_name'].text = (settings['glyph_name'] ||= "")
    gtk_locals['glyph_no'] = Gtk::Entry.new; gtk_locals['glyph_no'].text = (settings['glyph_no'] ||= "")
    gtk_locals['glyph_material'] = Gtk::Entry.new; gtk_locals['glyph_material'].text = (settings['glyph_material'] ||= "")
    gtk_locals['make_hammers'] = Gtk::CheckButton.new('Make FORGING-HAMMER pieces with the free glyph'); gtk_locals['make_hammers'].active = (settings['make_hammers'] ||= false)
    gtk_locals['surge'] = Gtk::CheckButton.new('Use CMan Surge of Strength'); gtk_locals['surge'].active = (settings['surge'] ||= false)
    gtk_locals['squelch'] = Gtk::CheckButton.new('Squelch Forging Screen Scroll'); gtk_locals['squelch'].active = (settings['squelch'] ||= false)
    gtk_locals['safe_keepers'] = Gtk::CheckButton.new('MARK Best Pieces as Unsellable'); gtk_locals['safe_keepers'].active = (settings['safe_keepers'] ||= false)

    # Add tooltips
    ttips_text.each_pair { |widget, tip|
      if (widget = gtk_locals[widget])
        widget.set_tooltip_text(tip).has_tooltip = true
      end
    }

    # Primary Window
    window = Gtk::Window.new
    window.title = "eForgery"
    window.border_width = 3
    window.resizable = false

    # Notebooks for tabs at the top
    nb = Gtk::Notebook.new.set_show_border(true) # deprecated - .set_tab_border(3)

    #
    # Notebook Page 1 - Sacks
    #
    big_box = Gtk::Box.new(:horizontal, 1).set_border_width(3)

    vb_pg1a = Gtk::Box.new(:vertical, 1).set_border_width(3)
    vb_pg1b = Gtk::Box.new(:vertical, 1).set_border_width(3)
    big_box.pack_start(vb_pg1a, :expand => false, :fill => false, :padding => 0)
    big_box.pack_start(vb_pg1b, :expand => false, :fill => false, :padding => 0)

    #
    # Page 1, Frame 1 - Sacks
    #
    vb_pg1_1 = Gtk::Box.new(:vertical, 1).set_border_width(3)
    fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('Storage Options'))
    fr_pg1_1.add(vb_pg1_1)
    vb_pg1a.pack_start(fr_pg1_1, :expand => false, :fill => false, :padding => 0)

    lbl = Gtk::Label.new.set_markup("<b>*MOUSE OVER FIELDS FOR INFORMATION*</b>")
    lbl.set_wrap(true).set_width_request(250).set_padding(0, 0)
    vb_pg1_1.pack_start(lbl, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Average Container:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['average_container'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Keeper Container:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['keeper_container'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Oil Container:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['oil_container'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Cut Slab Container:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['block_container'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Fresh Slab Container:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['slab_container'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Leftover Cut Slabs Container:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['scrap_container'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Glyph Container:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['glyph_container'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(gtk_locals['safe_keepers'].set_width_request(300), :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    vb_pg1_2 = Gtk::Box.new(:vertical, 1).set_border_width(3)
    fr_pg1_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('Forging Options'))
    fr_pg1_2.add(vb_pg1_2)
    vb_pg1b.pack_start(fr_pg1_2, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Material Name:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['material_name'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Material Noun:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['material_noun'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Material Order #:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['material_no'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Glyph Name:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['glyph_name'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Glyph Material:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['glyph_material'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Glyph Order #:')), :expand => true, :fill => false, :padding => 0)
    hb.pack_start(gtk_locals['glyph_no'], :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(gtk_locals['make_hammers'].set_width_request(300), :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(gtk_locals['surge'].set_width_request(300), :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(gtk_locals['squelch'].set_width_request(300), :expand => false, :fill => false, :padding => 0)
    vb_pg1_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    nb.append_page(big_box, Gtk::Label.new('Setup'))

    # Save/Close buttons
    hb_saveclose = Gtk::Box.new(:horizontal, 0)
    save = Gtk::Button.new(:label => '_Save & Close')
    close = Gtk::Button.new(:label => 'E_xit')

    save.signal_connect('clicked') { window_action = :save }
    close.signal_connect('clicked') { window_action = :done }

    hb_saveclose.pack_start(save, :expand => false, :fill => false, :padding => 0)
    hb_saveclose.pack_start(close, :expand => false, :fill => false, :padding => 0)

    # Primary VerticalBox to split up Notebook and Save/Close buttons
    vb_main = Gtk::Box.new(:vertical, 5)
    vb_main.border_width = 3

    vb_main.pack_start(nb, :expand => false, :fill => false, :padding => 0)
    vb_main.pack_start(Gtk::Alignment.new(1, 0, 0, 0).add(hb_saveclose), :expand => false, :fill => false, :padding => 0)

    window.signal_connect('delete_event') { window_action = :exit } # respond window.allocation.width;

    window.add(vb_main)
    window.show_all
    window.keep_above = true # On windows keep_above is required AFTER show_all
  }

  before_dying { Gtk.queue { window.destroy } }
  wait_while { window_action.nil? }
  undo_before_dying # Don't ask me what this does - I stripped it from Tillmen's code
  Gtk.queue { window.destroy }

  clean_entry = proc { |entry|
    entry.text = entry.text.strip
    if entry.text.empty?
      entry.text = ""
    end

    entry.text
  }

  if window_action == :save
    gtk_locals.each_pair { |option, widget|
      if widget.class == Gtk::CheckButton or widget.class == Gtk::RadioButton
        CharSettings[option] = widget.active?
      elsif widget.class == Gtk::Entry
        CharSettings[option] = clean_entry.call(widget)
      else
        Lich::Messaging.msg("error", "error: unknown local widget #{option} [#{widget.class}]")
      end
    }

    Lich::Messaging.msg("info", "Settings saved")
  else
    Lich::Messaging.msg("warn", "Closed without saving")
  end
  exit
}

class << forger
  attr_accessor :keeper_container, :oil_container,
                :wastebin, :block_container, :material_no, :last_msg, :last_count,
                :material_name, :slab_container, :glyph_no, :glyph_name,
                :glyph_material, :scrap_container, :size, :keepers, :average_container,
                :DEBUG, :rank, :afk, :afk_count, :reps, :successes, :failures, :major_failures, :trash_choice,
                :note_size, :note, :note_names

  Rent = 300

  # Targets contains the location and name of trash bins in a town.
  Targets = {
    "Ta'Illistim"        => {
      'town'     => 188,
      'wastebin' => 'bin'
    },
    "Wehnimer's Landing" => {
      'town'     => 228,
      'wastebin' => 'bin'
    },
    'Solhaven'           => {
      'town'     => 1438,
      'wastebin' => 'bin'
    },
    'Icemule Trace'      => {
      'town'     => 2300,
      'wastebin' => 'bin'
    },
    'Teras Isle'         => {
      'town'     => 1932,
      'wastebin' => 'barrel'
    },
    "River's Rest"       => {
      'town'     => 10861,
      'wastebin' => 'bin'
    },
    'Zul Logoth'         => {
      'town'     => 1005,
      'wastebin' => 'barrel'
    },
    "Ta'Vaalor"          => {
      'town'     => 3516, # Ta'Vaalor, Victory Wey (Inside Victory Gate)
      'wastebin' => 'barrel'
    }
  }

  # mapping what the tempering oils/water look like in the trough
  Oil_Trough = {
    "water"               => "some water",
    "tempering oil"       => "some oil",
    "enchanted oil"       => "some iridescent oil",
    "twice-enchanted oil" => "some opalescent oil",
    "ensorcelled oil"     => "some dimly glowing oil"
  }

  # mapping what materials use what oil
  Material_Oil = {
    "bronze"    => "water",
    "iron"      => "water",
    "steel"     => "tempering oil",
    "invar"     => "tempering oil",
    "faenor"    => "enchanted oil",
    "mithril"   => "enchanted oil",
    "ora"       => "enchanted oil",
    "drakar"    => "enchanted oil",
    "gornar"    => "enchanted oil",
    "rhimar"    => "enchanted oil",
    "zorchar"   => "enchanted oil",
    "kelyn"     => "enchanted oil",
    "imflass"   => "twice-enchanted oil",
    "razern"    => "twice-enchanted oil",
    "eahnor"    => "ensorcelled oil",
    "mithglin"  => "ensorcelled oil",
    "vaalorn"   => "twice-enchanted oil",
    "vultite"   => "ensorcelled oil",
    "rolaren"   => "ensorcelled oil",
    "veil iron" => "ensorcelled oil",
    "eonake"    => "ensorcelled oil",
    "golvern"   => "ensorcelled oil"
  }

  # mapping the order numbers for the oils
  Oil_Order = {
    "tempering oil"       => 5,
    "enchanted oil"       => 6,
    "twice-enchanted oil" => 7,
    "ensorcelled oil"     => 8
  }

  # Finds the optimal wastebin location based on the shortest travel time from the current room.
  #
  # This method calculates the shortest paths from the current room to all target towns
  # using Dijkstra's algorithm. It then determines which wastebin is located in the town
  # with the least estimated travel time, and assigns it to the `@wastebin` instance variable.
  #
  # @return [void]
  def find_wastebin
    target_list = Array.new
    Targets.each_value { |town| target_list += [town['town']] }

    _previous, shortest_distances = Map.dijkstra(Room.current, target_list)
    @wastebin = least_time = nil
    for town in Targets.values
      next unless shortest_distances[town['town']]
      est_time = shortest_distances[town['town']]
      if !est_time.nil? and (least_time.nil? or least_time > est_time)
        @wastebin = town['wastebin']
        least_time = est_time
      end
    end
  end

  # Suppresses or filters repetitive or unimportant forge-related messages from the game server output.
  #
  # This method installs a `DownstreamHook` that processes server messages, suppressing common
  # forging-related outputs to reduce visual clutter. It preserves relevant information such as
  # round time indicators, and automatically removes the hook when the script is about to exit.
  #
  # @return [void]
  def squelch
    forgeaction = proc { |server_string|
      if server_string.strip.length == 0
        next
      end
      case server_string
      when /begin pumping to set the wheel spinning|you press it against the spinning stone|dust rises from the spinning wheel as you grind|internal strength fully recovers|begin to lose touch with your internal sources|You swap|you feel pleased with yourself at having cleaned|may order a .*? of this item|for your patronage|ask about the price|silvers you offer in payment|Sold for \d+ silvers|sparks leap from the spinning wheel|around you see a grinder that may suit your|focus deep within yourself, searching for untapped sources|feel a great deal stronger|feel fully energetic|you still have some time remaining, the clerk directs you|press it against the spinning wheel|hum of the spinning wheel and the scent|reducing areas of roughness to a polished|pause to press a tube of diamond dust paste|straighten up from working at the polishing wheel|#{Char.name} is using the polisher right|pause to examine both pieces closely|pick up a file and file|decide the safest thing to do now is to|you get to your feet|cost you \d+ silvers|you set to work assembling your|dip some rendered rolton fat from a small|upon fitting the two pieces together/
        nil
      when /around you see a trough and a pair of tongs|need it in order to set the temper in the weapon when you're done|pull the drain plug from the tempering trough|the tempering trough is empty nothing happens|lift the bucket from its hook and dip a bucket|take the mithril tongs from their place on the anvil|dull orange glow filling the gaps between the coals pulses|darkens with perspiration as the newly awakened heat floods|takes on the glow from the surrounding|you begin to shape it with your forging|reddish sparks fly in all directions as you hammer away|hammer until the glow has faded|waiting for.*?to heat up again|from the forge and resume your work|fall about the base of the anvil|toward its final form as beads of perspiration form|you realize that the scribed pattern is gone|wipe sweat from your forehead with the back of your hand|waiting for.*?coloring of workable|sparks fly in all directions as you hammer|dozens of the blue sparks strike the chain webbing overhead\.  As each spark touches a mithril link it winks out of existence, but in its place a blue nimbus forms around the link|spinning wheel as you grind away/
        nil
      when /(<roundTime value=\'.*\'\/>)(?:You carefully trace|You begin to trace)/
        $1
      else
        server_string
      end
    }
    DownstreamHook.remove('forgesquelch')
    DownstreamHook.add('forgesquelch', forgeaction)

    before_dying { DownstreamHook.remove('forgesquelch') }
  end

  # Initializes character-specific forging settings and prepares the forging environment.
  #
  # This method normalizes user-configured settings stored in `CharSettings`, ensuring
  # empty strings are converted to `nil`. It assigns relevant values to instance variables,
  # sets up tracking counters, activates squelch filtering if enabled, and calls several
  # setup procedures such as `find_wastebin`, `wear_apron`, `empty_hands`, and `rent`.
  #
  # It also configures default note size if none is provided, sets up valid note names, and
  # registers cleanup routines via `before_dying`.
  #
  # @return [void]
  def setup
    if CharSettings["average_container"]  == "" then CharSettings["average_container"]  = nil end
    if CharSettings["keeper_container"]   == "" then CharSettings["keeper_container"]   = nil end
    if CharSettings["oil_container"]      == "" then CharSettings["oil_container"]      = nil end
    if CharSettings["block_container"]    == "" then CharSettings["block_container"]    = nil end
    if CharSettings["slab_container"]     == "" then CharSettings["slab_container"]     = nil end
    if CharSettings["scrap_container"]    == "" then CharSettings["scrap_container"]    = nil end
    if CharSettings["glyph_container"]    == "" then CharSettings["glyph_container"]    = nil end
    if CharSettings["material_noun"]      == "" then CharSettings["material_noun"]      = nil end
    if CharSettings["material_name"]      == "" then CharSettings["material_name"]      = nil end
    if CharSettings["material_no"]        == "" then CharSettings["material_no"]        = nil end
    if CharSettings["glyph_name"]         == "" then CharSettings["glyph_name"]         = nil end
    if CharSettings["glyph_no"]           == "" then CharSettings["glyph_no"]           = nil end
    if CharSettings["glyph_material"]     == "" then CharSettings["glyph_material"]     = nil end
    if CharSettings["note_size"]          == "" then CharSettings["note_size"]          = nil end
    if CharSettings["debug"]              == "" then CharSettings["debug"]              = nil end

    @average_container  = CharSettings["average_container"]
    @keeper_container   = CharSettings["keeper_container"]
    @oil_container      = CharSettings["oil_container"]
    @block_container    = CharSettings["block_container"]
    @slab_container     = CharSettings["slab_container"]
    @scrap_container    = CharSettings["scrap_container"]
    @glyph_container    = CharSettings["glyph_container"]
    @material_noun      = CharSettings["material_noun"]
    @material_name      = CharSettings["material_name"]
    @material_no        = CharSettings["material_no"].to_i
    @glyph_name         = CharSettings["glyph_name"]
    @glyph_no           = CharSettings["glyph_no"].to_i
    @glyph_material     = CharSettings["glyph_material"]
    @make_hammers       = CharSettings["make_hammers"]
    @keepers            = 0
    @successes          = 0
    @failures           = 0
    @major_failures     = 0
    @reps               = 0
    @last_msg           = Time.now
    @last_count         = 0
    @surge              = CharSettings["surge"]
    @squelch            = CharSettings["squelch"]
    @unsafe_keepers     = !CharSettings['safe_keepers']
    @note_size          = CharSettings["note_size"].to_i
    @note               = nil
    @DEBUG              = CharSettings["debug"] || false

    Lich::Messaging.msg("info", "In Setup") if @DEBUG

    if @note_size == nil || @note_size == 0 then
      Lich::Messaging.msg("info", "note_size is nil or 0, setting default of 100,000") if @DEBUG
      @note_size = 100_000 # use a default of 100k if not set to something else
    end

    @note_names = ['Northwatch bond note', 'Icemule promissory note', 'Borthuum Mining Company scrip', "Wehnimer's promissory note", 'Torren promissory note', 'mining chit', 'City-States promissory note', 'Vornavis promissory note', 'Mist Harbor promissory note']

    if @squelch
      Lich::Messaging.msg("info", "squelch enabled") if @DEBUG
      squelch
      Lich::Messaging.msg("info", "Squelch Successful")
    end

    before_dying { breakdown }

    find_wastebin
    wear_apron
    empty_hands
    rent
  end

  # Attempts to withdraw the specified amount of silver.
  #
  # Withdraws only the additional silver needed.
  # Exits if the withdrawal fails due to insufficient account balance.
  #
  # @param [Integer] silver_needed - The total amount of silver needed.
  # @return [void]
  def withdraw(silver_needed)
    Lich::Messaging.msg("info", "in withdraw(#{silver_needed})") if @DEBUG
    fput "withdraw #{(silver_needed - Util.silver_count)} silver" if silver_needed > Util.silver_count # withdraw the additional silver needed only
    exit if (waitfor "makes a few marks", "carefully records the transaction", "scribbles the transaction into a book", "you don't seem to have that much in the account.\"") =~ /sorry/
  end

  # Ensures the character has at least the specified amount of silver.
  #
  # If the current silver count is already sufficient, the method does nothing.
  # Otherwise, it navigates to the bank, withdraws the required silver,
  # and then returns to the forge.
  #
  # @param [Integer] silver_needed - The minimum amount of silver needed.
  # @return [void]
  def bank(silver_needed)
    Lich::Messaging.msg("info", "in bank(#{silver_needed})") if @DEBUG
    Lich::Messaging.msg("info", "Current silver: #{Util.silver_count}") if @DEBUG
    return if Util.silver_count >= silver_needed # already have enough silver to fulfill request

    waitrt?

    Script.run("go2", "bank")
    withdraw(silver_needed)
    Script.run("go2", "forge")
  end

  # Executes a command and collects output lines until no roundtime delay is present.
  #
  # This method sends a command to the game and captures matching output lines using a
  # provided regular expression. It continues retrying the command until no roundtime or wait
  # message is detected, ensuring that output is collected only when the character is free to act.
  #
  # @param command [String] the command to send to the game
  # @param regex [Regexp] the regular expression used to match lines of interest
  # @return [Array<String>] an array of lines matching the given regex or additional roundtime patterns
  def get_lines(command, regex)
    Lich::Messaging.msg("info", "get_lines(\"#{command}\", \"#{regex}\")") if @DEBUG
    lines = []
    regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

    loop {
      waitrt?
      lines = Lich::Util.quiet_command_xml(command, regex)
      break unless lines.any? { |l| l =~ /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i }
    }

    return lines
  end

  # Reads the currently held note to determine its monetary value.
  #
  # This method executes a read command on the note stored in `@note` and parses
  # the resulting output to extract its silver value. If a value is found in the
  # output, it is converted to an integer and returned.
  #
  # @return [Integer, nil] the note's silver value, or `nil` if not found
  def read_note()
    Lich::Messaging.msg("info", "in read_note()") if @DEBUG
    lines = get_lines("read #{@note}", /Hold in right hand to use/)

    if lines.any? { |l| l =~ /has a value of (.*?) silver and reads/ }
      result = $1.delete(",").to_i
    end

    return result
  end

  # Ensures the character has a promissory note of sufficient value, retrieving one if necessary.
  #
  # This method searches the character's containers for an existing promissory note. If a note is found,
  # it is read to determine its value. If the note is missing or has insufficient value, the method
  # travels to the bank, deposits all silver, withdraws a new note of the appropriate amount,
  # and returns to the forge. It also retrieves rent money while at the bank.
  #
  # @param amt [Integer] the minimum required value of the promissory note
  # @return [void]
  def get_note(amt)
    Lich::Messaging.msg("info", "in get_note(#{amt})") if @DEBUG

    need_note = false

    GameObj.inv.each { |item|
      if GameObj.containers[item.id]
        @note = item.contents.find { |i| @note_names.any? { |s| s.include?(i.name) } }
        Lich::Messaging.msg("info", "Found note: #{@note.name} (#{@note.id})") if @DEBUG && @note
        break if @note
      end
    }

    if @note
      Lich::Messaging.msg("info", "Checking note amount") if @DEBUG
      fput "get ##{@note.id}"

      note_amount = read_note
      need_note = true unless note_amount >= amt # if the note is worth enough, then we're good, otherwise we need to get a new one
    else
      need_note = true # didn't find a note, so we need one
    end

    Lich::Messaging.msg("info", "Need note: #{need_note}") if @DEBUG
    return unless need_note # if we don't need a note, then we're done

    Script.run("go2", "bank")

    fput "deposit all" # deposit everything we have into the bank so we can clean up old notes and such
    result = dothistimeout "withdraw #{((amt > @note_size) ? amt : @note_size)} note", 5, /^The teller carefully records the transaction|Very well|The teller hands you the coins|The teller makes some marks on a blank note and hands|The teller makes a few scribblings|The teller taps her quill thoughtfully|The teller scribbles the transaction|seem to have that much/

    if result =~ /seem to have that much/
      Lich::Messaging.msg("error", "** Insufficient funds! Exiting **")
      exit
    end

    waitrt?

    @note = [GameObj.right_hand, GameObj.left_hand].find { |i| @note_names.any? { |s| s.include?(i.name) } }

    # while we are here, we may as well get rent money since we just deposited everything
    withdraw(Rent)

    Script.run("go2", "forge")
  end

  # Stows any promissory note currently held in either hand.
  #
  # This method checks the character's hands for an item matching known promissory note names.
  # If such an item is found, it issues a command to stow the note.
  #
  # @return [void]
  def clear_note()
    Lich::Messaging.msg("info", "in clear_note()") if @DEBUG
    havenote = [GameObj.right_hand, GameObj.left_hand].find { |i| @note_names.any? { |s| s.include?(i.name) } }
    fput "stow #{havenote}" if havenote
  end

  # Activates the "surge" combat maneuver if stamina conditions are met.
  #
  # This method checks whether the Surge of Strength (Spell 9606) is active and uses different
  # stamina thresholds accordingly. If the character has sufficient stamina, it issues the
  # `cman surge` command.
  #
  # @return [void]
  def use_surge
    Lich::Messaging.msg("info", "in use_surge()") if @DEBUG
    CMan.use("surge", ignore_cooldown: true)
  end

  # Retrieves a glyph and stores it in the designated container, measuring it if needed.
  #
  # If all necessary glyph-related settings (`@glyph_container`, `@glyph_no`, `@glyph_name`,
  # and `@glyph_material`) are present, purchases the glyph, places it into the specified container,
  # and rents a workshop. If only the container and name are set, it simply rents a workshop.
  # Finally, if the glyph size (`@size`) has not been set, it calls `measure` to determine
  # and store the glyph size.
  #
  # @return [void]
  def get_glyph
    Lich::Messaging.msg("info", "in get_glyph") if @DEBUG
    if @glyph_container && @glyph_no && @glyph_name && @glyph_material
      move "out"
      buy(@glyph_no, @glyph_material)
      you_put(@glyph_name, @glyph_container)
      rent
    elsif @glyph_container && @glyph_name
      rent
    end
    if @size == nil
      measure # #measures the glyph size and saves for later...IMPORTANT
    end
  end

  # Purchases an item (optionally of a specific material) and ensures sufficient funds are available.
  #
  # This method handles the entire item purchasing process, including checking the cost,
  # retrieving a promissory note for payment via `get_note`, issuing the buy command, and handling
  # edge cases such as exceeding carry weight. It can optionally specify a material when ordering.
  # After a successful purchase, it clears the promissory note from the character's hands.
  #
  # @param item [Integer, String] the item number or identifier to order
  # @param material [String, nil] optional material specification for the item
  # @return [void]
  def buy(item, material = nil)
    Lich::Messaging.msg("info", "in buy(#{item}, #{material})") if @DEBUG
    line = ""
    until line =~ /hands you/
      if material
        cost = dothis "order #{item} material #{material}", /a citizen of this town, I\'ll drop the price to [\d,]+\.|[\d,]+ silvers/
      else
        cost = dothis "order #{item}", /a citizen of this town, I\'ll drop the price to [\d,]+\.|[\d,]+ silvers/
      end
      cost = cost.slice(/ [\d,]+/).gsub(",", "").to_i

      get_note(cost)
      fput "swap"

      if material
        Lich::Messaging.msg("info", "in material if") if @DEBUG
        cost = dothis "order #{item} material #{material}", /a citizen of this town, I\'ll drop the price to [\d,]+\.|[\d,]+ silvers/
      else
        Lich::Messaging.msg("info", "in material else") if @DEBUG
        cost = dothis "order #{item}", /a citizen of this town, I\'ll drop the price to [\d,]+\.|[\d,]+ silvers/
      end

      fput "buy"
      line = waitfor "buckle under", "hands you", "do not have"
      if line =~ /buckle under/
        Lich::Messaging.msg("error", "** You're carrying too much.")
        exit
      end

      clear_note
      # bank(cost + Rent) if line =~ /do not have/
    end
  end

  # Ensures the character is wielding a forging hammer in the right hand.
  #
  # This method checks if the character has a forging hammer equipped. If it's in the left hand,
  # it swaps hands. If it's not equipped, it attempts to either remove it from worn inventory
  # or retrieve it from a container. It will continue trying until the hammer is in the right hand.
  #
  # @return [void]
  def hammer_time
    Lich::Messaging.msg("info", "hammer_time") if @DEBUG
    waitrt?
    fput "swap" if checkleft =~ /forging-hammer/
    until checkright =~ /forging-hammer/
      command = GameObj.inv.find { |i| i.noun == "forging-hammer" } ? 'remove my forging-hammer' : 'get my forging-hammer'
      fput "stow right" if checkright
      fput command unless checkright =~ /forging-hammer/
    end
  end

  # Moves the character to the workshop and ensures rental fees are paid.
  #
  # This method checks if the character is currently in the workshop. If not, it attempts to move
  # there. If the system responds that the character lacks sufficient silver for the rental fee,
  # it withdraws the required amount from the bank and tries again. Workshop access costs 300 silver.
  #
  # @return [void]
  def rent
    Lich::Messaging.msg("info", "in rent") if @DEBUG
    if checkroom !~ /Workshop\]/
      fput "go workshop"
      if (waitfor "rentals", "remaining", "collects") =~ /You don\'t have enough silver, rentals are 300 silver\./
        bank(Rent) # rent requires silvers specifically
        move "go workshop"
      end
    end
  end

  # Pauses script execution to wait for user input after a set number of repetitions.
  #
  # This method is used to prevent prolonged unattended operation. If the repetition counter (`@reps`)
  # is a multiple of `@afk_count`, it displays a message prompting the user to provide input
  # (typically by typing `EXPERIENCE`) and waits for the response to include "Level:".
  #
  # @return [void]
  def afk_wait
    Lich::Messaging.msg("info", "in afk_wait") if @DEBUG
    if @reps > 0 and @reps % @afk_count == 0
      Lich::Messaging.msg("warn", "")
      Lich::Messaging.msg("warn", "[#{Script.self} * Waiting on user input. Hit EXPERIENCE.]")
      Lich::Messaging.msg("warn", "")
      waitfor "Level:"
    end
  end

  # Performs the tempering step in the forging process using tongs.
  #
  # This method coordinates a complex forging step that involves retrieving tongs, checking and
  # applying oil as needed, verifying forging conditions, and reacting to various outcomes based
  # on system messages. It handles spell and stamina checks (e.g., surge), ensures the forging
  # hammer is equipped, manages repetitions, failure states, and determines whether to keep,
  # trash, or average the forged item based on the result.
  #
  # The method exits early if critical conditions are unmet (e.g., required material not held).
  #
  # @return [void]
  def tongs
    Lich::Messaging.msg("info", "in tongs") if @DEBUG
    waitrt?
    move "go door"
    oil
    done = false
    line = ""
    until done
      if Spell[9605].timeleft < 1 and @surge
        use_surge
      end
      hammer_time
      fput "get tongs" # "grinding wheel chews" <--- wtf?
      line = waitfor "tempering trough is empty", "will be ruined if you try to set the temper with", "tongs on the anvil", "tongs to the anvil", "need to be holding", "material you want to work", "expired", "has not been scribed", "hanging crystal and spreads", "into the tempering trough", "anvil as you shake your head and ", "hammer in your right", "this would be a real waste"
      Lich::Messaging.msg("info", line) if @DEBUG
      waitrt?
      afk_wait if @afk and line =~ /best work|into the tempering trough|hanging crystal and spreads|tongs on the anvil|tongs to the anvil|anvil as you shake your head/
      ## more return handlers
      # done = line =~ /shake your head and /
      exit if line =~ /need to be holding|material you want to work/
      if line =~ /this would be a real waste|will be ruined if you try to set the temper with|trough is empty/
        oil
      elsif line =~ /hammer in your right/
        hammer_time
      elsif line =~ /tongs to the anvil|has not been scribed/
        done = true
        move "go door"
        fput "wear my forging"
        glyph
      elsif line =~ /expired/
        multimove "go door", "out"
        rent
        move "go door"
      elsif line =~ /best work/
        @reps += 1
        done = true
        fput "wear my forging"
        move "go door"
        if @rank
          trash(checkleft)
        else
          keeper
        end
      elsif line =~ /into the tempering trough/
        @reps += 1
        done = true
        fput "wear my forging"
        move "go door"
        if @rank
          trash(checkleft)
        else
          average
        end
      elsif line =~ /hanging crystal and spreads/ # |grinding wheel chews/ ????
        @reps += 1
        @failures += 1
        fput "wear my forging"
        move "go door"
        trash(checkleft)
        done = true
      else
        @reps += 1
      end
    end

    if line !~ /hanging crystal and spreads across|into the tempering trough|grinding wheel chews into|best work|tongs to the anvil/
      fput "wear forging"
      move "go door"
    end
  end

  # Purchases forging oil and stores it in the designated container.
  #
  # This method ensures the forging hammer is not interfering, exits the workshop, purchases
  # the appropriate oil based on the current material, and stores it in `@oil_container`.
  # It temporarily stows the slab, retrieves it again after the purchase, and ensures the
  # character returns to the workshop afterward. If no oil container is set, it logs an error
  # and exits the script.
  #
  # @return [void]
  def buy_oil
    Lich::Messaging.msg("info", "in buy_oil") if @DEBUG
    waitrt?
    fput "wear forging" if checkright =~ /forging-hammer/ && !(checkleft and checkright).nil?
    multimove "go door", "out"
    if @oil_container
      you_put("slab", @block_container)
      buy(Oil_Order[Material_Oil[@material_name]])
      you_put("oil", @oil_container)
      clear_note
      you_get("slab", @block_container)
      fput "swap"
      rent
      move "go door"
    else
      Lich::Messaging.msg("error", "No oil container set. Run ;eforgery setup.")
      exit
    end
  end

  # Ensures the correct type of oil is in the tempering trough for the forging process.
  #
  # This method verifies the contents of the trough and replaces them with the appropriate oil
  # based on the current material (`@material_name`) if needed. It handles draining incorrect contents,
  # retrieving oil from the designated container (`@oil_container`), and pouring it into the trough.
  # If the correct oil is unavailable, it attempts to purchase it. If no oil container is set,
  # it logs an error and exits the script.
  #
  # @return [void]
  def oil
    Lich::Messaging.msg("info", "in oil") if @DEBUG
    waitrt?
    fput "wear forging" if checkright =~ /forging-hammer/ && !(checkleft and checkright).nil?
    oil = Material_Oil[@material_name]
    res = dothistimeout "look in trough", 10, /In the trough/
    unless res =~ /#{Oil_Trough[oil]}/ # ie.. unless you already have the oil you need in the trough
      if res =~ /oil|water/
        fput "pull plug"
        if @oil_container and (checkright =~ /oil/ or checkleft =~ /oil/)
          you_put("oil", @oil_container)
        elsif checkright =~ /oil/
          empty_right_hand
        elsif checkleft =~ /oil/
          empty_left_hand
        end
      end
      if oil != "water"
        if you_get(oil, @oil_container)
          fput "pour oil in trough" until !(checkright =~ /oil/ or checkleft =~ /oil/)
        elsif @oil_container
          buy_oil
        else
          Lich::Messaging.msg("error", "No oil container set. Run ;eforgery setup.")
          exit
        end
      else
        fput "get bucket"
        waitrt?
      end
    end
  end

  # Drains and salvages any remaining oil from the tempering trough.
  #
  # This method checks the contents of the tempering trough. If oil is present, it pulls the plug
  # to drain it. If the character is holding a container and has oil in either hand, the oil is
  # stored appropriately using `you_put`. If no container is available, it simply clears the hand.
  #
  # @return [void]
  def salvage_oil
    Lich::Messaging.msg("info", "in salvage_oil") if @DEBUG
    res = dothistimeout "look in trough", 10, /In the trough/
    if res =~ /oil/
      fput "pull plug"
      if @oil_container and (checkright =~ /oil/ or checkleft =~ /oil/)
        you_put("oil", @oil_container)
      elsif checkright =~ /oil/
        empty_right_hand
      elsif checkleft =~ /oil/
        empty_left_hand
      end
    end
  end

  # Prepares the appropriate material for forging by ensuring a cut slab is available and measured.
  #
  # This method attempts to retrieve a cut slab (bar) of the required material from the block container.
  # If none is found, it retrieves a raw slab from the slab container, measures the associated glyph
  # to determine the correct size for future cuts, and then returns the raw slab to storage.
  #
  # @return [void]
  def prepare     # sees if you have/gets a cut slab...(if not, then an uncut slab), then sees if you have/gets/measures the glyph to make a note of how big your cut slabs (bars) need to be, then puts the raw slab back in the slab container
    Lich::Messaging.msg("info", "in prepare") if @DEBUG
    unless you_get(@material_noun, @block_container)
      if @slab_container
        get_slab
        measure   # measures the glyph size and saves for later...IMPORTANT
        you_put(@material_noun, @slab_container)
      end
    end
  end

  # Retrieves a raw forging slab and ensures it is held in the left hand.
  #
  # This method first attempts to retrieve a slab of the specified material from the slab container.
  # If none is found, it purchases a new slab using the material number (`@material_no`), then rents
  # a room. After acquiring the slab, it swaps hands to ensure the slab is in the left hand.
  #
  # @return [void]
  def get_slab # gets a raw slab from container (or merchant) and puts it in your left hand
    Lich::Messaging.msg("info", "in get_slab") if @DEBUG
    unless you_get(@material_noun, @slab_container)
      if checkright != "iron"
        Lich::Messaging.msg("info", "buying slab") if @DEBUG
        move "out"
        buy(@material_no)
        rent
      end
    end

    Lich::Messaging.msg("info", "post get_slab buy swap L: #{GameObj.right_hand.noun} R: #{GameObj.left_hand.noun}") if @DEBUG
    fput "swap"
    waitfor "You swap"
  end

  # Attempts to retrieve a specified item from a container or directly from inventory.
  #
  # This method first checks if the item is already in either hand. If not, it attempts to get the item
  # from the specified container. It handles the case where the container is closed by retrying until
  # it can successfully retrieve the item, then closes the container if it had to be opened.
  # If no container is provided, it tries to get the item directly. Returns `true` if the item was
  # successfully retrieved.
  #
  # @param item [String] the name or noun of the item to retrieve
  # @param container [String, nil] the name of the container to retrieve the item from, or `nil` to search general inventory
  # @return [Boolean] `true` if the item was successfully retrieved, `false` otherwise
  def you_get(item, container)
    Lich::Messaging.msg("info", "in you_get(#{item}, #{container})") if @DEBUG
    if container
      Lich::Messaging.msg("info", "container exists") if @DEBUG

      # if item is already in hands, move along
      if !(GameObj.right_hand.noun == item || GameObj.left_hand.noun == item) then
        Lich::Messaging.msg("info", "items were not in hand already") if @DEBUG
        closed = false
        line = nil
        until line && !(line =~ /It's closed/)
          fput "get #{item} from #{container}"
          line = waitfor "You remove", "You grab", "It's closed", "Get what"
          closed = closed || line =~ /It's closed./
        end
        fput "close #{container}" if closed
      else
        Lich::Messaging.msg("info", "item found in hand") if @DEBUG
      end
    else
      Lich::Messaging.msg("info", "container doesn't exist") if @DEBUG
      fput "get my #{item}"
      line = waitfor "You remove", "You grab", "It's closed", "Get what"
    end
    return line =~ /You remove/ || line =~ /You grab/
  end

  # Measures a glyph to determine the required block size for forging.
  #
  # This method sends a `measure` command for the current glyph to determine how many pounds of metal
  # are needed. If the measurement is successful, it saves the size to `@size`. If measurement fails
  # due to missing required items (e.g., the metal not being in the left hand), it attempts to retrieve
  # the necessary bar and retries the measurement. If the glyph is missing or unreadable, it attempts
  # to acquire it again.
  #
  # @return [void]
  def measure
    Lich::Messaging.msg("info", "in measure") if @DEBUG
    if @make_hammers
      res = dothistimeout "measure #{glyph_name}", 5, /you determine it|What were|You can\'t seem/
    else
      res = dothistimeout "measure my #{glyph_name}", 5, /you determine it|What were|You can\'t seem/
    end
    if res =~ /necessary to have (\d+) pounds of/
      @size = $1.to_i
      Lich::Messaging.msg("info", "")
      Lich::Messaging.msg("info", "Your glyph requires #{@size} pound blocks.  saving info...")
      Lich::Messaging.msg("info", "")
    elsif res =~ /You can't seem to get a good measurement without holding the metal you intend to use in your left hand/
      get_bar
      measure
    else
      get_glyph
    end
  end

  # Places a specified item into a given container, handling open/closed states.
  #
  # This method attempts to put an item into the specified container. If the container is closed,
  # it opens it and retries until successful. After placing the item, it closes the container
  # if it had been opened. If the item won't fit in the container, the script exits.
  #
  # @param item [String] the name or identifier of the item to store
  # @param container [String] the name of the container to store the item in
  # @return [void]
  def you_put(item, container)
    Lich::Messaging.msg("info", "in you_put (#{item}, #{container})") if @DEBUG
    closed = false
    line = nil
    until line =~ /You put/ || line =~ /You tuck/
      fput "put #{item} in #{container}"
      line = waitfor "You put", "You tuck", "It's closed.", "won't fit"
      exit if line =~ /won't fit/
      closed = closed || line =~ /It's closed./
      fput "open #{container}" if closed
    end
    fput "close #{container}" if closed
  end

  # Initiates the forging process by retrieving a metal bar and applying the glyph.
  #
  # This method begins the forging workflow by calling `get_bar` to obtain the required metal bar,
  # then proceeds to apply the glyph using the `glyph` method.
  #
  # @return [void]
  def forge
    Lich::Messaging.msg("info", "in forge") if @DEBUG
    get_bar
    glyph
  end

  # Ensures a correctly sized metal block is in the character's left hand for forging.
  #
  # This method first checks if a suitable block (cut slab) is already held. If not, it attempts
  # to retrieve one from the block container. If none is found and a slab container is available,
  # it retrieves a raw slab, measures the glyph if needed to determine the correct size, and
  # cuts the slab into the appropriate blocks. It then ensures the correct block is swapped into
  # the left hand.
  #
  # @return [void]
  def get_bar # sees if you have correct sized BLOCKs (cut slabs in your @block_container) and puts in your left hand
    Lich::Messaging.msg("info", "in get_bar") if @DEBUG
    # if NOT, it gets a raw slab from slab container, CUTs it to needed size, and puts it in your left hand
    unless checkleft(@material_noun) or checkright(@material_noun)
      unless you_get(@material_noun, @block_container)
        exit unless @slab_container
        get_slab    # gets a raw slab from container (or merchant) and puts it in your left hand, returns to workshop if you had to buy it
        if @size == nil
          measure   # measures the glyph size and saves for later...IMPORTANT
        end
        cut(@size) # goes to workshop if you're not already, cuts slab into right sized blocks
        exit unless you_get(@material_noun, @block_container)
      end
    end
    until checkleft =~ /#{@material_noun}/
      fput "swap"
      pause 0.5
    end
  end

  # Cuts a raw slab into blocks of a specified target size.
  #
  # This method ensures the character is in the workshop, then proceeds to cut a raw material slab
  # into blocks matching the required forging size (`target_size`, typically from glyph measurement).
  # If the `pieces` argument is provided (manual mode), it performs a fixed number of cuts.
  # Otherwise (automatic mode), it continues cutting until the slab is no longer held.
  # After cutting, it scraps any remaining material still in the character's left hand.
  #
  # @param target_size [Integer] the desired size for each block, usually determined by the glyph
  # @param pieces [Integer, nil] optional number of pieces to cut manually; if nil, auto-cutting is used
  # @return [void]
  def cut(target_size, pieces = nil) # target_size is @size variable saved from earlier when measuring glyph
    Lich::Messaging.msg("info", "in cut(#{target_size}, #{pieces})") if @DEBUG
    rent unless checkroom =~ /Workshop/
    left = right = 0
    if pieces # #ONLY true when using the manual ;eforgery cut <#>
      Lich::Messaging.msg("info", "cut: pieces #{pieces}") if @DEBUG
      pieces.times { left, right = cut_once(target_size, left, right) }
    else
      Lich::Messaging.msg("info", "cut: else") if @DEBUG
      until checkleft.nil? # #when forging automatically with ;eforgery
        if @material_noun =~ /block/
          left = 10
        elsif @material_noun =~ /bar/
          left = 15
        elsif @material_noun =~ /slab/
          left = 25
        end
        Lich::Messaging.msg("info", "cut: about to call cut_once(#{target_size}, L: #{left}, R: #{right})") if @DEBUG
        left, right = cut_once(target_size, left, right)
      end
    end
    scrap(GameObj.left_hand) if checkleft
  end

  # Attempts a single cut of a slab or bar into two pieces of a target size using the slab-cutter.
  #
  # This method handles logic for manipulating the slab-cutter to achieve a cut that yields at least
  # one piece of the desired `target_size`. It checks initial cut estimates, adjusts the cutter position,
  # and responds to various cutter feedback lines. It places pieces into the block container, scraps
  # unusable fragments, and swaps pieces between hands if necessary. Handles special cases like
  # uncuttable slabs and edge-case outputs.
  #
  # @param target_size [Integer] the desired weight for a forged block
  # @param left [Integer] the current weight of the item in the left hand
  # @param right [Integer] the current weight of the potential cut-off piece
  # @return [Array<Integer, Integer>] the final weights of the left and right pieces after the cut
  def cut_once(target_size, left, right)
    Lich::Messaging.msg("info", "in cut_once(#{target_size}, #{left}, #{right})") if @DEBUG
    if left == target_size || (left / 2) < target_size # #no need to cut if you can't get at least 2 pieces out of it (e.g. greatsword blade =13 lbs)
      you_put("left", @block_container)
    else
      fput "poke slab-cutter" # #checks the starting position "proposed" cut sizes
      # As you prepare to slide your bronze bar down a bit, you realize that any further adjustment will cause it to fall out of the slab-cutter!
      line = waitfor("You've just set", "You slide your", "You've just reset", "You really can't accomplish much", "too small to cut in two!") # , "further adjustment will cause it to fall out")
      if line =~ /reset/
        right = left = left / 2
      elsif line =~ /into a (\d+)lb. piece and a (\d+)lb. piece/
        left, right = $1.to_i, $2.to_i
        Lich::Messaging.msg("info", "#{left} #{right} #{$1} #{$2}") if @DEBUG
      elsif line =~ /too small to cut in two/
        left = 1
        right = 0
      elsif line =~ /further adjustment will cause it to fall out/
        left = 2
        right = 0
      else
        get_slab unless checkleft
        # redo
      end
      if left + right == target_size # #if the 'proposed' cut sizes exactly add up to the desired size, then left IS ALREADY the desired size
        you_put("left", @block_container)
      elsif left + right < target_size && left + right > 0 # #if proposed cut sizes added together are less than the desired size, it's useless.
        scrap(GameObj.left_hand)
      else
        until left == target_size || right == target_size # #until EITHER proposed size is a correct match, push cutter into other measurements
          fput "push slab-cutter"
          line = (waitfor "You slide", "As you prepare to slide")
          if line =~ /cut it into a (\d+)lb. piece and a (\d+)lb. piece/
            if ($1.to_i + $2.to_i) == (target_size * 2)
              fput "poke slab-"
              left, right = target_size, target_size
            else
              left, right = $1.to_i, $2.to_i
            end
          elsif line =~ /further adjustment will cause it to fall out/
            you_put("left", @block_container)
            left = right = nil
            return left, right # if it's already the right size, move on
          else
            Lich::Messaging.msg("error", "Unexpected response from slab-cutter: #{line}")
          end
        end
        fput "pull slab-cutter" # #when proposed cut size is correctly reached by the "until" condition above
        if left == target_size && right == target_size
          you_put("right", @block_container)
          you_put("left", @block_container)
          left = right = nil
        elsif right == target_size
          you_put("right", @block_container)
          if left < target_size
            scrap(GameObj.left_hand)
            left = right = nil
          end
        elsif left == target_size
          you_put("left", @block_container)
          if right < target_size
            scrap(GameObj.left_hand)
          else
            fput "swap"
            left = right
            right = nil
          end
        end
      end
    end
    pause "0.5s"
    return left, right # #does right need to be nil now?
  end

  # Applies the glyph to the forging material and determines the next step based on the outcome.
  #
  # This method attempts to "stare" at the glyph to apply it to the forging material. It waits for
  # responses and uses conditional logic to determine the appropriate next stepeither proceeding
  # to grinding, tempering with tongs, retrieving a new glyph, or correcting issues such as an
  # empty hand or incorrect material. It also handles edge cases, including degraded glyphs and
  # unrecognized forging items.
  #
  # @return [void]
  def glyph
    Lich::Messaging.msg("info", "in glyph") if @DEBUG
    waitrt?
    if @make_hammers
      fput "stare #{@glyph_name}"
    else
      fput "stare my #{@glyph_name}"
    end
    done = false
    while !done
      line = get

      if line =~ /Your left hand is empty/
        done = true
        waitrt?
        fput "swap"
        get_bar if (waitfor "swap" =~ /have anything to swap/)
      elsif line =~ /grinder that may suit/
        done = true
        waitrt?
        grind
      elsif line =~ /door to the forging chamber/
        done = true
        waitrt?
        tongs
      elsif line =~ /has already been worked on, it cannot be scribed./
        done = true
        waitrt?
        tongs
      elsif line =~ /Roundtime:/ # didn't glance at the grinder or the door; time to do this manually.
        # Note from trisscar1212: This is most likely happening when the glyph degrades ("then the glyph turns a dull grey and crumbles to dust")
        done = true
        waitrt?
        if @make_hammers
          grind
        elsif checkleft == "block"
          grind
        elsif GameObj.left_hand.noun =~ /slab|bar/ and GameObj.left_hand.name =~ /haft|handle|hilt|shaft/
          grind
        elsif checkleft =~ /slab|bar/
          tongs
        else
          Lich::Messaging.msg("info", "Please send Elanthia Online the details of what you\'re forging; the script cannot figure out what machine to use.")
        end
      elsif line =~ /realize it is too small/
        done = true
        waitrt?
        trash(checkleft)
      elsif line =~ /What were you referring to/ || line =~ /You stare at nothing in particular/
        done = true
        waitrt?
        you_put(@material_noun, @block_container)
        get_glyph
      elsif line =~ /The material in your left hand is not in a form that the glyph will work on./
        done = true
        waitrt?
        Lich::Messaging.msg("warn", "")
        Lich::Messaging.msg("warn", "* Something weird is in your left hand.")
        Lich::Messaging.msg("warn", "  This shouldn't have happened.")
        Lich::Messaging.msg("warn", "")
        empty_left_hand
        get_bar
        glyph
      end
    end
  end

  # Polishes forged items stored in the keeper container that are marked as rough or partially polished.
  #
  # This method searches the `@keeper_container` for items that are rough or polished but not yet complete.
  # For each item found, it ensures the character is in the workshop, retrieves the item, uses the polisher,
  # and returns the item to the container. It also handles expired workshop rentals by renewing them before
  # continuing the polishing process.
  #
  # @return [void]
  def polish
    Lich::Messaging.msg("info", "in polish") if @DEBUG
    container = GameObj.inv.find { |box| box.noun =~ /#{@keeper_container}/ }
    container.contents.select { |obj| obj.name =~ /rough|polished/ && obj.noun.include?("-") && (obj.type == 'uncommon' || !obj.type) && container }.each { |item|
      Lich::Messaging.msg("info", "")
      Lich::Messaging.msg("info", "It looks like #{item.name} needs polishing.")
      Lich::Messaging.msg("info", "")
      unless checkroom =~ /Workshop/
        move "go door"
      end
      fput "get ##{item.id} from ##{container.id}"
      fput "swap"
      fput "lean polisher"
      line = waitfor "rent on this workshop has expired", "You give the polishing wheel a shove"
      waitrt?
      if line =~ /rent on this workshop has expired/
        move "out"
        rent
        fput "lean polisher"
        waitfor "You straighten up from working at the polishing wheel"
      elsif line =~ /You give the polishing wheel a shove/
        waitfor "You straighten up from working at the polishing wheel"
      end
      waitrt?
      fput "_drag ##{item.id} ##{container.id}"
    }
    sleep 1
  end

  # Ensures the character is wearing an apron, retrieving it if necessary.
  #
  # This method checks if an apron is present in the character's inventory. If not, it attempts to get
  # and wear the apron using a multi-command. If the apron still isn't found, it calls `get_apron` to
  # retrieve one and retries the wear process.
  #
  # @return [void]
  def wear_apron
    Lich::Messaging.msg("info", "in wear_apron") if @DEBUG
    if !GameObj.inv.find { |i| i.noun == "apron" }
      multifput("get my apron", "wear my apron")
      get_apron unless GameObj.inv.find { |i| i.noun == "apron" }
      multifput("get my apron", "wear my apron") unless GameObj.inv.find { |i| i.noun == "apron" }
    end
  end

  # Retrieves a new apron for forging use.
  #
  # This method stows all currently held items, withdraws 1,000 silver from the bank,
  # and purchases an apron using item order `1`. It assumes this order number corresponds
  # to an apron at the local shop.
  #
  # @return [void]
  def get_apron
    Lich::Messaging.msg("info", "in get_apron") if @DEBUG
    fput "stow all"
    bank(1000)
    buy(1)
  end

  # Performs the grinding step in the forging process and responds to the result.
  #
  # This method handles the grinding phase by turning the grinder and reacting to various system messages.
  # It ensures surge is used if available, manages roundtime, and evaluates the result of the grind. Based on
  # the outcome (e.g., failure, satisfaction, best work), it increments counters, recycles or saves the item,
  # and potentially restarts the glyphing process. It also handles cases where rent has expired or incorrect
  # items are held.
  #
  # @return [void]
  def grind
    Lich::Messaging.msg("info", "in grind") if @DEBUG
    fput "wear forging" if checkright =~ /forging-hammer/
    if Spell[9605].timeleft < 1 and @surge
      use_surge
    end
    waitrt?
    fput "turn grinder"
    line = waitfor "doesn't budge!", "Resignedly", "you need to hold it in your", "satisfied with the piece", "vindictive", "very best"
    waitrt?
    afk_wait if @afk unless line == 'The grinding wheel doesn\'t budge!  Most likely the rent on this workshop has expired.'
    if line =~ /doesn't budge!/
      you_put(@material_noun, @block_container)
      move "out"
      rent
    elsif line =~ /Resignedly, you get/
      @failures += 1
      @reps += 1
      glyph
    elsif line =~ /you need to hold it in your/
      fput "swap"
    elsif line =~ /very best/
      @reps += 1
      if @rank
        trash(checkleft)
      else
        keeper
      end
      if checkright(@material_noun)
        scrap(GameObj.right_hand)
      end
    elsif line =~ /satisfied with the piece/
      @reps += 1
      if @rank
        trash(checkleft)
      else
        average
      end
      if checkright(@material_noun)
        scrap(GameObj.right_hand)
      end
    elsif line =~ /vindictive/
      @reps += 1
      @major_failures += 1
      trash(checkleft)
      if checkright(@material_noun)
        scrap(GameObj.right_hand)
      end
    end
  end

  # Handles storage of a successfully forged item deemed a "keeper."
  #
  # This method marks the item in the left hand (unless unsafe keepers are allowed), increments
  # the keeper counter, and attempts to store the item in the designated keeper container.
  # If no container is set, it logs a warning and exits the script to prevent unintended loss.
  # Finally, it prints forging statistics.
  #
  # @return [void]
  def keeper
    Lich::Messaging.msg("info", "in keeper") if @DEBUG
    fput "mark my #{checkleft}" unless @unsafe_keepers # Don't sell/trash it!
    @keepers += 1
    if @keeper_container
      # announce("Made a best #{checkleft}!") if @@ANNOUNCE
      you_put(checkleft, @keeper_container)
    else
      Lich::Messaging.msg("warn", "No keeper container set!  Aborting...")
      Lich::Messaging.msg("info", "Deal with your keeper, then run ;eforgery setup again to set the keeper container.")
      exit
    end
    print_stats
  end

  # Handles storage of a successfully forged item with average quality.
  #
  # This method increments the success counter and attempts to store the item in the
  # designated average container. If no average container is set, the item is discarded
  # using the `trash` method.
  #
  # @return [void]
  def average
    Lich::Messaging.msg("info", "in average") if @DEBUG
    @successes += 1
    if @average_container
      you_put(checkleft, @average_container)
    else
      trash(checkleft)
    end
    print_stats
  end

  # Disposes of a specified item by trashing it.
  #
  # This method checks whether the character is in the forge and moves to the proper location
  # if necessary before issuing the trash command. It ensures roundtime is clear before acting,
  # and handles different room contexts appropriately.
  #
  # @param item [String] the name or identifier of the item to be trashed
  # @return [void]
  def trash(item)
    Lich::Messaging.msg("info", "in trash(#{item})") if @DEBUG
    waitrt?
    if checkname =~ /Forge/
      move "go door"
      fput "trash my #{item}"
      move "go door"
    else
      fput "trash my #{item}"
    end
  end

  # Attempts to store a scrap item, sell it, or discard it based on container capacity and value.
  #
  # This method tries to place the given item into the designated scrap container. If the container is full,
  # it proceeds to the pawnshop to sell the item. If the item is deemed worthless, it is trashed or dropped.
  # If no scrap container is defined, the item is discarded using the `trash` method.
  # Handles container open/close states, room transitions, and ensures the forging loop can continue afterward.
  #
  # @param item [GameObj] the item object to be scrapped, sold, or discarded
  # @return [void]
  def scrap(item)
    Lich::Messaging.msg("info", "in scrap(#{item})") if @DEBUG
    if @scrap_container
      closed = false
      donescrapping = false
      until donescrapping == true
        line = nil
        fput "put ##{item.id} in #{@scrap_container}"
        line = waitfor "You put", "You tuck", "It's closed", "won't fit"
        if line =~ /fit/
          fput "look in my #{@scrap_container}"
          unless checkroom =~ /Workshop/
            move "go door"
          end
          move "out"
          Script.run("go2", "pawnshop")
          fput "sell ##{item.id}"
          line = waitfor "then hands you", "basically worthless here", "hands it back to you"
          if line =~ /then hands you/
            box = GameObj.inv.find { |container| container.noun =~ /#{@scrap_container}/ }
            box.contents.select { |obj| obj.name =~ /#{@material_name} slab/ }.each { |obj| multifput "get ##{obj.id}", "sell ##{obj.id}" }

            donescrapping = true
            Script.run("go2", "forge")
            rent
          elsif line =~ /worthless|hands it back to you/
            fput "trash ##{item.id}" # try to trash it, otherwise drop it
            fput "drop ##{item.id}" if (GameObj.left_hand.id == item.id || GameObj.right_hand.id == item.id)
            Lich::Messaging.msg("info", "*")
            Lich::Messaging.msg("info", "* Scrap was worthless, so it was trashed or dropped.")
            Lich::Messaging.msg("info", "*")
            # exit  ## TODO:  Why exit here?  Seems we can just keep running after this, it's not a breaking error.
          end
        elsif line =~ /closed/
          closed = true
          fput "open my #{@scrap_container}"
        elsif line =~ /You put/ || line =~ /You tuck/
          donescrapping = true
        end
      end
      fput "close #{@scrap_container}" if closed
    else
      trash(item)
    end
  end

  # Performs cleanup tasks at the end of a forging session.
  #
  # This method salvages any remaining oil in the forge if the character is in the forge room,
  # and then prints forging statistics. It's typically called before exiting or resetting the script.
  #
  # @return [void]
  def breakdown
    Lich::Messaging.msg("info", "in breakdown") if @DEBUG
    salvage_oil if checkroom =~ /Forge\]/
    print_stats
  end

  # Displays a summary of the current forging session's statistics.
  #
  # This method logs counts for best pieces, average pieces, minor failures, and major failures.
  # It provides an overview of the forging session's performance, and is typically called at the end
  # of a session or after a key event like item completion or script shutdown.
  #
  # @return [void]
  def print_stats
    Lich::Messaging.msg("info", "in print_stats") if @DEBUG
    Lich::Messaging.msg("warn", "#{Script.self} session stats:")
    Lich::Messaging.msg("info", "  Best pieces:    #{@keepers}")
    Lich::Messaging.msg("info", "  Average pieces: #{@successes}")
    Lich::Messaging.msg("info", "  Minor failures: #{@failures}")
    Lich::Messaging.msg("info", "  Major failures: #{@major_failures}")
    Lich::Messaging.msg("info", "") if !@rank && (@keepers + @successes + @failures + @major_failures > 0)
  end

  # Displays usage instructions and setup guidance for the forging script.
  #
  # This method outputs a comprehensive guide to the scripts configuration options and commands,
  # including how to set containers, materials, glyphs, and operational modes. It includes
  # backward-compatible XML encoding for older versions of Lich (< 5.11), and provides helpful notes
  # for proper setup and usage to avoid common pitfalls.
  #
  # @return [void]
  def usage
    Lich::Messaging.msg("info", "in usage") if @DEBUG

    #
    # Dear future coder,
    # Lich didn't encode XML through Messaging.mono in the past, so we had to add .xml_encode manually.
    # At the time of this writing, this has been resolved, so we can just use Lich::Messaging.mono
    # without .xml_encode in the future, but I left it here for backwards compatibility right now.
    # After lich 5.11 has been out for a while and is very common, the extra encoding can be removed.
    # if you remove it, please leave the comment below for future coders.
    #
    # DEBUG Hint:  If Lich::Messaging.xml_encode is not included below, older version of lich (pre 5.11) will not display the messages correctly.

    Lich::Messaging.mono("")
    Lich::Messaging.mono(Lich::Messaging.xml_encode("#{Script.self} SETUP:"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set average <container>   <= container for average pieces  (will TRASH them if left blank) "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set oil <container>       <= container for tempering oil                                   "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set keepers <container>   <= container for keepers (perfect pieces)                        "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set slabs <container>     <= container for raw slabs                             (REQUIRED)"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set blocks <container>    <= container for the measured and cut slab blocks      (REQUIRED)"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set scraps <container>    <= container for material scraps  (will TRASH them if left blank)"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set glyph <name> <container> <#> <material> <=e.g.[blade-glyph backpack 14 wax] (SEE NOTE*)"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set material <material> <noun> <order #>    <=e.g.[steel slab 4][maoral block 3] (REQUIRED)"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set make_hammers <true/false>  <= make forging hammer-heads/handles with workshop glyphs   "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set surge <true/false>        <= toggles use of Cman Surge of Strength for relevant steps  "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set squelch <true/false>  <= squelches screen scroll for forging actions                   "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set debug <true/false>    <= will turn on debug messages (useful for troubleshooting)      "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} set <name>                <= will clear that setting                                       "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} display                   <= display the current Settings                                  "))

    Lich::Messaging.mono("")
    Lich::Messaging.mono(Lich::Messaging.xml_encode("IMPORTANT NOTES ABOUT SETUP:"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  Block, Slab, Scrap, Keeper containers MUST be different.                                             "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  If keeping 'Average' pieces, container should be different from 'Keeper' container.                  "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  Do NOT use commas in when entering Settings for glyph and material                                   "))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  *To use your own glyphs (e.g. Maul/Lance), do NOT set order # or material. e.g.[blade-glyph backpack]"))
    Lich::Messaging.mono("")
    Lich::Messaging.mono(Lich::Messaging.xml_encode("#{Script.self} USAGE"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self}                  <= Begin forging and polishing best pieces"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} setup            <= Will open a gui to setup your options"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} cut <size> <#>   <= cuts as many of # size as it can from one slab"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} keepers <#>      <= stop when # of keepers have been forged"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} forge [#]        <= does the forge routine [optionally, # times]"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} polish           <= polishes rough hilt/blade pieces found in your containers"))
    Lich::Messaging.mono(Lich::Messaging.xml_encode("  #{$clean_lich_char}#{Script.self} rank             <= Forge away to rank up, DOES NOT KEEP ANY BEST PIECES"))
    Lich::Messaging.mono("")
  end
end

# Main entry point and command dispatcher for the forging script.
#
# This case block interprets command-line arguments (`script.vars`) passed to the script and routes them
# to the appropriate behavior. It supports a wide range of commands, including:
#
# - `"afk"`: Enables AFK mode with a configurable delay and loops forging and polishing.
# - `"rank"`: Runs the forging process without keeping best pieces, optionally in AFK mode.
# - `"forge"`: Executes the forging routine either a set number of times or continuously.
# - `"polish"`: Polishes items stored in the keeper container.
# - `"cut"`: Cuts slabs into specified sizes and quantities.
# - `"keepers"`: Forges until a defined number of keeper items are made.
# - `"display"`: Shows the current settings stored in `CharSettings`.
# - `"set"`: Updates individual configuration settings based on user input.
# - `"setup"` and `"settings"`: Invokes the GUI-based setup routine.
#
# If no recognized command is provided, the script defaults to showing usage instructions.
#
# @return [void]
Lich::Messaging.msg("info", "#{Script.self} started.") if @DEBUG
case script.vars[1].downcase
when nil, 'afk'
  if script.vars[1].downcase == 'afk'
    forger.afk = true
    forger.afk_count = script.vars[2].to_i > 0 ? script.vars[2].to_i : 2
  end
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    Script.run("go2", "forge")
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  forger.prepare
  fput "look in my #{@average_container}" if @average_container
  fput "look in my #{@keeper_container}" if @keeper_container
  fput "inventory"
  loop {
    forger.forge
    forger.polish
  }
when 'rank'
  forger.rank = true
  if script.vars[2].downcase == 'afk'
    forger.afk = true
    forger.afk_count = script.vars[3].to_i > 0 ? script.vars[3].to_i : 2
  end
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    Script.run("go2", "forge")
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  forger.prepare
  fput "look in my #{@average_container}" if @average_container
  fput "look in my #{@keeper_container}" if @keeper_container
  fput "inventory"
  loop {
    forger.forge
  }
when "forge"
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    Script.run("go2", "forge")
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  forger.prepare
  fput "look in my #{@average_container}" if @average_container
  fput "look in my #{@keeper_container}" if @keeper_container
  fput "inventory"
  if script.vars[2].to_i
    script.vars[2].to_i.times {
      forger.forge
    }
  else
    loop {
      forger.forge
    }
  end
when "polish"
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    Script.run("go2", "forge")
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  fput "look in my #{@average_container}" if @average_container
  fput "look in my #{@keeper_container}" if @keeper_container
  fput "inventory"
  forger.rent
  forger.polish
when "cut"
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    Script.run("go2", "forge")
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  fput "inventory"
  forger.cut(script.vars[2].to_i, script.vars[3].to_i)
when "keepers"
  unless CharSettings["keeper_container"]
    Lich::Messaging.msg("error", "You must first set a keeper container.")
    exit
  end
  fput "look in my #{@average_container}" if @average_container
  fput "look in my #{@keeper_container}" if @keeper_container
  fput "inventory"
  waitrt?
  if checkroom !~ /(Forge|Workshop)\]/
    Script.run("go2", "forge")
  elsif checkroom =~ /Forge\]/
    move 'go door'
  end
  forger.setup
  forger.prepare
  while forger.keepers < script.vars[2].to_i
    forger.forge
    forger.polish
  end
when "display"
  Lich::Messaging.mono(Lich::Messaging.xml_encode("Current Forger Settings:"))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("average             =>  #{CharSettings["average_container"]}   "))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("oil                 =>  #{CharSettings["oil_container"]}       "))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("keepers             =>  #{CharSettings["keeper_container"]}    "))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("slabs               =>  #{CharSettings["slab_container"]}      "))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("blocks  (slab cuts) =>  #{CharSettings["block_container"]}     "))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("scraps              =>  #{CharSettings["scrap_container"]}     "))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("glyph (name, container, order #, order material)  =>  #{CharSettings["glyph_name"]} #{CharSettings["glyph_container"]} #{CharSettings["glyph_no"]} #{CharSettings["glyph_material"]}  "))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("material  (material type, material noun, order #) =>  #{CharSettings["material_name"]} #{CharSettings["material_noun"]} #{CharSettings["material_no"]}  "))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("make_hammers        =>  #{CharSettings["make_hammers"]}        "))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("surge               =>  #{CharSettings["surge"]}               "))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("squelch             =>  #{CharSettings["squelch"]}             "))
  Lich::Messaging.mono("")
  Lich::Messaging.mono(Lich::Messaging.xml_encode("IMPORTANT:"))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("   #{$clean_lich_char}#{Script.self} set <setting> <whatever>    for details type  #{$clean_lich_char}#{Script.self} help"))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("   Keepers, slabs, blocks, and scraps container must be different, but only the first 3 are required."))
  Lich::Messaging.mono(Lich::Messaging.xml_encode("   Leaving the average and scrap CharSettings blank will cause those things to be thrown away!   "))
  Lich::Messaging.mono("")
when "set"
  case script.vars[2]
  when "average"
    CharSettings["average_container"] = script.vars[3]
    Lich::Messaging.msg("info", "Settings saved!")
  when "keepers"
    CharSettings["keeper_container"] = script.vars[3]
    Lich::Messaging.msg("info", "Settings saved!")
  when "blocks"
    CharSettings["block_container"] = script.vars[3]
    Lich::Messaging.msg("info", "Settings saved!")
  when "oil"
    CharSettings["oil_container"] = script.vars[3]
    Lich::Messaging.msg("info", "Settings saved!")
  when "slabs"
    CharSettings["slab_container"] = script.vars[3]
    Lich::Messaging.msg("info", "Settings saved!")
  when "material"
    CharSettings["material_name"] = script.vars[3]
    CharSettings["material_noun"] = script.vars[4]
    CharSettings["material_no"] = script.vars[5]
    Lich::Messaging.msg("info", "Settings saved!")
  when "glyph"
    CharSettings["glyph_name"] = script.vars[3]
    CharSettings["glyph_container"] = script.vars[4]
    CharSettings["glyph_no"] = script.vars[5]
    CharSettings["glyph_material"] = script.vars[6]
    Lich::Messaging.msg("info", "Settings saved!")
  when "make_hammers"
    CharSettings["make_hammers"] = script.vars[3]
    Lich::Messaging.msg("info", "Settings saved!")
  when "scraps"
    CharSettings["scrap_container"] = script.vars[3]
    Lich::Messaging.msg("info", "Settings saved!")
  when "surge"
    CharSettings["surge"] = script.vars[3]
    Lich::Messaging.msg("info", "Settings saved!")
  when "squelch"
    CharSettings["squelch"] = script.vars[3]
    Lich::Messaging.msg("info", "Settings saved!")
  when "debug"
    CharSettings["debug"] = script.vars[3]
    Lich::Messaging.msg("info", "Settings saved!")
  else
    forger.usage
  end
when "setup"
  setup.call
when "settings"
  setup.call
else
  forger.usage
end
