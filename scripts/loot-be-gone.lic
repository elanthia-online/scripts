=begin

  This script gets rid of your loot.

  gives heirlooms to a guard
  gives bounty herbs to herbalist if the id's of the herbs are in the array $bounty_herbs
  opens boxes (off by default)
  bunldes herbs (off by default)
  gives gold rings to the chronomage
  stockpiles gems into jars in your locker (off by default)
  gets gems from the stockpile for bounties (only if you have enough to complete the bounty)
  saves scrolls that have spells you choose (list is empty by default)
  appraise various types of items that you choose, and saves them if they're expensive
  might possibly avoid selling gems and skins that you have a bounty for in the wrong town
  sells stuff
  deposits monies

  ;loot-be-gone help

    author: Tillmen (tillmen@lichproject.org)
      game: Gemstone
      tags: loot
   version: 0.15
  required: Lich >= 4.6.14

  changelog:
    0.15 (2020-10-10):
      fix for commas in silver check
    0.14 (2019-05-11):
      improve regexes (austin-j)
    0.13 (2018-09-04):
      don't sell bounty gems in Sylvarrend

=end
=begin

    0.12 (2018-08-30):
      don't show trusted script warning on Ruby >= 2.3
    0.11 (2017-09-23):
      herb bundling function now works when the herbsack is also a lootsack
      combine equivalent healing potions from different towns
    0.10 (2016-09-17):
      unhide before selling a container if invisible
    0.9 (2015-12-10):
      update bounty regex
    0.8 (2015-10-13):
      try to load gameobj-data.xml if it's not already loaded
    0.7 (2015-03-23):
      check silvers without prettynum script messing it up
      use Vars[] instead of UserVars.send
      start on GUI setup (not functional)
    0.6 (2014-12-01):
      bug fix when opening lootsacks
      allow lootsacks and herbsack to be set using the script instead of ;vars or ;settings
    0.5 (2014-11-09):
      only remove and sell lootsacks if there are more than two items to sell in them
    0.4 (2014-10-07):
      Fix bug when depositing notes
    0.3 (2014-10-05):
      typo
    0.2 (2014-10-05):
      added stow-herbs option (for people with autobundle herb bags)
      added option to fetch arbitrary stockpiled gems
      sell container at gemshop and furrier if it doesn't have excluded items
      empty a hand before depositing notes

=end

# fixme: large/small gold nuggets don't go in the same jar
# fixme: locker times out and object ids become invalid

if GameObj.type_data.empty? or GameObj.type_data.nil?
  GameObj.load_data
  if GameObj.type_data.empty? or GameObj.type_data.nil?
    echo 'error: gameobj data is missing; you may need to download gameobj-data.xml'
    exit
  end
end

if ($SAFE == 0) and (RUBY_VERSION =~ /^2\.[012]\./)
  echo "warning: this script is trusted, but it doesn't need to be"
end

silence_me unless $loot_be_gone_debug

withdraw_amount = 8000
save_value = { 'gemshop' => 15000, 'pawnshop' => 35000 }

put_regex = /^You (?:attempt to shield .*? from view as you |discreetly |carefully |absent-mindedly )?(?:put|place|slip|tuck|add|hang|drop|untie your|find an incomplete bundle|wipe off .*? and sheathe)|^A sigh of grateful pleasure can be heard as you feed .*? to your|^As you place|^I could not find what you were referring to\.$|^Your bundle would be too large|^The .+ is too large to be bundled\.|^As you place your|^The .*? is already a bundle|^Your .*? won't fit in .*?\.$|^You can't .+ It's closed!$|^You need a free hand to pick that up\.|^Do you want to put that in or on/
get_regex = /^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly )?(?:remove|draw|grab|reach|slip|tuck|retrieve|already have|unsheathe|pick up)|^Get what\?$|^Why don't you leave some for others\?$|^You need a free hand|^I could not find what you were referring to\./

$loot_be_gone_ignore ||= Array.new
need_close_lootsack    = Array.new

save_herb_list = { 'some torban leaf' => 1, 'some basal moss' => 1, 'some acantha leaf' => 1, 'some cactacae spine' => 1, 'some aloeas stem' => 1, 'some haphip root' => 1, 'some pothinir grass' => 1, 'some ephlox moss' => 1, 'some calamia fruit' => 1, 'some sovyn clove' => 1, 'some wolifrew lichen' => 1, 'some woth flower' => 1, 'some ambrominas leaf' => 3 }
save_potion_list = { 'rose-marrow potion' => 2, 'brostheras potion' => 2, 'wingstem potion' => 2, 'talneo potion' => 2, 'bolmara potion' => 2, 'white flask' => 1, 'bur-clover potion' => 1 }
equivalent_potions = [
  [ 'rose-marrow potion', 'crystalline rose-marrow elixir', 'tincture of rose-marrow', 'elk horn potion', 'some feverfew tea', 'rusty red ale', "flagon of Semak's Smooth ale", "barrel of Semak's Smooth ale" ],
  [ 'tiny cup of polar bear fat soup', 'brostheras potion', 'crystalline brostheras elixir', 'tincture of brostheras', 'pennyroyal potion', 'stone soot brew', "flagon of Reaper's Red ale", "barrel of Reaper's Red ale" ],
  [ 'wingstem potion', 'crystalline wingstem elixir', 'tincture of wingstem', 'earthworm potion', 'wyrmwood root potion', 'dirty crevice brew', "flagon of Wort's Winter ale", "barrel of Wort's Winter ale" ],
  [ 'rock lizard potion', 'talneo potion', 'crystalline talneo elixir', 'tincture of talneo', 'wyrmwood root tea', 'brown weedroot ale', "flagon of Gert's Homemade ale", "barrel of Gert's Homemade ale" ],
  [ 'snowflake elixir', 'bolmara potion', 'crystalline bolmara elixir', 'tincture of bolmara', 'red lichen potion', 'glowing mold tea', "flagon of Kenar's Dropjaw ale", "barrel of Kenar's Dropjaw ale" ],
  [ 'bur-clover potion', 'crystalline bur-clover elixir', 'tincture of bur-clover', 'starfish potion', 'daggit root potion', 'dirty rat fur potion', "flagon of Volcano Vision ale", "barrel of Volcano Vision ale" ],
]

herbalist_rooms = [ 3824, 1851, 10396, 640, 5722, 2406 ] # fixme: use tags

CharSettings['keep scrolls'] = Array.new unless CharSettings['keep scrolls'].class == Array
CharSettings['exclude types'] = 'weapon|armor|scroll|cursed' if CharSettings['exclude types'].nil?
CharSettings['appraise types'] = 'jewelry|weapon|armor|uncommon' if CharSettings['appraise types'].nil?
CharSettings['chronomage'] = true if CharSettings['chronomage'].nil?
notes = Array.new

if (Char.name == 'Tillmen') and (XMLData.game == 'GSIV')
  # fixme: make this a setting so other people can use it
  hoarding_jars = [
    { :name => 'a glossy black glass jar',   :gem => 'tiny black pearl', :count => 13, :min_value => 3000, :max_value => 3099 },
    { :name => 'a glossy white glass jar',   :gem => 'tiny white pearl', :count => 13, :min_value => 3000, :max_value => 3099 },
    { :name => 'a dingy grey glass jar',     :gem => 'tiny grey pearl',  :count => 13, :min_value => 3000, :max_value => 3099 },
    { :name => 'a pale pink glass jar',      :gem => 'tiny pink pearl',  :count => 13, :min_value => 2000 },
    { :name => 'a tall glass jar',           :gem => 'uncut diamond',    :count => 13 },
    { :name => 'a matte black glass bottle', :gem => 'black opal',       :count => 13 },
#   { :name => 'a burnt ochre glass bottle', :gem => 'dragonfire opal',  :count => 20 },
#   { :name => 'a bright scarlet glass jar', :gem => 'moonglae opal',    :count => 20 },
  ]
else
  hoarding_jars = Array.new
end

if script.vars[1] =~ /^stockpile=(on|off|yes|no|true|false|forget)$/
  if $1 == 'forget'
    CharSettings[:jars] = nil
    echo 'stockpile tracking cleared'
  else
    fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
    CharSettings['stockpile'] = fix_option[$1]
    echo 'setting saved'
  end
  exit
elsif script.vars[0] =~ /^lootsack([0-9]+)?=(.+)$/
  num = $1
  name = $2
  if name == 'nil'
    if num
      Vars["lootsack#{num}"] = nil
    else
      Vars.lootsack = nil
    end
    echo 'setting cleared'
  else
    obj_list = GameObj.inv.find_all { |obj| obj.noun == name }
    if obj_list.empty?
      obj_list = GameObj.inv.find_all { |obj| obj.name == name }
    end
    if obj_list.empty?
      obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(name)}$/i }
    end
    if obj_list.empty?
      obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{name.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
    end
    if obj_list.empty?
      echo "error: failed to find a container in your inventory by the name of \"#{name}\""
    elsif obj_list.length > 1
      echo "error: multiple containers in your inventory match the name \"#{name}\""
    else
      if num
        Vars["lootsack#{num}"] = name
      else
        Vars.lootsack = name
      end
      echo 'setting saved'
    end
  end
  exit
elsif script.vars[1] =~ /^herbsack=(.+)$/
  name = $1
  for x in 2..100
    if script.vars[x]
      name.concat " #{script.vars[x]}"
    else
      break
    end
  end
  if name == 'nil'
    Vars.herbsack = nil
    echo 'setting cleared'
  else
    obj_list = GameObj.inv.find_all { |obj| obj.noun == name }
    if obj_list.empty?
      obj_list = GameObj.inv.find_all { |obj| obj.name == name }
    end
    if obj_list.empty?
      obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(name)}$/i }
    end
    if obj_list.empty?
      obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{name.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
    end
    if obj_list.empty?
      echo "error: failed to find a container in your inventory by the name of \"#{name}\""
    elsif obj_list.length > 1
      echo "error: multiple containers in your inventory match the name \"#{name}\""
    else
      Vars.herbsack = name
      echo 'setting saved'
    end
  end
  exit
elsif script.vars[1] =~ /^locker=([0-9]+|nil)$/
  if $1 == 'nil'
    CharSettings['locker'] = nil
  else
    CharSettings['locker'] = $1
  end
  echo 'setting saved'
  exit
elsif script.vars[1] =~ /^open(?:\-boxes)?=(on|off|yes|no|true|false)$/
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  CharSettings['open boxes'] = fix_option[$1]
  echo 'setting saved'
  exit
elsif script.vars[1] =~ /^bundle(?:\-herbs)?=(on|off|yes|no|true|false)$/
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  CharSettings['bundle herbs'] = fix_option[$1]
  echo 'setting saved'
  exit
elsif script.vars[1] =~ /^stow(?:\-herbs)?=(on|off|yes|no|true|false)$/
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  CharSettings['stow-herbs'] = fix_option[$1]
  echo 'setting saved'
  exit
elsif script.vars[1] =~ /^chronomage=(on|off|yes|no|true|false)$/
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  CharSettings['chronomage'] = fix_option[$1]
  echo 'setting saved'
  exit
elsif script.vars[1] =~ /^open\-cheap\-plinites=(on|off|yes|no|true|false)$/
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  CharSettings['open-cheap-plinites'] = fix_option[$1]
  echo 'setting saved'
  exit
elsif script.vars[1] =~ /^trash(?:\-herbs)?=(on|off|yes|no|true|false)$/
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  CharSettings['trash herbs'] = fix_option[$1]
  echo 'setting saved'
  exit
elsif script.vars[1] =~ /^(?:herb\-)?drop(?:\-room)?=(.+)$/
  if $1 == 'nil'
    CharSettings['herb drop room'] = nil
  else
    CharSettings['herb drop room'] = $1
  end
  echo 'setting saved'
  exit
elsif script.vars[0] =~ /^exclude-names=(.+)$/
  var = $1
  if var == 'nil'
    CharSettings['exclude regex'] = false
  else
    begin
      Regexp.new(var)
    rescue
      echo "error: #{$!}"
      echo 'ignoring setting'
      exit
    end
    CharSettings['exclude regex'] = var
  end
  echo 'setting saved'
  exit
elsif script.vars[0] =~ /^exclude\-types=(.+)$/
  var = $1
  if var == 'nil'
    CharSettings['exclude types'] = false
  else
    begin
      Regexp.new(var)
    rescue
      echo "error: #{$!}"
      echo 'ignoring setting'
      exit
    end
    CharSettings['exclude types'] = var
  end
  echo 'setting saved'
  exit
elsif script.vars[0] =~ /^appraise\-types=(.+)$/
  var = $1
  if var == 'nil'
    CharSettings['appraise types'] = false
  else
    begin
      Regexp.new(var)
    rescue
      echo "error: #{$!}"
      echo 'ignoring setting'
      exit
    end
    CharSettings['appraise types'] = var
  end
  echo 'setting saved'
  exit
elsif script.vars[1] =~ /^(?:keep\-)?scrolls=(.+)$/
  option = $1
  if option.downcase == 'nil'
    CharSettings['keep scrolls'] = Array.new
    echo 'setting saved'
  elsif option =~ /^[0-9,]+$/
    CharSettings['keep scrolls'] = option.split(',').collect { |num| num.to_i }
    echo 'setting saved'
  else
    echo "You're doing it wrong."
  end
  exit
elsif script.vars[1] =~ /list/
  if script.vars[2] =~ /stockpile/
    output = "                           gem count  full\n"
    output.concat "                           --- -----  ----\n"
    for jar in CharSettings[:jars].sort { |a,b| b[:count] <=> a[:count] }
      output.concat "#{jar[:gem].rjust(30)} #{jar[:count].to_s.rjust(2)} #{jar[:full].to_s.rjust(8)}\n"
    end
    respond output
  else
    fix_option = { true => 'on', false => 'off', nil => 'off' }
    output = "\n"
    output.concat "          stockpile: #{fix_option[CharSettings['stockpile']]}\n"
    output.concat "             locker: #{CharSettings['locker'] || 'nil'}\n"
    output.concat "         open-boxes: #{fix_option[CharSettings['open boxes']]}\n"
    if CharSettings['keep scrolls'].empty?
      output.concat "       keep-scrolls: (none)\n"
    else
      output.concat "       keep-scrolls: #{CharSettings['keep scrolls'].join(',')}\n"
    end
    output.concat "       bundle-herbs: #{fix_option[CharSettings['bundle herbs']]}\n"
    output.concat "         stow-herbs: #{fix_option[CharSettings['stow-herbs']]}\n"
    output.concat "        trash-herbs: #{fix_option[CharSettings['trash herbs']]}\n"
    output.concat "         chronomage: #{fix_option[CharSettings['chronomage']]}\n"
    output.concat "open-cheap-plinites: #{fix_option[CharSettings['open-cheap-plinites']]}\n"
    output.concat "     herb-drop-room: #{CharSettings['herb drop room'] || '(none)'}\n"
    output.concat "\n"
    output.concat "      exclude-names: #{CharSettings['exclude regex'] || '(none)'}\n"
    output.concat "\n"
    output.concat "      exclude-types: #{CharSettings['exclude types'] || '(none)'}\n"
    output.concat "\n"
    output.concat "     appraise-types: #{CharSettings['appraise types'] || '(none)'}\n"
    output.concat "\n"
    output.concat "           lootsack: #{Vars.lootsack || '(none)'}\n"
    lootsack_num = 2
    while (Vars["lootsack#{lootsack_num}"].class == String) and not Vars["lootsack#{lootsack_num}"].empty?
      output.concat "          lootsack#{lootsack_num}: #{Vars["lootsack#{lootsack_num}"]}\n"
      lootsack_num += 1
    end
    output.concat "\n"
    respond output
  end
  exit
elsif script.vars[1] =~ /get/i
  nil
elsif script.vars[1] == 'setup'
  echo "gui setup does not yet work"
  settings = CharSettings.to_hash
  window = nil
  done = false
  hook_proc = proc { |s|
    if s =~ /^You are wearing|^I could not find|^You see nothing/
      nil
    else
      s
    end
  }
  DownstreamHook.add('loot-be-gone-container-search', hook_proc)
  begin
    script.want_downstream = false
    script.want_downstream_xml = true
    result = dothistimeout 'inventory containers', 5, /^You are wearing/
    script.want_downstream_xml = false
    script.want_downstream = true
    container_ids = result.scan(/exist="(.*?)"/).flatten
    containers = GameObj.inv.find_all { |obj| container_ids.include?(obj.id) }
    container_usable_names = Array.new
    containers.each { |c|
      words = c.name.sub(/^some /, '').split(' ')
      ni = words.index(c.noun)
      adjs = words[0...ni]
      if adjs.length == 0
        container_usable_names.push(c.noun)
      elsif adjs.length == 1
        container_usable_names.push("#{adjs[0]} #{c.noun}")
      else
        for adj in adjs
          result = dothistimeout "look my #{adj} #{c.noun}", 5, /^You see|^I could not find/
          if result =~ /^You see/
            container_usable_names.push("#{adj} #{c.noun}")
            break
          end
        end
      end
    }
  ensure
    DownstreamHook.remove('loot-be-gone-container-search')
  end
# container_usable_names = [ 'leather cloak', 'grey tunic', 'burlap sack' ]
  Gtk.queue {
    container_label = Gtk::Label.new.set_markup('<big><b>Get loot from these containers</b></big>')
    container_label_box = Gtk::Box.new(:horizontal)
    container_label_box.pack_start(container_label, :expand => false, :fill => false, :padding => 0)

    lootsack1_label = Gtk::Label.new('lootsack')
    lootsack1_label_box = Gtk::Box.new(:horizontal)
    lootsack1_label_box.pack_end(lootsack1_label, :expand => false, :fill => false, :padding => 0)
    lootsack1_entry = Gtk::ComboBoxText.new(:entry => true)
    if Vars.lootsack.class == String
      lootsack1_entry.child.text = Vars.lootsack
    end
    lootsack1_color = nil
    lootsack1_entry.child.signal_connect('changed') { |w|
      report_errors {
        if w.text.empty?
          unless lootsack1_color == :grey
            w.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('#dddddd'))
            lootsack1_color = :grey
          end
        else
          obj_list = GameObj.inv.find_all { |obj| obj.noun == w.text }
          if obj_list.empty?
            obj_list = GameObj.inv.find_all { |obj| obj.name == w.text }
          end
          if obj_list.empty?
            obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(w.text)}$/i }
          end
          if obj_list.empty?
            obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{w.text.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
          end
          if obj_list.empty? or (obj_list.length > 1)
            unless lootsack1_color == :red
              w.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('#ffbbbb'))
              lootsack1_color = :red
            end
          else
            unless lootsack1_color == :white
              w.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('#ffffff'))
              lootsack1_color == :white
            end
          end
        end
      }
    }
    lootsack1_entry.child.signal_emit('changed')
    container_usable_names.each { |n| lootsack1_entry.append_text(n) }

    container_table = Gtk::Table.new(2, 2)
    container_table.attach(lootsack1_label_box, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 3, 3)
    container_table.attach(lootsack1_entry, 1, 2, 0, 1, (Gtk::EXPAND|Gtk::FILL), Gtk::FILL, 3, 3)

    extra_lootsacks = Array.new

    add_new_lootsack = proc {
      h = Hash.new
      h[:label] = Gtk::Label.new("lootsack#{extra_lootsacks.length+2}")
      h[:label_box] = Gtk::Box.new(:horizontal)
      h[:label_box].pack_end(h[:label], :expand => false, :fill => false, :padding => 0)
      h[:entry] = Gtk::ComboBoxText.new(:entry => true)
      if Vars["lootsack#{extra_lootsacks.length+2}"].class == String
        h[:entry].child.text = Vars["lootsack#{extra_lootsacks.length+2}"]
      end
      container_usable_names.each { |n| h[:entry].append_text(n) }
      container_table.attach(h[:label_box], 0, 1, (extra_lootsacks.length+1), (extra_lootsacks.length+2), Gtk::FILL, Gtk::FILL, 3, 3)
      container_table.attach(h[:entry], 1, 2, (extra_lootsacks.length+1), (extra_lootsacks.length+2), (Gtk::EXPAND|Gtk::FILL), Gtk::FILL, 3, 3)
      h[:entry].child.signal_connect('changed') { |w|
        report_errors {
          if extra_lootsacks[-1][:entry].child == w
            add_new_lootsack.call
          end
          if w.text.empty?
            w.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('#dddddd'))
          else
            obj_list = GameObj.inv.find_all { |obj| obj.noun == w.text }
            if obj_list.empty?
              obj_list = GameObj.inv.find_all { |obj| obj.name == w.text }
            end
            if obj_list.empty?
              obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(w.text)}$/i }
            end
            if obj_list.empty?
              obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{w.text.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
            end
            if obj_list.empty? or (obj_list.length > 1)
              w.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('#ffbbbb'))
            else
              w.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('#ffffff'))
            end
          end
        }
      }
      h[:entry].child.signal_emit('changed')
      container_table.show_all
      extra_lootsacks.push(h)
    }

    for num in 2..100
      add_new_lootsack.call
      break unless Vars["lootsack#{num}"].class == String
    end

    exclude_types_label = Gtk::Label.new.set_markup("<big><b>Don't sell these types of items</b></big>")
    exclude_types_label_box = Gtk::Box.new(:horizontal)
    exclude_types_label_box.pack_start(exclude_types_label, :expand => false, :fill => false, :padding => 0)

    exclude_cbs = Hash.new
    exclude_types_table = Gtk::Table.new(1, 5)
    num = 0
    GameObj.type_data.keys.each { |type|
      next if type =~ /^(alchemy equipment|ammo|herb|junk|undead|bandit|lm tool|note|food|quest|jar|passive npc|grimswarm|aggressive npc|escort|lm trap)$/
      row = num / 5
      col = num % 5
      cb = Gtk::CheckButton.new(type)
      cb.active = ((type =~ /#{settings['exclude types']}/) ? true : false)
      exclude_cbs[type] = cb
      exclude_types_table.attach(cb, col, (col+1), row, (row+1), Gtk::FILL, Gtk::FILL, 3, 3)
      num += 1
    }

    appraise_types_label = Gtk::Label.new.set_markup("<big><b>Appraise these types of items</b></big>")
    appraise_types_label_box = Gtk::Box.new(:horizontal)
    appraise_types_label_box.pack_start(appraise_types_label, :expand => false, :fill => false, :padding => 0)

    appraise_cbs = Hash.new
    appraise_types_table = Gtk::Table.new(1, 5)
    num = 0
    GameObj.type_data.keys.each { |type|
      next if type =~ /^(alchemy equipment|ammo|herb|junk|undead|bandit|lm tool|note|food|quest|jar|passive npc|grimswarm|aggressive npc|escort|lm trap)$/
      row = num / 5
      col = num % 5
      cb = Gtk::CheckButton.new(type)
      cb.active = ((type =~ /#{settings['appraise types']}/) ? true : false)
      appraise_cbs[type] = cb
      appraise_types_table.attach(cb, col, (col+1), row, (row+1), Gtk::FILL, Gtk::FILL, 3, 3)
      num += 1
    }

    appraise_types_label2 = Gtk::Label.new(" ...and sell them if they appraise for less than 15k (gemshop) or 35k (pawnshop)")
    appraise_types_label2_box = Gtk::Box.new(:horizontal)
    appraise_types_label2_box.pack_start(appraise_types_label2, :expand => false, :fill => false, :padding => 0)

    exclude_names_label = Gtk::Label.new.set_markup("<big><b>Don't sell items with these names</b></big>")
    exclude_names_label_box = Gtk::Box.new(:horizontal)
    exclude_names_label_box.pack_start(exclude_names_label, :expand => false, :fill => false, :padding => 0)


    herbsack_label = Gtk::Label.new('herbsack')
    herbsack_label_box = Gtk::Box.new(:horizontal)
    herbsack_label_box.pack_end(herbsack_label, :expand => false, :fill => false, :padding => 0)
    herbsack_entry = Gtk::ComboBoxText.new(:entry => true)
    if Vars.herbsack.class == String
      herbsack_entry.child.text = Vars.herbsack
    end
    herbsack_entry.child.signal_connect('changed') { |w|
      report_errors {
        if w.text.empty?
          w.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('#dddddd'))
        else
          obj_list = GameObj.inv.find_all { |obj| obj.noun == w.text }
          if obj_list.empty?
            obj_list = GameObj.inv.find_all { |obj| obj.name == w.text }
          end
          if obj_list.empty?
            obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(w.text)}$/i }
          end
          if obj_list.empty?
            obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{w.text.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
          end
          if obj_list.empty? or (obj_list.length > 1)
            w.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('#ffbbbb'))
          else
            w.modify_base(Gtk::STATE_NORMAL, Gdk::Color.parse('#ffffff'))
          end
        end
      }
    }
    herbsack_entry.child.signal_emit('changed')
    container_usable_names.each { |n| herbsack_entry.append_text(n) }
#   container_table.attach(herbsack_label_box, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 3, 3)
#   container_table.attach(herbsack_entry, 1, 2, 1, 2, (Gtk::EXPAND|Gtk::FILL), Gtk::FILL, 3, 3)


    stockpile_cbtn = Gtk::CheckButton.new('Stockpile gems in jars in locker')
    stockpile_cbtn.active = (settings['stockpile'] ? true : false)

    bundle_herbs_cbtn = Gtk::CheckButton.new('Bundle herbs')
    bundle_herbs_cbtn.active = (settings['bundle herbs'] ? true : false)

    stow_herbs_cbtn = Gtk::CheckButton.new('Stow herbs')
    stow_herbs_cbtn.active = (settings['stow-herbs'] ? true : false)

    trash_herbs_cbtn = Gtk::CheckButton.new('Throw away herbs found in boxes')
    trash_herbs_cbtn.active = (settings['trash herbs'] ? true : false)

    chronomage_cbtn = Gtk::CheckButton.new('Give gold rings to a chronomage')
    chronomage_cbtn.active = (settings['chronomage'] ? true : false)

    box = Gtk::Box.new(:vertical)
    box.pack_start(container_label_box, :expand => false, :fill => false, :padding => 8)
    box.pack_start(container_table, :expand => false, :fill => false, :padding => 1)
    box.pack_start(exclude_types_label_box, :expand => false, :fill => false, :padding => 8)
    box.pack_start(exclude_types_table, :expand => false, :fill => false, :padding => 1)
    box.pack_start(appraise_types_label_box, :expand => false, :fill => false, :padding => 8)
    box.pack_start(appraise_types_table, :expand => false, :fill => false, :padding => 1)
    box.pack_start(appraise_types_label2_box, :expand => false, :fill => false, :padding => 8)
    box.pack_start(exclude_names_label_box, :expand => false, :fill => false, :padding => 8)
    box.pack_start(stockpile_cbtn, :expand => false, :fill => false, :padding => 1)
    box.pack_start(bundle_herbs_cbtn, :expand => false, :fill => false, :padding => 1)
    box.pack_start(stow_herbs_cbtn, :expand => false, :fill => false, :padding => 1)
    box.pack_start(trash_herbs_cbtn, :expand => false, :fill => false, :padding => 1)
    box.pack_start(chronomage_cbtn, :expand => false, :fill => false, :padding => 1)

    vp = Gtk::Viewport.new(nil, nil)
    vp.add(box)

    sw = Gtk::ScrolledWindow.new
    sw.set_policy(:automatic, :always)
    sw.add(vp)

    window = Gtk::Window.new
    window.title = "Lich - #{Char.name}'s loot-be-gone"
    window.add(sw)
    window.signal_connect('delete_event') {
      report_errors {
        done = true
      }
    }
    window.set_default_size(700,800) #fixme - get back to dynamic screen sizing ability
    window.set_window_position(Gtk::Window::POS_CENTER)
    window.show_all
  }
  begin
    wait_until { done }
  ensure
    Gtk.queue { window.destroy }
  end
  exit
elsif not script.vars[1].nil?
  output = "\n"
  output.concat "   #{$clean_lich_char}#{script.name} list                           Shows current settings.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} list stockpile                 Shows stockpile contents.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} stockpile=<on|off>             Stockpile gems in jars in your locker, and retrieve and sell them\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                when you have a gem bounty.\n"
  output.concat "   #{$clean_lich_char}#{script.name} locker=<room number>           Room number of the room with a curtain or opening to get to your locker.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} stockpile=forget               Clears the tracking info for the jars in your locker.  Needed\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                if you manually add or remove gems or jars from your locker.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} get <#> <gem name>             Retrieve gems from the stockpile.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} open-boxes=<on|off>            Uses the town npc locksmith to open boxes before selling.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} keep-scrolls=nil               Sell scrolls without reading them.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} keep-scrolls=<#,#,#>           Read scrolls and save them only if they have a spell that's in the\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                given comma separated list. (Use exclude-types to save all scrolls.)\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} bundle-herbs=<on|off>          Bundles herbs commonly found in the loot system with those\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                found in your herbsack.  Keeps only one full bundle or two\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                full potions of each type, and drops the rest.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} stow-herbs=<on|off>            Stow herbs commonly found in the loot system in your herbsack\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                without bundling them"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} trash-herbs=<on|off>           Throw away herbs found in boxes\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} herb-drop-room=<room number>   Sets the room where extra herbs will be dropped.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} herb-drop-room=<varname>       If <varname> is \"rest_room\", the script will look up the drop\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                room from rest_room as shown in the ;vars command.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} herb-drop-room=nil             Clears the setting.  Extra herbs will be dropped where ever you\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                happen to be standing (could be the room the script was started\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                in, the locksmith, the herbalist, or the town guard)\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} chronomage=<on|off>            Give gold rings to the chronomage.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} types=<regex>                  Only sell items whose type matches the given regex. (does not\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                stop items marked as new loot from being sold or dropped)\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} exclude-names=<regex>          Any item names matching the given regex will not be sold.\n"
  output.concat "   #{$clean_lich_char}#{script.name} exclude-names=nil              Clears the setting.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} exclude-types=<regex>          Any item type matching the given regex will not be sold.\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                Meaningful types will change as gameobj-data.xml changes, but\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                here's a random list: gem, skin, reagent, jewelry, magic, uncommon,\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                herb, food, weapon, armor, clothing, alchemy product, cursed\n"
  output.concat "   #{$clean_lich_char}#{script.name} exclude-types=nil              Clears the setting.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} appraise-types=<regex>         Any item type matching the given regex will be appraised first,\n"
  output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                and saved if it's expensive.\n"
  output.concat "   #{$clean_lich_char}#{script.name} appriase-types=nil             Clears the setting.\n"
  output.concat "\n"
  output.concat "   #{$clean_lich_char}#{script.name} lootsack=<container>\n"
  output.concat "   #{$clean_lich_char}#{script.name} lootsack2=<container>\n"
  output.concat "   #{$clean_lich_char}#{script.name} lootsack<num>=<container>\n"
  output.concat "   #{$clean_lich_char}#{script.name} herbsack=<container>\n"
  output.concat "\n"
  respond output
  exit
end

lootsack_list = Array.new
lootsack_num = nil
while (Vars["lootsack#{lootsack_num}"].class == String) and not Vars["lootsack#{lootsack_num}"].empty?
  if lootsack = (GameObj.inv.find { |obj| obj.noun == Vars["lootsack#{lootsack_num}"] } || GameObj.inv.find { |obj| obj.name == Vars["lootsack#{lootsack_num}"] } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(Vars["lootsack#{lootsack_num}"])}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Vars["lootsack#{lootsack_num}"].split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i })
    lootsack_list.push(lootsack)
  else
    echo "warning: failed to find lootsack#{lootsack_num} (#{Vars["lootsack#{lootsack_num}"]})"
  end
  lootsack_num = 1 if lootsack_num.nil?
  lootsack_num += 1
end
if lootsack_list.empty?
  echo 'error: no lootsacks found'
  exit
end

for lootsack in lootsack_list
  if lootsack.contents.nil?
    open_result = dothistimeout "open ##{lootsack.id}", 5, /^You open|^That is already open\.$/
    if open_result =~ /^You open/
      need_close_lootsack.push(lootsack.id)
    else
      dothistimeout "look in ##{lootsack.id}", 5, /In .*? you see/
      if lootsack.contents.nil?
        echo 'error: failed to find lootsack contents'
        exit
      end
    end
  end
end

lootsack_put = proc { |obj|
  if obj.class == GameObj
    cmd = "_drag ##{obj.id}"
  elsif obj =~ /^[0-9]+$/
    cmd = "_drag ##{obj}"
  else
    cmd = "put #{obj} in"
  end
  for lootsack in lootsack_list
    result = dothistimeout "#{cmd} ##{lootsack.id}", 5, put_regex
    break unless result =~ /won't fit/
  end
}

if CharSettings['bundle herbs'] or CharSettings['stow-herbs']
  if Vars.herbsack.nil? or Vars.herbsack.empty?
    echo "herbsack is not set. (;#{script.name} herbsack=<container name>)"
    exit
  end
  unless herbsack = (GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(Vars.herbsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(Vars.herbsack).sub(' ', ' .*')}$/i })
    echo 'error: failed to find your herbsack'
    exit
  end
end

check_silvers = proc {
  hook_proc = proc { |server_string|
    if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
      nil
    elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9,]+)/
      DownstreamHook.remove('go2_check_silvers')
      nil
    else
      server_string
    end
  }
  clear
  DownstreamHook.add('go2_check_silvers', hook_proc)
  silence_me unless undo_silence = silence_me
  put 'info'
  silence_me if undo_silence
   start = Time.now
  while (line = get)
    if line =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9,]+)/
      silvers = $1.gsub(',','').to_i
      break
      elsif (Time.now - start) > 15
         silvers = 0
         break
    end
  end
  silvers
}

need_to_open_boxes = proc {
  need = true
  unless (GameObj.right_hand.type =~ /box/) or (GameObj.left_hand.type =~ /box/) or lootsack_list.any? { |lootsack| lootsack.contents.find { |obj| obj.type =~ /box/ } }
    unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
      if reget.any? { |line| line =~ /^Your disk arrives, following you dutifully\.\r?$/ }
        50.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk$/ }; sleep 0.1 }
        disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
      end
    end
    if disk and disk.contents.nil?
      dothistimeout "look in ##{disk.id}", 5, /^In the|^There is nothing in there\.$/
    end
    unless disk.contents.any? { |obj| obj.type =~ /box/ }
      need = false
    end
  end
  need
}

table = activator = trash = nil
open_box = proc { |box|
  unless (GameObj.right_hand.id == box.id) or (GameObj.left_hand.id == box.id)
    dothistimeout "get ##{box.id}", 5, get_regex
  end
  if (GameObj.right_hand.id == box.id) or (GameObj.left_hand.id == box.id)
    fput 'unhide' if invisible?
    activator_result = dothistimeout activator, 5, /^You .*? the .*? but .*? ignores you|I'm afraid that you can't pull that.|^You .*? the .*?, and ask .*?/
    if activator_result =~ /^You .*? the .*? but .*? ignores you/
      dothistimeout "drop ##{box.id}", 5, /flickers in and out of existence|^You drop/
      dothistimeout "get ##{box.id}", 5, /^You already|^You pick up/
      activator_result = dothistimeout activator, 5, /^You .*? the .*? but .*? ignores you|I'm afraid that you can't pull that.|^You .*? the .*?, and ask .*?/
    end
    if activator_result =~ /^You .*? the .*?, and ask .*?|^You .*? the .*? but .*? ignores you/
      if activator_result =~ /^You .*? the .*? but .*? ignores you/
        pay_result = 'accepts your silvers'
      else
        pay_result = dothistimeout 'pay', 5, /^But you don't have enough!|accepts your silvers/
      end
      if pay_result =~ /accepts your silvers/
        open_result = dothistimeout "open ##{box.id}", 5, /^You open|^That is already open\.|^It appears to be locked\./
        if open_result =~ /^You open|^That is already open\./
          get_result = dothistimeout "get coins from ##{box.id}", 5, /^You gather the remaining|^Get what\?/
          unless get_result =~ /^You gather the remaining/
            echo 'fixme (9)'
          end
          waitrt?
          drop_box = false
          for obj in box.contents
            if obj.type =~ /cursed/
              drop_box = true
              next
            elsif (obj.type =~ /junk|food/) or (CharSettings['trash herbs'] and obj.type =~ /herb/)
              if trash
                dothistimeout "get ##{obj.id}", 5, /^You/
                dothistimeout "put ##{obj.id} in ##{trash.id}", 5, /^You put|^As you place/
              else
                dothistimeout "_drag ##{obj.id} drop", 5, /^You drop/
              end
            elsif (obj.type =~ /herb/) and CharSettings['stow-herbs']
              if herbsack.contents.nil?
                open_result = dothistimeout "open ##{herbsack.id}", 5, /^You open|^That is already open\.$/
                if open_result =~ /^You open/
                  close_herbsack = true
                end
              end
              dothistimeout "_drag ##{obj.id} ##{herbsack.id}", 5, put_regex
            else
              lootsack_put.call(obj)
            end
          end
          if drop_box
            dothistimeout "drop ##{box.id}", 5, /^You drop/
          else
            unless box.contents.empty?
              echo 'error: box is not empty'
              lootsack_put.call(box)
            end
            if trash
              dothistimeout "put ##{box.id} in ##{trash.id}", 5, /^You put|^As you place/
            else
              dothistimeout "drop ##{box.id}", 5, /^You drop/
            end
          end
          sleep 0.1
        elsif open_result =~ /^It appears to be locked\./
          echo 'fixme (2382)'
        else
          echo 'fixme (8)'
        end
      elsif pay_result =~ /^But you don't have enough!/
        Script.run('go2', 'bank --disable-confirm')
        fput "withdraw #{withdraw_amount} silvers"
        Script.run('go2', 'locksmith --disable-confirm')
        open_box.call(box)
      else
        echo 'fixme (6)'
      end
    else
      echo 'fixme (5)'
    end
  else
    echo 'fixme (3)'
  end
  dothistimeout "close ##{herbsack.id}", 5, /^You close|^That is already closed\.$/ if close_herbsack
}

to_locker = proc {
  silvers = check_silvers.call
  if silvers < 526
    Script.run('go2', 'bank --disable-confirm')
    fput 'unhide' if invisible?
    fput "withdraw #{526 - silvers}"
  end
  Script.run('go2', CharSettings['locker'])
  if way_in = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
    move "go #{way_in.noun}"
  else
    false
  end
}

from_locker = proc {
  if way_out = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
    move "go #{way_out.noun}"
  end
}

gem_in_jar_regex = proc { |gem|
  # fixme
  if gem =~ /pearl$/
    /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/
  else
    /^#{gem.sub(/some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/
  end

}

need_to_stockpile = proc {
  can_start_new_jar = (CharSettings[:empty_jar_count] > 0) && lootsack_list.any? { |lootsack| lootsack.contents.any? { |obj| (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not CharSettings[:jars].any? { |jar| jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/ } } }
  can_add_to_jar = CharSettings[:jars].any? { |jar|
    !jar[:full] && lootsack_list.any? { |lootsack|
      lootsack.contents.any? { |obj|
        jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/
      }
    }
  }
  CharSettings[:jars].nil? || can_start_new_jar || can_add_to_jar
}

stockpile = proc {
  status_tags
  open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
  status_tags
  if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
    locker_id = $1
    locker_contents = GameObj.containers[locker_id]
    unless locker_contents
      dothistimeout "look in ##{locker_id}", 5, /^In the/
      locker_contents = GameObj.containers[locker_id]
    end
    if locker_contents
      if CharSettings[:jars].nil?
        CharSettings[:jars] = Array.new
        CharSettings[:empty_jar_count] = 0
        locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ }.each { |jar|
          if jar.after_name.nil?
            CharSettings[:empty_jar_count] = CharSettings[:empty_jar_count] + 1
          else
            look_result = dothistimeout "look in ##{jar.id} from ##{locker_id}", 5, /^Inside .*? you see [0-9]+ portion/
            if look_result =~ /^Inside .*? you see ([0-9]+) portion/
              count = $1.to_i
              gem = jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '')
              full = look_result.include?('It is full')
              CharSettings[:jars].push(h={ :gem => gem, :count => count, :full => full })
            end
          end
        }
      end
      empty_hands
      not_suitable = Array.new
      for jar in locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|beaker|bottle)$/ }
        if jar.after_name =~ /^containing /
          gem_list = Array.new
          lootsack_list.each { |lootsack| gem_list.concat(lootsack.contents.find_all { |obj| (jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/) }) }
          gem_list.delete_if { |obj| not_suitable.include?(obj.id) }
          jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') }
          unless gem_list.empty? or jar_hash[:full]
            dothistimeout "get ##{jar.id} from ##{locker_id}", 5, /^You remove/
            for gem in gem_list
              result = dothistimeout "_drag ##{gem.id} ##{jar.id}", 5, /^You add|is full|does not appear to be a suitable container for/
              if result =~ /^You add .* filling it/
                jar_hash[:count] = jar_hash[:count] + 1
                jar_hash[:full] = true
              elsif result =~ /^You add/
                jar_hash[:count] = jar_hash[:count] + 1
              elsif result =~ /is full/
                jar_hash[:full] = true
                lootsack_put.call(gem)
                break
              elsif result =~ /does not appear to be a suitable container for/
                not_suitable.push(gem.id)
                lootsack_put.call(gem)
              else
                lootsack_put.call(gem)
              end
            end
            dothistimeout "put ##{jar.id} in ##{locker_id}", 5, /^You (?:put|place)/
          end
        else
          gem_count = Hash.new
          lootsack_list.each { |lootsack|
            lootsack.contents.each { |obj|
              if (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not locker_contents.any? { |o| o.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/ and not not_suitable.include?(obj.id) }
                gem_count[obj.name.gsub(/large |medium |small |tiny |some /, '')] = gem_count[obj.name.gsub(/large |medium |small |tiny |some /, '')].to_i + 1
              end
            }
          }
          next if gem_count.empty?
          gem_name = nil
          gem_num = 0
          gem_count.each_pair { |name,num|
            if num > gem_num
              gem_name = name
              gem_num = num
            end
          }
          dothistimeout "get ##{jar.id} from ##{locker_id}", 5, /^You remove/
          jar_hash = nil
          lootsack_list.each { |lootsack|
            lootsack.contents.each { |obj|
              if obj.name.gsub(/large |medium |small |tiny |some /, '') == gem_name
                result = dothistimeout "_drag ##{obj.id} ##{jar.id}", 5, /^You (?:add|put)|is full|does not appear to be a suitable container for/
                if result =~ /^You put/
                  dothistimeout "put ##{jar.id} in ##{lootsack.id}", 5, put_regex
                  gem = lootsack.contents.find { |obj| obj.id == jar.id }.after_name.gsub(/^containing |large |medium |small |tiny |some /, '')
                  dothistimeout "get ##{jar.id}", 5, get_regex
                  jar_hash = { :gem => gem, :count => 1, :full => false }
                  CharSettings[:jars].push(jar_hash)
                elsif result =~ /^You add/
                  jar_hash[:count] = jar_hash[:count] + 1
                elsif result =~ /is full/
                  dothistimeout "put ##{obj.id} in ##{lootsack.id}", 5, put_regex
                  jar_hash[:full] = true
                  break
                elsif result =~ /does not appear to be a suitable container for/
                  not_suitable.push(obj.id)
                  dothistimeout "put ##{obj.id} in ##{lootsack.id}", 5, put_regex
                end
              end
            }
          }
          dothistimeout "put ##{jar.id} in ##{locker_id}", 5, /^You (?:put|place)/
        end
      end
      dothistimeout "close locker", 5, /^You close|^That is already closed\.$/
      fill_hands
    else
      dothistimeout "close locker", 5, /^You close|^That is already closed\.$/
      echo 'error: failed to find locker contents'
    end
  else
    dothistimeout "close locker", 5, /^You close|^That is already closed\.$/
    echo 'error: failed to find locker'
  end
}

need_to_raid_stockpile = proc {
  if checkbounty =~ /gem dealer.* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
    gem = $1
    count = $2.to_i
    if checkbounty =~ /(Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor)/
      target_town = $1
      gemshop = Room[Room[CharSettings['locker']].find_nearest_by_tag('gemshop')]
      if gemshop.location and (gemshop.location =~ /Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor/) and ((gemshop.location !~ /#{target_town}/) or gemshop.title.include?('Shimmarglin Jewels and Gems'))
        false
      else
        CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
      end
    else
      CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
    end
  else
    false
  end
}

raid_stockpile = proc { |gem,count|
  gem.gsub!(/large |medium |small |tiny |some /, '')
  status_tags
  open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
  status_tags
  if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
    locker_id = $1
    locker_contents = GameObj.containers[locker_id]
    unless locker_contents
      dothistimeout "look in ##{locker_id}", 5, /^In the/
      locker_contents = GameObj.containers[locker_id]
    end
    if locker_contents
      if CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
        if jar = locker_contents.find { |jar| jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/ }
          jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.sub(/^containing |large |medium |small |tiny |some /, '') }
          empty_hands
          dothistimeout "get ##{jar.id} from ##{locker_id}", 5, /^You remove/
          count.times {
            dothistimeout "shake ##{jar.id}", 5, /^You .*shake/
            if GameObj.right_hand.id != jar.id
              obj = GameObj.right_hand
            elsif GameObj.left_hand.id != jar.id
              obj = GameObj.left_hand
            end
            lootsack_put.call(obj)
            jar_hash[:count] = jar_hash[:count] - 1
            jar_hash[:full] = false
          }
          dothistimeout "put ##{jar.id} in ##{locker_id}", 5, /^You (?:put|place)/
          if jar_hash[:count] < 1
            CharSettings[:jars].delete(jar_hash)
            CharSettings[:empty] = CharSettings[:empty] + 1
          end
          fill_hands
          dothistimeout "close locker", 5, /^You close|^That is already closed\.$/
          true
        else
          dothistimeout "close locker", 5, /^You close|^That is already closed\.$/
          false
        end
      else
        dothistimeout "close locker", 5, /^You close|^That is already closed\.$/
        false
      end
    else
      dothistimeout "close locker", 5, /^You close|^That is already closed\.$/
      echo 'error: failed to find locker contents'
      false
    end
  else
    dothistimeout "close locker", 5, /^You close|^That is already closed\.$/
    echo 'error: failed to find locker'
    false
  end
  true
}

stow_notes = proc {
  if GameObj.right_hand.noun =~ /^(?:note|scrip|chit)$/
    notes.push(GameObj.right_hand.id) unless notes.include?(GameObj.right_hand.id)
    lootsack_put.call(GameObj.right_hand)
  end
  if GameObj.left_hand.noun =~ /^(?:note|scrip|chit)$/
    notes.push(GameObj.left_hand.id) unless notes.include?(GameObj.left_hand.id)
    lootsack_put.call(GameObj.left_hand)
  end
}

undo_trading_bonus = proc { |val|
  bonus = (Skills.to_bonus(Skills.trading) + Stats.inf[1])/12
  if (bonus < 1) or (Skills.trading <= bonus)
    bonus = 0
  end
  location = Room.current.location
  if location =~ /between Wehnimer's Landing and Zul Logoth/
    if Char.race == 'Dark Elf'
      bonus -= 25
    end
  elisf location =~ /Wehnimer's Landing/
    if Char.race =~ /^(?:Dark Elf|Forest Gnome)$/
      bonus -= 5
    elsif Char.race == 'Half-krolvin'
      bonus -= 25
    end
  elsif location =~ /Kharam-Dzu/
    if Char.race == 'Dark Elf'
      bonus -= 25
    elsif Char.race =~ /^(?:Elf|Sylvankind)$/
      bonus -= 15
    elsif Char.race =~ /^(Half-elf|Burghal Gnome|Half-krolvin|Aeoltoi)$/
      bonus -= 5
    elsif Char.race == 'Dwarf'
      bonus += 5
    end
  elsif location =~ /Icemule Trace|Pinefar Trading Post/
    if Char.race =~ /^(?:Dark Elf|Burghal Gnome)$/
      bonus -= 5
    elsif Char.race == 'Halfling'
      bonus += 5
    end
  elsif location =~ /Cysaegir/
    if Char.race == 'Half-krolvin'
      bonus -= 15
    elsif Char.race =~ /^(?:Human|Dwarf|Giantman|Halfling|Half-elf|Burghal Gnome|Forest Gnome|Erithian)$/
      bonus -= 5
    elsif Char.race == 'Aelotoi'
      bonus += 5
    end
  elsif location =~ /Solhaven/
    if Char.race == 'Dark Elf'
      bonus -= 25
    elsif Char.race == 'Sylvankind'
      bonus -= 15
    elsif Char.race =~ /^(?:Half-elf|Burghal Gnome)$/
      bonus -= 5
    elsif Char.race == 'Human'
      bonus += 5
    end
  elsif location =~ /Northern Caravansary/
    if Char.race =~ /^(?:Dark Elf|Burghal Gnome)$/
      bonus -= 5
    end
  elsif location =~ /Zul Logoth/
    if Char.race =~ /^(?:Elf|Dark Elf|Sylvankind)$/
      bonus -= 15
    elsif Char.race =~ /^(?:Half-elf|Burghal Gnome|Half-krolvin|Aelotoi)$/
      bonus -= 5
    elsif Char.race == 'Dwarf'
      bonus += 5
    end
  elsif location =~ /Zhindel's Post/
    if Char.race =~ /^(?:Dark Elf|Sylvankind)$/
      bonus -= 15
    elsif Char.race == 'Dwarf'
      bonus += 5
    end
  elsif location =~ /Ta'Illistim|Ta'Vaalor/
    if Char.race == 'Dark Elf'
      bonus -= 25
    elsif Char.race =~ /^(?:Dwarf|Half-elf|Half-krolvin)$/
      bonus -= 15
    elsif Char.race == 'Human'
      bonus -= 10
    elsif Char.race =~ /^(?:Giantman|Halfling|Burghal Gnome|Forest Gnome|Erithian|Aelotoi)$/
      bonus -= 5
    elsif Char.race == 'Elf'
      bonus += 5
    end
  elsif location =~ /River's Rest/
    if Char.race =~ /^(?:Dark Elf|Half-krolvin)$/
      bonus -= 15
    elsif Char.race == 'Elf'
      bonus -= 10
    elsif Char.race =~ /^(?:Half-elf|Sylvankind|Erithian|Aelotoi)$/
      bonus -= 5
    elsif Char.race == 'Human'
      bonus += 5
    end
# elsif location =~ /the Isle of Four Winds/
    # no bonus or penalty
  end
  if bonus == 0
    val
  else
    (val*(1/((bonus/100.0)+1))).ceil
  end
}

did_something = false
if script.vars[1] =~ /get/i
  if CharSettings['locker'].nil?
    echo 'error: locker room is not set'
    exit
  end

  count = script.vars[2].to_i
  gem = script.vars[3..-1].join(" ")

  unless count > 0
    echo "You seem to have requested 0 gems.  My work here is done."
    exit
  end

  unless CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
    echo "Can't find #{count} gems by the name \"#{gem}\" in your stockpile."
    exit
  end

  if to_locker.call
    raid_stockpile.call(gem, count)
    from_locker.call
  end
  exit
end

if bounty? =~ /You have located the heirloom/
  did_something = true
  Script.run('go2', 'advguard --disable-confirm')
  unless (guard = GameObj.npcs.find { |npc| npc.noun.downcase =~ /^(?:guard|vontrilaias|syllardeth|arnlis|dukash|simlasyth|gaelthar|sergeant|guardsman)$/ }) or (checkroom == "[River's Rest, Purser's Office]")
    Script.run('go2', 'advguard2 --disable-confirm')
    guard = GameObj.npcs.find { |npc| npc.noun.downcase =~ /^(?:guard|vontrilaias|syllardeth|arnlis|dukash|simlasyth|gaelthar|sergeant|guardsman)$/ }
  end
  if guard or (checkroom == "[River's Rest, Purser's Office]")
    for lootsack in lootsack_list
      for item in lootsack.contents
        look_result = dothistimeout "look ##{item.id}", 5, /^Engraved .* initials|^You see nothing unusual\.$|^The ring appears|^It takes you a moment|^It is difficult to see/
        if look_result =~ /^Engraved .* initials/
          fput 'unhide' if invisible?
          empty_hands
          fput "get ##{item.id}"
          if guard
            result = dothistimeout "give ##{guard.id}", 5, /I shall inform the Adventurer's Guild that you successfully completed your task|The guard is in no condition to receive your offer!/
            if result =~ /The guard is in no condition to receive your offer!/
              fput "put ##{item.id} in ##{lootsack.id}"
            end
          else
            fput "give purser"
          end
          fill_hands
          break
        end
      end
    end
  end
end

$bounty_herbs ||= Array.new
unless $bounty_herbs.empty?
  did_something = true
  target = Room.current.find_nearest(herbalist_rooms)
  Script.run('go2', target.to_s)
  empty_hands
  for herb_id in $bounty_herbs
    fput "get ##{herb_id}"
    if herb = [ GameObj.right_hand, GameObj.left_hand ].find { |obj| obj.id == herb_id }
      fput 'unhide' if invisible?
      fput "give #{GameObj.npcs.last.noun}"
      25.times { break unless checkright; sleep 0.1 }
      lootsack_put.call(herb) if checkright
    end
  end
  fill_hands
  $bounty_herbs.clear
end

if CharSettings['open boxes'] and need_to_open_boxes.call
  did_something = true
  silvers = check_silvers.call
  if silvers < withdraw_amount
    Script.run('go2', 'bank --disable-confirm')
    fput 'unhide' if invisible?
    fput "withdraw #{withdraw_amount - silvers} silvers"
  end
  Script.run('go2', 'locksmith --disable-confirm')
  unless trash = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /^(?:crate|barrel|wastebarrel|casket)$/ } || trash = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun == 'coffer' }
    echo 'warning: failed to find a trash container'
  end
  if table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /^(?:table|counter)$/ }
    if table.contents.nil?
      dothistimeout "look on ##{table.id}", 5, /On the .*? you see/
      if not table.contents.nil?
        activator = nil
        if table.contents.any? { |obj| obj.noun == 'bell' }
          activator = 'ring bell'
        elsif table.contents.any? { |obj| obj.noun == 'keys' }
          activator = 'pull keys'
        elsif table.contents.any? { |obj| obj.noun == 'chime' } or GameObj.loot.any? { |obj| obj.noun == 'chime' }
          activator = 'ring chime'
        end
        if activator
          #max_wait = Time.now + 120
          #after = table.contents.collect { |obj| obj.id }
          #while checkpcs
          # before = after.dup
          # 100.times {
          #   sleep 0.2
          #   break unless checkpcs
          #   after = table.contents.collect { |obj| obj.id }
          #   break if before != after
          # }
          # break if (before == after) or (Time.now > max_wait)
          #end
          empty_hands
          for lootsack in lootsack_list
            for obj in lootsack.contents
              if obj.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
                open_box.call(obj)
              end
            end
          end
          unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
            if reget.any? { |line| line =~ /^Your disk arrives, following you dutifully\./ }
              50.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk$/ }; sleep 0.1 }
              disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
            end
          end
          if disk
            if GameObj.loot.any? { |obj| obj.id == disk.id }
              if disk.contents.nil?
                dothistimeout "look in ##{disk.id}", 5, /^In the|^There is nothing in there\.$/
              end
              for obj in disk.contents
                if obj.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
                  open_box.call(obj)
                end
              end
              $disk_full = false
            end
          end
          dothistimeout "drop ##{GameObj.right_hand.id}", 5, /^You drop/ if GameObj.right_hand.type =~ /box/
          dothistimeout "drop ##{GameObj.left_hand.id}", 5, /^You drop/ if GameObj.left_hand.type =~ /box/
          fill_hands
          dothistimeout "drop ##{GameObj.right_hand.id}", 5, /^You drop/ if GameObj.right_hand.type =~ /box/
          dothistimeout "drop ##{GameObj.left_hand.id}", 5, /^You drop/ if GameObj.left_hand.type =~ /box/
        else
          echo 'error: failed to find a bell, keys, or chime on the table'
        end
      else
        echo 'error: failed to find table contents'
      end
    end
  else
    echo 'error: failed to find a table'
  end
end

need_bundle_herbs = false

if CharSettings['bundle herbs']
  sack_list = lootsack_list.dup
  sack_list.push(herbsack) unless sack_list.include?(herbsack)
  if lootsack_list.any? { |lootsack| (lootsack != herbsack) and lootsack.contents.any? { |o| save_herb_list.keys.include?(o.name) or save_potion_list.keys.include?(o.name) } } or [save_herb_list, save_potion_list].any? { |list| list.any? { |thing,count| total = 0; sack_list.each { |sack| sack.contents.each { |o| total += 1 if o.name == thing or (equivalent_potions.include?(thing) and equivalent_potions.include?(o.name)) } }; total > count } }
    did_something = true
    if CharSettings['herb drop room'].nil?
      herb_drop_room = nil
    elsif CharSettings['herb drop room'] =~ /^[0-9]+$/
      herb_drop_room = CharSettings['herb drop room'].to_i
    elsif (Vars[CharSettings['herb drop room']].class == Fixnum) or (Vars[CharSettings['herb drop room']] =~ /^[0-9]+$/)
      herb_drop_room = Vars[CharSettings['herb drop room']].to_i
    else
      echo 'warning: bad herb-drop-room setting'
      herb_drop_room = nil
    end
    check_drop_room = proc {
      unless herb_drop_room.nil? or Room.current.id == herb_drop_room
        Script.run('go2', herb_drop_room.to_s)
      end
    }
    if herbsack.contents.nil?
      open_result = dothistimeout "open ##{herbsack.id}", 5, /^You open|^That is already open\.$/
      if open_result =~ /^You open/
        close_herbsack = true
      else
        dothistimeout "look in ##{herbsack.id}", 5, /In .*? you see/
      end
    end
    unless herbsack.contents.nil?
      empty_hands
      for herb_name,save_count in save_herb_list
        save_herbs = Array.new; save_count.times { if h = herbsack.contents.find { |o| o.name == herb_name and not save_herbs.include?(o) }; save_herbs.push(h); end }
        extra_herbs = Array.new; sack_list.each { |sack| sack.contents.each { |o| extra_herbs.push(o) if o.name == herb_name and not save_herbs.include?(o) } }
        move_herbs = Array.new
        while (save_herbs.length < save_count) and not extra_herbs.empty?
          herb = extra_herbs.shift
          save_herbs.push(herb)
          move_herbs.push(herb) unless herbsack.contents.include?(herb)
        end
        if extra_herbs.empty?
          move_herbs.each { |herb| dothistimeout("_drag ##{herb.id} ##{herbsack.id}", 3, put_regex) }
          next
        end
        drop_herb = false
        save_herb = save_herbs.shift
        dothistimeout "get ##{save_herb.id}", 5, get_regex
        move_herbs.delete(save_herb)
        while extra_herb = extra_herbs.shift
          dothistimeout "get ##{extra_herb.id}", 5, get_regex
          if drop_herb
            check_drop_room.call
            dothistimeout "drop ##{extra_herb.id}", 3, /^You drop/
          else
            while checkleft and checkright
              bundle_result = dothistimeout 'bundle', 3, /^Carefully, you combine|^If you add anything more to this bundle|^You do not have anything to bundle!$/
              if bundle_result =~ /^If you add anything more to this bundle/
                if save_herbs.empty?
                  drop_herb = true
                  dothistimeout "eat ##{extra_herb.id}", 3, /^You take a bite/
                else
                  dothistimeout "_drag ##{save_herb.id} ##{herbsack.id}", 5, put_regex
                  save_herb = save_herbs.shift
                  dothistimeout "get ##{save_herb.id}", 5, get_regex
                  move_herbs.delete(save_herb)
                end
              elsif bundle_result.nil?
                break
              end
            end
          end
        end
        dothistimeout "put ##{GameObj.right_hand.id} in ##{herbsack.id}", 3, put_regex if checkright
        dothistimeout "put ##{GameObj.left_hand.id} in ##{herbsack.id}", 3, put_regex if checkleft
        move_herbs.each { |herb| dothistimeout("_drag ##{herb.id} ##{herbsack.id}", 3, put_regex) }
      end
      for potion_name,save_count in save_potion_list
        potion_names = (equivalent_potions.find { |l| l.include?(potion_name) } || [potion_name])
        save_potions = Array.new; potion_names.each { |name| while save_potions.length < save_count; if h = herbsack.contents.find { |o| o.name == name and not save_potions.include?(o) }; save_potions.push(h); else; break; end; end } # prefer names the come first in the list, because not all potions weigh the same
        extra_potions = Array.new; sack_list.each { |sack| sack.contents.each { |o| extra_potions.push(o) if potion_names.include?(o.name) and not save_potions.include?(o) } }
        while (save_potions.length < save_count) and not extra_potions.empty?
          potion = extra_potions.shift
          save_potions.push(potion)
          dothistimeout "_drag ##{potion.id} ##{herbsack.id}", 3, put_regex
        end
        if extra_potions.empty?
          next
        end
        drop_potion = false
        save_potion = save_potions.shift
        while extra_potion = extra_potions.shift
          dothistimeout "get ##{extra_potion.id}", 5, get_regex
          if drop_potion
            check_drop_room.call
            dothistimeout "drop ##{extra_potion.id}", 3, /^You drop/
          else
            loop {
              pour_result = dothistimeout "pour ##{extra_potion.id} in ##{save_potion.id}", 3, /^You carefully pour|^You can't pour any more|^I can't find that\.$|^You can't pour that\.$/
              if (pour_result =~ /^You can't pour any more/) and not save_potions.empty?
                save_potion = save_potions.shift
              elsif pour_result !~ /^You carefully pour/
                break
              end
            }
            if (GameObj.right_hand.id == extra_potion.id) or (GameObj.left_hand.id == extra_potion.id)
              drop_potion = true
              check_drop_room.call
              dothistimeout "drop ##{extra_potion.id}", 3, /^You drop/
            end
          end
        end
        dothistimeout "put ##{GameObj.right_hand.id} in ##{herbsack.id}", 3, put_regex if checkright
        dothistimeout "put ##{GameObj.left_hand.id} in ##{herbsack.id}", 3, put_regex if checkleft
      end
      fill_hands
    else
      echo 'error: failed to find herbsack contents'
    end
    dothistimeout "close ##{herbsack.id}", 3, /^You close|^That is already closed\.$/ if close_herbsack
  end
end

if CharSettings['chronomage'] and XMLData.game =~ /^(?:GSF|GSIV)$/
  ring_list = Array.new
  for lootsack in lootsack_list
    ring_list.concat(lootsack.contents.to_a.find_all { |obj| obj.name =~ /gold ring$/ })
  end
  unless ring_list.empty?
    did_something = true
    Script.run('go2', 'chronomage --disable-confirm')
    empty_hand
    if npc = GameObj.npcs.last
      for ring in ring_list
        fput "get ##{ring.id}"
        fput 'unhide' if invisible?
        fput "give ##{ring.id} to #{npc.noun}"
        sleep 0.3
        lootsack_put.call(ring) if (GameObj.right_hand.id == ring.id) or (GameObj.left_hand.id == ring.id)
      end
    end
    fill_hand
  end
end

if CharSettings['stockpile'] and CharSettings['locker'].nil?
  echo 'warning: stockpiling is turned on but locker room is not set'
end

if checkbounty =~ /gem dealer.* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
  bounty_gem_name = $1
  bounty_gem_count = $2.to_i
end

if CharSettings['stockpile'] and CharSettings['locker'] and (need_to_stockpile.call or need_to_raid_stockpile.call)
  did_something = true
  if to_locker.call
    stockpile.call if need_to_stockpile.call
    raid_stockpile.call(bounty_gem_name, bounty_gem_count) if need_to_raid_stockpile.call
    from_locker.call
  end
end

for place in [ 'consignment', 'furrier', 'gemshop', 'pawnshop' ]
  sell_list = Array.new
  for lootsack in lootsack_list
    sell_list.concat(lootsack.contents.to_a.find_all { |obj| (!CharSettings['exclude regex'] or obj.name !~ /#{CharSettings['exclude regex']}/o) and (!CharSettings['exclude types'] or obj.type !~ /#{CharSettings['exclude types']}/o) and (!$clericbot_settings['gems'] or not $clericbot_settings['gems'].any? { |gem| gem[:id] == obj.id }) and (Vars.needed_reagents.nil? or Vars.needed_reagents.empty? or obj.name !~ /#{Vars.needed_reagents}/) and !$loot_be_gone_ignore.include?(obj.id) and (obj.sellable =~ /#{place}/) })
  end
  if (place == 'gemshop') and (checkbounty =~ /gem dealer.*? (Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor).*? requesting (?:a|an|some) (.*?)\. .* retrieve [0-9]+ (?:more )?of them\./)
    target_town = $1
    gem = $2
    gemshop = Room[Room.current.find_nearest_by_tag('gemshop')]
    if gemshop.location and (gemshop.location =~ /Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor/) and ((gemshop.location !~ /#{target_town}/) or gemshop.title.include?('Shimmarglin Jewels and Gems'))
      sell_list.delete_if { |obj| obj.name.sub(/large |medium |small |tiny |some /, '') == gem }
    end
  end
  if (place == 'furrier') and (checkbounty =~ /tasked to retrieve [0-9]+ (.*?) of at least .*? quality .*? (Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor)\./)
    skin = $1
    target_town = $2
    skin.sub!(/s$/, '')
    furrier = Room[Room.current.find_nearest_by_tag('furrier')]
    if furrier.location and (furrier.location =~ /Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor/) and (furrier.location !~ /#{target_town}/)
      sell_list.delete_if { |obj| obj.name =~ /^(?:bundle of )?#{skin}\s?$/ }
    end
  end
  unless sell_list.empty?
    did_something = true
    Script.run('go2', "#{place} --disable-confirm")
    empty_hands
    if place == 'gemshop'
      hoarding_jars.each { |jar_info|
        jar = nil
        for lootsack in lootsack_list
          break if (jar = lootsack.contents.find { |o| o.full_name =~ /^#{jar_info[:name]}/ })
        end
        if jar
          if lootsack_list.any? { |c| c.contents.any? { |o| o.name == jar_info[:gem] } }
            result = dothistimeout "look in ##{jar.id}", 5, /^Inside .+ you see \d+ portion|^The .+ is empty/
            if result =~ /^Inside .+ you see (\d+) portion/
              jar_count = $1.to_i
            elsif result =~ /^The .+ is empty/
              jar_count = 0
            else
              jar_count = nil
            end
            got_jar = false
            if jar_count and (jar_count < jar_info[:count])
              for lootsack in lootsack_list
                break unless (jar_count < jar_info[:count])
                for obj in lootsack.contents
                  break unless (jar_count < jar_info[:count])
                  if obj.name == jar_info[:gem]
                    dothistimeout "get ##{obj.id}", 2, get_regex
                    unless ((jar_info[:min_value].nil? or (jar_info[:min_value] < 1)) and jar_info[:max_value].nil?)
                      result = dothistimeout "appraise ##{obj.id}", 5, /[0-9,]+ (?:silver|for it if you want to sell|for this if you'd like)|I'm not buying anything this valuable today|not quite my field|only deal in gems and jewelry|There is nothing of value to me|Trying to pull a fast one on old Hortemeyer, are you\?|Can't say I'm interested|That's basically worthless here|I have no use for that/
                    end
                    if ((jar_info[:min_value].nil? or (jar_info[:min_value] < 1)) and jar_info[:max_value].nil?) or ((result =~ /([0-9,]+) (?:silver|for it if you want to sell|for this if you'd like)/) and (value = undo_trading_bonus.call($1.gsub(',', '').to_i)) and (jar_info[:min_value].nil? or value >= jar_info[:min_value]) and (jar_info[:max_value].nil? or value <= jar_info[:max_value]))
                      unless got_jar
                        dothistimeout "get ##{jar.id}", 2, get_regex
                        got_jar = true
                      end
                      dothistimeout "put ##{obj.id} in ##{jar.id}", 5, /^You add|^You put/
                      jar_count += 1
                      sell_list.delete_if { |o| o.id == obj.id }
                    else
                      lootsack_put.call(obj)
                    end
                  end
                end
              end
            end
            if got_jar
              lootsack_put.call(jar)
            end
          end
        end
      }
      if CharSettings['open-cheap-plinites']
        echo 'blah'
      end
    end
    if place =~ /^gemshop$|^furrier$/
      for lootsack in lootsack_list
        if (lootsack.contents.count { |obj| sell_list.any? { |o| o.id == obj.id } } > 2) and not lootsack.contents.any? { |obj| ((place == 'gemshop' and obj.type =~ /gem/) or (place == 'furrier' and obj.type =~ /skin/)) and not sell_list.any? { |o| o.id == obj.id } }
          ids_before = lootsack.contents.collect { |obj| obj.id }
          dothistimeout "remove ##{lootsack.id}", 5, /^You/
          fput 'unhide' if invisible?
          dothistimeout "sell ##{lootsack.id}", 5, /^You/
          dothistimeout "wear ##{lootsack.id}", 5, /^You/
          stow_notes.call
          ids_after = lootsack.contents.collect { |obj| obj.id }
          sold_ids = ids_before - ids_after
          sell_list.delete_if { |obj| sold_ids.include?(obj.id) }
        end
      end
    end
    for obj in sell_list
      if (obj.type =~ /scroll/) and not CharSettings['keep scrolls'].empty?
        script.want_downstream = false
        script.want_downstream_xml = true
        result = dothistimeout "read ##{obj.id}", 5, /^On the/
        if result.nil?
          script.want_downstream = true
          script.want_downstream_xml = false
          echo "error: failed to read scroll"
          $loot_be_gone_ignore.push(obj.id)
          next
        end
        spell_list = Array.new
        while (line = get) and line !~ /<prompt/
          if line =~ /noun="([0-9]+)"/
            spell_list.push($1.to_i)
          end
        end
        script.want_downstream = true
        script.want_downstream_xml = false
        unless (CharSettings['keep scrolls'] & spell_list).empty?
          $loot_be_gone_ignore.push(obj.id)
          next
        end
      end
      dothistimeout "get ##{obj.id}", 2, get_regex
      fput 'unhide' if invisible?
      if CharSettings['appraise types'] and (obj.type =~ /#{CharSettings['appraise types']}/o) and save_value[place]
        result = dothistimeout "appraise ##{obj.id}", 5, /[0-9,]+ (?:silver|for it if you want to sell|for this if you'd like)|I'm not buying anything this valuable today|not quite my field|only deal in gems and jewelry|There is nothing of value to me|Trying to pull a fast one on old Hortemeyer, are you\?|Can't say I'm interested|That's basically worthless here|I have no use for that/
        if result.nil? or result =~ /not quite my field|only deal in gems and jewelry|There is nothing of value to me|Trying to pull a fast one on old Hortemeyer, are you\?/
          lootsack_put.call(obj)
          next
        elsif (result =~ /([0-9,]+) (?:silver|for it if you want to sell|for this if you'd like)/ and $1.gsub(',', '').to_i >= save_value[place]) or result =~ /I'm not buying anything this valuable today|Can't say I'm interested|That's basically worthless here|I have no use for that/
          lootsack_put.call(obj)
          $loot_be_gone_ignore.push(obj.id)
          next
        end
      end
      fput 'unhide' if invisible?
      result = dothistimeout "sell ##{obj.id}", 5, /(?:pays|hands) you [0-9,]+ silver|not quite my field|only deal in gems and jewelry|I have no use for that|Where do you find this junk/
      stow_notes.call
      if (GameObj.right_hand.id == obj.id) or (GameObj.left_hand.id == obj.id)
        lootsack_put.call(obj)
      end
    end
=begin
        if ring = table.contents.find { |o| o.name =~ /gold ring$/ }
          dothistimeout "buy ##{ring.id}", 5, /^She hands .+ to you/
          # ring id changes after buying
          if ring = [ GameObj.right_hand, GameObj.left_hand ].find { |o| o.name =~ /gold ring$/ }
            Script.run('go2', 'chronomage --disable-confirm')
            if npc = GameObj.npcs.last
              fput 'unhide' if invisible?
              dothistimeout "give ##{ring.id} to #{npc.noun}", 5, /^(?:A|An|The) .+ credit/
            end
            lootsack_put.call(ring) if (GameObj.right_hand.id == ring.id) or (GameObj.left_hand.id == ring.id)
          end
        end
=end
    fill_hands
  end
end

=begin
silvers = check_silvers.call
if (Char.name == 'Tillmen') and (Room.current.location =~ /Icemule|Solhaven|Wehnimer's/) and (percentencumbrance < 100) and ((notes.length > 0) or (silvers >= 2000))
  Script.run('go2', 'pawnshop')
  if Room.current.location =~ /Icemule/
    move 'out'
  elsif Room.current.location =~ /Solhaven/
    move 'west'
  elsif Room.current.location =~ /Wehnimer's/
    move 'go door'
  elsif Room.current.location =~ /Cysaegir/
    move 'go archway'
  end
  if table = GameObj.loot.find { |o| o.name =~ /(arcana|magic) table/ }
    dothistimeout "look on ##{table.id}", 5, /^On the/
    if statue = table.contents.find { |o| o.name == 'small statue' }
      empty_hands
      if silvers < 2000
        dothistimeout "get ##{notes.first}", 5, get_regex
      end
      dothistimeout "buy ##{statue.id}", 5, /^She hands .+ to you/
      stow_notes.call
      # statue id changes after buying
      if statue = [ GameObj.right_hand, GameObj.left_hand ].find { |o| o.name == 'small statue' }
        lootsack_put.call(statue)
        Script.run('stockshop') if Room.current.location =~ /Icemule/
      end
      fill_hands
    end
  end
end
=end

silvers = check_silvers.call
if (silvers > 0) or (notes.length > 0)
  did_something = true
  Script.run('go2', 'bank --disable-confirm')
  fput 'unhide' if invisible?
  if XMLData.room_title == '[Pinefar, Depository]'
    if silvers > 100
      dothistimeout "give banker #{silvers} silvers", 5, /takes your silvers/
    end
  else
    if silvers > 0
      dothistimeout "deposit #{silvers}", 5, /^You/
    end
  end
  empty_hand unless notes.empty?
  for note_id in notes
    dothistimeout "get ##{note_id}", 2, /^You/
    fput 'unhide' if invisible?
    if XMLData.room_title == '[Pinefar, Depository]'
      dothistimeout "give ##{note_id} to banker", 2, /^takes your note|laughs at you/
    else
      dothistimeout "deposit ##{note_id}", 2, /^You/
    end
    if (GameObj.right_hand.id == note_id) or (GameObj.left_hand.id == note_id)
      lootsack_put.call(note_id)
    end
  end
  fill_hand unless notes.empty?
end

for lootsack_id in need_close_lootsack
  dothistimeout "close ##{lootsack_id}", 3, /^You close|^That is already closed;\./
end

if did_something
  echo 'done'
else
  echo 'nothing to do'
end

# fixme: There is no merchant here that can buy that
# fixme: The glass jar does not appear to be a suitable container for a black helmet shell.
