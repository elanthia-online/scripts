require "dcell"

module Cluster
  ##
  ## minimal options parser
  ##
  module Opts
    FLAG_PREFIX    = "--"
    
    def self.parse_command(h, c)
      h[c.to_sym] = true
    end

    def self.parse_flag(h, f)
      (name, val) = f[2..-1].split("=")
      if val.nil?
        h[name.to_sym] = true
      else
        val = val.split(",")

        h[name.to_sym] = val.size == 1 ? val.first : val
      end
    end

    def self.parse(args = Script.current.vars[1..-1])    
      OpenStruct.new(**args.to_a.reduce(Hash.new) do |opts, v|
        if v.start_with?(FLAG_PREFIX)
          Opts.parse_flag(opts, v)
        else
          Opts.parse_command(opts, v)
        end
        opts
      end)
    end

    def self.method_missing(method, *args)
      parse.send(method, *args)
    end
  end
end
##
## distributed cluster for queryiny character states
##
module Cluster
  ##
  ## normalize a key in the cluster
  ##
  def self.key_of(t)
    t.to_s.downcase.gsub(%{\s}, "_")
  end
  ##
  ## all nodes
  ##
  def self.nodes()
    DCell::Node.all
  end
  ##
  ## fetch a Node by normalized key
  ##
  def self.node(id)
    DCell::Node[key_of(id)]
  end
  ##
  ## put a key to the dcell 
  ## global k/v registry
  ##
  def self.put(key, value)
    DCell::Global.set(key, value)
  end
  ##
  ## fetch a value from the 
  ## dcell global k/v registry
  ##
  def self.fetch(key, default = nil)
    val = DCell::Global.get(key)
    if val.nil?
      default
    else
      val
    end
  end
  ##
  ## get all keys from the 
  ## global k\v registry
  ##
  def self.keys()
    DCell::Global.keys()
  end
  ##
  ## check if a cluster implements
  ## an actor everywhere
  ##
  def self.implements?(actor)
    DCell::Node.all.map do |node|
      [node.id, 
        !node[actor].nil?]
    end
  end
  ##
  ## invoke a given method on a Node within an available Actor
  ##
  def self.call(id, method, *args, actor: :bridge)
    if node = Cluster.node(id)
      node[actor].send(method, *args)
    end
  end
  ##
  ## map the invocation of a method 
  ## across all nodes in the cluster
  ##
  ## ex:
  ##
  ## Hash[Cluster.map(&:room)] => Hash(Character, Room)
  ## Cluster.map(:roundtime).map(&:last).map(&:values).flatten.sort.last => longest remaining RT
  ##
  def self.map(method, *args, actor: :bridge)
    DCell::Node.all.map do |node|
      [node.id,
        Cluster.call(node.id, method, *args, actor: actor)]
    end
  end
  ##
  ## start the Cluster
  ##
  def self.link(id: Char.name, addr: "tcp://127.0.0.1:0")
    DCell.start(id: key_of(id), addr: addr)
    Cluster::Bridge.supervise_as :bridge
  end
end

module Cluster
  ##
  ## this is the interface for querying
  ## the state of any single character
  ##
  class Bridge
    include Celluloid

    def roundtime()
      { hard: checkrt, 
        soft: checkcastrt}
    end

    def health()
      { total:   checkhealth,
        percent: percenthealth}
    end

    def mana()
      { total: checkmana,
        percent: percentmana}
    end

    def encumbrance()
      { label:   Cluster.key_of(checkencumbrance).to_sym,
        percent: percentencumbrance}
    end
    
    def room()
      { id:       Room.current.id,
        monsters: GameObj.npcs.to_a}
    end

    def effects()
      { bound:     checkbound,
        webbed:    checkwebbed,
        poisoned:  checkpoison,
        diseased:  checkdisease,
        cutthroat: checkcutthroat}
    end
  end
end
##
## initialize this node
##
module Cluster
  Cluster::link(addr: Opts.host || "tcp://127.0.0.1:0")
  loop do sleep(1) end
end
