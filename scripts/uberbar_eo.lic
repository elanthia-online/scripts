=begin

  Based off uberbarv_d, which was a fork of uberbarv, which was a fork of uberbar
  Integrates with ;bank or ;ledger script to display Silver gained during day (optional)
  Integrates with ;bank or ;hud_bounty scrip to display Bounty points gained (optional)

          author: elanthia-online
    contributors: Dantax, Tysong, Gibreficul, Bait, Xanlin, Khazaann, Dissonance
            game: gemstone
            tags: uberbar, bar, uber, vitals, paperdoll
         version: 2.1.0
        required: Lich >= 5.11.0

  Help Contribute: https://github.com/elanthia-online/scripts

  Version Control:
    Major_change.feature_addition.bugfix
  v2.1.0 (2026-01-13)
    - add Shadow Essence tracking bar for Sorcerers (separate from profession resources, disabled by default)
  v2.0.3 (2025-10-29)
    - remove saving of XP history into UserVars as not used for anything
  v2.0.2 (2025-09-24)
    - update percent capped to use total experience, so it includes ascension experience
  v2.0.1 (2025-07-04)
    - allow for empath resource to work
  v2.0.0 (2025-04-28)
    - converted to module
    - made various bars/txt togglable display
    - made exp/resource check a customizable interval
    - add support for ledger.lic (daily silver) and hud_bounty.lic (current session bounty points)
    - convert evals into sends for security
  v1.2.1 (2025-04-28)
    - % capped should now update as well
  v1.2.0 (2025-04-28)
    - Added rogue to conditional display of resources
    - Tweaked % capped to display correctly for empaths
  v1.1.1 (2025-04-27)
    - Missed some depreciated calls, fixed them.
  v1.1.0 (2025-04-27)
    - Replace depreciated calls with new Char. class data
    - Added % capped bar.
    - Updated minimum lich required to be slightly newer based on Char class rewrite
  v1.0.3 (2024-11-05)
    - Add Rogue to resource tracking
  v1.0.2 (2024-07-13)
    - Add Paladin to resource tracking
  v1.0.1 (2024-05-01)
    - Change Char.level to Stats.level
  v1.0.0 (2024-03-10)
    - initial release and forking from uberbarv_d version 2.1

=end

no_kill_all
no_pause_all
hide_me
silence_me

# Validate frontend compatibility
unless ['stormfront', 'wrayth'].include?($frontend)
  respond ""
  respond " Thank you for your interest in UberBar"
  respond " This version is specific to the Wrayth frontend"
  respond " There is a Wizard (GTK) version on the repository"
  respond ""
  respond " ;repo download uberbarwiz"
  respond ""
  respond " Closing now"
  respond ""
  exit
end

# Check version of Lich for compatibility
REQUIRED_LICH_VERSION = '5.11.0' unless defined?(REQUIRED_LICH_VERSION)

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(REQUIRED_LICH_VERSION)
  error_message_lines = [
    "########################################",
    "Script:#{script.name} now requires a newer version of Lich(#{REQUIRED_LICH_VERSION}+) to run.",
    "Please update to a newer version.",
    "",
    "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}",
    "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation",
    "########################################"
  ]

  if $frontend == 'stormfront' || $frontend == 'profanity'
    error_message_lines.each_with_index do |line, index|
      preset = if index.zero? || index == error_message_lines.length - 1
                 'speech'
               else
                 'thought'
               end
      _respond "<preset id=\"#{preset}\">#{line}</preset>"
    end
  else
    prefix = ->(line) { line.empty? ? ">" : "##" }
    error_message_lines.each do |line|
      _respond "#{prefix.call(line)}#{line}"
    end
  end
  exit
end

wait_while { XMLData.next_level_text !~ /(experience|until next level)/ || !XMLData.next_level_value.integer? }

# Main module for UberBar functionality
# @since 2.0.0
module UberBarEO
  # Command-line options parser module
  # Handles parsing of command-line arguments and flags
  # @since 2.0.0
  module Opts
    # Prefix for command-line flags
    FLAG_PREFIX = '--' unless defined?(FLAG_PREFIX)

    # Parse a command into the options hash
    # @param options_hash [Hash] the hash to store parsed options
    # @param command [String] the command to parse
    # @return [void]
    def self.parse_command(options_hash, command)
      options_hash[command.to_sym] = true
    end

    # Parse a flag into the options hash
    # Flags can be in format: --name or --name=value or --name=value1,value2
    # @param options_hash [Hash] the hash to store parsed options
    # @param flag [String] the flag to parse (must start with FLAG_PREFIX)
    # @return [void]
    def self.parse_flag(options_hash, flag)
      name, value = flag[2..-1].split('=')

      if value.nil?
        options_hash[name.to_sym] = true
      else
        value_array = value.split(',')
        options_hash[name.to_sym] = value_array.length == 1 ? value_array.first : value_array
      end
    end

    # Parse command-line arguments into an OpenStruct
    # @param args [Array<String>] command-line arguments to parse
    # @return [OpenStruct] parsed options as an OpenStruct
    def self.parse(args = Script.current.vars[1..-1])
      parsed_options = args.to_a.each_with_object({}) do |value, opts|
        if value.start_with?(FLAG_PREFIX)
          parse_flag(opts, value)
        else
          parse_command(opts, value)
        end
      end

      OpenStruct.new(**parsed_options)
    end

    # Convert a key's value to an array
    # @param key [Symbol, String] the key to look up
    # @return [Array] the value as an array
    def self.as_list(key)
      value = to_h.fetch(key.to_sym, [])
      value = [value] if value.is_a?(String)
      value
    end

    # Method missing handler to delegate to parsed options
    # @param method [Symbol] the method name
    # @param args [Array] method arguments
    # @return [Object] result from the parsed options
    def self.method_missing(method, *args)
      parse.send(method, *args)
    end

    # Respond to missing handler
    # @param method [Symbol] the method name
    # @param include_private [Boolean] whether to include private methods
    # @return [Boolean] true if the parsed options respond to the method
    def self.respond_to_missing?(method, include_private = false)
      parse.respond_to?(method, include_private) || super
    end
  end

  @options = Opts.parse

  # Mapping of string values to boolean for settings
  @boolean_values = {
    'on' => true, 'true' => true, 'yes' => true,
    'off' => false, 'false' => false, 'no' => false
  }.freeze

  # Initialize settings with defaults
  @settings = CharSettings[:settings] || {}

  # Default settings configuration
  DEFAULT_SETTINGS = {
    'display-silver'         => true,
    'display-bounty'         => true,
    'display-room'           => true,
    'display-favor'          => true,
    'display-atp'            => true,
    'display-tp'             => true,
    'display-fxp'            => true,
    'display-resources'      => true,
    'display-shadow-essence' => false,
    'display-percentcap'     => true,
    'display-loudxp'         => false,
    'display-debug'          => false,
    'silent-check-interval'  => 120
  }.freeze unless defined?(DEFAULT_SETTINGS)

  # Apply default settings if not already set
  DEFAULT_SETTINGS.each do |key, default_value|
    @settings[key] = default_value if @settings[key].nil?
  end

  # Cleanup handler to close the dialog and save settings on script termination
  before_dying do
    puts("<closeDialog id='UberBar'/>")
    CharSettings[:settings] = @settings
  end

  # Body area definitions for wounds and scars tracking
  # Maps internal names to display names
  BODY_AREAS = {
    'nsys'      => 'nerves',
    'leftArm'   => 'left arm',
    'rightArm'  => 'right arm',
    'rightLeg'  => 'right leg',
    'leftLeg'   => 'left leg',
    'head'      => 'head',
    'rightFoot' => 'right foot',
    'leftFoot'  => 'left foot',
    'rightHand' => 'right hand',
    'leftHand'  => 'left hand',
    'rightEye'  => 'right eye',
    'leftEye'   => 'left eye',
    'back'      => 'back',
    'neck'      => 'neck',
    'chest'     => 'chest',
    'abdomen'   => 'abdomen'
  }.freeze unless defined?(BODY_AREAS)

  # Order of body areas for display purposes
  BODY_AREA_ORDER = %w[
    nsys leftArm rightArm rightLeg leftLeg head
    rightFoot leftFoot rightHand leftHand
    rightEye leftEye back neck chest abdomen
  ].freeze unless defined?(BODY_AREA_ORDER)

  # Generate XML for displaying a single wound or scar
  # @param area_key [String] the body area key (e.g., 'nsys', 'head')
  # @param area_name [String] the display name of the area
  # @return [String] XML string for the image element
  # @since 1.0.0
  def self.generate_wound_image(area_key, area_name)
    wound_level = Wounds.send(area_key)
    scar_level = Scars.send(area_key)

    image_name = if wound_level > 0
                   area_key == 'nsys' ? "Nsys#{wound_level}" : "Injury#{wound_level}"
                 elsif scar_level > 0
                   area_key == 'nsys' ? "Nsys#{scar_level}" : "Scar#{scar_level}"
                 else
                   area_key
                 end

    "<image id='#{area_key}' name='#{image_name}' cmd='cure #{area_name}' " \
    "tooltip='cure #{area_name}' height='0' width='0'/>"
  end

  # Generate full wounds display XML for all body areas
  # @return [String] complete XML string for all wound images
  # @since 1.0.0
  def self.generate_full_wounds_display
    BODY_AREAS.map do |area_key, area_name|
      generate_wound_image(area_key, area_name)
    end.join
  end

  # Generate XML for a single changed wound location
  # @param location [String] the body area that changed
  # @return [String] XML string for the updated image element
  # @since 1.0.0
  def self.generate_wound_change_display(location)
    area_name = BODY_AREAS[location]
    return '' unless area_name

    generate_wound_image(location, area_name)
  end

  # Create a composite hash value for wounds and scars
  # Used to detect changes in injury status
  # @return [Array<Integer>] array of composite values (wounds*10 + scars) for each area
  # @since 1.0.0
  def self.calculate_wounds_hash
    BODY_AREA_ORDER.map do |area|
      (Wounds.send(area) * 10) + Scars.send(area)
    end
  end

  # Add thousand separators to a number
  # @param number [Numeric] the number to format
  # @return [String] formatted number string with commas
  # @example
  #   add_commas(1234567) #=> "1,234,567"
  # @since 1.0.0
  def self.add_commas(number)
    number.to_s.reverse.scan(/(?:\d*\.)?\d{1,3}-?/).join(',').reverse
  end

  # Determine if profession resource tracking is available
  # @return [Boolean] true if the character's profession has resource tracking
  # @since 1.0.0
  def self.profession_resource_available?
    case Stats.prof
    when 'Bard'
      Spell[1030].known?
    when 'Cleric'
      Spell[330].known?
    when 'Empath'
      Spell[1135].known?
    when 'Monk'
      Stats.level >= 20
    when 'Paladin'
      Spell[1620].known?
    when 'Ranger'
      Spell[620].known?
    when 'Rogue'
      Stats.level >= 20
    when 'Sorcerer'
      Spell[735].known?
    when 'Warrior'
      Stats.level >= 20
    when 'Wizard'
      Spell[925].known?
    else
      false
    end
  end

  # Get current bounty points from BountyHUD or bank script
  # @return [Integer] current bounty points, or 0 if unavailable
  # @since 2.0.0
  def self.bounty_points
    if defined?(BountyHUD)
      points = BountyHUD.metadata.dig(:earned, :recent)
      points.is_a?(Numeric) ? points : 0
    elsif UserVars.bank_bounty_per_day
      points = UserVars.bank_bounty_per_day
      points.is_a?(Numeric) ? points : 0
    else
      0
    end
  end

  # Get daily silver earned from Ledger or bank script
  # @return [Integer] daily silver earned, or 0 if unavailable
  # @since 2.0.0
  def self.daily_silvers
    if defined?(Ledger)
      silver = Ledger::Character.daily
      silver.is_a?(Numeric) ? silver : 0
    elsif UserVars.bank_silver_per_day
      silver = UserVars.bank_silver_per_day
      silver.is_a?(Numeric) ? silver : 0
    else
      0
    end
  end

  # Apply command-line settings to the stored settings
  # @return [void]
  # @raise [RuntimeError] if an invalid command-line option is provided
  # @since 2.0.0
  def self.set_vars
    return if @options.to_h.empty?

    Lich::Messaging.mono(Lich::Messaging.xml_encode(
                           "#{Script.current.name} vars detected, attempting to set settings now:"
                         ))

    @options.to_h.each do |key, value|
      key_string = key.to_s

      case key_string
      when /^display-(?:silver|bounty|room|favor|atp|tp|fxp|resources|shadow-essence|percentcap|loudxp|debug)$/
        old_value = @settings[key_string]
        new_value = @boolean_values[value.to_s.downcase]

        Lich::Messaging.mono(Lich::Messaging.xml_encode(
                               "  #{key} changing from #{old_value} to #{new_value}"
                             ))

        @settings[key_string] = new_value

      when /^silent-check-interval$/
        old_value = @settings[key_string]
        new_value = value.to_i

        Lich::Messaging.mono(Lich::Messaging.xml_encode(
                               "  #{key} changing from #{old_value} to #{new_value}"
                             ))

        @settings[key_string] = new_value

      else
        raise "You started #{Script.current.name} with an invalid command line option: #{key}\n" \
              "Please see #{$lich_char}#{Script.current.name} help\n" \
              "For proper CLI options."
      end
    end
  end

  # Check if character state has changed
  # @param old_state [Hash] previous state hash
  # @param check_grouped [Boolean] whether to ignore room changes for grouped characters
  # @return [Boolean] true if nothing has changed
  # @since 2.0.0
  def self.character_state_unchanged?(old_state, check_grouped)
    # Character stats unchanged
    stats_unchanged = (
      old_state[:health] == Char.health &&
      old_state[:mana] == Char.mana &&
      old_state[:stamina] == Char.stamina &&
      old_state[:spirit] == Char.spirit
    )

    # Character state unchanged
    state_unchanged = (
      old_state[:experience] == XMLData.next_level_text &&
      old_state[:mind] == XMLData.mind_text &&
      old_state[:stance] == XMLData.stance_text &&
      old_state[:encumbrance] == XMLData.encumbrance_text &&
      old_state[:injuries] == XMLData.injuries.to_s
    )

    # Room unchanged (or we're ignoring it)
    room_unchanged = check_grouped || old_state[:room] == Room.current.id

    stats_unchanged && state_unchanged && room_unchanged
  end

  # Check if periodic updates are needed
  # @param settings [Hash] current settings
  # @param last_check_time [Integer] timestamp of last check
  # @param check_interval [Integer] interval between checks in seconds
  # @return [Boolean] true if an update is needed
  # @since 2.0.0
  def self.needs_periodic_update?(settings, last_check_time, check_interval)
    return false unless periodic_checks_enabled?(settings)

    Time.now.to_i - last_check_time > check_interval
  end

  # Check if any periodic checks are enabled
  # @param settings [Hash] current settings
  # @return [Boolean] true if any periodic checks are enabled
  # @since 2.0.0
  def self.periodic_checks_enabled?(settings)
    settings['display-resources'] ||
      settings['display-favor'] ||
      settings['display-shadow-essence'] ||
      settings['display-fxp'] ||
      settings['display-atp'] ||
      settings['display-tp'] ||
      settings['display-percentcap']
  end

  # Perform experience checks via silent command
  # @return [Hash] hash with :asc_next and :asc_tps keys
  # @since 2.0.0
  def self.check_experience
    result = { asc_next: nil, asc_tps: nil }

    response = Lich::Util.quiet_command_xml('exp', /<output class="mono"\/>/, /<prompt time=/)

    response.each do |line|
      if line =~ /Exp to next ATP: ([\d,]+)/i
        result[:asc_next] = Regexp.last_match(1).delete(',').to_i
      end

      if line =~ /ATPs: ([\d,]+)/i
        result[:asc_tps] = Regexp.last_match(1).delete(',').to_i
      end
    end

    result
  end

  # Calculate experience values for display
  # @param next_level_text [String] the XML next level text
  # @param capped [Boolean] whether the character is level-capped
  # @return [Hash] hash with :current, :last, :cap, :value, and :text keys
  # @since 2.0.0
  def self.calculate_experience_values(next_level_text, capped)
    result = {
      current: 0,
      last: 0,
      cap: 0,
      value: 0,
      text: ''
    }

    if next_level_text =~ /( experience| until next level)/
      current_xp = next_level_text.delete(' experience').delete(' until next level').to_i
      result[:current] = current_xp

      if capped
        xp_until_cap = ((current_xp / 2500) + 1) * 2500 - current_xp
        result[:cap] = xp_until_cap
        result[:value] = 100 - (xp_until_cap / 25)
        result[:text] = "#{xp_until_cap} until TP"
      else
        result[:value] = XMLData.next_level_value.to_i
        result[:text] = sprintf("Level: %2s  (%s%%)   %6s TNL",
                                Stats.level, result[:value], current_xp)
      end
    end

    result
  end

  # Main execution loop
  # @return [void]
  # @since 2.0.0
  def self.main
    # Initialize ascension tracking variables
    ascension_state = {
      total_points: 0,
      experience: 0,
      pulse: 0,
      next_atp: 50_000,
      last_check: 0,
      total_earned: 0
    }

    # Initialize experience tracking variables
    experience_state = {
      first_time: 0,
      current_time: Time.now - 1,
      current: 0,
      old: 0,
      cap: 0,
      value: 0,
      text: '',
      per_hour: 0,
      last_pulse: 0,
      total: 0,
      old_bank: 0,
      old_bounty: 0,
      old_favor: 0,
      old_shadow_essence: 0
    }

    # Initialize character state tracking
    character_state = {
      room: nil,
      health: nil,
      mana: nil,
      stamina: nil,
      spirit: nil,
      experience: nil,
      mind: nil,
      stance: nil,
      encumbrance: nil,
      injuries: nil
    }

    old_wounds = calculate_wounds_hash
    capped = Stats.level == 100
    first_pulse = true

    # UI sizing constants
    ui_dimensions = {
      buffer_x: 3,
      buffer_y: 3,
      bar_width: 186,
      resource_width: 100,
      element_height: 15
    }

    # Initialize daily experience tracking
    current_time = Time.now
    UserVars.uberbar_date = current_time - (3600 * 24) if UserVars.uberbar_date.nil?

    # Reset daily experience if it's a new day (after 5 AM)
    if current_time.hour > 5 &&
       UserVars.uberbar_day != current_time.day &&
       UserVars.uberbar_xp_per_day != 0
      UserVars.uberbar_xp_per_day = 0
      UserVars.uberbar_day = current_time.day
      UserVars.uberbar_date = current_time
      UserVars.save
    end

    check_grouped = @settings['display-room'] == false

    # Generate UI builder lambdas
    ui_builders = create_ui_builders(
      ui_dimensions,
      experience_state,
      ascension_state,
      character_state
    )

    # Build and display initial UI
    initial_ui = build_initial_ui(ui_builders, old_wounds)
    puts(initial_ui)

    # Main update loop
    loop do
      wait_while do
        state_unchanged = character_state_unchanged?(character_state, check_grouped)
        timeout_not_reached = Time.now - experience_state[:current_time] < 5

        (state_unchanged && timeout_not_reached) || Script.running?('go2')
      end

      experience_state[:current_time] = Time.now
      update_lines = ["<dialogData id='UberBar'>"]

      # Check for stat changes
      update_lines.concat(check_stat_changes(character_state, ui_builders))

      # Check for state changes
      update_lines.concat(check_state_changes(character_state, ui_builders))

      # Check for resource changes
      update_lines.concat(check_resource_changes(
                            experience_state,
                            ui_builders
                          ))

      # Periodic experience and resource checks
      if needs_periodic_update?(
        @settings,
        ascension_state[:last_check],
        @settings['silent-check-interval']
      )
        ascension_state[:last_check] = Time.now.to_i

        perform_periodic_checks(ascension_state)
      end

      # Handle experience updates
      update_lines.concat(check_experience_changes(
                            character_state,
                            experience_state,
                            ascension_state,
                            capped,
                            first_pulse,
                            ui_builders
                          ))

      first_pulse = false if first_pulse

      # Handle injury updates
      update_lines.concat(check_injury_changes(
                            character_state,
                            old_wounds,
                            ui_builders
                          ))

      update_lines << '</dialogData>'

      # Only send updates if there were actual changes
      puts(update_lines.join) unless update_lines.length == 2
    end
  end

  # Create UI builder lambdas for generating XML elements
  # These lambdas use closures to maintain anchor state for proper UI positioning
  # @param dims [Hash] UI dimensions
  # @param exp_state [Hash] experience state
  # @param asc_state [Hash] ascension state
  # @param char_state [Hash] character state
  # @return [Hash] hash of lambda functions for building UI elements
  # @private
  # @since 2.0.0
  def self.create_ui_builders(dims, exp_state, asc_state, _char_state)
    buffx = dims[:buffer_x]
    buffy = dims[:buffer_y]
    sizebx = dims[:bar_width]
    sizerx = dims[:resource_width]
    sizey = dims[:element_height]

    # Shared anchor tracking variables (modified by lambdas to create anchor chain)
    ub_top_anchor_left = nil
    ub_top_anchor_right = nil
    ub_bottom_anchor = nil

    builders = {}

    # Left-side labels - each has its own anchor variable that captures state on first call
    builders[:log_label] = lambda do
      ub_top_anchor_left = 'ublog'
      "<label id='ublog' value='Today:' justify='4' anchor_left='ubinjury' align='n' " \
      "top='#{buffy + 2}' left='5' height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    builders[:log_value] = lambda do
      ub_top_anchor_right = 'ublogv'
      "<label id='ublogv' value='#{UserVars.uberbar_xp_per_day}' justify='6' " \
      "anchor_left='ublog' align='n' top='#{buffy + 2}' left='0' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    anchor_ublinehourl = nil
    builders[:hour_label] = lambda do
      anchor_ublinehourl = ub_top_anchor_left unless anchor_ublinehourl
      ub_top_anchor_left = 'ubhour'
      "<label id='ubhour' value='AVG/Hr:' justify='4' anchor_left='ubinjury' " \
      "anchor_top='#{anchor_ublinehourl}' top='#{buffy}' left='5' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    anchor_ublinehourv = nil
    builders[:hour_value] = lambda do
      anchor_ublinehourv = ub_top_anchor_right unless anchor_ublinehourv
      ub_top_anchor_right = 'ubhourv'
      "<label id='ubhourv' value='#{exp_state[:per_hour]}' justify='6' " \
      "anchor_left='ubhour' anchor_top='#{anchor_ublinehourv}' top='#{buffy}' left='0' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    anchor_ublinelastl = nil
    builders[:pulse_label] = lambda do
      anchor_ublinelastl = ub_top_anchor_left unless anchor_ublinelastl
      ub_top_anchor_left = 'ublast'
      "<label id='ublast' value='Pulse:' justify='4' anchor_left='ubinjury' " \
      "anchor_top='#{anchor_ublinelastl}' top='#{buffy}' left='5' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    anchor_ublinelastv = nil
    builders[:pulse_value] = lambda do
      anchor_ublinelastv = ub_top_anchor_right unless anchor_ublinelastv
      ub_top_anchor_right = 'ublastv'
      pulse_value = exp_state[:last_pulse] + asc_state[:pulse]
      "<label id='ublastv' value='#{pulse_value}' justify='6' " \
      "anchor_left='ublast' anchor_top='#{anchor_ublinelastv}' top='#{buffy}' left='0' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    # Optional room display
    anchor_ublinerooml = nil
    builders[:room_label] = lambda do
      return '' unless @settings['display-room']
      anchor_ublinerooml = ub_top_anchor_left unless anchor_ublinerooml
      ub_top_anchor_left = 'ubroom'
      "<label id='ubroom' value='Room:' justify='4' anchor_left='ubinjury' " \
      "anchor_top='#{anchor_ublinerooml}' top='#{buffy + 2}' left='5' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    anchor_ublineroomv = nil
    builders[:room_value] = lambda do
      return '' unless @settings['display-room']
      anchor_ublineroomv = ub_top_anchor_right unless anchor_ublineroomv
      ub_top_anchor_right = 'ubroomv'
      "<label id='ubroomv' value='#{Room.current.id}' justify='6' " \
      "anchor_left='ubroom' anchor_top='#{anchor_ublineroomv}' top='#{buffy + 2}' left='0' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    # Optional silver display
    anchor_ublinesilvl = nil
    builders[:silver_label] = lambda do
      return '' unless @settings['display-silver']
      anchor_ublinesilvl = ub_top_anchor_left unless anchor_ublinesilvl
      ub_top_anchor_left = 'ubsil'
      "<label id='ubsil' value='Silver:' justify='4' anchor_left='ubinjury' " \
      "anchor_top='#{anchor_ublinesilvl}' top='#{buffy + 2}' left='5' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    anchor_ublinesilvv = nil
    builders[:silver_value] = lambda do
      return '' unless @settings['display-silver']
      anchor_ublinesilvv = ub_top_anchor_right unless anchor_ublinesilvv
      ub_top_anchor_right = 'ubsilv'
      "<label id='ubsilv' value='#{add_commas(daily_silvers)}' justify='6' " \
      "anchor_left='ubsil' anchor_top='#{anchor_ublinesilvv}' top='#{buffy + 2}' left='0' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    # Optional bounty display
    anchor_ublinebountyl = nil
    builders[:bounty_label] = lambda do
      return '' unless @settings['display-bounty']
      anchor_ublinebountyl = ub_top_anchor_left unless anchor_ublinebountyl
      ub_top_anchor_left = 'ubbounty'
      "<label id='ubbounty' value='Bounty:' justify='4' anchor_left='ubinjury' " \
      "anchor_top='#{anchor_ublinebountyl}' top='#{buffy + 2}' left='5' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    anchor_ublinebountyv = nil
    builders[:bounty_value] = lambda do
      return '' unless @settings['display-bounty']
      anchor_ublinebountyv = ub_top_anchor_right unless anchor_ublinebountyv
      ub_top_anchor_right = 'ubbountyv'
      "<label id='ubbountyv' value='#{add_commas(bounty_points)}' justify='6' " \
      "anchor_left='ubbounty' anchor_top='#{anchor_ublinebountyv}' top='#{buffy + 2}' left='0' " \
      "height='#{sizey}' width='#{sizerx / 2}'/>"
    end

    # Vital bars
    builders[:bars_bg] = lambda do
      "<image id='ubbars' name='PanelBackground' justify='4' anchor_left='ubinjury' " \
      "align='n' top='#{buffy}' left='5' height='120' width='0'/>"
    end

    builders[:health_bar] = lambda do
      "<skin id='ubheal' name='healthBar' controls='health' anchor_left='ubinjury' " \
      "anchor_top='ubbars' top='#{buffy}' left='#{buffx + 1}' width='0' height='#{sizey}'/>" \
      "<progressBar id='health' value='#{Char.percent_health}' " \
      "text='#{Char.health}/#{Char.max_health}' customText='t' anchor_left='ubinjury' " \
      "anchor_top='ubbars' top='#{buffy}' left='#{buffx + 1}' " \
      "width='#{sizerx}' height='#{sizey}'/>"
    end

    builders[:mana_bar] = lambda do
      "<skin id='ubmana' name='manaBar' controls='mana' anchor_left='ubinjury' " \
      "anchor_top='ubheal' top='#{buffy}' left='#{buffx}' width='0' height='#{sizey}'/>" \
      "<progressBar id='mana' value='#{Char.percent_mana}' " \
      "text='#{Char.mana}/#{Char.max_mana}' customText='t' anchor_left='ubinjury' " \
      "anchor_top='health' top='#{buffy}' left='#{buffx + 1}' " \
      "width='#{sizerx}' height='#{sizey}'/>"
    end

    builders[:stamina_bar] = lambda do
      "<skin id='ubstam' name='staminaBar' controls='stamina' anchor_left='ubinjury' " \
      "anchor_top='ubmana' top='#{buffy}' left='#{buffx + 1}' width='0' height='#{sizey}'/>" \
      "<progressBar id='stamina' value='#{Char.percent_stamina}' " \
      "text='#{Char.stamina}/#{Char.max_stamina}' customText='t' anchor_left='ubinjury' " \
      "anchor_top='mana' top='#{buffy}' left='#{buffx + 1}' " \
      "width='#{sizerx}' height='#{sizey}'/>"
    end

    builders[:spirit_bar] = lambda do
      ub_bottom_anchor = 'ubspir'
      "<skin id='ubspir' name='spiritBar' controls='spirit' anchor_left='ubinjury' " \
      "anchor_top='ubstam' top='#{buffy}' left='#{buffx + 1}' width='0' height='#{sizey}'/>" \
      "<progressBar id='spirit' value='#{Char.percent_spirit}' " \
      "text='#{Char.spirit}/#{Char.max_spirit}' customText='t' anchor_left='ubinjury' " \
      "anchor_top='stamina' top='#{buffy}' left='#{buffx + 1}' " \
      "width='#{sizerx}' height='#{sizey}'/>"
    end

    # Optional favor display
    builders[:favor_label] = lambda do
      return '' unless @settings['display-favor']
      "<label id='ubfavor' value='Favor' anchor_top='ubinjury' top='#{buffy + 2}' " \
      "left='0' height='#{sizey}' width='#{sizerx}'/>"
    end

    builders[:favor_value] = lambda do
      return '' unless @settings['display-favor']
      "<label id='ubfavorv' value='#{add_commas(Resources.voln_favor)}' " \
      "anchor_top='ubfavor' top='#{buffy}' left='0' " \
      "height='#{sizey}' width='#{sizerx}'/>"
    end

    # Experience bars with proper anchor tracking
    anchor_ublineascnext = nil
    builders[:atp_bar] = lambda do
      return '' unless @settings['display-atp']
      anchor_ublineascnext = ub_bottom_anchor unless anchor_ublineascnext
      ub_bottom_anchor = 'ubascnext'
      progress = 100.0 - (asc_state[:next_atp].to_f / 50_000.0 * 100)
      "<progressBar id='ubascnext' value='#{progress}' " \
      "text='#{asc_state[:next_atp]} until next ATP [ #{asc_state[:total_points]} ]' " \
      "anchor_top='#{anchor_ublineascnext}' top='#{buffy}' left='#{buffx}' " \
      "width='#{sizebx}' height='#{sizey}'/>"
    end

    anchor_ublinenext = nil
    builders[:tp_bar] = lambda do
      return '' unless @settings['display-tp']
      anchor_ublinenext = ub_bottom_anchor unless anchor_ublinenext
      ub_bottom_anchor = 'ubnext'
      "<progressBar id='ubnext' value='#{exp_state[:value]}' text='#{exp_state[:text]}' " \
      "anchor_top='#{anchor_ublinenext}' top='#{buffy}' left='#{buffx}' " \
      "width='#{sizebx}' height='#{sizey}'/>"
    end

    anchor_ublinemind = nil
    builders[:mind_bar] = lambda do
      anchor_ublinemind = ub_bottom_anchor unless anchor_ublinemind
      ub_bottom_anchor = 'ubmind'
      mind_text = XMLData.mind_text
      mind_text += " (#{Experience.fxp_current}/#{Experience.fxp_max})" if @settings['display-fxp']
      "<progressBar id='ubmind' value='#{XMLData.mind_value}' text='#{mind_text}' " \
      "customText='t' anchor_top='#{anchor_ublinemind}' top='#{buffy}' left='#{buffx}' " \
      "width='#{sizebx}' height='#{sizey}'/>"
    end

    anchor_ublinestan = nil
    builders[:stance_bar] = lambda do
      anchor_ublinestan = ub_bottom_anchor unless anchor_ublinestan
      ub_bottom_anchor = 'ubstnc'
      "<progressBar id='ubstnc' value='#{XMLData.stance_value}' " \
      "text='#{XMLData.stance_text}' anchor_top='#{anchor_ublinestan}' top='#{buffy}' " \
      "left='#{buffx}' width='#{sizebx}' height='#{sizey}'/>"
    end

    anchor_ublineencm = nil
    builders[:encumbrance_bar] = lambda do
      anchor_ublineencm = ub_bottom_anchor unless anchor_ublineencm
      ub_bottom_anchor = 'ubencm'
      "<progressBar id='ubencm' value='#{XMLData.encumbrance_value}' " \
      "text='#{XMLData.encumbrance_text}' anchor_top='#{anchor_ublineencm}' top='#{buffy}' " \
      "left='#{buffx}' width='#{sizebx}' height='#{sizey}'/>"
    end

    # Resource bars with proper anchor tracking
    anchor_ublineresource = nil
    builders[:resource_weekly] = lambda do
      return '' unless @settings['display-resources']
      anchor_ublineresource = ub_bottom_anchor unless anchor_ublineresource
      progress = (Resources.weekly.to_f / 50_000.to_f) * 100
      "<progressBar id='ubresource_cur' value='#{progress}' " \
      "text='#{add_commas(Resources.weekly)}/#{add_commas(50_000)}' " \
      "anchor_top='#{anchor_ublineresource}' top='#{buffy}' left='#{buffx}' " \
      "width='#{sizebx / 2 - buffx}' height='#{sizey}'/>"
    end

    builders[:resource_total] = lambda do
      return '' unless @settings['display-resources']
      ub_bottom_anchor = 'ubresource_cur'
      progress = (Resources.total.to_f / 200_000.to_f) * 100
      "<progressBar id='ubresource_total' value='#{progress}' " \
      "text='#{add_commas(Resources.total)}/#{add_commas(200_000)}' " \
      "anchor_top='#{anchor_ublineresource}' anchor_left='ubresource_cur' " \
      "top='#{buffy}' left='#{buffx}' width='#{sizebx / 2}' height='#{sizey}'/>"
    end

    # Shadow essence bar for Sorcerers
    anchor_ublineessence = nil
    builders[:shadow_essence] = lambda do
      return '' unless @settings['display-shadow-essence'] && Stats.profession == 'Sorcerer'
      anchor_ublineessence = ub_bottom_anchor unless anchor_ublineessence
      ub_bottom_anchor = 'ubessence'
      essence = Resources.shadow_essence || 0
      progress = (essence.to_f / 5.0) * 100
      "<progressBar id='ubessence' value='#{progress}' text='Essence #{essence}/5' " \
      "anchor_top='#{anchor_ublineessence}' top='#{buffy}' left='#{buffx}' " \
      "width='#{sizebx}' height='#{sizey}'/>"
    end

    # Percent capped bar
    anchor_ublinepcapped = nil
    builders[:percent_capped] = lambda do
      return '' unless @settings['display-percentcap']
      anchor_ublinepcapped = ub_bottom_anchor unless anchor_ublinepcapped
      ub_bottom_anchor = 'ubpcapped'
      percent = ((Experience.txp).fdiv(7_572_500) * 100).round(2)
      "<progressBar id='ubpcapped' value='#{percent}' text='#{percent} % Capped' " \
      "anchor_top='#{anchor_ublinepcapped}' top='#{buffy}' left='#{buffx}' " \
      "width='#{sizebx}' height='#{sizey}'/>"
    end

    builders
  end

  # Build the initial UI display
  # @param builders [Hash] hash of UI builder lambdas
  # @param old_wounds [Array] initial wound state
  # @return [String] complete XML for initial UI
  # @private
  # @since 2.0.0
  def self.build_initial_ui(builders, _old_wounds)
    header = [
      "<closeDialog id='UberBar'/>",
      "<openDialog type='dynamic' id='UberBar' title='#{Char.name}'s Uberbar' " \
      "target='UberBar' location='main' height='282' width='190' resident='true'>",
      "<dialogData id='UberBar' clear='t'>",
      "<skin id='ubinjury' name='InjuriesPanel' " \
      "controls='nsys,leftArm,rightArm,rightLeg,leftLeg,head,rightFoot,leftFoot," \
      "rightHand,leftHand,rightEye,leftEye,back,neck,chest,abdomen' " \
      "top='5' left='5' width='100' height='150' align='nw'/>"
    ].join

    ui_elements = [
      builders[:log_label].call,
      builders[:hour_label].call,
      builders[:pulse_label].call,
      builders[:room_label].call,
      builders[:silver_label].call,
      builders[:bounty_label].call,
      builders[:log_value].call,
      builders[:hour_value].call,
      builders[:pulse_value].call,
      builders[:room_value].call,
      builders[:silver_value].call,
      builders[:bounty_value].call,
      builders[:bars_bg].call,
      builders[:health_bar].call,
      builders[:mana_bar].call,
      builders[:stamina_bar].call,
      builders[:spirit_bar].call,
      builders[:atp_bar].call,
      builders[:tp_bar].call,
      builders[:mind_bar].call,
      builders[:stance_bar].call,
      builders[:encumbrance_bar].call,
      builders[:percent_capped].call
    ].join

    # Add favor display if applicable
    if Society.status =~ /Voln/
      ui_elements += [
        builders[:favor_label].call,
        builders[:favor_value].call
      ].join
    end

    # Add profession resources if applicable
    if profession_resource_available?
      ui_elements += [
        builders[:resource_weekly].call,
        builders[:resource_total].call
      ].join
    end

    # Add shadow essence for Sorcerers if enabled
    if @settings['display-shadow-essence'] && Stats.profession == 'Sorcerer'
      ui_elements += builders[:shadow_essence].call
    end

    header + generate_full_wounds_display + ui_elements + '</dialogData></openDialog>'
  end

  # Check for character stat changes and generate update XML
  # @param char_state [Hash] character state tracking
  # @param builders [Hash] UI builder lambdas
  # @return [Array<String>] array of XML update strings
  # @private
  # @since 2.0.0
  def self.check_stat_changes(char_state, builders)
    updates = []

    if char_state[:health] != Char.health
      echo 'updated health' if @settings['display-debug']
      char_state[:health] = Char.health
      updates << builders[:health_bar].call
    end

    if char_state[:mana] != Char.mana
      echo 'updated mana' if @settings['display-debug']
      char_state[:mana] = Char.mana
      updates << builders[:mana_bar].call
    end

    if char_state[:stamina] != Char.stamina
      echo 'updated stamina' if @settings['display-debug']
      char_state[:stamina] = Char.stamina
      updates << builders[:stamina_bar].call
    end

    if char_state[:spirit] != Char.spirit
      echo 'updated spirit' if @settings['display-debug']
      char_state[:spirit] = Char.spirit
      updates << builders[:spirit_bar].call
    end

    updates
  end

  # Check for character state changes and generate update XML
  # @param char_state [Hash] character state tracking
  # @param builders [Hash] UI builder lambdas
  # @return [Array<String>] array of XML update strings
  # @private
  # @since 2.0.0
  def self.check_state_changes(char_state, builders)
    updates = []

    if char_state[:mind] != XMLData.mind_text
      echo 'updated mind' if @settings['display-debug']
      char_state[:mind] = XMLData.mind_text
      updates << builders[:mind_bar].call
    end

    if char_state[:stance] != XMLData.stance_text
      echo 'updated stance' if @settings['display-debug']
      char_state[:stance] = XMLData.stance_text
      updates << builders[:stance_bar].call
    end

    if char_state[:encumbrance] != XMLData.encumbrance_text
      echo 'updated encumbr' if @settings['display-debug']
      char_state[:encumbrance] = XMLData.encumbrance_text
      updates << builders[:encumbrance_bar].call
    end

    if char_state[:room] != Room.current.id
      echo 'updated room' if @settings['display-debug']
      char_state[:room] = Room.current.id
      updates << builders[:room_value].call
    end

    updates
  end

  # Check for resource changes and generate update XML
  # @param exp_state [Hash] experience state tracking
  # @param builders [Hash] UI builder lambdas
  # @return [Array<String>] array of XML update strings
  # @private
  # @since 2.0.0
  def self.check_resource_changes(exp_state, builders)
    updates = []

    if exp_state[:old_bank] != daily_silvers
      echo 'updated bank' if @settings['display-debug']
      exp_state[:old_bank] = daily_silvers
      updates << builders[:silver_value].call
    end

    if exp_state[:old_bounty] != bounty_points
      echo 'updated bounty' if @settings['display-debug']
      exp_state[:old_bounty] = bounty_points
      updates << builders[:bounty_value].call
    end

    if exp_state[:old_favor] != Resources.voln_favor
      echo 'updated favor' if @settings['display-debug']
      exp_state[:old_favor] = Resources.voln_favor
      updates << builders[:favor_value].call
    end

    if @settings['display-shadow-essence'] &&
       Stats.profession == 'Sorcerer' &&
       exp_state[:old_shadow_essence] != Resources.shadow_essence
      echo 'updated shadow essence' if @settings['display-debug']
      exp_state[:old_shadow_essence] = Resources.shadow_essence
      updates << builders[:shadow_essence].call
    end

    updates
  end

  # Perform periodic experience and resource checks
  # @param asc_state [Hash] ascension state tracking
  # @return [void]
  # @private
  # @since 2.0.0
  def self.perform_periodic_checks(asc_state)
    # Check experience if any ATP/TP/FXP/percent displays are enabled
    if @settings['display-fxp'] ||
       @settings['display-atp'] ||
       @settings['display-tp'] ||
       @settings['display-percentcap']
      exp_data = check_experience
      asc_state[:next_atp] = exp_data[:asc_next] if exp_data[:asc_next]
      asc_state[:total_points] = exp_data[:asc_tps] if exp_data[:asc_tps]
    end

    # Check resources if any resource displays are enabled
    if @settings['display-resources'] ||
       @settings['display-favor'] ||
       @settings['display-shadow-essence']
      Lich::Util.quiet_command_xml('resource', /<output class="mono"\/>/, /<prompt time=/)
    end
  end

  # Check for experience changes and generate update XML
  # @param char_state [Hash] character state tracking
  # @param exp_state [Hash] experience state tracking
  # @param asc_state [Hash] ascension state tracking
  # @param capped [Boolean] whether character is level-capped
  # @param first_pulse [Boolean] whether this is the first experience pulse
  # @param builders [Hash] UI builder lambdas
  # @return [Array<String>] array of XML update strings
  # @private
  # @since 2.0.0
  def self.check_experience_changes(char_state, exp_state, asc_state, capped, first_pulse, builders)
    return [] if char_state[:experience] == XMLData.next_level_text &&
                 Experience.axp == asc_state[:experience]

    updates = []
    echo 'updated next_level' if @settings['display-debug']

    # Calculate ascension pulse
    if asc_state[:experience] != 0
      asc_state[:pulse] = Experience.axp - asc_state[:experience]
    end
    asc_state[:experience] = Experience.axp

    # Parse experience values
    xp_values = calculate_experience_values(XMLData.next_level_text, capped)

    # Calculate experience gained this pulse
    experience_gained = exp_state[:old] - xp_values[:current]
    experience_gained = -experience_gained if experience_gained < 0
    experience_gained = 0 if experience_gained > 2499

    # Handle first pulse initialization
    if first_pulse
      exp_state[:first_time] = Time.now - 1
      exp_state[:total] = 0
      asc_state[:total_earned] = 0
      experience_gained = 0
    end

    # Update experience tracking
    exp_state[:current] = xp_values[:current]
    exp_state[:value] = xp_values[:value]
    exp_state[:text] = xp_values[:text]
    exp_state[:last_pulse] = experience_gained

    total_gained = experience_gained + asc_state[:pulse]
    exp_state[:total] += total_gained
    asc_state[:total_earned] += asc_state[:pulse]

    UserVars.uberbar_xp_per_day += total_gained
    UserVars.save

    # Calculate experience per hour
    time_elapsed_hours = (exp_state[:current_time] - exp_state[:first_time]) / 3600.0
    exp_state[:per_hour] = (exp_state[:total] / time_elapsed_hours).to_i

    exp_state[:old] = xp_values[:current]
    char_state[:experience] = XMLData.next_level_text

    # Output loud experience notification if enabled
    if @settings['display-loudxp'] && experience_gained > 0
      echo sprintf('********  %2s EXP Gained this Pulse ********* (%2s)+',
                   experience_gained, Time.now.strftime('%X'))
    end

    # Generate update XML
    updates << builders[:atp_bar].call
    updates << builders[:tp_bar].call
    updates << builders[:log_value].call
    updates << builders[:hour_value].call
    updates << builders[:pulse_value].call
    updates << builders[:mind_bar].call

    if profession_resource_available?
      updates << builders[:resource_weekly].call
      updates << builders[:resource_total].call
    end

    updates << builders[:percent_capped].call

    updates
  end

  # Check for injury changes and generate update XML
  # @param char_state [Hash] character state tracking
  # @param old_wounds [Array] previous wound state
  # @param builders [Hash] UI builder lambdas (not used but kept for consistency)
  # @return [Array<String>] array of XML update strings
  # @private
  # @since 2.0.0
  def self.check_injury_changes(char_state, old_wounds, _builders)
    return [] if char_state[:injuries] == XMLData.injuries.to_s

    echo 'updated injuries' if @settings['display-debug']

    updates = []
    new_wounds = calculate_wounds_hash

    new_wounds.each_with_index do |wound_value, index|
      if old_wounds[index] != wound_value
        updates << generate_wound_change_display(BODY_AREA_ORDER[index])
      end
    end

    char_state[:injuries] = XMLData.injuries.to_s
    old_wounds.replace(new_wounds)

    updates
  end
end

# Handle command-line interface
if Script.current.vars[1] =~ /help/
  script_version = (Script.list.find { |s| s.name == Script.current.name }.inspect)[/version: (\d+\.\d+\.\d+)/i, 1]

  help_lines = [
    "#{Script.current.name} Version: #{script_version}",
    "",
    "  Creates a Wrayth window with injury panel, vitals, and other useful information.",
    "",
    "  Configuration options are below:",
    "",
    "     --display-silver=<on|off>        - Turns on/off silver tracker display " \
      "(requires #{$lich_char}bank or #{$lich_char}ledger to work)",
    "     --display-bounty=<on|off>        - Turns on/off Bounty point tracker display " \
      "(requires #{$lich_char}bank or #{$lich_char}hud_bounty to work)",
    "     --display-room=<on|off>          - Turns on/off Lich Room # display",
    "     --display-favor=<on|off>         - Turns on/off Order of Voln favor display",
    "     --display-atp=<on|off>           - Turns on/off experience till next ATP bar",
    "     --display-tp=<on|off>            - Turns on/off experience till next TP bar",
    "     --display-fxp=<on|off>           - Turns on/off Field Experience shown in mindstate bar",
    "     --display-resources=<on|off>     - Turns on/off Profession Resource bars",
    "     --display-shadow-essence=<on|off> - Turns on/off Shadow Essence bar (Sorcerers only)",
    "     --display-percentcap=<on|off>    - Turns on/off Percent Capped bar",
    "     --display-loudxp=<on|off>        - Turns on/off loud exp pulses",
    "     --display-debug=<on|off>         - Turns on/off debug messaging",
    "     --silent-check-interval=<NUMBER> - Delay in seconds between checking EXP and/or RESOURCE",
    "",
    "  Disabling atp, tp, fxp, percentcap will prevent periodic EXPERIENCE checks",
    "  Disabling favor, resources, & shadow-essence will prevent periodic RESOURCE checks",
    ""
  ]

  help_lines.each do |line|
    Lich::Messaging.mono(Lich::Messaging.xml_encode(line))
  end

elsif Script.current.vars[1] =~ /list/
  echo JSON.pretty_generate(CharSettings[:settings])

elsif Script.current.vars[1]
  UberBarEO.set_vars

else
  UberBarEO.main
end
