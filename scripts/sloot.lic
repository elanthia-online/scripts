##quiet
## vim: set ft=ruby:
=begin

    SpiffyLoot by SpiffyJr

		maintained by: Elanthia-Online
		author: SpiffyJr
		name: SpiffyLoot
		tags: loot
		version: 3.5.gtk3

		Note: This is the GTK3 version of "old sloot" updated for GTK3 (Lich5) support by Demandred, previously uploaded as gtk3-sloot.lic on repo. Due to issues found in sloot 2.0.2, that version has been pulled and temporarily replaced by this version until 2.0.2 can be stabilized with a future version. This will be updated once that occurs.  

    changelog:
        3.5 (2020-03-19)
            Removing Gtk::Tooltips to prep for Gtk3
        3.4 (2019-01-15)
            Attempting fix for finding sacks for item TYPE in any order
        3.3 (2017-12-18)
            Attempting to fix phasing for sorcerors.
            Reorder changelog, new shit on top, duh.
        3.2 (2016-06-19)
            Updated the get_item and put_item code to not care about your container
        3.1 (2016-01-27)
            Added ability to try and sell boxes at pawn (useful for after a lockpick session if you keep mithril ones)
            Added ability to sell scarabs at the gemshop
        3.0 (2015-11-19)
            Add massive boulder skinning as a rolled up krynch sushi roll
=end

### TMP - bramble patch lewt
str = GameObj.type_data["gem"][:name].to_s

if str !~ /berry|thorn/
  GameObj.type_data["gem"][:name] = Regexp.new(str.sub("(?-mix:", "").sub(")$)", "|berry|thorn)$"))
  GameObj.sellable_data["gemshop"][:name] = Regexp.new(GameObj.sellable_data["gemshop"][:name].to_s.sub("(?-mix:", "").sub("$)", "|berry$|thorn$"))
end

str = GameObj.type_data["skin"][:name].to_s

if str !~ /shriveled cutting/
  GameObj.type_data["skin"][:name] = Regexp.new(GameObj.type_data["skin"][:name].to_s.sub("(?-mix:", "").sub(")s?$)", "|shriveled cutting|dessicated stem|frosted branch)s?$"))
  GameObj.sellable_data["furrier"][:name] = Regexp.new(GameObj.sellable_data["furrier"][:name].to_s.sub("(?-mix:", "").sub(")s?$)", "|shriveled cutting|dessicated stem|frosted branch)s?$"))
end
### TMP

putregex = /^You (?:put|(?:discreetly )?tuck|attempt to shield your|place|.* place|slip|wipe off the blade and sheathe|absent-mindedly drop|carefully add|find an incomplete bundle|untie your drawstring pouch)|^The .+ is already a bundle|^Your bundle would be too large if you if you tried to add that|^The .+ is too large to be bundled\.|^As you place your .+ inside your .+, you notice another .+ inside the .+ and carefully arrange the two .+ into a neat bundle\./

settings = CharSettings.to_hash
settings["skin_exclude"] ||= Array.new
settings["loot_exclude"] ||= "drake|feras|black ora"
settings["sell_exclude"] ||= "gold ring|(?:gold|aquamarine) wand|(?:white|black) crystal"

$sloot_has_disk ||= false
$sloot_disk_full ||= false
$sloot_searched ||= false
$sloot_hooks ||= Array.new
$sloot_locker_full ||= false

closed_sacks = Array.new
prev_stance = checkstance
skin_prepared = false
skin_empty_hands = false
sacks = Hash.new
skinweaponcurrent = nil
skinweapon = nil
skinweaponblunt = nil

change_stance = proc { |stance|
  loop {
    break if (checkstance == stance) or (stance == "defensive" and checkstance 80)

    res = dothistimeout "stance #{stance}", 2, /You are now|Roundtime|Wait|wait|You move into/
    if res =~ /Roundtime: (\d+)|wait (\d+)/i
      sleep (($1 or $2).strip.to_f - 1)
    end
  }
}

go2 = proc { |room|
  next if Room.current.id.to_s == room.to_s

  wait_while { running?("go2") }
  start_script("go2", [room.to_s, "_disable_confirm_"])
  wait_while { running?("go2") }
}

msg = proc { |str|
  echo str
}

setup = proc {
  gtk_globals = Hash.new
  gtk_locals = Hash.new

  window = window_action = nil

  Gtk.queue {
    gtk_globals["ammosack"] = Gtk::Entry.new
		gtk_globals["ammosack"].text = (UserVars.ammosack ||= '')
    gtk_globals["boxsack"] = Gtk::Entry.new
    gtk_globals["boxsack"].text = (UserVars.boxsack ||= '')
    gtk_globals["foragesack"] = Gtk::Entry.new
    gtk_globals["foragesack"].text = (UserVars.foragesack ||= '')
    gtk_globals["gemsack"] = Gtk::Entry.new
    gtk_globals["gemsack"].text = (UserVars.gemsack ||= '')
    gtk_globals["herbsack"] = Gtk::Entry.new
    gtk_globals["herbsack"].text = (UserVars.herbsack ||= '')
    gtk_globals["jewelrysack"] = Gtk::Entry.new
    gtk_globals["jewelrysack"].text = (UserVars.jewelrysack ||= '')
    gtk_globals["lockpicksack"] = Gtk::Entry.new
    gtk_globals["lockpicksack"].text = (UserVars.lockpicksack ||= '')
    gtk_globals["magicsack"] = Gtk::Entry.new
    gtk_globals["magicsack"].text = (UserVars.magicsack ||= '')
    gtk_globals["reagentsack"] = Gtk::Entry.new
    gtk_globals["reagentsack"].text = (UserVars.reagentsack ||= '')
    gtk_globals["scrollsack"] = Gtk::Entry.new
    gtk_globals["scrollsack"].text = (UserVars.scrollsack ||= '')
    gtk_globals["skinsack"] = Gtk::Entry.new
    gtk_globals["skinsack"].text = (UserVars.skinsack ||= '')
    gtk_globals["uncommonsack"] = Gtk::Entry.new
    gtk_globals["uncommonsack"].text = (UserVars.uncommonsack ||= '')
    gtk_globals["valuablesack"] = Gtk::Entry.new
    gtk_globals["valuablesack"].text = (UserVars.valuablesack ||= '')
    gtk_globals["clothingsack"] = Gtk::Entry.new
    gtk_globals["clothingsack"].text = (UserVars.clothingsack ||= '')
    gtk_globals["wandsack"] = Gtk::Entry.new
    gtk_globals["wandsack"].text = (UserVars.wandsack ||= '')
    gtk_globals["skinweapon"] = Gtk::Entry.new
    gtk_globals["skinweapon"].text = (UserVars.skinweapon ||= '')
    gtk_globals["skinweaponblunt"] = Gtk::Entry.new
    gtk_globals["skinweaponblunt"].text = (UserVars.skinweaponblunt ||= '')
    gtk_globals["skinweaponsack"] = Gtk::Entry.new
    gtk_globals["skinweaponsack"].text = (UserVars.skinweaponsack ||= '')
    gtk_locals["locker"] = Gtk::Entry.new
    gtk_locals["locker"].text = (settings["locker"] ||= '')
    gtk_locals["locker_in"] = Gtk::Entry.new
    gtk_locals["locker_in"].text = (settings["locker_in"] ||= '')
    gtk_locals["locker_out"] = Gtk::Entry.new
    gtk_locals["locker_out"].text = (settings["locker_out"] ||= '')

    gtk_locals["enable_close_sacks"] = Gtk::CheckButton.new("(?) Keep sacks shut")
    gtk_locals["enable_close_sacks"].active = (settings["enable_close_sacks"] ||= false)
    gtk_locals["overflowsack"] = Gtk::Entry.new
    gtk_locals["overflowsack"].text = (settings["overflowsack"] ||= '')
    gtk_locals["loot_exclude"] = Gtk::Entry.new
    gtk_locals["loot_exclude"].text = (settings["loot_exclude"] ||= '')
    gtk_locals["critter_exclude"] = Gtk::Entry.new
    gtk_locals["critter_exclude"].text = (settings["critter_exclude"] ||= '')
    gtk_locals["enable_search_all"] = Gtk::CheckButton.new("(?) Search all dead")
    gtk_locals["enable_search_all"].active = (settings["enable_search_all"] ||= false)
    gtk_locals["enable_loot_box"] = Gtk::CheckButton.new("Boxes")
    gtk_locals["enable_loot_box"].active = (settings["enable_loot_box"] ||= false)
    gtk_locals["enable_loot_gem"] = Gtk::CheckButton.new("Gems")
    gtk_locals["enable_loot_gem"].active = (settings["enable_loot_gem"] ||= false)
    gtk_locals["enable_loot_herb"] = Gtk::CheckButton.new("Herbs")
    gtk_locals["enable_loot_herb"].active = (settings["enable_loot_herb"] ||= false)
    gtk_locals["enable_loot_jewelry"] = Gtk::CheckButton.new("Jewelry")
    gtk_locals["enable_loot_jewelry"].active = (settings["enable_loot_jewelry"] ||= false)
    gtk_locals["enable_loot_lockpick"] = Gtk::CheckButton.new("Lockpicks")
    gtk_locals["enable_loot_lockpick"].active = (settings["enable_loot_lockpick"] ||= false)
    gtk_locals["enable_loot_magic"] = Gtk::CheckButton.new("Magical")
    gtk_locals["enable_loot_magic"].active = (settings["enable_loot_magic"] ||= false)
    gtk_locals["enable_loot_reagent"] = Gtk::CheckButton.new("Reagents")
    gtk_locals["enable_loot_reagent"].active = (settings["enable_loot_reagent"] ||= false)
    gtk_locals["enable_loot_scroll"] = Gtk::CheckButton.new("Scrolls")
    gtk_locals["enable_loot_scroll"].active = (settings["enable_loot_scroll"] ||= false)
    gtk_locals["enable_loot_skin"] = Gtk::CheckButton.new("Skins")
    gtk_locals["enable_loot_skin"].active = (settings["enable_loot_skin"] ||= false)
    gtk_locals["enable_loot_uncommon"] = Gtk::CheckButton.new("Uncommon")
    gtk_locals["enable_loot_uncommon"].active = (settings["enable_loot_uncommon"] ||= false)
    gtk_locals["enable_loot_valuable"] = Gtk::CheckButton.new("Valuables")
    gtk_locals["enable_loot_valuable"].active = (settings["enable_loot_valuable"] ||= false)
    gtk_locals["enable_loot_clothing"] = Gtk::CheckButton.new("Clothings")
    gtk_locals["enable_loot_clothing"].active = (settings["enable_loot_clothing"] ||= false)
    gtk_locals["enable_loot_wand"] = Gtk::CheckButton.new("Wands")
    gtk_locals["enable_loot_wand"].active = (settings["enable_loot_wand"] ||= false)
    gtk_locals["enable_disking"] = Gtk::CheckButton.new("(?) Disking")
    gtk_locals["enable_disking"].active = (settings["enable_disking"] ||= false)
    gtk_locals["enable_phasing"] = Gtk::CheckButton.new("(?) Phasing")
    gtk_locals["enable_phasing"].active = (settings["enable_phasing"] ||= false)
    gtk_locals["enable_gather"] = Gtk::CheckButton.new("(?) Gather ammo")
    gtk_locals["enable_gather"].active = (settings["enable_gather"] ||= false)
    gtk_locals["ammo_name"] = Gtk::Entry.new
    gtk_locals["ammo_name"].text = (settings["ammo_name"] ||= '')
    gtk_locals["enable_safe_hiding"] = Gtk::CheckButton.new("(?) Safe hiding")
    gtk_locals["enable_safe_hiding"].active = (settings["enable_safe_hiding"] ||= false)
    gtk_locals["safe_ignore"] = Gtk::Entry.new
    gtk_locals["safe_ignore"].text = (settings["safe_ignore"] ||= '')
    gtk_locals["enable_stow_left"] = Gtk::CheckButton.new("(?) Stow left hand")
    gtk_locals["enable_stow_left"].active = (settings["enable_stow_left"] ||= false)
    gtk_locals["enable_stance_on_start"] = Gtk::CheckButton.new("(?) Stance on start")
    gtk_locals["enable_stance_on_start"].active = (settings["enable_stance_on_start"] ||= false)
    gtk_locals["enable_self_drops"] = Gtk::CheckButton.new("(?) Self loot only")
    gtk_locals["enable_self_drops"].active = (settings["enable_self_drops"] ||= false)
    gtk_locals["enable_skinning"] = Gtk::CheckButton.new("(?) Enable skinning")
    gtk_locals["enable_skinning"].active = (settings["enable_skinning"] ||= false)
    gtk_locals["enable_skin_alternate"] = Gtk::CheckButton.new("(?) Enable alternate")
    gtk_locals["enable_skin_alternate"].active = (settings["enable_skin_alternate"] ||= false)
    gtk_locals["enable_skin_offensive"] = Gtk::CheckButton.new("(?) Skin in offensive")
    gtk_locals["enable_skin_offensive"].active = (settings["enable_skin_offensive"] ||= false)
    gtk_locals["enable_skin_kneel"] = Gtk::CheckButton.new("(?) Kneel to skin")
    gtk_locals["enable_skin_kneel"].active = (settings["enable_skin_kneel"] ||= false)
    gtk_locals["enable_skin_safe_mode"] = Gtk::CheckButton.new("(?) Safe mode")
    gtk_locals["enable_skin_safe_mode"].active = (settings["enable_skin_safe_mode"] ||= false)
    gtk_locals["enable_skin_stance_first"] = Gtk::CheckButton.new("(?) Stance first")
    gtk_locals["enable_skin_stance_first"].active = (settings["enable_skin_stance_first"] ||= false)
    gtk_locals["enable_skin_604"] = Gtk::CheckButton.new("(?) Use 604")
    gtk_locals["enable_skin_604"].active = (settings["enable_skin_604"] ||= false)
    gtk_locals["enable_skin_sigil"] = Gtk::CheckButton.new("(?) Use Sigil of Resolve")
    gtk_locals["enable_skin_sigil"].active = (settings["enable_skin_sigil"] ||= false)
    #gtk_locals['enable_skin_stats'] = Gtk::CheckButton.new('(?) Track statistics')
    #gtk_locals['enable_skin_stats'] = Gtk::CheckButton.new('(?) Track statistics').set_active(settings['enable_skin_stats']).set_sensitive(false)
    gtk_locals["skin_stand_verb"] = Gtk::Entry.new
    gtk_locals["skin_stand_verb"].text = (settings["skin_stand_verb"] ||= '')
    gtk_locals["enable_sell_type_gem"] = Gtk::CheckButton.new("Gems")
    gtk_locals["enable_sell_type_gem"].active = (settings["enable_sell_type_gem"] ||= false)
    gtk_locals["enable_sell_type_valuable"] = Gtk::CheckButton.new("Valuables")
    gtk_locals["enable_sell_type_valuable"].active = (settings["enable_sell_type_valuable"] ||= false)
    gtk_locals["enable_sell_type_clothing"] = Gtk::CheckButton.new("Clothings")
    gtk_locals["enable_sell_type_clothing"].active = (settings["enable_sell_type_clothing"] ||= false)
    gtk_locals["enable_sell_type_jewelry"] = Gtk::CheckButton.new("Jewelry")
    gtk_locals["enable_sell_type_jewelry"].active = (settings["enable_sell_type_jewelry"] ||= false)
    gtk_locals["enable_sell_type_lockpick"] = Gtk::CheckButton.new("Lockpicks")
    gtk_locals["enable_sell_type_lockpick"].active = (settings["enable_sell_type_lockpick"] ||= false)
    gtk_locals["enable_sell_type_magic"] = Gtk::CheckButton.new("Magical")
    gtk_locals["enable_sell_type_magic"].active = (settings["enable_sell_type_magic"] ||= false)
    gtk_locals["enable_sell_type_reagent"] = Gtk::CheckButton.new("Reagents")
    gtk_locals["enable_sell_type_reagent"].active = (settings["enable_sell_type_reagent"] ||= false)
    gtk_locals["enable_sell_type_scroll"] = Gtk::CheckButton.new("Scrolls")
    gtk_locals["enable_sell_type_scroll"].active = (settings["enable_sell_type_scroll"] ||= false)
    gtk_locals["enable_sell_type_skin"] = Gtk::CheckButton.new("Skins")
    gtk_locals["enable_sell_type_skin"].active = (settings["enable_sell_type_skin"] ||= false)
    gtk_locals["enable_sell_type_scarab"] = Gtk::CheckButton.new("Scarabs to gemshop")
    gtk_locals["enable_sell_type_scarab"].active = (settings["enable_sell_type_scarab"] ||= false)
    gtk_locals["enable_sell_type_empty_box"] = Gtk::CheckButton.new("Boxes as empties")
    gtk_locals["enable_sell_type_empty_box"].active = (settings["enable_sell_type_empty_box"] ||= false)
    gtk_locals["enable_sell_type_wand"] = Gtk::CheckButton.new("Wands")
    gtk_locals["enable_sell_type_wand"].active = (settings["enable_sell_type_wand"] ||= false)
    gtk_locals["enable_sell_chronomage"] = Gtk::CheckButton.new("(?) Rings -> Chrono")
    gtk_locals["enable_sell_chronomage"].active = (settings["enable_sell_chronomage"] ||= false)
    gtk_locals["enable_sell_share_silvers"] = Gtk::CheckButton.new("(?) Share silvers")
    gtk_locals["enable_sell_share_silvers"].active = (settings["enable_sell_share_silvers"] ||= false)
    gtk_locals["sell_withdraw"] = Gtk::Entry.new
    gtk_locals["sell_withdraw"].text = (settings["sell_withdraw"] ||= '')
    gtk_locals["enable_sell_locksmith"] = Gtk::CheckButton.new("(?) Enable locksmith")
    gtk_locals["enable_sell_locksmith"].active = (settings["enable_sell_locksmith"] ||= false)
    gtk_locals["enable_locker_boxes"] = Gtk::CheckButton.new("(?) Enable lockering")
    gtk_locals["enable_locker_boxes"].active = (settings["enable_locker_boxes"] ||= false)
    gtk_locals["enable_sell_stockpile"] = Gtk::CheckButton.new("(?) Stockpile gems")
    gtk_locals["enable_sell_stockpile"].active = (settings["enable_sell_stockpile"] ||= false)
    #gtk_locals['enable_sell_force_bounty_gems'] = Gtk::CheckButton.new('(?) Force sell gems')
    #gtk_locals['enable_sell_force_bounty_gems'] = Gtk::CheckButton.new('(?) Force sell gems').set_active(settings['enable_sell_force_bounty_gems']).set_sensitive(false)
    gtk_locals["sell_exclude"] = Gtk::Entry.new
    gtk_locals["sell_exclude"].text = (settings["sell_exclude"] ||= '')

    # Signals
    gtk_locals["ammo_name"].sensitive = gtk_locals["enable_gather"].active?
    gtk_locals["enable_gather"].signal_connect("toggled") { gtk_locals["ammo_name"].sensitive = gtk_locals["enable_gather"].active? }

    gtk_locals["safe_ignore"].sensitive = gtk_locals["enable_safe_hiding"].active?
    gtk_locals["enable_safe_hiding"].signal_connect("toggled") { gtk_locals["safe_ignore"].sensitive = gtk_locals["enable_safe_hiding"].active? }

    # Primary Window
    window = Gtk::Window.new
    window.title = "SLoot configuration for #{Char.name}"
    window.border_width = 3
    window.resizable = false
    window.default_width = 450
	window.default_height = 300

    # Notebooks for tabs at the top
#    nb = Gtk::Notebook.new.set_show_border(true).set_tab_border(3)
    nb = Gtk::Notebook.new.set_show_border(true)

    #
    # Notebook Page 1 - Sacks
    #
#    vb_pg1 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg1 = Gtk::Box.new(:vertical, 1)

    #
    # Page 1, Frame 1 - Sacks
    #
#    vb_pg1_1 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg1_1 = Gtk::Box.new(:vertical, 1)
    fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Sacks</b></big>"))
    fr_pg1_1.add(vb_pg1_1)
    vb_pg1.pack_start(fr_pg1_1, false)

    lbl = Gtk::Label.new.set_markup("SLoot features sorting of loot by allowing you to specify " +
                                    "a sack for each type of loot. Use the fields below to set the sack(s) for " +
                                    "each loot type.")
    lbl.set_wrap(true).set_width_request(500).set_padding(0, 10)
    vb_pg1_1.pack_start(lbl, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Ammunition:")).set_width_request(100))
    hb.pack_start(gtk_globals["ammosack"], false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Boxes:")).set_width_request(100))
    hb.pack_start(gtk_globals["boxsack"], false)
    vb_pg1_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Gems:")).set_width_request(100))
    hb.pack_start(gtk_globals["gemsack"], false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Herbs:")).set_width_request(100))
    hb.pack_start(gtk_globals["herbsack"], false)
    vb_pg1_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Jewelry:")).set_width_request(100))
    hb.pack_start(gtk_globals["jewelrysack"], false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Lockpicks:")).set_width_request(100))
    hb.pack_start(gtk_globals["lockpicksack"], false)
    vb_pg1_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Magical:")).set_width_request(100))
    hb.pack_start(gtk_globals["magicsack"], false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Reagents:")).set_width_request(100))
    hb.pack_start(gtk_globals["reagentsack"], false)
    vb_pg1_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Scrolls:")).set_width_request(100))
    hb.pack_start(gtk_globals["scrollsack"], false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Skins:")).set_width_request(100))
    hb.pack_start(gtk_globals["skinsack"], false)
    vb_pg1_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Uncommon:")).set_width_request(100))
    hb.pack_start(gtk_globals["uncommonsack"], false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Wands:")).set_width_request(100))
    hb.pack_start(gtk_globals["wandsack"], false)
    vb_pg1_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Clothings:")).set_width_request(100))
    hb.pack_start(gtk_globals["clothingsack"], false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Valuables:")).set_width_request(100))
    hb.pack_start(gtk_globals["valuablesack"], false)

    vb_pg1_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("(?) Overflow:")).set_width_request(100), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["overflowsack"].set_width_request(419)))
    vb_pg1_1.pack_start(hb, false)

    #
    # Page 1, Frame 2 - Locker
    #
#    vb_pg1_2 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg1_2 = Gtk::Box.new(:vertical, 1)
    fr_pg1_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Locker</b></big>"))
    fr_pg1_2.add(vb_pg1_2)
    vb_pg1.pack_start(fr_pg1_2, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("(?) Locker:")), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["locker"]), false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("(?) Locker in:")), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["locker_in"]), false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("(?) Locker out:")), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["locker_out"]), false)
    vb_pg1_2.pack_start(hb, false)

    #
    # Page 1, Frame 3 - Advanced Options
    #
#    vb_pg1_3 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg1_3 = Gtk::Box.new(:vertical, 1)
    fr_pg1_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Advanced Options</b></big>"))
    fr_pg1_3.add(vb_pg1_3)
    vb_pg1.pack_start(fr_pg1_3, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_close_sacks"].set_width_request(150)), false)
    vb_pg1_3.pack_start(hb, false)

    lbl = Gtk::Label.new.set_markup("<span color=\"blue\" weight=\"bold\">Tip: (?) " +
                                    "in front of any option means you can hover over it for additional information.</span>")
    lbl.set_wrap(true).set_width_request(500).set_padding(0, 10)
    vb_pg1_1.pack_start(lbl, false)

    nb.append_page(vb_pg1, Gtk::Label.new("Sacks"))

    #
    # Notebook Page 2 - Looting
    #
#    vb_pg2 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg2 = Gtk::Box.new(:vertical, 1)

    #
    # Page 2, Frame 1 - Looting
    #
#    vb_pg2_1 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg2_1 = Gtk::Box.new(:vertical, 1)
    fr_pg2_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Looting</b></big>"))
    fr_pg2_1.add(vb_pg2_1)
    vb_pg2.pack_start(fr_pg2_1, false)

    lbl = Gtk::Label.new.set_markup("Use the options below to specify how " +
                                    "SLoot behaves when looting. Each checkbox represents a loot category which SLoot will only " +
                                    "pickup if checked. You can also enabled advanced features such as autolooting, disking/phasing " +
                                    "of boxes, and looting drops from critters you search.")
    lbl.set_wrap(true).set_width_request(500).set_padding(0, 10)
    vb_pg2_1.pack_start(lbl, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("(?) Exclude critters:")).set_width_request(100), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["critter_exclude"].set_width_request(419)))
    vb_pg2_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("(?) Exclude loot:")).set_width_request(100), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["loot_exclude"].set_width_request(419)))
    vb_pg2_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_search_all"].set_width_request(129)), false)
    vb_pg2_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_box"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_gem"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_herb"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_jewelry"].set_width_request(129)), false)
    vb_pg2_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_lockpick"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_magic"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_reagent"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_scroll"].set_width_request(129)), false)
    vb_pg2_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_skin"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_wand"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_uncommon"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_valuable"].set_width_request(129)), false)
    vb_pg2_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_loot_clothing"].set_width_request(129)), false)

    vb_pg2_1.pack_start(hb, false)

    #
    # Page 2, Frame 1 - Looting
    #
#    vb_pg2_2 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg2_2 = Gtk::Box.new(:vertical, 1)
    fr_pg2_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Advanced Options</b></big>"))
    fr_pg2_1.add(vb_pg2_2)
    vb_pg2.pack_start(fr_pg2_1, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_disking"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_stow_left"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_self_drops"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_stance_on_start"].set_width_request(129)), false)

    if Char.prof == "Sorcerer" and Char.level > 3 and Spell[704].known?
      hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_phasing"].set_width_request(129)), false)
    end

    vb_pg2_2.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 0).add(gtk_locals["enable_safe_hiding"].set_width_request(129)), false)
    hb.pack_start(gtk_locals["safe_ignore"], false)
    vb_pg2_2.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 0).add(gtk_locals["enable_gather"].set_width_request(129)), false)
    hb.pack_start(gtk_locals["ammo_name"], false)
    vb_pg2_2.pack_start(hb, false)

    nb.append_page(vb_pg2, Gtk::Label.new("Looting"))

    #
    # Notebook Page 3 - Skinning
    #
#    vb_pg3 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg3 = Gtk::Box.new(:vertical, 1)

    #
    # Page 3, Frame 1 - Skinning
    #
#    vb_pg3_1 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg3_1 = Gtk::Box.new(:vertical, 1)
    fr_pg3_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Skinning</b></big>"))
    fr_pg3_1.add(vb_pg3_1)
    vb_pg3.pack_start(fr_pg3_1, false)

    lbl = Gtk::Label.new.set_markup("The options below give you absolute control over skinning critters. " +
                                    "You can use your current weapon, an alternate weapon, left or right hand, and advanced enhancements " +
                                    "such as kneeling, stancing to offensive, Skinning (604) and Sigil of Resolve.")
    lbl.set_wrap(true).set_width_request(500).set_padding(0, 10)
    vb_pg3_1.pack_start(lbl, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_skinning"].set_width_request(129)), false)
    vb_pg3_1.pack_start(hb, false)

    #
    # Page 3, Frame 2 - Alternate Weapon
    #
#    vb_pg3_2 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg3_2 = Gtk::Box.new(:vertical, 1)
    fr_pg3_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Alternate Skinning Weapon</b></big>"))
    fr_pg3_2.add(vb_pg3_2)
    vb_pg3.pack_start(fr_pg3_2, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_skin_alternate"].set_width_request(129)), false)
    vb_pg3_2.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Regular:")), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_globals["skinweapon"]), false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Sack:")), false)
    hb.pack_start(gtk_globals["skinweaponsack"], false)
    vb_pg3_2.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("Blunt:")), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_globals["skinweaponblunt"]), false)
    vb_pg3_2.pack_start(hb, false)

    #
    # Page 3, Frame 3 - Enhancements
    #
#    vb_pg3_3 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg3_3 = Gtk::Box.new(:vertical, 1)
    fr_pg3_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Enhancements</b></big>"))
    fr_pg3_3.add(vb_pg3_3)
    vb_pg3.pack_start(fr_pg3_3, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
	hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_skin_offensive"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_skin_kneel"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_skin_safe_mode"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_skin_stance_first"].set_width_request(129)), false)
    vb_pg3_3.pack_start(hb, false)

    if (Char.prof == "Ranger" and Char.level > 3 and Spell[604].known?) or (Spell[9704].known?)
#	  hb = Gtk::HBox.new(false, 1)
	  hb = Gtk::Box.new(:horizontal, 1)
	  
      if Char.prof == "Ranger" and Char.level > 3 and Spell[604].known?
        hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_skin_604"].set_width_request(129)), false)
      end

      if Spell[9704].known?
        hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_skin_sigil"].set_width_request(129)), false)
      end

      vb_pg3_3.pack_start(hb, false)
    end

    #
    # Page 3, Frame 4 - Advanced Options
    #
#    vb_pg3_4 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg3_4 = Gtk::Box.new(:vertical, 1)
    fr_pg3_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Advanced Options</b></big>"))
    fr_pg3_4.add(vb_pg3_4)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    #hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_stats'].set_width_request(129)),false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(Gtk::Label.new("(?) Stand verb:")).set_width_request(100), false)
    hb.pack_start(gtk_locals["skin_stand_verb"], false)
    vb_pg3_4.pack_start(hb, false)

    vb_pg3.pack_start(fr_pg3_4, false)

    nb.append_page(vb_pg3, Gtk::Label.new("Skinning"))

    #
    # Notebook Page 4 - Skinning
    #
#    vb_pg4 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg4 = Gtk::Box.new(:vertical, 1)

    #
    # Page 4, Frame 1 - Selling
    #
#    vb_pg4_1 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg4_1 = Gtk::Box.new(:vertical, 1)
    fr_pg4_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Selling</b></big>"))
    fr_pg4_1.add(vb_pg4_1)
    vb_pg4.pack_start(fr_pg4_1, false)

    lbl = Gtk::Label.new.set_markup("SLoot comes with a built in sell option that will sell all " +
                                    "loot and even open boxes at the town locksmith. Use the checkboxes to set what type of loot " +
                                    "you want to sell and the advanced options to customize exactly how selling operates.")
    lbl.set_wrap(true).set_width_request(500).set_padding(0, 10)
    vb_pg4_1.pack_start(lbl, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("(?) Exclude loot:")).set_width_request(100), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["sell_exclude"].set_width_request(419)))
    vb_pg4_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_gem"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_jewelry"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_lockpick"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_magic"].set_width_request(129)), false)
    vb_pg4_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_reagent"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_scroll"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_skin"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_wand"].set_width_request(129)), false)
    vb_pg4_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_valuable"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_clothing"].set_width_request(129)), false)
    vb_pg4_1.pack_start(hb, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_empty_box"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_type_scarab"].set_width_request(129)), false)
    vb_pg4_1.pack_start(hb, false)

    #
    # Page 4, Frame 2 - Cleanup
    #
#    vb_pg4_2 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg4_2 = Gtk::Box.new(:vertical, 1)
    fr_pg4_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Cleanup</b></big>"))
    fr_pg4_2.add(vb_pg4_2)
    vb_pg4.pack_start(fr_pg4_2, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_chronomage"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_share_silvers"].set_width_request(129)), false)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new("(?) Withdraw:")).set_width_request(100), false)
    hb.pack_start(gtk_locals["sell_withdraw"], false)
    vb_pg4_2.pack_start(hb, false)

    #
    # Page 4, Frame 3 - Boxes
    #
#    vb_pg4_3 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg4_3 = Gtk::Box.new(:vertical, 1)
    fr_pg4_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Boxes</b></big>"))
    fr_pg4_3.add(vb_pg4_3)
    vb_pg4.pack_start(fr_pg4_3, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_locker_boxes"].set_width_request(129)), false)
    vb_pg4_3.pack_start(hb, false)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_locksmith"].set_width_request(129)), false)
    vb_pg4_3.pack_start(hb, false)

    #
    # Page 4, Frame 4 - Bounties
    #
#    vb_pg4_4 = Gtk::VBox.new(false, 1).set_border_width(3)
	vb_pg4_4 = Gtk::Box.new(:vertical, 1)
    fr_pg4_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup("<big><b>Bounties</b></big>"))
    fr_pg4_4.add(vb_pg4_4)
    vb_pg4.pack_start(fr_pg4_4, false)

#    hb = Gtk::HBox.new(false, 1)
	hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(0, 0, 0, 1).add(gtk_locals["enable_sell_stockpile"].set_width_request(129)), false)
    #hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_force_bounty_gems'].set_width_request(129)),false)
    vb_pg4_4.pack_start(hb, false)

    nb.append_page(vb_pg4, Gtk::Label.new("Selling"))

    # Save/Close buttons
#    hb_saveclose = Gtk::HBox.new
	hb_saveclose = Gtk::Box.new(1)
    save = Gtk::Button.new("_Save & Close")
    close = Gtk::Button.new("E_xit")

    save.signal_connect("clicked") { window_action = :save }
    close.signal_connect("clicked") { window_action = :done }

    hb_saveclose.pack_start(save, false)
    hb_saveclose.pack_start(close, false)

    # Primary VerticalBox to split up Notebook and Save/Close buttons
#    vb_main = Gtk::VBox.new(false, 5)
	vb_main = Gtk::Box.new(:vertical, 5)
    vb_main.border_width = 3

    vb_main.pack_start(nb, false)
    vb_main.pack_start(Gtk::Alignment.new(1, 0, 0, 0).add(hb_saveclose), false)

    window.signal_connect("delete_event") { window_action = :exit }

    window.add(vb_main)
    window.show_all
    window.keep_above = true # On windows keep_above is required AFTER show_all
  }

  before_dying { Gtk.queue { window.destroy } }
  wait_while { window_action.nil? }

  clean_entry = proc { |entry|
    entry.text = entry.text.strip
    if entry.text.empty?
      entry.text = ''
    end

    entry.text
  }

  if window_action == :save
    gtk_globals.each_pair { |option, widget|
      if widget.class == Gtk::CheckButton
        UserVars.change(option, widget.active?, :char)
      elsif widget.class == Gtk::Entry
        UserVars.change(option, clean_entry.call(widget), :char)
      else
        echo "error: unknown global widget #{option} [#{widget.class}]"
      end
    }

    gtk_locals.each_pair { |option, widget|
      if widget.class == Gtk::CheckButton
        settings[option] = widget.active?
      elsif widget.class == Gtk::Entry
        settings[option] = clean_entry.call(widget)
      else
        echo "error: unknown local widget #{option} [#{widget.class}]"
      end
    }

    echo "settings saved"
    $lootable = nil
  else
    echo "closed without saving"
  end
}

# Installs hooks that sloot uses to function. Will only install a hook
# once in order to increase performance.
install_hooks = proc { |type|
  if settings["enable_disking"]
    if !$sloot_hooks.include?(:disk)
      $sloot_hooks.push(:disk)

      hook = proc { |server_string|
        if server_string =~ /from in the <a exist="(?:\d+)" noun="disk">.*#{Char.name} disk<\/a>|You give your disk a flip/
          $sloot_has_disk = true
          $sloot_disk_full = false
        elsif server_string =~ /#{Char.name} disk in a dismissing gesture./
          $sloot_has_disk = false
          $sloot_disk_full = false
        elsif server_string =~ /^Your <a exist=".*" noun="disk">disk<\/a> arrives|^A small circular container suddenly appears/
          $sloot_has_disk = true
          $sloot_disk_full = false
        elsif server_string =~ /^Your .* won't fit in the .*disk.*$/
          $sloot_has_disk = true
          $sloot_disk_full = true
        end

        server_string
      }

      DownstreamHook.add("SLootDisk", hook)
    end
  elsif $sloot_hooks.include?(:disk)
    DownstreamHook.remove("SLootDisk")
  end
  if !$sloot_hooks.include?(:sloot_gameobj_watcher)
    $sloot_hooks.push(:sloot_gameobj_watcher)
    sloot_gameobj_watcher_hook = proc { |server_string|
      if server_string =~ /You (?:reach out to )?search/
        $sloot_searched = true
        #elsif  $sloot_searched && server_string =~ /exist="(?<exist>.*?)".*which looks like the heirloom that you are searching for/
        #unless GameObj.loot.find { |obj| obj.id == exist }
        #    GameObj.new_loot(exist, noun, name)
        #$sloot_searched = false
      elsif $sloot_searched && server_string =~ /had nothing else of value\.|had nothing of interest\.|^A.+ body shimmers slightly, then fades from view like a dissipating phantom\.$|prompt/
        $sloot_searched = false
      elsif $sloot_searched && server_string !~ /prompt/
        for link in server_string.scan(/<a.*?>.*?<\/a>/)
          if link =~ /<a exist="(.*?)" noun="(.*?)">(.*?)<\/a>/
            exist, noun, name = $1, $2, $3
            next if name =~ /^(?:he|she|it|her|his|him|its|itself)$|'s$/i
            GameObj.new_loot(exist, noun, name) unless GameObj.loot.find { |obj| obj.id == exist } or GameObj.inv.find { |obj| obj.id == exist }
          end
        end
      end
      server_string
    }
    DownstreamHook.add("SLootGameObjWatcher", sloot_gameobj_watcher_hook)
  end
}

# Get dem silvers
checksilvers = proc {
  silvers = nil
  action = proc { |server_string|
    if server_string !~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
      nil
    elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
      silvers = $1.to_i
      DownstreamHook.remove("slib_check_silvers")
      nil
    else
      server_string
    end
  }
  DownstreamHook.add("slib_check_silvers", action)
  $_SERVER_.puts "#{$cmd_prefix}info\n"
  wait_until { silvers }
  silvers
}

# Deposits coins in the bank
deposit_coins = proc {
  silvers = checksilvers.call.to_i
  withdraw = settings["sell_withdraw"].to_i

  if (silvers == 0 and withdraw == 0) or silvers == withdraw
    next
  end

  go2.call("bank")

  if settings["enable_sell_share_silvers"] and silvers > 1
    dothistimeout "share all", 5, /In order to share|share/
  end
  res = dothistimeout "deposit all", 5, /The teller carefully records the transaction|^You have no coins to deposit\.$/

  if (withdraw > 0)
    dothistimeout "withdraw #{withdraw} silvers", 5, /^The teller carefully records the transaction, and then hands you \d+ silvers\.$|Very well/
  end
}

# Opens up a sack and keeps a record of it
open_sack = proc { |sack|
  unless sack.class == GameObj or sack = GameObj[sack]
    echo "fixme: open_sack failed to find #{sack}"
    exit
  end

  res = dothistimeout "open ##{sack.id}", 5, /^You open .*\.$/
  unless res
    echo "fixme: unknown open_sack result: #{res}"
    exit
  end

  closed_sacks.push(sack.id)
}

# Closes all opened sacks in closed_sacks
close_open_sacks = proc {
  next unless settings["enable_close_sacks"]

  closed_sacks.each { |sack|
    res = dothistimeout "close ##{sack}", 5, /^You close .*\.$/
    unless res
      echo "fixme: unknown close_open_sacks result: #{res}"
      exit
    end
  }
}

# Puts an item somewhere
put_item = proc { |item, sack|
  if item.class != GameObj
    print.call("WARNING: item #{item} passed to put_item was not a GameObj")
  end

  if sack.class != GameObj
    print.call("WARNING: sack #{sack} passed to put_item was not a GameObj")
  end

  waitrt?

  next false unless GameObj.right_hand.id == item or GameObj.left_hand.id == item or checkleft =~ /#{item}/ or checkright =~ /#{item}/

  if sack.class == GameObj or sack = GameObj[sack]
    fput "put my #{item} in ##{sack.id}"
  else
    fput "put my #{item} in my #{sack}"
  end

  noun = item.class == GameObj ? item.noun : item
  result = false
  30.times {
    waitrt?

    if GameObj.right_hand.id != item and GameObj.left_hand.id != item and (not checkleft or noun !~ /#{checkleft}/) and (not checkright or noun !~ /#{checkright}/)
      result = true
      break
    end

    line = get?
    if line =~ /^You can't put .* in .*\.  It's closed\!$/
      open_sack.call(sack)
      next put_item.call(item, sack)
    elsif line =~ /^Your .* won't fit in .*\.$|find there is no space for the/
      break
    end

    sleep 0.10
  }

  result
}

# Gets an item
get_item = proc { |item, sack|
  waitrt?

  next true if GameObj.right_hand.id == item or GameObj.left_hand.id == item or checkleft =~ /#{item}/ or checkright =~ /#{item}/

  id = item.class == GameObj ? "##{item.id}" : item

  if sack.nil?
    fput "get #{id}"
  elsif sack.class == GameObj or sack = GameObj[sack]
    fput "get #{id} from ##{sack.id}"
  else
    fput "get #{id} from my #{sack}"
  end

  noun = item.class == GameObj ? item.noun : item
  result = false
  30.times {
    waitrt?

    if GameObj.right_hand.id == item or GameObj.left_hand.id == item or (checkleft and noun =~ /#{checkleft}/) or (checkright and noun =~ /#{checkright}/)
      result = true
      break
    end

    line = get?
    if line =~ /is out of your reach/
      sleep 4
      next get_item.call(item, sack)
    elsif line =~ /^You can't pick that up\.$|^Get what?$|crumbles and decays away.$|crumbles into a pile of dust!$/
      break
    end

    sleep 0.10
  }

  result
}

# Waits until your disk is present or a timeout occurs
check_for_disk = proc {
  disk = nil
  notified = false
  25.times {
    break if disk = GameObj[/^.*#{Char.name} (?:disk|coffin)$/]
    sleep 0.2
    unless notified
      msg.call("-- waiting on your disk to arrive")
      notified = true
    end
  }

  unless disk
    $sloot_has_disk = false
  end

  disk
}

# Withdraws coins from the bank, hooray!
withdraw_coins = proc { |amount|
  success = true
  room = Room.current.id

  coins = checksilvers.call
  if coins < amount
    go2.call("bank")

    dothistimeout "unhide", 5, /hiding|visible/ if invisible? or hiding?
    res = dothistimeout "withdraw #{amount - coins} silvers", 5, /^The teller carefully records the transaction, and then hands you \d+ silvers?\.$|I'm sorry, .*, you don't seem to have that much in the account\./
    case res
    when /I'm sorry/
      success = false
    when /^The teller carefully/
    else
      echo "unknown response for withdraw_coins: #{res}"
    end
  end

  go2.call(room)

  success
}

# Grabs loot!
grab_loot = proc { |loot, from|
  type = loot.type.split(",").first
  disk = nil
  loot2 = loot.type.split(",")

  if loot2.include?("box") and settings["enable_disking"] and $sloot_has_disk and not $sloot_disk_full
    unless disk = check_for_disk.call
      msg.call("I can't seem to find your disk")
      $sloot_has_disk = false

      if Char.prof == "Wizard" and Spell[511].known? and Char.level > 10
        msg.call("Hooray! You're a Weezard!")

        if Spell[511]
          Spell[511].cast
          disk = check_for_disk.call
        else
          msg.call("No mana, aborting.")
        end
      end
    end
  end

  loot2.each { |cont|
    type = cont
    if sack = sacks[cont]
      type = cont
      break
    end
  }

  unless sack = sacks[type]
    msg.call("unable to find sack for \"#{loot.name}\" with type \"#{loot.type}\"")
    msg.call("to loot manually, ;p #{script.name}")
    msg.call("you have 5 seconds to pause me")
    fput "look in ##{loot.id}"
    sleep 5
    next
  end

  unless get_item.call(loot, from)
    msg.call("failed to get item \"#{loot.name}\" from \"#{sack.name}\"")
  else
    if disk and put_item.call(loot, disk)
      next
    elsif loot2.include?("box") and settings["enable_phasing"] and Spell[704].known? and Spell[704].affordable? and Char.level > 3 and loot.name !~ /mithril|enruned/
      right_hand = GameObj.left_hand.id == loot.id

      dothistimeout "prep 704", 5, /Phase/
      res = dothistimeout "cast ##{loot.id}", 5, /somewhat insubstantial|flickers in and out|becomes momentarily|resists the effects/

      # phased items get a different id so refresh the loot GameObj
      if res =~ /becomes momentarily/
        if right_hand
          wait_while { GameObj.right_hand.noun.nil? }
          loot = GameObj.right_hand
        else
          wait_while { GameObj.left_hand.noun.nil? }
          loot = GameObj.left_hand
        end
      end
    end

    unless put_item.call(loot, sack)
      result = false
      settings["overflowsack"].split(",").each { |overflow|
        if put_item.call(loot, overflow)
          sacks[type] = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(overflow.strip)}/i }
          result = true
          break
        end
      }

      unless result
        msg.call("failed to put item \"#{loot.name}\" in sack \"#{sack.name}\" or overflow containers")
        fput "drop ##{loot.id}"
      end
    end
  end
}

# Frees up the loot hand
free_hand = proc {
  next if checkleft.nil? or checkright.nil?

  if UserVars.lootsack.nil?
    msg.call("warning: attempting to empty hand using lich function but no loostack has been set")
  end

  if settings["enable_stow_left"]
    empty_left_hand
  else
    empty_right_hand
  end
}

# Loots a single GameObj or an array of GameObjs
loot_it = proc { |array, exclude|
  next if array.nil?
  unless array.class == Array
    array = [array]
  end

  if CharSettings["loot_exclude"].to_s.length > 0
    array.delete_if { |loot| loot.name =~ /#{CharSettings["loot_exclude"]}/ }
  end

  array.each { |loot|
    next if loot.name =~ /severed.*(?:arm|leg)/

    # Skip over any loot that is in the exclude array
    if exclude.include?(loot.id)
      exclude.delete(loot.id)
      next
    end

    # Make sure that the loot type is something we want to pickup
    if loot.type.split(",").any? { |type| settings["enable_loot_#{type}"] }
      free_hand.call() unless GameObj.right_hand.id == loot.id or GameObj.left_hand.id == loot.id
      grab_loot.call(loot, nil)
    elsif loot.name == "some silver coins"
      dothistimeout "get ##{loot.id}", 5, /^You gather the remaining \d+ coins from inside your .*\.$|^You gather the remaining/
    end
  }
}

# Checks a bundle for ammo type
check_bundle = proc { |id|
  ammo_name = settings["ammo_name"].strip
  result = nil

  action = proc { |server_string|
    line = server_string
    if server_string =~ /Individual projectiles from this bundle will have a (?:show|long) of "(.*)"|Each individual projectile will be "(.*)"/
      name_long = $1
      name_short = $2

      if name_long =~ /.*#{ammo_name}/ or name_short =~ /.*#{ammo_name}/
        result = server_string
      end
      nil
    elsif server_string =~ /^You carefully count|Individual/
      nil
    elsif server_string.strip.empty?
      nil
    elsif server_string =~ /<prompt time=/
      result = false if result.nil?
      DownstreamHook.remove("sloot_check_bundle")
      nil
    else
      server_string
    end
  }

  DownstreamHook.add("sloot_check_bundle", action)
  $_SERVER_.puts "#{$cmd_prefix}look at ##{id}\n"
  wait_while { result.nil? }

  result
}

# Gets bundle information for ammo
get_bundle_details = proc do |bundle|
  details = {
    :id => bundle.id,
  }

  put "look at ##{bundle.id}"
  while line = get
    if line =~ /a strength of (\d+) and a durability of (\d+)/
      details[:strength] = $1.to_i
      details[:durability] = $2.to_i
    elsif line =~ /Each individual projectile will be "([^"]+)"\./
      details[:name] = $1.to_s
      break
    end
  end

  details
end

# Gathers ammunition
gather_ammo = proc do
  next unless settings["enable_gather"]

  ammo_name = settings["ammo_name"].strip
  quiver = GameObj.inv.find { |obj| obj.name =~ /#{UserVars.ammosack}/ }

  if quiver.nil?
    echo "failed to gather: you must specify an ammo container to use this feature"
    next
  end

  if ammo_name.nil? or ammo_name.empty?
    echo "failed to gather: you must specify the ammo name to use this feature"
    next
  end

  ammo_noun = nil
  if ammo_name =~ /\b(bolt|arrow|dart)\b/
    ammo_noun = $1.to_s
  else
    echo "failed to gather: unknown arrow noun"
  end

  bundles = quiver.contents.find_all do |loot|
    loot.type == "ammo" and
    loot.name =~ /bundle/i
  end

  $sloot_bundles ||= []
  $sloot_bundles.delete_if { |sb| not quiver.contents.find { |item| item.id == sb[:id] } }

  bundles.each do |bundle|
    if $sloot_bundles.find { |sb| sb[:id] == bundle.id }
      next
    end

    $sloot_bundles.push(get_bundle_details.call(bundle))
  end

  ammo = GameObj.loot.find_all do |loot|
    loot.type == "ammo" and
    loot.name =~ /\b#{ammo_name}s?\b/
  end

  if ammo.length > 0
    # gather ammo first
    res = dothistimeout "gather #{ammo_noun}", 2, /The bolt is out of your reach\.|You gather|You pick up/

    if res =~ /You gather/
      sleep 0.2 until GameObj.right_hand.id
    end
  end

  if GameObj.right_hand.name =~ /#{ammo_noun}s/i
    details = get_bundle_details.call(GameObj.right_hand)
    bundle = $sloot_bundles.find { |bundle| bundle[:name] == details[:name] }

    if bundle
      fput "put ##{details[:id]} in ##{bundle[:id]}"
    end
  elsif GameObj.right_hand.name =~ /#{ammo_name}/i
    bundle = $sloot_bundles.find { |bundle| bundle[:name] =~ /#{GameObj.right_hand.name}/i }

    if bundle
      fput "put ##{GameObj.right_hand.id} in ##{bundle[:id]}"
    end
  else
  end
end

# Locksmithing routine
locksmith = proc { |boxes, silver_breakdown|
  empty_hands
  withdraw_coins.call(10000)
  go2.call("locksmith")

  unless trash = GameObj[/crate|barrel|wastebarrel|casket/]
    msg.call("unable to locate trash")
  end

  # FWI: Try and find activator first.
  activator = GameObj[/chime/]

  if activator.nil?
    unless table = GameObj[/table|counter/]
      msg.call("unable to find table")
      next
    end

    unless table.contents
      dothistimeout "look on ##{table.id}", 5, /On the/

      unless table.contents
        msg.call("failed to find contents of #{table.name}")
        next
      end
    end

    unless activator = table.contents.find { |o| o.noun =~ /bell|keys|chime/ }
      msg.call("unable to find activator")
    end
  end

  case activator.noun
  when /bell|chime/
    activator = "ring ##{activator.id}"
  when /keys/
    activator = "pull keys"
  end

  if settings["enable_disking"] and $sloot_has_disk
    unless disk = GameObj[/^.*#{Char.name} (?:disk|coffin)$/]
      unless disk = check_for_disk.call
        msg.call("failed to find a disk")
      end
    end
  end

  open_box = proc { |box|
    get_item.call(box, nil)

=begin
        unless [2425].include? Room.current.id
            res = dothistimeout "put ##{box.id} on ##{table.id}", 5, /^You put|^You should really/

            # Phasing for those Sorcerer types (evil bastards!)
            if res =~ /^You should really/
                dothistimeout "drop ##{box.id}", 5, /flickers in and out of existence/
                put_item.call(box,table.id)
            end
        end
=end

    # properly handle phased items
    if box.name =~ /shifting/i
      right_hand = GameObj.left_hand.id == box.id

      res = dothistimeout "drop ##{box.id}", 5, /flickers in and out of existence/

      if res =~ /flickers in and out of existence/
        if right_hand
          wait_while { GameObj.right_hand.noun.nil? }
          box = GameObj.right_hand
        else
          wait_while { GameObj.left_hand.noun.nil? }
          box = GameObj.left_hand
        end
      end
    end

    res = dothistimeout activator, 5, /but it'll cost ya\.  Gimme (\d+) silvers/
    if res =~ /Gimme (\d+) silvers/
      box_cost = $1.to_i
    else
      box_cost = 0
      msg.call("unknown locksmith response: " + res.to_s)
    end

    res = dothistimeout "pay", 5, /accepts|have enough/
    if res =~ /have enough/
      put_item.call(box, UserVars.boxsack)
      withdraw_coins.call(10000)
      next open_box.call(box)
    end

    silver_breakdown["locksmith"] ||= 0
    silver_breakdown["locksmith"] = silver_breakdown["locksmith"].to_i - box_cost

    cur_silvers = checksilvers.call

    dothistimeout "open ##{box.id}", 5, /open/
    unless box.contents
      dothistimeout "look in ##{box.id}", 5, /^In the/

      unless box.contents
        msg.call("failed to see contents of #{box.name}")
        loot_it.call(box, nil)
        next
      end
    end

    loot_it.call(box.contents, nil)
    silver_breakdown["locksmith"] = silver_breakdown["locksmith"] + (checksilvers.call - cur_silvers)
    unless trash.nil?
      unless put_item.call(box, trash.id)
        dothistimeout "drop ##{box.id}", 5, /drop/ if [checkleft, checkright].include?(box.noun)
      end
    end

    dothistimeout "drop ##{box.id}", 5, /drop/ if [checkleft, checkright].include?(box.noun)
  }

  dothistimeout "unhide", 5, /hiding|visible/ if invisible? or hiding?
  done = []
  boxes.each { |b|
    next if done.include? b.id

    open_box.call(b)
    done.push(b.id)
  }
}

to_locker = proc {
  if checksilvers.call < 1000
    withdraw_coins.call(1000)
  end
  go2.call(CharSettings["locker"])

  CharSettings["locker_in"].split(",").each do |cmd|
    move cmd
  end

  if way_in = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
    move "go #{way_in.noun}"
  else
    echo "error: failed to find locker entrance"
  end
}

from_locker = proc {
  if way_out = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
    move "go #{way_out.noun}"
  else
    echo "error: failed to find locker exit"
  end

  CharSettings["locker_out"].split(",").each do |cmd|
    move cmd
  end
}

need_to_stockpile = proc {
  if CharSettings[:jars].any? { |jar| jar[:gem] =~ /large|medium|small|tiny/ }
    CharSettings[:jars] = nil
  end
  lootsack = sacks["gem"]
  can_start_new_jar = (CharSettings[:empty_jar_count] > 0) and lootsack.contents.any? { |obj| (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not CharSettings[:jars].any? { |jar| jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, "").sub(/y\b/, "(?:y|ie)").sub(/z\b/, "ze?").gsub(/\b\s/, "s? ")}s?$/ } }
  can_add_to_jar = CharSettings[:jars].any? { |jar| !jar[:full] and lootsack.contents.any? { |obj| jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, "").sub(/y\b/, "(?:y|ie)").sub(/z\b/, "ze?").gsub(/\b\s/, "s? ")}s?$/ } }
  CharSettings[:jars].nil? or can_start_new_jar or can_add_to_jar
}

need_to_raid_stockpile = proc {
  if checkbounty =~ /gem dealer.* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
    gem = $1
    count = $2.to_i
    CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, "").sub(/y\b/, "(?:y|ie)").sub(/z\b/, "ze?").gsub(/\b\s/, "s? ")}s?$/) and (jar[:count] >= count) }
  else
    false
  end
}

stockpile = proc {
  status_tags
  lootsack = sacks["gem"]
  open_result = dothistimeout "open locker", 5, /exist=".*?" noun="(?:locker|chest)"/
  status_tags
  if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
    locker_id = $1
    locker_contents = GameObj.containers[locker_id]
    unless locker_contents
      dothistimeout "look in ##{locker_id}", 3, /^In the/
      locker_contents = GameObj.containers[locker_id]
    end
    if locker_contents
      if CharSettings[:jars].nil?
        CharSettings[:jars] = Array.new
        CharSettings[:empty_jar_count] = 0
        locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ }.each { |jar|
          if jar.after_name.nil?
            CharSettings[:empty_jar_count] = CharSettings[:empty_jar_count] + 1
          else
            look_result = dothistimeout "look in ##{jar.id} from ##{locker_id}", 3, /^Inside .*? you see [0-9]+ portion/
            if look_result =~ /^Inside .*? you see ([0-9]+) portion/
              count = $1.to_i
              gem = jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, "")
              full = look_result.include?("It is full")
              CharSettings[:jars].push(h = { :gem => gem, :count => count, :full => full })
            end
          end
        }
      end
      empty_hands
      not_suitable = Array.new
      for jar in locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|beaker|bottle)$/ }
        if jar.after_name =~ /^containing /
          gem_list = lootsack.contents.find_all { |obj| (jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, "") =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, "").sub(/y\b/, "(?:y|ie)").sub(/z\b/, "ze?").gsub(/\b\s/, "s? ")}s?$/) }
          gem_list.delete_if { |obj| not_suitable.include?(obj.id) }
          jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, "") }
          unless gem_list.empty? or jar_hash[:full]
            dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
            for gem in gem_list
              result = dothistimeout "_drag ##{gem.id} ##{jar.id}", 3, /^You add|is full|does not appear to be a suitable container for/
              if result =~ /^You add .* filling it/
                jar_hash[:count] = jar_hash[:count] + 1
                jar_hash[:full] = true
              elsif result =~ /^You add/
                jar_hash[:count] = jar_hash[:count] + 1
              elsif result =~ /is full/
                jar_hash[:full] = true
                dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, putregex
                break
              elsif result =~ /does not appear to be a suitable container for/
                dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, putregex
                not_suitable.push(gem.id)
              else
                dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, putregex
              end
            end
            dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
          end
        else
          gem_count = Hash.new
          lootsack.contents.each { |obj|
            if (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not locker_contents.any? { |o| o.after_name.gsub(/^containing |large |medium |small |tiny |some /, "") =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, "").sub(/y\b/, "(?:y|ie)").sub(/z\b/, "ze?").gsub(/\b\s/, "s? ")}s?$/ and not not_suitable.include?(obj.id) }
              gem_count[obj.name.gsub(/large |medium |small |tiny |some /, "")] = gem_count[obj.name.gsub(/large |medium |small |tiny |some /, "")].to_i + 1
            end
          }
          next if gem_count.empty?
          gem_name = nil
          gem_num = 0
          gem_count.each_pair { |name, num|
            if num > gem_num
              gem_name = name
              gem_num = num
            end
          }
          dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
          jar_hash = nil
          lootsack.contents.each { |obj|
            if obj.name.gsub(/large |medium |small |tiny |some /, "") == gem_name
              result = dothistimeout "_drag ##{obj.id} ##{jar.id}", 3, /^You (?:add|put)|is full|does not appear to be a suitable container for/
              if result =~ putregex
                dothistimeout "put ##{jar.id} in ##{lootsack.id}", 3, putregex
                gem = lootsack.contents.find { |obj| obj.id == jar.id }.after_name.gsub(/^containing |large |medium |small |tiny |some /, "")
                dothistimeout "get ##{jar.id}", 3, /^You remove/
                jar_hash = { :gem => gem, :count => 1, :full => false }
                CharSettings[:jars].push(jar_hash)
              elsif result =~ /^You add/
                jar_hash[:count] = jar_hash[:count] + 1
              elsif result =~ /is full/
                dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, putregex
                jar_hash[:full] = true
                break
              elsif result =~ /does not appear to be a suitable container for/
                not_suitable.push(obj.id)
                fput "put ##{obj.id} in ##{lootsack.id}"
              end
            end
          }
          dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
        end
      end
      dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
      fill_hands
    else
      dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
      echo "error: failed to find locker contents"
    end
  else
    dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
    echo "error: failed to find locker"
  end
}

raid_stockpile = proc {
  lootsack = sacks["gem"]
  if bounty? =~ /gem dealer .* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
    gem = $1
    count = $2.to_i
    gem.gsub!(/large |medium |small |tiny |some /, "")
    status_tags
    open_result = dothistimeout "open locker", 5, /exist=".*?" noun="(?:locker|chest)"/
    status_tags
    if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
      locker_id = $1
      locker_contents = GameObj.containers[locker_id]
      unless locker_contents
        dothistimeout "look in ##{locker_id}", 3, /^In the/
        locker_contents = GameObj.containers[locker_id]
      end
      if locker_contents
        if CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, "").sub(/y\b/, "(?:y|ie)").sub(/z\b/, "ze?").gsub(/\b\s/, "s? ")}s?$/) and (jar[:count] >= count) }
          if jar = locker_contents.find { |jar| jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, "") =~ /^#{gem.gsub(/large |medium |small |tiny |some /, "").sub(/y\b/, "(?:y|ie)").sub(/z\b/, "ze?").gsub(/\b\s/, "s? ")}s?$/ }
            jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.sub(/^containing |large |medium |small |tiny |some /, "") }
            empty_hands
            dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
            count.times {
              dothistimeout "shake ##{jar.id}", 3, /^You .*shake/
              if GameObj.right_hand.id != jar.id
                obj = GameObj.right_hand
              elsif GameObj.left_hand.id != jar.id
                obj = GameObj.left_hand
              end
              dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, putregex
              jar_hash[:count] = jar_hash[:count] - 1
              jar_hash[:full] = false
            }
            dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
            if jar_hash[:count] < 1
              CharSettings[:jars].delete(jar_hash)
              CharSettings[:empty] = CharSettings[:empty] + 1
            end
            fill_hands
            dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
            true
          else
            dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
            false
          end
        else
          dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
          false
        end
      else
        dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
        echo "error: failed to find locker contents"
        false
      end
    else
      dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
      echo "error: failed to find locker"
      false
    end
  else
    echo "error: you're doing it wrong"
    false
  end
}

# Lockering boxes routine
locker_boxes = proc { |boxes|
  to_locker.call()

  status_tags
  open_result = dothistimeout "open locker", 5, /exist=".*?" noun="(?:locker|chest)"/
  if !open_result
    echo "error: failed to find locker to open"
    next
  end
  status_tags

  if open_result !~ /exist="(\d+)" noun="(locker|chest)"/
    echo "error: failed to find locker id"
    exit
  end

  locker_id = $1.to_s

  boxes.each do |box|
    fput "get ##{box.id}"
    res = dothistimeout "put ##{box.id} in locker", 3, /in the locker, and it quickly disappears\./
    if res !~ /in the locker/ or GameObj.right_hand.id == box.id or GameObj.left_hand.id == box.id
      $sloot_locker_full = true
      loot_it.call(GameObj.right_hand) if checkright
      loot_it.call(GameObj.left_hand) if checkleft
      break
    end
  end

  fput "close locker"

  from_locker.call()
}

# Sell routine
sell = proc {
  cur_room = Room.current.id
  found_sacks = Array.new
  selling = Hash.new
  silver_breakdown = Hash.new
  types = Array.new

  # Chronomage
  if settings["enable_sell_chronomage"]
    sack = GameObj[UserVars.jewelrysack]
    rings = sack.contents.find_all { |item| item.name =~ /^(\w+) gold ring$/ }
    if not rings.empty?
      go2.call("chronomage")
      npc = GameObj.npcs.first

      if not npc.nil?
        empty_hands

        rings.each { |ring|
          fput "get ##{ring.id}"
          fput "give ##{ring.id} to ##{npc.id}"

          if checkleft or checkright
            fput "put ##{ring.id} in my ##{sack.id}"
          end
        }

        fill_hands
      end
    end
  end

  find_boxes = proc {
    box_sacks = [GameObj[UserVars.boxsack]]
    boxes = []

    settings["overflowsack"].split(",").each { |sack|
      if found_sack = GameObj[sack]
        box_sacks.push(found_sack)
      end
    }

    box_sacks.each { |sack|
      if (more_boxes = sack.contents.find_all { |o| o.type.include?("box") })
        boxes += more_boxes
      end
    }

    if settings["enable_disking"] and $sloot_has_disk
      unless disk = GameObj[/^.*#{Char.name} (?:disk|coffin)$/]
        unless disk = check_for_disk.call
          msg.call("failed to find a disk")
        end
      end

      if disk
        unless disk.contents
          dothistimeout "look in ##{disk.id}", 5, /There is nothing|In the .*?/
          unless disk.contents
            msg.call("failed to find contents of your disk")
          end
        end

        boxes += disk.contents.find_all { |o| o.type.include?("box") }.to_a if disk.contents
      end
    end

    boxes
  }

  boxes = find_boxes.call

  # Lockering boxes
  if boxes.size > 0 and settings["enable_locker_boxes"] and not $sloot_locker_full
    locker_boxes.call(boxes)
    boxes = find_boxes.call
  end

  # Locksmith
  if boxes.size > 0 and settings["enable_sell_locksmith"]
    locksmith.call(boxes, silver_breakdown)
  end

  # Stockpile gems
  if settings["enable_sell_stockpile"]
    if CharSettings["locker"].nil?
      echo "warning: stockpiling is turned on but locker room is not set"
      sleep 3
    elsif need_to_stockpile.call or need_to_raid_stockpile.call
      if to_locker.call
        stockpile.call if need_to_stockpile.call
        raid_stockpile.call if need_to_raid_stockpile.call
        from_locker.call
      end
    end
  end

  settings.keys.each { |key|
    if key =~ /^enable_sell_type_(.*)$/
      type = $1
      types.push(type) if settings[key]

      if found_sack = GameObj[UserVars.send("#{type}sack")]
        found_sacks.push(found_sack) unless found_sacks.include?(found_sack)
      end
    end
  }

  settings["overflowsack"].split(",").each { |sack|
    if found_sack = GameObj[sack]
      found_sacks.push(found_sack) unless found_sacks.include?(found_sack)
    end
  }

  found_sacks.each { |sack|
    unless sack.contents
      dothistimeout "look in ##{sack.id}", 5, /In the .*?/
      unless sack.contents
        msg.call("-- failed to find contents of sack: #{sack.name}")
        next
      end
    end

    sack.contents.each { |item|
      if CharSettings["sell_exclude"].to_s.length > 0
        next if item.name =~ /#{CharSettings["sell_exclude"]}/
        next if item.name =~ /Guild voucher pack/i
      end
      unless item.sellable.nil?
        if item.type.split(",").any? { |type| type =~ /^#{types.join("|")}$/ }
          selling[item.sellable] ||= Array.new
          selling[item.sellable].push(item)
        end
      end
    }
  }

  # sell empty boxes
  if settings["enable_sell_type_empty_box"]
    box_sacks = [GameObj[UserVars.boxsack]]
    box_sacks.each { |sack|
      if (more_boxes = sack.contents.find_all { |o| o.type.include?("box") })
        more_boxes.each { |box|
          selling["pawnshop"] ||= Array.new
          selling["pawnshop"].push(box)
        }
      end
    }
  end

  # sell scarabs as gems
  if settings["enable_sell_type_scarab"]
    if (more_scarabs = GameObj[UserVars.boxsack].contents.find_all { |o| o.type.include?("scarab") })
      more_scarabs.each { |scarab|
        selling["gemshop"] ||= Array.new
        selling["gemshop"].push(scarab)
      }
    end
  end

  sell_item = proc { |item|
    if get_item.call(item, nil)
      dothistimeout "sell ##{item.id}", 5, /ask|offer/

      if checkleft == item.noun or checkright == item.noun
        unless put_item.call(item, UserVars.send("#{item.type.split(",").first}sack"))
          dothistimeout "drop ##{item.id}", 5, /drop/
        end
      end
    else
      msg.call("-- failed to find #{item.name}")
      exit
    end
  }

  if selling.size == 0
    msg.call("-- nothing to sell")
  else
    empty_hands

    selling.each_pair { |location, items|
      start_silvers = checksilvers.call

      location = location.split(",").first
      go2.call(location)
      items.each { |item| sell_item.call(item) }

      silver_breakdown[location] = checksilvers.call - start_silvers
    }
  end

  deposit_coins.call()
  go2.call(cur_room)
  fill_hands

  unless silver_breakdown.empty?
    msg.call("silver breakdown")
    silver_breakdown.each_pair { |location, silver|
      msg.call("#{location.split(",").first}: #{silver}")
    }

    total_made = silver_breakdown.values.inject { |i, j| i + j }
    msg.call("total: #{total_made}")
  end
}

# Returns an array of all dead npcs using GameObj
find_dead = proc { |type|
  npcs = GameObj.npcs.find_all { |npc| npc.status == "dead" }

  if CharSettings["critter_exclude"].to_s.length > 0
    npcs.delete_if { |npc| npc.name =~ /#{CharSettings["critter_exclude"]}/ }
  end

  npcs
}

# Checks if it's safe to enhance skinning by kneeling or stancing to offensive
safe_to_enhance = proc {
  next true unless settings["enable_skin_safe_mode"]
  !GameObj.npcs.any? { |npc| npc.status !~ /dead/ }
}

# Prepares for skinning process
prepare_skinner = proc { |critter|
  next if settings["skin_exclude"].include?(critter.name)
  next if skin_prepared
  next unless GameObj.npcs.any? { |npc| npc.status =~ /dead/ }
  next unless settings["enable_skinning"]

  # Sigil of Resolve
  if Spell[9704].known? and Spell[9704].affordable? and not Spell[9704].active? and settings["enable_skin_sigil"]
    Spell[9704].cast
  end

  # 604 - Skinning
  if Spell[604].known? and Spell[604].affordable? and settings["enable_skin_604"]
    while !Spell[604].active?
      Spell[604].cast
    end
  end

  if settings["enable_skin_alternate"]
    if critter.name =~ /krag dweller|greater krynch|massive boulder/
      empty_hands
      skin_empty_hands = true
    else
      free_hand.call
    end

    skinweaponcurrent = skinweapon
    if critter.name =~ /krynch|spiked cavern urchin|krag dweller|stone mastiff|gargoyle|massive boulder/i and UserVars.skinweaponblunt.to_s.length > 1
      skinweaponcurrent = skinweaponblunt
    end

    unless get_item.call(skinweaponcurrent, sacks["skinweapon"])
      msg.call("** failed to find #{skinweaponcurrent.name} in #{sacks["skinweapon"].name}")
    end
  else
    if critter.name =~ /krag dweller|greater krynch|massive boulder/
      free_hand.call
    end
  end

  if safe_to_enhance.call
    while settings["enable_skin_kneel"] and !checkkneeling
      dothistimeout "kneel", 5, /^You kneel down\.$|^You move to|^You are already kneeling\.$/
    end

    if settings["enable_skin_offensive"]
      change_stance.call("offensive")
    end
  end

  skin_prepared = true
}

# Get thee up!
stand_up = proc {
  if settings["skin_stand_verb"].nil? or settings["skin_stand_verb"].empty?
    until standing?
      dothistimeout "stand", 5, /^You stand back up\.$/
    end
  else
    until standing?
      fput settings["skin_stand_verb"]
    end
  end
}

# Finishes up skinning process
finish_skinner = proc {
  next unless skin_prepared
  next unless settings["enable_skinning"]

  if settings["enable_skin_stance_first"]
    change_stance.call(prev_stance)
    stand_up.call
  else
    stand_up.call
    change_stance.call(prev_stance)
  end

  if settings["enable_skin_alternate"]
    unless put_item.call(skinweaponcurrent, UserVars.skinweaponsack)
      echo "failed to put #{skinweaponcurrent} in #{UserVars.skinweaponsack}"
    end
  end

  if skin_empty_hands
    fill_hands
    skin_empty_hands = false
  end
}

# Skins a critter
skin_critter = proc { |critter|
  next if settings["skin_exclude"].include?(critter.name)

  cmd = "skin ##{critter.id}"
  if not skinweaponcurrent.nil? and checkleft =~ /#{skinweaponcurrent}/i
    cmd += " with ##{GameObj.left_hand.id}"
  end

  res = dothistimeout cmd, 5, /skinned|botched|already been|cannot skin|must be a member|can only skin|You are unable to break through|You break through the crust of the|You crack open a portion/
  if res =~ /^You cannot skin/
    settings["skin_exclude"].push(critter.name)
  elsif res =~ /^(?:You break through the crust of the .+ and withdraw |You crack open a portion of the .+ and uncover )(.+)!/
    foundgem = $1.split.last
    gemsack = GameObj.inv.find { |obj| obj.name =~ /#{UserVars.gemsack}/ }
    put_item.call(foundgem, gemsack)
  end
}

# Retrieves the previously stored item
get_stored = proc {
  if settings["enable_stow_left"]
    fill_left_hand
    $fill_left_hand_actions = Array.new
  else
    fill_right_hand
    $fill_right_hand_actions = Array.new
  end
}

["clothing", "ammo", "box", "gem", "herb", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "wand", "skinweapon", "valuable"].each { |type|
  if !UserVars.send("#{type}sack").nil? and UserVars.send("#{type}sack").length > 0 and sack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("#{type}sack").strip)}/i }
    sacks[type] = sack
  elsif script.vars[1] !~ /^setup/i
    next if type == "skinweapon" && !settings["enable_skinning"]
    next if !settings["enable_loot_#{type}"]
    echo "** failed to find #{type} sack"
    exit
  end
}

if script.vars[1] =~ /^reset-gui$/i
  settings["window_height"] = nil
  settings["window_width"] = nil
  settings["window_position"] = nil

  echo "gui reset"
elsif script.vars[1] =~ /^stockpile-forget$/i
  CharSettings[:jars] = nil
  echo "stockpile cleared"
elsif script.vars[1] =~ /^stockpile-list$/i
  output = "                           gem count  full\n"
  output.concat "                           --- -----  ----\n"

  gem = script.vars[2]
  for jar in CharSettings[:jars].sort { |a, b| b[:count] <=> a[:count] }
    if gem.nil? or jar[:gem] =~ /#{gem}/
      output.concat "#{jar[:gem].rjust(30)} #{jar[:count].to_s.rjust(2)} #{jar[:full].to_s.rjust(8)}\n"
    end
  end
  respond output
elsif script.vars[1] =~ /^deposit$/i
  deposit_coins.call
elsif script.vars[1] =~ /^sell$/i
  sell.call
elsif script.vars[1] =~ /^setup$/i
  setup.call
elsif script.vars[1] =~ /^(right|left)$/i
  hand = $1 == "right" ? GameObj.right_hand : GameObj.left_hand
  unless hand.contents
    dothistimeout "look in ##{hand.id}", 5, /^I could not find|In the .*\.$/
    unless hand.contents
      msg.call("failed to find contents of #{hand.name}")
    end
  end

  loot_it.call(hand.contents, nil)
elsif script.vars[1] =~ /^(?:help|\?)$/
  msg.call(sprintf("SLoot"))
  msg.call(sprintf("%17s: SpiffyJr &lt;spiffyjr@gmail.com&gt;", "Author"))
  msg.call(sprintf("%17s: SLoot is designed to be the most versatile looter available!", "Description"))
  msg.call(sprintf("%17s: ;sloot - runs the skin, search, and loot routine on the current room.", "Usage"))
  respond
  msg.call(sprintf("%17s     %s", "help, ?", "show this help message"))
  msg.call(sprintf("%17s     %s", "setup", "run the GUI configuration"))
  msg.call(sprintf("%17s     %s", "reset-gui", "resets the GUI window if it gets lost"))
  respond
  msg.call(sprintf("%17s     %s", "stockpile-forget", "forget your stockpile settings"))
  msg.call(sprintf("%17s     %s", "stockpile-list", "lists your stockpiled gems"))
  respond
  msg.call(sprintf("%17s     %s", "dump", "dumps the current settings to the screen"))
  respond
  msg.call(sprintf("%17s     %s", "sell", "runs the automated selling routine"))
  msg.call(sprintf("%17s     %s", "deposit", "deposits your coins according to settings"))
  respond
  msg.call(sprintf("%17s     %s", "sack", "runs sloot on the sack specified"))
  msg.call(sprintf("%17s     %s", "left", "runs sloot on the sack in your left hand"))
  msg.call(sprintf("%17s     %s", "right", "runs sloot on the sack in your right hand"))
end

exit unless script.vars[1].nil?

if settings["enable_skinning"] and settings["enable_skin_alternate"]
  skinweaponsack = sacks["skinweapon"]

  if skinweaponsack.nil?
    echo "** skinning is enabled but I could not find your skin weapon sack"
    exit
  end

  if not sacks["skinweapon"].contents
    fput "look in ##{sacks["skinweapon"].id}"
  end

  skinweapon = skinweaponsack.contents.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweapon)}/i }
  skinweaponblunt = skinweaponsack.contents.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponblunt)}/i }

  if skinweapon.nil?
    echo "** skinning is enabled but I could not find your skin weapon"
  end

  if skinweaponblunt.nil?
    skinweaponblunt = skinweapon
  end
end

if settings["enable_locker_boxes"] and not settings["locker"]
  echo "** lockering boxes is enabled but your locker is not set"
  exit
end

# Hooks for disk tracking and statistics
install_hooks.call

# Is safe hiding enabled?
if settings["enable_safe_hiding"] and hiding?
  bad_npcs = GameObj.npcs.find_all { |npc|
    npc.type !~ /escort/ and npc.status !~ /dead/ and npc.name !~ /^(?:#{settings["safe_ignore"].to_s})$/
  }
  exit if bad_npcs.length > 0
end

# Keep track of loot IDs in the current room if we're only looting our critter drops
previous_loot_ids = Array.new
if settings["enable_self_drops"]
  previous_loot_ids = GameObj.loot.collect { |l| l.id }
end

critters = find_dead.call

if settings["enable_skinning"]
  critters.each { |critter|
    next if critter.name =~ /Grimswarm/ or critter.type =~ /bandit/
    prepare_skinner.call(critter)
    skin_critter.call(critter)
  }
  finish_skinner.call
end

# fuck the bramble patch, seriously
critters.delete_if { |critter| critter.name =~ /\b(?:shrub|plant|tumbleweed|creeper)\b/ }

critters.each { |critter|
  res = dothistimeout "search ##{critter.id}", 5, /^You search (?:through )?the .*\.$|^What were you referring to|You plunge your hand|and withdraw a fiery red gem!|causing assorted foliage to fall|You quickly grab the/

  if res =~ /withdraw a (?:cold blue gem|fiery red gem)/
    righthand == "gem" ? loot_it.call(GameObj.right_hand, []) : loot_it.call(GameObj.left_hand, [])
  elsif res =~ /you withdraw your arm to find a pungent piece/
    righthand == "caederine" ? loot_it.call(GameObj.right_hand, []) : loot_it.call(GameObj.left_hand, [])
  end

  # Bramble patch lewt
  if righthand =~ /berry|thorn/
    fput "stow right"
  elsif lefthand =~ /berry|thorn/
    fput "stow left"
  end

  break unless settings["enable_search_all"]
}

if script.vars[1] =~ /^left$/i
  target = [GameObj.left_hand]
elsif script.vars[1] =~ /^right$/i
  target = [GameObj.right_hand]
else
  target = GameObj.loot
end

if settings["enable_stance_on_start"]
  change_stance.call("defensive")
end

loot_it.call(target, previous_loot_ids)
gather_ammo.call()

get_stored.call()
close_open_sacks.call()

$fill_hand_actions = Array.new
$fill_left_hand_actions = Array.new
$fill_right_hand_actions = Array.new
