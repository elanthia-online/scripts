=begin
  Rebuild by Demandred of the Vailans Original version but strill being maintained by Vailan
  Demandred did a major overhaul of this and asked me to upload it for consistancy. I think this is a major improvement over how I was doing it before and I
  Would like to really thank them for the effort they put into this.
  Major overhaul of vars and such. Sorting by var now. Etc etc. Check out ;lumnismon help

  Note: you will need to re-run this for all of your characters as it does not import the old csv file and starts from scratch

  author: elanthia-online
  contributors: Vailan
  tags: character, information
  version: 1.1.0

  1.1.0 (2025-04-06)
    * Update for Empath profession service going live
  1.0.1 (2024-11-05)
    * Update for Rogue profession service going live
  1.0.0 (2024-09-23)
    * Migrated under under EO
    * Updated for Paladins
=end
=begin
  2024.07.12    - Updated for Paladins
  2024.04.29    - Updated for Bardic Luck
  2024.04.20    - Fix for error parsing info (If you see "did not find expected key while parsing a block mapping" it is likely bad text in your saved data)
  2023.11.22    - Added Field for Average Time remaining on Invoker Supplied Spells
  2023.11.30    - Security Fix for reading YAML File due to Aliases
  2023.09.12    - Rubocop code cleanup and update for Ruby 3.2
  2022.07.29    - reportOnly issue in .load fixed. Display sorting fixed. Overcomplicated and wasn't working right.
  2022.07.27.2  - small account display issues resolved.
  2022.07.27    - fix small issue with resource scoop - finish incorporating f2p fixes.

=end

VERSION = "1.0.0"

module MyInfo
  require 'yaml'

  @allcharInfo = Hash.new

  def self.message(text)
    string = ''
    if $fake_stormfront then string.concat("\034GSL\r\n ") else string.concat("<pushBold\/>") end
    if (text.index('\n')) then text.split('\n').each { |line| string.concat("#{line}") } else string.concat(text) end
    if $fake_stormfront then string.concat("\034GSM\r\n ") else string.concat("<popBold\/>") end
    _respond string
  end

  Dir.mkdir(File.join(DATA_DIR, "myinfo")) unless File.exist?(File.join(DATA_DIR, "myinfo"))
  @myinfofilename = File.join(DATA_DIR, "myinfo", "#{XMLData.game}-myinfo.yaml")

  def self.load(reportOnly)
    unless File.exist?(@myinfofilename)
      @allcharInfo = Hash.new
      @allcharInfo["#{XMLData.name}"] = {
        :charactername           => "",
        :characteraccount        => "",
        :profession              => "",
        :level                   => "",
        :lastcheckwhen           => "",
        :refreshwhen             => "",
        :doubledexperience       => "",
        :tripledexperience       => "",
        :refreshdays             => "",
        :refreshhours            => "",
        :refreshminutes          => "",
        :refreshstring           => "",
        :mindcapacity            => "",
        :mindpercent             => "",
        :currentmind             => "",
        :currentdeed             => "",
        :currentweeklyresource   => "",
        :currenttotalresource    => "",
        :currentsuffusedresource => "",
        :currentexp              => "",
        :expnext                 => "",
        :nextschedulestring      => "",
        :bountypoints            => "",
        :customplace             => "",
        :invokerspellsremaining  => ""
      }
    else
      if Gem::Version.new(RUBY_VERSION) < Gem::Version.new('3.1')
        @allcharInfo = YAML.load_file(@myinfofilename)
      else
        @allcharInfo = YAML.load_file(@myinfofilename, permitted_classes: [Time, Symbol], aliases: true)
      end
      if @allcharInfo["#{XMLData.name}"].nil? && reportOnly == false
        @allcharInfo["#{XMLData.name}"] = {
          :charactername           => "",
          :characteraccount        => "",
          :profession              => "",
          :level                   => "",
          :lastcheckwhen           => "",
          :refreshwhen             => "",
          :doubledexperience       => "",
          :tripledexperience       => "",
          :refreshdays             => "",
          :refreshhours            => "",
          :refreshminutes          => "",
          :refreshstring           => "",
          :mindcapacity            => "",
          :mindpercent             => "",
          :currentmind             => "",
          :currentdeed             => "",
          :currentweeklyresource   => "",
          :currenttotalresource    => "",
          :currentsuffusedresource => "",
          :currentexp              => "",
          :expnext                 => "",
          :nextschedulestring      => "",
          :bountypoints            => "",
          :customplace             => "",
          :invokerspellsremaining  => "",
        }
      end
    end
  end

  def self.getMindCapacity
    return 800 + Stats.enhanced_log[0] + Stats.enhanced_dis[0]
  end

  def self.getMindPercent
    mindString = mind?
    if mindString.downcase == "clear as a bell"
      return  0
    elsif mindString.downcase == "fresh and clear"
      return  0.25 / 2
    elsif mindString.downcase == "clear"
      return  0.75 / 2
    elsif mindString.downcase == "muddled"
      return  1.12 / 2
    elsif mindString.downcase == "becoming numbed"
      return  1.37 / 2
    elsif mindString.downcase == "numbed"
      return  1.65 / 2
    elsif mindString.downcase == "must rest"
      return  1.9 / 2
    elsif mindString.downcase == "saturated"
      return  1
    end
  end

  def self.getCurrentMind
    put "experience"
    while (line = get)
      if line =~ /Field Exp: ([\d,]+)\/([\d,]+)/
        curmind = $1.delete(",")
        break
      end
    end
    return curmind
  end

  def self.expUntilnext
    nextLevelExp = 0
    xpnNLT = XMLData.next_level_text
    if xpnNLT =~ /( experience| until next level)/
      nextLevelExp = xpnNLT.delete(' experience').delete(' until next level').to_i
    end
    return nextLevelExp
  end

  def self.calcTotalSeconds(refreshDays, refreshHours, refreshMinutes)
    refreshTotalSeconds = (refreshDays.to_i * 24 * 60 * 60) + (refreshHours.to_i * 60 * 60) + (refreshMinutes.to_i * 60)
    return refreshTotalSeconds
  end

  def self.parseResultArray(currentDateTime, lumnisResult, _charInfo)
    resultArray = lumnisResult.split(".")
    experienceArray = resultArray[0].split(" ")
    doubledExperience = 0
    tripledExperience = 0
    experienceElementNumber = 0
    experienceArray.each { |experienceArrayElement|
      if experienceArrayElement =~ /tripled/
        tripledExperience = experienceArray[experienceElementNumber - 3]
      elsif experienceArrayElement =~ /doubled/
        doubledExperience = experienceArray[experienceElementNumber - 3]
      else

      end

      experienceElementNumber += 1
    }
    timeArray = resultArray[1].split(" ")
    refreshDays = 0
    refreshHours = 0
    refreshMinutes = 0
    timeElementNumber = 0
    timeArray.each { |timeArrayElement|
      if timeArrayElement =~ /minute/
        refreshMinutes = timeArray[timeElementNumber - 1]
      elsif timeArrayElement =~ /hour/
        refreshHours = timeArray[timeElementNumber - 1]
      elsif timeArrayElement =~ /day/
        refreshDays = timeArray[timeElementNumber - 1]
      else

      end
      timeElementNumber += 1
    }
    totalSeconds = calcTotalSeconds(refreshDays, refreshHours, refreshMinutes)
    refreshWhen = currentDateTime + totalSeconds
    @allcharInfo["#{XMLData.name}"][:lastcheckwhen] = currentDateTime
    @allcharInfo["#{XMLData.name}"][:refreshwhen] = refreshWhen
    @allcharInfo["#{XMLData.name}"][:refreshdays] = refreshDays.to_i
    @allcharInfo["#{XMLData.name}"][:refreshhours] = refreshHours.to_i
    @allcharInfo["#{XMLData.name}"][:refreshminutes] = refreshMinutes.to_i
    @allcharInfo["#{XMLData.name}"][:doubledexperience] = doubledExperience.to_i
    @allcharInfo["#{XMLData.name}"][:tripledexperience] = tripledExperience.to_i
    return
  end

  def self.getInvokerInfo
    watchedSpells = Array.[]("101", "104", "105", "107", "112", "401", "406", "414", "503", "509", "601", "602", "618", "911", "1204", "1208")
    totalDuration = 0
    watchedSpells.each do |watchedSpell|
      spellFound = false
      Spell.active.each do |spell|
        # echo "#{watchedSpell} #{spell.num}"
        if watchedSpell.to_i == spell.num.to_i
          spellFound = true
          totalDuration += spell.timeleft
          # echo "#{watchedSpell} #{spell.num} (#{spell.name} #{spell.timeleft})"

        end
      end
    end
    averageTime = (totalDuration / watchedSpells.count).to_i
    return averageTime
  end

  def self.getLumnisInfo
    currentDateTime = Time.now
    lastScheduleMonth = nil
    lastScheduleDay = nil
    lastScheduleYear = nil
    lumnisResult = nil
    lumnisinfodone = false
    lumnismon_f2p = false

    lumnis_info_get = proc do
      filter = false
      action = proc do |server_string|
        if server_string =~ /It is scheduled to refresh|restart as soon as you gain experience|Because your account is free,/
          filter = true
          lumnisResult = server_string
          lumnismon_f2p = true if server_string =~ /Because your account is free,/
          # echo "filter"
          next(nil)
        elsif server_string.strip.length == 0 && filter
          next(nil)
        elsif server_string =~ /You last used a Lumnis scheduling option|You have not selected a Gift of Lumnis schedule\./ && filter
          # echo "schedule and shit"
          if server_string =~ /You last used a Lumnis scheduling option on (?:Sun|Mon|Tue|Wed|Thu|Fri|Sat) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d+) ........ .. (\d+)\.(?:\s\sYou must wait six months from then to use another Lumnis scheduling option\.)?/
            lastScheduleMonth = $1
            lastScheduleDay = $2
            lastScheduleYear = $3
            if server_string !~ /You must wait six months from then to use another Lumnis scheduling option./
              lastScheduleMonth = "Ready"
              lastScheduleYear = "Ready"
              lastScheduleDay = "Ready"
            end
          elsif server_string =~ /You have not selected/
            lastScheduleMonth = "Ready"
            lastScheduleDay = "Ready"
            lastScheduleYear = "Ready"
          end
          next(nil)
        elsif server_string =~ /Your Gift of Lumnis is scheduled|You have [,\d]+ available uses? of |You have no available uses of / && filter
          next(nil)
        elsif server_string =~ /^\<prompt time\=/ && filter
          DownstreamHook.remove("lumnismon_lumnis_info_scoop")
          lumnisinfodone = true
          next(nil)
        else
          next(server_string)
        end
      end

      DownstreamHook.add("lumnismon_lumnis_info_scoop", action)
      silence_me
      put "lumnis info"
      silence_me
    end

    lumnis_info_get.call
    wait_until { lumnisinfodone }

    nextmonth = nil
    if lastScheduleMonth == "Ready"
      nextmonth = "Ready"
    elsif lastScheduleMonth == "Jan"
      nextmonth = "7"
    elsif lastScheduleMonth == "Feb"
      nextmonth = "8"
    elsif lastScheduleMonth == "Mar"
      nextmonth = "9"
    elsif lastScheduleMonth == "Apr"
      nextmonth = "10"
    elsif lastScheduleMonth == "May"
      nextmonth = "11"
    elsif lastScheduleMonth == "Jun"
      nextmonth = "12"
    elsif lastScheduleMonth == "Jul"
      nextmonth = "1"
    elsif lastScheduleMonth == "Aug"
      nextmonth = "2"
    elsif lastScheduleMonth == "Sep"
      nextmonth = "3"
    elsif lastScheduleMonth == "Oct"
      nextmonth = "4"
    elsif lastScheduleMonth == "Nov"
      nextmonth = "5"
    elsif lastScheduleMonth == "Dec"
      nextmonth = "6"
    end

    nextsyear = nil
    if lastScheduleMonth =~ /Jan|Feb|Mar|Apr|May|Jun/
      nextsyear = (lastScheduleYear).to_s.slice(2..3)
    elsif lastScheduleMonth == "Ready"
      nextsyear = "Ready"
    else
      nextsyear = (lastScheduleYear.to_i + 1).to_s.slice(2..3)
    end

    unless lumnismon_f2p == true
      if nextsyear == "Ready"
        nextScheduleString = "Ready"
      else
        nextScheduleString = "#{nextmonth}/#{lastScheduleDay}"
      end
    else
      nextScheduleString = "F2P"
    end

    curweekres = nil
    curtotres = nil
    cursuff = nil
    resourcedone = false

    resource_get = proc do
      filter = false
      action = proc do |server_string|
        if server_string =~ /(?:\<pushBold\/\>)?[,\d]+(?:\<popBold\/\>)?\/(?:\<pushBold\/\>)?[,\d]+(?:\<popBold\/\>)?\s+Mana\:/
          filter = true
          next(nil)
        elsif server_string.strip.length == 0 && filter
          next(nil)
        elsif server_string =~ /^(?:\<popBold\/\>)?Voln Favor\:/ && filter
          next(nil)
        elsif server_string =~ /^(?:\<popBold\/\>)?(?:Guile|Luck Inspiration|Essence|Necrotic Energy|Motes of Tranquility|Grit|Devotion|Nature's Grace|Devotion):\s+([,\d]+)\/50,000 \(Weekly\)\s+([,\d]+)\/200,000\s+\(Total\)/ && filter
          curweekres = $1.delete(",")
          curtotres = $2.delete(",")
          next(nil)
        elsif server_string =~ /^Suffused (?:Guile|Luck Inspiration|Essence|Necrotic Energy|Motes of Tranquility|Grit|Devotion|Nature's Grace|Devotion)\: ([,\d]+)/ && filter
          cursuff = $1.delete(',')
          next(nil)
        elsif server_string =~ /\<prompt time\=/ && filter
          DownstreamHook.remove("lumnismon_resource_scoop")
          resourcedone = true
          next(nil)
        else
          next(server_string)
        end
      end

      DownstreamHook.add("lumnismon_resource_scoop", action)
      silence_me
      put "resource"
      silence_me
    end

    unless lumnismon_f2p == true
      if (Stats.prof == "Bard" && Stats.level >= 20) || (Stats.prof == "Monk" && Stats.level >= 20) || (Stats.prof == "Wizard" && Stats.level >= 25 && Spell[925].known?) || (Stats.prof == "Sorcerer" && Stats.level >= 35 && Spell[735].known?) || (Stats.prof == "Warrior" && Stats.level >= 20) || (Stats.prof == "Cleric" && Stats.level >= 30 && Spell[330].known?) || (Stats.prof == "Ranger" && Stats.level >= 20 && Spell[620].known?) || (Stats.prof == "Paladin" && Stats.level >= 20 && Spell[1620].known?) || (Stats.prof == "Rogue" && Stats.level >= 20)  || (Stats.prof == "Empath" && Spell[1135].known?)
        resource_get.call
        wait_until { resourcedone }
      else
        curweekres = "RSN"
        curtotres = "RSN"
        cursuff = "RSN"
      end
    else
      curweekres = "F2P"
      curtotres = "F2P"
      cursuff = "F2P"
    end

    expdone = false
    curmind = 0
    curdeed = 0

    exp_get = proc do
      filter = false
      action = proc do |server_string|
        if server_string =~ /^\s+Level\:\s+\d+\s+Fame\:\s+(?:[,\d]*)/
          filter = true
          next(nil)
        elsif server_string.strip.length == 0 && filter
          next(nil)
          # You feel a strange sense of serenity and find that you are able to reflect on recent events with uncommon clarity and understanding.
        elsif server_string =~ /\s+Ascension Exp\:\s+[,\d]+|\s+Total\sExp\:\s+[,\d]+|Exp to next TP\:|Exp until lvl\: |PTPs\/MTPs\:\s+[,\d]+\/[,\d]+|Your mind|You feel a strange sense of serenity and find|Your recent adventures echo powerfully in your mind\./ && filter
          next(nil)
        elsif server_string =~ /Deeds\: (\d+)/ && filter
          curdeed = $1
          next(nil)
        elsif server_string =~ /Field Exp: ([\d,]+)\/([\d,]+)/ && filter
          curmind = $1.delete(",")
          next(nil)
        elsif server_string =~ /^\<prompt time\=/ && filter
          DownstreamHook.remove("lumnismon_exp_scoop")
          expdone = true
          next(nil)
        else
          next(server_string)
        end
      end

      DownstreamHook.add("lumnismon_exp_scoop", action)
      silence_me
      put "experience"
      silence_me
    end

    exp_get.call
    wait_until { expdone }

    bps = 0
    bpsdone = false

    bps_get = proc do
      filter = false
      action = proc do |server_string|
        if server_string =~ /\<a exist\=\"\-\d+\" noun=\"#{XMLData.name}\">#{XMLData.name}<\/a>, your Adventurer\'s Guild information is as follows\:/
          filter = true
          next(nil)
        elsif server_string.strip.length == 0 && filter
          next(nil)
        elsif server_string =~ /You have succeeded|You have accumulated a total of|You have [,\d]+ expedited|You are not currently|You have succeeded at the|You have been tasked|The taskmaster told you/ && filter
          next(nil)
        elsif server_string =~ /You currently have ([,\d]+) unspent bounty points./ && filter
          bps = $1.delete(",").to_i
          next(nil)
        elsif server_string =~ /^\<prompt time\=/ && filter
          DownstreamHook.remove("lumnismon_bounty_points_scoop")
          bpsdone = true
          next(nil)
        else
          next(server_string)
        end
      end

      DownstreamHook.add("lumnismon_bounty_points_scoop", action)
      silence_me
      put "bounty"
      silence_me
    end

    bps_get.call
    wait_until { bpsdone }

    suffix = ""
    if bps > 1000000000
      bps = bps.to_f
      bps = (bps / 1000000000).truncate(2)
      suffix = "B"
    elsif bps > 1000000
      bps = bps.to_f
      bps = (bps / 1000000).truncate(2)
      suffix = "M"
    elsif bps > 1000
      bps = bps.to_f
      bps = (bps / 1000).truncate(0)
      suffix = "K"
    end

    bps = bps.to_s + suffix
    averageInvokerTime = getInvokerInfo()
    refreshDays = 0
    refreshHours = 0
    refreshMinutes = 0
    @allcharInfo["#{XMLData.name}"][:charactername] = XMLData.name
    if UserVars.lumnismon[:char_account].nil? || UserVars.lumnismon[:char_account] == ""
      @allcharInfo["#{XMLData.name}"][:characteraccount] = "9999 Not Listed"
    else
      @allcharInfo["#{XMLData.name}"][:characteraccount] = UserVars.lumnismon[:char_account]
    end
    @allcharInfo["#{XMLData.name}"][:nextschedulestring] = nextScheduleString
    @allcharInfo["#{XMLData.name}"][:profession] = Stats.prof
    @allcharInfo["#{XMLData.name}"][:level] = Char.level
    @allcharInfo["#{XMLData.name}"][:mindcapacity] = MyInfo.getMindCapacity()
    @allcharInfo["#{XMLData.name}"][:mindpercent] = MyInfo.getMindPercent()
    @allcharInfo["#{XMLData.name}"][:currentmind] = curmind
    @allcharInfo["#{XMLData.name}"][:currentdeed] = curdeed
    @allcharInfo["#{XMLData.name}"][:currentweeklyresource] = curweekres
    @allcharInfo["#{XMLData.name}"][:currenttotalresource] = curtotres
    @allcharInfo["#{XMLData.name}"][:currentsuffusedresource] = cursuff
    @allcharInfo["#{XMLData.name}"][:currentexp] = Char.exp
    @allcharInfo["#{XMLData.name}"][:bountypoints] = bps
    @allcharInfo["#{XMLData.name}"][:customplace] = UserVars.lumnismon[:custom_place]
    @allcharInfo["#{XMLData.name}"][:invokerspellsremaining] = averageInvokerTime

    if Char.level == 100
      @allcharInfo["#{XMLData.name}"][:expnext] = "Cap"
    else
      @allcharInfo["#{XMLData.name}"][:expnext] = MyInfo.expUntilnext()
    end

    unless lumnismon_f2p == true
      if lumnisResult =~ /Your Gift of Lumnis will restart as soon as you gain experience/
        refreshDateTime = currentDateTime
        @allcharInfo["#{XMLData.name}"][:lastcheckwhen] = currentDateTime
        @allcharInfo["#{XMLData.name}"][:refreshwhen] = refreshDateTime
        @allcharInfo["#{XMLData.name}"][:refreshdays] = refreshDays
        @allcharInfo["#{XMLData.name}"][:refreshhours] = refreshHours
        @allcharInfo["#{XMLData.name}"][:refreshminutes] = refreshMinutes
        @allcharInfo["#{XMLData.name}"][:doubledexperience] = 7300
        @allcharInfo["#{XMLData.name}"][:tripledexperience] = 7300
        # Triple and Double Exp left
      elsif lumnisResult =~ /You have/ and lumnisResult =~ /points of tripled experience followed by/
        MyInfo.parseResultArray(currentDateTime, lumnisResult, @allcharInfo["#{XMLData.name}"])
        # Double Exp left
      elsif lumnisResult =~ /You have/ and lumnisResult =~ /points of doubled experience/
        MyInfo.parseResultArray(currentDateTime, lumnisResult, @allcharInfo["#{XMLData.name}"])
        # No Lumnis left
      elsif lumnisResult =~ /Your Gift of Lumnis has expired for this week./
        MyInfo.parseResultArray(currentDateTime, lumnisResult, @allcharInfo["#{XMLData.name}"])
      else
        echo "Lumnis Info was not found and therefore unable to be parsed"
      end
    else
      @allcharInfo["#{XMLData.name}"][:lastcheckwhen] = "F2P"
      @allcharInfo["#{XMLData.name}"][:refreshwhen] = "F2P"
      @allcharInfo["#{XMLData.name}"][:refreshdays] = "F2P"
      @allcharInfo["#{XMLData.name}"][:refreshhours] = "F2P"
      @allcharInfo["#{XMLData.name}"][:refreshminutes] = "F2P"
      @allcharInfo["#{XMLData.name}"][:doubledexperience] = "F2P"
      @allcharInfo["#{XMLData.name}"][:tripledexperience] = "F2P"
    end
  end

  def self.save()
    File.write(@myinfofilename, @allcharInfo.to_yaml)
    Lich::Messaging.msg("info", "#{Script.self}: Data saved to #{@myinfofilename}.")
  end

  def self.parseMinutesToString(minuteValue)
    hTime = (minuteValue / 60).to_i
    mTime = (minuteValue % 60).to_i
    timeString = "#{hTime}h#{mTime}m"
    # echo timeString
    return timeString
  end

  def self.report()
    # output header for screen display
    justname = 5
    justprof = 5
    justaccount = 8
    justlevel = 4
    justdeed = 5
    just2x = 3
    just3x = 3
    juststatus = 5
    justfldxp = 4
    justxptn = 4
    justweek = 4
    justtot = 4
    justsuf = 4
    justlastcheck = 9
    justrefresh = 9
    justinvoker = 9
    justnextsched = 6
    @allcharInfo.each do |thechar|
      char = thechar[1]
      refreshstring = ""
      if char[:invokerspellsremaining] == nil
        char[:invokerspellsremaining] = 0
      end

      unless char[:refreshwhen] == "F2P"
        if Time.now >= char[:refreshwhen]
          refreshstring = "Ready"
        elsif Time.now < char[:refreshwhen]
          t = char[:refreshwhen] - Time.now
          mm, _ss = t.divmod(60)
          hh, mm = mm.divmod(60)
          dd, hh = hh.divmod(24)
          hh = hh.to_s.rjust(2, '0')
          mm = mm.to_s.rjust(2, '0')
          refreshstring = "#{dd}d#{hh}h#{mm}m"
        end
      else
        char[:refreshwhen] = Time.now + 2592000
        refreshstring = "F2P"
      end
      char[:customplace] = 0 if char[:customplace].nil?
      char[:refreshstring] = refreshstring
      justname = (char[:charactername].to_s.length + 1) if (char[:charactername].to_s.length + 1) > justname
      justaccount = (char[:characteraccount].to_s.length + 1) if (char[:characteraccount].to_s.length + 1) > justaccount
      just2x = (char[:doubledexperience].to_s.length + 1) if (char[:doubledexperience].to_s.length + 1) > just2x
      just3x = (char[:tripledexperience].to_s.length + 1) if (char[:tripledexperience].to_s.length + 1) > just3x
      justfldxp = (char[:currentmind].to_s.length + 1) if (char[:currentmind].to_s.length + 1) > justfldxp
      justxptn = (char[:expnext].to_s.length + 1) if (char[:expnext].to_s.length + 1) > justxptn
      justweek = (char[:currentweeklyresource].to_s.length + 1) if (char[:currentweeklyresource].to_s.length + 1) > justweek
      justtot = (char[:currenttotalresource].to_s.length + 1) if (char[:currenttotalresource].to_s.length + 1) > justtot
      justsuf = (char[:currentsuffusedresource].to_s.length + 1) if (char[:currentsuffusedresource].to_s.length + 1) > justsuf
      unless char[:lastcheckwhen] == "F2P"
        justlastcheck = (char[:lastcheckwhen].strftime("%H%M %-d/%-m").to_s.length + 1) if (char[:lastcheckwhen].strftime("%H%M %-d/%-m").to_s.length + 1) > justlastcheck
      end
      justrefresh = (char[:refreshstring].length + 1) if (char[:refreshstring].length + 1) > justrefresh
      justinvoker = (parseMinutesToString(char[:invokerspellsremaining]).length + 1) if (parseMinutesToString(char[:invokerspellsremaining]).length + 1) > justinvoker

      justnextsched = (char[:nextschedulestring].length + 1) if (char[:nextschedulestring].length + 1) > justnextsched
    end
    totaljust = 0
    echo "All Values are based off of the last time that character ran LumnisMon"
    screenOutputline = "Char".ljust(justname)
    totaljust += justname
    ## Demandred - put in a bunch of uservars for showing or not showing stuff
    if UserVars.lumnismon[:show_account] == true && UserVars.lumnismon[:account_inline] == true
      screenOutputline += "Account".ljust(justaccount)
      totaljust += justaccount
    end
    if UserVars.lumnismon[:show_prof] == true
      screenOutputline += "Prof".ljust(justprof)
      totaljust += justprof
    end
    if UserVars.lumnismon[:show_level] == true
      screenOutputline += "Lvl".ljust(justlevel)
      totaljust += justlevel
    end
    if UserVars.lumnismon[:show_deeds] == true
      screenOutputline += "Deed".ljust(justdeed)
      totaljust += justdeed
    end

    if UserVars.lumnismon[:show_invoker] == true
      screenOutputline += "Invoker".ljust(justdeed)
      totaljust += justdeed
    end

    if UserVars.lumnismon[:show_check_time] == true
      screenOutputline += "ChckTime".ljust(justlastcheck)
      totaljust += justlastcheck
    end
    if UserVars.lumnismon[:show_renew_time] == true
      screenOutputline += "RenTim".ljust(justrefresh)
      totaljust += justrefresh
    end
    screenOutputline += "2x".ljust(just2x)
    totaljust += just2x
    screenOutputline += "3x".ljust(just3x)
    totaljust += just3x
    screenOutputline += "Stat".ljust(juststatus)
    totaljust += juststatus
    if UserVars.lumnismon[:show_field_exp] == true
      screenOutputline += "Fld".ljust(justfldxp)
      totaljust += justfldxp
    end
    if UserVars.lumnismon[:show_xpn] == true
      screenOutputline += "XPN".ljust(justxptn)
      totaljust += justxptn
    end
    if UserVars.lumnismon[:show_weekly_resource] == true
      screenOutputline += "WRe".ljust(justweek)
      totaljust += justweek
    end
    if UserVars.lumnismon[:show_total_resource] == true
      screenOutputline += "TRe".ljust(justtot)
      totaljust += justtot
    end
    if UserVars.lumnismon[:show_suffused_resource] == true
      screenOutputline += "SRe".ljust(justsuf)
      totaljust += justsuf
    end
    if UserVars.lumnismon[:show_next_schedule] == true
      screenOutputline += "NxSch".ljust(justnextsched)
      totaljust += justnextsched
    end
    if UserVars.lumnismon[:show_bps] == true
      screenOutputline += "BPs"
    end
    _respond("<output class=\"mono\"/>#{monsterbold_start}#{screenOutputline}#{monsterbold_end}\r\n<output class=\"\"/>")
    firstchar = true
    if UserVars.lumnismon[:sort_by_refresh] == true && UserVars.lumnismon[:sort_by_account] == true
      @allcharInfo = @allcharInfo.sort_by { |_k, v| [v[:characteraccount], v[:refreshwhen]] }
      echo "sorted refresh & account"
    elsif UserVars.lumnismon[:sort_by_refresh] == false && UserVars.lumnismon[:sort_by_account] == true
      @allcharInfo = @allcharInfo.sort_by { |k, v| [v[:characteraccount], k] }
      echo "sorted account"
    elsif UserVars.lumnismon[:sort_by_refresh] == true && UserVars.lumnismon[:sort_by_account] == false
      @allcharInfo = @allcharInfo.sort_by { |k, v| [v[:refreshwhen], k] }
    end
    for trackedCharacter in @allcharInfo
      charInfo = trackedCharacter[1]
      if UserVars.lumnismon[:account_inline] == false && UserVars.lumnismon[:sort_by_account] == true
        if UserVars.lumnismon[:show_account] == true
          if firstchar == true
            _respond("<output class=\"mono\"/>#{monsterbold_start}#{charInfo[:characteraccount].upcase.center(totaljust)}#{monsterbold_end}\r\n<output class=\"\"/>")
            currentAccount = charInfo[:characteraccount]
            firstchar = false
          end
          if currentAccount != charInfo[:characteraccount]
            _respond("<output class=\"mono\"/>#{monsterbold_start}#{charInfo[:characteraccount].upcase.center(totaljust)}#{monsterbold_end}\r\n<output class=\"\"/>")
            currentAccount = charInfo[:characteraccount]
          end
        elsif UserVars.lumnismon[:show_account] == false
          if firstchar == true
            count = 1
            thetext = "ACCOUNT#{count}"
            _respond("<output class=\"mono\"/>#{monsterbold_start}#{thetext.upcase.center(totaljust)}#{monsterbold_end}\r\n<output class=\"\"/>")
            currentAccount = charInfo[:characteraccount]
            firstchar = false
          end
          if currentAccount != charInfo[:characteraccount]
            count += 1
            thetext = "ACCOUNT#{count}"
            _respond("<output class=\"mono\"/>#{monsterbold_start}#{thetext.upcase.center(totaljust)}#{monsterbold_end}\r\n<output class=\"\"/>")
            currentAccount = charInfo[:characteraccount]
          end
        end
      end
      if charInfo[:charactername] != nil and charInfo[:charactername] != ""

        screenOutputline = "#{charInfo[:charactername].ljust(justname)}"
        if UserVars.lumnismon[:show_account] == true && UserVars.lumnismon[:account_inline] == true
          screenOutputline += "#{charInfo[:characteraccount].upcase.ljust(justaccount)}"
        end
        if UserVars.lumnismon[:show_prof] == true
          screenOutputline += "#{charInfo[:profession].slice(0..2).ljust(justprof)}"
        end
        if UserVars.lumnismon[:show_level] == true
          screenOutputline += "#{charInfo[:level].to_s.ljust(justlevel)}"
        end
        if UserVars.lumnismon[:show_deeds] == true
          screenOutputline += "#{charInfo[:currentdeed].ljust(justdeed)}"
        end
        if UserVars.lumnismon[:show_invoker] == true
          screenOutputline += "#{parseMinutesToString(charInfo[:invokerspellsremaining]).ljust(justinvoker)}"
        end

        # echo "Break Check 1"
        if UserVars.lumnismon[:show_check_time] == true
          screenOutputline += "#{(charInfo[:lastcheckwhen]).strftime("%H%M %-d/%-m").to_s.ljust(justlastcheck)}"
        end
        # echo "Break Check 2"
        if UserVars.lumnismon[:show_renew_time] == true
          if charInfo[:refreshstring] == "F2P"
            screenOutputline += "<preset id=\"speech\">#{charInfo[:refreshstring].to_s.ljust(justrefresh)}</preset>"
          else
            screenOutputline += "#{(charInfo[:refreshstring])}".ljust(justrefresh)
          end
        end
        # echo "Break Check 3"

        unless charInfo[:refreshwhen] > (Time.now + 1000000)
          if (charInfo[:refreshwhen]) < Time.now
            screenOutputline += "7300".ljust(just2x)
            screenOutputline += "7300".ljust(just3x)
            screenOutputline += "Rdy".ljust(juststatus)
          else
            if charInfo[:doubledexperience].to_i == 0
              screenOutputline += "<preset id=\"watching\">#{charInfo[:doubledexperience].to_s.ljust(just2x)}</preset>"
              screenOutputline += "<preset id=\"watching\">#{charInfo[:tripledexperience].to_s.ljust(just3x)}</preset>"
            else
              screenOutputline += "#{charInfo[:doubledexperience].to_s.ljust(just2x)}"
              screenOutputline += "#{charInfo[:tripledexperience].to_s.ljust(just3x)}"
            end
            if charInfo[:doubledexperience].to_i > 0 or charInfo[:tripledexperience].to_i > 0
              screenOutputline += "Act".ljust(juststatus)
            else
              screenOutputline += "<preset id=\"watching\">" + "Exp".ljust(juststatus) + "</preset>"
            end
          end
        else
          screenOutputline += "<preset id=\"speech\">" + "F2P".ljust(just2x) + "</preset>"
          screenOutputline += "<preset id=\"speech\">" + "F2P".ljust(just3x) + "</preset>"
          screenOutputline += "<preset id=\"speech\">" + "F2P".ljust(juststatus) + "</preset>"
        end
        if UserVars.lumnismon[:show_field_exp] == true
          screenOutputline += "#{charInfo[:currentmind]}".ljust(justfldxp)
        end
        if UserVars.lumnismon[:show_xpn] == true
          if charInfo[:expnext] == "Cap"
            screenOutputline += "<preset id=\"watching\">" + charInfo[:expnext].ljust(justxptn) + "</preset>"
          else
            screenOutputline += "#{charInfo[:expnext]}".to_s.ljust(justxptn)
          end
        end
        if UserVars.lumnismon[:show_weekly_resource] == true
          unless charInfo[:currentweeklyresource] == "F2P"
            if charInfo[:currentweeklyresource].to_i == 50000
              screenOutputline += "<preset id=\"watching\">#{charInfo[:currentweeklyresource].to_s.ljust(justweek)}</preset>"
            elsif charInfo[:currenttotalresource].to_i == 200000
              screenOutputline += "<preset id=\"speech\">#{charInfo[:currentweeklyresource].to_s.ljust(justweek)}</preset>"
            elsif charInfo[:currenttotalresource] == "RSN"
              screenOutputline += "<preset id=\"thought\">#{charInfo[:currentweeklyresource].to_s.ljust(justweek)}</preset>"
            elsif charInfo[:currenttotalresource] == "ATN"
              screenOutputline += "<preset id=\"speech\">#{charInfo[:currentweeklyresource].to_s.ljust(justweek)}</preset>"
            else
              screenOutputline += "#{charInfo[:currentweeklyresource]}".to_s.ljust(justweek)
            end
          else
            screenOutputline += "<preset id=\"speech\">#{charInfo[:currentweeklyresource].to_s.ljust(justweek)}</preset>"
          end
        end
        if UserVars.lumnismon[:show_total_resource] == true
          unless charInfo[:currenttotalresource] == "F2P"
            if charInfo[:currenttotalresource].to_i == 200000
              screenOutputline += "<preset id=\"speech\">#{charInfo[:currenttotalresource].to_s.ljust(justtot)}</preset>"
            elsif charInfo[:currenttotalresource].to_i > 150000 && charInfo[:currenttotalresource].to_i < 200000
              screenOutputline += "<pushBold/>#{charInfo[:currenttotalresource].to_s.ljust(justtot)}<popBold/>"
            elsif charInfo[:currenttotalresource] == "RSN"
              screenOutputline += "<preset id=\"thought\">#{charInfo[:currenttotalresource].to_s.ljust(justtot)}</preset>"
            elsif charInfo[:currenttotalresource] == "ATN"
              screenOutputline += "<preset id=\"speech\">#{charInfo[:currenttotalresource].to_s.ljust(justtot)}</preset>"
            else
              screenOutputline += "#{charInfo[:currenttotalresource]}".to_s.ljust(justtot)
            end
          else
            screenOutputline += "<preset id=\"speech\">#{charInfo[:currenttotalresource].to_s.ljust(justtot)}</preset>"
          end
        end
        if UserVars.lumnismon[:show_suffused_resource] == true
          if charInfo[:currentsuffusedresource] == "RSN"
            screenOutputline += "<preset id=\"thought\">#{charInfo[:currentsuffusedresource].to_s.ljust(justsuf)}</preset>"
          elsif charInfo[:currentsuffusedresource] == "ATN"
            screenOutputline += "<preset id=\"speech\">#{charInfo[:currentsuffusedresource].to_s.ljust(justsuf)}</preset>"
          elsif charInfo[:currentsuffusedresource] == "F2P"
            screenOutputline += "<preset id=\"speech\">#{charInfo[:currentsuffusedresource].to_s.ljust(justsuf)}</preset>"
          else
            screenOutputline += "#{charInfo[:currentsuffusedresource]}".to_s.ljust(justsuf)
          end
        end
        # echo screenOutputline.length
        if UserVars.lumnismon[:show_next_schedule] == true
          screenOutputline += "#{charInfo[:nextschedulestring]}".ljust(justnextsched)
        end
        if UserVars.lumnismon[:show_bps] == true
          screenOutputline += "#{charInfo[:bountypoints]}"
        end
        _respond("<output class=\"mono\"/>#{screenOutputline}\r\n<output class=\"\"/>")
        # echo screenOutputline
      end
    end
    # }
  end

  def self.giveInstructions
    Lich::Messaging.msg("info", "Welcome to LumnisMon/MyInfo. We provide a bunch of cool info to help you track what your characters are doing each week!")
    Lich::Messaging.msg("info", "From lumnis info to resources to bounty points to deeds...there's a lot here now.")
    _respond ""
    Lich::Messaging.msg("info", "Run ';lumnismon' by itself to get and record the information for this character and report any other characters that are already logged")
    Lich::Messaging.msg("info", "Run ';lumnismon log' to execute lumnis info and log the results but not show the report for other characters upon completion")
    Lich::Messaging.msg("info", "Run ';lumnismon help' or 'lumnismon ?' shows this dialog you are reading now.")
    Lich::Messaging.msg("info", "Run ';lumnismon report' to only load and report what is stored, not logging anything.")
    _respond ""
    Lich::Messaging.msg("info", "In addition, you can set a whole lot of options, including picking one of two ways to sort, whether you want to see your account...well, enough, here's the options and how to set them, and what they are currently set to!!! (hint: all the dashes in the settings are also optional ;)")
    _respond
    Lich::Messaging.msg("info", "Setting: --show-account=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "-- what it says. The behavior of this combines with the sort by renew? setting further down, as well - if you combine show account, turn off inline account, and choose not to sort by renew time, it will divide all your accounts up, then have one header each!")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_account]}")
    _respond
    Lich::Messaging.msg("info", "Setting: --char-account=ACCOUNT")
    Lich::Messaging.msg("info", "-- if you choose to show account, this actually defaults to '9999 Not Listed'. You'd want to set this to your account name. If you don't show account, it doesn't matter. (hint: if you capitalize these, it will sort capital 'Z' before lowercase 'a' if you sort by account and character name...you can also use nonsense names!)")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:char_account]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --account-inline=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "This determines, when choosing to show your account, whether it appears inline or as a header. Set to on/etc to show in the line, off/etc to show as a header.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:account_inline]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-prof=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show your profession.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_prof]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-level=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show your level.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_level]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-deeds=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show your current deeds.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_deeds]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-invoker=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show Average time remaining for invoker supplied spells.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_invoker]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-check-time=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show the last time you checked your info.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_check_time]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-renew-time=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show how long until your next lumnis starts.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_renew_time]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-field-exp=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show field exp on last check.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_field_exp]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-weekly-resource=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show your weekly resource.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_weekly_resource]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-total-resource=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show your total resource.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_total_resource]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-suffused-resource=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show your suffused resource.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_suffused_resource]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-xpn=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Show how much exp to next level(shows 'Cap' if 100)")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_xpn]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-next-schedule=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Shows next (approximate) date you can use a lumnis schedule to get some extra exp!")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_next_schedule]}")
    _respond ""
    Lich::Messaging.msg("info", "Setting: --show-bps=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Shows your bounty points, truncated.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:show_bps]}")
    _respond ""
    Lich::Messaging.msg("speech", "The sorting options below work thus: Refresh and account can work in tandem. Account or refresh alone will use character name as the tiebreaker.")
    _respond
    Lich::Messaging.msg("info", "Setting: --sort-by-refresh=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Sort by time of next lumnis renewal.")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:sort_by_refresh]}")
    _respond
    Lich::Messaging.msg("info", "Setting: --sort-by-account=on|yes|true|off|no|false")
    Lich::Messaging.msg("info", "Will sort by account name you specify. (can use this with fake names for a custom sort method to group people how you want!)")
    Lich::Messaging.msg("bold", "Currently: #{UserVars.lumnismon[:sort_by_account]}")
    _respond
  end
end

logOnly = false
reportOnly = false

UserVars.lumnismon = {} if UserVars.lumnismon.nil?
UserVars.lumnismon[:show_account] = false if UserVars.lumnismon[:show_account].nil?
UserVars.lumnismon[:char_account] = UserVars.lumnismon_char_account unless UserVars.lumnismon_char_account.nil?
UserVars.lumnismon[:char_account] = "9999 Not Listed" if UserVars.lumnismon[:char_account].nil?
UserVars.lumnismon[:account_inline] = false if UserVars.lumnismon[:account_inline].nil?
UserVars.lumnismon[:show_prof] = true if UserVars.lumnismon[:show_prof].nil?
UserVars.lumnismon[:show_level] = true if UserVars.lumnismon[:show_level].nil?
UserVars.lumnismon[:show_deeds] = true if UserVars.lumnismon[:show_deeds].nil?
UserVars.lumnismon[:show_invoker] = true if UserVars.lumnismon[:show_invoker].nil?
UserVars.lumnismon[:show_check_time] = false if UserVars.lumnismon[:show_check_time].nil?
UserVars.lumnismon[:show_renew_time] = false if UserVars.lumnismon[:show_renew_time].nil?
UserVars.lumnismon[:show_field_exp] = true if UserVars.lumnismon[:show_field_exp].nil?
UserVars.lumnismon[:show_weekly_resource] = true if UserVars.lumnismon[:show_weekly_resource].nil?
UserVars.lumnismon[:show_total_resource] = true if UserVars.lumnismon[:show_total_resource].nil?
UserVars.lumnismon[:show_suffused_resource] = true if UserVars.lumnismon[:show_suffused_resource].nil?
UserVars.lumnismon[:show_xpn] = true if UserVars.lumnismon[:show_xpn].nil?
UserVars.lumnismon[:show_next_schedule] = false if UserVars.lumnismon[:show_next_schedule].nil?
UserVars.lumnismon[:show_bps] = true if UserVars.lumnismon[:show_bps].nil?
UserVars.lumnismon[:sort_by_refresh] = false if UserVars.lumnismon[:sort_by_refresh].nil?
UserVars.lumnismon[:sort_by_account] = true if UserVars.lumnismon[:sort_by_account].nil?

setting_value = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
# new var handling for builtin setup options and such...
unless Script.current.vars[0].nil?
  did_something = false
  if Script.current.vars[0] =~ /^log$/
    logOnly = true
    did_something = true
  elsif Script.current.vars[0] =~ /^help$|\?$/
    MyInfo.giveInstructions
    exit
  elsif Script.current.vars[0] =~ /^report$/
    reportOnly = true
    did_something = true
  else
    for var in Script.current.vars[1..-1]
      if var =~ /^(?:\-\-|\-)?show\-?account=(yes|no|on|off|true|false)$/
        UserVars.lumnismon[:show_account] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?char\-?account=(.+?)$/
        UserVars.lumnismon[:char_account] = $1
        did_something = true
      elsif var =~ /(?:\-\-|\-)?account\-?inline=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:account_inline] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?prof=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_prof] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?level=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_level] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?deeds=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_deeds] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?invoker=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_invoker] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?check\-?time=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_check_time] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?renew\-?time=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_renew_time] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?field\-?exp=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_field_exp] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?weekly\-?resource=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_weekly_resource] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?total\-?resource=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_total_resource] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?suffused\-?resource=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_suffused_resource] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?xpn=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_xpn] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?next\-?schedule=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_next_schedule] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?show\-?bps=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:show_bps] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?sort\-?by\-?refresh=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:sort_by_refresh] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?sort\-?by\-?account=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:sort_by_account] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?sort\-?by\-?name=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:sort_by_name] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?sort\-?by\-?custom=(yes|no|on|off|true|false)/
        UserVars.lumnismon[:sort_by_custom] = setting_value[$1]
        did_something = true
      elsif var =~ /(?:\-\-|\-)?custom\-?place=(\d+?)$/
        UserVars.lumnismon[:custom_place] = $1.to_i
        did_something = true
      end
    end
    if did_something == true
      Lich::Messaging.msg("info", "Saving var changes and exiting. Rerun plain or with 'log' as option to log data and/or see output.")
      exit
    end
  end
  unless did_something == true
    Lich::Messaging.msg("info", "No match to var options. Continuing with no vars.")
  end
end

MyInfo.load(reportOnly)
# skip these if reportOnly ('report' command line)
MyInfo.getLumnisInfo unless reportOnly == true
MyInfo.save unless reportOnly == true
# only output if we are not in log only mode
MyInfo.report unless logOnly
