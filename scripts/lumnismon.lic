=begin
  Rebuild by Demandred of the Vailans Original version but still being maintained by Vailan
  Demandred did a major overhaul of this and asked me to upload it for consistency. I think this is a major improvement over how I was doing it before and I
  Would like to really thank them for the effort they put into this.
  Major overhaul of vars and such. Sorting by var now. Etc etc. Check out ;lumnismon help

  Note: you will need to re-run this for all of your characters as it does not import the old csv file and starts from scratch

  author: elanthia-online
  contributors: Vailan, Demandred
  tags: character, information
  version: 1.2.3

  1.2.3 (2025-01-27)
    * Fix capped total resource highlight not working
  1.2.2 (2025-01-27)
    * Fix for additional cycle detection in LUMNIS INFO output
  1.2.1 (2025-01-23)
    * Fix for adding back colorizing table
  1.2.0 (2025-01-17)
    * Complete refactor with YARD documentation
    * DRY principles applied throughout
    * Ruby best practices and idioms
    * terminal-table integration for better output
    * Added 4x and 5x experience tracking
    * Extracted configuration management
    * Improved code organization and maintainability
  1.1.1 (2025-07-04)
    * Fix for Empath resource name Vitality to be tracked correctly
  1.1.0 (2025-04-06)
    * Update for Empath profession service going live
  1.0.1 (2024-11-05)
    * Update for Rogue profession service going live
  1.0.0 (2024-09-23)
    * Migrated under under EO
    * Updated for Paladins
=end

# Main module for character information tracking
module MyInfo
  require 'yaml'
  require 'terminal-table'

  # Constants for data structure
  DEFAULT_CHAR_INFO = {
    charactername: "",
    characteraccount: "",
    profession: "",
    level: "",
    lastcheckwhen: "",
    refreshwhen: "",
    doubledexperience: "",
    tripledexperience: "",
    quadrupledexperience: 0,      # Default to 0 (not enabled until donations detected)
    quintupledexperience: 0,      # Default to 0 (not enabled until donations detected)
    supports_4x_5x: false,        # Whether character has made Temple donations
    refreshdays: "",
    refreshhours: "",
    refreshminutes: "",
    refreshstring: "",
    mindcapacity: "",
    mindpercent: "",
    currentmind: "",
    currentdeed: "",
    currentweeklyresource: "",
    currenttotalresource: "",
    currentsuffusedresource: "",
    currentexp: "",
    expnext: "",
    nextschedulestring: "",
    bountypoints: "",
    customplace: "",
    invokerspellsremaining: ""
  }.freeze unless defined?(MyInfo::DEFAULT_CHAR_INFO)

  # Mind state to percentage mapping
  MIND_STATES = {
    "clear as a bell" => 0,
    "fresh and clear" => 0.25 / 2,
    "clear"           => 0.75 / 2,
    "muddled"         => 1.12 / 2,
    "becoming numbed" => 1.37 / 2,
    "numbed"          => 1.65 / 2,
    "must rest"       => 1.9 / 2,
    "saturated"       => 1
  }.freeze unless defined?(MyInfo::MIND_STATES)

  # Month to number mapping for schedule calculations
  MONTH_TO_NEXT = {
    "Ready" => "Ready",
    "Jan"   => "7",
    "Feb"   => "8",
    "Mar"   => "9",
    "Apr"   => "10",
    "May"   => "11",
    "Jun"   => "12",
    "Jul"   => "1",
    "Aug"   => "2",
    "Sep"   => "3",
    "Oct"   => "4",
    "Nov"   => "5",
    "Dec"   => "6"
  }.freeze unless defined?(MyInfo::MONTH_TO_NEXT)

  # Watched spells for invoker tracking
  WATCHED_SPELLS = %w[101 104 105 107 112 401 406 414 503 509 601 602 618 911 1204 1208].freeze unless defined?(MyInfo::WATCHED_SPELLS)

  @allcharInfo ||= {}

  class << self
    attr_accessor :allcharInfo

    # Displays a message with appropriate formatting
    # @param text [String] the message to display
    # @return [void]
    def message(text)
      string = monsterbold_start ? "\034GSL\r\n " : "<pushBold/>"
      string << if text.include?('\n')
                  text.split('\n').join
                else
                  text
                end
      string << (monsterbold_end ? "\034GSM\r\n " : "<popBold/>")
      _respond string
    end

    # Ensures the data directory exists
    # @return [void]
    def ensure_data_directory
      Dir.mkdir(File.join(DATA_DIR, "myinfo")) unless File.exist?(File.join(DATA_DIR, "myinfo"))
    end

    # Returns the filename for the current game's data
    # @return [String] the full path to the YAML data file
    def data_filename
      @myinfofilename ||= File.join(DATA_DIR, "myinfo", "#{XMLData.game}-myinfo.yaml")
    end

    # Loads character information from file
    # @param report_only [Boolean] whether to skip creating default entries for missing characters
    # @return [void]
    def load(report_only)
      ensure_data_directory

      unless File.exist?(data_filename)
        @allcharInfo = {}
        add_character_entry(XMLData.name) unless report_only
        return
      end

      @allcharInfo = if Gem::Version.new(RUBY_VERSION) < Gem::Version.new('3.1')
                       YAML.load_file(data_filename)
                     else
                       YAML.load_file(data_filename, permitted_classes: [Time, Symbol], aliases: true)
                     end

      # Migrate existing characters to ensure 4x/5x fields exist and default to 0
      @allcharInfo.each do |_name, char_info|
        char_info[:quadrupledexperience] = 0 if char_info[:quadrupledexperience].nil? || char_info[:quadrupledexperience] == ""
        char_info[:quintupledexperience] = 0 if char_info[:quintupledexperience].nil? || char_info[:quintupledexperience] == ""
        # Migrate supports_4x_5x field - default to false if missing
        char_info[:supports_4x_5x] = false if char_info[:supports_4x_5x].nil?
      end

      add_character_entry(XMLData.name) if @allcharInfo[XMLData.name].nil? && !report_only
    end

    # Adds a default character entry to the data structure
    # @param char_name [String] the character name
    # @return [void]
    def add_character_entry(char_name)
      @allcharInfo[char_name] = DEFAULT_CHAR_INFO.dup
    end

    # Calculates mind capacity based on stats
    # @return [Integer] the calculated mind capacity
    def mind_capacity
      800 + Stats.enhanced_log[0] + Stats.enhanced_dis[0]
    end

    # Gets the current mind state as a percentage
    # @return [Float] the mind state percentage
    def mind_percent
      mind_string = mind?.downcase
      MIND_STATES[mind_string] || 0
    end

    # Gets the current field experience
    # @return [Integer] the current field experience
    def current_mind
      put "experience"
      while (line = get)
        return Regexp.last_match(1).delete(",").to_i if line =~ /Field Exp: ([\d,]+)\/[\d,]+/
      end
      0
    end

    # Calculates experience until next level
    # @return [Integer, String] experience needed or "Cap" if at cap
    def exp_until_next
      xpn_nlt = XMLData.next_level_text
      return 0 unless xpn_nlt =~ /( experience| until next level)/

      xpn_nlt.delete(' experience').delete(' until next level').to_i
    end

    # Calculates total seconds from days, hours, and minutes
    # @param days [Integer] number of days
    # @param hours [Integer] number of hours
    # @param minutes [Integer] number of minutes
    # @return [Integer] total seconds
    def calc_total_seconds(days, hours, minutes)
      (days.to_i * 24 * 60 * 60) + (hours.to_i * 60 * 60) + (minutes.to_i * 60)
    end

    # Parses the lumnis result string and updates character info
    # @param current_datetime [Time] the current time
    # @param lumnis_result [String] the result string from lumnis info command
    # @param _char_info [Hash] character info hash (unused but kept for compatibility)
    # @param supports_4x_5x [Boolean] whether character has made Temple donations for 4x/5x support
    # @return [void]
    def parse_result_array(current_datetime, lumnis_result, _char_info, _supports_4x_5x)
      result_array = lumnis_result.split(".")
      experience_array = result_array[0].split(" ")

      # Parse experience multipliers - ALWAYS use actual values from LUMNIS INFO
      # The supports_4x_5x flag is only used when lumnis RESTARTS, not for current values
      exp_multipliers = { doubled: 0, tripled: 0, quadrupled: 0, quintupled: 0 }
      highest_tier_found = 0

      experience_array.each_with_index do |element, index|
        case element
        when /tripled/
          exp_multipliers[:tripled] = experience_array[index - 3].delete(",").to_i
          highest_tier_found = [highest_tier_found, 3].max
        when /doubled/
          exp_multipliers[:doubled] = experience_array[index - 3].delete(",").to_i
          highest_tier_found = [highest_tier_found, 2].max
        when /quadrupled/
          # Always parse actual current value from LUMNIS INFO
          exp_multipliers[:quadrupled] = experience_array[index - 3].delete(",").to_i
          highest_tier_found = [highest_tier_found, 4].max
        when /quintupled/
          # Always parse actual current value from LUMNIS INFO
          exp_multipliers[:quintupled] = experience_array[index - 3].delete(",").to_i
          highest_tier_found = [highest_tier_found, 5].max
        end
      end

      # If "followed by additional cycles" appears, infer queued lower tiers
      # When on a higher tier with remaining cycles, lower tiers are queued at 7,300
      if lumnis_result =~ /followed by (?:an )?additional cycles? of increased experience/
        case highest_tier_found
        when 5  # On 5x, queue 4x, 3x, 2x if not already set
          exp_multipliers[:quadrupled] = 7300 if exp_multipliers[:quadrupled] == 0
          exp_multipliers[:tripled] = 7300 if exp_multipliers[:tripled] == 0
          exp_multipliers[:doubled] = 7300 if exp_multipliers[:doubled] == 0
        when 4  # On 4x, queue 3x, 2x if not already set
          exp_multipliers[:tripled] = 7300 if exp_multipliers[:tripled] == 0
          exp_multipliers[:doubled] = 7300 if exp_multipliers[:doubled] == 0
        when 3  # On 3x, queue 2x if not already set
          exp_multipliers[:doubled] = 7300 if exp_multipliers[:doubled] == 0
        end
      end

      # Parse time remaining
      time_array = result_array[1].split(" ")
      time_components = { days: 0, hours: 0, minutes: 0 }

      time_array.each_with_index do |element, index|
        case element
        when /minute/
          time_components[:minutes] = time_array[index - 1].to_i
        when /hour/
          time_components[:hours] = time_array[index - 1].to_i
        when /day/
          time_components[:days] = time_array[index - 1].to_i
        end
      end

      total_seconds = calc_total_seconds(time_components[:days], time_components[:hours], time_components[:minutes])
      refresh_when = current_datetime + total_seconds

      # Update character info
      char_info = @allcharInfo[XMLData.name]
      char_info[:lastcheckwhen] = current_datetime
      char_info[:refreshwhen] = refresh_when
      char_info[:refreshdays] = time_components[:days]
      char_info[:refreshhours] = time_components[:hours]
      char_info[:refreshminutes] = time_components[:minutes]
      char_info[:doubledexperience] = exp_multipliers[:doubled]
      char_info[:tripledexperience] = exp_multipliers[:tripled]
      char_info[:quadrupledexperience] = exp_multipliers[:quadrupled]
      char_info[:quintupledexperience] = exp_multipliers[:quintupled]
    end

    # Gets average time remaining for invoker-supplied spells
    # @return [Integer] average time remaining in seconds
    def invoker_info
      total_duration = WATCHED_SPELLS.sum do |watched_spell|
        Spell.active.find { |spell| watched_spell.to_i == spell.num.to_i }&.timeleft || 0
      end

      (total_duration / WATCHED_SPELLS.count).to_i
    end

    # Main method to gather lumnis information
    # @return [void]
    def get_lumnis_info
      current_datetime = Time.now
      last_schedule_info = { month: nil, day: nil, year: nil }
      lumnis_result = nil
      lumnis_info_done = false
      lumnismon_f2p = false
      supports_4x_5x = false

      # Get lumnis info
      lumnis_info_get = proc do
        filter = false
        action = proc do |server_string|
          case server_string
          when /It is scheduled to refresh|restart as soon as you absorb experience|Because your account is free,/
            filter = true
            lumnis_result = server_string
            lumnismon_f2p = true if server_string =~ /Because your account is free,/
            next(nil)
          when /^\s*$/ # Empty line
            next(nil) if filter
          when /You are not presently receiving Fash'lo'nae's Tutelage\./
            next(nil) if filter
          when /You have made [\d,]+ recent donations to the Temple of Lumnis\./
            supports_4x_5x = true
            next(nil)
          when /You have not made any recent donations to the Temple of Lumnis\./
            supports_4x_5x = false
            next(nil)
          when /You last used a Lumnis scheduling option|You have not selected a Gift of Lumnis schedule\./
            if filter
              if server_string =~ /You last used a Lumnis scheduling option on (?:Sun|Mon|Tue|Wed|Thu|Fri|Sat) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d+) ........ .. (\d+)\./
                last_schedule_info[:month] = Regexp.last_match(1)
                last_schedule_info[:day] = Regexp.last_match(2)
                last_schedule_info[:year] = Regexp.last_match(3)

                if server_string !~ /You must wait six months from then to use another Lumnis scheduling option\./
                  last_schedule_info.transform_values! { "Ready" }
                end
              elsif server_string =~ /You have not selected/
                last_schedule_info.transform_values! { "Ready" }
              end
            end
            next(nil)
          when /Your Gift of Lumnis is scheduled|You have [,\d]+ available uses? of |You have no available uses of /
            next(nil) if filter
          when /^<prompt time=/
            if filter
              DownstreamHook.remove("lumnismon_lumnis_info_scoop")
              lumnis_info_done = true
            end
            next(nil)
          else
            next(server_string)
          end
        end

        DownstreamHook.add("lumnismon_lumnis_info_scoop", action)
        silence_me
        put "lumnis info"
        silence_me
      end

      lumnis_info_get.call
      wait_until { lumnis_info_done }

      # Calculate next schedule
      next_schedule_string = calculate_next_schedule(last_schedule_info, lumnismon_f2p)

      # Get resource information
      resource_data = get_resource_info(lumnismon_f2p)

      # Get experience information
      exp_data = get_exp_info

      # Get bounty points
      bounty_points = get_bounty_points

      # Format bounty points
      formatted_bps = format_bounty_points(bounty_points)

      # Get invoker info
      average_invoker_time = invoker_info

      # Update character info
      update_character_info(
        current_datetime: current_datetime,
        next_schedule_string: next_schedule_string,
        resource_data: resource_data,
        exp_data: exp_data,
        formatted_bps: formatted_bps,
        average_invoker_time: average_invoker_time,
        lumnis_result: lumnis_result,
        lumnismon_f2p: lumnismon_f2p,
        supports_4x_5x: supports_4x_5x
      )
    end

    # Calculates the next schedule string
    # @param schedule_info [Hash] hash containing month, day, year
    # @param f2p [Boolean] whether account is free-to-play
    # @return [String] the next schedule string
    def calculate_next_schedule(schedule_info, f2p)
      return "F2P" if f2p
      return "Ready" if schedule_info[:month] == "Ready"

      next_month = MONTH_TO_NEXT[schedule_info[:month]]
      if %w[Jan Feb Mar Apr May Jun].include?(schedule_info[:month])
        schedule_info[:year].to_s.slice(2..3)
      else
        (schedule_info[:year].to_i + 1).to_s.slice(2..3)
      end

      "#{next_month}/#{schedule_info[:day]}"
    end

    # Gets resource information
    # @param f2p [Boolean] whether account is free-to-play
    # @return [Hash] hash with weekly, total, and suffused resource values
    def get_resource_info(f2p)
      return { weekly: "F2P", total: "F2P", suffused: "F2P" } if f2p

      # Check if character has access to profession service
      unless has_profession_service?
        return { weekly: "RSN", total: "RSN", suffused: "RSN" }
      end

      cur_week_res = nil
      cur_tot_res = nil
      cur_suff = nil
      resource_done = false

      resource_get = proc do
        filter = false
        action = proc do |server_string|
          case server_string
          when /(?:<pushBold\/>)?[,\d]+(?:<popBold\/>)?\/(?:<pushBold\/>)?[,\d]+(?:<popBold\/>)?\s+Mana:/
            filter = true
            next(nil)
          when /^\s*$/
            next(nil) if filter
          when /^(?:<popBold\/>)?Voln Favor:/
            next(nil) if filter
          when /^(?:<popBold\/>)?(?:Guile|Luck Inspiration|Essence|Necrotic Energy|Motes of Tranquility|Grit|Devotion|Nature's Grace|Vitality):\s+([,\d]+)\/50,000 \(Weekly\)\s+([,\d]+)\/200,000\s+\(Total\)/
            if filter
              cur_week_res = Regexp.last_match(1).delete(",")
              cur_tot_res = Regexp.last_match(2).delete(",")
            end
            next(nil)
          when /^Suffused (?:Guile|Luck Inspiration|Essence|Necrotic Energy|Motes of Tranquility|Grit|Devotion|Nature's Grace|Vitality): ([,\d]+)/
            cur_suff = Regexp.last_match(1).delete(',') if filter
            next(nil)
          when /<prompt time=/
            if filter
              DownstreamHook.remove("lumnismon_resource_scoop")
              resource_done = true
            end
            next(nil)
          else
            next(server_string)
          end
        end

        DownstreamHook.add("lumnismon_resource_scoop", action)
        silence_me
        put "resource"
        silence_me
      end

      resource_get.call
      wait_until { resource_done }

      { weekly: cur_week_res, total: cur_tot_res, suffused: cur_suff }
    end

    # Checks if character has access to profession service
    # @return [Boolean] true if character has profession service access
    def has_profession_service?
      prof = Stats.prof
      level = Stats.level

      case prof
      when "Bard", "Monk", "Warrior", "Rogue"
        level >= 20
      when "Wizard"
        level >= 25 && Spell[925].known?
      when "Sorcerer"
        level >= 35 && Spell[735].known?
      when "Cleric"
        level >= 30 && Spell[330].known?
      when "Ranger"
        level >= 20 && Spell[620].known?
      when "Paladin"
        level >= 20 && Spell[1620].known?
      when "Empath"
        Spell[1135].known?
      else
        false
      end
    end

    # Gets experience information
    # @return [Hash] hash with mind and deed values
    def get_exp_info
      exp_done = false
      cur_mind = 0
      cur_deed = 0

      exp_get = proc do
        filter = false
        action = proc do |server_string|
          case server_string
          when /^\s+Level:\s+\d+\s+Fame:\s+(?:[,\d]*)/
            filter = true
            next(nil)
          when /^\s*$/
            next(nil) if filter
          when /\s+Ascension Exp:\s+[,\d]+|\s+Total\sExp:\s+[,\d]+|Exp to next TP:|Exp until lvl: |PTPs\/MTPs:\s+[,\d]+\/[,\d]+|Your mind|You feel a strange sense of serenity and find|Your recent adventures echo powerfully in your mind\./
            next(nil) if filter
          when /Deeds: (\d+)/
            cur_deed = Regexp.last_match(1).to_i if filter
            next(nil)
          when /Field Exp: ([\d,]+)\/[\d,]+/
            cur_mind = Regexp.last_match(1).delete(",").to_i if filter
            next(nil)
          when /^<prompt time=/
            if filter
              DownstreamHook.remove("lumnismon_exp_scoop")
              exp_done = true
            end
            next(nil)
          else
            next(server_string)
          end
        end

        DownstreamHook.add("lumnismon_exp_scoop", action)
        silence_me
        put "experience"
        silence_me
      end

      exp_get.call
      wait_until { exp_done }

      { mind: cur_mind, deed: cur_deed }
    end

    # Gets bounty points
    # @return [Integer] current bounty points
    def get_bounty_points
      bps = 0
      bps_done = false

      bps_get = proc do
        filter = false
        action = proc do |server_string|
          case server_string
          when /<a exist="-\d+" noun="#{XMLData.name}">#{XMLData.name}<\/a>, your Adventurer's Guild information is as follows:/
            filter = true
            next(nil)
          when /^\s*$/
            next(nil) if filter
          when /You have succeeded|You have accumulated a total of|You have [,\d]+ expedited|You are not currently|You have succeeded at the|You have been tasked|The taskmaster told you/
            next(nil) if filter
          when /You currently have ([,\d]+) unspent bounty points\./
            bps = Regexp.last_match(1).delete(",").to_i if filter
            next(nil)
          when /^<prompt time=/
            if filter
              DownstreamHook.remove("lumnismon_bounty_points_scoop")
              bps_done = true
            end
            next(nil)
          else
            next(server_string)
          end
        end

        DownstreamHook.add("lumnismon_bounty_points_scoop", action)
        silence_me
        put "bounty"
        silence_me
      end

      bps_get.call
      wait_until { bps_done }
      bps
    end

    # Formats bounty points with suffixes
    # @param bps [Integer] bounty points
    # @return [String] formatted bounty points string
    def format_bounty_points(bps)
      suffix = ""
      formatted = bps

      if bps > 1_000_000_000
        formatted = (bps.to_f / 1_000_000_000).truncate(2)
        suffix = "B"
      elsif bps > 1_000_000
        formatted = (bps.to_f / 1_000_000).truncate(2)
        suffix = "M"
      elsif bps > 1_000
        formatted = (bps.to_f / 1_000).truncate(0)
        suffix = "K"
      end

      "#{formatted}#{suffix}"
    end

    # Updates character information with gathered data
    # @param options [Hash] hash of data to update
    # @return [void]
    def update_character_info(options)
      char_info = @allcharInfo[XMLData.name]

      char_info[:charactername] = XMLData.name
      char_info[:characteraccount] = UserVars.lumnismon[:char_account] || "9999 Not Listed"
      char_info[:nextschedulestring] = options[:next_schedule_string]
      char_info[:profession] = Stats.prof
      char_info[:level] = Char.level
      char_info[:mindcapacity] = mind_capacity
      char_info[:mindpercent] = mind_percent
      char_info[:currentmind] = options[:exp_data][:mind]
      char_info[:currentdeed] = options[:exp_data][:deed]
      char_info[:currentweeklyresource] = options[:resource_data][:weekly]
      char_info[:currenttotalresource] = options[:resource_data][:total]
      char_info[:currentsuffusedresource] = options[:resource_data][:suffused]
      char_info[:currentexp] = Char.exp
      char_info[:bountypoints] = options[:formatted_bps]
      char_info[:customplace] = UserVars.lumnismon[:custom_place]
      char_info[:invokerspellsremaining] = options[:average_invoker_time]
      char_info[:supports_4x_5x] = options[:supports_4x_5x]

      char_info[:expnext] = Char.level == 100 ? "Cap" : exp_until_next

      update_lumnis_status(char_info, options[:current_datetime], options[:lumnis_result], options[:lumnismon_f2p], options[:supports_4x_5x])
    end

    # Updates lumnis status information
    # @param char_info [Hash] character info hash
    # @param current_datetime [Time] current time
    # @param lumnis_result [String] lumnis result string
    # @param f2p [Boolean] whether account is free-to-play
    # @param supports_4x_5x [Boolean] whether character has made Temple donations for 4x/5x support
    # @return [void]
    def update_lumnis_status(char_info, current_datetime, lumnis_result, f2p, supports_4x_5x)
      if f2p
        char_info[:lastcheckwhen] = "F2P"
        char_info[:refreshwhen] = "F2P"
        char_info[:refreshdays] = "F2P"
        char_info[:refreshhours] = "F2P"
        char_info[:refreshminutes] = "F2P"
        char_info[:doubledexperience] = "F2P"
        char_info[:tripledexperience] = "F2P"
        char_info[:quadrupledexperience] = "F2P"
        char_info[:quintupledexperience] = "F2P"
        return
      end

      if lumnis_result =~ /Your Gift of Lumnis will restart as soon as you absorb experience/
        char_info[:lastcheckwhen] = current_datetime
        char_info[:refreshwhen] = current_datetime
        char_info[:refreshdays] = 0
        char_info[:refreshhours] = 0
        char_info[:refreshminutes] = 0
        char_info[:doubledexperience] = 7300
        char_info[:tripledexperience] = 7300
        # Only set 4x/5x if player has made Temple donations
        if supports_4x_5x
          char_info[:quadrupledexperience] = 7300
          char_info[:quintupledexperience] = 7300
        else
          char_info[:quadrupledexperience] = 0
          char_info[:quintupledexperience] = 0
        end
      elsif lumnis_result =~ /You have.*points of (tripled|doubled|quadrupled|quintupled) experience/
        parse_result_array(current_datetime, lumnis_result, char_info, supports_4x_5x)
      elsif lumnis_result =~ /Your Gift of Lumnis has expired for this week\./
        parse_result_array(current_datetime, lumnis_result, char_info, supports_4x_5x)
      else
        echo "Lumnis Info was not found and therefore unable to be parsed"
      end
    end

    # Saves character information to file
    # @return [void]
    def save
      File.write(data_filename, @allcharInfo.to_yaml)
      Lich::Messaging.msg("info", "#{Script.self}: Data saved to #{data_filename}.")
    end

    # Converts minutes to formatted time string
    # @param minute_value [Integer] minutes
    # @return [String] formatted time string (e.g., "2h30m")
    def parse_minutes_to_string(minute_value)
      return "0h0m" if minute_value.nil? || minute_value == ""
      minute_value = minute_value.to_i
      hours = minute_value / 60
      minutes = minute_value % 60
      "#{hours}h#{minutes}m"
    end

    # Generates and displays the character report
    # @return [void]
    def report
      prepare_character_data

      if UserVars.lumnismon[:use_terminal_table]
        report_with_terminal_table
      else
        report_legacy_format
      end
    end

    # Prepares character data for reporting
    # @return [void]
    def prepare_character_data
      @allcharInfo.each do |_name, char|
        char[:invokerspellsremaining] ||= 0
        char[:customplace] ||= 0

        unless char[:refreshwhen] == "F2P"
          char[:refreshstring] = if Time.now >= char[:refreshwhen]
                                   "Ready"
                                 else
                                   format_time_until(char[:refreshwhen])
                                 end
        else
          char[:refreshwhen] = Time.now + 2_592_000
          char[:refreshstring] = "F2P"
        end
      end
    end

    # Formats time until a future date
    # @param future_time [Time] the future time
    # @return [String] formatted time string
    def format_time_until(future_time)
      time_diff = future_time - Time.now
      mm, _ss = time_diff.divmod(60)
      hh, mm = mm.divmod(60)
      dd, hh = hh.divmod(24)

      "#{dd}d#{hh.to_s.rjust(2, '0')}h#{mm.to_s.rjust(2, '0')}m"
    end

    # Reports using terminal-table gem
    # @return [void]
    def report_with_terminal_table
      echo "All values are based off of the last time that character ran LumnisMon"
      echo "Includes 2x, 3x, 4x, and 5x experience tracking"

      sorted_chars = sort_characters(@allcharInfo)

      if UserVars.lumnismon[:show_account] && !UserVars.lumnismon[:account_inline]
        report_by_account(sorted_chars)
      else
        report_single_table(sorted_chars)
      end
    end

    # Sorts characters according to user preferences
    # @param chars [Hash] character hash
    # @return [Array] sorted array of [name, info] pairs
    def sort_characters(chars)
      if UserVars.lumnismon[:sort_by_refresh] && UserVars.lumnismon[:sort_by_account]
        chars.sort_by { |_k, v| [v[:characteraccount], v[:refreshwhen]] }
      elsif UserVars.lumnismon[:sort_by_account]
        chars.sort_by { |k, v| [v[:characteraccount], k] }
      elsif UserVars.lumnismon[:sort_by_refresh]
        chars.sort_by { |k, v| [v[:refreshwhen], k] }
      else
        chars.sort_by { |k, _v| k }
      end
    end

    # Reports characters grouped by account
    # @param sorted_chars [Array] sorted character array
    # @return [void]
    def report_by_account(sorted_chars)
      all_rows = []
      current_account = nil
      headers = build_table_headers

      sorted_chars.each do |_name, char_info|
        next if char_info[:charactername].nil? || char_info[:charactername].empty?

        if current_account != char_info[:characteraccount]
          # Add account header row as a separator
          display_account = UserVars.lumnismon[:show_account] ? char_info[:characteraccount].upcase : "ACCOUNT"

          # Add blank separator row if not first account
          all_rows << :separator unless current_account.nil?

          # Add account header row
          all_rows << { type: :header, text: display_account }
          all_rows << :separator

          current_account = char_info[:characteraccount]
        end

        # Add character row
        all_rows << build_table_row(char_info)
      end

      # Build the unified table
      display_unified_table(headers, all_rows)
    end

    # Reports all characters in a single table
    # @param sorted_chars [Array] sorted character array
    # @return [void]
    def report_single_table(sorted_chars)
      chars_to_display = sorted_chars.map { |_name, info| info }
                                     .reject { |info| info[:charactername].nil? || info[:charactername].empty? }

      display_character_table(chars_to_display)
    end

    # Displays character data in a terminal-table
    # @param chars [Array] array of character info hashes
    # @return [void]
    def display_character_table(chars)
      headers = build_table_headers
      repeat_interval = UserVars.lumnismon[:header_repeat_rows] || 10

      # If repeat is 0, show one table with all characters
      if repeat_interval == 0 || chars.length <= repeat_interval
        rows = chars.map { |char| build_table_row(char) }
        table = Terminal::Table.new(headings: headers, rows: rows)
        table.style = { border_x: "-", border_y: "|", border_i: "+" }

        _respond "<output class=\"mono\"/>"
        _respond colorize_table_output(table.to_s, headers)
        _respond "<output class=\"\"/>"
      else
        # Show headers every N rows
        chars.each_slice(repeat_interval).with_index do |char_group, index|
          rows = char_group.map { |char| build_table_row(char) }
          table = Terminal::Table.new(headings: headers, rows: rows)
          table.style = { border_x: "-", border_y: "|", border_i: "+" }

          _respond "<output class=\"mono\"/>"
          _respond colorize_table_output(table.to_s, headers)
          _respond "<output class=\"\"/>"

          # Add a small separator between tables (except for the last one)
          _respond "" unless index == (chars.length.to_f / repeat_interval).ceil - 1
        end
      end
    end

    # Displays a unified table with account header rows
    # @param headers [Array] table column headers
    # @param all_rows [Array] array of rows, separators, and header hashes
    # @return [void]
    def display_unified_table(headers, all_rows)
      # Build the table manually with all rows
      table = Terminal::Table.new(headings: headers)
      table.style = { border_x: "-", border_y: "|", border_i: "+" }

      all_rows.each do |row|
        if row == :separator
          table.add_separator
        elsif row.is_a?(Hash) && row[:type] == :header
          # Create a row that spans all columns for the account header
          header_row = [{ value: row[:text].center(80), colspan: headers.length, alignment: :center }]
          table.add_row(header_row)
        else
          table.add_row(row)
        end
      end

      _respond "<output class=\"mono\"/>"
      _respond colorize_table_output(table.to_s, headers)
      _respond "<output class=\"\"/>"
    end

    # Post-processes table output to add colorization presets
    # @param table_string [String] the generated table string
    # @param headers [Array] column headers to identify column positions
    # @return [String] colorized table string
    def colorize_table_output(table_string, headers)
      lines = table_string.split("\n")

      # Find header row to verify table structure
      header_line_idx = lines.index { |line| line.include?("Char") && line.include?("|") }
      return table_string unless header_line_idx

      # Process each line
      lines.map.with_index do |line, idx|
        # Skip separators and header
        if line.start_with?("+") || idx == header_line_idx
          line
        # Check if this is an account header row (centered text spanning full width)
        elsif line.match?(/^\|\s+[A-Z0-9]+\s+\|$/) && !line.include?("Char")
          # Apply monsterbold to account headers
          line.gsub(/^(\|\s+)([A-Z0-9]+)(\s+\|)$/) do
            "#{$1}#{monsterbold_start}#{$2}#{monsterbold_end}#{$3}"
          end
        else
          # Colorize data rows
          colorize_data_row(line, nil, headers)
        end
      end.join("\n")
    end

    # Colorizes a data row based on column content
    # @param line [String] the data row line
    # @param column_positions [Hash] column position mapping (unused but kept for compatibility)
    # @param headers [Array] column headers
    # @return [String] colorized line
    def colorize_data_row(line, _column_positions, headers)
      # Split line into cells
      return line unless line.include?("|")

      cells = line.split("|")
      return line if cells.length <= 1

      # First and last elements are empty (before first | and after last |)
      cells.shift # Remove leading empty
      cells.pop if cells.last == "" # Remove trailing empty only if it's actually empty

      # Colorize each cell based on its header
      colorized_cells = cells.each_with_index.map do |cell, idx|
        header = headers[idx] if idx < headers.length
        colorize_cell(cell, header)
      end

      # Pad with empty cells if we have fewer cells than headers
      while colorized_cells.length < headers.length
        colorized_cells << " "
      end

      # Reconstruct line
      "|" + colorized_cells.join("|") + "|"
    end

    # Colorizes a single cell based on its column header and value
    # @param cell [String] the cell content (includes padding)
    # @param header [String] the column header name
    # @return [String] colorized cell
    def colorize_cell(cell, header)
      value = cell.strip
      padding_left = cell[0...(cell.index(value) || 0)]
      padding_right = cell[(cell.index(value) || 0) + value.length..-1] || ""

      colored_value = case header
                      when "RenTim"
                        value == "F2P" ? "<preset id=\"speech\">#{value}</preset>" : value
                      when "2x", "3x", "4x", "5x"
                        if value == "F2P"
                          "<preset id=\"speech\">#{value}</preset>"
                        elsif value == "0"
                          "<preset id=\"watching\">#{value}</preset>"
                        else
                          value
                        end
                      when "Stat"
                        if value == "F2P"
                          "<preset id=\"speech\">#{value}</preset>"
                        elsif value == "Exp"
                          "<preset id=\"watching\">#{value}</preset>"
                        else
                          value
                        end
                      when "XPN"
                        value == "Cap" ? "<preset id=\"watching\">#{value}</preset>" : value
                      when "WRe"
                        if value == "F2P"
                          "<preset id=\"speech\">#{value}</preset>"
                        elsif value =~ /^(RSN|ATN)$/
                          "<preset id=\"thought\">#{value}</preset>"
                        elsif value == "50000*"
                          "<preset id=\"watching\">#{value}</preset>"
                        elsif value =~ /\*$/
                          "<preset id=\"speech\">#{value}</preset>"
                        else
                          value
                        end
                      when "TRe"
                        if value == "F2P"
                          "<preset id=\"speech\">#{value}</preset>"
                        elsif value =~ /^(RSN|ATN)$/
                          "<preset id=\"thought\">#{value}</preset>"
                        elsif value == "200000!"
                          "<preset id=\"speech\">#{value}</preset>"
                        elsif value.to_i > 150_000 && value.to_i < 200_000
                          "<pushBold/>#{value}<popBold/>"
                        else
                          value
                        end
                      when "SRe"
                        if value == "F2P"
                          "<preset id=\"speech\">#{value}</preset>"
                        elsif value =~ /^(RSN|ATN)$/
                          "<preset id=\"thought\">#{value}</preset>"
                        else
                          value
                        end
                      else
                        value
                      end

      padding_left + colored_value + padding_right
    end

    # Builds table headers based on user preferences
    # @return [Array] array of header strings
    def build_table_headers
      headers = ["Char"]

      headers << "Account" if UserVars.lumnismon[:show_account] && UserVars.lumnismon[:account_inline]
      headers << "Prof" if UserVars.lumnismon[:show_prof]
      headers << "Lvl" if UserVars.lumnismon[:show_level]
      headers << "Deed" if UserVars.lumnismon[:show_deeds]
      headers << "Invoker" if UserVars.lumnismon[:show_invoker]
      headers << "ChckTime" if UserVars.lumnismon[:show_check_time]
      headers << "RenTim" if UserVars.lumnismon[:show_renew_time]
      headers += ["2x", "3x", "4x", "5x", "Stat"]
      headers << "Fld" if UserVars.lumnismon[:show_field_exp]
      headers << "XPN" if UserVars.lumnismon[:show_xpn]
      headers << "WRe" if UserVars.lumnismon[:show_weekly_resource]
      headers << "TRe" if UserVars.lumnismon[:show_total_resource]
      headers << "SRe" if UserVars.lumnismon[:show_suffused_resource]
      headers << "NxSch" if UserVars.lumnismon[:show_next_schedule]
      headers << "BPs" if UserVars.lumnismon[:show_bps]

      headers
    end

    # Builds a table row for a character
    # @param char [Hash] character info hash
    # @return [Array] array of values for the row
    def build_table_row(char)
      row = [char[:charactername].to_s]

      row << char[:characteraccount].to_s.upcase if UserVars.lumnismon[:show_account] && UserVars.lumnismon[:account_inline]
      row << char[:profession].to_s.slice(0..2) if UserVars.lumnismon[:show_prof]
      row << char[:level].to_s if UserVars.lumnismon[:show_level]
      row << char[:currentdeed].to_s if UserVars.lumnismon[:show_deeds]
      row << parse_minutes_to_string(char[:invokerspellsremaining]) if UserVars.lumnismon[:show_invoker]
      row << format_check_time(char[:lastcheckwhen]) if UserVars.lumnismon[:show_check_time]
      row << char[:refreshstring].to_s if UserVars.lumnismon[:show_renew_time]

      # Experience multipliers
      row += format_experience_status(char)

      row << char[:currentmind].to_s if UserVars.lumnismon[:show_field_exp]
      row << format_xpn(char[:expnext]) if UserVars.lumnismon[:show_xpn]
      row << format_resource(char[:currentweeklyresource], char[:currenttotalresource], :weekly) if UserVars.lumnismon[:show_weekly_resource]
      row << format_resource(char[:currenttotalresource], char[:currenttotalresource], :total) if UserVars.lumnismon[:show_total_resource]
      row << format_resource(char[:currentsuffusedresource], char[:currenttotalresource], :suffused) if UserVars.lumnismon[:show_suffused_resource]
      row << char[:nextschedulestring].to_s if UserVars.lumnismon[:show_next_schedule]
      row << (char[:bountypoints] || "").to_s if UserVars.lumnismon[:show_bps]

      row
    end

    # Formats the check time for display
    # @param check_time [Time, String] the check time
    # @return [String] formatted time string
    def format_check_time(check_time)
      return "" if check_time.nil? || check_time == ""
      check_time == "F2P" ? "F2P" : check_time.strftime("%H%M %-d/%-m")
    end

    # Formats experience status columns
    # @param char [Hash] character info
    # @return [Array] array of [2x, 3x, 4x, 5x, status] values
    def format_experience_status(char)
      return ["F2P", "F2P", "F2P", "F2P", "F2P"] if char[:refreshwhen] > (Time.now + 1_000_000)

      if char[:refreshwhen] < Time.now
        # When lumnis is Ready - use flag to determine starting values
        x4_ready = (char[:supports_4x_5x] == true) ? "7300" : "0"
        x5_ready = (char[:supports_4x_5x] == true) ? "7300" : "0"

        [
          char[:doubledexperience].to_s || "7300",
          char[:tripledexperience].to_s || "7300",
          x4_ready,
          x5_ready,
          "Rdy"
        ]
      else
        # When lumnis is active - always show actual stored values
        [
          char[:doubledexperience].to_s,
          char[:tripledexperience].to_s,
          char[:quadrupledexperience].to_s || "0",
          char[:quintupledexperience].to_s || "0",
          determine_status(char)
        ]
      end
    end

    # Determines the status based on remaining experience
    # @param char [Hash] character info
    # @return [String] status string
    def determine_status(char)
      total_exp = [
        char[:doubledexperience].to_i,
        char[:tripledexperience].to_i,
        char[:quadrupledexperience].to_i || 0,
        char[:quintupledexperience].to_i || 0
      ].sum

      total_exp > 0 ? "Act" : "Exp"
    end

    # Formats XPN for display
    # @param xpn [String, Integer] experience to next level
    # @return [String] formatted string
    def format_xpn(xpn)
      xpn == "Cap" ? "Cap" : xpn.to_s
    end

    # Formats resource value for display
    # @param value [String, Integer] resource value
    # @param total [String, Integer] total resource value
    # @param type [Symbol] resource type (:weekly, :total, :suffused)
    # @return [String] formatted resource string
    def format_resource(value, total, type)
      return value.to_s if %w[F2P RSN ATN].include?(value.to_s)

      case type
      when :weekly
        value.to_i == 50_000 ? "#{value}*" : value.to_s
      when :total
        total.to_i == 200_000 ? "#{value}!" : value.to_s
      when :suffused
        value.to_s
      else
        value.to_s
      end
    end

    # Reports using legacy format (original output style)
    # @return [void]
    def report_legacy_format
      # Calculate justification widths
      justifications = calculate_justifications

      # Output header
      output_legacy_header(justifications)

      # Sort characters
      sorted_chars = sort_characters(@allcharInfo)

      # Output character data
      output_legacy_characters(sorted_chars, justifications)
    end

    # Calculates justification widths for columns
    # @return [Hash] hash of column widths
    def calculate_justifications
      just = {
        name: 5, prof: 5, account: 8, level: 4, deed: 5,
        x2: 3, x3: 3, x4: 3, x5: 3, status: 5, fldxp: 4,
        xptn: 4, week: 4, tot: 4, suf: 4, lastcheck: 9,
        refresh: 9, invoker: 9, nextsched: 6
      }

      @allcharInfo.each do |_name, char|
        just[:name] = [just[:name], char[:charactername].to_s.length + 1].max
        just[:account] = [just[:account], char[:characteraccount].to_s.length + 1].max
        just[:x2] = [just[:x2], char[:doubledexperience].to_s.length + 1].max
        just[:x3] = [just[:x3], char[:tripledexperience].to_s.length + 1].max
        just[:x4] = [just[:x4], (char[:quadrupledexperience] || 0).to_s.length + 1].max
        just[:x5] = [just[:x5], (char[:quintupledexperience] || 0).to_s.length + 1].max
        just[:fldxp] = [just[:fldxp], char[:currentmind].to_s.length + 1].max
        just[:xptn] = [just[:xptn], char[:expnext].to_s.length + 1].max
        just[:week] = [just[:week], char[:currentweeklyresource].to_s.length + 1].max
        just[:tot] = [just[:tot], char[:currenttotalresource].to_s.length + 1].max
        just[:suf] = [just[:suf], char[:currentsuffusedresource].to_s.length + 1].max

        unless char[:lastcheckwhen] == "F2P"
          just[:lastcheck] = [just[:lastcheck], char[:lastcheckwhen].strftime("%H%M %-d/%-m").length + 1].max
        end

        just[:refresh] = [just[:refresh], char[:refreshstring].to_s.length + 1].max
        just[:invoker] = [just[:invoker], parse_minutes_to_string(char[:invokerspellsremaining]).length + 1].max
        just[:nextsched] = [just[:nextsched], char[:nextschedulestring].to_s.length + 1].max
      end

      just
    end

    # Outputs legacy format header
    # @param just [Hash] justification widths
    # @return [void]
    def output_legacy_header(just)
      echo "All values are based off of the last time that character ran LumnisMon"
      echo "Now includes 4x and 5x experience tracking!"

      line = "Char".ljust(just[:name])
      line += "Account".ljust(just[:account]) if UserVars.lumnismon[:show_account] && UserVars.lumnismon[:account_inline]
      line += "Prof".ljust(just[:prof]) if UserVars.lumnismon[:show_prof]
      line += "Lvl".ljust(just[:level]) if UserVars.lumnismon[:show_level]
      line += "Deed".ljust(just[:deed]) if UserVars.lumnismon[:show_deeds]
      line += "Invoker".ljust(just[:invoker]) if UserVars.lumnismon[:show_invoker]
      line += "ChckTime".ljust(just[:lastcheck]) if UserVars.lumnismon[:show_check_time]
      line += "RenTim".ljust(just[:refresh]) if UserVars.lumnismon[:show_renew_time]
      line += "2x".ljust(just[:x2])
      line += "3x".ljust(just[:x3])
      line += "4x".ljust(just[:x4])
      line += "5x".ljust(just[:x5])
      line += "Stat".ljust(just[:status])
      line += "Fld".ljust(just[:fldxp]) if UserVars.lumnismon[:show_field_exp]
      line += "XPN".ljust(just[:xptn]) if UserVars.lumnismon[:show_xpn]
      line += "WRe".ljust(just[:week]) if UserVars.lumnismon[:show_weekly_resource]
      line += "TRe".ljust(just[:tot]) if UserVars.lumnismon[:show_total_resource]
      line += "SRe".ljust(just[:suf]) if UserVars.lumnismon[:show_suffused_resource]
      line += "NxSch".ljust(just[:nextsched]) if UserVars.lumnismon[:show_next_schedule]
      line += "BPs" if UserVars.lumnismon[:show_bps]

      _respond("<output class=\"mono\"/>#{monsterbold_start}#{line}#{monsterbold_end}\r\n<output class=\"\"/>")
    end

    # Outputs legacy format character lines
    # @param sorted_chars [Array] sorted character array
    # @param just [Hash] justification widths
    # @return [void]
    def output_legacy_characters(sorted_chars, just)
      current_account = nil
      first_char = true
      account_count = 0
      total_just = calculate_total_justification(just)

      sorted_chars.each do |_name, char_info|
        next if char_info[:charactername].nil? || char_info[:charactername].empty?

        # Handle account headers if needed
        if UserVars.lumnismon[:account_inline] == false && UserVars.lumnismon[:sort_by_account]
          if first_char || current_account != char_info[:characteraccount]
            display_account_header(char_info, total_just, account_count, first_char)
            current_account = char_info[:characteraccount]
            first_char = false
            account_count += 1 unless UserVars.lumnismon[:show_account]
          end
        end

        output_character_line(char_info, just)
      end
    end

    # Calculates total justification width
    # @param just [Hash] justification widths
    # @return [Integer] total width
    def calculate_total_justification(just)
      total = just[:name]
      total += just[:account] if UserVars.lumnismon[:show_account] && UserVars.lumnismon[:account_inline]
      total += just[:prof] if UserVars.lumnismon[:show_prof]
      total += just[:level] if UserVars.lumnismon[:show_level]
      total += just[:deed] if UserVars.lumnismon[:show_deeds]
      total += just[:invoker] if UserVars.lumnismon[:show_invoker]
      total += just[:lastcheck] if UserVars.lumnismon[:show_check_time]
      total += just[:refresh] if UserVars.lumnismon[:show_renew_time]
      total += just[:x2] + just[:x3] + just[:x4] + just[:x5] + just[:status]
      total += just[:fldxp] if UserVars.lumnismon[:show_field_exp]
      total += just[:xptn] if UserVars.lumnismon[:show_xpn]
      total += just[:week] if UserVars.lumnismon[:show_weekly_resource]
      total += just[:tot] if UserVars.lumnismon[:show_total_resource]
      total += just[:suf] if UserVars.lumnismon[:show_suffused_resource]
      total += just[:nextsched] if UserVars.lumnismon[:show_next_schedule]
      total
    end

    # Displays account header for legacy format
    # @param char_info [Hash] character info
    # @param total_just [Integer] total justification width
    # @param account_count [Integer] account counter
    # @param first_char [Boolean] whether this is the first character
    # @return [void]
    def display_account_header(char_info, total_just, account_count, first_char)
      if UserVars.lumnismon[:show_account]
        header_text = char_info[:characteraccount].upcase
      else
        header_text = "ACCOUNT#{first_char ? '' : account_count}"
      end

      _respond("<output class=\"mono\"/>#{monsterbold_start}#{header_text.center(total_just)}#{monsterbold_end}\r\n<output class=\"\"/>")
    end

    # Outputs a single character line in legacy format
    # @param char [Hash] character info
    # @param just [Hash] justification widths
    # @return [void]
    def output_character_line(char, just)
      line = char[:charactername].ljust(just[:name])

      line += char[:characteraccount].upcase.ljust(just[:account]) if UserVars.lumnismon[:show_account] && UserVars.lumnismon[:account_inline]
      line += char[:profession].to_s.slice(0..2).ljust(just[:prof]) if UserVars.lumnismon[:show_prof]
      line += char[:level].to_s.ljust(just[:level]) if UserVars.lumnismon[:show_level]
      line += char[:currentdeed].to_s.ljust(just[:deed]) if UserVars.lumnismon[:show_deeds]
      line += parse_minutes_to_string(char[:invokerspellsremaining]).ljust(just[:invoker]) if UserVars.lumnismon[:show_invoker]

      if UserVars.lumnismon[:show_check_time]
        check_time = char[:lastcheckwhen] == "F2P" ? "F2P" : char[:lastcheckwhen].strftime("%H%M %-d/%-m")
        line += check_time.ljust(just[:lastcheck])
      end

      if UserVars.lumnismon[:show_renew_time]
        line += if char[:refreshstring] == "F2P"
                  "<preset id=\"speech\">#{char[:refreshstring].ljust(just[:refresh])}</preset>"
                else
                  char[:refreshstring].ljust(just[:refresh])
                end
      end

      # Experience multipliers
      line += format_experience_columns(char, just)

      line += char[:currentmind].to_s.ljust(just[:fldxp]) if UserVars.lumnismon[:show_field_exp]

      if UserVars.lumnismon[:show_xpn]
        line += if char[:expnext] == "Cap"
                  "<preset id=\"watching\">#{char[:expnext].ljust(just[:xptn])}</preset>"
                else
                  char[:expnext].to_s.ljust(just[:xptn])
                end
      end

      line += format_resource_columns(char, just)
      line += char[:nextschedulestring].ljust(just[:nextsched]) if UserVars.lumnismon[:show_next_schedule]
      line += char[:bountypoints].to_s if UserVars.lumnismon[:show_bps]

      _respond("<output class=\"mono\"/>#{line}\r\n<output class=\"\"/>")
    end

    # Formats experience columns for legacy output
    # @param char [Hash] character info
    # @param just [Hash] justification widths
    # @return [String] formatted experience columns
    def format_experience_columns(char, just)
      return "<preset id=\"speech\">F2P</preset>".ljust(just[:x2]) +
             "<preset id=\"speech\">F2P</preset>".ljust(just[:x3]) +
             "<preset id=\"speech\">F2P</preset>".ljust(just[:x4]) +
             "<preset id=\"speech\">F2P</preset>".ljust(just[:x5]) +
             "<preset id=\"speech\">F2P</preset>".ljust(just[:status]) if char[:refreshwhen] > (Time.now + 1_000_000)

      if char[:refreshwhen] < Time.now
        # When lumnis is Ready - use flag to determine starting values
        x4_ready = (char[:supports_4x_5x] == true) ? "7300" : "0"
        x5_ready = (char[:supports_4x_5x] == true) ? "7300" : "0"

        return (char[:doubledexperience].to_s || "7300").ljust(just[:x2]) +
               (char[:tripledexperience].to_s || "7300").ljust(just[:x3]) +
               x4_ready.ljust(just[:x4]) +
               x5_ready.ljust(just[:x5]) +
               "Rdy".ljust(just[:status])
      end

      result = ""

      # 2x experience
      if char[:doubledexperience].to_i == 0
        result += "<preset id=\"watching\">#{char[:doubledexperience].to_s.ljust(just[:x2])}</preset>"
      else
        result += char[:doubledexperience].to_s.ljust(just[:x2])
      end

      # 3x experience
      if char[:tripledexperience].to_i == 0
        result += "<preset id=\"watching\">#{char[:tripledexperience].to_s.ljust(just[:x3])}</preset>"
      else
        result += char[:tripledexperience].to_s.ljust(just[:x3])
      end

      # 4x experience - show actual stored value when active
      if (char[:quadrupledexperience] || 0).to_i == 0
        result += "<preset id=\"watching\">#{(char[:quadrupledexperience] || 0).to_s.ljust(just[:x4])}</preset>"
      else
        result += (char[:quadrupledexperience] || 0).to_s.ljust(just[:x4])
      end

      # 5x experience - show actual stored value when active
      if (char[:quintupledexperience] || 0).to_i == 0
        result += "<preset id=\"watching\">#{(char[:quintupledexperience] || 0).to_s.ljust(just[:x5])}</preset>"
      else
        result += (char[:quintupledexperience] || 0).to_s.ljust(just[:x5])
      end

      # Status
      total_exp = [
        char[:doubledexperience].to_i,
        char[:tripledexperience].to_i,
        (char[:quadrupledexperience] || 0).to_i,
        (char[:quintupledexperience] || 0).to_i
      ].sum

      result += if total_exp > 0
                  "Act".ljust(just[:status])
                else
                  "<preset id=\"watching\">Exp</preset>".ljust(just[:status])
                end

      result
    end

    # Formats resource columns for legacy output
    # @param char [Hash] character info
    # @param just [Hash] justification widths
    # @return [String] formatted resource columns
    def format_resource_columns(char, just)
      result = ""

      if UserVars.lumnismon[:show_weekly_resource]
        result += format_weekly_resource_column(char, just)
      end

      if UserVars.lumnismon[:show_total_resource]
        result += format_total_resource_column(char, just)
      end

      if UserVars.lumnismon[:show_suffused_resource]
        result += format_suffused_resource_column(char, just)
      end

      result
    end

    # Formats weekly resource column
    # @param char [Hash] character info
    # @param just [Hash] justification widths
    # @return [String] formatted column
    def format_weekly_resource_column(char, just)
      value = char[:currentweeklyresource]
      total = char[:currenttotalresource]

      if value == "F2P"
        "<preset id=\"speech\">#{value.ljust(just[:week])}</preset>"
      elsif value.to_i == 50_000
        "<preset id=\"watching\">#{value.to_s.ljust(just[:week])}</preset>"
      elsif total.to_i == 200_000
        "<preset id=\"speech\">#{value.to_s.ljust(just[:week])}</preset>"
      elsif %w[RSN ATN].include?(value)
        "<preset id=\"thought\">#{value.ljust(just[:week])}</preset>"
      else
        value.to_s.ljust(just[:week])
      end
    end

    # Formats total resource column
    # @param char [Hash] character info
    # @param just [Hash] justification widths
    # @return [String] formatted column
    def format_total_resource_column(char, just)
      value = char[:currenttotalresource]

      if value == "F2P"
        "<preset id=\"speech\">#{value.ljust(just[:tot])}</preset>"
      elsif value.to_i == 200_000
        "<preset id=\"speech\">#{value.to_s.ljust(just[:tot])}</preset>"
      elsif value.to_i > 150_000 && value.to_i < 200_000
        "<pushBold/>#{value.to_s.ljust(just[:tot])}<popBold/>"
      elsif %w[RSN ATN].include?(value)
        "<preset id=\"thought\">#{value.ljust(just[:tot])}</preset>"
      else
        value.to_s.ljust(just[:tot])
      end
    end

    # Formats suffused resource column
    # @param char [Hash] character info
    # @param just [Hash] justification widths
    # @return [String] formatted column
    def format_suffused_resource_column(char, just)
      value = char[:currentsuffusedresource]

      if %w[RSN ATN].include?(value)
        "<preset id=\"thought\">#{value.ljust(just[:suf])}</preset>"
      elsif value == "F2P"
        "<preset id=\"speech\">#{value.ljust(just[:suf])}</preset>"
      else
        value.to_s.ljust(just[:suf])
      end
    end

    # Displays help instructions
    # @return [void]
    def give_instructions
      Lich::Messaging.msg("info", "Welcome to LumnisMon/MyInfo. We provide a bunch of cool info to help you track what your characters are doing each week!")
      Lich::Messaging.msg("info", "From lumnis info to resources to bounty points to deeds...there's a lot here now.")
      _respond ""
      Lich::Messaging.msg("info", "Run ';lumnismon' by itself to get and record the information for this character and report any other characters that are already logged")
      Lich::Messaging.msg("info", "Run ';lumnismon log' to execute lumnis info and log the results but not show the report for other characters upon completion")
      Lich::Messaging.msg("info", "Run ';lumnismon help' or 'lumnismon ?' shows this dialog you are reading now.")
      Lich::Messaging.msg("info", "Run ';lumnismon report' to only load and report what is stored, not logging anything.")
      _respond ""
      Lich::Messaging.msg("info", "In addition, you can set a whole lot of options, including picking one of two ways to sort, whether you want to see your account...")
      _respond ""

      display_settings
    end

    # Displays current settings
    # @return [void]
    # Displays current settings
    # @return [void]
    def display_settings
      settings_info = [
        ["--show-account", "Show account names", UserVars.lumnismon[:show_account]],
        ["--char-account", "Your account name", UserVars.lumnismon[:char_account]],
        ["--account-inline", "Show account inline or as header", UserVars.lumnismon[:account_inline]],
        ["--show-prof", "Show profession", UserVars.lumnismon[:show_prof]],
        ["--show-level", "Show level", UserVars.lumnismon[:show_level]],
        ["--show-deeds", "Show current deeds", UserVars.lumnismon[:show_deeds]],
        ["--show-invoker", "Show invoker spell times", UserVars.lumnismon[:show_invoker]],
        ["--show-check-time", "Show last check time", UserVars.lumnismon[:show_check_time]],
        ["--show-renew-time", "Show renewal time", UserVars.lumnismon[:show_renew_time]],
        ["--show-field-exp", "Show field experience", UserVars.lumnismon[:show_field_exp]],
        ["--show-weekly-resource", "Show weekly resource", UserVars.lumnismon[:show_weekly_resource]],
        ["--show-total-resource", "Show total resource", UserVars.lumnismon[:show_total_resource]],
        ["--show-suffused-resource", "Show suffused resource", UserVars.lumnismon[:show_suffused_resource]],
        ["--show-xpn", "Show experience to next level", UserVars.lumnismon[:show_xpn]],
        ["--show-next-schedule", "Show next schedule date", UserVars.lumnismon[:show_next_schedule]],
        ["--show-bps", "Show bounty points", UserVars.lumnismon[:show_bps]],
        ["--sort-by-refresh", "Sort by renewal time", UserVars.lumnismon[:sort_by_refresh]],
        ["--sort-by-account", "Sort by account", UserVars.lumnismon[:sort_by_account]],
        ["--use-terminal-table", "Use terminal-table for output", UserVars.lumnismon[:use_terminal_table]],
        ["--header-repeat-rows", "Show headers every N rows (0=never repeat)", UserVars.lumnismon[:header_repeat_rows]]
      ]

      settings_info.each do |setting, description, value|
        if setting == "--char-account"
          Lich::Messaging.msg("info", "Setting: #{setting}=ACCOUNT_NAME")
        elsif setting == "--header-repeat-rows"
          Lich::Messaging.msg("info", "Setting: #{setting}=NUMBER (e.g., 10, 15, 0)")
        else
          Lich::Messaging.msg("info", "Setting: #{setting}=on|yes|true|off|no|false")
        end
        Lich::Messaging.msg("info", "#{description}")
        Lich::Messaging.msg("bold", "Currently: #{value}")
        _respond ""
      end
    end
  end

  # Configuration management
  module Config
    # Available boolean settings
    BOOLEAN_SETTINGS = {
      show_account: false,
      account_inline: false,
      show_prof: true,
      show_level: true,
      show_deeds: true,
      show_invoker: true,
      show_check_time: false,
      show_renew_time: false,
      show_field_exp: true,
      show_weekly_resource: true,
      show_total_resource: true,
      show_suffused_resource: true,
      show_xpn: true,
      show_next_schedule: false,
      show_bps: true,
      sort_by_refresh: false,
      sort_by_account: true,
      sort_by_name: false,
      sort_by_custom: false,
      use_terminal_table: true
    }.freeze unless defined?(MyInfo::Config::BOOLEAN_SETTINGS)

    # Default numeric settings
    NUMERIC_SETTINGS = {
      header_repeat_rows: 10 # Show headers every N rows (0 = never repeat)
    }.freeze unless defined?(MyInfo::Config::NUMERIC_SETTINGS)

    # Value converters for settings
    SETTING_VALUES = {
      'on' => true, 'true' => true, 'yes' => true,
      'off' => false, 'false' => false, 'no' => false
    }.freeze unless defined?(MyInfo::Config::SETTING_VALUES)

    class << self
      # Initializes default settings
      # @return [void]
      def initialize_defaults
        UserVars.lumnismon = {} if UserVars.lumnismon.nil?

        BOOLEAN_SETTINGS.each do |setting, default|
          UserVars.lumnismon[setting] = default if UserVars.lumnismon[setting].nil?
        end

        NUMERIC_SETTINGS.each do |setting, default|
          UserVars.lumnismon[setting] = default if UserVars.lumnismon[setting].nil?
        end

        # Handle legacy migration
        if !UserVars.lumnismon_char_account.nil?
          UserVars.lumnismon[:char_account] = UserVars.lumnismon_char_account
        end

        UserVars.lumnismon[:char_account] = "9999 Not Listed" if UserVars.lumnismon[:char_account].nil?
      end

      # Processes command line arguments
      # @param args [Array] command line arguments
      # @return [Hash] hash with :mode and :settings_changed keys
      def process_arguments(args)
        return { mode: :normal, settings_changed: false } if args.nil? || args.empty?

        first_arg = args[0]

        return { mode: :log, settings_changed: false } if first_arg =~ /^log$/
        return { mode: :help, settings_changed: false } if first_arg =~ /^help$|\?$/
        return { mode: :report, settings_changed: false } if first_arg =~ /^report$/

        settings_changed = process_settings(args)

        { mode: :normal, settings_changed: settings_changed }
      end

      # Processes settings from arguments
      # @param args [Array] command line arguments
      # @return [Boolean] whether any settings were changed
      def process_settings(args)
        changed = false

        args.each do |arg|
          changed = true if process_single_setting(arg)
        end

        changed
      end

      # Processes a single setting argument
      # @param arg [String] the argument string
      # @return [Boolean] whether the setting was recognized and changed
      def process_single_setting(arg)
        # Boolean settings
        if arg =~ /^(?:--|-)?(\w+(?:-\w+)*)=(yes|no|on|off|true|false)$/
          setting_name = Regexp.last_match(1).tr('-', '_').to_sym
          value = SETTING_VALUES[Regexp.last_match(2)]

          if BOOLEAN_SETTINGS.key?(setting_name)
            UserVars.lumnismon[setting_name] = value
            return true
          end
        end

        # Numeric settings
        if arg =~ /^(?:--|-)?(\w+(?:-\w+)*)=(\d+)$/
          setting_name = Regexp.last_match(1).tr('-', '_').to_sym
          value = Regexp.last_match(2).to_i

          if NUMERIC_SETTINGS.key?(setting_name)
            UserVars.lumnismon[setting_name] = value
            return true
          end
        end

        # char_account setting
        if arg =~ /(?:--|-)?char-?account=(.+?)$/
          UserVars.lumnismon[:char_account] = Regexp.last_match(1)
          return true
        end

        # custom_place setting (legacy, kept for compatibility)
        if arg =~ /(?:--|-)?custom-?place=(\d+?)$/
          UserVars.lumnismon[:custom_place] = Regexp.last_match(1).to_i
          return true
        end

        false
      end
    end
  end
end

# Main execution
log_only = false
report_only = false

# Initialize configuration
MyInfo::Config.initialize_defaults

# Process command line arguments
result = MyInfo::Config.process_arguments(Script.current.vars)

case result[:mode]
when :help
  MyInfo.give_instructions
  exit
when :log
  log_only = true
when :report
  report_only = true
when :normal
  if result[:settings_changed]
    Lich::Messaging.msg("info", "Saving var changes and exiting. Rerun plain or with 'log' as option to log data and/or see output.")
    exit
  end
end

# Execute main functionality
MyInfo.load(report_only)
MyInfo.get_lumnis_info unless report_only
MyInfo.save unless report_only
MyInfo.report unless log_only
