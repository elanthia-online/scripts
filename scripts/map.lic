=begin
map - Elanthia Online's fork of LostRanger's narost fork.
Tracks your current room on visual maps

  Key differences between this and ;narost:
    * map has a better-organized map list with submenus, and uses 'proper' map names instead of filenames.
    * map sorts the list of tags.

  click on a room to go there
  shift-click on a room to show its description
  right-click for some options

      author: elanthia-online
      game: Gemstone
      tags: core, movement, mapping
      required: Lich >= 5.13.0
      version: 2.0.2

  changelog:
    v2.0.2 (2025-02-12)
      * Fix Linux window sticking to all workspaces - removed incorrect stick() calls
      * Fix GTK menu detach warning on cleanup
    v2.0.1 (2025-02-12)
      * Fix GTK crash on long running sessions
      * Fix follow_me getting disabled when opening with specific room#
      * Fix showing empty canvas/layout around the map as toggleable option
    v2.0.0 (2025-01-21)
      * Complete refactor into ElanthiaMap namespace
      * Added proper module/class architecture
      * Added comprehensive YARD documentation
      * Cleaned up GTK3 code
      * Modernized Ruby idioms
      * Renamed legacy 'narost' variables to descriptive names
      * Added "Keep Centered" option (enabled by default) to auto-center viewport on room marker
    v1.4.1 (2025-07-08)
      * Handle a location of false
    v1.4.0 (2025-07-04)
      * Add Locations drop down (similar to tags)
    v1.3.10 (2025-05-29)
      * Fix for missing dark maps causing GTK errors and DR not having any dark maps
    v1.3.9 (2025-05-10)
      * Fix for default geometry and primary display saved settings forcing window back to primary monitor
      * Correct MapData variable return to be class variable instead of instance variable
    v1.3.8 (2025-04-20)
      * Fix for initial default window position for tiling window managers that do not set monitor geometry
    v1.3.7 (2025-04-15)
      * Fix reset and initial default value/position of window to primary monitor location
    v1.3.6 (2025-03-06)
      * Bugfix for toggling dark mode when no map available for current room in mapdb
    v1.3.5 (2025-02-23)
      * Add opacity setting to reset option
    v1.3.4 (2024-08-23)
      * Bugfix on Find Room loading map file
    v1.3.3 (2024-08-09)
      * Update Settings to save location / size parameters per character
    v1.3.2 (2024-07-12)
      * Additional fixes for WSL and responsiveness
    v1.3.1 (2024-06-29)
      * fix popup menu crash under WSL
      * fix pointer click offset issues in WSL
    v1.3.0 (2024-06-26)
      * add runtime toggle for opacity (ala orbuculum)
      * add runtime toggle for borderless window and no scrollbar window (also orbuculum)
    v1.2.0 (2024-05-19)
      * fix crash when closing window after opening context menu
      * add runtime togglable 'dark mode'
      * added spacer to keep window position on Mac OS
    v1.1.2 (2024-04-30)
      * update to use File.join where appropriate
      * change to use MAP_DIR instead of LICH_DIR+'maps' folder.
      * change to use lich constants instead of global vars
    v1.1.1 (2024-02-27)
      * fix to unhide circle when doing a 'find room' search
    v1.1.0 (2023-12-15)
      * add RESET option to set all Settings back to default
    v1.0.0 (2023-08-18)
      * initial release and forking from xnarost v1.0.3
=end

i_stand_alone
clear

unless HAVE_GTK
  respond
  respond 'error: ruby-gtk bindings are not installed or failed to load'
  respond
  exit
end

unless defined?(Gtk.queue)
  respond
  respond 'Your version of Lich is too old for this script.'
  respond
  exit
end

if Script.current.vars[1] == 'help'
  respond "Version: #{(Script.list.find { |x| x.name == Script.current.name }.inspect)[/version: (\d+\.\d+\.\d+)/i, 1]}                                                                              "
  respond "   ;map help                   - this output                                                "
  respond "   ;map <number>               - shows LichID# in map window instead of current room        "
  respond "   ;map u<number>              - shows RealID# in map window instead of current room        "
  respond "   ;map <text to search>       - shows room# that first matches text instead of current room"
  respond "   ;map fix                    - enables coordinate fix mode (ctrl+shift+click to set room) "
  respond "   ;map trouble                - enables debug output for troubleshooting window issues     "
  respond "   ;map reset                  - resets map settings to default values                      "
  respond "                                      keep_above = true                                     "
  respond "                                      keep_centered = true                                  "
  respond "                                      expanded_canvas = true                                "
  respond "                                      follow_mode = true                                    "
  respond "                                      global_scale = 1                                      "
  respond "                                      global_scale_enabled = false                          "
  respond "                                      dynamic_indicator_size = false                        "
  respond "                                      opacity = 1.0                                         "
  respond "                                      map_scale = {}                                        "
  respond "                                      window_width = 400                                    "
  respond "                                      window_height = 300                                   "
  respond "                                      primary window_position = [0, 0]                      "
  respond "                                                                                            "
  respond "   In-Map Controls:                                                                         "
  respond "      click                    - navigate to room or follow map link                        "
  respond "      shift+click              - show room description                                      "
  respond "      ctrl+click               - show coordinates at click position                         "
  respond "      ctrl+shift+click (fix)   - set room coordinates (click twice for corners)             "
  respond "      ctrl+scroll              - zoom in/out                                                "
  respond "      right-click              - open options menu                                          "
  exit
end

# Main namespace for the Elanthia map visualization tool
#
# This module provides GTK-based map visualization for Lich scripting framework,
# with full cross-platform support for Linux, native Windows, WSL, and macOS.
#
# @note Platform-Specific Behavior
#   - **macOS**: Uses Quartz backend with special handling for window visibility
#     and presentation. X11-specific features (UTILITY window hints, stick/unstick)
#     are automatically skipped.
#   - **Native Windows**: Uses Windows backend. X11-specific features are skipped
#     to ensure proper taskbar integration and window behavior.
#   - **Linux/WSL+X11**: Uses X11/Wayland backends with full window manager
#     integration and all X11-specific features enabled.
#
# @example Basic Usage
#   # Run the map script
#   ;map
#
#   # Show specific room
#   ;map 12345
#
#   # Enable debug output
#   ;map trouble
module ElanthiaMap
  # Platform detection constants for GTK backend compatibility
  # Uses Lich's OS module for consistent platform detection across scripts
  #
  # @return [Boolean] True if running on macOS (Quartz backend)
  IS_MACOS = OS.mac? unless defined?(IS_MACOS)
  # @return [Boolean] True if running on native Windows (Windows backend)
  IS_WINDOWS = OS.windows? unless defined?(IS_WINDOWS)
  # @return [Boolean] True if X11-specific features should be used (Linux/WSL+X11)
  USE_X11_FEATURES = (!IS_MACOS && !IS_WINDOWS) unless defined?(USE_X11_FEATURES)

  # Module instance variable to store current window for cleanup
  @current_window = nil

  class << self
    # @return [Window, nil] The currently active map window
    attr_accessor :current_window
  end

  # Manages map metadata extracted from room tags in the mapdb
  #
  # @example Get map data for a specific map
  #   map_info = ElanthiaMap::MapData['TI-teras.gif']
  #   puts map_info[:name]
  #
  # @example Access all map data
  #   ElanthiaMap::MapData.data.each do |key, map_info|
  #     puts "#{key}: #{map_info[:name]}"
  #   end
  class MapData
    @data = nil

    class << self
      # Returns the complete map metadata hash
      #
      # Lazy-loads and caches map metadata from room tags on first access.
      # Extracts mapname, mapshortname, and mapcategory tags from rooms.
      #
      # @return [Hash{String => Hash}] Map metadata indexed by normalized filename
      # @option value [String] :name Display name for the map
      # @option value [String] :shortname Short display name
      # @option value [Hash] :categories Category/subcategory relationships
      # @option value [String] :filename Original filename from room data
      def data
        return @data if @data

        @data = {}
        Room.list.each do |room|
          next unless room.image

          key = normalize_key(room.image)
          map = @data[key]

          unless map
            @data[key] = map = {
              name: nil,
              shortname: nil,
              categories: {},
              filename: room.image
            }
          end

          next unless room.tags

          extract_tags(room.tags, map)
        end

        finalize_metadata
        @data
      end

      # Retrieves map metadata for a given filename
      #
      # @param key [String] Map filename (will be normalized)
      # @return [Hash, nil] Map metadata or nil if not found
      def [](key)
        data[normalize_filename(key)]
      end

      # Sets map metadata for a given filename
      #
      # @param key [String] Map filename (will be normalized)
      # @param value [Hash] Map metadata to store
      # @return [Hash] The stored metadata
      def []=(key, value)
        data[normalize_filename(key)] = value
      end

      # Normalizes a filename to a standard format
      #
      # Removes file extension and trailing numbers (e.g., '-1', '-2')
      # and converts to lowercase for consistent lookup.
      #
      # @param filename [String] Filename to normalize
      # @return [String] Normalized filename
      # @example
      #   MapData.normalize_filename('TI-Teras-1.gif') #=> 'ti-teras'
      def normalize_filename(filename)
        filename.gsub(/(-\d+)?\..+$/, '').downcase
      end

      private

      # Normalizes a map key from room data
      # @param image [String] The image filename from room data
      # @return [String] Normalized key
      def normalize_key(image)
        key = image
        key = ::Regexp.last_match(1) if key =~ /^(.+)\.[^.]*$/
        key = ::Regexp.last_match(1) if key =~ /^(.+)-\d+$/
        key
      end

      # Extracts metadata tags from room tags
      # @param tags [Array<String>] Room tags to process
      # @param map [Hash] Map metadata hash to update
      # @return [void]
      def extract_tags(tags, map)
        return unless tags

        tags.each do |tag|
          next unless tag.is_a?(String)

          case tag
          when /^meta:mapname:(.*)$/
            map[:name] ||= ::Regexp.last_match(1)
          when /^meta:mapshortname:(.*)$/
            map[:shortname] ||= ::Regexp.last_match(1)
          when /^meta:mapcategory:(.*?)(?::(.*))?$/
            map[:categories][::Regexp.last_match(1)] = ::Regexp.last_match(2)
          end
        end
      end

      # Finalizes metadata by filling in defaults
      # @return [void]
      def finalize_metadata
        @data.each do |key, map|
          map[:name] ||= key
          shortname = (map[:shortname] ||= map[:name])
          map[:categories].each_key { |k| map[:categories][k] ||= shortname }
        end
      end
    end

    # Map link definitions for navigation between maps
    # Format: [source_map, x1, x2, y1, y2, target_map, target_x, target_y]
    MAP_LINKS = [
      ['TI-teras.gif', 1962, 2238, 68, 192, 'TI-wilds.gif', 840, 1252],
      ['TI-teras.gif', 710, 972, 2130, 2260, 'WL-wehnimers.gif', 2338, 1070],
      ['TI-wilds.gif', 1124, 1412, 604, 682, 'TI-vtull.gif', 2276, 1638],
      ['TI-wilds.gif', 678, 1006, 1218, 1296, 'TI-teras.gif', 2100, 130],
      ['TI-wilds.gif', 1448, 1776, 1386, 1464, 'EN-victory.gif', 660, 1340],
      ['TI-vtull.gif', 2156, 2380, 1556, 1636, 'TI-wilds.gif', 1246, 654],
      ['WL-wehntower.gif', 1448, 1738, 1284, 1414, 'WL-wehnimers.gif', 2182, 464],
      ['WL-wehnimers.gif', 2198, 2314, 364, 480, 'WL-wehntower.gif', 1622, 1332],
      ['WL-wehnimers.gif', 2296, 2380, 1020, 1104, 'TI-teras.gif', 858, 1010],
      ['EN-victory.gif', 548, 724, 1256, 1332, 'TI-wilds.gif', 1634, 1428],
      ['EN-dragonspine.gif', 2038, 2130, 2180, 2272, 'EN-victory.gif', 1654, 218],
      ['EN-victory.gif', 1628, 1720, 144, 236, 'EN-dragonspine.gif', 2092, 2218],
    ].freeze unless defined?(MAP_LINKS)
  end

  # Manages cached map images and their properties
  #
  # Handles loading, caching, and scaling of map images including
  # support for dark mode variants.
  class MapCache
    # @return [Hash{String => Hash}] Cached map data
    attr_reader :cached_maps

    def initialize
      @cached_maps = {}
    end

    # Loads and caches map image data
    #
    # @param map_path [String] Full path to the map file
    # @param dark_mode [Boolean] Whether to load dark mode variant
    # @return [Hash, nil] Map data hash with :pixbuf, :width, :height or nil if file doesn't exist
    def load_map(map_path, dark_mode: false)
      effective_path = resolve_map_path(map_path, dark_mode)
      return nil unless File.exist?(effective_path)

      cache_key = effective_path

      unless @cached_maps[cache_key]
        begin
          pixbuf = GdkPixbuf::Pixbuf.new(file: effective_path)
          @cached_maps[cache_key] = {
            pixbuf: pixbuf,
            width: pixbuf.width,
            height: pixbuf.height
          }
        rescue StandardError => e
          respond "[map: Error loading map file '#{effective_path}': #{e.message}]"
          return nil
        end
      end

      @cached_maps[cache_key]
    end

    # Gets cached map data if available
    #
    # @param map_path [String] Full path to the map file
    # @param dark_mode [Boolean] Whether to check for dark mode variant
    # @return [Hash, nil] Cached map data or nil
    def [](map_path, dark_mode: false)
      effective_path = resolve_map_path(map_path, dark_mode)
      @cached_maps[effective_path]
    end

    # Clears all cached map data
    #
    # @return [void]
    def clear
      @cached_maps.clear
    end

    private

    # Resolves the actual file path considering dark mode variants
    #
    # @param map_path [String] Base map path
    # @param dark_mode [Boolean] Whether to use dark mode variant
    # @return [String] Resolved file path
    def resolve_map_path(map_path, dark_mode)
      return map_path unless dark_mode

      dark_path = map_path.sub('/maps/', '/maps-dark/')
      File.exist?(dark_path) ? dark_path : map_path
    end
  end

  # Main window manager for the map interface
  #
  # Handles GTK window creation, map display, user interaction,
  # and room tracking. Provides cross-platform support with special
  # handling for macOS and Windows GTK backend quirks.
  #
  # @note Platform Compatibility
  #   The Window class includes special handling for different GTK backends:
  #
  #   **macOS (Quartz backend)**:
  #   - Explicit window presentation via `present()` and `activate_focus()`
  #   - Skips X11-specific window hints (UTILITY type, stick/unstick)
  #   - Uses fixed delay instead of `visible?` check for window readiness
  #   - Positions window before showing to ensure correct placement
  #
  #   **Native Windows (Windows backend)**:
  #   - Skips X11-specific window hints to ensure proper taskbar integration
  #   - Uses standard GTK keep_above without UTILITY type or stick methods
  #
  #   **Linux/WSL+X11 (X11/Wayland backends)**:
  #   - Full X11 feature support including UTILITY hints and stick/unstick
  #   - Better integration with various window managers
  #
  # @example Create and show a window
  #   window = ElanthiaMap::Window.new(script, MAP_DIR)
  #   window.show
  #   # Window will automatically present itself on macOS
  #   # and appear in taskbar on Windows
  class Window
    # @return [Gtk::Window] The GTK window instance
    attr_reader :gtk_window

    # @return [String] Currently displayed map file path
    attr_reader :current_map

    # @return [Boolean] Whether the script should exit
    attr_accessor :should_exit

    # @return [Boolean] Whether to follow room changes automatically
    attr_accessor :follow_mode

    # @return [Boolean] Whether follow_mode was temporarily disabled (don't save on exit)
    attr_accessor :temp_follow_disabled

    # @return [Boolean] Whether debug/trouble mode is enabled
    attr_reader :trouble_mode

    # Default window dimensions
    DEFAULT_WIDTH = 400 unless defined?(DEFAULT_WIDTH)
    DEFAULT_HEIGHT = 300 unless defined?(DEFAULT_HEIGHT)

    # Creates and initializes the map window
    #
    # @param script [Script] The running script instance
    # @param map_dir [String] Directory containing map files
    def initialize(script, map_dir)
      @script = script
      @map_dir = map_dir
      @map_cache = MapCache.new
      @current_map = nil
      @current_room = nil
      @should_exit = false
      @drag_state = nil
      @fake_room = nil
      @tag_markers = []
      @location_markers = []
      @fix_click = nil
      @last_user_scroll = nil
      @map_offset_x = 0  # X offset of map image within layout
      @map_offset_y = 0  # Y offset of map image within layout

      # Check for special modes
      @fix_mode = script.vars[1] =~ /fix/ ? true : false
      @trouble_mode = script.vars[1] =~ /trouble/ ? true : false

      # Load settings
      load_settings

      # Set follow_mode from loaded settings
      @follow_mode = @settings[:follow_mode]

      # Track if follow_mode was temporarily disabled (e.g., for viewing specific room)
      # When true, don't save follow_mode state on exit
      @temp_follow_disabled = false

      # Create GTK components
      create_window
      create_menu
      create_map_display
      setup_event_handlers

      # Apply initial settings
      apply_window_settings
    end

    # Shows the window and enters the main event loop
    #
    # On MacOS, GTK windows require explicit presentation and activation to become visible.
    # The window is positioned before showing to ensure correct placement, then presented
    # to the user with focus activation.
    #
    # @return [void]
    def show
      # Position before showing to ensure correct placement
      position_window
      @gtk_window.show_all
      # Establish keep_above status after showing (window is mapped)
      @gtk_window.keep_above = @settings[:keep_above]

      # MacOS-specific: Explicitly present and activate the window
      # GTK's window visibility works differently on MacOS than Linux/X11
      if IS_MACOS
        @gtk_window.present
        begin
          @gtk_window.activate_focus if @gtk_window.respond_to?(:activate_focus)
        rescue StandardError
          # Ignore if method doesn't work in current environment
        end
      end
    end

    # Changes the currently displayed map
    #
    # @param map_path [String] Path to the new map file
    # @return [Boolean] Whether the map was successfully changed
    def change_map(map_path)
      return false if @current_map == map_path

      map_data = @map_cache.load_map(map_path, dark_mode: @settings[:dark_mode])
      return false unless map_data

      @current_map = map_path
      update_map_display(map_data)
      true
    end

    # Updates the room marker to the current room's position
    #
    # @param room [Room, nil] The room to display, defaults to current room
    # @return [void]
    def update_room_marker(room = nil)
      room ||= Room.current
      @current_room = room # Track the current room for title updates

      if room && room.image
        coords = extract_room_coordinates(room)
        if coords
          display_room_marker(*coords)
          update_window_title(room)
          return
        end
      end

      hide_room_marker
      update_window_title(nil)
    end

    # Updates the window title with character name and current room ID
    #
    # @param room [Room, nil] The room to display in the title, or nil for no room ID
    # @return [void]
    def update_window_title(room = nil)
      title = if room && room.id
                "Map: #{Char.name} (##{room.id})"
              else
                "Map: #{Char.name}"
              end

      Gtk.queue { @gtk_window.title = title }
    end

    # Destroys the window and cleans up resources
    # Note: Settings are saved in run method or before_dying hook, not here
    #
    # @return [void]
    def destroy
      begin
        Gtk.queue do
          # Clean up markers first
          begin
            @tag_markers.each do |marker|
              marker.destroy if marker && !marker.destroyed?
            end
            @tag_markers.clear
          rescue StandardError
            # Ignore errors
          end

          begin
            @location_markers.each do |marker|
              marker.destroy if marker && !marker.destroyed?
            end
            @location_markers.clear
          rescue StandardError
            # Ignore errors
          end

          # Destroy menu before window
          if @menu && !@menu.destroyed?
            # No need to detach - menus created with Gtk::Menu.new aren't attached
            @menu.destroy
          end
          @menu = nil

          # Destroy child widgets explicitly
          if @gtk_window && !@gtk_window.destroyed?
            begin
              # Remove all children from layout to clean up signal handlers
              if @layout && !@layout.destroyed?
                @layout.each { |child| @layout.remove(child) rescue nil }
              end
            rescue StandardError
              # Ignore errors
            end

            # Now destroy the window
            @gtk_window.destroy
          end
          @gtk_window = nil
        end
      rescue StandardError => e
        # Log error if in trouble mode but don't raise
        respond "[map: Error during cleanup: #{e.message}]" if @trouble_mode rescue nil
      end
    end

    # Captures current window position and size
    # This is a separate method to maintain DRY principle
    #
    # On macOS, the captured Y position is adjusted to account for the 28-pixel
    # menu bar offset that will be applied during position_window(). This prevents
    # the window from creeping up the screen on each restart.
    #
    # @return [Array] Two-element array: [position_array, size_array] or [nil, nil] if capture fails
    def capture_window_geometry
      window_pos = window_size = nil
      completed = false
      window_exists = false
      window_destroyed = false
      window_visible = false

      Gtk.queue {
        begin
          window_exists = @gtk_window ? true : false

          if window_exists
            # Only check destroyed/visible if window exists
            # These can raise errors if called on destroyed GObjects
            begin
              window_destroyed = @gtk_window.destroyed?
              window_visible = @gtk_window.visible? unless window_destroyed
            rescue StandardError => e
              respond "[map: Error checking window state: #{e.message}]" if @trouble_mode
              window_destroyed = true # Assume destroyed if we can't check
            end
          end

          if window_exists && !window_destroyed && window_visible
            window_pos = @gtk_window.position
            window_size = [@gtk_window.allocation.width, @gtk_window.allocation.height]

            # On macOS, detect and compensate for GTK's automatic position adjustment.
            # GTK adjusts our positioned Y by ~32 pixels (matches our +32 offset).
            # If captured Y is close to expected (within 10px), maintain original Y to prevent drift.
            # If captured Y is far from expected, user manually moved window - honor that.
            if ElanthiaMap::IS_MACOS && window_pos && @char_settings[:window_position]
              original_y = @char_settings[:window_position][1]
              captured_y = window_pos[1]
              expected_y = original_y + 32 - 32 # We add 32, GTK subtracts ~32

              drift = (captured_y - expected_y).abs

              if @trouble_mode
                respond "[map: DEBUG - Original Y: #{original_y}]"
                respond "[map: DEBUG - Captured Y: #{captured_y}]"
                respond "[map: DEBUG - Expected Y: #{expected_y}]"
                respond "[map: DEBUG - Drift: #{drift}px]"
              end

              if drift < 10 # Within 10px = GTK adjustment, not user move
                respond "[map: DEBUG - Drift < 10px, maintaining original Y]" if @trouble_mode
                window_pos = [window_pos[0], original_y]
              else
                respond "[map: DEBUG - Drift >= 10px, user moved window, using captured Y]" if @trouble_mode
              end
            end
          end
        rescue StandardError => e
          # Window already destroyed or error accessing properties
          respond "[map: Error capturing geometry: #{e.message}]" if @trouble_mode
        ensure
          completed = true
        end
      }

      # Wait for Gtk.queue block to complete with timeout
      timeout = 100 # Increased timeout
      while !completed && timeout > 0
        sleep 0.01
        timeout -= 1
      end

      # Debug output if in trouble mode
      if @trouble_mode
        respond '[map: === CAPTURE_WINDOW_GEOMETRY ===]'
        respond "[map: Window exists: #{window_exists}]"
        respond "[map: Window destroyed: #{window_destroyed}]"
        respond "[map: Window visible: #{window_visible}]"
        respond "[map: Queue completed: #{completed}]"
        respond "[map: Timeout remaining: #{timeout}]"
        respond "[map: Captured position: #{window_pos.inspect}]"
        respond "[map: Captured size: #{window_size.inspect}]"
        respond '[map: === END CAPTURE ===]'
      end

      [window_pos, window_size]
    end

    # Saves settings to Lich's Settings store
    # This method does NOT call any GTK methods - position/size must be passed in
    #
    # @param window_pos [Array, nil] Captured window position [x, y]
    # @param window_size [Array, nil] Captured window size [width, height]
    # @return [void]
    def save_settings(window_pos = nil, window_size = nil)
      # Debug output if in trouble mode - BEFORE saving
      if @trouble_mode
        respond
        respond '[map: === SAVING SETTINGS ===]'
        respond "[map: Captured window_pos: #{window_pos.inspect}]"
        respond "[map: Captured window_size: #{window_size.inspect}]"
        respond "[map: Current @char_settings: #{@char_settings.inspect}]"
      end

      # Save position if valid
      if window_pos.is_a?(Array) && window_pos.length == 2
        CharSettings['window_position'] = window_pos
      end

      # Save size if valid
      if window_size.is_a?(Array) && window_size.length == 2 && window_size[0] > 100 && window_size[1] > 100
        CharSettings['window_width'] = window_size[0]
        CharSettings['window_height'] = window_size[1]
      end

      # Save global settings
      Settings['keep_above'] = @settings[:keep_above]
      Settings['global_scale'] = @settings[:global_scale]
      Settings['global_scale_enabled'] = @settings[:global_scale_enabled]
      Settings['map_scale'] = @settings[:map_scale]
      Settings['dark_mode'] = @settings[:dark_mode]
      Settings['opacity'] = @settings[:opacity]
      Settings['borderless'] = @settings[:borderless]
      Settings['hide_scrollbars'] = @settings[:hide_scrollbars]
      Settings['keep_centered'] = @settings[:keep_centered]
      # Only save follow_mode if it wasn't temporarily disabled
      Settings['follow_mode'] = @follow_mode unless @temp_follow_disabled
      Settings['dynamic_indicator_size'] = @settings[:dynamic_indicator_size]
      Settings['expanded_canvas'] = @settings[:expanded_canvas]

      Settings.save

      # Debug output if in trouble mode - AFTER saving
      if @trouble_mode
        respond "[map: Position saved? #{window_pos.is_a?(Array) && window_pos.length == 2}]"
        respond "[map: Size saved? #{window_size.is_a?(Array) && window_size.length == 2 && window_size[0] > 100 && window_size[1] > 100}]"
        respond "[map: CharSettings['window_position'] after save: #{CharSettings['window_position'].inspect}]"
        respond "[map: CharSettings['window_width'] after save: #{CharSettings['window_width'].inspect}]"
        respond "[map: CharSettings['window_height'] after save: #{CharSettings['window_height'].inspect}]"
        respond "[map: Global @settings: #{@settings.inspect}]"
        respond '[map: === END SAVING SETTINGS ===]'
        respond
      end
    end

    # Resets all settings to defaults and saves them (class method)
    # Used by `;map reset` command before window creation
    #
    # @return [void]
    def self.reset_all_settings
      # Reset global settings
      Settings['keep_above'] = true
      Settings['global_scale'] = 1
      Settings['global_scale_enabled'] = false
      Settings['map_scale'] = {}
      Settings['dark_mode'] = false
      Settings['opacity'] = 1.0
      Settings['borderless'] = false
      Settings['hide_scrollbars'] = false
      Settings['keep_centered'] = true
      Settings['follow_mode'] = true
      Settings['dynamic_indicator_size'] = false
      Settings['expanded_canvas'] = true

      # Reset character-specific settings
      CharSettings['window_width'] = DEFAULT_WIDTH
      CharSettings['window_height'] = DEFAULT_HEIGHT
      CharSettings['window_position'] = [0, 0]

      respond '[map: All settings have been reset to defaults]'
    end

    private

    # Loads settings from Lich's Settings store
    # @return [void]
    def load_settings
      @settings = {
        keep_above: Settings['keep_above'].nil? ? true : Settings['keep_above'],
        global_scale: Settings['global_scale'] || 1,
        global_scale_enabled: Settings['global_scale_enabled'].nil? ? false : Settings['global_scale_enabled'],
        map_scale: Settings['map_scale'] || {},
        dark_mode: Settings['dark_mode'] || false,
        opacity: Settings['opacity'] || 1.0,
        borderless: Settings['borderless'] || false,
        hide_scrollbars: Settings['hide_scrollbars'] || false,
        keep_centered: Settings['keep_centered'].nil? ? true : Settings['keep_centered'],
        follow_mode: Settings['follow_mode'].nil? ? true : Settings['follow_mode'],
        dynamic_indicator_size: Settings['dynamic_indicator_size'] || false,
        expanded_canvas: Settings['expanded_canvas'].nil? ? true : Settings['expanded_canvas']
      }

      @char_settings = {
        window_width: CharSettings['window_width'] || DEFAULT_WIDTH,
        window_height: CharSettings['window_height'] || DEFAULT_HEIGHT,
        window_position: CharSettings['window_position'] || [0, 0]
      }

      # Debug output if in trouble mode
      if @trouble_mode
        respond
        respond '[map: === LOADED SETTINGS AT STARTUP ===]'
        respond "[map: Global Settings: #{@settings.inspect}]"
        respond "[map: Character Settings: #{@char_settings.inspect}]"
        respond "[map: CharSettings['window_width']: #{CharSettings['window_width'].inspect}]"
        respond "[map: CharSettings['window_height']: #{CharSettings['window_height'].inspect}]"
        respond "[map: CharSettings['window_position']: #{CharSettings['window_position'].inspect}]"
        respond '[map: === END LOADED SETTINGS ===]'
        respond
      end
    end

    # Creates the main GTK window
    #
    # Sets up the window with appropriate size and type hints. The UTILITY type hint is
    # skipped on macOS (Quartz backend) and native Windows (Windows backend) as it can
    # cause visibility and taskbar issues. On Linux/X11, UTILITY hint helps with
    # keep_above behavior in various window managers.
    #
    # @note Platform-Specific Behavior
    #   - **macOS**: No UTILITY hint (prevents window visibility issues)
    #   - **Native Windows**: No UTILITY hint (ensures taskbar presence)
    #   - **Linux/WSL+X11**: Uses UTILITY hint (better window manager integration)
    #
    # @return [void]
    def create_window
      @gtk_window = Gtk::Window.new
      @gtk_window.title = "Map: #{Char.name}"
      @gtk_window.set_icon(GdkPixbuf::Pixbuf.new(:file => File.join(LICH_DIR, 'logo.png'))) if File.exist?(File.join(LICH_DIR, 'logo.png'))
      @gtk_window.set_default_size(@char_settings[:window_width], @char_settings[:window_height])
      @gtk_window.resize(@char_settings[:window_width], @char_settings[:window_height])

      # Set window type hints to help with keep_above in various window managers
      # Skip UTILITY hint on macOS and native Windows - causes visibility/taskbar issues
      if USE_X11_FEATURES
        @gtk_window.set_type_hint(Gdk::WindowTypeHint::UTILITY)
      end
    end

    # Creates the context menu
    # @return [void]
    def create_menu
      @menu = Gtk::Menu.new

      # Follow mode toggle
      @menu_follow = Gtk::CheckMenuItem.new(label: 'Follow')
      @menu_follow.active = @follow_mode
      @menu_follow.signal_connect('activate') do
        @follow_mode = @menu_follow.active?
        @temp_follow_disabled = false # User explicitly changed it, so save this state
      end
      @menu.append(@menu_follow)

      # Keep centered toggle
      menu_keep_centered = Gtk::CheckMenuItem.new(label: 'Keep Centered')
      menu_keep_centered.active = @settings[:keep_centered]
      menu_keep_centered.signal_connect('activate') do
        @settings[:keep_centered] = menu_keep_centered.active?
      end
      @menu.append(menu_keep_centered)

      # Expanded canvas toggle
      menu_expanded_canvas = Gtk::CheckMenuItem.new(label: 'Expanded Canvas')
      menu_expanded_canvas.active = @settings[:expanded_canvas]
      menu_expanded_canvas.signal_connect('activate') do
        @settings[:expanded_canvas] = menu_expanded_canvas.active?
        # Reload current map to apply new canvas size
        if @current_map
          temp_map = @current_map
          @current_map = nil
          change_map(temp_map)
          update_room_marker
        end
      end
      @menu.append(menu_expanded_canvas)

      # Keep above toggle
      menu_keep_above = Gtk::CheckMenuItem.new(label: 'Keep window on top')
      menu_keep_above.active = @settings[:keep_above]
      menu_keep_above.signal_connect('activate') do
        @settings[:keep_above] = menu_keep_above.active?
        # Apply keep_above setting (stays on top of other windows)
        Gtk.queue do
          @gtk_window.keep_above = @settings[:keep_above]
          # Note: stick/unstick controls workspace behavior (all workspaces vs single)
          # which is separate from keep_above (z-order). Don't link them.
        end
      end
      @menu.append(menu_keep_above)

      # Dark mode toggle
      @menu_dark = Gtk::CheckMenuItem.new(label: 'Dark Mode')
      @menu_dark.active = @settings[:dark_mode]
      @menu_dark.signal_connect('activate') do
        @settings[:dark_mode] = @menu_dark.active?
        # Clear current map from cache to force reload
        if @current_map
          temp_map = @current_map
          @current_map = nil
          change_map(temp_map)
          update_room_marker
        end
      end
      @menu.append(@menu_dark)

      # Opacity submenu
      create_opacity_menu

      # Scale submenu
      create_scale_menu

      # Map selection submenu
      create_map_menu

      # Tags submenu
      create_tags_menu

      # Locations submenu
      create_locations_menu

      # Find room option
      menu_find = Gtk::MenuItem.new(label: 'Find room...')
      menu_find.signal_connect('activate') { prompt_find_room }
      @menu.append(menu_find)

      # Borderless toggle
      menu_borderless = Gtk::CheckMenuItem.new(label: 'Borderless Window')
      menu_borderless.active = @settings[:borderless]
      menu_borderless.signal_connect('activate') do
        @settings[:borderless] = menu_borderless.active?
        Gtk.queue { @gtk_window.decorated = !@settings[:borderless] }
      end
      @menu.append(menu_borderless)

      # Hide scrollbars toggle
      menu_hide_scroll = Gtk::CheckMenuItem.new(label: 'Hide Scrollbars')
      menu_hide_scroll.active = @settings[:hide_scrollbars]
      menu_hide_scroll.signal_connect('activate') do
        @settings[:hide_scrollbars] = menu_hide_scroll.active?
        update_scrollbar_visibility
      end
      @menu.append(menu_hide_scroll)

      # Dynamic indicator size toggle
      menu_dynamic_indicator = Gtk::CheckMenuItem.new(label: 'Dynamic Indicator Size')
      menu_dynamic_indicator.active = @settings[:dynamic_indicator_size]
      menu_dynamic_indicator.signal_connect('activate') do
        @settings[:dynamic_indicator_size] = menu_dynamic_indicator.active?
        # Force marker redraw with new size
        update_room_marker
      end
      @menu.append(menu_dynamic_indicator)

      # Rebuild dynamic menus when menu is about to show
      @menu.signal_connect('show') do
        rebuild_dynamic_menus
      end

      @menu.show_all
    end

    # Creates the opacity submenu
    # @return [void]
    def create_opacity_menu
      menu_opacity = Gtk::MenuItem.new(label: 'Opacity')
      submenu = Gtk::Menu.new
      menu_opacity.submenu = submenu

      group = []
      [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0].each do |opacity_value|
        item = Gtk::RadioMenuItem.new(group, (opacity_value * 100).to_i.to_s + '%')
        group = item.group

        item.active = (@settings[:opacity] == opacity_value)

        # Capture opacity_value in a local variable for the closure
        value_to_apply = opacity_value
        item.signal_connect('activate') do
          next unless item.active?

          @settings[:opacity] = value_to_apply
          Gtk.queue do
            @gtk_window.set_opacity(value_to_apply)
          end
        end
        submenu.append(item)
      end

      @menu.append(menu_opacity)
    end

    # Creates the scale submenu
    # @return [void]
    def create_scale_menu
      menu_scale = Gtk::MenuItem.new(label: 'Scale')
      submenu = Gtk::Menu.new
      menu_scale.submenu = submenu

      # Global Scale checkbox at top
      global_scale_item = Gtk::CheckMenuItem.new(label: 'Global Scale')
      global_scale_item.active = @settings[:global_scale_enabled]
      global_scale_item.signal_connect('activate') do
        @settings[:global_scale_enabled] = global_scale_item.active?
        # Force map reload to apply new scale mode
        if @current_map
          temp_map = @current_map
          @current_map = nil
          change_map(temp_map)
          update_room_marker
        end
      end
      submenu.append(global_scale_item)
      submenu.append(Gtk::SeparatorMenuItem.new)

      # Scale percentage options with radio buttons
      group = []
      [0.10, 0.25, 0.33, 0.50, 0.66, 0.75, 0.90, 1.0, 1.10, 1.25, 1.33, 1.50, 1.66, 1.75, 1.90, 2.0].each do |scale_value|
        item = Gtk::RadioMenuItem.new(group, (scale_value * 100).to_i.to_s + '%')
        group = item.group

        # Show active state based on mode
        if @settings[:global_scale_enabled]
          # Global mode: show if matches global_scale
          item.active = (@settings[:global_scale] == scale_value)
        else
          # Per-map mode: show if matches current map's scale
          current_map_scale = @settings[:map_scale][@current_map] || @settings[:global_scale]
          item.active = (current_map_scale == scale_value)
        end

        # Capture scale_value for closure
        value_to_apply = scale_value
        item.signal_connect('activate') do
          next unless item.active?

          if @settings[:global_scale_enabled]
            # Global mode: set global_scale
            @settings[:global_scale] = value_to_apply
          else
            # Per-map mode: set this map's scale
            @settings[:map_scale][@current_map] = value_to_apply if @current_map
          end

          # Force map reload
          if @current_map
            temp_map = @current_map
            @current_map = nil
            change_map(temp_map)
            update_room_marker
          end
        end
        submenu.append(item)
      end

      @menu.append(menu_scale)
    end

    # Creates the map selection submenu
    # @return [void]
    def create_map_menu
      menu_maps = Gtk::MenuItem.new(label: 'Maps')
      submenu = build_map_submenu
      menu_maps.submenu = submenu
      @menu.append(menu_maps)
    end

    # Builds the hierarchical map selection menu (2 levels max)
    # @return [Gtk::Menu] The constructed menu
    def build_map_submenu
      submenu = Gtk::Menu.new
      categories = {}
      uncategorized = []
      all_maps = []

      # Group maps by their primary category
      MapData.data.values.sort_by { |m| (m[:name] || '').downcase }.each do |map_info|
        all_maps << map_info

        if map_info[:categories] && !map_info[:categories].empty?
          # Use the first category only (primary category)
          primary_category = map_info[:categories].keys.first
          categories[primary_category] ||= []
          categories[primary_category] << map_info
        else
          uncategorized << map_info
        end
      end

      # Build two-level menu: Category -> Maps
      categories.keys.sort_by(&:downcase).each do |category|
        category_item = Gtk::MenuItem.new(label: category)
        category_menu = Gtk::Menu.new

        # Sort maps within category
        categories[category].sort_by { |m| (m[:shortname] || m[:name] || '').downcase }.each do |map_info|
          map_name = map_info[:shortname] || map_info[:name] || map_info[:filename] || 'Unknown'
          map_item = Gtk::MenuItem.new(label: map_name)

          if map_info[:filename]
            map_path = File.join(@map_dir, map_info[:filename])
            map_item.signal_connect('activate') do
              Gtk.queue do
                change_map(map_path)
                update_room_marker
              end
            end
          end

          category_menu.append(map_item)
        end

        category_item.submenu = category_menu
        submenu.append(category_item)
      end

      # Add separator before "All Maps"
      unless all_maps.empty?
        submenu.append(Gtk::SeparatorMenuItem.new)

        all_maps_item = Gtk::MenuItem.new(label: 'All Maps')
        all_maps_menu = Gtk::Menu.new

        all_maps.each do |map_info|
          map_name = map_info[:shortname] || map_info[:name] || map_info[:filename] || 'Unknown'
          map_item = Gtk::MenuItem.new(label: map_name)

          if map_info[:filename]
            map_path = File.join(@map_dir, map_info[:filename])
            map_item.signal_connect('activate') do
              Gtk.queue do
                change_map(map_path)
                update_room_marker
              end
            end
          end

          all_maps_menu.append(map_item)
        end

        all_maps_item.submenu = all_maps_menu
        submenu.append(all_maps_item)
      end

      # Add "Uncategorized Maps" section at the bottom
      unless uncategorized.empty?
        submenu.append(Gtk::SeparatorMenuItem.new)

        uncategorized_item = Gtk::MenuItem.new(label: 'Uncategorized Maps')
        uncategorized_menu = Gtk::Menu.new

        uncategorized.sort_by { |m| (m[:shortname] || m[:name] || '').downcase }.each do |map_info|
          map_name = map_info[:shortname] || map_info[:name] || map_info[:filename] || 'Unknown'
          map_item = Gtk::MenuItem.new(label: map_name)

          if map_info[:filename]
            map_path = File.join(@map_dir, map_info[:filename])
            map_item.signal_connect('activate') do
              Gtk.queue do
                change_map(map_path)
                update_room_marker
              end
            end
          end

          uncategorized_menu.append(map_item)
        end

        uncategorized_item.submenu = uncategorized_menu
        submenu.append(uncategorized_item)
      end

      submenu
    end

    # Creates the tags filter submenu
    # @return [void]
    def create_tags_menu
      @menu_tags = Gtk::MenuItem.new(label: 'Tags')
      @menu.append(@menu_tags)
    end

    # Builds the tags filter menu (filtered to current map)
    # @return [Gtk::Menu] The constructed menu
    def build_tags_submenu
      submenu = Gtk::Menu.new

      # Filter rooms to current map only
      current_map_name = @current_map ? File.basename(@current_map) : nil
      rooms_on_map = if current_map_name
                       Room.list.select { |r| r.image == current_map_name }
                     else
                       Room.list
                     end

      # Safely collect and sort tags from rooms on current map
      # Exclude silver-cost and meta tags
      all_tags = rooms_on_map
                 .flat_map { |r| r.tags || [] }
                 .compact
                 .reject { |tag| tag =~ /^(silver-cost|meta:)/ }
                 .uniq
                 .sort_by(&:downcase)

      if all_tags.empty?
        no_tags = Gtk::MenuItem.new(label: '(No tags on this map)')
        no_tags.sensitive = false
        submenu.append(no_tags)
      else
        # Add Clear option at top
        clear_item = Gtk::MenuItem.new(label: 'Clear Tag Markers')
        clear_item.signal_connect('activate') { clear_tag_markers }
        submenu.append(clear_item)
        submenu.append(Gtk::SeparatorMenuItem.new)

        all_tags.each do |tag|
          item = Gtk::MenuItem.new(label: tag)
          item.signal_connect('activate') do
            rooms_with_tag = rooms_on_map.select { |r| r.tags&.include?(tag) }
            display_tag_markers(rooms_with_tag)
          end
          submenu.append(item)
        end
      end

      submenu
    end

    # Creates the locations filter submenu
    # @return [void]
    def create_locations_menu
      @menu_locations = Gtk::MenuItem.new(label: 'Locations')
      @menu.append(@menu_locations)
    end

    # Builds the locations filter menu (filtered to current map)
    # @return [Gtk::Menu] The constructed menu
    def build_locations_submenu
      submenu = Gtk::Menu.new

      # Filter rooms to current map only
      current_map_name = @current_map ? File.basename(@current_map) : nil
      rooms_on_map = if current_map_name
                       Room.list.select { |r| r.image == current_map_name }
                     else
                       Room.list
                     end

      # Filter out nil and false, ensure we have strings, then sort
      locations = rooms_on_map
                  .map(&:location)
                  .compact
                  .reject { |loc| loc == false }
                  .map(&:to_s)
                  .uniq
                  .sort_by(&:downcase)

      if locations.empty?
        no_locations = Gtk::MenuItem.new(label: '(No locations on this map)')
        no_locations.sensitive = false
        submenu.append(no_locations)
      else
        # Add Clear option at top
        clear_item = Gtk::MenuItem.new(label: 'Clear Location Markers')
        clear_item.signal_connect('activate') { clear_location_markers }
        submenu.append(clear_item)
        submenu.append(Gtk::SeparatorMenuItem.new)

        locations.each do |location|
          item = Gtk::MenuItem.new(label: location)
          item.signal_connect('activate') do
            # Compare using string representation since we converted above
            rooms_in_location = rooms_on_map.select { |r| r.location.to_s == location }
            display_location_markers(rooms_in_location)
          end
          submenu.append(item)
        end
      end

      submenu
    end

    # Rebuilds dynamic menus (tags, locations) with current map data
    # @return [void]
    def rebuild_dynamic_menus
      # Rebuild tags menu
      if @menu_tags
        @menu_tags.submenu.destroy if @menu_tags.submenu
        submenu = build_tags_submenu
        @menu_tags.submenu = submenu
        submenu.show_all
      end

      # Rebuild locations menu
      if @menu_locations
        @menu_locations.submenu.destroy if @menu_locations.submenu
        submenu = build_locations_submenu
        @menu_locations.submenu = submenu
        submenu.show_all
      end
    end

    # Creates the map display area
    # @return [void]
    def create_map_display
      @scroller = Gtk::ScrolledWindow.new
      @scroller.set_policy(
        @settings[:hide_scrollbars] ? Gtk::PolicyType::NEVER : Gtk::PolicyType::AUTOMATIC,
        @settings[:hide_scrollbars] ? Gtk::PolicyType::NEVER : Gtk::PolicyType::AUTOMATIC
      )

      @layout = Gtk::Layout.new
      @layout.can_focus = true

      # Map image
      @map_image = Gtk::Image.new
      @layout.put(@map_image, 0, 0)

      # Room marker
      @room_marker = Gtk::Image.new
      @layout.put(@room_marker, 0, 0)

      @scroller.add(@layout)
      @gtk_window.add(@scroller)
    end

    # Sets up event handlers for user interaction
    # @return [void]
    def setup_event_handlers
      # Window close event
      @gtk_window.signal_connect('delete_event') do
        respond '[map: === DELETE_EVENT HANDLER CALLED ===]' if @trouble_mode

        # Capture window geometry directly (we're already in GTK context, no need for Gtk.queue)
        window_pos = nil
        window_size = nil

        begin
          if @gtk_window && !@gtk_window.destroyed?
            window_pos = @gtk_window.position
            window_size = [@gtk_window.allocation.width, @gtk_window.allocation.height]

            if @trouble_mode
              respond '[map: === DIRECT GEOMETRY CAPTURE ===]'
              respond "[map: Captured position: #{window_pos.inspect}]"
              respond "[map: Captured size: #{window_size.inspect}]"
              respond '[map: === END DIRECT CAPTURE ===]'
            end
          end
        rescue StandardError => e
          respond "[map: Error capturing geometry in delete_event: #{e.message}]" if @trouble_mode
        end

        # Save settings with captured geometry
        save_settings(window_pos, window_size)

        respond '[map: === DELETE_EVENT HANDLER COMPLETE ===]' if @trouble_mode

        @should_exit = true

        # Return true to prevent automatic destruction - we'll handle cleanup in main loop
        true
      end

      # Mouse button press
      @layout.add_events(:button_press_mask)
      @layout.signal_connect('button_press_event') do |_widget, event|
        handle_button_press(event)
      end

      # Mouse button release
      @layout.add_events(:button_release_mask)
      @layout.signal_connect('button-release-event') do |_widget, event|
        handle_button_release(event)
      end

      # Scroll wheel with modifiers for zoom
      @layout.add_events(:scroll_mask)
      @layout.signal_connect('scroll_event') do |_widget, event|
        handle_scroll(event)
      end
    end

    # Handles mouse button press events
    # @param event [Gdk::EventButton] The button press event
    # @return [void]
    def handle_button_press(event)
      case event.button
      when 3 # Right click
        @menu.popup_at_pointer(event)
      when 1 # Left click
        start_drag(event)
      end
    end

    # Handles mouse button release events
    # @param event [Gdk::EventButton] The button release event
    # @return [void]
    def handle_button_release(event)
      return unless event.button == 1

      if @drag_state
        # Check if actual dragging occurred (threshold exceeded)
        was_dragging = @drag_state.fetch(:dragging, false)

        # End the drag (stops the thread)
        end_drag

        # Wait for thread to finish
        sleep 0.05

        # Clear drag state
        @drag_state = nil

        # Only treat as click if no dragging occurred
        unless was_dragging
          handle_click(event)
        end
      else
        # No drag state = pure click
        handle_click(event)
      end
    end

    # Handles scroll events for zoom functionality
    # @param event [Gdk::EventScroll] The scroll event
    # @return [Boolean] Whether the event was handled
    def handle_scroll(event)
      return false unless event.state.control_mask?

      # Ctrl + scroll for zoom
      case event.direction
      when Gdk::ScrollDirection::UP
        adjust_scale(1.1)
      when Gdk::ScrollDirection::DOWN
        adjust_scale(0.9)
      end

      true
    end

    # Starts a drag operation
    # @param event [Gdk::EventButton] The button press event
    # @return [void]
    def start_drag(_event)
      pointer = get_pointer_position

      # Capture drag state in local variables to prevent external modification
      start_x = pointer[0]
      start_y = pointer[1]
      start_hadj = @scroller.hadjustment.value.to_i
      start_vadj = @scroller.vadjustment.value.to_i

      # Track dragging state (local to thread)
      dragging = nil

      # Set minimal instance variable for button_release to check
      @drag_state = { dragging: false, active: true }

      # Start drag monitoring thread with captured local variables
      Thread.new do
        return unless @current_map && File.exist?(@current_map)

        # Continue while drag is active (button not released)
        while @drag_state && @drag_state[:active]
          sleep 0.05

          # Get current pointer position
          pointer = nil
          Gtk.queue { pointer = get_pointer_position }
          sleep 0.01 while pointer.nil?

          # Break if drag was ended
          break unless @drag_state && @drag_state[:active]

          # Check if drag threshold exceeded
          if dragging.nil?
            dx = (pointer[0] - start_x).abs
            dy = (pointer[1] - start_y).abs
            if dx > 10 || dy > 10
              dragging = true
              @drag_state[:dragging] = true if @drag_state
            end
          end

          # Update scroll position during drag
          if dragging
            diff_x = start_x - pointer[0]
            diff_y = start_y - pointer[1]

            new_x = start_hadj + diff_x
            new_y = start_vadj + diff_y

            if @trouble_mode
              respond "[map drag: diff=(#{diff_x},#{diff_y}) new=(#{new_x},#{new_y}) start=(#{start_hadj},#{start_vadj})]"
            end

            Gtk.queue do
              # Don't constrain to image size - let GTK handle the scroll limits naturally
              @scroller.hadjustment.value = [new_x, 0].max
              @scroller.vadjustment.value = [new_y, 0].max
            end
          end
        end
      end
    end

    # Ends a drag operation
    # @return [void]
    def end_drag
      # Signal thread to stop by marking drag as inactive
      @drag_state[:active] = false if @drag_state
    end

    # Handles a click event (when not dragging)
    # @param event [Gdk::EventButton] The button release event
    # @return [void]
    def handle_click(event)
      pointer = get_pointer_position
      map_data = @map_cache[@current_map, dark_mode: @settings[:dark_mode]]
      return unless map_data

      scale = calculate_scale(map_data)
      # Account for map offset within layout
      click_x = (@scroller.hadjustment.value.to_i + pointer[0] - @map_offset_x) / scale.to_f
      click_y = (@scroller.vadjustment.value.to_i + pointer[1] - @map_offset_y) / scale.to_f

      # Check for ctrl+shift click in fix mode
      if event.state.shift_mask? && event.state.control_mask? && @fix_mode
        handle_fix_mode_click(click_x, click_y)
      elsif event.state.control_mask?
        # Ctrl-click: show coordinates
        respond "x: #{click_x.round}, y: #{click_y.round}"
      elsif event.state.shift_mask?
        # Shift-click: show room description
        room = find_room_at(click_x, click_y)
        if room
          respond
          respond room
          respond
        else
          respond '[map: no matching room found]'
        end
      else
        # Regular click: navigate or follow link
        if (link = find_link_at(@current_map, click_x, click_y))
          change_map(link[:target_map])
          Gtk.queue do
            scale = calculate_scale(@map_cache[@current_map, dark_mode: @settings[:dark_mode]])
            # Account for map offset when positioning after link navigation
            @scroller.hadjustment.value = (link[:target_x].to_i * scale) + @map_offset_x
            @scroller.vadjustment.value = (link[:target_y].to_i * scale) + @map_offset_y
          end
        elsif (room = find_room_at(click_x, click_y))
          start_script('go2', [room.id.to_s, '_disable_confirm_'])
        else
          respond '[map: no matching room found]'
        end
      end
    end

    # Handles fix mode clicks for setting room coordinates
    # @param click_x [Float] X coordinate of click
    # @param click_y [Float] Y coordinate of click
    # @return [void]
    def handle_fix_mode_click(click_x, click_y)
      map_name = File.basename(@current_map)

      if @fix_click.nil?
        # First click - store corner
        @fix_click = [click_x, click_y]
        respond "[map fix: First corner set at (#{click_x.round}, #{click_y.round}). Click second corner.]"
      else
        # Second click - calculate room position
        x = ((click_x + @fix_click[0]) / 2).round
        y = ((click_y + @fix_click[1]) / 2).round
        size = ((([click_x, @fix_click[0]].max - [click_x, @fix_click[0]].min) +
                 ([click_y, @fix_click[1]].max - [click_y, @fix_click[1]].min)) / 2).round

        current_room = @fake_room || Room.current
        respond "#{current_room.id}; x: #{x}, y: #{y}, size: #{size}"

        current_room.image = map_name
        current_room.image_coords = [
          [@fix_click[0].round, click_x.round].min,
          [@fix_click[1].round, click_y.round].min,
          [@fix_click[0].round, click_x.round].max,
          [@fix_click[1].round, click_y.round].max
        ]

        @fix_click = nil
        respond "[map fix: Room coordinates set.]"
      end
    end

    # Adjusts the current map scale using ctrl+scroll
    # @param factor [Float] Scale adjustment factor (e.g., 1.1 for 10% increase)
    # @return [void]
    def adjust_scale(factor)
      return unless @current_map

      if @settings[:global_scale_enabled]
        # Global mode: adjust global_scale
        @settings[:global_scale] *= factor
        @settings[:global_scale] = [[@settings[:global_scale], 0.1].max, 10.0].min
      else
        # Per-map mode: adjust this map's scale
        current_scale = @settings[:map_scale][@current_map] || @settings[:global_scale]
        new_scale = current_scale * factor
        new_scale = [[new_scale, 0.1].max, 10.0].min
        @settings[:map_scale][@current_map] = new_scale
      end

      # Force map reload
      temp_map = @current_map
      @current_map = nil
      change_map(temp_map)
      update_room_marker
    end

    # Gets the current pointer position relative to the layout
    # @return [Array<Integer>] Pointer position [x, y]
    def get_pointer_position
      return [0, 0] unless @layout.window

      pointer = @layout.window.pointer
      [pointer[1], pointer[2]] # Returns [x, y]
    rescue StandardError => e
      respond "[map: Error getting pointer position: #{e.message}]" if @trouble_mode
      [0, 0]
    end

    # Finds a room at the given coordinates
    # @param x [Float] X coordinate on the map
    # @param y [Float] Y coordinate on the map
    # @return [Room, nil] The room at these coordinates or nil
    def find_room_at(x, y)
      return nil unless @current_map

      current_map_name = File.basename(@current_map)

      Room.list.find do |room|
        next unless room.image
        next unless room.image == current_map_name

        coords = extract_room_coordinates(room)
        next unless coords

        x1, y1, x2, y2 = coords
        x.between?(x1, x2) && y.between?(y1, y2)
      end
    end

    # Finds a map link at the given coordinates
    # @param map_path [String] Current map file path
    # @param x [Float] X coordinate on the map
    # @param y [Float] Y coordinate on the map
    # @return [Hash, nil] Link data with :target_map, :target_x, :target_y
    def find_link_at(map_path, x, y)
      map_name = File.basename(map_path)

      MapData::MAP_LINKS.each do |link|
        next unless link[0] == map_name
        next unless x.between?(link[1], link[2]) && y.between?(link[3], link[4])

        return {
          target_map: File.join(@map_dir, link[5]),
          target_x: link[6],
          target_y: link[7]
        }
      end

      nil
    end

    # Updates the map display with new map data
    # @param map_data [Hash] Map data from cache
    # @return [void]
    def update_map_display(map_data)
      return unless map_data

      begin
        scale = calculate_scale(map_data)
        scaled_width = (map_data[:width] * scale).to_i
        scaled_height = (map_data[:height] * scale).to_i

        # Ensure minimum size
        scaled_width = [scaled_width, 1].max
        scaled_height = [scaled_height, 1].max

        scaled_pixbuf = map_data[:pixbuf].scale_simple(
          scaled_width,
          scaled_height,
          GdkPixbuf::InterpType::BILINEAR
        )

        # Layout size and offset depend on expanded_canvas setting
        if @settings[:expanded_canvas]
          # Make layout 200% of image size to allow dragging in all directions
          layout_width = (scaled_width * 2).to_i
          layout_height = (scaled_height * 2).to_i

          # Center the image within the layout
          @map_offset_x = (layout_width - scaled_width) / 2
          @map_offset_y = (layout_height - scaled_height) / 2
        else
          # Legacy mode: layout matches image size exactly
          layout_width = scaled_width
          layout_height = scaled_height
          @map_offset_x = 0
          @map_offset_y = 0
        end

        Gtk.queue do
          @map_image.pixbuf = scaled_pixbuf
          @layout.set_size(layout_width, layout_height)
          @layout.move(@map_image, @map_offset_x, @map_offset_y)

          # Center the viewport on the map image (only if expanded canvas is enabled)
          # Calculate center point of the image within the layout
          if @settings[:expanded_canvas]
            center_x = @map_offset_x + (scaled_width / 2)
            center_y = @map_offset_y + (scaled_height / 2)

            # Only center if this is a new map or if keep_centered is disabled
            # (if keep_centered is enabled, the room marker display will handle centering)
            unless @settings[:keep_centered]
              # Wait a moment for the layout to be realized with new size
              GLib::Timeout.add(50) do
                begin
                  center_viewport_on(center_x, center_y)
                rescue StandardError
                  # Ignore if window is being destroyed
                end
                false # Don't repeat
              end
            end
          end
        end
      rescue StandardError => e
        respond "[map: Error updating map display: #{e.message}]"
      end
    end

    # Calculates the effective scale for a map
    # @param map_data [Hash] Map data with :width and :height
    # @return [Float] The calculated scale factor
    def calculate_scale(map_data)
      return 1.0 unless map_data

      if @settings[:global_scale_enabled]
        # Global scale mode - use global_scale for all maps
        @settings[:global_scale]
      else
        # Per-map scale mode - use this map's scale or fall back to global
        @settings[:map_scale][@current_map] || @settings[:global_scale]
      end
    end

    # Extracts room coordinates from room data
    # @param room [Room] The room to extract coordinates from
    # @return [Array<Integer>, nil] Coordinates [x1, y1, x2, y2] or nil
    def extract_room_coordinates(room)
      return nil unless room

      if defined?(room.image_coords) && room.image_coords
        room.image_coords
      elsif room.respond_to?(:map_x) && room.map_x && room.respond_to?(:map_y) && room.map_y
        size = room.respond_to?(:map_roomsize) && room.map_roomsize ? room.map_roomsize : 5
        [
          room.map_x - size,
          room.map_y - size,
          room.map_x + size,
          room.map_y + size
        ]
      end
    end

    # Displays the room marker at given coordinates
    # @param x1 [Integer] Left X coordinate
    # @param y1 [Integer] Top Y coordinate
    # @param x2 [Integer] Right X coordinate
    # @param y2 [Integer] Bottom Y coordinate
    # @return [void]
    def display_room_marker(x1, y1, x2, y2)
      map_data = @map_cache[@current_map, dark_mode: @settings[:dark_mode]]
      return unless map_data

      scale = calculate_scale(map_data)

      if @settings[:dynamic_indicator_size]
        # Dynamic sizing based on room coordinates and scale
        # Calculate base marker size
        base_width = (x2 - x1) * scale
        base_height = (y2 - y1) * scale

        # Increased boost for better visibility at small scales
        # At 100% scale: 1.0x boost, at 50% scale: 3.0x boost, at 25% scale: 5.0x boost
        if scale < 1.0
          size_boost = 1.0 + ((1.0 - scale) * 4.0) # Linear boost from 1.0 to 5.0
        else
          size_boost = 1.0
        end

        marker_width = (base_width * size_boost).to_i
        marker_height = (base_height * size_boost).to_i

        # Position adjusted for center (since we're making it bigger)
        center_offset_x = ((marker_width - base_width) / 2).to_i
        center_offset_y = ((marker_height - base_height) / 2).to_i

        marker_x = (x1 * scale).to_i - center_offset_x + @map_offset_x
        marker_y = (y1 * scale).to_i - center_offset_y + @map_offset_y
      else
        # Fixed size indicator (original behavior): 58x58 pixels
        marker_width = 58
        marker_height = 58

        # Center the fixed-size marker on the room coordinates
        room_center_x = ((x1 + x2) / 2.0 * scale).to_i
        room_center_y = ((y1 + y2) / 2.0 * scale).to_i

        marker_x = room_center_x - (marker_width / 2) + @map_offset_x
        marker_y = room_center_y - (marker_height / 2) + @map_offset_y
      end

      # Create a circular marker
      create_room_marker(marker_width, marker_height)

      Gtk.queue do
        @layout.move(@room_marker, marker_x, marker_y)
        @room_marker.show

        # Center viewport on the marker if keep_centered is enabled
        # BUT not if user just manually scrolled (via drag) within last 2 seconds
        if @settings[:keep_centered]
          time_since_scroll = @last_user_scroll ? (Time.now - @last_user_scroll) : Float::INFINITY

          if time_since_scroll > 2.0
            center_x = marker_x + (marker_width / 2)
            center_y = marker_y + (marker_height / 2)
            center_viewport_on(center_x, center_y)
          end
        end
      end
    end

    # Centers the viewport on the given coordinates
    # @param x [Integer] X coordinate to center on
    # @param y [Integer] Y coordinate to center on
    # @return [void]
    def center_viewport_on(x, y)
      return unless @scroller

      viewport_width = @scroller.allocation.width
      viewport_height = @scroller.allocation.height

      # Calculate the scroll position to center the point
      target_x = x - (viewport_width / 2)
      target_y = y - (viewport_height / 2)

      # Clamp to valid scroll range
      max_x = [@scroller.hadjustment.upper - @scroller.hadjustment.page_size, 0].max
      max_y = [@scroller.vadjustment.upper - @scroller.vadjustment.page_size, 0].max

      target_x = [[target_x, 0].max, max_x].min
      target_y = [[target_y, 0].max, max_y].min

      @scroller.hadjustment.value = target_x
      @scroller.vadjustment.value = target_y
    end

    # Creates the room marker image as a hollow red circle
    # Uses the original embedded PNG for correct color display
    # @param width [Integer] Marker width
    # @param height [Integer] Marker height
    # @return [void]
    def create_room_marker(width, height)
      begin
        # Ensure minimum size
        width = [width, 10].max
        height = [height, 10].max

        # Create a surface for drawing
        surface = Cairo::ImageSurface.new(Cairo::FORMAT_ARGB32, width, height)
        context = Cairo::Context.new(surface)

        # Calculate circle parameters
        center_x = width / 2.0
        center_y = height / 2.0
        radius = [width, height].min / 2.0

        # Line width scales with size but has min/max bounds
        line_width = [[radius * 0.2, 2].max, 8].min

        # Draw the hollow circle (stroke only, no fill)
        # Note: System uses BGR byte order, so swap R and B
        context.set_source_rgba(0.0, 0.0, 1.0, 0.8) # BGR: Blue value in R channel = Red display
        context.set_line_width(line_width)
        context.arc(center_x, center_y, radius - line_width / 2, 0, 2 * Math::PI)
        context.stroke

        # Convert surface to pixbuf
        pixbuf = GdkPixbuf::Pixbuf.new(
          data: surface.data,
          colorspace: GdkPixbuf::Colorspace::RGB,
          has_alpha: true,
          bits_per_sample: 8,
          width: width,
          height: height,
          rowstride: surface.stride
        )

        @room_marker.pixbuf = pixbuf
      rescue StandardError => e
        respond "[map: Error creating room marker: #{e.message}]" if @trouble_mode
      end
    end

    # Hides the room marker
    # @return [void]
    def hide_room_marker
      Gtk.queue { @room_marker.hide }
    end

    # Prompts user to find a specific room
    # @return [void]
    def prompt_find_room
      dialog = Gtk::Dialog.new(
        title: 'Find Room',
        parent: @gtk_window,
        flags: :modal,
        buttons: [
          [Gtk::Stock::OK, Gtk::ResponseType::OK],
          [Gtk::Stock::CANCEL, Gtk::ResponseType::CANCEL]
        ]
      )

      entry = Gtk::Entry.new
      dialog.content_area.add(entry)
      dialog.show_all

      if dialog.run == Gtk::ResponseType::OK
        search_text = entry.text

        begin
          room = Room[search_text]
        rescue StandardError => e
          respond "[map: Error searching for room: #{e.message}]"
          room = nil
        end

        if room && room.image
          @fake_room = room
          @follow_mode = false
          @temp_follow_disabled = true # Mark as temporary, don't save this state
          @menu_follow.active = false

          map_path = File.join(@map_dir, room.image)
          Gtk.queue do
            change_map(map_path)
            update_room_marker(room)
          end
        else
          msg_dialog = Gtk::MessageDialog.new(
            parent: @gtk_window,
            flags: :modal,
            type: :info,
            buttons: :ok,
            message: room ? 'Room has no map image' : 'Room not found'
          )
          msg_dialog.run
          msg_dialog.destroy
        end
      end

      dialog.destroy
    end

    # Creates an X marker image
    # @param width [Integer] Marker width
    # @param height [Integer] Marker height
    # @param color [Array<Float>] RGB color values (e.g., [0, 0, 1] for blue)
    # @return [GdkPixbuf::Pixbuf] The X marker pixbuf
    def create_x_marker(width, height, color)
      # Ensure minimum size
      width = [width, 10].max
      height = [height, 10].max

      # Create a surface for drawing
      surface = Cairo::ImageSurface.new(Cairo::FORMAT_ARGB32, width, height)
      context = Cairo::Context.new(surface)

      # Set color with opacity
      # Note: System uses BGR byte order, so swap R and B channels
      # For blue display, set R channel to 1.0
      context.set_source_rgba(color[2], color[1], color[0], 0.8)
      context.set_line_width(2)

      # Draw X (two diagonal lines)
      context.move_to(0, 0)
      context.line_to(width, height)
      context.stroke

      context.move_to(width, 0)
      context.line_to(0, height)
      context.stroke

      # Convert surface to pixbuf
      GdkPixbuf::Pixbuf.new(
        data: surface.data,
        colorspace: GdkPixbuf::Colorspace::RGB,
        has_alpha: true,
        bits_per_sample: 8,
        width: width,
        height: height,
        rowstride: surface.stride
      )
    end

    # Displays blue X markers for rooms with selected tag
    # @param rooms [Array<Room>] Rooms to mark
    # @return [void]
    def display_tag_markers(rooms)
      clear_tag_markers

      map_data = @map_cache[@current_map, dark_mode: @settings[:dark_mode]]
      return unless map_data

      scale = calculate_scale(map_data)

      rooms.each do |room|
        coords = extract_room_coordinates(room)
        next unless coords

        x1, y1, x2, y2 = coords
        marker_x = (x1 * scale).to_i + @map_offset_x
        marker_y = (y1 * scale).to_i + @map_offset_y
        marker_width = ((x2 - x1) * scale).to_i
        marker_height = ((y2 - y1) * scale).to_i

        # Create blue X marker
        pixbuf = create_x_marker(marker_width, marker_height, [0, 0, 1]) # Blue
        marker = Gtk::Image.new(pixbuf: pixbuf)

        Gtk.queue do
          @layout.put(marker, marker_x, marker_y)
          marker.show
          @tag_markers << marker
        end
      end
    end

    # Clears all tag markers
    # @return [void]
    def clear_tag_markers
      Gtk.queue do
        @tag_markers.each do |marker|
          @layout.remove(marker) if marker && !marker.destroyed?
        end
        @tag_markers.clear
      end
    end

    # Displays green X markers for rooms with selected location
    # @param rooms [Array<Room>] Rooms to mark
    # @return [void]
    def display_location_markers(rooms)
      clear_location_markers

      map_data = @map_cache[@current_map, dark_mode: @settings[:dark_mode]]
      return unless map_data

      scale = calculate_scale(map_data)

      rooms.each do |room|
        coords = extract_room_coordinates(room)
        next unless coords

        x1, y1, x2, y2 = coords
        marker_x = (x1 * scale).to_i + @map_offset_x
        marker_y = (y1 * scale).to_i + @map_offset_y
        marker_width = ((x2 - x1) * scale).to_i
        marker_height = ((y2 - y1) * scale).to_i

        # Create green X marker
        pixbuf = create_x_marker(marker_width, marker_height, [0, 1, 0]) # Green
        marker = Gtk::Image.new(pixbuf: pixbuf)

        Gtk.queue do
          @layout.put(marker, marker_x, marker_y)
          marker.show
          @location_markers << marker
        end
      end
    end

    # Clears all location markers
    # @return [void]
    def clear_location_markers
      Gtk.queue do
        @location_markers.each do |marker|
          @layout.remove(marker) if marker && !marker.destroyed?
        end
        @location_markers.clear
      end
    end

    # Displays a list of rooms in a dialog
    # @param rooms [Array<Room>] Rooms to display
    # @param title [String] Dialog title
    # @return [void]
    def display_room_list(rooms, title)
      dialog = Gtk::Dialog.new(
        title: title,
        parent: @gtk_window,
        flags: :modal,
        buttons: [[Gtk::Stock::OK, Gtk::ResponseType::OK]]
      )

      dialog.set_default_size(400, 300)

      scrolled = Gtk::ScrolledWindow.new
      scrolled.set_policy(Gtk::PolicyType::AUTOMATIC, Gtk::PolicyType::AUTOMATIC)

      text_view = Gtk::TextView.new
      text_view.editable = false
      text_view.cursor_visible = false

      buffer = text_view.buffer
      rooms.sort_by(&:id).each do |room|
        room_title = room.title&.first || 'Unknown'
        buffer.insert(buffer.end_iter, "#{room.id}: #{room_title}\n")
      end

      scrolled.add(text_view)
      dialog.content_area.add(scrolled)
      dialog.show_all

      dialog.run
      dialog.destroy
    end

    # Updates scrollbar visibility based on settings
    # @return [void]
    def update_scrollbar_visibility
      policy = @settings[:hide_scrollbars] ? Gtk::PolicyType::NEVER : Gtk::PolicyType::AUTOMATIC
      Gtk.queue { @scroller.set_policy(policy, policy) }
    end

    # Applies current settings to the window
    #
    # Updates window properties like keep_above, opacity, borders, and scrollbars.
    # On macOS and native Windows, X11-specific features (UTILITY hint, stick) are
    # skipped as they can cause compatibility issues with their respective backends.
    #
    # @note Platform-Specific Behavior
    #   - **macOS**: Skips UTILITY hint and stick (Quartz backend incompatibility)
    #   - **Native Windows**: Skips UTILITY hint and stick (Windows backend, ensures taskbar)
    #   - **Linux/WSL+X11**: Uses all X11 features (better window manager integration)
    #
    # @return [void]
    def apply_window_settings
      Gtk.queue do
        # Apply keep_above setting (window stays on top in z-order)
        @gtk_window.keep_above = @settings[:keep_above]
        # Note: We don't call stick here. keep_above (z-order) and stick (workspace behavior)
        # are separate concepts and should not be linked. Users can manually unstick via
        # window manager if they want single-workspace behavior.

        @gtk_window.opacity = @settings[:opacity]
        @gtk_window.decorated = !@settings[:borderless]
      end
      update_scrollbar_visibility
    end

    # Positions the window on screen
    # @return [void]
    def position_window
      # Get display geometry
      display = Gdk::Display.default
      geometry = display.default_screen.get_monitor_geometry(
        display.default_screen.get_monitor_at_point(
          @char_settings[:window_position][0],
          @char_settings[:window_position][1]
        )
      )

      monitor_x = geometry.x || 0
      monitor_y = geometry.y || 0
      monitor_width = geometry.width || 0
      monitor_height = geometry.height || 0

      # Ensure window fits on screen
      x = [[monitor_x, @char_settings[:window_position][0]].max,
           monitor_x + monitor_width - @char_settings[:window_width]].min
      y = [[monitor_y, @char_settings[:window_position][1]].max,
           monitor_y + monitor_height - @char_settings[:window_height]].min

      # macOS requires extra offset for menu bar
      y += 32 if IS_MACOS

      @gtk_window.move(x, y)

      # Trouble mode debug output
      if @trouble_mode
        respond
        respond "[map: window_width: #{@char_settings[:window_width].inspect}]"
        respond "[map: window_height: #{@char_settings[:window_height].inspect}]"
        respond "[map: window_position: #{@char_settings[:window_position].inspect}]"
        respond "[map: window.allocation.width: #{@gtk_window.allocation.width.inspect}]"
        respond "[map: window.allocation.height: #{@gtk_window.allocation.height.inspect}]"
        respond "[map: window.position: #{@gtk_window.position.inspect}]"
        respond "[map: calculated position: [#{x}, #{y}]]"
        respond
      end
    end
  end

  # Main entry point for the script
  #
  # Creates the window, handles initial room display, waits for window readiness,
  # and enters the main event loop to track room changes.
  #
  # @note Platform-Specific Window Readiness
  #   - **MacOS**: Uses a fixed 0.3s delay as GTK's `visible?` method doesn't
  #     reliably report window visibility on the Quartz backend.
  #   - **Linux/Windows**: Waits for `visible?` to return true with a 3-second
  #     timeout to prevent infinite hangs.
  #
  # @param script [Script] The running script instance
  # @return [void]
  def self.run(script)
    begin
      # Handle reset command before creating window
      if script.vars[1] =~ /^reset$/i
        Window.reset_all_settings
        respond '[map: Please restart the script for changes to take effect]'
        return
      end

      # Determine which room to display
      display_room = determine_display_room(script)

      # Create and show window
      window = Window.new(script, MAP_DIR)

      # Store window reference for before_dying cleanup
      ElanthiaMap.current_window = window

      # Handle initial room display if specified
      if display_room
        window.follow_mode = false
        window.temp_follow_disabled = true # Mark as temporary, don't save this state
        if display_room.image
          map_path = File.join(MAP_DIR, display_room.image)
          Gtk.queue do
            window.change_map(map_path)
            window.update_room_marker(display_room)
          end
        end
      end

      Gtk.queue { window.show }

      # Wait for window to be ready (with timeout for MacOS compatibility)
      # On MacOS, GTK windows may not report visible? correctly, so use a fixed delay
      # On Linux, wait for visibility with timeout to prevent infinite hangs
      if IS_MACOS
        # On MacOS, give the window a moment to show but don't wait for visible flag
        sleep 0.3
      else
        # On Linux, wait for visibility with timeout
        timeout = 30 # 3 seconds (30 * 0.1s)
        sleep 0.1 while !window.gtk_window.visible? && timeout > 0 && (timeout -= 1)
      end

      # Main loop: track room changes
      until window.should_exit
        if window.follow_mode
          current_room = Room.current
          if current_room&.image
            map_path = File.join(MAP_DIR, current_room.image)
            Gtk.queue do
              window.change_map(map_path) unless window.current_map == map_path
              window.update_room_marker(current_room)
            end
          else
            # Hide marker if room has no map
            Gtk.queue { window.update_room_marker(nil) }
          end
        end

        # Wait for room change
        room_count = $room_count
        sleep 0.2 while room_count == $room_count && !window.should_exit
        sleep 0.1 while !window.follow_mode && !window.should_exit
      end

      # Clean up - capture and save settings before destroying window
      # Note: When closing via GUI (clicking X), geometry is already saved in delete_event handler
      # This path handles script kills or programmatic exits
      respond '[map: === NORMAL EXIT CLEANUP ===]' if window.trouble_mode
      window_pos, window_size = window.capture_window_geometry
      window.save_settings(window_pos, window_size)
      respond '[map: === NORMAL EXIT CLEANUP COMPLETE ===]' if window.trouble_mode

      # Now destroy the window
      window.destroy
      ElanthiaMap.current_window = nil
    rescue StandardError => e
      respond "[map: Fatal error: #{e.class}: #{e.message}]"
      respond "[map: Backtrace: #{e.backtrace.first(5).join("\n")}]"
      ElanthiaMap.current_window = nil
      raise
    end
  end

  # Determines which room to display based on script arguments
  #
  # @param script [Script] The running script instance
  # @return [Room, nil] The room to display, or nil for normal operation
  def self.determine_display_room(script)
    return nil unless script.vars[1]
    return nil if script.vars[1] =~ /^(help|fix|trouble|reset)$/

    # Try to find room by ID or description
    search_term = script.vars[1..-1].join(' ')
    begin
      Room[search_term]
    rescue StandardError => e
      respond "[map: Error finding room '#{search_term}': #{e.message}]"
      nil
    end
  end
end

# Register cleanup handler for when script is killed
before_dying {
  if ElanthiaMap.current_window
    begin
      window = ElanthiaMap.current_window
      respond '[map: === BEFORE_DYING CLEANUP ===]' if window.trouble_mode

      # Capture window geometry using helper method (DRY)
      window_pos, window_size = window.capture_window_geometry

      # Save settings
      window.save_settings(window_pos, window_size)

      respond '[map: === BEFORE_DYING CLEANUP COMPLETE ===]' if window.trouble_mode

      # Destroy the window using existing cleanup method
      window.destroy
    rescue StandardError => e
      respond "[map: Error during cleanup: #{e.message}]" rescue nil
    end

    ElanthiaMap.current_window = nil
  end
}

# Run the script
ElanthiaMap.run(Script.current)
