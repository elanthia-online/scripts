=begin
map - Elanthia Online's fork of LostRanger's narost fork.
Tracks your current room on visual maps

  Key differences between this and ;narost:
    * map has a better-organized map list with submenus, and uses 'proper' map names instead of filenames.
    * map sorts the list of tags.

  click on a room to go there
  shift-click on a room to show its description
  right-click for some options

      author: elanthia-online
      contributors: LostRanger, Tillmen, Eleazzar
      game: Gemstone
      tags: core, movement, mapping
      required: Lich > 5.0.1
      version: 1.4.0

  changelog:
    v1.4.0 (2025-07-04)
      * Add Locations drop down (similar to tags)
    v1.3.10 (2025-05-29)
      * Fix for missing dark maps causing GTK errors and DR not having any dark maps
    v1.3.9 (2025-05-10)
      * Fix for default geometry and primary display saved settings forcing window back to primary monitor
      * Correct MapData variable return to be class variable instead of instance variable
    v1.3.8 (2025-04-20)
      * Fix for initial default window position for tiling window managers that do not set monitor geometry
    v1.3.7 (2025-04-15)
      * Fix reset and initial default value/position of window to primary monitor location
    v1.3.6 (2025-03-06)
      * Bugfix for toggling dark mode when no map available for current room in mapdb
    v1.3.5 (2025-02-23)
      * Add opacity setting to reset option
    v1.3.4 (2024-08-23)
      * Bugfix on Find Room loading map file
    v1.3.3 (2024-08-09)
      * Update Settings to save location / size parameters per character
    v1.3.2 (2024-07-12)
      * Additional fixes for WSL and responsiveness
    v1.3.1 (2024-06-29)
      * fix popup menu crash under WSL
      * fix pointer click offset issues in WSL
    v1.3.0 (2024-06-26)
      * add runtime toggle for opacity (ala orbuculum)
      * add runtime toggle for borderless window and no scrollbar window (also orbuculum)
    v1.2.0 (2024-05-19)
      * fix crash when closing window after opening context menu
      * add runtime togglable 'dark mode'
      * added spacer to keep window position on Mac OS
    v1.1.2 (2024-04-30)
      * update to use File.join where appropriate
      * change to use MAP_DIR instead of LICH_DIR+'maps' folder.
      * change to use lich constants instead of global vars
    v1.1.1 (2024-02-27)
      * fix to unhide circle when doing a 'find room' search
    v1.1.0 (2023-12-15)
      * add RESET option to set all Settings back to default
    v1.0.0 (2023-08-18)
      * initial release and forking from xnarost v1.0.3
=end
=begin
Previous xnarost release notes
    version 1.0.3 [2023-01-23]
     * Update for Ruby v3 compatibility

    version 1.0.2 [2022-11-24]
     * Remove $SAFE reference

    version 1.0.1 [2022-06-15]
     * Fix for @theme_state going from on/off to true/false in newer Lich5

    version 1.0 [2021-10-30]
     * Added darkmode support for maps included in lich\maps-dark directory

    version 0.7 (2021-03-01) based on narost.lic from 2014-08-24
     * Updated menu elements to support GTK3 in Lich5.

    version 0.6
     * Metadata is no longer built-in to xnarost but is now instead set on rooms in the mapdb.

    version 0.5.1 (2017-05-29)
     * fix some metadata errors between Solhaven/Vornavis
     * remove inadvertent debugging code left on during drag.

    version 0.5 (2017-05-29)
     * Improve ctrl+mousewheel zoom to not reset the map to the origin
     * Fix some bugs that would cause the circle image to be visible when it shouldn't be
     * Reintroduced regular scrolling with mousewheel
     * Added horizontal mousewheel scrolling with shift+mousewheel

    version 0.4 (2017-05-27)
     * Fix issue where filename comparisons were case-sensitive, causing map menu metadata to not apply correctly.
     * Fix issue where maps with no associated metadata were not properly added to the list.

    version 0.3 (2017-05-26)
     * Added most of the rest of the map metadata.  Remove the "This is experimental!" nag-message.
     * Sort the list of tags.
     * Make tag and map sorting case-insensitive.
     * Maps can now be zoomed with CTRL+Mousewheel.

    version 0.2 (2017-05-25)
     * Complete more map data.

    version 0.1 (2017-05-25) based on narost.lic from 2014-08-24
     * Improve map list organization.

=end

i_stand_alone
clear

unless HAVE_GTK
  respond
  respond 'error: ruby-gtk bindings are not installed or failed to load'
  respond
  exit
end

unless defined?(Gtk.queue)
  respond
  respond 'Your version of Lich is too old for this script.'
  respond
  exit
end

if Script.current.vars[1] == 'help'
  echo "Version: #{(Script.list.find { |x| x.name == Script.current.name }.inspect)[/version: (\d+\.\d+\.\d+)/i, 1]}                                                                              "
  echo "   ;map help                   - this output                                                "
  echo "   ;map <number>               - shows LichID# in map window instead of current room        "
  echo "   ;map u<number>              - shows RealID# in map window instead of current room        "
  echo "   ;map <text to search>       - shows room# that first matches text instead of current room"
  echo "   ;map reset                  - resets map settings to default values                      "
  echo "                                      keep_above = true                                     "
  echo "                                      global_scale = 1                                      "
  echo "                                      opacity = 1.0                                         "
  echo "                                      map_scale = none                                      "
  echo "                                      window_width = 400                                    "
  echo "                                      window_height = 300                                   "
  echo "                                      primary window_position = [0, 0]                      "
  exit
end

class MapData
  @@data = nil

  def MapData.data
    return @@data if @@data
    @@data = {}
    Room.list.each do |room|
      next unless room.image
      key = room.image
      if key =~ /^(.+)\.[^.]*$/
        key = $1
      end
      if key =~ /^(.+)-\d+$/
        key = $1
      end
      map = @@data[key]
      unless map
        @@data[key] = map = { :name => nil, :shortname => nil, :categories => {}, :filename => room.image }
      end
      next unless room.tags
      room.tags.each do |tag|
        if tag =~ /^meta:mapname:(.*)$/
          map[:name] ||= $1
        elsif tag =~ /^meta:mapshortname:(.*)$/
          map[:shortname] ||= $1
        elsif tag =~ /^meta:mapcategory:(.*?)(?::(.*))?$/
          map[:categories][$1] = $2
        end
      end
    end
    @@data.each do |key, map|
      map[:name] ||= key
      sn = (map[:shortname] ||= map[:name])
      map[:categories].keys.each { |k| map[:categories][k] ||= sn }
    end

    return @@data
  end

  def MapData.normalize_filename(filename)
    filename.gsub(/(-\d+)?\..+$/, '').downcase
  end

  def MapData.[](key)
    MapData.data[MapData.normalize_filename(key)]
  end

  def MapData.[]=(key, value)
    MapData.data[MapData.normalize_filename(key)] = value
  end

  # Links from narost.  Migrated on startup because I'm too lazy to do it right.
  [
    ['TI-teras.gif', 1962, 2238, 68, 192, 'TI-wilds.gif', 840, 1252],
    ['TI-teras.gif', 710, 972, 2130, 2260, 'WL-wehnimers.gif', 2338, 1070],
    ['TI-wilds.gif', 1124, 1412, 604, 682, 'TI-vtull.gif', 2276, 1638],
    ['TI-wilds.gif', 678, 1006, 1218, 1296, 'TI-teras.gif', 2100, 130],
    ['TI-wilds.gif', 1190, 1390, 2750, 2878, 'TI-nelemar.gif', 2794, 1670],
    ['TI-vtull.gif', 2100, 2452, 1598, 1672, 'TI-wilds.gif', 1268, 643],
    ['TI-nelemar.gif', 2704, 2882, 1598, 1724, 'TI-wilds.gif', 1290, 2814],
    ['WL-wehnimers.gif', 2188, 2494, 976, 1144, 'TI-teras.gif', 834, 2204],
    ['WL-gates.gif', 1956, 2160, 1600, 1660, 'WL-danjirland.gif', 226, 2592],
    ['WL-danjirland.gif', 96, 354, 2500, 2672, 'WL-gates.gif', 2052, 1636],
    ['EN-tavaalor.gif', 2380, 2618, 322, 446, 'EN-cemetery.gif', 350, 1906],
    ['EN-tavaalor.gif', 2348, 2618, 1794, 1912, 'EN-cemetery.gif', 170, 2178],
    ['EN-tavaalor.gif', 1058, 1362, 1802, 1920, 'EN-victory.gif', 2510, 560],
    ['EN-tavaalor.gif', 1030, 1344, 242, 364, 'EN-fearling.gif', 2158, 1946],
    ['EN-tavaalor.gif', 48, 266, 1260, 1480, 'EN-fearling.gif', 2768, 1882],
    ['EN-cemetery.gif', 230, 472, 1816, 1992, 'EN-tavaalor.gif', 2498, 374],
    ['EN-cemetery.gif', 56, 294, 2096, 2266, 'EN-tavaalor.gif', 2490, 1844],
    ['EN-victory.gif', 2360, 2656, 492, 612, 'EN-tavaalor.gif', 1210, 1850],
    ['EN-victory.gif', 1812, 2154, 688, 788, 'EN-fearling.gif', 1658, 2182],
    ['EN-victory.gif', 1494, 1840, 614, 670, 'EN-fearling.gif', 1148, 2188],
    ['EN-fearling.gif', 1986, 2324, 1876, 1998, 'EN-tavaalor.gif', 1184, 296],
    ['EN-fearling.gif', 2644, 2892, 1858, 1932, 'EN-tavaalor.gif', 162, 1378],
    ['EN-fearling.gif', 2698, 2892, 1810, 1858, 'EN-tavaalor.gif', 162, 1378],
    ['EN-fearling.gif', 990, 1316, 2132, 2238, 'EN-victory.gif', 1660, 642],
    ['EN-fearling.gif', 1570, 1742, 2120, 2242, 'EN-victory.gif', 1984, 744],
    ['EN-fearling.gif', 1214, 1500, 84, 212, 'EN-sylvarraend.gif', 2492, 2223],
    ['EN-sylvarraend.gif', 2396, 2588, 2162, 2278, 'EN-fearling.gif', 1350, 150],
    ['EN-gyldemar.gif', 2118, 2330, 1364, 1486, 'EN-old-tafaendryl.gif', 482, 2192],
    ['EN-gyldemar.gif', 2052, 2118, 1545, 1486, 'EN-old-tafaendryl.gif', 482, 2192],
    ['EN-gyldemar.gif', 84, 374, 2232, 2408, 'EN-sylvarraend.gif', 1436, 1148],
    ['EN-old-tafaendryl.gif', 372, 592, 2156, 2230, 'EN-gyldemar.gif', 2186, 1434],
    ['EN-sapphire.gif', 2636, 2944, 1870, 1992, 'EN-taillistim.gif', 246, 716],
    ['EN-sapphire.gif', 2202, 2522, 30, 150, 'EN-taillistim.gif', 2726, 2222],
    ['EN-sylvarraend.gif', 1330, 1548, 1106, 1184, 'EN-gyldemar.gif', 228, 2372],
    ['EN-sylvarraend.gif', 74, 498, 978, 1096, 'EN-sapphire.gif', 2394, 440],
    ['EN-sapphire.gif', 2270, 2524, 386, 500, 'EN-sylvarraend.gif', 282, 1046],
    ['EN-sapphire.gif', 1210, 1464, 704, 828, 'EN-skull.gif', 1332, 2808],
    ['EN-skull.gif', 1240, 1436, 2740, 2868, 'EN-sapphire.gif', 1386, 772],
    ['EN-taillistim.gif', 78, 416, 614, 866, 'EN-sapphire.gif', 2788, 1940],
    ['EN-taillistim.gif', 2552, 2900, 2154, 2270, 'EN-sapphire.gif', 2364, 100],
    ['IMT-icemule.gif', 76, 188, 1654, 1730, 'IMT-east-west-north-gates.gif', 632, 1266],
    ['IMT-icemule.gif', 1132, 1272, 564, 640, 'IMT-east-west-north-gates.gif', 2156, 2076],
    ['IMT-icemule.gif', 2214, 2320, 1482, 1560, 'IMT-east-west-north-gates.gif', 226, 2110],
    ['IMT-icemule.gif', 1136, 1270, 2750, 2826, 'IMT-south-gate.gif', 856, 1084],
    ['IMT-east-west-north-gates.gif', 580, 694, 1228, 1306, 'IMT-icemule.gif', 132, 1690],
    ['IMT-east-west-north-gates.gif', 2088, 2226, 2043, 2114, 'IMT-icemule.gif', 1198, 602],
    ['IMT-east-west-north-gates.gif', 178, 282, 2076, 2150, 'IMT-icemule.gif', 2260, 1520],
    ['IMT-east-west-north-gates.gif', 230, 478, 2196, 2260, 'IMT-south-gate.gif', 1126, 814],
    ['IMT-east-west-north-gates.gif', 390, 638, 1340, 1414, 'IMT-south-gate.gif', 694, 812],
    ['RR-riversrest.gif', 300, 544, 84, 206, 'RR-maelstrom.gif', 1946, 2668],
    ['RR-riversrest.gif', 1518, 1682, 298, 372, 'RR-citadel.gif', 1988, 1046],
    ['RR-riversrest.gif', 430, 706, 1608, 1680, 'VO-caravansary.gif', 1688, 1782],
    ['RR-maelstrom.gif', 1814, 2076, 2626, 2702, 'RR-riversrest.gif', 416, 148],
    ['RR-citadel.gif', 1868, 2138, 1010, 1082, 'RR-riversrest.gif', 1598, 336],
    ['VO-caravansary.gif', 1556, 1824, 1742, 1816, 'RR-riversrest.gif', 576, 1642],
  ].each { |link|
    map = MapData[link[0]]
    next unless map
    link[5] = MapData[link[5]]
    next unless link[5]
    map[:links] = [] unless map[:links]
    map[:links] << link[1..-1]
  }
end

def get_map_dir(dark_mode)
  if (dark_mode) && File.exist?(File.join(LICH_DIR, 'maps-dark'))
    return File.join(LICH_DIR, 'maps-dark')
  end
  return File.join(MAP_DIR)
end

trouble = script.vars.any? { |var| var =~ /trouble/i }

if Script.current.vars[1] =~ /reset/i
  Settings['keep_above'] = true
  Settings['global_scale'] = 1
  Settings['map_scale'] = Hash.new
  Settings['opacity'] = 1.0
  CharSettings['window_width'] = 400
  CharSettings['window_height'] = 300
  # Get the default display and primary monitor
  display = Gdk::Display.default
  monitor = display.primary_monitor
  # Get geometry of the primary monitor
  geometry = monitor.geometry
  monitor_x = geometry.x || 0
  monitor_y = geometry.y || 0
  monitor_width = geometry.width || 0
  monitor_height = geometry.height || 0
  # Assume window_position is an array [x, y]
  window_position = [0, 0]
  # Adjust the window position within bounds of the primary monitor
  window_position[0] = [[monitor_x, window_position[0].to_i].max, monitor_x + monitor_width - 400].min
  window_position[1] = [[monitor_y, window_position[1].to_i].max, monitor_y + monitor_height - 300].min
  CharSettings['window_position'] = window_position
  Settings['dark_mode'] = ((@theme_state || @theme_state == 'on') ? true : false)
  Settings.save
end

get_pointer = proc do |gtk_window|
  gdk_window = gtk_window.window
  pos = gdk_window.get_device_position(Gdk::Display.default.default_seat.pointer)

  next pos[1], pos[2]
end

setting_keep_above = Settings['keep_above']
setting_keep_above = true if setting_keep_above.nil?
setting_borderless = Settings['borderless']
setting_borderless = false if setting_borderless.nil?
setting_hide_scrollbars = Settings['hide_scrollbars']
setting_hide_scrollbars = false if setting_hide_scrollbars.nil?
setting_follow = nil
menu_follow = nil
Settings['theme_state'] ||= @theme_state
if Settings['theme_state'] == @theme_state
  if Settings['dark_mode'].nil?
    dark_mode = ((@theme_state || @theme_state == 'on') ? true : false)
  else
    dark_mode = Settings['dark_mode']
  end
else
  Settings['theme_state'] = @theme_state
  dark_mode = ((@theme_state || @theme_state == 'on') ? true : false)
end

window_width = CharSettings['window_width'] || Settings['window_width'] || 400
window_height = CharSettings['window_height'] || Settings['window_height'] || 300
window_position = CharSettings['window_position'] || Settings['window_position'] || [0, 0]
if trouble
  echo "CharSettings['window_width']: #{CharSettings['window_width'].inspect}"
  echo "CharSettings['window_height']: #{CharSettings['window_height'].inspect}"
  echo "CharSettings['window_position']: #{CharSettings['window_position'].inspect}"
  echo "window_width: #{window_width.inspect}"
  echo "window_height: #{window_height.inspect}"
  echo "window_position: #{window_position.inspect}"
  echo "dark_mode: #{dark_mode}"
end
global_scale = Settings['global_scale']
global_scale = 1.0 if global_scale.nil?
map_scale = Settings['map_scale'] || Hash.new
opacity = Settings['opacity'] || 1.0

$narost_maps ||= Hash.new
scale = nil
window_offset_x = 0
window_offset_y = 0
map_offset_x = nil
map_offset_y = nil
narost_exit = false
dragging = false

window_resized = true
fix_click = nil
current_room = nil
current_map = nil
short_current_map = nil
start = nil

window = nil
scroller = nil
layout = nil
image = nil
circle_width = nil
circle_height = nil
circle_image = nil
tag_img_pixbuf = nil
tag_img_width = nil
tag_img_height = nil
tag_img_list = Array.new

location_img_pixbuf = nil
location_img_width = nil
location_img_height = nil
location_img_list = Array.new
menu = nil
menu_scale_list = nil
menu_tags_list = nil
current_tag = nil
menu_locations_list = nil
current_location = nil
scale_list = [10, 25, 33, 50, 66, 75, 90, 100, 110, 125, 133, 150, 166, 175, 190, 200]
opacity_list = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
begin
  using_wsl = !File.readlines(File.join('/proc/version')).grep(/microsoft/i).empty?
rescue Errno::ENOENT
  using_wsl = false
end

map_dir = get_map_dir(dark_mode)
used_maps = Set.new
Map.list.each { |room| used_maps.add(room.map_name) unless room.map_name.nil? }
missing_maps = used_maps.find_all { |map_name| not File.exist?(File.join(map_dir, map_name)) }
echo "These map images were not found: #{missing_maps.sort.join(', ')}" unless missing_maps.empty? || (XMLData.game =~ /^DR/ && dark_mode)
# missing_maps = nil

unless File.exist?(File.join(map_dir, "circle.png"))
  File.open(File.join(map_dir, "circle.png"), 'wb') { |f| f.puts('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'.unpack('m').join('')) }
end

unless File.exist?(File.join(map_dir, "tag_img.png"))
  File.open(File.join(map_dir, "tag_img.png"), 'wb') { |f| f.puts('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'.unpack('m').join('')) }
end

location_image_file = File.join(map_dir, "location_image.png")
unless File.exist?(location_image_file)
  File.binwrite(location_image_file, "\x89PNG\r\n\x1A\n\x00\x00\x00\rIHDR\x00\x00\x00\x1D\x00\x00\x00\x1D\b\x06\x00\x00\x00V\x93g\x0F\x00\x00\x03\xD7IDATHK\xAD\x96ohNQ\x1C\xC7\xCFy\x0Ef\xF6x\xE6\xCFcF\x99\xCC\v\xA2\fC\x88\xBCP^(\xF1NY\b\xE5\x8DdbhX\ea\xC6l\xA5!)%/DJ\x96%\xBCx\xB2\x90?\x9B\x92\xD0V\xFE\xE4\xCF\f\xED\xFF\x10\xEE=\xBE\xBF{\xCF}\xDC\xFB\xDCs\xB7g\xB3[\xDF\xEE\xF3\x9Cs\xEE\xEFs\x7F\x7F\xEE9?\xCE\xF6\x85$\x93\xCC\xBE\xBE\xB3|\x96j\xD6Z\xBF\x0F\xB3z5\xFA\x7F\xB7B6\x9B\xB1P\x9D\xDB\b\xB7\xA0\xEE\xAB;\x15\xE0\xEE\x81\x01\x13\x90{\x81\x84\xE2l\x7F\x02\xD4\xF1x\xB8\xF2\xB8\xB8\x9F\x1E\x130\xE4\a\xDA\xD0\xA2\x04\xA8;\xD4\xFD\x05\x17\x03h$\x00]\xF1\x84\xA7l.B\xF0H\x9B\xB8\xEF<\x8F\x85\x8DW\xD6\\\xB2\x1E\xEB\x80n\xE3\xC2\xCC\xE50\x86\xB7b\x02\xA1\xD0\x83\x7F\xF2U\xB2\xF4\xCF-<7\x1E\x1A\n5q\xCE[\xC8\x8E\x942\x05\xB7lh\f\xF4\x86\x97\xF01\xCC\xD4\x87\xD4\xE2\x86\xCC\\;\xBC\xB6\x17\x04Nc\"t\xD7\xE3\xB1\n\xC9\x88\xA1\xD1\x8B\xAD{\x9Aobn,\xF4\x1A\xBAM&\xA0\x1Ch\x01\xF4\x8D\xC6y\xB1\x88i#f\x91l E\xCC\x86\xF6\x04V\xD3\xB1\xB5\x0F\xCA\x96d\xCF#o\x7F@5\n:\x03\xF7A\x04\xE5%\xA2\xC2\at\xF2\xE8\x02Z|\xCFB\xF2\xD8\x1A\xD5\x87\xE8\xEB\x8E\xE6K\xD1\xB4\xE8h\xAC\x88@&\xF4\x01z\x0E`I\xA0\x87\xEC\x9F\x87\xCE\x1A/\x14\xA3\xC8\x13\x85M\xF0\x83\xE2\x97\xC7\x90z\xEB\xA6m\x1Fc\x99\xE9\x99\x19\xEA\x85\e\xF8\x01\xB12\x10(\xFD@\xBF\xA76t\x14nT\x1CC\x00\xBE\xA73\xF8\xA7\xD0\xA8\x16\x82\xB19Us\xB3\xEBZ\xEA\xA7\xEB\xD6\xC8\xFD\x06\xA5\xA2\rEG\xE9\xF0\\:O'a\xC5Lh\xF2\xFB\xF6O,\xEB\xE4\x84c\xC1\xA1\xD3\xCC \"\x00n\xC5\xCCg\xE8\t\xA0o\x93\x81\x92\xA7\v\xA1yP\x86i\x9A\\\x1C\x19\xBC\xD9g\xDE\xBBy\xC6\xA7\xE5>\xE3\f\xFE\x18\xD0K\xE8\x16\xA0\x8D\xC9@)\xA7\x04^\n-\x87\xA6@\xED\xFC\x90X\xD6\x9B\xC7r\xAFq\x0Ek\xE8\x9B\xFD\x02]\x81\x1E\x02\xDA\xD1+\xD4Y\x80\xDC.\xC2\xEF\xED\xD0T\x886\x83\xDB\xFCpp\x95\xCAB\x83\nj54\x0Ez\f\x9D\x85\xDE\x03\xEA-H\f\xFArJP\x00\xA9:\t8\x1F\xA2]\xA7\x91\x1F\x11\xEB\x02=E\xA8\xB3\x86M\xBC\xFC.\xFFu\x13\xD6L\x86(\xBC\x0F\xA1\xAB\x806$\xE5)\xA0\xF4\xBDn\x80\xA8\xA8>\xF3R\xB1\xC9z0 \x8F\x8E\xD1\x15Y+N]\xCF\xBB6\x18\xFF\xD3\xA17P\r\xA0\xDE]\xAE\aO)\x8FTHQ\x00O\x04z\xA8\x99\x98\x9F\xB1\xF8\xFC\x83\x8D\xB1\xA7\x98j\x83j\x93\xAA^\x15\xDET\xDC\x87\xF1\xA3\x82\xF6T\xED%w\e[0_\xE5\x9BD4\x06\xFD\x8A\x14\xFD.j-\xA50\x03J;\x97\xE7\xF2\xE7\xB4Lm\x852\xF8\xB4\x90\xBB\x8C\e\xB0\x12\x86\xDE\x02\xBC^\xFBV]h}\"\xAA\x11\xD8\xE5m\x04\xBCP\a\xE8\xEEi\x12\xF2\b\xE0i@\xE8tq>\x8Dz^&h3\xF0_\x9D)\x00\xFF\xB0[\x1F\x17\xF8\x1FT\aL0#\v\x8C5\x18\xA2#*\xAA\xA0\xF4|\xC3\xB3\xE6g\xD59\x17f\xDD\xD1\x82;\xD0sET\xCF\xA5\xC06\xD4\x01\x06\x9C.\xB4D\xEE4\xE8,\xA5\xA3\x8C<\xA4\\\xD3\x9E:\rj\x87\xEE\xF3r\x9E\x89\x03\\\xDF\bt\x85\xF3Y\xB8#\xEE1\x8F\x03\x03\x9A(\xEB\xA5L3W\x16\xC8\x17\xF85\x12\xA2\xF3\xB3\x05\x05\xD2\xED\xF3\xEC8Z\x1F\x19\x00\xEE\x14\x00\xFF\xB6\xC0\x9CU\xA0p\x12[\fw\x1E\x01L\xCC\x896\x8C\xCE \x81Y\x00\xB8\x03\xC5\x156k9+\xD7\xB4\xA0\x8E\x01\xD5\xD3`o\xEA[\xE3\xDD\v\x98\xB3\x13\x01P\xA7\xC5\xE8+\xD0\xEDq@\x97\x89\xF0\xEA\xA0*\xA4\xFD\x05:\xE0J\x84ZS\\\x9CU*h<\x8F\x03\x04\xEC\x01\xFC\x17\xE7?X\x95\x14BJ\xB9\x00\x00\x00\x00IEND\xAEB`\x82")
end

Gtk.queue {
  _format, width, height = GdkPixbuf::Pixbuf.get_file_info(File.join(map_dir, "tag_img.png"))
  tag_img_width = width
  tag_img_height = height
  tag_img_pixbuf = GdkPixbuf::Pixbuf.new(:file => File.join(map_dir, "tag_img.png"))

  _format, width, height = GdkPixbuf::Pixbuf.get_file_info(location_image_file)
  location_img_width = width
  location_img_height = height
  location_img_pixbuf = GdkPixbuf::Pixbuf.new(:file => location_image_file)
}

show_tag = proc { |tag|
  current_tag = tag
  while (img = tag_img_list.shift)
    img.hide
    img.destroy
  end
  if tag
    # short_current_map = current_map.sub(/^.*\//, '')
    Map.list.each { |room|
      next if room.nil?
      next unless room.image == short_current_map
      next unless room.tags.include?(tag)
      img = Gtk::Image.new
      tag_img_list.push(img)
      img.set_pixbuf(tag_img_pixbuf)
      layout.put(img, (((room.image_coords[0].to_i + room.image_coords[2].to_i) / 2) * scale) - (tag_img_width / 2) + map_offset_x, (((room.image_coords[1].to_i + room.image_coords[3].to_i) / 2) * scale) - (tag_img_height / 2) + map_offset_y)
      img.show
    }
  end
}

show_location = proc { |location|
  current_location = location
  while (img = location_img_list.shift)
    img.hide
    img.destroy
  end
  if location
    Map.list.each { |room|
      next if room.nil?
      next unless room.image == short_current_map
      next if room.location.nil?
      next unless room.location == location
      img = Gtk::Image.new
      location_img_list.push(img)
      img.set_pixbuf(location_img_pixbuf)
      layout.put(img, (((room.image_coords[0].to_i + room.image_coords[2].to_i) / 2) * scale) - (location_img_width / 2) + map_offset_x, (((room.image_coords[1].to_i + room.image_coords[3].to_i) / 2) * scale) - (location_img_height / 2) + map_offset_y)
      img.show
    }
  end
}

change_map = proc { |file_name, suppress_scroll = false|
  current_map = file_name
  short_current_map = current_map.sub(/^.*\//, '')
  if dark_mode && !File.exist?(current_map) && File.exist?(File.join(MAP_DIR, File.basename(current_map)))
    current_map = File.join(MAP_DIR, File.basename(current_map))
  end
  if File.exist?(current_map)
    if global_scale
      scale = global_scale
    else
      scale = map_scale[current_map] || 1.0
    end
    menu_scale_list.children[scale_list.index((scale * 100).to_i) + 1].active = true
    unless $narost_maps[current_map] and ($narost_maps[current_map]['scale'] == scale)
      # Gtk.queue {
      $narost_maps[current_map] = Hash.new
      _format, width, height = GdkPixbuf::Pixbuf.get_file_info(current_map)
      $narost_maps[current_map]['width'] = width
      $narost_maps[current_map]['height'] = height
      $narost_maps[current_map]['scale'] = scale
      if scale == 1
        $narost_maps[current_map]['pixbuf'] = GdkPixbuf::Pixbuf.new(:file => current_map)
      else
        $narost_maps[current_map]['pixbuf'] = GdkPixbuf::Pixbuf.new(:file => current_map).scale(width * scale, height * scale)
      end
      # }
    end
    # Gtk.queue {
    image.set_pixbuf($narost_maps[current_map]['pixbuf'])
    image.set_size_request($narost_maps[current_map]['width'] * scale, $narost_maps[current_map]['height'] * scale)
    map_offset_x = scroller.allocation.width.to_i / 2
    map_offset_y = scroller.allocation.height.to_i / 2
    layout.set_size(($narost_maps[current_map]['width'] * scale) + map_offset_x * 2, ($narost_maps[current_map]['height'] * scale) + map_offset_y * 2)
    layout.move(image, map_offset_x, map_offset_y) unless suppress_scroll
    tag_list = Set.new
    short_current_map = current_map.sub(/^.*\//, '')
    Map.list.each { |room|
      next if room.nil?
      next unless room.image == short_current_map
      room.tags.each { |tag|
        tag_list.add(tag) unless tag =~ /^silver\-cost|^meta:/
      }
    }
    menu_tags_list.children.each { |child| child.destroy }
    group = Gtk::RadioMenuItem.new(nil, '(clear)')
    menu_tags_list.append(group)
    group.signal_connect('toggled') { |owner|
      Gtk.queue {
        show_tag.call(nil) if owner.active?
      }
    }
    tag_list.sort_by { |tag| tag.downcase }.each { |tag|
      menu_tag = Gtk::RadioMenuItem.new(group, tag)
      menu_tags_list.append(menu_tag)
      menu_tag.signal_connect('toggled') { |owner|
        Gtk.queue {
          if owner.active?
            show_tag.call(tag)
          end
        }
      }
      if current_tag == tag
        menu_tag.active = true
        show_tag.call(tag)
      end
    }
    menu_tags_list.show_all
    unless tag_list.include?(current_tag)
      group.active = true
      show_tag.call(nil)
    end
    location_list = Set.new
    Map.list.each { |room|
      next if room.nil?
      next unless room.image == short_current_map
      next if room.location.nil?
      location_list.add(room.location)
    }
    menu_locations_list.children.each { |child| child.destroy }
    group = Gtk::RadioMenuItem.new(nil, '(clear)')
    menu_locations_list.append(group)
    group.signal_connect('toggled') { |owner|
      Gtk.queue {
        show_location.call(nil) if owner.active?
      }
    }
    location_list.sort_by { |location| location.downcase }.each { |location|
      menu_location = Gtk::RadioMenuItem.new(group, location)
      menu_locations_list.append(menu_location)
      menu_location.signal_connect('toggled') { |owner|
        Gtk.queue {
          if owner.active?
            show_location.call(location)
          end
        }
      }
      if current_location == location
        menu_location.active = true
        show_location.call(location)
      end
    }
    menu_locations_list.show_all
    unless location_list.include?(current_location)
      group.active = true
      show_location.call(nil)
    end
  # }
  else
    echo "file not found: #{current_map}"
  end
}

change_room = proc { |suppress_scroll = false|
  if File.exist?(current_map)
    if window_resized
      window_resized = false
      # Gtk.queue {
      map_offset_x = scroller.allocation.width.to_i / 2
      map_offset_y = scroller.allocation.height.to_i / 2
      layout.set_size(($narost_maps[current_map]['width'] * scale) + (map_offset_x * 2), ($narost_maps[current_map]['height'] * scale) + (map_offset_y * 2))
      layout.move(image, map_offset_x, map_offset_y)
      if current_tag
        show_tag.call(current_tag)
      end
      if current_location
        show_location.call(current_location)
      end
      # }
    end
    # Gtk.queue {
    unless suppress_scroll
      scroller.hadjustment.value = current_room.map_x.to_i * scale
      scroller.vadjustment.value = current_room.map_y.to_i * scale
    end
    if current_room.image == short_current_map
      layout.move(circle_image, (current_room.map_x.to_i * scale) - (circle_width / 2) + map_offset_x, (current_room.map_y.to_i * scale) - (circle_height / 2) + map_offset_y)
      circle_image.show
    else
      circle_image.hide
    end
    window.title = "Map: #{Char.name} (##{current_room.id})"
    # }
  end
}

no_room = proc {
  Gtk.queue {
    circle_image.hide
    # layout.move(circle_image, -circle_width, -circle_height)
    window.title = "Map: #{Char.name}"
  }
}

def find_clicked_link(key, click_x, click_y)
  map = MapData[key]
  return unless map
  return unless map[:links]
  map[:links].each { |link|
    if (click_x > link[0]) and (click_x < link[1]) and (click_y > link[2]) and (click_y < link[3])
      return [File.join(map_dir, link[4][:filename]), link[5], link[6]]
    end
  }
  nil
end

# Gtk will segfault if we do not use the object scroller here
set_scrolling_policy = proc { |scroller|
  if setting_hide_scrollbars then
    scroller.set_policy(:never, :never)
  else
    scroller.set_policy(:automatic, :always)
  end
}

find_clicked_room = proc { |click_x, click_y|
  Map.list.find { |room|
    not room.nil? and not room.map_name.nil? and not room.map_x.nil? and not room.map_y.nil? and not room.map_roomsize.nil? and (current_map =~ /#{room.map_name}$/) and (room.map_x > click_x - (room.map_roomsize / 2)) and (room.map_x < click_x + (room.map_roomsize / 2)) and (room.map_y > click_y - (room.map_roomsize / 2)) and (room.map_y < click_y + (room.map_roomsize / 2))
  }
}

Gtk.queue {
  window = Gtk::Window.new
  window.title = "Map: #{Char.name}"
  window.set_icon(@default_icon)
  window.signal_connect('delete_event') { narost_exit = true }
  window.signal_connect("size-allocate") do
    window_resized = true
    if using_wsl
      # on windows (at least through WSL) an unaccounted for border and titlebar are included in the
      # pointer position, so we must offset by them
      frame_extents = window.window.frame_extents
      outer_width = frame_extents.width
      outer_height = frame_extents.height
      inner_width, inner_height = window.size
      window_offset_x = (outer_width - inner_width) / 2
      window_offset_y = (outer_height - inner_height) - window_offset_x
      window_offset_x *= 1 / (scale ? scale : (global_scale ? global_scale : 1.0))
      window_offset_y *= 1 / (scale ? scale : (global_scale ? global_scale : 1.0))
      # echo "outer_width: #{outer_width} outer_height: #{outer_height}"
      # echo "inner_width: #{inner_width} inner_height: #{inner_height}"
      # echo "offsetx: #{window_offset_x} offsety: #{window_offset_y}"
    end
  end
  scroller = Gtk::ScrolledWindow.new
  scroller.border_width = 0
  setting_hide_scrollbars ? scroller.set_policy(:never, :never) : scroller.set_policy(:automatic, :always)
  window.add(scroller)

  layout = Gtk::Layout.new
  scroller.add(layout)

  image = Gtk::Image.new
  layout.put(image, 0, 0)

  _format, width, height = GdkPixbuf::Pixbuf.get_file_info(File.join(map_dir, "circle.png"))
  circle_width = width
  circle_height = height
  circle_pixbuf = GdkPixbuf::Pixbuf.new(:file => File.join(map_dir, "circle.png"))
  circle_image = Gtk::Image.new
  circle_image.set_pixbuf(circle_pixbuf)
  layout.put(circle_image, -circle_width, -circle_height)

  menu_follow = Gtk::CheckMenuItem.new(:label => 'follow current room')
  menu_follow.active = true
  setting_follow = true
  menu_follow.signal_connect('toggled') { |owner| setting_follow = owner.active? }

  menu_keep_above = Gtk::CheckMenuItem.new(:label => 'keep above')
  menu_keep_above.active = setting_keep_above
  menu_keep_above.signal_connect('toggled') { |owner| setting_keep_above = window.keep_above = owner.active? }

  menu_borderless = Gtk::CheckMenuItem.new(:label => 'borderless')
  menu_borderless.active = setting_borderless
  menu_borderless.signal_connect('toggled') { |owner| window.set_decorated(!setting_borderless = owner.active?) }

  menu_hide_scrollbars = Gtk::CheckMenuItem.new(:label => 'hide scrollbars')
  menu_hide_scrollbars.active = setting_hide_scrollbars
  menu_hide_scrollbars.signal_connect('toggled') { |owner|
    setting_hide_scrollbars = owner.active?
    set_scrolling_policy.call(scroller)
  }

  menu_dark_mode = Gtk::CheckMenuItem.new(:label => 'dark mode')
  menu_dark_mode.active = dark_mode
  menu_dark_mode.signal_connect('toggled') { |owner|
    dark_mode = owner.active?
    map_dir = get_map_dir(dark_mode)
    unless current_room.map_name.nil?
      file_name = File.join(map_dir, current_room.map_name)
      Gtk.queue {
        change_map.call(file_name)
      }
    end
  }

  menu_find = Gtk::MenuItem.new(:label => 'find room')
  menu_find.signal_connect('activate') {
    Gtk.queue {
      find_window = Gtk::Window.new
      find_window.title = 'find room'
      find_entry = Gtk::Entry.new
      find_button = Gtk::Button.new('find')
      find_entry.signal_connect('activate') {
        Gtk.queue { find_button.clicked }
      }
      find_button.signal_connect('clicked') {
        Gtk.queue {
          if (room = Room[find_entry.text])
            if room.map_name
              file_name = File.join(map_dir, "#{room.map_name}")
              change_map.call(file_name) unless current_map == file_name
              if window_resized
                window_resized = false
                Gtk.queue {
                  map_offset_x = scroller.allocation.width.to_i / 2
                  map_offset_y = scroller.allocation.height.to_i / 2
                  layout.set_size(($narost_maps[current_map]['width'] * scale) + (map_offset_x * 2), ($narost_maps[current_map]['height'] * scale) + (map_offset_y * 2))
                  layout.move(image, map_offset_x, map_offset_y)
                }
              end
              Gtk.queue {
                scroller.hadjustment.value = room.map_x.to_i * scale
                scroller.vadjustment.value = room.map_y.to_i * scale
                layout.move(circle_image, (room.map_x.to_i * scale) - (circle_width / 2) + map_offset_x, (room.map_y.to_i * scale) - (circle_height / 2) + map_offset_y)
                circle_image.show
                window.title = "Map: #{Char.name} (##{room.id})"
              }
            else
              respond '[map: that room does not have an image associated with it]'
            end
          else
            respond '[map: no matching room]'
          end
          find_window.destroy
        }
      }
      find_box = Gtk::Box.new(:horizontal)
      find_box.pack_start(find_entry, false, false, 2)
      find_box.pack_start(find_button, false, false, 2)
      find_window.add(find_box)
      find_window.show_all
    }
  }

  # used_maps.each {|filename|
  #     MapData.associate(filename)
  # }
  #
  make_gtk_submenu = proc { |title|
    item = Gtk::MenuItem.new(:label => title, :use_underline => false)
    item.submenu = Gtk::Menu.new
    item
  }

  make_gtk_mapitem = proc { |mapdata, title = nil|
    title = mapdata[:shortname] unless title
    item = Gtk::MenuItem.new(:label => title, :use_underline => false)
    item.signal_connect('activate') { change_map.call(File.join(map_dir, mapdata[:filename])); no_room.call }
    item
  }

  map_submenus = {}
  map_special_submenus = { 'ALL' => make_gtk_submenu.call('All Maps') }

  # Create category menus
  for _key, data in MapData.data.sort_by { |_key, map| map[:shortname].downcase }
    next unless data[:categories].length > 0 # Only want categorized maps.
    next unless data[:filename] # Skip not-found maps
    data[:categories].each { |cat, shortname|
      map_submenus[cat] = make_gtk_submenu.call(cat) unless map_submenus[cat]
      map_submenus[cat].submenu.append(make_gtk_mapitem.call(data, shortname))
    }
  end

  # Create All/Uncategorized Menus
  for _key, data in MapData.data.sort_by { |_key, map| map[:name].downcase }
    next unless data[:filename] # Skip not-found maps
    map_special_submenus['ALL'].submenu.append(make_gtk_mapitem.call(data, data[:name]))
    next if data[:categories].length > 0 # Only want categorized maps.
    map_special_submenus['UNCATEGORIZED'] = make_gtk_submenu.call('Uncategorized Maps') unless map_special_submenus['UNCATEGORIZED']
    map_special_submenus['UNCATEGORIZED'].submenu.append(make_gtk_mapitem.call(data, data[:name]))
  end

  menu_map_list = Gtk::Menu.new
  map_submenus.sort.each { |_unused, submenu| menu_map_list.append(submenu) }
  menu_map_list.append(Gtk::SeparatorMenuItem.new)
  map_special_submenus.sort.each { |_unused, submenu| menu_map_list.append(submenu) }

  menu_view_map = Gtk::MenuItem.new(:label => 'view map')
  menu_view_map.submenu = menu_map_list

  menu_scale_list = Gtk::Menu.new
  menu_global_scale = Gtk::CheckMenuItem.new(:label => 'global setting')
  menu_global_scale.active = true if global_scale
  menu_scale_list.append(menu_global_scale)
  group = nil
  scale_list.each { |num|
    if group
      item = Gtk::RadioMenuItem.new(group, "#{num} %")
    else
      group = item = Gtk::RadioMenuItem.new(group, "#{num} %")
    end
    item.signal_connect('toggled') { |owner|
      if owner.active?
        new_scale = num / 100.0
        if new_scale != scale
          if global_scale
            global_scale = new_scale
          else
            map_scale[current_map] = new_scale
          end
          change_map.call(current_map)
          change_room.call
        end
      end
    }
    menu_scale_list.append(item)
  }
  group = nil

  menu_global_scale.signal_connect('toggled') {
    if menu_global_scale.active?
      scale_list.each_index { |index| global_scale = scale_list[index] / 100.0 if menu_scale_list.children[index + 1].active? }
    else
      global_scale = false
    end
  }

  menu_scale_map = Gtk::MenuItem.new(:label => 'scale')
  menu_scale_map.submenu = menu_scale_list

  menu_tags = Gtk::MenuItem.new(:label => 'tags')

  menu_tags_list = Gtk::Menu.new
  menu_tags.submenu = menu_tags_list

  menu_locations = Gtk::MenuItem.new(:label => 'locations')

  menu_locations_list = Gtk::Menu.new
  menu_locations.submenu = menu_locations_list

  menu_opacity_list = Gtk::Menu.new
  opacity_list.each { |num|
    if group
      item = Gtk::RadioMenuItem.new(group, "#{num} %")
    else
      group = item = Gtk::RadioMenuItem.new(group, "#{num} %")
    end
    item.signal_connect('toggled') { |owner|
      if owner.active?
        new_opacity = num / 100.0
        if new_opacity != opacity
          opacity = new_opacity
          window.opacity = opacity
        end
      end
    }
    menu_opacity_list.append(item)
  }
  menu_opacity = Gtk::MenuItem.new(label: 'opacity')
  menu_opacity.submenu = menu_opacity_list
  menu_opacity_list.children[opacity_list.index((opacity * 100).to_i)].active = true

  menu = Gtk::Menu.new
  menu.append(menu_follow)
  menu.append(menu_keep_above)
  menu.append(menu_dark_mode)
  menu.append(menu_borderless)
  menu.append(menu_hide_scrollbars)
  menu.append(menu_opacity)
  menu.append(menu_find)
  menu.append(menu_view_map)
  menu.append(menu_scale_map)
  menu.append(menu_tags)
  menu.append(menu_locations)

  menu.show_all

  def scroll_event_handler(owner, ev)
  end

  layout.signal_connect('scroll_event') { |_owner, ev|
    if ev.state == :shift_mask
      if ev.direction == :down
        ev.direction = :right
        ev.put
        true
      elsif ev.direction == :up
        ev.direction = :left
        ev.put
        true
      else
        false
      end
    # Gtk.queue {
    # Gdk::Signal.new()
    # }
    elsif ev.state == :control_mask
      if current_map
        Gtk.queue {
          # TODO: Figure out why this is not centering on the mousepointer and what's wrong with the math.
          # It's at least better than recentering to the corner though!

          window_x = (ev.x - scroller.hadjustment.value)
          window_y = (ev.y - scroller.vadjustment.value)
          old_width = layout.width.to_f
          old_height = layout.height.to_f

          echo "---"
          echo "event: #{ev.x}, #{ev.y}"
          echo "window event: #{window_x}, #{window_y}"
          echo "old width: #{layout.width}, #{layout.height}"
          if ev.direction == :down
            new_scale = scale_list[scale_list.index((scale * 100).to_i) - 1] / 100.0
          elsif ev.direction == :up
            new_scale = scale_list[scale_list.index((scale * 100).to_i) + 1] / 100.0
          end
          unless new_scale.nil?
            if global_scale
              global_scale = new_scale
            else
              map_scale[current_map] = new_scale
            end
            change_map.call(current_map, true)
            change_room.call(true)
            echo "new width: #{layout.width}, #{layout.height}"
            scale_x = layout.width.to_f / old_width
            scale_y = layout.height.to_f / old_height
            echo "scale: #{scale_x}, #{scale_y}"

            translated_x = ev.x * scale_x
            translated_y = ev.y * scale_y
            echo "tx event: #{translated_x}, #{translated_y}"

            scroller.hadjustment.value = translated_x - window_x
            scroller.vadjustment.value = translated_y - window_y
            echo scroller.hadjustment.lower
            echo scroller.hadjustment.upper
            echo scroller.hadjustment.page_size
            echo scroller.hadjustment.value
          end
        }

      end
      true
    else
      false
    end
  }
  #=end
  layout.add_events(:button_press_mask)
  layout.signal_connect('button_press_event') { |_owner, ev|
    if ev.button == 3
      # fix for Gdk error in WSL - probably GDK version related - just using the newer wrapper for popup
      menu.popup_at_pointer(ev)
    elsif ev.button == 4
      respond 'button4'
    elsif ev.button == 5
      respond 'button4'
    else
      dragging = nil
      pointer_x, pointer_y = get_pointer.call(layout.parent.parent)
      before_drag = {
        'x'    => pointer_x,
        'y'    => pointer_y,
        'hadj' => scroller.hadjustment.value.to_i,
        'vadj' => scroller.vadjustment.value.to_i
      }
      Thread.new {
        if File.exist?(current_map)
          while dragging != false
            sleep 0.1
            pointer_x = pointer_y = nil
            Gtk.queue do
              pointer_x, pointer_y = get_pointer.call(layout.parent.parent)
            end
            sleep 0.01 while pointer_y.nil?
            if dragging.nil?
              if (pointer_x < before_drag['x'] - 10) or (pointer_x > before_drag['x'] + 10) or (pointer_y < before_drag['y'] - 10) or (pointer_y > before_drag['y'] + 10)
                dragging = true
              end
            end
            if dragging
              diff_x = before_drag['x'] - pointer_x
              diff_y = before_drag['y'] - pointer_y
              Gtk.queue {
                scroller.hadjustment.value = [(before_drag['hadj'] + diff_x), ($narost_maps[current_map]['width'] * scale)].min
                scroller.vadjustment.value = [(before_drag['vadj'] + diff_y), ($narost_maps[current_map]['height'] * scale)].min
              }
            end
          end
        end
      }
    end
  }
  layout.add_events(:button_release_mask)
  layout.signal_connect('button-release-event') { |_owner, ev|
    Gtk.queue {
      if dragging
        dragging = false
      else
        dragging = false
        if (ev.event_type == Gdk::EventType::BUTTON_RELEASE) and (ev.button == 1)
          pointer_x, pointer_y = get_pointer.call(layout.parent.parent)
          click_x = ((scroller.hadjustment.value.to_i + pointer_x.to_i - map_offset_x.to_i) / scale.to_f) - window_offset_x
          click_y = ((scroller.vadjustment.value.to_i + pointer_y.to_i - map_offset_y.to_i) / scale.to_f) - window_offset_y

          # fixme: check state correctly
          if (ev.state.inspect =~ /shift-mask.*control-mask|control-mask.*shift-mask/) and (script.vars[0] =~ /fix/)
            map_name = current_map.slice(/([^\/\\]+)$/)
            if fix_click.nil?
              fix_click = [click_x, click_y]
            else
              x = ((click_x + fix_click[0]) / 2).round
              y = ((click_y + fix_click[1]) / 2).round
              size = ((([click_x, fix_click[0]].max - [click_x, fix_click[0]].min) + ([click_y, fix_click[1]].max - [click_y, fix_click[1]].min)) / 2).round
              current_room = $narost_fake_room || Room.current
              respond "#{current_room.id}; x: #{x}, y: #{y}, size: #{size}"
              if defined?(current_room.image_coords)
                current_room.image = map_name
                current_room.image_coords = [[fix_click[0].round, click_x.round].min, [fix_click[1].round, click_y.round].min, [fix_click[0].round, click_x.round].max, [fix_click[1].round, click_y.round].max]
              else
                current_room.map_name = map_name
                current_room.map_x = x
                current_room.map_y = y
                current_room.map_roomsize = size
              end
              fix_click = nil
            end
          elsif ev.state.inspect =~ /control-mask/
            respond "x: #{click_x}, y: #{click_y}"
          elsif ev.state.inspect =~ /shift-mask/
            if (clicked_room = find_clicked_room.call(click_x, click_y))
              respond
              respond clicked_room
              respond
            else
              respond '[map: no matching room found]'
            end
          else
            if (clicked_link = find_clicked_link(current_map, click_x, click_y))
              change_map.call(clicked_link[0])
              scroller.hadjustment.value = clicked_link[1].to_i * scale
              scroller.vadjustment.value = clicked_link[2].to_i * scale
            elsif (clicked_room = find_clicked_room.call(click_x, click_y))
              start_script 'go2', [clicked_room.id.to_s, '_disable_confirm_']
            else
              respond '[map: no matching room found]'
            end
          end
        end
      end
    }
  }
  setting_borderless ? window.set_decorated(false) : window.set_decorated(true)
  window.show_all

  # Get the default display and primary monitor
  display = Gdk::Display.default
  # Get geometry of the primary monitor
  geometry = display.default_screen.get_monitor_geometry(
    display.default_screen.get_monitor_at_point(window_position[0], window_position[1])
  )

  monitor_x = geometry.x || 0
  monitor_y = geometry.y || 0
  monitor_width = geometry.width || 0
  monitor_height = geometry.height || 0

  # Set window size
  window_width = [window_width, 100].max
  window_height = [window_height, 100].max
  window.resize(window_width, window_height)

  window_position[0] = [[monitor_x, window_position[0].to_i].max, monitor_x + monitor_width - window_width].min
  window_position[1] = [[monitor_y, window_position[1].to_i].max, monitor_y + monitor_height - window_height].min
  RUBY_PLATFORM =~ /darwin/ ? window_spacer = 28 : window_spacer = 0
  window.move(window_position[0], window_position[1] + window_spacer)

  if trouble
    respond
    respond "[map: window_width: #{window_width.inspect}]"
    respond "[map: window_height: #{window_height.inspect}]"
    respond "[map: window_position: #{window_position.inspect}]"
    respond "[map: window.allocation.width: #{window.allocation.width.inspect}]"
    respond "[map: window.allocation.height: #{window.allocation.height.inspect}]"
    respond "[map: window.position: #{window.position.inspect}]"
  end

  window.keep_above = true if setting_keep_above
  window.set_opacity(opacity)
  start = true
}

before_dying {
  window_position = window_width = window_height = nil
  Gtk.queue {
    window_position = window.position
    window_width = window.allocation.width
    window_height = window.allocation.height
  }
  sleep 0.01 while window_height.nil?
  Gtk.queue {
    menu.destroy
    window.destroy
  }
  CharSettings['window_position'] = window_position if (window_position.class == Array) and (window_position[0].to_i > 0) and (window_position[1].to_i > 0)
  CharSettings['window_width'] = window_width if (window_width.class == Integer) and (window_width > 100)
  CharSettings['window_height'] = window_height if (window_height.class == Integer) and (window_height > 100)
  Settings['keep_above'] = setting_keep_above
  Settings['global_scale'] = global_scale
  Settings['map_scale'] = map_scale
  Settings['dark_mode'] = dark_mode
  Settings['opacity'] = opacity
  Settings['borderless'] = setting_borderless
  Settings['hide_scrollbars'] = setting_hide_scrollbars

  Settings.save
}

wait_until { start }

if script.vars[1] and (script.vars[1] !~ /^fix|trouble$/) and (current_room = Room[script.vars[1..-1].join(' ')]) and (map_name = current_room.map_name)
  menu_follow.active = false
  setting_follow = false
  file_name = File.join(map_dir, map_name)
  Gtk.queue {
    change_map.call(file_name) unless current_map == file_name
    change_room.call
  }
  room_count = $room_count
  sleep 0.2 while (room_count == $room_count) and not narost_exit
  wait_until { setting_follow or narost_exit } unless setting_follow or narost_exit
end

until narost_exit
  if (current_room = Room.current) and (map_name = current_room.map_name)
    file_name = File.join(map_dir, map_name)
    Gtk.queue {
      change_map.call(file_name) unless current_map == file_name
      change_room.call
    }
  else
    no_room.call
  end
  room_count = $room_count
  sleep 0.2 while (room_count == $room_count) and not narost_exit
  wait_until { setting_follow or narost_exit } unless setting_follow or narost_exit
end
