=begin

  This script exists to backup several primary files used by Lich.

    Usage: ;jbackup help

  Future improvements:
    * Upload backups to remote sources via FTP, SFTP, etc.

        author: elanthia-online
  contributors: Jahadeem, Tysong
          tags: backup, back up, lich, files, copy
          game: all
      required: Lich >= 5.0.0
       version: 1.0.0

  Improvements:
  Major_change.feature_addition.bugfix
    1.0.0 (2025-01-17)
      - Complete refactor following Ruby best practices
      - Added YAML configuration support
      - Implemented automatic backup retention management
      - Added configurable backup frequency
      - Improved module/class architecture
      - Added YARD documentation
      - Enhanced error handling
      - Ruby 2.6+ compatibility
    0.2.3 (2023-03-15)
      - Rubocop cleanup
      - Fix unnecessary creation of backup folders when running add, remove, init, list, reset, help commands
    0.2.2 (2023-01-23)
      - Update for Ruby v3 compatibility
    0.2.1 (2019-09-30)
      - Fixed bug where not running init caused no backups.
      - Changed all output to catch and output all at once at script exit.
    0.2.0 (2019-09-30)
      - Backups made with this version on will be put in a jbackup folder under your lich folder.
      - Inside folders will be date and time coded with the associated backup date and time.
    0.1.1 (2019-09-19)
      - Bug fixes.
    0.1.0 (2019-09-19)
      - Changed invdb.lic detection to Scripts.exists?
      - Added ability to add, remove, & list files to backup.
    0.0.4 (2019-09-18)
      - Added detection for invdb.lic to backup inv.db3
    0.0.3 (2019-09-16)
      - Added safe script trust information.
      - Prepended all output with script name.
    0.0.2 (2019-09-15)
      - QOL updates
    0.0.1 (2019-09-14)
      - Initial Version

=end

require 'fileutils'
require 'yaml'
require 'time'

# JBackup module for managing Lich file backups
module JBackup
  VERSION = '0.3.0'

  # Default configuration values
  DEFAULT_CONFIG = {
    'files'          => %w[
      data/entry.dat
      data/entry.yaml
      data/lich.db3
      data/alias.db3
      data/inv.db3
      data/ledger.db3
      data/jbackup.yaml
    ],
    'frequency'      => 'daily',
    'retention_days' => 14
  }.freeze

  # Configuration manager for backup settings
  class Configuration
    attr_reader :files, :frequency, :retention_days, :config_path

    # Initialize configuration
    #
    # @param data_dir [String] Path to the data directory
    def initialize(data_dir)
      @config_path = File.join(data_dir, 'jbackup.yaml')
      load_configuration
    end

    # Add a file to the backup list
    #
    # @param file [String] File path relative to LICH_DIR
    # @return [Boolean] true if added successfully
    def add_file(file)
      return false if @files.include?(file)

      @files << file
      save_configuration
      true
    end

    # Remove a file from the backup list
    #
    # @param file [String] File path or pattern to remove
    # @return [Boolean] true if removed successfully
    def remove_file(file)
      removed = @files.reject! { |f| f.include?(file) }
      save_configuration if removed
      !removed.nil?
    end

    # Reset configuration to defaults
    #
    # @return [Boolean] true if reset successfully
    def reset
      @files = DEFAULT_CONFIG['files'].dup
      @frequency = DEFAULT_CONFIG['frequency']
      @retention_days = DEFAULT_CONFIG['retention_days']
      save_configuration
      true
    end

    # Check if backup should run based on frequency
    #
    # @param last_backup_time [Time, nil] Time of last backup
    # @return [Boolean] true if backup should run
    def should_backup?(last_backup_time)
      return true if last_backup_time.nil?

      case @frequency.downcase
      when 'daily'
        Time.now - last_backup_time >= 86_400
      when 'weekly'
        Time.now - last_backup_time >= 604_800
      when 'monthly'
        Time.now - last_backup_time >= 2_592_000
      else
        # Default to daily if unknown frequency
        Time.now - last_backup_time >= 86_400
      end
    end

    private

    # Load configuration from YAML file
    def load_configuration
      if File.exist?(@config_path)
        config = YAML.load_file(@config_path)
        @files = config['files'] || DEFAULT_CONFIG['files'].dup
        @frequency = config['frequency'] || DEFAULT_CONFIG['frequency']
        @retention_days = config['retention_days'] || DEFAULT_CONFIG['retention_days']
      else
        @files = DEFAULT_CONFIG['files'].dup
        @frequency = DEFAULT_CONFIG['frequency']
        @retention_days = DEFAULT_CONFIG['retention_days']
        save_configuration
      end
    rescue StandardError
      @files = DEFAULT_CONFIG['files'].dup
      @frequency = DEFAULT_CONFIG['frequency']
      @retention_days = DEFAULT_CONFIG['retention_days']
    end

    # Save configuration to YAML file
    def save_configuration
      config = {
        'files'          => @files,
        'frequency'      => @frequency,
        'retention_days' => @retention_days
      }

      File.write(@config_path, config.to_yaml)
    end
  end

  # Manages backup operations
  class BackupManager
    attr_reader :config, :backup_root, :output_messages

    # Initialize backup manager
    #
    # @param lich_dir [String] Path to Lich directory
    # @param data_dir [String] Path to data directory
    def initialize(lich_dir, data_dir)
      @lich_dir = lich_dir
      @data_dir = data_dir
      @backup_root = File.join(lich_dir, 'jbackup')
      @config = Configuration.new(data_dir)
      @output_messages = []
    end

    # Perform backup operation
    #
    # @param force [Boolean] force backup regardless of frequency
    # @return [Boolean] true if backup succeeded
    def perform_backup(force: false)
      unless force
        last_backup = get_last_backup_time
        unless @config.should_backup?(last_backup)
          log_message("Skipping backup (last backup: #{last_backup&.strftime('%Y-%m-%d %H:%M:%S')})")
          log_message("Frequency set to: #{@config.frequency}")
          return false
        end
      end

      ensure_backup_directory

      backup_time = Time.now.strftime('%Y%m%d-%H%M%S')
      backup_dir = File.join(@backup_root, backup_time)

      return false unless create_directory(backup_dir)

      success_count = 0
      @config.files.each do |file|
        source_path = File.join(@lich_dir, file)

        unless File.exist?(source_path)
          log_message("Skipping: #{file} (does not exist)")
          next
        end

        if backup_file(source_path, backup_dir, file)
          success_count += 1
        end
      end

      cleanup_old_backups if success_count > 0

      success_count > 0
    end

    # Get the timestamp of the most recent backup
    #
    # @return [Time, nil] time of last backup or nil if none exist
    def get_last_backup_time
      return nil unless Dir.exist?(@backup_root)

      backup_dirs = Dir.glob(File.join(@backup_root, '*'))
                       .select { |path| File.directory?(path) }
                       .map { |path| File.basename(path) }

      return nil if backup_dirs.empty?

      # Sort descending and get the most recent
      latest = backup_dirs.sort.last

      begin
        Time.strptime(latest, '%Y%m%d-%H%M%S')
      rescue ArgumentError
        nil
      end
    end

    # Clean up old backups based on retention policy
    #
    # @return [Integer] number of backups removed
    def cleanup_old_backups
      return 0 unless Dir.exist?(@backup_root)

      cutoff_time = Time.now - (@config.retention_days * 86_400)
      removed_count = 0

      Dir.glob(File.join(@backup_root, '*')).each do |backup_dir|
        next unless File.directory?(backup_dir)

        begin
          dir_name = File.basename(backup_dir)
          backup_time = Time.strptime(dir_name, '%Y%m%d-%H%M%S')

          if backup_time < cutoff_time
            FileUtils.rm_rf(backup_dir)
            log_message("Removed old backup: #{dir_name}")
            removed_count += 1
          end
        rescue ArgumentError
          # Skip directories that don't match the expected format
          next
        end
      end

      removed_count
    end

    # List current backup configuration
    #
    # @return [Array<String>] list of files to backup
    def list_files
      @config.files.dup
    end

    # Add file to backup list
    #
    # @param file [String] file path relative to LICH_DIR
    # @return [Boolean] true if added successfully
    def add_file(file)
      full_path = File.join(@lich_dir, file)

      unless File.exist?(full_path)
        log_message("ERROR: File does not exist: #{full_path}")
        return false
      end

      if @config.add_file(file)
        log_message("Added to backup list: #{file}")
        true
      else
        log_message("File already in backup list: #{file}")
        false
      end
    end

    # Remove file from backup list
    #
    # @param file [String] file path or pattern to remove
    # @return [Boolean] true if removed successfully
    def remove_file(file)
      if @config.remove_file(file)
        log_message("Removed from backup list: #{file}")
        true
      else
        log_message("File not found in backup list: #{file}")
        false
      end
    end

    # Reset configuration to defaults
    #
    # @return [Boolean] true if reset successfully
    def reset_configuration
      @config.reset
      log_message('Configuration reset to defaults')
      true
    end

    # Get formatted output messages
    #
    # @return [String] all output messages joined with newlines
    def formatted_output
      @output_messages.join("\n")
    end

    private

    # Ensure backup root directory exists
    def ensure_backup_directory
      return if Dir.exist?(@backup_root)

      if create_directory(@backup_root)
        log_message("Created backup directory: #{@backup_root}")
      else
        log_message("ERROR: Cannot create backup directory: #{@backup_root}")
      end
    end

    # Create a directory
    #
    # @param path [String] directory path
    # @return [Boolean] true if created or already exists
    def create_directory(path)
      return true if Dir.exist?(path)

      FileUtils.mkdir_p(path)
      true
    rescue StandardError => e
      log_message("ERROR: Cannot create directory #{path}: #{e.message}")
      false
    end

    # Backup a single file
    #
    # @param source [String] source file path
    # @param backup_dir [String] backup directory path
    # @param relative_path [String] relative path for organizing backup
    # @return [Boolean] true if backup succeeded
    def backup_file(source, backup_dir, relative_path)
      destination_dir = File.join(backup_dir, File.dirname(relative_path))
      create_directory(destination_dir)

      destination = File.join(backup_dir, relative_path)

      source_size = File.size(source)
      FileUtils.copy_file(source, destination)
      destination_size = File.size(destination)

      if source_size == destination_size
        log_message("Backup success: #{relative_path} (#{format_size(source_size)})")
        true
      else
        log_message("ERROR: Size mismatch for #{relative_path} (#{source_size} vs #{destination_size})")
        false
      end
    rescue StandardError => e
      log_message("ERROR: Failed to backup #{relative_path}: #{e.message}")
      false
    end

    # Format file size for display
    #
    # @param bytes [Integer] file size in bytes
    # @return [String] formatted size
    def format_size(bytes)
      if bytes < 1024
        "#{bytes} B"
      elsif bytes < 1_048_576
        "#{(bytes / 1024.0).round(2)} KB"
      else
        "#{(bytes / 1_048_576.0).round(2)} MB"
      end
    end

    # Log a message with script name prefix
    #
    # @param message [String] message to log
    def log_message(message)
      @output_messages << "[#{Script.current.name}] #{message}"
    end
  end

  # Command-line interface handler
  class CLI
    # Initialize CLI handler
    #
    # @param manager [BackupManager] backup manager instance
    # @param args [Array<String>] command-line arguments (Script.current.vars)
    def initialize(manager, args)
      @manager = manager
      @args = args
    end

    # Execute the command
    #
    # @return [String] output to display
    def execute
      # In Lich, Script.current.vars[1] is the first actual argument
      command = @args[1]&.downcase

      case command
      when 'help'
        show_help
      when 'list'
        list_files
      when 'add'
        add_file
      when 'remove'
        remove_file
      when 'reset'
        reset_configuration
      when 'cleanup'
        cleanup_backups
      when 'config'
        show_configuration
      when 'now'
        perform_backup_now
      when nil
        # No arguments - perform backup
        perform_backup
      else
        # Unknown command - show help
        show_help
      end

      @manager.formatted_output
    end

    private

    # Show help menu
    def show_help
      script_name = Script.current.name
      prefix = $clean_lich_char

      @manager.instance_variable_get(:@output_messages).concat([
                                                                 "[#{script_name}] JBackup v#{VERSION} - Automated Lich File Backup System",
                                                                 "[#{script_name}] ",
                                                                 "[#{script_name}] This script backs up important Lich files automatically.",
                                                                 "[#{script_name}] Configuration is stored in jbackup.yaml in your data directory.",
                                                                 "[#{script_name}] ",
                                                                 "[#{script_name}] Usage:",
                                                                 "[#{script_name}] ",
                                                                 "[#{script_name}]   #{prefix}#{script_name}                 Perform backup (respects frequency)",
                                                                 "[#{script_name}]   #{prefix}#{script_name} now             Force backup now (ignores frequency)",
                                                                 "[#{script_name}]   #{prefix}#{script_name} add <file>      Add file to backup list",
                                                                 "[#{script_name}]        Example: #{prefix}#{script_name} add data/custom.db3",
                                                                 "[#{script_name}]   #{prefix}#{script_name} remove <file>   Remove file from backup list",
                                                                 "[#{script_name}]        Example: #{prefix}#{script_name} remove custom.db3",
                                                                 "[#{script_name}]   #{prefix}#{script_name} list            List files in backup configuration",
                                                                 "[#{script_name}]   #{prefix}#{script_name} reset           Reset configuration to defaults",
                                                                 "[#{script_name}]   #{prefix}#{script_name} cleanup         Remove old backups per retention policy",
                                                                 "[#{script_name}]   #{prefix}#{script_name} config          Show current configuration",
                                                                 "[#{script_name}]   #{prefix}#{script_name} help            Show this help menu",
                                                                 "[#{script_name}] ",
                                                                 "[#{script_name}] Configuration (edit jbackup.yaml):",
                                                                 "[#{script_name}]   files:          List of files to backup",
                                                                 "[#{script_name}]   frequency:      Backup frequency (daily, weekly, monthly)",
                                                                 "[#{script_name}]   retention_days: Days to keep old backups (default: 14)",
                                                                 "[#{script_name}] "
                                                               ])
    end

    # List files in backup configuration
    def list_files
      files = @manager.list_files
      script_name = Script.current.name

      @manager.instance_variable_get(:@output_messages).concat([
                                                                 "[#{script_name}] Files configured for backup:",
                                                                 "[#{script_name}] "
                                                               ])

      files.each do |file|
        full_path = File.join(LICH_DIR, file)
        status = File.exist?(full_path) ? '[OK]' : '[MISSING]'
        @manager.send(:log_message, "  #{status} #{file}")
      end
    end

    # Add file to backup list
    def add_file
      file = @args[2]

      unless file
        @manager.send(:log_message, 'ERROR: No file specified')
        @manager.send(:log_message, "Usage: #{$clean_lich_char}#{Script.current.name} add <file>")
        return
      end

      @manager.add_file(file)
    end

    # Remove file from backup list
    def remove_file
      file = @args[2]

      unless file
        @manager.send(:log_message, 'ERROR: No file specified')
        @manager.send(:log_message, "Usage: #{$clean_lich_char}#{Script.current.name} remove <file>")
        return
      end

      @manager.remove_file(file)
    end

    # Reset configuration
    def reset_configuration
      @manager.reset_configuration
    end

    # Cleanup old backups
    def cleanup_backups
      count = @manager.cleanup_old_backups
      @manager.send(:log_message, "Removed #{count} old backup(s)")
    end

    # Show current configuration
    def show_configuration
      script_name = Script.current.name
      config = @manager.config

      @manager.instance_variable_get(:@output_messages).concat([
                                                                 "[#{script_name}] Current Configuration:",
                                                                 "[#{script_name}] ",
                                                                 "[#{script_name}]   Frequency:      #{config.frequency}",
                                                                 "[#{script_name}]   Retention:      #{config.retention_days} days",
                                                                 "[#{script_name}]   Config path:    #{config.config_path}",
                                                                 "[#{script_name}] ",
                                                                 "[#{script_name}]   Files configured for backup (#{config.files.length}):",
                                                                 "[#{script_name}] "
                                                               ])

      config.files.each do |file|
        full_path = File.join(LICH_DIR, file)
        status = File.exist?(full_path) ? '[OK]' : '[MISSING]'
        @manager.send(:log_message, "     #{status} #{file}")
      end

      @manager.instance_variable_get(:@output_messages) << "[#{script_name}] "
    end

    # Perform backup
    def perform_backup
      if @manager.perform_backup
        @manager.send(:log_message, 'Backup completed successfully')
      else
        @manager.send(:log_message, 'WARNING: Backup completed with errors or skipped due to frequency')
      end
    end

    # Perform forced backup now
    def perform_backup_now
      @manager.send(:log_message, 'Forcing manual backup...')
      if @manager.perform_backup(force: true)
        @manager.send(:log_message, 'Manual backup completed successfully')
      else
        @manager.send(:log_message, 'ERROR: Manual backup failed')
      end
    end
  end
end

# Main execution
begin
  manager = JBackup::BackupManager.new(LICH_DIR, DATA_DIR)
  # Note: In Lich, Script.current.vars[1] is the first actual argument
  # vars[0] is typically nil or script-related metadata
  cli = JBackup::CLI.new(manager, Script.current.vars)
  output = cli.execute

  respond output unless output.empty?
rescue StandardError => e
  respond "[#{Script.current.name}] FATAL ERROR: #{e.message}"
  respond "[#{Script.current.name}] #{e.backtrace.first}"
end

exit
