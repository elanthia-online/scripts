=begin

  this script uses the new playershop system by Naos to parse in-game shop directories 
  and generate JSON files that can be consumed by external systems.

  This script also exposes the Bodega module that other scripts may call.

  ;bodega --help is your friend
 
  Author: Ondreian
  Requirements: Ruby >= 2.3
  version: 0.1
  tags: playershops

=end
require "ostruct"
require "json"
require "fileutils"
require "benchmark"

unless Gem::Version.new(RUBY_VERSION) >= Gem::Version.new("2.3")
  fail "your ruby@#{RUBY_VERSION} is too old"
end

module Bodega
  ##
  ## contextual logging
  ##
  module Log  
    def self.out(msg, label: :debug)
      #return unless Opts.debug
      if msg.is_a?(Exception)
        msg = %{
          #{msg.message}
          #{msg.backtrace.join("\n")}
        }
      end

      _respond Preset.as(:debug, 
        _view(msg, label))
    end

    def self._view(msg, label)
      label = [Script.current.name, label].flatten.compact.join(".")
      safe = msg.inspect
      safe = safe.gsub("<", "(").gsub(">", ")") if safe.include?("<") and safe.include?(">")
      "[#{label}] #{safe}"
    end

    def self.pp(msg, label = :debug)
      respond _view(msg, label)
    end

    def self.dump(*args)
      pp *args
    end

    module Preset
      def self.as(kind, body)
        %[<preset id="#{kind}">#{body}</preset>]
      end
    end
  end
  ##
  ## minimal options parser
  ##
  module Opts
    FLAG_PREFIX    = "--"
    
    def self.parse_command(h, c)
      h[c.to_sym] = true
    end

    def self.parse_flag(h, f)
      (name, val) = f[2..-1].split("=")
      if val.nil?
        h[name.to_sym] = true
      else
        val = val.split(",")

        h[name.to_sym] = val.size == 1 ? val.first : val
      end
    end

    def self.parse(args = Script.current.vars[1..-1])        
      OpenStruct.new(**args.to_a.reduce(Hash.new) do |opts, v|
        if v.start_with?(FLAG_PREFIX)
          Opts.parse_flag(opts, v)
        else
          Opts.parse_command(opts, v)
        end
        opts
      end)
    end

    def self.method_missing(method, *args)
      parse.send(method, *args)
    end
  end
end

module Bodega
  module Messages
    TOWNS    = %r[Valid options include: (?<towns>.*?)\.]
    COMMAND  = %r[You can use the (?<command>.*?) command to browse the inventory of a particular shop.]
    NEW_ROOM = %r[^(?<room_title>.*)\s\((?<branch>\w+)\)$]
    SIGN     = %r[^Written on]
    ITEM     = %r[^(?<item_id>\d+)\)]
  end
end

module Bodega
  class Collector
    attr_reader :start, :close, :command
    def initialize(start:, close:, command:)
      @start   = start
      @close   = close
      @command = command
    end

    def blow_up(ttl)
      fail Exception, "Collector(start: #{@start}, close: #{@close}) failed to complete in #{ttl} seconds"
    end

    def compare(line, pattern)
      return line.include?(pattern) if pattern.is_a?(String)
      return pattern.match(line)    if pattern.is_a?(Regexp)
      fail "Unable to compare #{pattern.class} <=> #{line.class}"
    end

    def run(seconds = 5)
      fput @command
      result = []
      ttl    = Time.now + seconds
      while line = get
        result.push(line) if compare(line, @start) or not result.empty?
        return result     if compare(line, @close) and not result.empty?
        return blow_up(seconds) if Time.now > ttl
      end
    end
  end
end

module Bodega
  class Extractor
    def self.of(details)
      # todo: implement detail extractor
      return details
    end

    def initialize(details)
    end

    def to_h
    end
  end
end

module Bodega
  def self.fetch_towns()
    case (result = dothistimeout("shop direc", 5, Messages::TOWNS))
    when Messages::TOWNS
      result.match(Messages::TOWNS)[:towns].gsub(" and ", ", ").split(", ")
    else
      fail "unknown outcome for parsing available towns"
    end
  end

  def self.towns()
    @towns ||= fetch_towns
  end

  def self.shops(town)
    coll = Collector.new(
      command: %[shop direc #{town}],
      start:   %r[~*~ (?<title>.*?) Shops ~*~],
      close:   %[You can use the SHOP BROWSE])

    result = coll.run()

    next_command = result.last.match(Messages::COMMAND)[:command]
    
    by_shop_number = result.slice(1..-2)
      .map(&:strip).map do |row| row.split(/\s{2,}/) end # split columns
      .flatten.map do |col| col.split(") ") end          # split number/shop name

    if Opts.shop
      by_shop_number = Hash[by_shop_number.select do |id, title| title.downcase.include?(Opts.shop.downcase) end]
    end

    Bodega.scan_shops(town, Hash[by_shop_number], next_command)
  end

  def self.scan_shops(town, shops, cmd_template)
    max_shop_depth = (Opts["max-shop-depth"] || 10_000).to_i
    shops.take(max_shop_depth).map do |id, name| 
      Bodega.scan_inv(town, id, name, 
        cmd_template.gsub("{SHOP#}", id)) 
    end 
  end

  def self.scan_inv(town, id, name, cmd)
    coll = Collector.new(
      start:   %[is located in],
      close:   %[You can use the SHOP INSPECT {STOCK#}],
      command: cmd)
    
    (preamble, *inv) = coll.run()

    { preamble:  preamble,
      town:      town,
      id:        id,
      inv:       parse_inv(inv.map(&:strip)) }
  end

  def self.add_room(acc, row)
    acc.push(
      OpenStruct.new(
        row.match(Messages::NEW_ROOM).to_h.merge({items: []})))
  end

  def self.add_sign(acc, row)
    acc.last.sign ||= []
    acc.last.sign.push(row)
  end

  def self.add_item(acc, row)
    acc.last.items.push(
      row.match(Messages::ITEM)[:item_id])
  end

  def self.parse_inv(inv)
    inv.reduce([]) do |acc, row|
      # we are at the terminal line for this shop
      break acc if row.include?("SHOP INSPECT")
      Bodega.add_room(acc, row) if row.match(Messages::NEW_ROOM)
      Bodega.add_sign(acc, row) if row.match(Messages::SIGN) or not acc.last.sign.nil?
      Bodega.add_item(acc, row) if row.match(Messages::ITEM) and acc.last.sign.nil?
      acc
    end
    .map do |room| 
      max_item_depth = (Opts["max-item-depth"] || 100).to_i
      room.items = room.items.take(max_item_depth).map do |id| Bodega.scan_item(id) end
      room
    end
    .map(&:to_h)
  end

  def self.scan_item(id)
    coll = Collector.new(
      command: %[shop inspect #{id}],
      start:   %[You request a thorough inspection of],
      close:   %[You can use SHOP PURCHASE #{id} to purchase])

    details = coll.run()

    { id:      id, 
      name:    details.first.gsub("You request a thorough inspection of ", "").gsub(%r[\sfrom [A-Z].*?\.$], ""), 
      details: Extractor.of(details.slice(1..-2)) }
  end

  def self.towns_to_search()
    towns_to_search = if Opts.town.nil? then 
      towns 
    else 
      towns.select do |town| town.downcase.include?(Opts.town.downcase) end
    end
  end

  def self.benchmark()
    start = Time.now
    result = yield
    Log.out(fmt_time(Time.now - start), label: :run_time)
    return result
  end

  def self.all()   
    towns_to_search.map do |town| 
      { town: town, 
        shops: Bodega.shops(town) } 
    end
  end

  def self.fmt_time(diff)
    (h, m, s) = (diff / 60).as_time.split(":").map(&:to_i)

    h = h % 24
    d = h / 24

    fmted = []
    fmted << d.to_s.rjust(2, "0") + "d" if d > 0
    fmted << h.to_s.rjust(2, "0") + "h" if h > 0
    fmted << m.to_s.rjust(2, "0") + "m" if m > 0
    fmted << s.to_s.rjust(2, "0") + "s" if s > 0
    return fmted.join(" ")
  end

  def self.main()
    benchmark do
      towns_to_search.each do |town|
        start = Time.now
        shops = Bodega.shops(town)

        next if shops.empty?

        save(prefix: town, 
               data: { created_at: Time.now.utc,
                         run_time: fmt_time(Time.now - start),
                             town: town,
                            shops: shops})
      end
    end
  end

  def self.save(
    name: "shops.json", 
    dir: "bodega", 
    data:, 
    prefix:) 
    data   = JSON.pretty_generate(data)
    return _respond(data) if Opts["dry-run"]
    opts   = Opts.to_h
    prefix = opts.fetch(:shop, prefix).downcase.gsub("'", "").gsub(/-|\s/, "_")
    root   = Pathname.new($lich_dir) + dir
    FileUtils.mkdir_p(root)
    file = root + [prefix, name].join("_")
    file = Opts.to_h.fetch(:out, file)
    Log.out("writing >>> #{file}")
    File.open(file, 'w') {|f| f.write(data) }
  end

  def self.help_menu()
    <<~HELP_MENU 
      \n
    bodega.lic

      this script uses the new playershop system by Naos to parse in-game shop directories 
      and generate JSON files that can be consumed by external systems.

      This script also exposes the Bodega module that other scripts may call.

    options:
      --dry-run             run but print JSON to your FE                 [used primarily for testing]
      --town                index all shops in one town                   [used primarily for testing]
      --max-shop-depth      index only a certain number of shops per town [used primarily for testing]
      --max-item-depth      index only a certain number of items per shop [used primarily for testing]
      --shop                index a shop by name                          [used primarily for testing]
      --save                dump the results to the filesystem            [required in standalone mode]
      --out                 the location on the filesystem to write to    [defaults to $lich_dir/bodega/]
      \n
    HELP_MENU
  end

  if Opts.help
    respond Bodega.help_menu()
    exit
  end

  if Opts.save or Opts["dry-run"]
    Bodega.benchmark do
      Bodega.main()
    end
  end
end