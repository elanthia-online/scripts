=begin

  this script uses the new playershop system by Naos to parse in-game shop directories 
  and generate JSON files that can be consumed by external systems.

  This script also exposes the Bodega module that other scripts may call.

  ;bodega --help is your friend
 
  Author: Ondreian
  Requirements: Ruby >= 2.3
  version: 0.1
  tags: playershops

=end
require "ostruct"
require "json"
require "fileutils"
require "benchmark"

unless Gem::Version.new(RUBY_VERSION) >= Gem::Version.new("2.3")
  fail "your ruby@#{RUBY_VERSION} is too old"
end
##
## check if a String is an int
##
class String
  def is_i?
    !!(self =~ /\A[-+]?[0-9]+\z/)
  end
end
##
## polyfill for working with MatchData
##
class MatchData
  def to_struct
    OpenStruct.new to_h
  end

  def to_h
    Hash[self.names.map(&:to_sym).zip(self.captures.map(&:strip).map do |capture|  
      if capture.is_i? then capture.to_i else capture end
    end)]
  end
end

module Bodega
  ##
  ## contextual logging
  ##
  module Log  
    def self.out(msg, label: :debug)
      #return unless Opts.debug
      if msg.is_a?(Exception)
        msg = %{
          #{msg.message}
          #{msg.backtrace.join("\n")}
        }
      end

      _respond Preset.as(:debug, 
        _view(msg, label))
    end

    def self._view(msg, label)
      label = [Script.current.name, label].flatten.compact.join(".")
      safe = msg.inspect
      safe = safe.gsub("<", "(").gsub(">", ")") if safe.include?("<") and safe.include?(">")
      "[#{label}] #{safe}"
    end

    def self.pp(msg, label = :debug)
      respond _view(msg, label)
    end

    def self.dump(*args)
      pp *args
    end

    module Preset
      def self.as(kind, body)
        %[<preset id="#{kind}">#{body}</preset>]
      end
    end
  end
  ##
  ## minimal options parser
  ##
  module Opts
    FLAG_PREFIX    = "--"
    
    def self.parse_command(h, c)
      h[c.to_sym] = true
    end

    def self.parse_flag(h, f)
      (name, val) = f[2..-1].split("=")
      if val.nil?
        h[name.to_sym] = true
      else
        val = val.split(",")

        h[name.to_sym] = val.size == 1 ? val.first : val
      end
    end

    def self.parse(args = Script.current.vars[1..-1])        
      OpenStruct.new(**args.to_a.reduce(Hash.new) do |opts, v|
        if v.start_with?(FLAG_PREFIX)
          Opts.parse_flag(opts, v)
        else
          Opts.parse_command(opts, v)
        end
        opts
      end)
    end

    def self.method_missing(method, *args)
      parse.send(method, *args)
    end
  end
end

module Bodega
  module Messages
    TOWNS    = %r[Valid options include: (?<towns>.*?)\.]
    COMMAND  = %r[You can use the (?<command>.*?) command to browse the inventory of a particular shop.]
    NEW_ROOM = %r[^(?<room_title>.*)\s\((?<branch>\w+)\)$]
    SIGN     = %r[^Written on]
    ITEM     = %r[^(?<item_id>\d+)\)]
  end
end

module Bodega
  class Collector
    attr_reader :start, :close, :command
    def initialize(start:, close:, command:)
      @start   = start
      @close   = close
      @command = command
    end

    def blow_up(ttl)
      fail Exception, "Collector(start: #{@start}, close: #{@close}) failed to complete in #{ttl} seconds"
    end

    def compare(line, pattern)
      return line.include?(pattern) if pattern.is_a?(String)
      return pattern.match(line)    if pattern.is_a?(Regexp)
      fail "Unable to compare #{pattern.class} <=> #{line.class}"
    end

    def run(seconds = 5)
      fput @command
      result = []
      ttl    = Time.now + seconds
      while line = get
        result.push(line) if compare(line, @start) or not result.empty?
        return result     if compare(line, @close) and not result.empty?
        return blow_up(seconds) if Time.now > ttl
      end
    end
  end
end

module Bodega
  class Extractor
    def self.of(details)
      # todo: implement detail extractor
      return details
    end

    def initialize(details)
    end

    def to_h
    end
  end
end

module Bodega
  def self.fetch_towns()
    case (result = dothistimeout("shop direc", 5, Messages::TOWNS))
    when Messages::TOWNS
      result.match(Messages::TOWNS)[:towns].gsub(" and ", ", ").split(", ")
    else
      fail "unknown outcome for parsing available towns"
    end
  end

  def self.towns()
    @towns ||= fetch_towns
  end

  def self.shops(town)
    coll = Collector.new(
      command: %[shop direc #{town}],
      start:   %r[~*~ (?<title>.*?) Shops ~*~],
      close:   %[You can use the SHOP BROWSE])

    result = coll.run()

    next_command = result.last.match(Messages::COMMAND)[:command]
    
    by_shop_number = result.slice(1..-2)
      .map(&:strip).map do |row| row.split(/\s{2,}/) end # split columns
      .flatten.map do |col| col.split(") ") end          # split number/shop name

    if Opts.shop
      by_shop_number = Hash[by_shop_number.select do |id, title| title.downcase.include?(Opts.shop.downcase) end]
    end

    Bodega.scan_shops(town, Hash[by_shop_number], next_command)
  end

  def self.scan_shops(town, shops, cmd_template)
    max_shop_depth = (Opts["max-shop-depth"] || 10_000).to_i
    shops.take(max_shop_depth).map do |id, name| 
      Bodega.scan_inv(town, id, name, 
        cmd_template.gsub("{SHOP#}", id)) 
    end 
  end

  def self.scan_inv(town, id, name, cmd)
    coll = Collector.new(
      start:   %[is located in],
      close:   %[You can use the SHOP INSPECT {STOCK#}],
      command: cmd)
    
    (preamble, *inv) = coll.run()

    { preamble:  preamble,
      town:      town,
      id:        id,
      inv:       parse_inv(inv.map(&:strip)) }
  end

  def self.add_room(acc, row)
    acc.push(
      OpenStruct.new(
        row.match(Messages::NEW_ROOM).to_h.merge({items: []})))
  end

  def self.add_sign(acc, row)
    acc.last.sign ||= []
    acc.last.sign.push(row)
  end

  def self.add_item(acc, row)
    acc.last.items.push(
      row.match(Messages::ITEM)[:item_id])
  end

  def self.parse_inv(inv)
    inv.reduce([]) do |acc, row|
      # we are at the terminal line for this shop
      break acc if row.include?("SHOP INSPECT")
      Bodega.add_room(acc, row) if row.match(Messages::NEW_ROOM)
      Bodega.add_sign(acc, row) if row.match(Messages::SIGN) or not acc.last.sign.nil?
      Bodega.add_item(acc, row) if row.match(Messages::ITEM) and acc.last.sign.nil?
      acc
    end
    .map do |room| 
      max_item_depth = (Opts["max-item-depth"] || 100).to_i
      room.items = room.items.take(max_item_depth).map do |id| Bodega.scan_item(id) end
      room
    end
    .map(&:to_h)
  end

  def self.scan_item(id)
    coll = Collector.new(
      command: %[shop inspect #{id}],
      start:   %[You request a thorough inspection of],
      close:   %[You can use SHOP PURCHASE #{id} to purchase])

    details = coll.run()

    { id:      id, 
      name:    details.first.gsub("You request a thorough inspection of ", "").gsub(%r[\sfrom [A-Z].*?\.$], ""), 
      details: Extractor.of(details.slice(1..-2)) }
  end

  def self.towns_to_search()
    if Opts.town.nil? then 
      towns 
    else 
      towns.select do |town| town.downcase.include?(Opts.town.downcase) end
    end
  end

  def self.benchmark()
    start = Time.now
    result = yield
    Log.out(fmt_time(Time.now - start), label: :run_time)
    return result
  end

  def self.all()   
    towns_to_search.map do |town| 
      { town: town, 
        shops: Bodega.shops(town) } 
    end
  end

  def self.fmt_time(diff)
    (h, m, s) = (diff / 60).as_time.split(":").map(&:to_i)

    h = h % 24
    d = h / 24

    fmted = []
    fmted << d.to_s.rjust(2, "0") + "d" if d > 0
    fmted << h.to_s.rjust(2, "0") + "h" if h > 0
    fmted << m.to_s.rjust(2, "0") + "m" if m > 0
    fmted << s.to_s.rjust(2, "0") + "s" if s > 0
    return fmted.join(" ")
  end

  def self.main()
    benchmark do
      towns_to_search.each do |town|
        start = Time.now
        shops = Bodega.shops(town)

        next if shops.empty?

        data = { 
          created_at: Time.now.utc,
            run_time: fmt_time(Time.now - start),
                town: town,
               shops: shops,
        }

        save_json(name: town, 
                  data: data)
      end
    end
  end

  def self.save_json(
    dir: "bodega", 
    name:,
    data:) 
    data   = JSON.pretty_generate(data)
    return _respond(data) if Opts["dry-run"]
    opts   = Opts.to_h
    name   = opts.fetch(:shop, name).downcase.gsub("'", "_").gsub(/-|\s/, "_")
    root   = Pathname.new($lich_dir) + dir
    FileUtils.mkdir_p(root)
    file = root + name + ".json"
    file = Opts.to_h.fetch(:out, file)
    Log.out("writing >>> #{file}")
    File.open(file, 'w') {|f| f.write(data) }
  end

  def self.read_json(file)
    begin
      return JSON.parse(File.read(file), symbolize_names: true)
    rescue => exception
      Script.log(exception)
      Script.log(exception.backtrace)
      return {}
    end
  end

  def self.manifest(dir: "bodega", url_root: Opts["url-root"], file: nil)
    url_root or fail "--url-root is required for this operation"
    root   = $lich_dir + dir
    assets = Dir[root + "/*.json"].reject do |f| f.include?("manifest.json") end
    fail "no assets found" if assets.empty?
    root = Pathname.new(root)
    manifest = JSON.pretty_generate({ created_at: Time.now.utc}.merge({
      assets: assets.map do |asset| 
        base_name = File.basename(asset)
        asset = read_json(root + asset)
        {       url: url_root + "/" + base_name, 
           run_time: asset.fetch(:run_time, nil),
         created_at: asset.fetch(:created_at, nil),
        }
      end
    }))

    file ||= root + "manifest.json"
    Log.out("writing >>> #{file}")
    return respond(manifest) if Opts["dry-run"]
    File.open(file, "w") {|f| f.write(manifest) }
  end

  def self.help_menu()
    <<~HELP_MENU 
      \n
    bodega.lic

      this script uses the new playershop system by Naos to parse in-game shop directories 
      and generate JSON files that can be consumed by external systems.

      This script also exposes the Bodega module that other scripts may call.

    parse mode options (admins only):
      --dry-run             run but print JSON to your FE                 [used primarily for testing]
      --town                index all shops in one town                   [used primarily for testing]
      --max-shop-depth      index only a certain number of shops per town [used primarily for testing]
      --max-item-depth      index only a certain number of items per shop [used primarily for testing]
      --shop                index a shop by name                          [used primarily for testing]
      --save                dump the results to the filesystem            [required in standalone mode]
      --out                 the location on the filesystem to write to    [defaults to $lich_dir/bodega/]
      --manifest            create a manifest file of the assets

      \n
    HELP_MENU
  end

  if Opts.help
    respond Bodega.help_menu()
    exit
  end

  if Opts.parser
    Log.out(Opts.to_h)
    Bodega.main()     if Opts.save
    Bodega.manifest() if Opts.manifest
  end
end