=begin
   A script that removes status affects and combines several previous separate scripts. Will cover dispels, disarmed, and other status affects.
   Configuration can be accessed via ;ecleanse setup
        author: Deysh
  contributors: Tysong
          game: Gemstone
          tags: dispel, unpoison, undisease, disarmed, effects
       version: 1.1.0

  Improvements:
  v1.1.0  (2024-08-18)
    - refactor of the queue process to improve disarm response
    - added help section
    - updated issue_command method to mirror Lich
  v1.0.19 (2024-08-06)
    - add chaotic spatial anomaly to dispelable items (found in HW by gigas disciples)
  v1.0.18 (2024-08-04)
    - fix disarm not waiting for bonded weapon
  v1.0.17 (2024-05-01)
    - fix for Char.level -> Stats.level
    - fix for Char.prof -> Stats.prof
  v1.0.16 (2023-11-24)
    - bugfix for stun recover - check to make sure not in a belly or innards
    - added check for silvery blue globe and spiraling ghostly rift in Moonsedge
    - added check for disarm maneuver in Moonsedge and Sanctum
    - added check for Sanctum disease needing the vat
=end
=begin
  v1.0.15 (2023-08-23)
    - Bugfix for cman retreat if current target != creature that caused grounded debuff
  v1.0.14 (2023-04-13)
    - Bugfix for disarm recovery
  v1.0.13 (2023-04-06)
    - Bugfix for regex comparison of an integer in Ruby 3.2+, force convert .to_s
  v1.0.12 (2023-03-27)
    - added standing check for "channel open" casting
  v1.0.11 (2023-03-11)
    - added multiple searches for recover item
  v1.0.10 (2023-03-07)
    - removed 906 from web dispell
    - added Powersink to dispell debuffs
  v1.0.9 (2023-02-12)
    - added wound eval for spell casting
    - added a wait for spirit servants in disarm recovery
    - add some error checking to disarm recovery
  v1.0.8 (2023-02-10)
    - bug fix for incorrect method name during spirit servant recovery
  v1.0.7 (2023-02-07)
    - bug fix for web check to avoid custom disks
  v1.0.6 (2023-01-31)
    - bug fix for magical_grounded method if either option is checked
  v1.0.5 (2023-01-31)
    - bug fix for weapon disarm section
  v1.0.4 (2023-01-24)
    - bug fix in remove stuff for barkskin check
    - update 1011 casting so it doesn't repeat
    - added support for sigil of determination
  v1.0.3 (2023-01-23)
    - bug fix in recover weapon
  v1.0.2 (2023-01-22)
    - fixed regex for disarmed to not mistake hurled weapons
  v1.0.1 (2023-01-21)
    - add check for CMan.known?("Retreat") and stamina check for grounded debuff.
    - moved magical/grounded debuffs into separate method to only pause scripts if necessary
    - add Mindwipe and Pious Trial to dispellable debuffs
  v1.0.0 (2023-01-20)
    - Initial release
=end

module Ecleanse
  class << self
    attr_accessor :did_something, :data, :event_stack
  end

  @did_something = false
  @data ||= nil
  @event_stack = []

  def self.load(settings)
    Ecleanse.data = settings
  end

  def self.load_settings()
    dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
    poison = [114].map { |s| Spell[s] }.find { |s| s.known? }
    disease = [113].map { |s| Spell[s] }.find { |s| s.known? }
    webs = [209, 417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

    CharSettings['cleanse_magical'] = false unless dispel.known?
    CharSettings['cleanse_grounded'] = false unless CMan.known?("Retreat")
    CharSettings['cleanse_poison'] = false unless poison.known?
    CharSettings['cleanse_disease'] = false unless disease.known?
    CharSettings['avoid_webs'] = false unless webs.known?
    CharSettings['determination'] = false unless Society.member =~ /Guardians of Sunfist/

    settings_hash = {
      :cleanse_magical  => CharSettings['cleanse_magical'],
      :cleanse_grounded => CharSettings['cleanse_grounded'],
      :cleanse_poison   => CharSettings['cleanse_poison'],
      :cleanse_disease  => CharSettings['cleanse_disease'],
      :recover_disarmed => CharSettings['recover_disarmed'],
      :avoid_webs       => CharSettings['avoid_webs'],
      :stop_scripts     => CharSettings['stop_scripts'],
      :determination    => CharSettings['determination'],
    }

    # Lets find the containers we need
    container_match = /<a exist="([^"]+)" noun="[^"]+">[^(.]+\(([a-z]+)\)/
    container_lines = Lich::Util.quiet_command_xml("stow list", /<output class="mono"\/>/)

    sacks = {}
    container_lines.each { |line|
      if line =~ container_match
        sacks.store(Regexp.last_match(2), GameObj.inv.find { |i| i.id == Regexp.last_match(1) })
        sacks.delete(Regexp.last_match(2)) unless sacks[Regexp.last_match(2)]
      end
    }

    settings_hash[:default] = sacks["default"]

    settings_hash[:script_list] = settings_hash[:stop_scripts].split(",").map(&:strip)
    settings_hash[:script_list].tap { |list| list.push("go2") unless list.include?("go2") }

    settings_hash
  end

  def self.save_settings(settings)
    CharSettings['cleanse_magical'] = settings[:cleanse_magical]
    CharSettings['cleanse_grounded'] = settings[:cleanse_grounded]
    CharSettings['cleanse_poison'] = settings[:cleanse_poison]
    CharSettings['cleanse_disease'] = settings[:cleanse_disease]
    CharSettings['recover_disarmed'] = settings[:recover_disarmed]
    CharSettings['avoid_webs'] = settings[:avoid_webs]
    CharSettings['stop_scripts'] = settings[:stop_scripts]
    CharSettings['determination'] = settings[:determination]
  end

  class Setup < Gtk::Builder
    attr_accessor :settings

    @@categories = {
      general: {
        cleanse_magical: { default: false },
        cleanse_grounded: { default: false },
        cleanse_poison: { default: false },
        cleanse_disease: { default: false },
        recover_disarmed: { default: false },
        avoid_webs: { default: false },
        stop_scripts: { default: '' },
        script_list: { default: [] },
        determination: { default: false },
      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?

      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()
      @settings = settings

      # Get script version
      version = Util.get_script_version

      # set default values if they don't exist
      @@categories.each do |_, data|
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end
      # remove settings that don't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }
      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        # add_from_file("#{$data_dir}ecleanse.ui")
        add_from_string(Setup.ui)
        load_settings
        self['main'].keep_above = true
        self['main'].set_title "Ecleanse Setup v#{version}"
        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    def self.ui
      '<?xml version="1.0" encoding="UTF-8"?><interface><requires lib="gtk+" version="3.20"/><object class="GtkWindow" id="main"><property name="width-request">510</property><property name="height-request">292</property><property name="can-focus">False</property><property name="title" translatable="yes">Ecleanse Setup</property><property name="default-height">325</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="recover_disarmed"><property name="label" translatable="yes">Recover Disarmed Weapons</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will use 218 if active</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">6</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="cleanse_magical"><property name="label" translatable="yes">Cleanse Magical</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Attempts to cleanse - Confusion, Vertigo, Sounds, or Thought Lash using spells 417, 119, or 1218 if known</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="cleanse_poison"><property name="label" translatable="yes">Cure Poison</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses unpoison (114)</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="avoid_webs"><property name="label" translatable="yes">Attempt to dispel magic\webs</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will try to cast (209, 417, 1218, 119) if known</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">6</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="cleanse_disease"><property name="label" translatable="yes">Cure Disease</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses undisease (113)</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="cleanse_grounded"><property name="label" translatable="yes">Cleanse Grounded</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Attempts to clear Rooted or Pressed using Cman Retreat</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="determination"><property name="label" translatable="yes">Sigil of Determination</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">13</property><property name="margin-end">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Scripts to Pause</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="stop_scripts"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-bottom">5</property><property name="width-chars">59</property><property name="placeholder-text" translatable="yes">list of scripts to pause eg - bigshot,eloot,awesome_script74</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="width">2</property>
      </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Scripts</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property>
      </object><packing><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes"> Intended to be run in the background
      or as part of Bigshot\'s active hunting scripts </property><attributes><attribute name="style" value="italic"/>
      </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
      </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update
          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        elsif obj.class == Gtk::ComboBoxText
          @settings[key] = obj.active_text
        end
      end
    end

    def on_close_clicked
      Ecleanse.load(@settings)
      self['main'].destroy
    end

    def on_destroy
      Gtk.queue {
        Ecleanse.load(@settings)
        @running = false
      }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings
      Gtk.queue do
        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym
          next if (setting = Setup.get_setting(key)).nil?

          # set the default value
          poison = [114].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_poison")) && poison.nil?

          disease = [113].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_disease")) && disease.nil?

          dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_magical")) && dispel.nil?

          webs = [209, 417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("avoid_webs")) && webs.nil?

          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_grounded")) && !CMan.known?("Retreat")

          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("determination")) && Society.member !~ /Guardians of Sunfist/

          # obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("rogue_password")) && Stats.prof != "Rogue"
          # obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("use_seeking")) && Society.member !~ /Order of Voln/ && Society.rank !~ /26/

          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) }
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].strip
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::SpinButton
            obj.value = @settings[key]
            obj.adjustment.value = @settings[key]
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::ComboBoxText
            # Fixme: change to builder_name
            if @settings[key] == "Auto"
              item = 0
            elsif @settings[key] == "On"
              item = 1
            elsif @settings[key] == "Off"
              item = 2
            elsif @settings[key] == "1"
              item = 0
            elsif @settings[key] == "2"
              item = 1
            end

            obj.set_active(item) if item
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::TreeView
            if (store = self["#{key}_store"]).nil?
              respond "** failed to find store for treeview #{key}"
              next
            elsif setting[:load].nil?
              respond "** no :load defined #{key}"
              next
            end

            setting[:load].call(store, @settings[key])

            # setup the signals
            if (add = self["#{key}_add"]).nil?
              respond "** failed to find add for treeview #{key}"
              next
            elsif (delete = self["#{key}_delete"]).nil?
              respond "** failed to find delete for treeview #{key}"
              next
            elsif (entry = self["#{key}_entry"]).nil?
              respond "** failed to find entry for treeview #{key}"
              next
            end

            add.signal_connect('clicked') do
              if setting[:set].nil?
                respond "** no :set defined for #{key}"
                next
              elsif entry.text.empty?
                next
              end
              setting[:set].call(store, entry.text, @settings[key])
              setting[:load].call(store, @settings[key])
            end

            delete.signal_connect('clicked') do
              if setting[:delete].nil?
                respond "** no :delete defined for #{key}"
                next
              elsif (selected = obj.selection.selected).nil?
                next
              end
              setting[:delete].call(store, selected, @settings[key])
              setting[:load].call(store, @settings[key])
            end
          end
        end

        # checkboxes for array storage with id's <setting>:<value>
        # this is primarily used by the loot types
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)
          next unless obj.builder_name =~ /^([^:]+):(.*)$/i
          next unless obj.class == Gtk::CheckButton

          key = Regexp.last_match(1).to_sym
          value = Regexp.last_match(2).to_s
          # echo "key: #{key} value: #{value}"
          next if Setup.get_setting(key).nil?

          # echo @settings[key].include?(value)
          obj.active = @settings[key].include?(value)

          # add in hook
          obj.signal_connect('toggled') do
            @settings[key].delete(value)
            if obj.active?
              @settings[key].push(value)
              @settings[key].uniq!.sort!
            end
          end
        end
      end
    end

    def start
      @running = true
      Gtk.queue { self['main'].show_all }
      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[general internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def self.update_setting(key, value)
      setting = Setup.get_setting(key)
      echo "** Setting #{key.inspect} does not exist" if setting.nil?
      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        echo " Reset #{key}"
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          echo " #{value.inspect} removed from #{key.inspect}"
        else
          @settings[key].push(value)
          echo " #{value.inspect} added to #{key.inspect}"
        end

        echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        echo "#{key.inspect} has been set to #{value.inspect}"
        @settings[key] = value
      end
    end
  end

  module Action
    def self.avoid_webs(web)
      return unless Ecleanse.data[:avoid_webs]
      return unless Util.able_to_cast

      dispel = [209, 417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

      # Return if we don't know how to do cast those
      return if dispel.nil?

      System.scripts_pause

      Action.mana_pulse(dispel.num)

      dispel.cast("at #{web}") if dispel.affordable?
    end

    def self.avoid_globe(globe)
      return unless Ecleanse.data[:avoid_webs]
      return unless Util.able_to_cast

      dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

      # Return if we don't know how to do cast those
      return if dispel.nil?

      Action.mana_pulse(dispel.num)

      System.scripts_pause
      dispel.cast("at #{globe}") if dispel.affordable?
    end

    def self.change_stance(new_stance)
      return if Effects::Debuffs.active?("Frenzy") || dead?
      return if percentstance == new_stance
      return if new_stance == 100 && percentstance(80)

      stances = {
        0   => 'offensive',
        20  => 'advanced',
        40  => 'forward',
        60  => 'neutral',
        80  => 'guarded',
        100 => 'defensive'
      }

      if CMan.available?('Stance Perfection') && ![0, 20, 40, 60, 80, 100].include?(new_stance)
        cmd = "cman stance #{new_stance}"
      elsif stances[new_stance]
        cmd = "stance #{stances[new_stance]}"
      else
        cmd = 'stance defensive'
      end

      expiry = Time.now + 2
      while percentstance != new_stance
        res = dothistimeout(cmd, 2, /You are now|You move into|Roundtime|wait|Your rage causes you/i)
        if res =~ /Roundtime: (\d+)|wait (\d+)/i
          sleep((Regexp.last_match(1) || Regexp.last_match(2)).strip.to_f - 1)
          expiry = Time.now + 2
        elsif Time.now > expiry
          break
        else
          break
        end
        sleep 0.5
      end
    end

    def self.determination
      return unless Spell["Sigil of Determination"].known? && Spell["Sigil of Determination"].affordable?
      return if Effects::Buffs.active?("Sigil of Determination")

      System.scripts_pause
      Spell["Sigil of Determination"].cast if Spell["Sigil of Determination"].affordable?
    end

    def self.go2(place)
      fput('unhide') if (hidden? || invisible?)

      return if Room.current.id == place

      if Room.current.id.nil?
        respond "Currently in an unmapped room - Need to go to #{place}"
        return
      end

      Script.run('go2', "#{place} --disable-confirm", { quiet: true, force: true })
    end

    def self.mana_pulse(spell_id)
      return unless Spell[spell_id].known? && !Spell[spell_id].affordable?

      mana_regex = Regexp.union(
        /An invigorating rush of mana pulses through you/i,
        /You are too mentally fatigued to attempt this ability/i,
        /You're already at full mana./i,
        /Your mana control skills are not yet advanced/i,
      )

      dothistimeout "mana pulse", 2, mana_regex
      sleep 0.2
    end

    def self.recover(item, room_id, title)
      # standard disarm mechanics

      return unless Ecleanse.data[:recover_disarmed]
      System.scripts_pause

      sanct = [213, 1011].map { |s| Spell[s] }.find { |s| s.known? }

      Util.msg("yellow", " ########## DISARMED!!! ##########")
      Util.msg("yellow", " ## Room#: #{room_id}")
      Util.msg("yellow", " ## Room Name: #{title.first}")
      Util.msg("yellow", " ## Looking for: #{item}")
      Util.msg("yellow", " ########## DISARMED!!! ##########")
      UserVars.last_disarm = room_id
      Action.go2(room_id)

      Util.wait_rt

      sanct.cast if !sanct.nil? && sanct.affordable? && Util.able_to_cast
      Util.wait_rt

      if Spell[218].active?
        15.times do
          break if (GameObj.npcs.find { |npc| npc.noun =~ /spirit/i })

          sleep(0.1)
        end

        line = dothistimeout "tell servant recover", 5, /flickers for a moment and manifests|has no personal recollection/
        if line =~ /flickers for a moment and manifests/
          servant_recover = true
        else
          servant_recover = false
        end
        if servant_recover
          lines = Util.get_lines("sense", /You open your soul to the lesser/)
          if lines.any? { |l| l =~ /An obvious presence of peace saturates the area and a feeling of safety overwhelms you/ }
            fput "stop 213"
          end

          return
        end
      end

      # Make the room safer.
      Action.settle_room

      # Sometimes bigshot sneaks in an eloot
      System.scripts_pause

      # Change to defensive stance
      Action.change_stance(100)

      # It might be a bonded weapon
      if Stats.prof =~ /Warrior|Paladin/
        wait_time = Time.now + 10
        until [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item) || wait_time < Time.now
          Util.wait_rt
        end
      end

      unless [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item)
        empty_hands

        search_count = 0
        until search_count.eql?(10)

          until kneeling?
            dothistimeout("kneel", 2, /You kneel|You are already/i)
          end

          Util.wait_rt

          lines = Util.get_command("recover item", /<dialogData|You spy|You continue to intently search the area|In order to recover something|You find nothing recoverable/)

          if lines.grep(/You spy (?:an|a) (?:.*) and recover it\!/).any? || [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item)
            break
          end

          if lines.grep(/You're not in any condition to be searching around/).any?
            Util.msg("yellow", " Unable to search. Exiting ecleanse.")
            Util.msg("yellow", " #{item} is in room #{room_id}")
            fput "stand" until standing?
            System.scripts_resume
            exit
          end

          if lines.grep(/In order to recover something/).any?
            empty_hands
          end

          # Or it could be in your default container if bonded weapon returned fast enough.
          if Ecleanse.data[:default].contents.find { |thing| thing.noun =~ /#{item}/ }
            break
          end

          search_count += 1
        end

        Util.wait_rt
      end

      fput "stand" until standing?
      Util.wait_rt

      fput "stop #{sanct.num}" if !sanct.nil?
    end

    def self.remove_disease
      return unless Ecleanse.data[:cleanse_disease]
      return unless Spell[113].known? && Util.able_to_cast

      Action.mana_pulse(113)

      return unless Spell[113].affordable?

      System.scripts_pause

      until !checkdisease || !Spell[113].affordable?
        Spell[113].cast
        Util.wait_rt
      end
    end

    def self.remove_grounded
      return unless Ecleanse.data[:cleanse_grounded]
      return unless CMan.known?("Retreat")

      grounded_debuffs = ["Rooted", "Pressed"]
      grounded_debuffs.each { |debuff|
        if Effects::Debuffs.active?(debuff) && checkstamina(11)
          System.scripts_pause
          Util.wait_rt
          fput "stand" until checkstanding
          Util.wait_rt
          current_target = XMLData.current_target_id
          fput 'target clear'
          fput 'cman retreat'
          fput "target ##{current_target}"
        end
      }
    end

    def self.remove_magical
      return unless Ecleanse.data[:cleanse_magical]
      return unless Util.able_to_cast

      dispellable_debuffs = ["Confusion", "Vertigo", "Sounds", "Thought Lash", "Mindwipe", "Pious Trial", "Powersink"]
      dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

      # Return if we don't know how to do dispel
      return if dispel.nil?

      Action.mana_pulse(dispel.num)

      dispellable_debuffs.each { |debuff|
        if Effects::Debuffs.active?(debuff) and !dispel.nil?
          System.scripts_pause

          Action.mana_pulse(dispel.num)

          fput "stand" until checkstanding
          Util.wait_rt
          dispel.force_incant("channel open") if dispel.affordable?
        end
      }
    end

    def self.remove_poison
      return unless Ecleanse.data[:cleanse_poison]
      return unless Spell[114].known? && Util.able_to_cast

      Action.mana_pulse(114)

      return unless Spell[114].affordable?

      System.scripts_pause

      until !checkpoison || !Spell[114].affordable?
        Spell[114].cast
        Util.wait_rt
      end
    end

    def self.remove_stun
      return unless (Spell[1040].known? && Spell[1040].affordable?) || (CMan.known?("Berserk") && checkstamina(21)) || (CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers.to_i > 2) || (Spell[605].known? && !Effects::Cooldowns.active?("Barkskin: Commune") && !Effects::Cooldowns.active?("Barkskin") && !Spell[605].active? && Skills.slblessings >= 15)
      return if Stats.prof =~ /Ranger/i && !Util.able_to_cast

      System.scripts_pause

      if Spell[1040].known?
        Action.mana_pulse(1040)

        if Spell[1040].affordable?
          fput "shout 1040"
        end
      elsif CMan.known?("Berserk") && checkstamina(21) && checkroom("The Belly of the Beast").nil? && checkroom("Ooze, Innards").nil?
        Spell[9607].cast
        sleep 1
        wait_until { !Spell[9607].active? }
      elsif CMan.stun_maneuvers > 2 && checkroom("The Belly of the Beast").nil? && checkroom("Ooze, Innards").nil?
        Action.stunman_perform
      elsif Spell[605].known? && !Effects::Cooldowns.active?("Barkskin: Commune") && !Effects::Cooldowns.active?("Barkskin") && !Spell[605].active? && Skills.slblessings >= 15
        Action.mana_pulse(605)
        Util.wait_rt
        fput "commune barkskin" if stunned?
        sleep(2)
      end
    end

    def self.remove_web_bound
      Action.mana_pulse(1040)

      return unless (Spell[1040].known? && Spell[1040].affordable?) || (CMan.known?("Berserk") && checkstamina(21))

      System.scripts_pause

      if Spell[1040].known? and Spell[1040].affordable?
        fput "shout 1040"
      elsif CMan.known?("Berserk") && checkstamina(21)
        Spell[9607].cast
        sleep 1
        wait_until { !Spell[9607].active? }
      elsif CMan.known?("Spell Cleave") && checkstamina(10)
        fput "cman scleave"
      elsif CMan.known?("Spell Thieve") && checkstamina(10)
        fput "cman sthieve"

      end
    end

    def self.sanctum_recover(creature)
      # Unholy Quickening by Lithe Veiled Sentinels in the Sanctum

      return unless Ecleanse.data[:recover_disarmed]
      System.scripts_pause

      Util.wait_rt

      # Make the room safer.
      Action.settle_room

      # Sometimes bigshot sneaks in an eloot
      System.scripts_pause

      # Change to defensive stance
      Action.change_stance(100)

      loop do
        result = Util.get_res("clench #{creature}")
        Util.wait_rt
        break if result =~ /You reach up and grab/
      end
    end

    def self.settle_room
      return unless Util.able_to_cast

      # Fixme: add options in UI
      if !GameObj.targets.empty? && Spell[619].known? && Spell[619].affordable?
        Spell[619].cast
      elsif !GameObj.targets.any? { |c| c.name =~ /arm/ } && !GameObj.targets.empty? && Spell[709].known? && Spell[709].affordable?
        Spell[709].cast
      elsif Spell[9811].known? && !GameObj.targets.empty?
        fput "sym of sleep"
      elsif Spell[919].known? && Spell[919].affordable? && !Effects::Buffs.active?("Wizard's Shield") && !Effects::Cooldowns.active?("Wizard's Shield")
        Spell[919].cast
      elsif Spell[140].known? && Spell[140].affordable? && !Effects::Buffs.active?("Wall of Force") && !Effects::Cooldowns.active?("Wall of Force")
        Spell[140].cast
      end
    end

    def self.stunman_perform
      stun_maneuvers = CMan.stun_maneuvers.to_i

      if stun_maneuvers > 4
        if Skills.stalking_and_hiding.to_f / Stats.level.to_f > 1.5
          fput "stunman hide"
        else
          Action.stunman_stand
          fput "stunman flee"
          sleep(0.5)
        end
      elsif stun_maneuvers > 3
        Action.stunman_stand
        fput 'stunman stance2'
      elsif stun_maneuvers > 2
        Action.stunman_stand
        fput 'stunman stance1'
      end
    end

    def self.stunman_stand
      unless checkstanding
        fput "stunman stand"
        Util.wait_rt
      end
    end

    def self.telekinetic_recover(item)
      # Telekinetic Disarm is cast in Moonsedge - Savant spell 1406

      return unless Ecleanse.data[:recover_disarmed]
      System.scripts_pause

      dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

      # Make the room safer.
      Action.settle_room

      # Sometimes bigshot sneaks in an eloot
      System.scripts_pause

      # Change to defensive stance
      Action.change_stance(100)

      until [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item)
        if dispel.nil?
          fput "get #{item}"
        else
          Action.mana_pulse(dispel.num)
          dispel.cast("at #{item}") if dispel.affordable?
        end

        lines = Util.get_lines("glance", /You glance/)
        break if lines.any? { |l| l =~ /#{item}/ }

        Util.wait_rt
      end
    end

    def self.use_vat
      # A bite/spit maneuver from a Shambling Lurk in the Sanctum

      System.scripts_pause

      current_room = Room.current.id
      vat_room = XMLData.game == 'GSF' ? '19967' : '25250'
      Action.go2(vat_room)

      Util.get_res("clean vat")
      Util.wait_rt

      Action.go2(current_room)
    end
  end

  module System
    def self.deadmans_switch
      # Kill script if dead
      Thread.new { loop { Script.self.kill if dead?; sleep(5); } }
    end

    def self.scripts_pause
      Ecleanse.data[:script_list].each { |script| Script.pause(script) if Script.running?(script) }
      Ecleanse.did_something = true
    end

    def self.scripts_resume
      Ecleanse.data[:script_list].each { |script| Script.unpause(script) if Script.paused?(script) }
      Ecleanse.did_something = false
    end

    def self.set_hooks
      ecleanse_status = proc { |server|
        if server =~ /Your <a exist=".*?" noun="(.*?)">.*?<\/a> is knocked from your grasp/
          item = Regexp.last_match(1)
          recover = Proc.new { Action.recover(item, Room.current.id, Room.current.title) }
          Ecleanse.event_stack.push(recover) unless Ecleanse.event_stack.include?(recover)
        elsif server =~ /Your <a exist=".*?" noun="(.*?)">.*?<\/a>tears free from your hands and floats/
          item = Regexp.last_match(1)
          telekinetic_recover = Proc.new { Action.telekinetic_recover(item) }
          Ecleanse.event_stack.push(telekinetic_recover) unless Ecleanse.event_stack.include?(telekinetic_recover)
        elsif server =~ /Striking with a serpent's unsettling quickness, (?:.*)\.  Vile (?:.*), kindling it into an unholy semblance of life.  The (?:.*) form twists and mutates, sprouting scales and cold eyes as it transforms into a <a exist="\d+" noun="([^"]+)">[^<]+<\/a>\!/
          creature = Regexp.last_match(1)
          sanctum_recover = Proc.new { Action.sanctum_recover(creature) }
          Ecleanse.event_stack.push(sanctum_recover) unless Ecleanse.event_stack.include?(sanctum_recover)
        elsif server =~ /The flesh around the wound feels hot and cold at the same time, heavy with infection./
          use_vat = Proc.new { Action.use_vat }
          Ecleanse.event_stack.push(use_vat) unless Ecleanse.event_stack.include?(use_vat)
        end
        server
      }
      DownstreamHook.add('ecleanse_status', ecleanse_status)

      before_dying {
        DownstreamHook.remove('ecleanse_status')
        Ecleanse.data[:script_list].each { |script| Script.unpause(script) if Script.paused?(script) }
      }
    end
  end

  module Util
    def self.able_to_cast
      able_to_cast = true
      stacked_right_scar = 0
      stacked_right_wound = 0
      stacked_left_scar = 0
      stacked_left_wound = 0
      try_sigil = true

      XMLData.injuries.each { |area, h|
        next unless area =~ /nsys|head|(left|right)(Eye|Arm|Hand)/
        next unless (h['scar'].positive? || h['wound'].positive?)

        # echo area
        # echo "scar: #{h['scar']} wound: #{h['wound']}"
        if h['scar'] > 2 || h['wound'] > 2
          try_sigil = false # Sigil of Determination cannot ignore rank 3
          able_to_cast = false
          break
        elsif area =~ /nsys|head/ && (h['scar'] > 1 || h['wound'] > 1)
          able_to_cast = false
          break
        elsif area =~ /left(Arm|Hand)/
          stacked_left_scar += h['scar']
          stacked_left_wound += h['wound']
          if (stacked_left_scar > 1 || stacked_left_wound > 1)
            able_to_cast = false
            break
          end
        elsif area =~ /right(Arm|Hand)/
          stacked_right_scar += h['scar']
          stacked_right_wound += h['wound']
          if (stacked_right_scar > 1 || stacked_right_wound > 1)
            able_to_cast = false
            break
          end
        end
      }

      # Eval Sigil of Determination if known
      if !able_to_cast && try_sigil
        able_to_cast = Util.check_determination
      end

      return able_to_cast
    end

    def self.check_determination
      return false unless Ecleanse.data[:determination]
      return false unless Spell["Sigil of Determination"].known?
      return false unless Spell["Sigil of Determination"].affordable?

      Action.determination unless Effects::Buffs.active?("Sigil of Determination")

      stacked_right_scar = 0
      stacked_right_wound = 0
      stacked_left_scar = 0
      stacked_left_wound = 0
      able_to_cast = true
      XMLData.injuries.each { |area, h|
        next unless area =~ /nsys|head|(left|right)(Eye|Arm|Hand)/

        if h['scar'] > 2 || h['wound'] > 2
          able_to_cast = false
        elsif area =~ /left(Arm|Hand)/
          stacked_left_scar += h['scar']
          stacked_left_wound += h['wound']
          if (stacked_left_scar > 2 || stacked_left_wound > 2)
            able_to_cast = false
            break
          end
        elsif area =~ /right(Arm|Hand)/
          stacked_right_scar += h['scar']
          stacked_right_wound += h['wound']
          if (stacked_right_scar > 2 || stacked_right_wound > 2)
            able_to_cast = false
            break
          end
        end
      }

      return able_to_cast
    end

    def self.get_command(command, regex)
      lines = []
      regex = Regexp.union(regex, /(?:\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

      loop do
        lines = Util.issue_command(command, regex)
        break unless lines.grep(/(?:\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

        Util.wait_rt
      end

      return lines
    end

    def self.get_lines(command, regex)
      lines = []
      regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

      loop do
        lines = Util.issue_command(command, regex, silent: true, quiet: true)
        break unless lines.grep(/(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

        Util.wait_rt
      end

      return lines
    end

    def self.get_res(command, regex = nil)
      rt_regex = /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./
      regex = regex.nil? ? Regexp.union(/.*?/, rt_regex) : Regexp.union(regex, rt_regex)
      result = nil
      loop do
        result = dothistimeout(command, 3, regex)
        break unless result =~ rt_regex

        Util.wait_rt
      end

      return result
    end

    def self.get_script_version
      data = Script.list.find { |x| x.name == Script.current.name }.inspect
      return data[/version: (\d+\.\d+\.\d+)/i, 1]
    end

    def self.help
      if defined?(Terminal::Table)
        rows = []
        rows << ["#{$lich_char}#{Script.current.name} setup", "UI configuration tool"]
        rows << ["#{$lich_char}#{Script.current.name} load", "Reloads all settings"]
        rows << ["#{$lich_char}#{Script.current.name} list", "Lists all settings"]
        rows << ["#{$lich_char}#{Script.current.name} last disarm", "Lists last disarm room"]

        table = Terminal::Table.new :title => "#{Script.current.name.capitalize} ver #{Util.get_script_version}", :rows => rows
        respond
        respond table
        respond
      else
        respond "############################################################"
        respond "                #{Script.current.name.capitalize} ver #{Util.get_script_version}"
        respond "############################################################"
        respond
        respond "If you install the 'terminal-table' gem, the help section will look better"
        respond "Install it with the following command: gem install terminal-table"
        respond "Via your computer's local terminal/shell"
        respond
        respond "#{$lich_char}#{Script.current.name} setup          UI configuration tool"
        respond "#{$lich_char}#{Script.current.name} load           Reloads all settings"
        respond "#{$lich_char}#{Script.current.name} list           Lists all settings"
        respond "#{$lich_char}#{Script.current.name} last disarm    Lists last disarm room"
        respond
        respond "############################################################"
        respond
      end
    end

    def self.issue_command(command, start_pattern, end_pattern = /<prompt/, include_end: true, timeout: 5, silent: nil, usexml: true, quiet: false)
      result = []
      name = "Ecleanse:: -#{Time.now.tv_sec}.#{Time.now.tv_usec}-#{Random.rand(10000)}"
      filter = false

      save_script_silent = Script.current.silent
      save_want_downstream = Script.current.want_downstream
      save_want_downstream_xml = Script.current.want_downstream_xml

      Script.current.silent = silent if !silent.nil?
      Script.current.want_downstream = !usexml
      Script.current.want_downstream_xml = usexml

      begin
        Timeout::timeout(timeout, Interrupt) {
          DownstreamHook.add(name, proc { |line|
            if filter
              if line =~ end_pattern
                DownstreamHook.remove(name)
                filter = false
                if quiet
                  next(nil)
                else
                  line
                end
              else
                if quiet
                  next(nil)
                else
                  line
                end
              end
            elsif line =~ start_pattern
              filter = true
              if quiet
                next(nil)
              else
                line
              end
            else
              line
            end
          })
          fput command

          until (line = get) =~ start_pattern; end
          result << line.rstrip
          until (line = get) =~ end_pattern
            result << line.rstrip
          end
          if include_end
            result << line.rstrip
          end
        }
      rescue Interrupt
        nil
      ensure
        DownstreamHook.remove(name)
        Script.current.silent = save_script_silent if !silent.nil?
        Script.current.want_downstream = save_want_downstream
        Script.current.want_downstream_xml = save_want_downstream_xml
      end
      return result
    end

    def self.msg(type = info, text)
      # color options - set type to use
      # yellow, orange, teal, green, plain

      if text.class == Hash
        text = text.inspect.gsub("#<", "#")
      elsif text.class == Array
        text = text.to_s
      elsif text.class == String
        text = text.gsub("#<", "#")
      end

      type = type == "debug" ? "speech" : type

      Lich::Messaging.msg(type, text)
    end

    def self.wait_rt
      sleep 0.2
      waitcastrt?
      waitrt?
      sleep 0.2
    end
  end

  def self.main_loop
    loop do
      while Ecleanse.event_stack.any?
        current_event = Ecleanse.event_stack.shift
        current_event.call
      end

      if checkpoison
        remove_poison = Proc.new { Action.remove_poison }
        Ecleanse.event_stack.push(remove_poison) unless Ecleanse.event_stack.include?(remove_poison)
      end

      if checkdisease
        remove_disease = Proc.new { Action.remove_disease }
        Ecleanse.event_stack.push(remove_disease) unless Ecleanse.event_stack.include?(remove_disease)
      end

      if checkstunned
        remove_stun = Proc.new { Action.remove_stun }
        Ecleanse.event_stack.push(remove_stun) unless Ecleanse.event_stack.include?(remove_stun)
      end

      if checkwebbed || checkbound
        remove_web_bound = Proc.new { Action.remove_web_bound }
        Ecleanse.event_stack.push(remove_web_bound) unless Ecleanse.event_stack.include?(remove_web_bound)
      end

      if Effects::Debuffs.to_h.any? { |debuff| debuff[0].to_s =~ /Rooted|Pressed/ }
        remove_grounded = Proc.new { Action.remove_grounded }
        Ecleanse.event_stack.push(remove_grounded) unless Ecleanse.event_stack.include?(remove_grounded)
      end

      if Effects::Debuffs.to_h.any? { |debuff| debuff[0].to_s =~ /Confusion|Vertigo|Sounds|Thought Lash|Mindwipe|Pious Trial|Powersink/ }
        remove_magical = Proc.new { Action.remove_magical }
        Ecleanse.event_stack.push(remove_magical) unless Ecleanse.event_stack.include?(remove_magical)
      end

      if (web = GameObj.loot.find { |l| l.noun =~ /web|silvery blue globe|spiraling ghostly rift/i })
        avoid_webs = Proc.new { Action.avoid_webs(web) }
        Ecleanse.event_stack.push(avoid_webs) unless Ecleanse.event_stack.include?(avoid_webs)
      end

      if (globe = GameObj.loot.find { |l| l.name =~ /silvery blue globe|spiraling ghostly rift|chaotic spatial anomaly/i })
        avoid_globe = Proc.new { Action.avoid_globe(globe) }
        Ecleanse.event_stack.push(avoid_globe) unless Ecleanse.event_stack.include?(avoid_globe)
      end

      if Ecleanse.data[:determination] && (XMLData.injuries["leftHand"]["wound"] > 1 || XMLData.injuries["rightHand"]["wound"] > 1 || XMLData.injuries["leftArm"]["wound"] > 1 || XMLData.injuries["rightArm"]["wound"] > 1 || XMLData.injuries["leftEye"]["wound"] > 1 || XMLData.injuries["rightEye"]["wound"] > 1 || XMLData.injuries["nsys"]["wound"] > 1 || XMLData.injuries["head"]["wound"] > 1)
        determination = Proc.new { Action.determination }
        Ecleanse.event_stack.push(determination) unless Ecleanse.event_stack.include?(determination)
      end

      System.scripts_resume if Ecleanse.did_something
      sleep 0.2
    end
  end

  unless Ecleanse.data
    Util.wait_rt
    Ecleanse.load(Ecleanse.load_settings)
  end

  case Script.current.vars[0]
  when /^setup$/i
    Setup.new(Ecleanse.load_settings).start
    Ecleanse.save_settings(Ecleanse.data)
    Ecleanse.load(Ecleanse.load_settings)
  when /load/
    Ecleanse.load(Ecleanse.load_settings)
  when /list/
    Ecleanse::Setup.new(Ecleanse.data).list
  when /last disarm/
    Ecleanse::Util.msg("yellow", " Last recorded disarm:  Room #{UserVars.last_disarm}.")
  when nil
    Ecleanse::System.deadmans_switch
    Ecleanse::System.set_hooks
    Ecleanse.main_loop
  else
    Ecleanse::Util.help
  end
end

# ToDo
# spell cleave
