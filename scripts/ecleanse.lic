=begin
   A script that removes status affects and combines several previous separate scripts. Will cover dispels, disarmed, and other status affects.
   Configuration can be accessed via ;ecleanse setup
        author: Deysh
  contributors: Tysong
          game: Gemstone
          tags: dispel, unpoison, undisease, disarmed, effects
       version: 1.0.17

  Improvements:
  v1.0.17 (2024-05-01)
    - fix for Char.level -> Stats.level
    - fix for Char.prof -> Stats.prof
  v1.0.16 (2023-11-24)
    - bugfix for stun recover - check to make sure not in a belly or innards
    - added check for silvery blue globe and spiraling ghostly rift in Moonsedge
    - added check for disarm maneuver in Moonsedge and Sanctum
    - added check for Sanctum disease needing the vat
=end
=begin
  v1.0.15 (2023-08-23)
    - Bugfix for cman retreat if current target != creature that caused grounded debuff
  v1.0.14 (2023-04-13)
    - Bugfix for disarm recovery
  v1.0.13 (2023-04-06)
    - Bugfix for regex comparison of an integer in Ruby 3.2+, force convert .to_s
  v1.0.12 (2023-03-27)
    - added standing check for "channel open" casting
  v1.0.11 (2023-03-11)
    - added multiple searches for recover item
  v1.0.10 (2023-03-07)
    - removed 906 from web dispell
    - added Powersink to dispell debuffs
  v1.0.9 (2023-02-12)
    - added wound eval for spell casting
    - added a wait for spirit servants in disarm recovery
    - add some error checking to disarm recovery
  v1.0.8 (2023-02-10)
    - bug fix for incorrect method name during spirit servant recovery
  v1.0.7 (2023-02-07)
    - bug fix for web check to avoid custom disks
  v1.0.6 (2023-01-31)
    - bug fix for magical_grounded method if either option is checked
  v1.0.5 (2023-01-31)
    - bug fix for weapon disarm section
  v1.0.4 (2023-01-24)
    - bug fix in remove stuff for barkskin check
    - update 1011 casting so it doesn't repeat
    - added support for sigil of determination
  v1.0.3 (2023-01-23)
    - bug fix in recover weapon
  v1.0.2 (2023-01-22)
    - fixed regex for disarmed to not mistake hurled weapons
  v1.0.1 (2023-01-21)
    - add check for CMan.known?("Retreat") and stamina check for grounded debuff.
    - moved magical/grounded debuffs into separate method to only pause scripts if necessary
    - add Mindwipe and Pious Trial to dispellable debuffs
  v1.0.0 (2023-01-20)
    - Initial release
=end

module Ecleanse
  Ecleanse_version ||= '1.0.16'

  @@data ||= nil
  @did_something = false

  def self.data
    @@data
  end

  def self.mana_pulse(spell_id)
    return unless Spell[spell_id].known? && !Spell[spell_id].affordable?

    mana_regex = Regexp.union(
      /An invigorating rush of mana pulses through you/i,
      /You are too mentally fatigued to attempt this ability/i,
      /You're already at full mana./i,
      /Your mana control skills are not yet advanced/i,
    )

    dothistimeout "mana pulse", 2, mana_regex
    sleep 0.2
  end

  def self.go2(place)
    fput('unhide') if (hidden? || invisible?)

    return if Room.current.id == place

    if Room.current.id.nil?
      respond "Currently in an unmapped room - Need to go to #{place}"
    end

    Script.run('go2', "#{place} --disable-confirm", { quiet: true })
  end

  def self.issue_command(command, start_pattern, loud = true, end_pattern = /<prompt/, include_end = false, timeout = 5)
    result = []
    name = "Sell:: -#{Time.now.tv_sec}.#{Time.now.tv_usec}-#{Random.rand(10000)}"
    filter = false
    save_want_downstream = Script.current.want_downstream
    save_want_downstream_xml = Script.current.want_downstream_xml
    Script.current.want_downstream = false
    Script.current.want_downstream_xml = true

    begin
      Timeout::timeout(timeout, Interrupt) {
        DownstreamHook.add(name, proc { |xml|
          is_loud = loud ? xml : nil
          if filter
            if xml =~ end_pattern
              DownstreamHook.remove(name)
              filter = false
            else
              next(is_loud)
            end
          elsif xml =~ start_pattern
            filter = true
            next(is_loud)
          else
            # echo "xml: #{xml}"
            # xml
            next(is_loud)
          end
        })
        if loud
          fput command
        else
          $_SERVER_.puts command
        end
        until (xml = get) =~ start_pattern; end
        result << xml.rstrip
        until (xml = get) =~ end_pattern
          result << xml.rstrip
        end
        if include_end
          result << xml.rstrip
        end
      }
    rescue Interrupt
      nil
    ensure
      DownstreamHook.remove(name)
      Script.current.want_downstream_xml = save_want_downstream_xml
      Script.current.want_downstream = save_want_downstream
    end
    # echo result
    return result
  end

  def self.get_command(command, regex)
    lines = []
    regex = Regexp.union(regex, /(?:\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

    loop do
      lines = Ecleanse.issue_command(command, regex)
      break unless lines.grep(/(?:\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

      Ecleanse.wait_rt
    end

    return lines
  end

  def self.get_lines(command, regex)
    lines = []
    regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

    loop do
      lines = Lich::Util.quiet_command_xml(command, regex)
      break unless lines.grep(/(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

      Ecleanse.wait_rt
    end

    return lines
  end

  def self.get_res(command, regex = nil)
    rt_regex = /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./
    regex = regex.nil? ? Regexp.union(/.*?/, rt_regex) : Regexp.union(regex, rt_regex)
    result = nil
    loop do
      result = dothistimeout(command, 3, regex)
      break unless result =~ rt_regex

      Ecleanse.wait_rt
    end

    return result
  end

  def self.deadmans_switch
    # Kill script if dead
    Thread.new { loop { Script.self.kill if dead?; sleep(5); } }
  end

  def self.load_settings()
    dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
    poison = [114].map { |s| Spell[s] }.find { |s| s.known? }
    disease = [113].map { |s| Spell[s] }.find { |s| s.known? }
    webs = [209, 417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

    CharSettings['cleanse_magical'] = false unless dispel.known?
    CharSettings['cleanse_grounded'] = false unless CMan.known?("Retreat")
    CharSettings['cleanse_poison'] = false unless poison.known?
    CharSettings['cleanse_disease'] = false unless disease.known?
    CharSettings['avoid_webs'] = false unless webs.known?
    CharSettings['determination'] = false unless Society.member =~ /Guardians of Sunfist/

    settings_hash = {
      :cleanse_magical  => CharSettings['cleanse_magical'],
      :cleanse_grounded => CharSettings['cleanse_grounded'],
      :cleanse_poison   => CharSettings['cleanse_poison'],
      :cleanse_disease  => CharSettings['cleanse_disease'],
      :recover_disarmed => CharSettings['recover_disarmed'],
      :avoid_webs       => CharSettings['avoid_webs'],
      :stop_scripts     => CharSettings['stop_scripts'],
      :determination    => CharSettings['determination'],
    }

    # Lets find the containers we need
    container_match = /<a exist="([^"]+)" noun="[^"]+">[^(.]+\(([a-z]+)\)/
    container_lines = Lich::Util.quiet_command_xml("stow list", /<output class="mono"\/>/)

    sacks = {}
    container_lines.each { |line|
      if line =~ container_match
        sacks.store(Regexp.last_match(2), GameObj.inv.find { |i| i.id == Regexp.last_match(1) })
        sacks.delete(Regexp.last_match(2)) unless sacks[Regexp.last_match(2)]
      end
    }

    settings_hash[:default] = sacks["default"]

    settings_hash[:script_list] = settings_hash[:stop_scripts].split(",")
    settings_hash[:script_list].push("go2") unless settings_hash[:script_list].include?("go2")

    settings_hash
  end

  def self.load(settings)
    @@data = settings
  end

  def self.save_settings(settings)
    CharSettings['cleanse_magical'] = settings[:cleanse_magical]
    CharSettings['cleanse_grounded'] = settings[:cleanse_grounded]
    CharSettings['cleanse_poison'] = settings[:cleanse_poison]
    CharSettings['cleanse_disease'] = settings[:cleanse_disease]
    CharSettings['recover_disarmed'] = settings[:recover_disarmed]
    CharSettings['avoid_webs'] = settings[:avoid_webs]
    CharSettings['stop_scripts'] = settings[:stop_scripts]
    CharSettings['determination'] = settings[:determination]
  end

  def self.msg(type = info, text)
    # color options - set type to use
    # yellow, orange, teal, green, plain

    if text.class == Hash
      text = text.inspect.gsub("#<", "#")
    elsif text.class == Array
      text = text.to_s
    elsif text.class == String
      text = text.gsub("#<", "#")
    end

    type = type == "debug" ? "speech" : type

    Lich::Messaging.msg(type, text)
  end

  def self.wait_rt
    sleep 0.2
    wait_while { checkrt > 0 }
    sleep 0.2
  end

  class Setup < Gtk::Builder
    attr_accessor :settings

    @@categories = {
      general: {
        cleanse_magical: { default: false },
        cleanse_grounded: { default: false },
        cleanse_poison: { default: false },
        cleanse_disease: { default: false },
        recover_disarmed: { default: false },
        avoid_webs: { default: false },
        stop_scripts: { default: '' },
        script_list: { default: [] },
        determination: { default: false },
      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?

      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()
      @settings = settings
      # set default values if they don't exist
      @@categories.each do |_, data|
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end
      # remove settings that doesn't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }
      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        # add_from_file("#{$data_dir}ecleanse.ui")
        add_from_string(Setup.ui)
        load_settings
        self['main'].keep_above = true
        self['main'].set_title "Ecleanse Setup v#{Ecleanse_version}"
        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    def self.ui
      '<?xml version="1.0" encoding="UTF-8"?><interface><requires lib="gtk+" version="3.20"/><object class="GtkWindow" id="main"><property name="width-request">510</property><property name="height-request">292</property><property name="can-focus">False</property><property name="title" translatable="yes">Ecleanse Setup</property><property name="default-height">325</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="recover_disarmed"><property name="label" translatable="yes">Recover Disarmed Weapons</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will use 218 if active</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">6</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="cleanse_magical"><property name="label" translatable="yes">Cleanse Magical</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Attempts to cleanse - Confusion, Vertigo, Sounds, or Thought Lash using spells 417, 119, or 1218 if known</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="cleanse_poison"><property name="label" translatable="yes">Cure Poison</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses unpoison (114)</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="avoid_webs"><property name="label" translatable="yes">Attempt to dispel magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will try to cast (209, 417, 1218, 119) if known</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">6</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="cleanse_disease"><property name="label" translatable="yes">Cure Disease</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses undisease (113)</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="cleanse_grounded"><property name="label" translatable="yes">Cleanse Grounded</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Attempts to clear Rooted or Pressed using Cman Retreat</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="determination"><property name="label" translatable="yes">Sigil of Determination</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">13</property><property name="margin-end">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Scripts to Pause</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="stop_scripts"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-bottom">5</property><property name="width-chars">59</property><property name="placeholder-text" translatable="yes">list of scripts to pause eg - bigshot,eloot,awesome_script74</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="width">2</property>
      </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Scripts</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property>
      </object><packing><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes"> Intended to be run in the background
      or as part of Bigshot\'s active hunting scripts </property><attributes><attribute name="style" value="italic"/>
      </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
      </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update
          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        elsif obj.class == Gtk::ComboBoxText
          @settings[key] = obj.active_text
        end
      end
    end

    def on_close_clicked
      Ecleanse.load(@settings)
      self['main'].destroy
    end

    def on_destroy
      Gtk.queue {
        Ecleanse.load(@settings)
        @running = false
      }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings
      Gtk.queue do
        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym
          next if (setting = Setup.get_setting(key)).nil?

          # set the default value
          poison = [114].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_poison")) && poison.nil?

          disease = [113].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_disease")) && disease.nil?

          dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_magical")) && dispel.nil?

          webs = [209, 417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("avoid_webs")) && webs.nil?

          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_grounded")) && !CMan.known?("Retreat")

          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("determination")) && Society.member !~ /Guardians of Sunfist/

          # obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("rogue_password")) && Stats.prof != "Rogue"
          # obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("use_seeking")) && Society.member !~ /Order of Voln/ && Society.rank !~ /26/

          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) }
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].strip
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::SpinButton
            obj.value = @settings[key]
            obj.adjustment.value = @settings[key]
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::ComboBoxText
            # Fixme: change to builder_name
            if @settings[key] == "Auto"
              item = 0
            elsif @settings[key] == "On"
              item = 1
            elsif @settings[key] == "Off"
              item = 2
            elsif @settings[key] == "1"
              item = 0
            elsif @settings[key] == "2"
              item = 1
            end

            obj.set_active(item) if item
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::TreeView
            if (store = self["#{key}_store"]).nil?
              respond "** failed to find store for treeview #{key}"
              next
            elsif setting[:load].nil?
              respond "** no :load defined #{key}"
              next
            end

            setting[:load].call(store, @settings[key])

            # setup the signals
            if (add = self["#{key}_add"]).nil?
              respond "** failed to find add for treeview #{key}"
              next
            elsif (delete = self["#{key}_delete"]).nil?
              respond "** failed to find delete for treeview #{key}"
              next
            elsif (entry = self["#{key}_entry"]).nil?
              respond "** failed to find entry for treeview #{key}"
              next
            end

            add.signal_connect('clicked') do
              if setting[:set].nil?
                respond "** no :set defined for #{key}"
                next
              elsif entry.text.empty?
                next
              end
              setting[:set].call(store, entry.text, @settings[key])
              setting[:load].call(store, @settings[key])
            end

            delete.signal_connect('clicked') do
              if setting[:delete].nil?
                respond "** no :delete defined for #{key}"
                next
              elsif (selected = obj.selection.selected).nil?
                next
              end
              setting[:delete].call(store, selected, @settings[key])
              setting[:load].call(store, @settings[key])
            end
          end
        end

        # checkboxes for array storage with id's <setting>:<value>
        # this is primarily used by the loot types
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)
          next unless obj.builder_name =~ /^([^:]+):(.*)$/i
          next unless obj.class == Gtk::CheckButton

          key = Regexp.last_match(1).to_sym
          value = Regexp.last_match(2).to_s
          # echo "key: #{key} value: #{value}"
          next if Setup.get_setting(key).nil?

          # echo @settings[key].include?(value)
          obj.active = @settings[key].include?(value)

          # add in hook
          obj.signal_connect('toggled') do
            @settings[key].delete(value)
            if obj.active?
              @settings[key].push(value)
              @settings[key].uniq!.sort!
            end
          end
        end
      end
    end

    def start
      @running = true
      Gtk.queue { self['main'].show_all }
      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[general internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def self.update_setting(key, value)
      setting = Setup.get_setting(key)
      echo "** Setting #{key.inspect} does not exist" if setting.nil?
      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        echo " Reset #{key}"
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          echo " #{value.inspect} removed from #{key.inspect}"
        else
          @settings[key].push(value)
          echo " #{value.inspect} added to #{key.inspect}"
        end

        echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        echo "#{key.inspect} has been set to #{value.inspect}"
        @settings[key] = value
      end
    end
  end

  def self.able_to_cast
    able_to_cast = true
    stacked_right_scar = 0
    stacked_right_wound = 0
    stacked_left_scar = 0
    stacked_left_wound = 0
    try_sigil = true

    XMLData.injuries.each { |area, h|
      next unless area =~ /nsys|head|(left|right)(Eye|Arm|Hand)/
      next unless (h['scar'].positive? || h['wound'].positive?)

      # echo area
      # echo "scar: #{h['scar']} wound: #{h['wound']}"
      if h['scar'] > 2 || h['wound'] > 2
        try_sigil = false # Sigil of Determination cannot ignore rank 3
        able_to_cast = false
        break
      elsif area =~ /nsys|head/ && (h['scar'] > 1 || h['wound'] > 1)
        able_to_cast = false
        break
      elsif area =~ /left(Arm|Hand)/
        stacked_left_scar += h['scar']
        stacked_left_wound += h['wound']
        if (stacked_left_scar > 1 || stacked_left_wound > 1)
          able_to_cast = false
          break
        end
      elsif area =~ /right(Arm|Hand)/
        stacked_right_scar += h['scar']
        stacked_right_wound += h['wound']
        if (stacked_right_scar > 1 || stacked_right_wound > 1)
          able_to_cast = false
          break
        end
      end
    }

    # Eval Sigil of Determination if known
    if !able_to_cast && try_sigil
      able_to_cast = Ecleanse.check_determination
    end

    return able_to_cast
  end

  def self.check_determination
    return false unless CharSettings['determination']
    return false unless Spell["Sigil of Determination"].known?
    return false unless Spell["Sigil of Determination"].affordable?

    Ecleanse.determination unless Effects::Buffs.active?("Sigil of Determination")

    stacked_right_scar = 0
    stacked_right_wound = 0
    stacked_left_scar = 0
    stacked_left_wound = 0
    able_to_cast = true
    XMLData.injuries.each { |area, h|
      next unless area =~ /nsys|head|(left|right)(Eye|Arm|Hand)/

      if h['scar'] > 2 || h['wound'] > 2
        able_to_cast = false
      elsif area =~ /left(Arm|Hand)/
        stacked_left_scar += h['scar']
        stacked_left_wound += h['wound']
        if (stacked_left_scar > 2 || stacked_left_wound > 2)
          able_to_cast = false
          break
        end
      elsif area =~ /right(Arm|Hand)/
        stacked_right_scar += h['scar']
        stacked_right_wound += h['wound']
        if (stacked_right_scar > 2 || stacked_right_wound > 2)
          able_to_cast = false
          break
        end
      end
    }

    return able_to_cast
  end

  def self.pause_scripts
    Ecleanse.data[:script_list].each { |script| Script.pause(script) if Script.running?(script) }
    @did_something = true
  end

  def self.unpause_scripts
    Ecleanse.data[:script_list].each { |script| Script.unpause(script) if Script.paused?(script) }
    @did_something = false
  end

  def self.remove_poison
    return unless CharSettings['cleanse_poison']
    return unless Spell[114].known? && Ecleanse.able_to_cast

    Ecleanse.mana_pulse(114)

    return unless Spell[114].affordable?

    Ecleanse.pause_scripts

    Spell[114].cast
    sleep 0.5
    waitcastrt?
  end

  def self.remove_disease
    return unless CharSettings['cleanse_disease']
    return unless Spell[113].known? && Ecleanse.able_to_cast

    Ecleanse.mana_pulse(113)

    return unless Spell[113].affordable?

    Ecleanse.pause_scripts

    until !checkdisease || !Spell[113].affordable?
      Spell[113].cast
      sleep 0.5
      waitcastrt?
    end
  end

  def self.remove_stun
    return unless (Spell[1040].known? && Spell[1040].affordable?) || (CMan.known?("Berserk") && checkstamina(21)) || (CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers.to_i > 2) || (Spell[605].known? && !Effects::Cooldowns.active?("Barkskin: Commune") && !Effects::Cooldowns.active?("Barkskin") && !Spell[605].active? && Skills.slblessings >= 15)
    return if Stats.prof =~ /Ranger/i && !Ecleanse.able_to_cast

    Ecleanse.pause_scripts

    if Spell[1040].known?
      Ecleanse.mana_pulse(1040)

      if Spell[1040].affordable?
        fput "shout 1040"
      end
    elsif CMan.known?("Berserk") && checkstamina(21) && checkroom("The Belly of the Beast").nil? && checkroom("Ooze, Innards").nil?
      Spell[9607].cast
      sleep 1
      wait_until { !Spell[9607].active? }
    elsif CMan.stun_maneuvers > 2 && checkroom("The Belly of the Beast").nil? && checkroom("Ooze, Innards").nil?
      Ecleanse.perform_stunman
    elsif Spell[605].known? && !Effects::Cooldowns.active?("Barkskin: Commune") && !Effects::Cooldowns.active?("Barkskin") && !Spell[605].active? && Skills.slblessings >= 15
      Ecleanse.mana_pulse(605)
      waitrt?
      fput "commune barkskin" if stunned?
      sleep(2)
    end
  end

  def self.stunman_stand
    unless checkstanding
      fput "stunman stand"
      sleep(0.5)
      waitrt?
    end
  end

  def self.perform_stunman
    stun_maneuvers = CMan.stun_maneuvers.to_i

    if stun_maneuvers > 4
      if Skills.stalking_and_hiding.to_f / Stats.level.to_f > 1.5
        fput "stunman hide"
      else
        Ecleanse.stunman_stand
        fput "stunman flee"
        sleep(0.5)
      end
    elsif stun_maneuvers > 3
      Ecleanse.stunman_stand
      fput 'stunman stance2'
    elsif stun_maneuvers > 2
      Ecleanse.stunman_stand
      fput 'stunman stance1'
    end
  end

  def self.remove_grounded
    return unless CharSettings['cleanse_grounded']
    return unless CMan.known?("Retreat")

    grounded_debuffs = ["Rooted", "Pressed"]
    grounded_debuffs.each { |debuff|
      if Effects::Debuffs.active?(debuff) && checkstamina(11)
        Ecleanse.pause_scripts
        waitrt?
        waitcastrt?
        fput "stand" until checkstanding
        waitrt?
        current_target = XMLData.current_target_id
        fput 'target clear'
        fput 'cman retreat'
        fput "target ##{current_target}"
      end
    }
  end

  def self.remove_magical
    return unless CharSettings['cleanse_magical']
    return unless Ecleanse.able_to_cast

    dispellable_debuffs = ["Confusion", "Vertigo", "Sounds", "Thought Lash", "Mindwipe", "Pious Trial", "Powersink"]
    dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

    # Return if we don't know how to do dispel
    return if dispel.nil?

    Ecleanse.mana_pulse(dispel.num)

    dispellable_debuffs.each { |debuff|
      if Effects::Debuffs.active?(debuff) and !dispel.nil?
        Ecleanse.pause_scripts

        Ecleanse.mana_pulse(dispel.num)

        fput "stand" until checkstanding
        waitrt?
        dispel.force_incant("channel open") if dispel.affordable?
        echo Ecleanse.able_to_cast
      end
    }
  end

  def self.remove_web_bound
    Ecleanse.mana_pulse(1040)

    return unless (Spell[1040].known? && Spell[1040].affordable?) || (CMan.known?("Berserk") && checkstamina(21))

    Ecleanse.pause_scripts

    if Spell[1040].known? and Spell[1040].affordable?
      fput "shout 1040"
    elsif CMan.known?("Berserk") && checkstamina(21)
      Spell[9607].cast
      sleep 1
      wait_until { !Spell[9607].active? }
    elsif CMan.known?("Spell Cleave") && checkstamina(10)
      fput "cman scleave"
    elsif CMan.known?("Spell Thieve") && checkstamina(10)
      fput "cman sthieve"

    end
  end

  def self.avoid_webs(web)
    return unless CharSettings['avoid_webs']
    return unless Ecleanse.able_to_cast

    dispel = [209, 417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

    # Return if we don't know how to do cast those
    return if dispel.nil?

    Ecleanse.pause_scripts

    Ecleanse.mana_pulse(dispel.num)

    dispel.cast("at #{web}") if dispel.affordable?
  end

  def self.avoid_globe(globe)
    return unless CharSettings['avoid_webs']
    return unless Ecleanse.able_to_cast

    dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

    # Return if we don't know how to do cast those
    return if dispel.nil?

    Ecleanse.mana_pulse(dispel.num)

    Ecleanse.pause_scripts
    dispel.cast("at #{globe}") if dispel.affordable?
  end

  def self.set_hooks
    @disarmed = false
    @smr_disarm = false
    @recover_room = nil
    @recover_title = nil
    @current_right = nil
    @current_left = nil
    @sanctum_disarm = false
    @creature = nil
    @need_vat = false

    disarm_status = proc { |server|
      if server =~ /Use the <d>RECOVER ITEM<\/d> command while in the appropriate room to regain your item./i
        @disarmed = true
        @recover_room = Room.current.id
        @recover_title = Room.current.title
      elsif server =~ /tears free from your hands and floats threateningly in the air around you, darting about as if possessed/
        @smr_disarm = true
        @recover_room = Room.current.id
        @recover_title = Room.current.title
      elsif server =~ /Striking with a serpent's unsettling quickness, (?:.*)\.  Vile (?:.*), kindling it into an unholy semblance of life.  The (?:.*) form twists and mutates, sprouting scales and cold eyes as it transforms into a <a exist="\d+" noun="([^"]+)">[^<]+<\/a>\!/
        @sanctum_disarm = true
        @creature = Regexp.last_match(1)
      elsif server =~ /The flesh around the wound feels hot and cold at the same time, heavy with infection./
        @need_vat = true
      end
      server
    }
    DownstreamHook.add('disarm_status', disarm_status)

    before_dying {
      DownstreamHook.remove('disarm_status')
      Ecleanse.unpause_scripts
    }
  end

  def self.recover(right, left)
    Ecleanse.pause_scripts

    sanct = [213, 1011].map { |s| Spell[s] }.find { |s| s.known? }

    look_for = GameObj.right_hand.name != right.name && !right.id.nil? ? right : left
    # echo "right: #{right.id} #{right.name} left: #{left.id} #{left.name}"
    Ecleanse.msg("yellow", " ########## DISARMED!!! ##########")
    Ecleanse.msg("yellow", " ## Room#: #{@recover_room}")
    Ecleanse.msg("yellow", " ## Room Name: #{@recover_title.first}")
    Ecleanse.msg("yellow", " Looking for: #{look_for.name}")
    Ecleanse.msg("yellow", " ########## DISARMED!!! ##########")
    UserVars.last_disarm = @recover_room
    Ecleanse.go2(@recover_room)

    Ecleanse.wait_rt

    sanct.cast if !sanct.nil? && sanct.affordable? && Ecleanse.able_to_cast
    waitcastrt?

    if Spell[218].active?

      15.times do
        break if (GameObj.npcs.find { |npc| npc.noun =~ /spirit/i })

        sleep(0.1)
      end

      line = dothistimeout "tell servant recover", 5, /flickers for a moment and manifests|has no personal recollection/
      if line =~ /flickers for a moment and manifests/
        servant_recover = true
      else
        servant_recover = false
      end
      if servant_recover
        @disarmed = false
        @recover_room = nil
        @recover_title = nil
        lines = Ecleanse.get_lines("sense", /You open your soul to the lesser/)
        if lines.any? { |l| l =~ /An obvious presence of peace saturates the area and a feeling of safety overwhelms you/ }
          fput "stop 213"
        end

        return
      end
    end

    if !GameObj.targets.empty? && Spell[619].known? && Spell[619].affordable? && Ecleanse.able_to_cast
      Spell[619].cast
    elsif !GameObj.targets.any? { |c| c.name =~ /arm/ } && !GameObj.targets.empty? && Spell[709].known? && Spell[709].affordable? && Ecleanse.able_to_cast
      Spell[709].cast
    elsif Spell[9811].known? && !GameObj.targets.empty?
      fput "sym of sleep"
    elsif Spell[919].known? && Spell[919].affordable? && !Effects::Buffs.active?("Wizard's Shield") && !Effects::Cooldowns.active?("Wizard's Shield") && Ecleanse.able_to_cast
      Spell[919].cast
    elsif Spell[140].known? && Spell[140].affordable? && !Effects::Buffs.active?("Wall of Force") && !Effects::Cooldowns.active?("Wall of Force") && Ecleanse.able_to_cast
      Spell[140].cast
    end

    # Sometimes bigshot sneaks in an eloot
    Ecleanse.pause_scripts

    fput "stance defensive"
    empty_hands
    search_count = 0
    until search_count.eql?(10)
      until (kneeling?)
        Ecleanse.wait_rt
        fput "kneel"
        exit if checkdead
      end
      Ecleanse.wait_rt

      lines = get_command("recover item", /<dialogData|You spy|You continue to intently search the area|In order to recover something|You find nothing recoverable/)

      if lines.grep(/You spy (?:an|a) (?:.*) and recover it\!/).any? || [GameObj.right_hand.id, GameObj.left_hand.id].include?(look_for.id)
        break
      end

      if lines.grep(/You're not in any condition to be searching around/).any?
        Ecleanse.msg("yellow", " Unable to search. Exiting ecleanse.")
        Ecleanse.msg("yellow", " #{look_for.name} is in room #{@recover_room}")
        fput "stand" unless standing?
        Ecleanse.unpause_scripts
        exit
      end

      if lines.grep(/In order to recover something/).any?
        empty_hands
      end

      # Or it could be in your default container if bonded weapon returned fast enough.
      if Ecleanse.data[:default].contents.find { |item| item.id == look_for.id }
        break
      end

      search_count += 1
    end

    Ecleanse.wait_rt

    # recovering a weapon changes it's ID
    item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.name == look_for.name }

    if item.name == right.name
      Ecleanse.get_res("_drag ##{item.id} right") unless GameObj.right_hand.id == item.id
      Ecleanse.get_res("_drag ##{left.id} left") unless GameObj.left_hand.id == left.id || left.id.nil?
    elsif item.name == left.name
      Ecleanse.get_res("_drag ##{right.id} right") unless GameObj.right_hand.id == right.id || right.id.nil?
      Ecleanse.get_res("_drag ##{item.id} left") unless GameObj.left_hand.id == item.id
    else
      Ecleanse.msg("warn", " Unknown Result: Unable to figure out what weapon you have.")
      Ecleanse.msg("warn", " Right: #{right.name} Left: #{left.name} Look_for: #{look_for.name}")
    end

    fput "stand" until (standing?)
    Ecleanse.wait_rt

    fput "stop #{sanct.num}" if !sanct.nil?

    @disarmed = false
    @recover_room = nil
    @recover_title = nil
    @current_right = GameObj.right_hand
    @current_left = GameObj.left_hand

    return true
  end

  def self.smr_recover(right, left)
    Ecleanse.pause_scripts

    dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

    Ecleanse.get_lines("glance", /You glance/)

    if GameObj.right_hand.name == "Empty" && !right.id.nil?
      look_for = right
    elsif GameObj.left_hand.name == "Empty" && !left.id.nil?
      look_for = left
    else
      Ecleanse.msg("yellow", " DISARMED! But I don't know which hand!")
    end

    Ecleanse.wait_rt

    # Make the room safer. Fixme: add options in UI
    if !GameObj.targets.empty? && Spell[619].known? && Spell[619].affordable? && Ecleanse.able_to_cast
      Spell[619].cast
    elsif !GameObj.targets.any? { |c| c.name =~ /arm/ } && !GameObj.targets.empty? && Spell[709].known? && Spell[709].affordable? && Ecleanse.able_to_cast
      Spell[709].cast
    elsif Spell[9811].known? && !GameObj.targets.empty?
      fput "sym of sleep"
    elsif Spell[919].known? && Spell[919].affordable? && !Effects::Buffs.active?("Wizard's Shield") && !Effects::Cooldowns.active?("Wizard's Shield") && Ecleanse.able_to_cast
      Spell[919].cast
    elsif Spell[140].known? && Spell[140].affordable? && !Effects::Buffs.active?("Wall of Force") && !Effects::Cooldowns.active?("Wall of Force") && Ecleanse.able_to_cast
      Spell[140].cast
    end

    # Sometimes bigshot sneaks in an eloot
    Ecleanse.pause_scripts

    until [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(look_for.noun)
      if dispel.nil?
        fput "get #{look_for.noun}"
      else
        Ecleanse.mana_pulse(dispel.num)
        dispel.cast("at #{look_for.noun}") if dispel.affordable?
      end

      lines = Ecleanse.get_lines("glance", /You glance/)
      break if lines.any? { |l| l =~ /#{look_for.noun}/ }

      Ecleanse.wait_rt
    end

    @smr_disarm = false
    @recover_room = nil
    @recover_title = nil
    @current_right = GameObj.right_hand
    @current_left = GameObj.left_hand
  end

  def self.sanctum_recover
    Ecleanse.pause_scripts

    Ecleanse.wait_rt

    # Make the room safer. Fixme: add options in UI
    if !GameObj.targets.empty? && Spell[619].known? && Spell[619].affordable? && Ecleanse.able_to_cast
      Spell[619].cast
    elsif !GameObj.targets.any? { |c| c.name =~ /arm/ } && !GameObj.targets.empty? && Spell[709].known? && Spell[709].affordable? && Ecleanse.able_to_cast
      Spell[709].cast
    elsif Spell[9811].known? && !GameObj.targets.empty?
      fput "sym of sleep"
    elsif Spell[919].known? && Spell[919].affordable? && !Effects::Buffs.active?("Wizard's Shield") && !Effects::Cooldowns.active?("Wizard's Shield") && Ecleanse.able_to_cast
      Spell[919].cast
    elsif Spell[140].known? && Spell[140].affordable? && !Effects::Buffs.active?("Wall of Force") && !Effects::Cooldowns.active?("Wall of Force") && Ecleanse.able_to_cast
      Spell[140].cast
    end

    # Sometimes bigshot sneaks in an eloot
    Ecleanse.pause_scripts

    loop do
      result = Ecleanse.get_res("clench #{@creature}")
      Ecleanse.wait_rt
      break if result =~ /You reach up and grab/
    end

    @sanctum_disarm = false
    @creature = nil
  end

  def self.use_vat
    Ecleanse.pause_scripts

    current_room = Room.current.id
    vat_room = XMLData.game == 'GSF' ? '19967' : '25250'

    Script.run('go2', "#{vat_room} --disable-confirm", { quiet: true, force: true })

    Ecleanse.get_res("clean vat")

    Ecleanse.wait_rt

    Script.run('go2', "#{current_room} --disable-confirm", { quiet: true, force: true })
  end

  def self.determination
    return unless Spell["Sigil of Determination"].known? && Spell["Sigil of Determination"].affordable?
    return if Effects::Buffs.active?("Sigil of Determination")

    Ecleanse.pause_scripts
    Spell["Sigil of Determination"].cast if Spell["Sigil of Determination"].affordable?
  end

  def self.start_up
    Ecleanse.set_hooks if CharSettings['recover_disarmed']

    loop {
      if checkpoison
        Ecleanse.remove_poison
      end

      if checkdisease
        Ecleanse.remove_disease
      end

      if checkstunned
        Ecleanse.remove_stun
      end

      if checkwebbed || checkbound
        Ecleanse.remove_web_bound
      end

      if Effects::Debuffs.to_h.any? { |debuff| debuff[0].to_s =~ /Rooted|Pressed/ }
        Ecleanse.remove_grounded
      end

      if Effects::Debuffs.to_h.any? { |debuff| debuff[0].to_s =~ /Confusion|Vertigo|Sounds|Thought Lash|Mindwipe|Pious Trial|Powersink/ }
        Ecleanse.remove_magical
      end

      if (web = GameObj.loot.find { |l| l.noun =~ /web|silvery blue globe|spiraling ghostly rift/i })
        Ecleanse.avoid_webs(web)
      end

      if (globe = GameObj.loot.find { |l| l.name =~ /silvery blue globe|spiraling ghostly rift/i })
        Ecleanse.avoid_globe(globe)
      end

      if CharSettings['recover_disarmed']
        if @disarmed
          Ecleanse.recover(@current_right, @current_left)
        elsif @smr_disarm
          Ecleanse.smr_recover(@current_right, @current_left)
        elsif @sanctum_disarm
          Ecleanse.sanctum_recover
        else
          @current_right = GameObj.right_hand
          @current_left = GameObj.left_hand
          # echo "@current_right: #{@current_right.name} @current_left: #{@current_left.name}"
        end
      end

      if @need_vat
        Ecleanse.use_vat
      end

      if CharSettings['determination'] && (XMLData.injuries["leftHand"]["wound"] > 1 || XMLData.injuries["rightHand"]["wound"] > 1 || XMLData.injuries["leftArm"]["wound"] > 1 || XMLData.injuries["rightArm"]["wound"] > 1 || XMLData.injuries["leftEye"]["wound"] > 1 || XMLData.injuries["rightEye"]["wound"] > 1 || XMLData.injuries["nsys"]["wound"] > 1 || XMLData.injuries["head"]["wound"] > 1)
        Ecleanse.determination
      end

      Ecleanse.unpause_scripts if @did_something

      sleep 0.2
    }
  end

  unless Ecleanse.data
    waitrt?
    Ecleanse.load(Ecleanse.load_settings)
  end

  if Script.current.vars[0] =~ /^setup$/i
    Setup.new(Ecleanse.load_settings).start
    Ecleanse.save_settings(Ecleanse.data)
    exit
  elsif Script.current.vars[0] =~ /load/
    Ecleanse.load(Ecleanse.load_settings)
    exit
  elsif Script.current.vars[0] =~ /last disarm/
    Ecleanse.msg("yellow", " Last recorded disarm:  Room #{UserVars.last_disarm}.")
    exit
  end

  Ecleanse.deadmans_switch
  Ecleanse.start_up
end

# ToDo
# spell cleave
