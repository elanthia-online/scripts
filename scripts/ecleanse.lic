=begin
   A script that removes status affects and combines several previous separate scripts. Will cover dispels, disarmed, and other status effects. 
   Configuration can be accessed via ;ecleanse setup
        author: Deysh
  contributers: Tysong
          game: Gemstone
          tags: dispel, unpoison, undisease, disarmed, effects
       version: 1.0.3
           
  Improvements:
  v1.0.3 (2023-01-23)
    - bug fix in recover weapon
    
=end
=begin
  v1.0.2 (2023-01-22)
    - fixed regex for disarmed to not mistake hurled weapons
  v1.0.1 (2023-01-21)
    - add check for CMan.known?("Retreat") and stamina check for grounded debuff.
    - moved magical/grounded debuffs into separate method to only pause scripts if necessary
    - add Mindwipe and Pious Trial to dispellable debuffs
  v1.0.0 (2023-01-20)
    - Initial release
=end



module Ecleanse

  Ecleanse_version = '1.0.2'
  
  @@data ||= nil
  
  def self.data
    @@data
  end

  def self.go2(place)
    fput('unhide') if (hidden? || invisible?)

    return if Room.current.id == place

    if Room.current.id.nil?
        respond "Currently in an unmapped room - Need to go to #{place}"
    end
    
    Script.run('go2', "#{place} --disable-confirm", { quiet: true })
  end

  def self.deadmans_switch
    #Kill script if dead
    Thread.new { loop { Script.self.kill if dead?; sleep(5); }} 
  end

  def self.load_settings()
  
    dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
    poison = [114].map { |s| Spell[s] }.find { |s| s.known? }         
    disease = [113].map { |s| Spell[s] }.find { |s| s.known? }    
    webs = [906,417,209,119].map { |s| Spell[s] }.find { |s| s.known? }
 
    CharSettings['cleanse_magical']   = false unless dispel.known?
    CharSettings['cleanse_grounded']  = false unless CMan.known?("Retreat")
    CharSettings['cleanse_poison']    = false unless poison.known?
    CharSettings['cleanse_disease']   = false unless disease.known?
    CharSettings['avoid_webs']        = false unless webs.known?
        
    settings_hash = {
      :cleanse_magical      => CharSettings['cleanse_magical'],
      :cleanse_grounded     => CharSettings['cleanse_grounded'],
      :cleanse_poison       => CharSettings['cleanse_poison'],
      :cleanse_disease      => CharSettings['cleanse_disease'], 
      :recover_disarmed     => CharSettings['recover_disarmed'],    
      :avoid_webs           => CharSettings['avoid_webs'],     
      :stop_scripts         => CharSettings['stop_scripts'],
  
    }
         
    settings_hash[:script_list] = settings_hash[:stop_scripts].split(",")
    settings_hash[:script_list].push("go2") unless settings_hash[:script_list].include?("go2")
    
    settings_hash
  end

  def self.load(settings)
    @@data = settings
  end

  def self.save_settings(settings)   
    CharSettings['cleanse_magical'] = settings[:cleanse_magical]
    CharSettings['cleanse_grounded'] = settings[:cleanse_grounded]
    CharSettings['cleanse_poison'] = settings[:cleanse_poison]
    CharSettings['cleanse_disease'] = settings[:cleanse_disease]
    CharSettings['recover_disarmed'] = settings[:recover_disarmed]
    CharSettings['avoid_webs'] = settings[:avoid_webs]
    CharSettings['stop_scripts'] = settings[:stop_scripts]
  end

  class Setup < Gtk::Builder

    attr_accessor :settings

    @@categories = {
      general: {
        cleanse_magical:  { default: false },
        cleanse_grounded: { default: false },
        cleanse_poison:   { default: false },
        cleanse_disease:  { default: false },
        recover_disarmed: { default: false },
        avoid_webs:       { default: false },
        stop_scripts:     { default: '' },
        script_list:      { default: [] },
      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?
      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()
      @settings = settings
      # set default values if they don't exist
      @@categories.each do |_, data|
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end
      # remove settings that doesn't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }
      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3
      Gtk.queue do
      #  add_from_file("#{$data_dir}ecleanse.ui")
        add_from_string(Setup.ui)
        load_settings
        self['main'].keep_above = true
        self['main'].set_title "Ecleanse Setup v#{Ecleanse_version}"
        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    def self.ui
    
      '<?xml version="1.0" encoding="UTF-8"?><interface><requires lib="gtk+" version="3.20"/><object class="GtkWindow" id="main"><property name="width-request">510</property><property name="height-request">292</property><property name="can-focus">False</property><property name="title" translatable="yes">Ecleanse Setup</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="recover_disarmed"><property name="label" translatable="yes">Recover Disarmed Weapons</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will use 218 if active</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">6</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="cleanse_magical"><property name="label" translatable="yes">Cleanse Magical</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Attempts to cleanse - Confusion, Vertigo, Sounds, or Thought Lash using spells 417, 119, or 1218 if known</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="cleanse_poison"><property name="label" translatable="yes">Cure Poison</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses unpoison (114)</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="avoid_webs"><property name="label" translatable="yes">Attempt to dispel webs</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will try to cast (906, 417, 209, 119) if known</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">6</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="cleanse_disease"><property name="label" translatable="yes">Cure Disease</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses undisease (113)</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="cleanse_grounded"><property name="label" translatable="yes">Cleanse Grounded</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Attempts to clear Rooted or Pressed using Cman Retreat</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">13</property><property name="margin-end">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Scripts to Pause</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="stop_scripts"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-bottom">5</property><property name="width-chars">59</property><property name="placeholder-text" translatable="yes">list of scripts to pause eg - bigshot,eloot,awesome_script74</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="width">2</property>
      </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Scripts</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property>
      </object><packing><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes"> Intended to be run in the background  or as part of Bigshot\'s active hunting scripts </property><attributes><attribute name="style" value="italic"/>
      </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
      </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
             
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update
          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        elsif obj.class == Gtk::ComboBoxText
          @settings[key] = obj.active_text
        end
      end
    end

    def on_close_clicked
      Ecleanse.load(@settings)
      self['main'].destroy
    end

    def on_destroy
      Gtk.queue {   
        Ecleanse.load(@settings)
        @running = false 
      }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings
      Gtk.queue do
        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym
          next if (setting = Setup.get_setting(key)).nil?

          # set the default value
          poison = [114].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_poison")) && poison.nil?
         
          disease = [113].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_disease")) && disease.nil?

          dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_magical")) && dispel.nil?

          webs = [906,417,209,119].map { |s| Spell[s] }.find { |s| s.known? }
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("avoid_webs")) && webs.nil?
          
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("cleanse_grounded")) && !CMan.known?("Retreat")  
        
          # obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("rogue_password")) && Char.prof != "Rogue"
          # obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("use_seeking")) && Society.member !~ /Order of Voln/ && Society.rank !~ /26/

          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) }
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].strip
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::SpinButton
            obj.value = @settings[key]
            obj.adjustment.value = @settings[key]
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::ComboBoxText
            #Fixme: change to builder_name
            if @settings[key] == "Auto"
              item = 0
            elsif @settings[key] == "On"
              item = 1
            elsif @settings[key] == "Off"
              item = 2
            elsif @settings[key] == "1"
              item = 0
            elsif @settings[key] == "2"
              item = 1
            end

            obj.set_active(item) if item
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::TreeView
            if (store = self["#{key}_store"]).nil?
              respond "** failed to find store for treeview #{key}"
              next
            elsif setting[:load].nil?
              respond "** no :load defined #{key}"
              next
            end

            setting[:load].call(store, @settings[key])

            # setup the signals
            if (add = self["#{key}_add"]).nil?
              respond "** failed to find add for treeview #{key}"
              next
            elsif (delete = self["#{key}_delete"]).nil?
              respond "** failed to find delete for treeview #{key}"
              next
            elsif (entry = self["#{key}_entry"]).nil?
              respond "** failed to find entry for treeview #{key}"
              next
            end

            add.signal_connect('clicked') do
              if setting[:set].nil?
                respond "** no :set defined for #{key}"
                next
              elsif entry.text.empty?
                next
              end
              setting[:set].call(store, entry.text, @settings[key])
              setting[:load].call(store, @settings[key])
            end

            delete.signal_connect('clicked') do
              if setting[:delete].nil?
                respond "** no :delete defined for #{key}"
                next
              elsif (selected = obj.selection.selected).nil?
                next
              end
              setting[:delete].call(store, selected, @settings[key])
              setting[:load].call(store, @settings[key])
            end
          end
        end

        # checkboxes for array storage with id's <setting>:<value>
        # this is primarily used by the loot types
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)
          next unless obj.builder_name =~ /^([^:]+):(.*)$/i
          next unless obj.class == Gtk::CheckButton

          key = Regexp.last_match(1).to_sym
          value = Regexp.last_match(2).to_s
         # echo "key: #{key} value: #{value}"
          next if Setup.get_setting(key).nil?
          #echo @settings[key].include?(value)
          obj.active = @settings[key].include?(value)

          # add in hook
          obj.signal_connect('toggled') do
            @settings[key].delete(value)
            if obj.active?
              @settings[key].push(value)
              @settings[key].uniq!.sort!
            end
          end
        end
      end
    end

    def start
      @running = true
      Gtk.queue { self['main'].show_all }
      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[general internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def self.update_setting(key, value)
      setting = Setup.get_setting(key)
      echo "** Setting #{key.inspect} does not exist" if setting.nil?
      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        echo" Reset #{key}"
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          echo " #{value.inspect} removed from #{key.inspect}"
        else
          @settings[key].push(value)
        echo  " #{value.inspect} added to #{key.inspect}"
        end

      echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        echo "#{key.inspect} has been set to #{value.inspect}"
        @settings[key] = value
      end
    end
  end

  def self.pause_scripts     
    Ecleanse.data[:script_list].each { |script| Script.pause(script) if Script.running?(script) }
  end

  def self.unpause_scripts
    Ecleanse.data[:script_list].each { |script| Script.unpause(script) if Script.paused?(script) } 
  end
 
  def self.remove_poison
  
    if !Spell[114].affordable?
      dothistimeout "mana pulse", 2, /An invigorating rush of mana pulses through you|You are too mentally fatigued to attempt this ability/
    end
  
    return unless Spell[114].affordable?
  
    Ecleanse.pause_scripts
        
    if Spell[114].affordable?
      Spell[114].cast
      sleep 0.5
      waitcastrt? 
    end
   
    Ecleanse.unpause_scripts
  end
  
  def self.remove_disease
  
    if !Spell[113].affordable?
      dothistimeout "mana pulse", 2, /An invigorating rush of mana pulses through you|You are too mentally fatigued to attempt this ability/
    end
    
    return unless Spell[113].affordable?
  
    Ecleanse.pause_scripts
    
    until !checkdisease || !Spell[113].affordable?
      Spell[113].cast
      sleep 0.5
      waitcastrt? 
    end
 
    Ecleanse.unpause_scripts
  end
  
  def self.remove_stun
     
    return unless (Spell[1040].known? && Spell[1040].affordable?) || (CMan.known?("Berserk") && checkstamina(21))  || (CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers.to_i > 2) || (Spell[605].known? && !Effects::Cooldowns.active?("Barkskin: Commune") && !Spell[605].active? && Skills.slblessings >= 15)
  
    Ecleanse.pause_scripts
  
    if Spell[1040].known?
      if !Spell[1040].affordable?
        dothistimeout "mana pulse", 2, /An invigorating rush of mana pulses through you|You are too mentally fatigued to attempt this ability/
      end
      if Spell[1040].affordable?
        fput "shout 1040"
      end
    elsif CMan.known?("Berserk") && checkstamina(21)
      Spell[9607].cast
      sleep 1
      wait_until { !Spell[9607].active? }
    elsif CMan.known?("Stun Maneuvers")
      if CMan.stun_maneuvers.to_i > 2 && !checkstanding
        fput "stun stand"
      end
      if CMan.stun_maneuvers.to_i > 4 && checkstanding
        fput "stun flee"
      end
    elsif Spell[605].known? && !Effects::Cooldowns.active?("Barkskin: Commune") && !Effects::Cooldowns.active?("Barkskin") && !Spell[605].active? && Skills.slblessings >= 15
      if !Spell[605].affordable?
        dothistimeout "mana pulse", 2, /An invigorating rush of mana pulses through you|You are too mentally fatigued to attempt this ability/
      end
      waitrt?
      fput "commune barkskin" if stunned?
      sleep(2)  
    end
    
    Ecleanse.unpause_scripts
  
  end
  
  def self.magical_grounded
  
    dispellable_debuffs = ["Confusion", "Vertigo", "Sounds", "Thought Lash", "Mindwipe", "Pious Trial"]
    grounded_debuffs = ["Rooted", "Pressed"]
    dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
  
    #Return if we don't know how to do dispel or retreat
    return if dispel.nil? && !CMan.known?("Retreat")
      
    #Check what kind of debuff
    dispellable_debuffs.each { |debuff|
      if Effects::Debuffs.active?(debuff) and !dispel.nil?
        Ecleanse.pause_scripts
        if !dispel.affordable?
          dothistimeout "mana pulse", 2, /An invigorating rush of mana pulses through you|You are too mentally fatigued to attempt this ability/
        end
        dispel.force_incant(arg_options = "channel open") if dispel.affordable?     
      end
    }
    
    grounded_debuffs.each { |debuff|
      if Effects::Debuffs.active?(debuff) && CMan.known?("Retreat") && checkstamina(11) 
          Ecleanse.pause_scripts
          waitrt?
          waitcastrt?
          fput "stand" until checkstanding
          fput "cman retreat"  
      end
    }
    
    Ecleanse.unpause_scripts
    
  end
  
  def self.remove_web_bound
    
    if Spell[1040].known? && !Spell[1040].affordable?
      dothistimeout "mana pulse", 2, /An invigorating rush of mana pulses through you|You are too mentally fatigued to attempt this ability/
    end
    
    return unless (Spell[1040].known? && Spell[1040].affordable?) || (CMan.known?("Berserk") && checkstamina(21))
    
    Ecleanse.pause_scripts
  
    if Spell[1040].known? and Spell[1040].affordable?
      fput "shout 1040"
    elsif CMan.known?("Berserk") && checkstamina(21)
      Spell[9607].cast
      sleep 1
      wait_until { !Spell[9607].active? }
    elsif CMan.known?("Spell Cleave") && checkstamina(10)
      fput "cman scleave"
    elsif CMan.known?("Spell Thieve") && checkstamina(10)
      fput "cman sthieve"
    
    end
   
    Ecleanse.unpause_scripts
   
  end
   
  def self.set_hooks
    @disarmed = false
    @recover_room = nil
    @recover_title = nil
    @current_right = nil
    @current_left = nil
    
    disarm_status = proc { |server|
      if server =~ /Use the <d>RECOVER ITEM<\/d> command while in the appropriate room to regain your item./i
        @disarmed = true
        @recover_room = Room.current.id
        @recover_title = Room.current.title
      end
      server
		}								
		DownstreamHook.add('disarm_status', disarm_status)
  
    before_dying { DownstreamHook.remove('disarm_status') }
  
  end
  
  def self.recover(right,left)
  
    Ecleanse.pause_scripts
    
    sanct = [213, 1011].map { |s| Spell[s] }.find { |s| s.known? }
 
    look_for = GameObj.right_hand != right ? right : left
  
    echo "########## DISARMED!!! ##########"
    echo "## Room#: #{@recover_room}"
    echo "## Room Name: #{@recover_title}"
    echo "## Looking for: #{look_for.name}"
    echo "########## DISARMED!!! ##########"
    
    Ecleanse.go2(@recover_room)
    
    waitrt?
    
    sanct.cast if !sanct.nil? && sanct.affordable? && !sanct.active?
    waitcastrt?
    
    line = nil
    if Spell[218].active?
      line = dothistimeout "tell servant recover", 5, /flickers for a moment and manifests|has no personal recollection/
      if line =~ /flickers for a moment and manifests/
        servant_recover = true 
      else
        servant_recover = false
      end
      if servant_recover
        @disarmed = false
        @recover_room = nil
        @recover_title = nil
        return
      end
    end
    
  
    if Spell[619].known? && Spell[619].affordable? #mass calm
			fput "release" unless checkprep("None")
      Spell[619].cast
		elsif Spell[709].known? && Spell[709].affordable?#grasp of the grave
			fput "release" unless checkprep("None")
      Spell[709].cast		
		elsif Spell[9811].known? #symbol of sleep
			fput "sym of sleep"
    elsif short_buff = [140, 919].map { |s| Spell[s] }.find { |s| s.known? }
      fput "release" unless checkprep("None")
      Spell[short_buff].cast
		end
  
    fput "stance defensive"
		line = nil
		empty_hands
		until line =~ /You spy (?:an|a) (?:.*) and recover it\!/
			until(kneeling?)
				waitrt?
				fput "kneel"
				exit if checkdead
			end
			waitrt?
			line = dothistimeout "recover item", 5, /You find nothing recoverable\.|You spy (?:an|a) (?:.*) and recover it\!|...wait (?:.*) seconds\./
		end
    
    @disarmed = false
    @recover_room = nil
    @recover_title = nil
		waitrt?
		fill_hands
    
    fput "stand" until(standing?)
    waitrt?
    fput "stop #{sanct.num}" if !sanct.nil? && sanct.active?
    
    Ecleanse.unpause_scripts
    
    return true
    
  end
  
  def self.start_up
     
    Ecleanse.set_hooks if CharSettings['recover_disarmed']
    
    webs = [906,417,209,119,1218].map { |s| Spell[s] }.find { |s| s.known? }
       
    loop{
    
      if checkpoison && CharSettings['cleanse_poison']
        Ecleanse.remove_poison
      end
      
      if checkdisease && CharSettings['cleanse_disease']
        Ecleanse.remove_disease
      end
      
      if checkstunned       
        Ecleanse.remove_stun 
      end
      
      if checkwebbed || checkbound       
        Ecleanse.remove_web_bound 
      end
      
      if !Effects::Debuffs.to_h.empty? && (CharSettings['cleanse_magical'] || CharSettings['cleanse_grounded'])
        Ecleanse.magical_grounded
      end
      
      if CharSettings['avoid_webs']
        if web = GameObj.loot.find { |l| l.name =~ /web/i }
          Ecleanse.pause_scripts
          webs.cast("at #{web}") if webs.affordable?	
          Ecleanse.unpause_scripts
        end
      end
      
      if CharSettings['recover_disarmed']
        @current_right = GameObj.right_hand unless GameObj.right_hand.name == "Empty"
        @current_left = GameObj.left_hand unless GameObj.left_hand.name == "Empty"
        
        if @disarmed
          Ecleanse.recover(@current_right,@current_left)
        end  
               
      end
         
      sleep 0.5
     }
  
  end
  
  unless Ecleanse.data
    waitrt?
    Ecleanse.load(Ecleanse.load_settings) 
  end

  
  if Script.current.vars[0] =~ /^setup$/i
    Setup.new(Ecleanse.load_settings).start
    Ecleanse.save_settings(Ecleanse.data)
    exit
  end
 
  Ecleanse.deadmans_switch
  Ecleanse.start_up
 
end



#ToDo
#spell cleave




