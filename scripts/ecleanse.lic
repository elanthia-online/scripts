=begin
   A script that removes status affects and combines several previous separate scripts. Will cover dispels, disarmed, and other status affects.
   Configuration can be accessed via ;ecleanse setup
        author: Deysh
  contributors: Tysong
          game: Gemstone
          tags: dispel, unpoison, undisease, disarmed, effects
      required: Lich >= 5.8.0
       version: 2.0.1

  Improvements:
  v2.0.1  (2025-03-12)
    - bugfix for stunman hide/flee/stand to not repeat if no longer stunned
  v2.0.0  (2025-03-09)
    - Lich version now required to be >= 5.8.0
    - update UI to use yaml to save settings
    - removed custom issue_command method for Lich method
    - bugfix for stun maneuvers
  v1.1.5  (2025-03-08)
    - bugfix to prevent constant stunman hide usage when stunned and successful hide
  v1.1.4  (2025-02-25)
    - bugfix to use UID for SOS vat cleansing
  v1.1.3  (2024-09-24)
    - bugfix for Unholy Quickening not breaking out of routine
  v1.1.2  (2024-09-11)
    - more Wall of Thorns bugfix
  v1.1.1  (2024-09-03)
    - bugfix to include Wall of Thorns poison checking
  v1.1.0  (2024-08-18)
    - refactor of the queue process to improve disarm response
    - added help section
    - updated issue_command method to mirror Lich
  v1.0.19 (2024-08-06)
    - add chaotic spatial anomaly to dispelable items (found in HW by gigas disciples)
  v1.0.18 (2024-08-04)
    - fix disarm not waiting for bonded weapon
  v1.0.17 (2024-05-01)
    - fix for Char.level -> Stats.level
    - fix for Char.prof -> Stats.prof
  v1.0.16 (2023-11-24)
    - bugfix for stun recover - check to make sure not in a belly or innards
    - added check for silvery blue globe and spiraling ghostly rift in Moonsedge
    - added check for disarm maneuver in Moonsedge and Sanctum
    - added check for Sanctum disease needing the vat
=end
=begin
  v1.0.15 (2023-08-23)
    - Bugfix for cman retreat if current target != creature that caused grounded debuff
  v1.0.14 (2023-04-13)
    - Bugfix for disarm recovery
  v1.0.13 (2023-04-06)
    - Bugfix for regex comparison of an integer in Ruby 3.2+, force convert .to_s
  v1.0.12 (2023-03-27)
    - added standing check for "channel open" casting
  v1.0.11 (2023-03-11)
    - added multiple searches for recover item
  v1.0.10 (2023-03-07)
    - removed 906 from web dispell
    - added Powersink to dispell debuffs
  v1.0.9 (2023-02-12)
    - added wound eval for spell casting
    - added a wait for spirit servants in disarm recovery
    - add some error checking to disarm recovery
  v1.0.8 (2023-02-10)
    - bug fix for incorrect method name during spirit servant recovery
  v1.0.7 (2023-02-07)
    - bug fix for web check to avoid custom disks
  v1.0.6 (2023-01-31)
    - bug fix for magical_grounded method if either option is checked
  v1.0.5 (2023-01-31)
    - bug fix for weapon disarm section
  v1.0.4 (2023-01-24)
    - bug fix in remove stuff for barkskin check
    - update 1011 casting so it doesn't repeat
    - added support for sigil of determination
  v1.0.3 (2023-01-23)
    - bug fix in recover weapon
  v1.0.2 (2023-01-22)
    - fixed regex for disarmed to not mistake hurled weapons
  v1.0.1 (2023-01-21)
    - add check for CMan.known?("Retreat") and stamina check for grounded debuff.
    - moved magical/grounded debuffs into separate method to only pause scripts if necessary
    - add Mindwipe and Pious Trial to dispellable debuffs
  v1.0.0 (2023-01-20)
    - Initial release
=end

# Check version of Lich for compatibility
lich_gem_requires = '5.8.0'

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires)
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
    _respond "##" + "########################################"
  end
  exit
end

require 'yaml'
require 'terminal-table'

# Data Class
module Ecleanse
  class Data
    attr_accessor :settings, :did_something, :event_stack, :disaease, :dispel, :poison, :web

    def initialize(settings)
      @settings = settings
      @did_something = false
      @event_stack = []

      @disease = [113].map { |s| Spell[s] }.find { |s| s.known? }
      @dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
      @poison = [114].map { |s| Spell[s] }.find { |s| s.known? }
      @webs = [209, 417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

      @settings[:script_list] = @settings[:stop_scripts].split(",").map(&:strip)
      @settings[:script_list] << "go2" unless @settings[:script_list].include?("go2")
    end
  end
end

# UI Setup
module Ecleanse
  class Setup < Gtk::Builder
    attr_accessor :settings

    @@categories = {
      general: {
        cleanse_magical: { default: false },
        cleanse_grounded: { default: false },
        cleanse_poison: { default: false },
        cleanse_disease: { default: false },
        recover_disarmed: { default: false },
        dispel_clouds: { default: false },
        dispel_magic: { default: false },
        avoid_webs: { default: false },
        use_berserk_webbed: { default: false },
        stop_scripts: { default: '' },
        script_list: { default: [] },
        determination: { default: false },
        use_stunned_barkskin: { default: false },
        use_berserk_stunned: { default: false },
        use_stunned1040: { default: false },
        use_stance1: { default: false },
        use_stance2: { default: false },
        use_flee: { default: false },
        use_hide: { default: false },
        use_709: { default: false },
        use_619: { default: false },
        use_213: { default: false },
        use_1011: { default: false },
        use_9811: { default: false },
        use_140: { default: false },
        use_919: { default: false },
        version: { default: '' },
      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?

      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()
      @settings = settings
      @silent_exit = false

      # Capture starting settings
      @original_settings = Marshal.load(Marshal.dump(settings))

      # Get script version
      version = Util.get_script_version
      @settings[:version] = version

      # set default values if they don't exist
      @@categories.each do |_, data|
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end

      # remove settings that don't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }

      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        # add_from_file("#{$data_dir}ecleanse.ui")
        add_from_string(Setup.ui)
        load_settings
        self['main'].keep_above = true
        self['main'].set_title "Ecleanse Setup v#{version}"
        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    def self.ui
      '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkWindow" id="main"><property name="width-request">550</property><property name="height-request">625</property><property name="can-focus">False</property><property name="title" translatable="yes">Ecleanse Setup</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">13</property><property name="margin-end">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Scripts to Pause</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="stop_scripts"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-bottom">5</property><property name="width-chars">59</property><property name="placeholder-text" translatable="yes">list of scripts to pause eg - bigshot, eloot, go2</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="width">2</property>
      </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Scripts</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="recover_disarmed"><property name="label" translatable="yes">Recover Disarmed Weapons</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will use 218 if active</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="cleanse_magical"><property name="label" translatable="yes">Cleanse Magical</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Attempts to cleanse - Confusion, Vertigo, Sounds, or Thought Lash using spells 417, 119, or 1218 if known</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="cleanse_poison"><property name="label" translatable="yes">Cure Poison</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses unpoison (114)</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="avoid_webs"><property name="label" translatable="yes">Dispel Webs</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">38</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="cleanse_disease"><property name="label" translatable="yes">Cure Disease</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses undisease (113)</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="cleanse_grounded"><property name="label" translatable="yes">Cleanse Grounded</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Attempts to clear Rooted or Pressed using Cman Retreat</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="determination"><property name="label" translatable="yes">Use Sigil of Determination</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="dispel_clouds"><property name="label" translatable="yes">Dispel Clouds</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">38</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="dispel_magic"><property name="label" translatable="yes">Dispel Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">38</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_berserk_webbed"><property name="label" translatable="yes">Use Berserk when Webbed</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="use_flee"><property name="label" translatable="yes">Stunman Flee</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">42</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_berserk_stunned"><property name="label" translatable="yes">Berserk</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_stunned1040"><property name="label" translatable="yes">Troubadour\'s Rally (1040)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="use_hide"><property name="label" translatable="yes">Stunman Hide</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">42</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_stance2"><property name="label" translatable="yes">Stunman Stance2</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">25</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_stance1"><property name="label" translatable="yes">Stunman Stance1</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">25</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_stunned_barkskin"><property name="label" translatable="yes">Barkskin (605)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Stun Recovery</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="use_9811"><property name="label" translatable="yes">Symbol of Sleep</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will use 218 if active</property><property name="halign">start</property><property name="margin-start">32</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_213"><property name="label" translatable="yes">Minor Sanctuary (213)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="use_140"><property name="label" translatable="yes">Wall of Force (140)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">24</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_919"><property name="label" translatable="yes">Wizard\'s Shield (919)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses undisease (113)</property><property name="halign">start</property><property name="margin-start">24</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_709"><property name="label" translatable="yes">Grasp of the Grave (709)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_619"><property name="label" translatable="yes">Mass Calm (619)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="use_1011"><property name="label" translatable="yes">Song of Peace (1011)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">32</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Cast in Room when Disarmed</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">3</property>
      </packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property></object><packing><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes">To save properly, exit with the close button and not the X window --&gt;</property><attributes><attribute name="style" value="italic"/>
      </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
      </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?

          if key == :use_stance1 && obj.active?
            self['use_stance2'].active = false
            @settings[:use_stance2] = false

            self['use_flee'].active = false
            @settings[:use_flee] = false

            self['use_hide'].active = false
            @settings[:use_hide] = false
          end

          if key == :use_stance2 && obj.active?
            self['use_stance1'].active = false
            @settings[:use_stance1] = false

            self['use_flee'].active = false
            @settings[:use_flee] = false

            self['use_hide'].active = false
            @settings[:use_hide] = false
          end

          if key == :use_flee && obj.active?
            self['use_stance1'].active = false
            @settings[:use_stance1] = false

            self['use_stance2'].active = false
            @settings[:use_stance2] = false

            self['use_hide'].active = false
            @settings[:use_hide] = false
          end

          if key == :use_hide && obj.active?
            self['use_stance1'].active = false
            @settings[:use_stance1] = false

            self['use_stance2'].active = false
            @settings[:use_stance2] = false

            self['use_flee'].active = false
            @settings[:use_flee] = false
          end
        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update
          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        elsif obj.class == Gtk::ComboBoxText
          @settings[key] = obj.active_text
        end
      end
    end

    def on_close_clicked
      if @original_settings == @settings
        respond
        Lich::Messaging.msg('plain', " Nothing to save. No changes were made.")
        respond
      else
        filename = File.join(DATA_DIR, XMLData.game, Char.name, 'ecleanse.yaml')
        File.write(filename, Ecleanse.data.settings.to_yaml)
        respond
        Lich::Messaging.msg('plain', " Settings saved to file: #{filename}.")
        respond
      end

      @silent_exit = true
      self['main'].destroy
    end

    def on_destroy
      Gtk.queue {
        unless @silent_exit
          respond
          Lich::Messaging.msg('plain', " #{@script_name} UI closed WITHOUT saving any changes")
          Lich::Messaging.msg('plain', " Be sure to use the close button to save changes")
          respond
        end
        @running = false
      }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings
      Gtk.queue do
        conditions = {
          "cleanse_disease"      => !Spell[113].known?,
          "cleanse_poison"       => !Spell[114].known?,
          "use_berserk_webbed"   => !CMan.known?("Berserk"),
          "determination"        => !Spell["Sigil of Determination"].known?,
          "cleanse_grounded"     => !CMan.known?("Retreat"),
          "cleanse_magical"      => [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }.nil?,
          "dispel_clouds"        => [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }.nil?,
          "dispel_magic"         => [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }.nil?,
          "avoid_webs"           => [209, 417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }.nil?,
          "use_stunned_barkskin" => !Spell[605].known?,
          "use_berserk_stunned"  => !CMan.known?("Berserk"),
          "use_stunned1040"      => !Spell[1040].known?,
          "use_stance1"          => CMan.stun_maneuvers < 2,
          "use_stance2"          => CMan.stun_maneuvers < 4,
          "use_flee"             => CMan.stun_maneuvers < 5,
          "use_hide"             => CMan.stun_maneuvers < 5,
          "use_709"              => !Spell[709].known?,
          "use_619"              => !Spell[619].known?,
          "use_213"              => !Spell[213].known?,
          "use_1011"             => !Spell[1011].known?,
          "use_9811"             => !Spell[9811].known?,
          "use_140"              => !Spell[140].known?,
          "use_919"              => !Spell[919].known?,
        }

        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym
          builder_name = obj.builder_name
          next if (Setup.get_setting(key)).nil?

          # disable options and set them to false if the character can't do them
          if conditions[builder_name]
            obj.set_sensitive(false)
            self[builder_name].active = false
            @settings[key] = false
          end

          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) }
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].strip
            obj.signal_connect('changed') { on_update(obj) }
          end
        end
      end
    end

    def start
      @running = true
      Gtk.queue { self['main'].show_all }
      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[general internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def self.update_setting(key, value)
      setting = Setup.get_setting(key)
      echo "** Setting #{key.inspect} does not exist" if setting.nil?
      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        echo " Reset #{key}"
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          echo " #{value.inspect} removed from #{key.inspect}"
        else
          @settings[key].push(value)
          echo " #{value.inspect} added to #{key.inspect}"
        end

        echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        echo "#{key.inspect} has been set to #{value.inspect}"
        @settings[key] = value
      end
    end
  end
end

# Load/Save profiles
module Ecleanse
  @@data ||= nil

  def self.data
    @@data
  end

  def self.load(settings)
    @@data = Data.new(settings)
  end

  def self.load_defaults
    {
      :cleanse_magical      => CharSettings['cleanse_magical'] || false,
      :cleanse_grounded     => CharSettings['cleanse_grounded'] || false,
      :cleanse_poison       => CharSettings['cleanse_poison'] || false,
      :cleanse_disease      => CharSettings['cleanse_disease'] || false,
      :recover_disarmed     => CharSettings['recover_disarmed'] || false,
      :dispel_clouds        => false,
      :dispel_magic         => false,
      :avoid_webs           => CharSettings['avoid_webs'] || false,
      :use_berserk_webbed   => false,
      :stop_scripts         => CharSettings['stop_scripts'] || '',
      :script_list          => [],
      :determination        => CharSettings['determination'] || false,
      :use_stunned_barkskin => false,
      :use_berserk_stunned  => false,
      :use_stunned1040      => false,
      :use_stance1          => false,
      :use_stance2          => false,
      :use_flee             => false,
      :use_hide             => false,
      :use_709              => false,
      :use_619              => false,
      :use_213              => false,
      :use_1011             => false,
      :use_9811             => false,
      :use_140              => false,
      :use_919              => false,
      :version              => '',
    }
  end

  def self.load_profile
    filename = File.join(DATA_DIR, XMLData.game, Char.name, 'ecleanse.yaml')

    if File.exist?(filename)
      settings_hash = YAML.load_file(filename)
    else
      settings_hash = Ecleanse.load_defaults
    end

    return settings_hash
  end
end

# Main Script Methods
module Ecleanse
  module Action
    def self.avoid_webs(web)
      return unless Ecleanse.data.settings[:avoid_webs]
      return unless Util.able_to_cast

      # Return if we don't know how to do cast those
      return if Ecleanse.data.webs.nil?

      System.scripts_pause

      Action.mana_pulse(Ecleanse.data.webs.num)

      Ecleanse.data.webs.cast("at #{web}") if Ecleanse.data.webs.affordable?
    end

    def self.avoid_globe(globe)
      return unless Ecleanse.data.settings[:dispel_magic]
      return unless Util.able_to_cast

      # Return if we don't know how to do cast those
      return if Ecleanse.data.dispel.nil?

      Action.mana_pulse(Ecleanse.data.dispel.num)

      System.scripts_pause
      Ecleanse.data.dispel.cast("at #{globe}") if Ecleanse.data.dispel.affordable?
    end

    def self.change_stance(new_stance)
      return if Effects::Debuffs.active?("Frenzy") || dead?
      return if percentstance == new_stance
      return if new_stance == 100 && percentstance(80)

      stances = {
        0   => 'offensive',
        20  => 'advanced',
        40  => 'forward',
        60  => 'neutral',
        80  => 'guarded',
        100 => 'defensive'
      }

      if CMan.available?('Stance Perfection') && ![0, 20, 40, 60, 80, 100].include?(new_stance)
        cmd = "cman stance #{new_stance}"
      elsif stances[new_stance]
        cmd = "stance #{stances[new_stance]}"
      else
        cmd = 'stance defensive'
      end

      expiry = Time.now + 2
      while percentstance != new_stance
        res = dothistimeout(cmd, 2, /You are now|You move into|Roundtime|wait|Your rage causes you/i)
        if res =~ /Roundtime: (\d+)|wait (\d+)/i
          sleep((Regexp.last_match(1) || Regexp.last_match(2)).strip.to_f - 1)
          expiry = Time.now + 2
        elsif Time.now > expiry
          break
        else
          break
        end
        sleep 0.5
      end
    end

    def self.determination
      return unless Ecleanse.data.settings[:determination]
      return unless Spell["Sigil of Determination"].known? && Spell["Sigil of Determination"].affordable?
      return if Effects::Buffs.active?("Sigil of Determination")

      System.scripts_pause
      Spell["Sigil of Determination"].cast if Spell["Sigil of Determination"].affordable?
    end

    def self.dispel_cloud(cloud)
      return unless Ecleanse.data.settings[:dispel_clouds]
      return unless Util.able_to_cast

      Action.mana_pulse(Ecleanse.data.dispel)

      System.scripts_pause
      Ecleanse.data.dispel.cast("at #{cloud}") if Ecleanse.data.dispel.affordable?
    end

    def self.go2(place)
      fput('unhide') if (hidden? || invisible?)

      return if Room.current.id == place

      if Room.current.id.nil?
        respond "Currently in an unmapped room - Need to go to #{place}"
        return
      end

      Script.run('go2', "#{place} --disable-confirm", { quiet: true, force: true })
    end

    def self.mana_pulse(spell_id)
      return unless Spell[spell_id].known? && !Spell[spell_id].affordable?

      mana_regex = Regexp.union(
        /An invigorating rush of mana pulses through you/i,
        /You are too mentally fatigued to attempt this ability/i,
        /You're already at full mana./i,
        /Your mana control skills are not yet advanced/i,
      )

      dothistimeout "mana pulse", 2, mana_regex
      sleep 0.2
    end

    def self.recover(item, room_id, title)
      # standard disarm mechanics

      return unless Ecleanse.data.settings[:recover_disarmed]
      System.scripts_pause

      stop_213 = false
      stop_1011 = false

      Util.msg("yellow", " ########## DISARMED!!! ##########")
      Util.msg("yellow", " ## Room#: #{room_id}")
      Util.msg("yellow", " ## Room Name: #{title.first}")
      Util.msg("yellow", " ## Looking for: #{item}")
      Util.msg("yellow", " ########## DISARMED!!! ##########")
      UserVars.last_disarm = room_id
      Action.go2(room_id)

      Util.wait_rt

      if Util.able_to_cast
        if Spell[213].known? && Ecleanse.data.settings[:use_213]
          Action.mana_pulse(213)
          Spell[213].cast if Spell[213].affordable?
          stop_213 = true
        end

        if Spell[1011].known? && Ecleanse.data.settings[:use_1011]
          Action.mana_pulse(1011)
          Spell[1011].cast if Spell[1011].affordable?
          stop_1011 = true
        end
        Util.wait_rt
      end

      if Spell[218].active?
        15.times do
          break if (GameObj.npcs.find { |npc| npc.noun =~ /spirit/i })

          sleep(0.1)
        end

        line = dothistimeout "tell servant recover", 5, /flickers for a moment and manifests|has no personal recollection/
        if line =~ /flickers for a moment and manifests/
          servant_recover = true
        else
          servant_recover = false
        end
        if servant_recover
          lines = Util.get_lines("sense", /You open your soul to the lesser/)
          if lines.any? { |l| l =~ /An obvious presence of peace saturates the area and a feeling of safety overwhelms you/ }
            fput "stop 213"
          end

          return
        end
      end

      # Make the room safer.
      Action.settle_room

      # Sometimes bigshot sneaks in an eloot
      System.scripts_pause

      # Change to defensive stance
      Action.change_stance(100)

      # It might be a bonded weapon
      if Feat.weapon_bonding == 5 || Spell[1625].known? # Fixme: Making an assumption you'd be using the bonded weapon
        wait_time = Time.now + 10
        until [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item) || wait_time < Time.now
          Util.wait_rt
        end
      end

      unless [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item)
        empty_hands

        search_count = 0
        until search_count.eql?(10)

          until kneeling?
            dothistimeout("kneel", 2, /You kneel|You are already/i)
          end

          Util.wait_rt

          lines = Util.get_command("recover item", /<dialogData|You spy|You continue to intently search the area|In order to recover something|You find nothing recoverable/)

          if lines.grep(/You spy (?:an|a) (?:.*) and recover it\!/).any? || [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item)
            break
          end

          if lines.grep(/You're not in any condition to be searching around/).any?
            Util.msg("yellow", " Unable to search. Exiting ecleanse.")
            Util.msg("yellow", " #{item} is in room #{room_id}")
            fput "stand" until standing?
            System.scripts_resume
            exit
          end

          if lines.grep(/In order to recover something/).any?
            empty_hands
          end

          search_count += 1
        end

        Util.wait_rt
      end

      fput "stand" until standing?
      Util.wait_rt

      fput "stop 213" if stop_213
      fput "stop 1011" if stop_1011
    end

    def self.remove_disease
      return unless Ecleanse.data.settings[:cleanse_disease]
      return unless Spell[113].known? && Util.able_to_cast

      Action.mana_pulse(113)

      return unless Spell[113].affordable?

      System.scripts_pause

      until !checkdisease || !Spell[113].affordable?
        Spell[113].cast
        Util.wait_rt
      end
    end

    def self.remove_grounded
      return unless Ecleanse.data.settings[:cleanse_grounded]
      return unless CMan.known?("Retreat")

      grounded_debuffs = ["Rooted", "Pressed"]
      grounded_debuffs.each { |debuff|
        if Effects::Debuffs.active?(debuff) && checkstamina(11)
          System.scripts_pause
          Util.wait_rt
          fput "stand" until checkstanding
          Util.wait_rt
          current_target = XMLData.current_target_id
          fput 'target clear'
          fput 'cman retreat'
          fput "target ##{current_target}"
        end
      }
    end

    def self.remove_magical
      return unless Ecleanse.data.settings[:cleanse_magical]
      return unless Util.able_to_cast

      dispellable_debuffs = ["Confusion", "Vertigo", "Sounds", "Thought Lash", "Mindwipe", "Pious Trial", "Powersink"]

      # Return if we don't know how to do dispel
      return if Ecleanse.data.dispel.nil?

      Action.mana_pulse(Ecleanse.data.dispel.num)

      dispellable_debuffs.each { |debuff|
        if Effects::Debuffs.active?(debuff) and !Ecleanse.data.dispel.nil?
          System.scripts_pause

          Action.mana_pulse(Ecleanse.data.dispel.num)

          fput "stand" until checkstanding
          Util.wait_rt
          Ecleanse.data.dispel.force_incant("channel open") if Ecleanse.data.dispel.affordable?
        end
      }
    end

    def self.remove_poison
      return unless Ecleanse.data.settings[:cleanse_poison]
      return unless Spell[114].known? && Util.able_to_cast

      Action.mana_pulse(114)

      return unless Spell[114].affordable?

      System.scripts_pause

      loop do
        if Gem::Version.new(LICH_VERSION) >= Gem::Version.new("5.10.2")
          thorns_active = Status.thorned?
        else
          thorns_active = Effects::Debuffs.to_h.keys.any? { |key| key.to_s =~ /Wall of Thorns Poison/ }
        end

        # Break loop if neither debuff is present or spell is no longer affordable
        break if (!checkpoison && !thorns_active) || !Spell[114].affordable?

        # Cast the spell to cleanse
        Spell[114].cast
        Util.wait_rt

        # Optionally refresh debuff status for thorns (if needed)
        Util.get_lines("spell active debuff", /<dialogData id='Debuffs'/) if thorns_active
      end
    end

    def self.remove_stun
      Action.mana_pulse(1040) if Spell[1040].known? && Ecleanse.data.settings[:use_stunned1040]
      not_escape_rooms = checkroom("The Belly of the Beast").nil? && checkroom("Ooze, Innards").nil?

      barkskin = Ecleanse.data.settings[:use_stunned_barkskin] && Spell[605].known? && !Effects::Cooldowns.active?("Barkskin: Commune") && !Effects::Cooldowns.active?("Barkskin") && !Spell[605].active? && Skills.slblessings >= 15
      berserk = Ecleanse.data.settings[:use_berserk_stunned] && CMan.known?("Berserk") && checkstamina(21) && not_escape_rooms
      stunned1040 = Ecleanse.data.settings[:use_stunned1040] && Spell[1040].known? && Spell[1040].affordable?
      stance1 = Ecleanse.data.settings[:use_stance1] && CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers > 2 && checkstamina(10) && not_escape_rooms
      stance2 = Ecleanse.data.settings[:use_stance2] && CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers > 3 && checkstamina(10) && not_escape_rooms
      flee = Ecleanse.data.settings[:use_flee] && CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers > 4 && checkstamina(10) && not_escape_rooms
      hide = Ecleanse.data.settings[:use_hide] && CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers > 4 && checkstamina(10) && not_escape_rooms && !checkhidden

      return unless barkskin || berserk || stunned1040 || stance1 || stance2 || flee || hide

      System.scripts_pause

      if barkskin
        Action.mana_pulse(605)
        Util.wait_rt
        fput "commune barkskin" if stunned?
        sleep 0.1 until !checkstunned
      elsif berserk
        Spell[9607].cast
        sleep 1
        wait_until { !Spell[9607].active? }
      elsif stunned1040
        fput "shout 1040"
      elsif stance1
        Action.stunman_perform('stance1')
      elsif stance2
        Action.stunman_perform('stance2')
      elsif flee
        Action.stunman_perform('flee')
      elsif hide
        Action.stunman_perform('hide')
      end
    end

    def self.remove_web_bound
      return unless Ecleanse.data.settings[:avoid_webs]
      Action.mana_pulse(1040) if Spell[1040].known?

      spell_1040_ready = Spell[1040].known? && Spell[1040].affordable?

      berserk_ready = Ecleanse.data.settings[:use_berserk_webbed] && CMan.known?("Berserk") && checkstamina(21)
      spell_cleave_ready = CMan.known?("Spell Cleave") && checkstamina(10)
      spell_thieve_ready = CMan.known?("Spell Thieve") && checkstamina(10)

      return unless spell_1040_ready || berserk_ready || spell_cleave_ready || spell_thieve_ready

      System.scripts_pause

      if Spell[1040].known? and Spell[1040].affordable?
        fput "shout 1040"
      elsif CMan.known?("Berserk") && checkstamina(21)
        Spell[9607].cast
        sleep 1
        wait_until { !Spell[9607].active? }
      elsif CMan.known?("Spell Cleave") && checkstamina(10)
        fput "cman scleave"
      elsif CMan.known?("Spell Thieve") && checkstamina(10)
        fput "cman sthieve"

      end
    end

    def self.sanctum_recover(creature)
      # Unholy Quickening by Lithe Veiled Sentinels in the Sanctum
      return unless Ecleanse.data.settings[:recover_disarmed]
      System.scripts_pause

      Util.wait_rt

      # Make the room safer.
      Action.settle_room

      # Sometimes bigshot sneaks in an eloot
      System.scripts_pause

      # Change to defensive stance
      Action.change_stance(100)

      loop do
        result = Util.get_res("clench #{creature}")
        Util.wait_rt
        break if result =~ /You reach up and grab|I could not find what you were referring to./
      end
    end

    def self.settle_room
      return if GameObj.targets.empty?
      return unless Util.able_to_cast

      if Ecleanse.data.settings[:use_140] && Spell[140].known? && !Effects::Buffs.active?("Wall of Force") && !Effects::Cooldowns.active?("Wall of Force")
        Action.mana_pulse(140)
        Spell[140].cast if Spell[140].affordable?
      elsif Ecleanse.data.settings[:use_619] && Spell[619].known?
        Action.mana_pulse(619)
        Spell[619].cast if Spell[619].affordable?
      elsif Ecleanse.data.settings[:use_709] && Spell[709].known? && !GameObj.npcs.any? { |c| c.name =~ /^(?:arm|appendage|claw|limb|pincer|tentacle)s?$|^(?:palpus|palpi)$/i }
        Action.mana_pulse(709)
        Spell[709].cast if Spell[709].affordable?
      elsif Ecleanse.data.settings[:use_919] && !Effects::Buffs.active?("Wizard's Shield") && !Effects::Cooldowns.active?("Wizard's Shield")
        Action.mana_pulse(919)
        Spell[919].cast if Spell[919].affordable?
      elsif Ecleanse.data.settings[:use_9811] && Spell[9811].known?
        Spell[9811].cast
      end
    end

    def self.stunman_perform(type)
      Action.stunman_stand

      case type
      when 'stance1'
        fput 'stunman stance1'
      when 'stance2'
        fput 'stunman stance2'
      when 'flee'
        current_room = Room.current.id
        until Room.current.id != current_room || !checkstunned
          Action.stunman_stand
          fput "stunman flee"
          sleep 0.5
        end
      when 'hide'
        until checkhidden || !checkstunned
          fput "stunman hide"
          Util.wait_rt
        end
      end

      sleep 0.1 until !checkstunned
    end

    def self.stunman_stand
      until standing? || !checkstunned
        put "stunman stand"
        Util.wait_rt
      end
    end

    def self.telekinetic_recover(item)
      # Telekinetic Disarm is cast in Moonsedge - Savant spell 1406
      return unless Ecleanse.data.settings[:recover_disarmed]
      System.scripts_pause

      # Make the room safer.
      Action.settle_room

      # Sometimes bigshot sneaks in an eloot
      System.scripts_pause

      # Change to defensive stance
      Action.change_stance(100)

      until [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item)
        if Ecleanse.data.dispel.nil?
          fput "get #{item}"
        else
          Action.mana_pulse(Ecleanse.data.dispel.num)
          Ecleanse.data.dispel.cast("at #{item}") if Ecleanse.data.dispel.affordable?
        end

        lines = Util.get_lines("glance", /You glance/)
        break if lines.any? { |l| l =~ /#{item}/ }

        Util.wait_rt
      end
    end

    def self.use_vat
      # A bite/spit maneuver from a Shambling Lurk in the Sanctum
      System.scripts_pause

      current_room = Room.current.id
      vat_room = Room.ids_from_uid(4216054).first
      Action.go2(vat_room)

      Util.get_res("clean vat")
      Util.wait_rt

      Action.go2(current_room)
    end
  end

  module System
    def self.deadmans_switch
      # Kill script if dead
      Thread.new { loop { Script.self.kill if dead?; sleep(5); } }
    end

    def self.scripts_pause
      Ecleanse.data.settings[:script_list].each { |script| Script.pause(script) if Script.running?(script) }
      Ecleanse.data.did_something = true
    end

    def self.scripts_resume
      Ecleanse.data.settings[:script_list].each { |script| Script.unpause(script) if Script.paused?(script) }
      Ecleanse.data.did_something = false
    end

    def self.set_hooks
      ecleanse_status = proc { |server|
        if server =~ /Your <a exist=".*?" noun="(.*?)">.*?<\/a> is knocked from your grasp/
          item = Regexp.last_match(1)
          recover = Proc.new { Action.recover(item, Room.current.id, Room.current.title) }
          Ecleanse.data.event_stack.push(recover) unless Ecleanse.data.event_stack.include?(recover)
        elsif server =~ /Your <a exist=".*?" noun="(.*?)">.*?<\/a>tears free from your hands and floats/
          item = Regexp.last_match(1)
          telekinetic_recover = Proc.new { Action.telekinetic_recover(item) }
          Ecleanse.data.event_stack.push(telekinetic_recover) unless Ecleanse.data.event_stack.include?(telekinetic_recover)
        elsif server =~ /Striking with a serpent's unsettling quickness, (?:.*)\.  Vile (?:.*), kindling it into an unholy semblance of life.  The (?:.*) form twists and mutates, sprouting scales and cold eyes as it transforms into a <a exist="\d+" noun="([^"]+)">[^<]+<\/a>\!/
          creature = Regexp.last_match(1)
          sanctum_recover = Proc.new { Action.sanctum_recover(creature) }
          Ecleanse.data.event_stack.push(sanctum_recover) unless Ecleanse.data.event_stack.include?(sanctum_recover)
        elsif server =~ /The flesh around the wound feels hot and cold at the same time, heavy with infection./
          use_vat = Proc.new { Action.use_vat }
          Ecleanse.data.event_stack.push(use_vat) unless Ecleanse.data.event_stack.include?(use_vat)
        end
        server
      }
      DownstreamHook.add('ecleanse_status', ecleanse_status)

      before_dying {
        DownstreamHook.remove('ecleanse_status')
        Ecleanse.data.settings[:script_list].each { |script| Script.unpause(script) if Script.paused?(script) }
      }
    end
  end

  module Util
    def self.able_to_cast
      able_to_cast = true
      stacked_right_scar = 0
      stacked_right_wound = 0
      stacked_left_scar = 0
      stacked_left_wound = 0
      try_sigil = true

      XMLData.injuries.each { |area, h|
        next unless area =~ /nsys|head|(left|right)(Eye|Arm|Hand)/
        next unless (h['scar'].positive? || h['wound'].positive?)

        # echo area
        # echo "scar: #{h['scar']} wound: #{h['wound']}"
        if h['scar'] > 2 || h['wound'] > 2
          try_sigil = false # Sigil of Determination cannot ignore rank 3
          able_to_cast = false
          break
        elsif area =~ /nsys|head/ && (h['scar'] > 1 || h['wound'] > 1)
          able_to_cast = false
          break
        elsif area =~ /left(Arm|Hand)/
          stacked_left_scar += h['scar']
          stacked_left_wound += h['wound']
          if (stacked_left_scar > 1 || stacked_left_wound > 1)
            able_to_cast = false
            break
          end
        elsif area =~ /right(Arm|Hand)/
          stacked_right_scar += h['scar']
          stacked_right_wound += h['wound']
          if (stacked_right_scar > 1 || stacked_right_wound > 1)
            able_to_cast = false
            break
          end
        end
      }

      # Eval Sigil of Determination if known
      if !able_to_cast && try_sigil
        able_to_cast = Util.check_determination
      end

      return able_to_cast
    end

    def self.check_determination
      return false unless Ecleanse.data.settings[:determination]
      return false unless Spell["Sigil of Determination"].known?
      return false unless Spell["Sigil of Determination"].affordable?

      Action.determination unless Effects::Buffs.active?("Sigil of Determination")

      stacked_right_scar = 0
      stacked_right_wound = 0
      stacked_left_scar = 0
      stacked_left_wound = 0
      able_to_cast = true
      XMLData.injuries.each { |area, h|
        next unless area =~ /nsys|head|(left|right)(Eye|Arm|Hand)/

        if h['scar'] > 2 || h['wound'] > 2
          able_to_cast = false
        elsif area =~ /left(Arm|Hand)/
          stacked_left_scar += h['scar']
          stacked_left_wound += h['wound']
          if (stacked_left_scar > 2 || stacked_left_wound > 2)
            able_to_cast = false
            break
          end
        elsif area =~ /right(Arm|Hand)/
          stacked_right_scar += h['scar']
          stacked_right_wound += h['wound']
          if (stacked_right_scar > 2 || stacked_right_wound > 2)
            able_to_cast = false
            break
          end
        end
      }

      return able_to_cast
    end

    def self.get_command(command, regex)
      lines = []
      regex = Regexp.union(regex, /(?:\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

      loop do
        lines = Lich::Util.issue_command(command, regex)
        break unless lines.grep(/(?:\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

        Util.wait_rt
      end

      return lines
    end

    def self.get_lines(command, regex)
      lines = []
      regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

      loop do
        lines = Lich::Util.issue_command(command, regex, silent: true, quiet: true)
        break unless lines.grep(/(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

        Util.wait_rt
      end

      return lines
    end

    def self.get_res(command, regex = nil)
      rt_regex = /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./
      regex = regex.nil? ? Regexp.union(/.*?/, rt_regex) : Regexp.union(regex, rt_regex)
      result = nil
      loop do
        result = dothistimeout(command, 3, regex)
        break unless result =~ rt_regex

        Util.wait_rt
      end

      return result
    end

    def self.get_script_version
      data = Script.list.find { |x| x.name == Script.current.name }.inspect
      return data[/version: (\d+\.\d+\.\d+)/i, 1]
    end

    def self.help
      rows = []
      rows << ["#{$lich_char}#{Script.current.name} setup", "UI configuration tool"]
      rows << ["#{$lich_char}#{Script.current.name} load", "Reloads all settings"]
      rows << ["#{$lich_char}#{Script.current.name} list", "Lists all settings"]
      rows << ["#{$lich_char}#{Script.current.name} last disarm", "Lists last disarm room"]

      table = Terminal::Table.new :title => "#{Script.current.name.capitalize} ver #{Util.get_script_version}", :rows => rows
      respond
      respond table
      respond
    end

    def self.msg(type = info, text)
      # color options - set type to use
      # yellow, orange, teal, green, plain

      if text.class == Hash
        text = text.inspect.gsub("#<", "#")
      elsif text.class == Array
        text = text.to_s
      elsif text.class == String
        text = text.gsub("#<", "#")
      end

      type = type == "debug" ? "speech" : type

      Lich::Messaging.msg(type, text)
    end

    def self.wait_rt
      sleep 0.2
      waitcastrt?
      waitrt?
      sleep 0.2
    end
  end

  def self.main_loop
    loop do
      while Ecleanse.data.event_stack.any?
        current_event = Ecleanse.data.event_stack.shift
        current_event.call
      end

      if checkpoison || Effects::Debuffs.to_h.keys.any? { |key| key.to_s =~ /Wall of Thorns Poison/ }
        remove_poison = Proc.new { Action.remove_poison }
        Ecleanse.data.event_stack.push(remove_poison) unless Ecleanse.data.event_stack.include?(remove_poison)
      end

      if checkdisease
        remove_disease = Proc.new { Action.remove_disease }
        Ecleanse.data.event_stack.push(remove_disease) unless Ecleanse.data.event_stack.include?(remove_disease)
      end

      if checkstunned
        remove_stun = Proc.new { Action.remove_stun }
        Ecleanse.data.event_stack.push(remove_stun) unless Ecleanse.data.event_stack.include?(remove_stun)
      end

      if checkwebbed || checkbound
        remove_web_bound = Proc.new { Action.remove_web_bound }
        Ecleanse.data.event_stack.push(remove_web_bound) unless Ecleanse.data.event_stack.include?(remove_web_bound)
      end

      if Effects::Debuffs.to_h.any? { |debuff| debuff[0].to_s =~ /Rooted|Pressed/ }
        remove_grounded = Proc.new { Action.remove_grounded }
        Ecleanse.data.event_stack.push(remove_grounded) unless Ecleanse.data.event_stack.include?(remove_grounded)
      end

      if Effects::Debuffs.to_h.any? { |debuff| debuff[0].to_s =~ /Confusion|Vertigo|Sounds|Thought Lash|Mindwipe|Pious Trial|Powersink/ }
        remove_magical = Proc.new { Action.remove_magical }
        Ecleanse.data.event_stack.push(remove_magical) unless Ecleanse.data.event_stack.include?(remove_magical)
      end

      if (cloud = GameObj.loot.find { |l| l.name =~ /cloud/i })
        dispel_cloud = Proc.new { Action.dispel_cloud(cloud) }
        Ecleanse.data.event_stack.push(dispel_cloud) unless Ecleanse.data.event_stack.include?(dispel_cloud)
      end

      if (globe = GameObj.loot.find { |l| l.name =~ /silvery blue globe|spiraling ghostly rift|chaotic spatial anomaly/i })
        avoid_globe = Proc.new { Action.avoid_globe(globe) }
        Ecleanse.data.event_stack.push(avoid_globe) unless Ecleanse.data.event_stack.include?(avoid_globe)
      end

      if (web = GameObj.loot.find { |l| l.noun =~ /web|silvery blue globe|spiraling ghostly rift/i })
        avoid_webs = Proc.new { Action.avoid_webs(web) }
        Ecleanse.data.event_stack.push(avoid_webs) unless Ecleanse.data.event_stack.include?(avoid_webs)
      end

      if Ecleanse.data.settings[:determination] && (XMLData.injuries["leftHand"]["wound"] > 1 || XMLData.injuries["rightHand"]["wound"] > 1 || XMLData.injuries["leftArm"]["wound"] > 1 || XMLData.injuries["rightArm"]["wound"] > 1 || XMLData.injuries["leftEye"]["wound"] > 1 || XMLData.injuries["rightEye"]["wound"] > 1 || XMLData.injuries["nsys"]["wound"] > 1 || XMLData.injuries["head"]["wound"] > 1)
        determination = Proc.new { Action.determination }
        Ecleanse.data.event_stack.push(determination) unless Ecleanse.data.event_stack.include?(determination)
      end

      System.scripts_resume if Ecleanse.data.did_something
      sleep 0.2
    end
  end

  unless Ecleanse.data
    Ecleanse.load(Ecleanse.load_profile)
  end

  case Script.current.vars[0]
  when /^setup$/i
    Setup.new(Ecleanse.data.settings).start
    Ecleanse.load(Ecleanse.load_profile)
  when /load/
    Ecleanse.load(Ecleanse.load_profile)
  when /list/
    Ecleanse::Setup.new(Ecleanse.data).list
  when /last disarm/
    Util.msg("yellow", " Last recorded disarm:  Room #{UserVars.last_disarm}.")
  when nil
    if Ecleanse.data.settings[:version] != Util.get_script_version
      respond
      Util.msg("yellow", "You are using a new version of ecleanse. Some of the options have changed.")
      Util.msg("yellow", "Please run setup to review your settings.")
      respond
    end
    Ecleanse.data.did_something = false
    Ecleanse.data.event_stack = []
    Ecleanse::System.deadmans_switch
    Ecleanse::System.set_hooks
    Ecleanse.main_loop
  else
    Ecleanse::Util.help
  end
end

# ToDo
# spell cleave
