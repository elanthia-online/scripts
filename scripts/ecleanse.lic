=begin
   A script that removes status affects and combines several previous separate scripts. Will cover dispels, disarmed, and other status affects.
   Configuration can be accessed via ;ecleanse setup
        author: Deysh
  contributors: Tysong
          game: Gemstone
          tags: dispel, unpoison, undisease, disarmed, effects
      required: Lich >= 5.11.1
       version: 2.2.5

  Improvements:
  v2.2.5  (2025-10-27)
    - bugfix in hive apparatus trap disarm regex when no trap
  v2.2.4  (2025-10-01)
    - disarm messaging for hisska warriors
    - hive traps search logic updates
    - hive_trap_room additional monitor strings
  v2.2.3  (2025-08-24)
    - bugfix in list output
    - bugfix in not saving current version to settings
    - bugfix in disarm regex for noun having spaces, aka Hammer of Kai
  v2.2.2  (2025-07-04)
    - bugfix in allowing berserk when webbed to actually work
  v2.2.1  (2025-06-21)
    - allow dispel magic and dispel webs to be toggled if Spell Cleave or Spell Thieve known.
  v2.2.0  (2025-04-23)
    - add support for Covert Arts: Escape Artist
    - determine whether web/globe/cloud is targetable to avoid dispelling player versions
    - track web/globe/cloud ids to not retry casting again via CappedCollection
    - remove spell cleave/thieve from bound/web removal, added to cloud/web/globe avoidance
    - bugfix for hive trap/apparatus to not search unless actual room detected for them
    - bugfix add Red Forest fog to invalid cloud check
    - bugfix in telekinetic disarm xml matching
  v2.1.1  (2025-04-18)
    - fix for Moonsedge bind not triggering properly in XML
    - add Paladin 1635 beseech support in remove_stun and remove_web_bound
  v2.1.0  (2025-03-16)
    - added Hive traps
    - added kiramon weapon-webbing
    - added kiramon disarm recovery
    - added bony protrusion disarm recovery
    - added itchy curse support
  v2.0.4  (2025-03-16)
    - bugfix for cloud dispel against gems with cloud in name
  v2.0.3  (2025-03-13)
    - bugfix in Char.percent_stance
  v2.0.2  (2025-03-12)
    - bugfix Ecleanse.data variable names
    - fix Lich5 API calls to non-deprecated calls
    - removed version change announcement
    - bugfix for cloud dispel against Wyrm and Sybil
  v2.0.1  (2025-03-12)
    - bugfix for stunman hide/flee/stand to not repeat if no longer stunned
  v2.0.0  (2025-03-09)
    - Lich version now required to be >= 5.8.0
    - update UI to use yaml to save settings
    - removed custom issue_command method for Lich method
    - bugfix for stun maneuvers
  v1.1.5  (2025-03-08)
    - bugfix to prevent constant stunman hide usage when stunned and successful hide
  v1.1.4  (2025-02-25)
    - bugfix to use UID for SOS vat cleansing
  v1.1.3  (2024-09-24)
    - bugfix for Unholy Quickening not breaking out of routine
  v1.1.2  (2024-09-11)
    - more Wall of Thorns bugfix
  v1.1.1  (2024-09-03)
    - bugfix to include Wall of Thorns poison checking
  v1.1.0  (2024-08-18)
    - refactor of the queue process to improve disarm response
    - added help section
    - updated issue_command method to mirror Lich
  v1.0.19 (2024-08-06)
    - add chaotic spatial anomaly to dispelable items (found in HW by gigas disciples)
  v1.0.18 (2024-08-04)
    - fix disarm not waiting for bonded weapon
  v1.0.17 (2024-05-01)
    - fix for Char.level -> Stats.level
    - fix for Char.prof -> Stats.prof
  v1.0.16 (2023-11-24)
    - bugfix for stun recover - check to make sure not in a belly or innards
    - added check for silvery blue globe and spiraling ghostly rift in Moonsedge
    - added check for disarm maneuver in Moonsedge and Sanctum
    - added check for Sanctum disease needing the vat
=end
=begin
  v1.0.15 (2023-08-23)
    - Bugfix for cman retreat if current target != creature that caused grounded debuff
  v1.0.14 (2023-04-13)
    - Bugfix for disarm recovery
  v1.0.13 (2023-04-06)
    - Bugfix for regex comparison of an integer in Ruby 3.2+, force convert .to_s
  v1.0.12 (2023-03-27)
    - added standing check for "channel open" casting
  v1.0.11 (2023-03-11)
    - added multiple searches for recover item
  v1.0.10 (2023-03-07)
    - removed 906 from web dispell
    - added Powersink to dispell debuffs
  v1.0.9 (2023-02-12)
    - added wound eval for spell casting
    - added a wait for spirit servants in disarm recovery
    - add some error checking to disarm recovery
  v1.0.8 (2023-02-10)
    - bug fix for incorrect method name during spirit servant recovery
  v1.0.7 (2023-02-07)
    - bug fix for web check to avoid custom disks
  v1.0.6 (2023-01-31)
    - bug fix for magical_grounded method if either option is checked
  v1.0.5 (2023-01-31)
    - bug fix for weapon disarm section
  v1.0.4 (2023-01-24)
    - bug fix in remove stuff for barkskin check
    - update 1011 casting so it doesn't repeat
    - added support for sigil of determination
  v1.0.3 (2023-01-23)
    - bug fix in recover weapon
  v1.0.2 (2023-01-22)
    - fixed regex for disarmed to not mistake hurled weapons
  v1.0.1 (2023-01-21)
    - add check for CMan.known?("Retreat") and stamina check for grounded debuff.
    - moved magical/grounded debuffs into separate method to only pause scripts if necessary
    - add Mindwipe and Pious Trial to dispellable debuffs
  v1.0.0 (2023-01-20)
    - Initial release
=end

# Check version of Lich for compatibility
lich_gem_requires = '5.11.1'

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires)
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
    _respond "##" + "########################################"
  end
  exit
end

require 'yaml'
require 'terminal-table'

module Ecleanse
  class CappedCollection
    MAX_SIZE ||= 200
    attr_accessor :list, :max_size

    def initialize(max_size = MAX_SIZE)
      @list = []
      @max_size = max_size
    end

    def <<(id)
      @list << id
      while @list.size > @max_size
        @list.shift
      end
    end

    def include?(id)
      @list.include?(id)
    end
  end
end

# Data Class
module Ecleanse
  class Data
    attr_accessor :settings, :did_something, :event_stack, :disease, :dispel, :poison, :webs, :injury_locations, :cloud, :globe, :web, :debuffs, :magic_globes,
                  :recover_item, :recover_room, :creature, :target_regex, :bad_targets, :escape_artist_available, :hive_trap_room, :invalid_clouds

    def initialize(settings)
      @settings = settings
      @did_something = false
      @event_stack = []
      @bad_targets = Ecleanse::CappedCollection.new

      @disease = [113].map { |s| Spell[s] }.find { |s| s.known? }
      @dispel = [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }
      @poison = [114].map { |s| Spell[s] }.find { |s| s.known? }
      @webs = [209, 417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }

      @escape_artist_available = false
      if Feat.known?("escapeartist")
        lines = Util.get_lines("feat info", /<a exist="[\d-]+" noun="[A-Za-z]+">[A-Za-z]+<\/a>, your Feats are as follows:/)
        @escape_artist_available = lines.join("\n") =~ /escapeartist'>escapeartist<\/d>\s+5\/5/ ? true : false
      end

      @settings[:script_list] = @settings[:stop_scripts].split(",").map(&:strip)
      @settings[:script_list] << "go2" unless @settings[:script_list].include?("go2")

      @injury_locations = ['leftHand', 'rightHand', 'leftArm', 'rightArm', 'leftEye', 'rightEye', 'nsys', 'head']

      @debuffs = /Confusion|Vertigo|Sounds|Thought Lash|Mindwipe|Pious Trial|Powersink/
      @magic_globes = /silvery blue globe|spiraling ghostly rift|chaotic spatial anomaly/i
      @target_regex = Regexp.union(
        /^You can only target creatures, players, and creature-created hazards\.$/,
        /^Usage:  TARGET {player\|creature\|hazard}$/,
        /^You are now targeting .+\.$/,
        /^You are unable to discern the origin of .+\.$/,
        /^You discern that you are the origin of .+ and decide against targeting yourself\.$/,
        /^Suspecting that .+ is the origin of .+, you turn your attention towards \w+!$/,
      )
      @invalid_clouds = [
        "cloud of acidic mist",
        "cloud of thick ethereal fog"
      ]

      # action variables
      @cloud = nil
      @globe = nil
      @web = nil

      # hook_variables
      @recover_item = nil
      @recover_room = nil
      @creature = nil
      @hive_trap_room = nil
    end
  end
end

# UI Setup
module Ecleanse
  class Setup < Gtk::Builder
    attr_accessor :settings

    @@categories = {
      general: {
        cleanse_magical: { default: false },
        cleanse_grounded: { default: false },
        cleanse_poison: { default: false },
        cleanse_disease: { default: false },
        recover_disarmed: { default: false },
        dispel_clouds: { default: false },
        dispel_magic: { default: false },
        avoid_webs: { default: false },
        use_berserk_webbed: { default: false },
        hive_traps_apparatus: { default: false },
        hive_traps_ground: { default: false },
        stop_scripts: { default: '' },
        script_list: { default: [] },
        determination: { default: false },
        itchy_curse: { default: false },
        safe_room: { default: '' },
        use_stunned_barkskin: { default: false },
        use_berserk_stunned: { default: false },
        use_stunned1040: { default: false },
        use_stance1: { default: false },
        use_stance2: { default: false },
        use_flee: { default: false },
        use_hide: { default: false },
        use_709: { default: false },
        use_619: { default: false },
        use_213: { default: false },
        use_1011: { default: false },
        use_9811: { default: false },
        use_140: { default: false },
        use_919: { default: false },
        use_1635: { default: false },
        version: { default: '' },
      }
    }

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?

      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()
      @settings = settings
      @silent_exit = false

      # Capture starting settings
      @original_settings = Marshal.load(Marshal.dump(settings))

      # Get script version
      @settings[:version] = version = Util.get_script_version

      # set default values if they don't exist
      @@categories.each do |_, data|
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end

      # remove settings that don't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }

      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        # add_from_file("#{$data_dir}ecleanse.ui")
        add_from_string(Setup.ui)
        load_settings
        self['main'].keep_above = true
        self['main'].set_title "Ecleanse Setup v#{version}"
        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    def self.ui
      '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkWindow" id="main"><property name="width-request">650</property><property name="height-request">675</property><property name="can-focus">False</property><property name="title" translatable="yes">Ecleanse Setup</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">13</property><property name="margin-end">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Scripts to Pause</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="stop_scripts"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-bottom">5</property><property name="width-chars">59</property><property name="placeholder-text" translatable="yes">list of scripts to pause eg - bigshot, eloot, go2</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="width">2</property>
      </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Scripts</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="recover_disarmed"><property name="label" translatable="yes">Recover Disarmed Weapons</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will use 218 if active</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="cleanse_magical"><property name="label" translatable="yes">Cleanse Magical</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Attempts to cleanse - Confusion, Vertigo, Sounds, or Thought Lash using spells 417, 119, or 1218 if known</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="cleanse_poison"><property name="label" translatable="yes">Cure Poison</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses unpoison (114)</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="avoid_webs"><property name="label" translatable="yes">Dispel Webs</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="cleanse_disease"><property name="label" translatable="yes">Cure Disease</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses undisease (113)</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="cleanse_grounded"><property name="label" translatable="yes">Cleanse Grounded</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Attempts to clear Rooted or Pressed</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="determination"><property name="label" translatable="yes">Use Sigil of Determination</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="dispel_clouds"><property name="label" translatable="yes">Dispel Clouds</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="dispel_magic"><property name="label" translatable="yes">Dispel Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_berserk_webbed"><property name="label" translatable="yes">Use Berserk when Webbed</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="hive_traps_apparatus"><property name="label" translatable="yes">Disarm Hive Apparatus</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="hive_traps_ground"><property name="label" translatable="yes">Disarm Hive Ground</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="itchy_curse"><property name="label" translatable="yes">Manage Itchy Curse</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="safe_room"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">If left empty will run to nearest town or sanctuary.</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">Itchy Curse Safe Rooom</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">4</property><property name="width">2</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object>
      </child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="use_flee"><property name="label" translatable="yes">Stunman Flee</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">42</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_berserk_stunned"><property name="label" translatable="yes">Berserk</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_stunned1040"><property name="label" translatable="yes">Troubadour\'s Rally (1040)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="use_hide"><property name="label" translatable="yes">Stunman Hide</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">42</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_stance2"><property name="label" translatable="yes">Stunman Stance2</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">25</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_stance1"><property name="label" translatable="yes">Stunman Stance1</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">25</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_stunned_barkskin"><property name="label" translatable="yes">Barkskin (605)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="use_1635"><property name="label" translatable="yes">Divine Intervention (1635)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">25</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Stun Recovery</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="use_9811"><property name="label" translatable="yes">Symbol of Sleep</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will use 218 if active</property><property name="halign">start</property><property name="margin-start">32</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_213"><property name="label" translatable="yes">Minor Sanctuary (213)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="use_140"><property name="label" translatable="yes">Wall of Force (140)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">24</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_919"><property name="label" translatable="yes">Wizard\'s Shield (919)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Uses undisease (113)</property><property name="halign">start</property><property name="margin-start">24</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_709"><property name="label" translatable="yes">Grasp of the Grave (709)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_619"><property name="label" translatable="yes">Mass Calm (619)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="use_1011"><property name="label" translatable="yes">Song of Peace (1011)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">32</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Cast in Room when Disarmed</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">3</property>
      </packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property></object><packing><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes">To save properly, exit with the close button and not the X window --&gt;</property><attributes><attribute name="style" value="italic"/>
      </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
      </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?

          if key == :use_stance1 && obj.active?
            self['use_stance2'].active = false
            @settings[:use_stance2] = false

            self['use_flee'].active = false
            @settings[:use_flee] = false

            self['use_hide'].active = false
            @settings[:use_hide] = false
          end

          if key == :use_stance2 && obj.active?
            self['use_stance1'].active = false
            @settings[:use_stance1] = false

            self['use_flee'].active = false
            @settings[:use_flee] = false

            self['use_hide'].active = false
            @settings[:use_hide] = false
          end

          if key == :use_flee && obj.active?
            self['use_stance1'].active = false
            @settings[:use_stance1] = false

            self['use_stance2'].active = false
            @settings[:use_stance2] = false

            self['use_hide'].active = false
            @settings[:use_hide] = false
          end

          if key == :use_hide && obj.active?
            self['use_stance1'].active = false
            @settings[:use_stance1] = false

            self['use_stance2'].active = false
            @settings[:use_stance2] = false

            self['use_flee'].active = false
            @settings[:use_flee] = false
          end
        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update
          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        elsif obj.class == Gtk::ComboBoxText
          @settings[key] = obj.active_text
        end
      end
    end

    def on_close_clicked
      if @original_settings == @settings
        respond
        Lich::Messaging.msg('plain', " Nothing to save. No changes were made.")
        respond
      else
        filename = File.join(DATA_DIR, XMLData.game, Char.name, 'ecleanse.yaml')
        File.write(filename, Ecleanse.data.settings.to_yaml)
        respond
        Lich::Messaging.msg('plain', " Settings saved to file: #{filename}.")
        respond
      end

      @silent_exit = true
      self['main'].destroy
    end

    def on_destroy
      Gtk.queue {
        unless @silent_exit
          respond
          Lich::Messaging.msg('plain', " #{@script_name} UI closed WITHOUT saving any changes")
          Lich::Messaging.msg('plain', " Be sure to use the close button to save changes")
          respond
        end
        @running = false
      }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings
      Gtk.queue do
        conditions = {
          "cleanse_disease"      => !Spell[113].known?,
          "cleanse_poison"       => !Spell[114].known?,
          "use_berserk_webbed"   => !CMan.known?("Berserk"),
          "determination"        => !Spell["Sigil of Determination"].known?,
          "cleanse_grounded"     => !(CMan.known?("Retreat") || Feat.known?("escapeartist")),
          "cleanse_magical"      => [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }.nil?,
          "dispel_clouds"        => [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }.nil?,
          "dispel_magic"         => [417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }.nil? && !CMan.known?("Spell Cleave") && !CMan.known?("Spell Thieve"),
          "avoid_webs"           => [209, 417, 1218, 119].map { |s| Spell[s] }.find { |s| s.known? }.nil? && !Feat.known?("escapeartist") && !CMan.known?("Spell Cleave") && !CMan.known?("Spell Thieve"),
          "use_stunned_barkskin" => !Spell[605].known?,
          "use_berserk_stunned"  => !CMan.known?("Berserk"),
          "use_stunned1040"      => !Spell[1040].known?,
          "use_stance1"          => CMan.stun_maneuvers < 2,
          "use_stance2"          => CMan.stun_maneuvers < 4,
          "use_flee"             => CMan.stun_maneuvers < 5,
          "use_hide"             => CMan.stun_maneuvers < 5,
          "use_709"              => !Spell[709].known?,
          "use_619"              => !Spell[619].known?,
          "use_213"              => !Spell[213].known?,
          "use_1011"             => !Spell[1011].known?,
          "use_9811"             => !Spell[9811].known?,
          "use_140"              => !Spell[140].known?,
          "use_919"              => !Spell[919].known?,
          "use_1635"             => !Spell[1635].known?,
        }

        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym
          builder_name = obj.builder_name
          next if (Setup.get_setting(key)).nil?

          # disable options and set them to false if the character can't do them
          if conditions[builder_name]
            obj.set_sensitive(false)
            self[builder_name].active = false
            @settings[key] = false
          end

          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) }
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].strip
            obj.signal_connect('changed') { on_update(obj) }
          end
        end
      end
    end

    def start
      @running = true
      Gtk.queue { self['main'].show_all }
      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[general internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def self.update_setting(key, value)
      setting = Setup.get_setting(key)
      echo "** Setting #{key.inspect} does not exist" if setting.nil?
      action = nil

      if value =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value == 'reset'
        @settings.delete(key)
        echo " Reset #{key}"
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          echo " #{value.inspect} removed from #{key.inspect}"
        else
          @settings[key].push(value)
          echo " #{value.inspect} added to #{key.inspect}"
        end

        echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        echo "#{key.inspect} has been set to #{value.inspect}"
        @settings[key] = value
      end
    end
  end
end

# Load/Save profiles
module Ecleanse
  @@data ||= nil

  def self.data
    @@data
  end

  def self.load(settings)
    @@data = Data.new(settings)
  end

  def self.load_defaults
    {
      :cleanse_magical      => CharSettings['cleanse_magical'] || false,
      :cleanse_grounded     => CharSettings['cleanse_grounded'] || false,
      :cleanse_poison       => CharSettings['cleanse_poison'] || false,
      :cleanse_disease      => CharSettings['cleanse_disease'] || false,
      :recover_disarmed     => CharSettings['recover_disarmed'] || false,
      :dispel_clouds        => false,
      :dispel_magic         => false,
      :avoid_webs           => CharSettings['avoid_webs'] || false,
      :use_berserk_webbed   => false,
      :stop_scripts         => CharSettings['stop_scripts'] || '',
      :script_list          => [],
      :determination        => CharSettings['determination'] || false,
      :use_stunned_barkskin => false,
      :use_berserk_stunned  => false,
      :use_stunned1040      => false,
      :use_stance1          => false,
      :use_stance2          => false,
      :use_flee             => false,
      :use_hide             => false,
      :use_709              => false,
      :use_619              => false,
      :use_213              => false,
      :use_1011             => false,
      :use_9811             => false,
      :use_140              => false,
      :use_919              => false,
      :version              => '',
    }
  end

  def self.load_profile
    filename = File.join(DATA_DIR, XMLData.game, Char.name, 'ecleanse.yaml')

    if File.exist?(filename)
      settings_hash = YAML.load_file(filename)
    else
      settings_hash = Ecleanse.load_defaults
    end

    return settings_hash
  end
end

# Main Script Methods
module Ecleanse
  module Action
    def self.avoid_webs
      return unless Ecleanse.data.settings[:avoid_webs]

      web_dispel_ready = !Ecleanse.data.webs.nil? && Util.able_to_cast
      spell_cleave_ready = CMan.known?("Spell Cleave") && Char.stamina >= 10
      spell_thieve_ready = CMan.known?("Spell Thieve") && Char.stamina >= 10

      # Return unless able to perform an action to remove webs
      return unless web_dispel_ready || spell_cleave_ready || spell_thieve_ready

      # Return unless able to target object
      result = dothistimeout("target ##{Ecleanse.data.web.id}", 2, Ecleanse.data.target_regex)
      unless result.is_a?(String) && result =~ /^Suspecting that .+ is the origin of .+, you turn your attention towards \w+!$/
        Ecleanse.data.bad_targets << Ecleanse.data.web.id
        return
      end

      System.scripts_pause

      if web_dispel_ready
        Action.mana_pulse(Ecleanse.data.webs.num)
        Ecleanse.data.webs.cast("at ##{Ecleanse.data.web.id}") if Ecleanse.data.webs.affordable?
      elsif CMan.known?("Spell Cleave") && Char.stamina >= 10
        fput "cman scleave ##{Ecleanse.data.web.id}"
      elsif CMan.known?("Spell Thieve") && Char.stamina >= 10
        fput "cman sthieve ##{Ecleanse.data.web.id}"
      end
      Ecleanse.data.web = nil
    end

    def self.avoid_globe
      return unless Ecleanse.data.settings[:dispel_magic]

      globe_dispel_ready = !Ecleanse.data.dispel.nil? && Util.able_to_cast
      spell_cleave_ready = CMan.known?("Spell Cleave") && Char.stamina >= 10
      spell_thieve_ready = CMan.known?("Spell Thieve") && Char.stamina >= 10

      # Return unless able to perform an action to remove globes
      return unless globe_dispel_ready || spell_cleave_ready || spell_thieve_ready

      # Return unless able to target object
      result = dothistimeout("target ##{Ecleanse.data.globe.id}", 2, Ecleanse.data.target_regex)
      unless result.is_a?(String) && result =~ /^Suspecting that .+ is the origin of .+, you turn your attention towards \w+!$/
        Ecleanse.data.bad_targets << Ecleanse.data.globe.id
        return
      end

      System.scripts_pause

      if globe_dispel_ready
        Action.mana_pulse(Ecleanse.data.dispel.num)
        Ecleanse.data.dispel.cast("at ##{Ecleanse.data.globe.id}") if Ecleanse.data.dispel.affordable?
      elsif CMan.known?("Spell Cleave") && Char.stamina >= 10
        fput "cman scleave ##{Ecleanse.data.globe.id}"
      elsif CMan.known?("Spell Thieve") && Char.stamina >= 10
        fput "cman sthieve ##{Ecleanse.data.globe.id}"
      end
      Ecleanse.data.globe = nil
    end

    def self.change_stance(new_stance)
      return if Effects::Debuffs.active?("Frenzy") || dead?
      return if Char.percent_stance == new_stance
      return if new_stance == 100 && Char.percent_stance >= 80

      stances = {
        0   => 'offensive',
        20  => 'advanced',
        40  => 'forward',
        60  => 'neutral',
        80  => 'guarded',
        100 => 'defensive'
      }

      if CMan.available?('Stance Perfection') && ![0, 20, 40, 60, 80, 100].include?(new_stance)
        cmd = "cman stance #{new_stance}"
      elsif stances[new_stance]
        cmd = "stance #{stances[new_stance]}"
      else
        cmd = 'stance defensive'
      end

      expiry = Time.now + 2
      while Char.percent_stance != new_stance
        res = dothistimeout(cmd, 2, /You are now|You move into|Roundtime|wait|Your rage causes you/i)
        if res =~ /Roundtime: (\d+)|wait (\d+)/i
          sleep((Regexp.last_match(1) || Regexp.last_match(2)).strip.to_f - 1)
          expiry = Time.now + 2
        elsif Time.now > expiry
          break
        else
          break
        end
        sleep 0.5
      end
    end

    def self.determination
      return unless Ecleanse.data.settings[:determination]
      return unless Spell["Sigil of Determination"].known? && Spell["Sigil of Determination"].affordable?
      return if Effects::Buffs.active?("Sigil of Determination")

      System.scripts_pause
      Spell["Sigil of Determination"].cast if Spell["Sigil of Determination"].affordable?
    end

    def self.dispel_cloud
      return unless Ecleanse.data.settings[:dispel_magic]

      cloud_dispel_ready = !Ecleanse.data.dispel.nil? && Util.able_to_cast
      spell_cleave_ready = CMan.known?("Spell Cleave") && Char.stamina >= 10
      spell_thieve_ready = CMan.known?("Spell Thieve") && Char.stamina >= 10

      # Return unless able to perform an action to remove globes
      return unless cloud_dispel_ready || spell_cleave_ready || spell_thieve_ready

      # Return unless able to target object
      result = dothistimeout("target ##{Ecleanse.data.cloud.id}", 2, Ecleanse.data.target_regex)
      unless result.is_a?(String) && result =~ /^Suspecting that .+ is the origin of .+, you turn your attention towards \w+!$/
        Ecleanse.data.bad_targets << Ecleanse.data.cloud.id
        return
      end

      System.scripts_pause

      if cloud_dispel_ready
        Action.mana_pulse(Ecleanse.data.dispel.num)
        Ecleanse.data.dispel.cast("at ##{Ecleanse.data.cloud.id}") if Ecleanse.data.dispel.affordable?
      elsif CMan.known?("Spell Cleave") && Char.stamina >= 10
        fput "cman scleave ##{Ecleanse.data.cloud.id}"
      elsif CMan.known?("Spell Thieve") && Char.stamina >= 10
        fput "cman sthieve ##{Ecleanse.data.cloud.id}"
      end
      Ecleanse.data.cloud = nil
    end

    def self.go2(place)
      fput('unhide') if (hidden? || invisible?)

      return if Room.current.id == place

      if Room.current.id.nil?
        respond "Currently in an unmapped room - Need to go to #{place}"
        return
      end

      Script.run('go2', "#{place} --disable-confirm", { quiet: true, force: true })
    end

    def self.hive_traps_apparatus
      return unless Ecleanse.data.settings[:hive_traps_apparatus]
      return if Script.running?('go2')
      return unless Ecleanse.data.hive_trap_room == Room.current

      System.scripts_pause

      search_count = 0
      loop do
        Util.wait_rt
        lines = Util.get_command("search", /d100: /)
        search_count += 1
        break if search_count >= 10
        next if lines.any? { |l| l =~ /Failure!/ }
        break if lines.any? { |l| l =~ /Success|You don't find anything of interest here/ }
      end

      Util.wait_rt

      search_count = 0
      loop do
        results = Util.get_command("disarm apparatus", /d100|You want to disarm what\?/)
        search_count += 1
        break if results.any? { |l| l =~ /Success|You want to disarm what\?/ }
        return if search_count >= 10
        Util.wait_rt
      end

      Util.wait_rt
    end

    def self.hive_traps_ground
      return unless Ecleanse.data.settings[:hive_traps_ground]
      return if Script.running?('go2')
      return unless Ecleanse.data.hive_trap_room == Room.current

      System.scripts_pause

      search_count = 0
      loop do
        Util.wait_rt
        lines = Util.get_command("search", /d100: /)
        search_count += 1
        break if search_count >= 10
        next if lines.any? { |l| l =~ /Failure!/ }
        break if lines.any? { |l| l =~ /Success|You don't find anything of interest here/ }
      end

      Util.wait_rt
    end

    def self.itchy_curse
      return unless Ecleanse.data.settings[:itchy_curse]

      cursed_room = Room.current.id

      if !Ecleanse.data.settings[:safe_room].to_s.empty?
        safe_place = Ecleanse.data.settings[:safe_room]
      else
        shortest_distances_var = Room.current.dijkstra.last
        town = Room.current.find_nearest_by_tag('town')
        sanctuary = Room.current.find_nearest_by_tag('sanctuary')

        safe_place = [town, sanctuary].compact.sort_by { |room| shortest_distances_var[room] }.first
      end

      System.scripts_pause
      Script.kill("go2") if Script.running?("go2")

      Script.start("go2", "#{safe_place} --disable-confirm")

      empty_hands

      timeout = Time.now + 180
      loop do
        break if Time.now > timeout
        break if reget(50).any? { |line| line =~ /You no longer feel so defenseless and the rash seems to disappear\./ }
        sleep(1)
      end

      fill_hands

      Action.go2(cursed_room)
    end

    def self.mana_pulse(spell_id)
      return unless Spell[spell_id].known? && !Spell[spell_id].affordable?

      mana_regex = Regexp.union(
        /An invigorating rush of mana pulses through you/i,
        /You are too mentally fatigued to attempt this ability/i,
        /You're already at full mana./i,
        /Your mana control skills are not yet advanced/i,
      )

      dothistimeout "mana pulse", 2, mana_regex
      sleep 0.2
    end

    def self.recover
      # standard disarm mechanics
      return unless Ecleanse.data.settings[:recover_disarmed]
      System.scripts_pause

      item = Ecleanse.data.recover_item
      room_id = Ecleanse.data.recover_room.id
      title = Ecleanse.data.recover_room.title

      stop_213 = false
      stop_1011 = false

      Util.msg("yellow", " ########## DISARMED!!! ##########")
      Util.msg("yellow", " ## Room#: #{room_id}")
      Util.msg("yellow", " ## Room Name: #{title.first}")
      Util.msg("yellow", " ## Looking for: #{item}")
      Util.msg("yellow", " ########## DISARMED!!! ##########")
      UserVars.last_disarm = room_id
      Action.go2(room_id)

      Util.wait_rt

      if Util.able_to_cast
        if Spell[213].known? && Ecleanse.data.settings[:use_213]
          Action.mana_pulse(213)
          Spell[213].cast if Spell[213].affordable?
          stop_213 = true
        end

        if Spell[1011].known? && Ecleanse.data.settings[:use_1011]
          Action.mana_pulse(1011)
          Spell[1011].cast if Spell[1011].affordable?
          stop_1011 = true
        end
        Util.wait_rt
      end

      if Spell[218].active?
        15.times do
          break if (GameObj.npcs.find { |npc| npc.noun =~ /spirit/i })

          sleep(0.1)
        end

        line = dothistimeout "tell servant recover", 5, /flickers for a moment and manifests|has no personal recollection/
        if line =~ /flickers for a moment and manifests/
          servant_recover = true
        else
          servant_recover = false
        end
        if servant_recover
          lines = Util.get_lines("sense", /You open your soul to the lesser/)
          if lines.any? { |l| l =~ /An obvious presence of peace saturates the area and a feeling of safety overwhelms you/ }
            fput "stop 213"
          end

          return
        end
      end

      # Make the room safer.
      Action.settle_room

      # Sometimes bigshot sneaks in an eloot
      System.scripts_pause

      # Change to defensive stance
      Action.change_stance(100)

      # It might be a bonded weapon
      if Feat.weapon_bonding == 5 || Spell[1625].known? # Fixme: Making an assumption you'd be using the bonded weapon
        wait_time = Time.now + 10
        until [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item) || wait_time < Time.now
          Util.wait_rt
        end
      end

      unless [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item)
        empty_hands

        search_count = 0
        until search_count.eql?(10)

          until kneeling?
            dothistimeout("kneel", 2, /You kneel|You are already/i)
          end

          Util.wait_rt

          lines = Util.get_command("recover item", /<dialogData|You spy|You continue to intently search the area|In order to recover something|You find nothing recoverable/)

          if lines.grep(/You spy (?:an|a) (?:.*) and recover it\!/).any? || [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item)
            break
          end

          if lines.grep(/You're not in any condition to be searching around/).any?
            Util.msg("yellow", " Unable to search. Exiting ecleanse.")
            Util.msg("yellow", " #{item} is in room #{room_id}")
            fput "stand" until standing?
            System.scripts_resume
            exit
          end

          if lines.grep(/In order to recover something/).any?
            empty_hands
          end

          search_count += 1
        end

        Util.wait_rt
      end

      fput "stand" until standing?
      Util.wait_rt

      fput "stop 213" if stop_213
      fput "stop 1011" if stop_1011
    end

    def self.recover_weapon_webbing
      return unless Ecleanse.data.settings[:recover_disarmed]
      System.scripts_pause

      item_noun = Ecleanse.data.recover_item

      stop_213 = false
      stop_1011 = false

      Util.wait_rt

      if Util.able_to_cast
        if Spell[213].known? && Ecleanse.data.settings[:use_213]
          Action.mana_pulse(213)
          Spell[213].cast if Spell[213].affordable?
          stop_213 = true
        end

        if Spell[1011].known? && Ecleanse.data.settings[:use_1011]
          Action.mana_pulse(1011)
          Spell[1011].cast if Spell[1011].affordable?
          stop_1011 = true
        end
        Util.wait_rt
      end

      # Make the room safer.
      Action.settle_room

      # Sometimes bigshot sneaks in an eloot
      System.scripts_pause

      # Change to defensive stance
      Action.change_stance(100)

      pry_count = 0
      until pry_count.eql?(10)
        lines = Util.get_command("pry my #{item_noun}", /^Pry what|^You try to pry your|^You pry your.*free from the webbing/)

        if lines.any? { |l| l =~ /You pry your|Pry what/i }
          fput "stop 213" if stop_213
          fput "stop 1011" if stop_1011
          return
        end

        pry_count += 1
      end

      fput "stop 213" if stop_213
      fput "stop 1011" if stop_1011
    end

    def self.remove_disease
      return unless Ecleanse.data.settings[:cleanse_disease]
      return unless Spell[113].known? && Util.able_to_cast

      Action.mana_pulse(113)

      return unless Spell[113].affordable?

      System.scripts_pause

      until !checkdisease || !Spell[113].affordable?
        Spell[113].cast
        Util.wait_rt
      end
    end

    def self.remove_grounded
      return unless Ecleanse.data.settings[:cleanse_grounded]

      if CMan.known?("Retreat")
        grounded_debuffs = ["Rooted", "Pressed"]
        grounded_debuffs.each do |debuff|
          if Effects::Debuffs.active?(debuff) && Char.stamina >= 11
            System.scripts_pause
            Util.wait_rt
            fput "stand" until checkstanding
            Util.wait_rt
            current_target = XMLData.current_target_id
            fput 'target clear'
            fput 'cman retreat'
            fput "target ##{current_target}"
          end
        end
      elsif Effects::Debuffs.active?("Rooted") && Ecleanse.data.escape_artist_available && Char.stamina >= 15
        System.scripts_pause
        Feat.use('escapeartist')
      end
    end

    def self.remove_magical
      return unless Ecleanse.data.settings[:cleanse_magical]
      return unless Util.able_to_cast

      dispellable_debuffs = ["Confusion", "Vertigo", "Sounds", "Thought Lash", "Mindwipe", "Pious Trial", "Powersink"]

      # Return if we don't know how to do dispel
      return if Ecleanse.data.dispel.nil?

      Action.mana_pulse(Ecleanse.data.dispel.num)

      dispellable_debuffs.each { |debuff|
        if Effects::Debuffs.active?(debuff) and !Ecleanse.data.dispel.nil?
          System.scripts_pause

          Action.mana_pulse(Ecleanse.data.dispel.num)

          fput "stand" until checkstanding
          Util.wait_rt
          Ecleanse.data.dispel.force_incant("channel open") if Ecleanse.data.dispel.affordable?
        end
      }
    end

    def self.remove_poison
      return unless Ecleanse.data.settings[:cleanse_poison]
      return unless Spell[114].known? && Util.able_to_cast

      Action.mana_pulse(114)

      return unless Spell[114].affordable?

      System.scripts_pause

      loop do
        if Gem::Version.new(LICH_VERSION) >= Gem::Version.new("5.10.2")
          thorns_active = Status.thorned?
        else
          thorns_active = Effects::Debuffs.to_h.keys.any? { |key| key.to_s =~ /Wall of Thorns Poison/ }
        end

        # Break loop if neither debuff is present or spell is no longer affordable
        break if (!checkpoison && !thorns_active) || !Spell[114].affordable?

        # Cast the spell to cleanse
        Spell[114].cast
        Util.wait_rt

        # Optionally refresh debuff status for thorns (if needed)
        Util.get_lines("spell active debuff", /<dialogData id='Debuffs'/) if thorns_active
      end
    end

    def self.remove_stun
      Action.mana_pulse(1040) if Spell[1040].known? && Ecleanse.data.settings[:use_stunned1040]
      not_escape_rooms = checkroom("The Belly of the Beast").nil? && checkroom("Ooze, Innards").nil?

      barkskin = Ecleanse.data.settings[:use_stunned_barkskin] && Spell[605].known? && !Effects::Cooldowns.active?("Barkskin: Commune") && !Effects::Cooldowns.active?("Barkskin") && !Spell[605].active? && Skills.slblessings >= 15
      berserk = Ecleanse.data.settings[:use_berserk_stunned] && CMan.known?("Berserk") && Char.stamina >= 21 && not_escape_rooms
      stunned1040 = Ecleanse.data.settings[:use_stunned1040] && Spell[1040].known? && Spell[1040].affordable?
      stance1 = Ecleanse.data.settings[:use_stance1] && CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers > 2 && Char.stamina >= 10 && not_escape_rooms
      stance2 = Ecleanse.data.settings[:use_stance2] && CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers > 3 && Char.stamina >= 10 && not_escape_rooms
      flee = Ecleanse.data.settings[:use_flee] && CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers > 4 && Char.stamina >= 10 && not_escape_rooms
      hide = Ecleanse.data.settings[:use_hide] && CMan.known?("Stun Maneuvers") && CMan.stun_maneuvers > 4 && Char.stamina >= 10 && not_escape_rooms && !checkhidden
      beseech_1635 = Ecleanse.data.settings[:use_1635] && Spell[1635].known? && Spell[1635].affordable?

      return unless barkskin || berserk || stunned1040 || stance1 || stance2 || flee || hide || beseech_1635

      System.scripts_pause

      if barkskin
        Action.mana_pulse(605)
        Util.wait_rt
        fput "commune barkskin" if stunned?
        sleep 0.1 until !checkstunned
      elsif berserk
        Spell[9607].cast
        sleep 1
        wait_until { !Spell[9607].active? }
      elsif stunned1040
        fput "shout 1040"
      elsif beseech_1635
        fput "beseech"
      elsif stance1
        Action.stunman_perform('stance1')
      elsif stance2
        Action.stunman_perform('stance2')
      elsif flee
        Action.stunman_perform('flee')
      elsif hide
        Action.stunman_perform('hide')
      end
    end

    def self.remove_web_bound
      return unless Ecleanse.data.settings[:avoid_webs] || Ecleanse.data.settings[:use_berserk_webbed]
      Action.mana_pulse(1040) if Spell[1040].known?

      spell_1040_ready = Spell[1040].known? && Spell[1040].affordable?
      berserk_ready = Ecleanse.data.settings[:use_berserk_webbed] && CMan.known?("Berserk") && Char.stamina >= 21
      beseech_1635 = Ecleanse.data.settings[:use_1635] && Spell[1635].known? && Spell[1635].affordable?
      escape_ready = Ecleanse.data.escape_artist_available && Char.stamina >= 15

      return unless spell_1040_ready || berserk_ready || beseech_1635 || escape_ready

      System.scripts_pause

      if Spell[1040].known? and Spell[1040].affordable?
        fput "shout 1040"
      elsif CMan.known?("Berserk") && Char.stamina >= 21
        Spell[9607].cast
        sleep 1
        wait_until { !Spell[9607].active? }
      elsif beseech_1635
        fput "beseech"
      elsif escape_ready && Char.stamina >= 15
        Feat.use('escapeartist')
      end
    end

    def self.sanctum_recover
      # Unholy Quickening by Lithe Veiled Sentinels in the Sanctum
      return unless Ecleanse.data.settings[:recover_disarmed]
      System.scripts_pause

      creature = Ecleanse.data.creature

      Util.wait_rt

      # Make the room safer.
      Action.settle_room

      # Sometimes bigshot sneaks in an eloot
      System.scripts_pause

      # Change to defensive stance
      Action.change_stance(100)

      loop do
        result = Util.get_res("clench #{creature}")
        Util.wait_rt
        break if result =~ /You reach up and grab|I could not find what you were referring to./
      end
    end

    def self.settle_room
      return if GameObj.targets.empty?
      return unless Util.able_to_cast

      if Ecleanse.data.settings[:use_140] && Spell[140].known? && !Effects::Buffs.active?("Wall of Force") && !Effects::Cooldowns.active?("Wall of Force")
        Action.mana_pulse(140)
        Spell[140].cast if Spell[140].affordable?
      elsif Ecleanse.data.settings[:use_619] && Spell[619].known?
        Action.mana_pulse(619)
        Spell[619].cast if Spell[619].affordable?
      elsif Ecleanse.data.settings[:use_709] && Spell[709].known? && !GameObj.npcs.any? { |c| c.name =~ /^(?:arm|appendage|claw|limb|pincer|tentacle)s?$|^(?:palpus|palpi)$/i }
        Action.mana_pulse(709)
        Spell[709].cast if Spell[709].affordable?
      elsif Ecleanse.data.settings[:use_919] && !Effects::Buffs.active?("Wizard's Shield") && !Effects::Cooldowns.active?("Wizard's Shield")
        Action.mana_pulse(919)
        Spell[919].cast if Spell[919].affordable?
      elsif Ecleanse.data.settings[:use_9811] && Spell[9811].known?
        Spell[9811].cast
      end
    end

    def self.stunman_perform(type)
      Action.stunman_stand

      case type
      when 'stance1'
        fput 'stunman stance1'
      when 'stance2'
        fput 'stunman stance2'
      when 'flee'
        current_room = Room.current.id
        until Room.current.id != current_room || !checkstunned
          Action.stunman_stand
          fput "stunman flee"
          sleep 0.5
        end
      when 'hide'
        until checkhidden || !checkstunned
          fput "stunman hide"
          Util.wait_rt
        end
      end

      sleep 0.1 until !checkstunned
    end

    def self.stunman_stand
      until standing? || !checkstunned
        put "stunman stand"
        Util.wait_rt
      end
    end

    def self.telekinetic_recover
      # Telekinetic Disarm is cast in Moonsedge - Savant spell 1406
      return unless Ecleanse.data.settings[:recover_disarmed]
      System.scripts_pause

      item = Ecleanse.data.recover_item

      # Make the room safer.
      Action.settle_room

      # Sometimes bigshot sneaks in an eloot
      System.scripts_pause

      # Change to defensive stance
      Action.change_stance(100)

      until [GameObj.right_hand.noun, GameObj.left_hand.noun].include?(item)
        if Ecleanse.data.dispel.nil?
          fput "get #{item}"
        else
          Action.mana_pulse(Ecleanse.data.dispel.num)
          Ecleanse.data.dispel.cast("at #{item}") if Ecleanse.data.dispel.affordable?
        end

        lines = Util.get_lines("glance", /You glance/)
        break if lines.any? { |l| l =~ /#{item}/ }

        Util.wait_rt
      end
    end

    def self.use_vat
      # A bite/spit maneuver from a Shambling Lurk in the Sanctum
      System.scripts_pause

      current_room = Room.current.id
      vat_room = Room.ids_from_uid(4216054).first
      Action.go2(vat_room)

      Util.get_res("clean vat")
      Util.wait_rt

      Action.go2(current_room)
    end
  end

  module System
    def self.deadmans_switch
      # Kill script if dead
      Thread.new { loop { Script.self.kill if dead?; sleep(5); } }
    end

    def self.scripts_pause
      Ecleanse.data.settings[:script_list].each { |script| Script.pause(script) if Script.running?(script) }
      Ecleanse.data.did_something = true
    end

    def self.scripts_resume
      Ecleanse.data.settings[:script_list].each { |script| Script.unpause(script) if Script.paused?(script) }
      Ecleanse.data.did_something = false
    end

    def self.set_hooks
      ecleanse_status = proc { |server|
        if server =~ /Your <a exist=".*?" noun="(.*?)">.*?<\/a> is knocked from your grasp/
          Ecleanse.data.recover_item = Regexp.last_match(1)
          Ecleanse.data.recover_room = Room.current
          Ecleanse.data.event_stack << :recover && !Ecleanse.data.event_stack.include?(:recover)
        elsif server =~ /your <a exist="\d+?" noun="([^"]+)">.+?<\/a> at .+?\.  The weapon rebounds off of the hardened .+? and is wrenched from your hand\.  It slides along the ground and disappears into the shadows!\r?\n?$/
          Ecleanse.data.recover_item = Regexp.last_match(1)
          Ecleanse.data.recover_room = Room.current
          Ecleanse.data.event_stack << :recover && !Ecleanse.data.event_stack.include?(:recover)
        elsif server =~ /^Your <a exist="\d+?" noun="([^"]+)">.+?<\/a> strikes one of the bony protrusions on <pushBold\/>an? <a exist="\d+" noun="[^"]+">[^<]+<\/a><popBold\/> \w+ and it is wrenched out of your grasp!\r?\n?$/
          Ecleanse.data.recover_item = Regexp.last_match(1)
          Ecleanse.data.recover_room = Room.current
          Ecleanse.data.event_stack << :recover && !Ecleanse.data.event_stack.include?(:recover)
        elsif server =~ /^You swing your <a exist="[^"]+" noun="([^"]+)">[^<]+<\/a> at <pushBold\/>(?:an?|the) <a exist="[^"]+" noun="[^"]+">[^<]+<\/a><popBold\/>\.  The weapon strikes one of the bony protrusions on the <pushBold\/><a exist="[^"]+" noun="[^"]+">[^<]+<\/a><popBold\/> \w+ and it is wrenched out of your grasp!\r?\n?$/
          Ecleanse.data.recover_item = Regexp.last_match(1)
          Ecleanse.data.recover_room = Room.current
          Ecleanse.data.event_stack << :recover && !Ecleanse.data.event_stack.include?(:recover)
        elsif server =~ /Your <a exist=".*?" noun="(.*?)">.*?<\/a> tears free from your hands and floats/
          Ecleanse.data.recover_item = Regexp.last_match(1)
          Ecleanse.data.event_stack << :telekinetic_recover && !Ecleanse.data.event_stack.include?(:telekinetic_recover)
        elsif server =~ /Striking with a serpent's unsettling quickness, (?:.*)\.  Vile (?:.*), kindling it into an unholy semblance of life.  The (?:.*) form twists and mutates, sprouting scales and cold eyes as it transforms into a <a exist="\d+" noun="([^"]+)">[^<]+<\/a>\!/
          Ecleanse.data.creature = Regexp.last_match(1)
          Ecleanse.data.event_stack << :sanctum_recover && !Ecleanse.data.event_stack.include?(:sanctum_recover)
        elsif server =~ /The flesh around the wound feels hot and cold at the same time, heavy with infection./
          Ecleanse.data.event_stack << :use_vat && !Ecleanse.data.event_stack.include?(:use_vat)
        elsif server =~ /The webbing entangles your <a exist=".*?" noun="(.*?)">.*?<\/a>, rendering it useless/
          Ecleanse.data.recover_item = Regexp.last_match(1)
          Ecleanse.data.event_stack << :recover_weapon_webbing && !Ecleanse.data.event_stack.include?(:recover_weapon_webbing)
        elsif server =~ /You notice a flickering glint in the shadows|The apparatus flickers with deadly radiance/
          Ecleanse.data.hive_trap_room = Room.current
          Ecleanse.data.event_stack << :hive_traps_apparatus && !Ecleanse.data.event_stack.include?(:hive_traps_apparatus)
        elsif server =~ /The ground churns violently as flashes of chitin jut from its depths|The ground underfoot churns violently and huge chitinous mandibles flash as the insectoid monstrosity below goes into a feeding frenzy!|Hindered by the churning terrain, you are helpless as the concealed assailant's mandibles snap at you from the safety of its pit trap!/
          Ecleanse.data.hive_trap_room = Room.current
          Ecleanse.data.event_stack << :hive_traps_ground && !Ecleanse.data.event_stack.include?(:hive_traps_ground)
        elsif server =~ /You shiver slightly as an invisible rash covers your body/
          Ecleanse.data.event_stack << :itchy_curse && !Ecleanse.data.event_stack.include?(:itchy_curse)
        elsif server =~ /^An unseen force entangles you, restricting your movement!\r?\n?$/
          Ecleanse.data.event_stack << :remove_web_bound && !Ecleanse.data.event_stack.include?(:remove_web_bound)
        end
        server
      }
      DownstreamHook.add('ecleanse_status', ecleanse_status)

      before_dying {
        DownstreamHook.remove('ecleanse_status')
        Ecleanse.data.settings[:script_list].each { |script| Script.unpause(script) if Script.paused?(script) }
      }
    end
  end

  module Util
    def self.able_to_cast
      able_to_cast = true
      stacked_right_scar = 0
      stacked_right_wound = 0
      stacked_left_scar = 0
      stacked_left_wound = 0
      try_sigil = true

      XMLData.injuries.each { |area, h|
        next unless area =~ /nsys|head|(left|right)(Eye|Arm|Hand)/
        next unless (h['scar'].positive? || h['wound'].positive?)

        # echo area
        # echo "scar: #{h['scar']} wound: #{h['wound']}"
        if h['scar'] > 2 || h['wound'] > 2
          try_sigil = false # Sigil of Determination cannot ignore rank 3
          able_to_cast = false
          break
        elsif area =~ /nsys|head/ && (h['scar'] > 1 || h['wound'] > 1)
          able_to_cast = false
          break
        elsif area =~ /left(Arm|Hand)/
          stacked_left_scar += h['scar']
          stacked_left_wound += h['wound']
          if (stacked_left_scar > 1 || stacked_left_wound > 1)
            able_to_cast = false
            break
          end
        elsif area =~ /right(Arm|Hand)/
          stacked_right_scar += h['scar']
          stacked_right_wound += h['wound']
          if (stacked_right_scar > 1 || stacked_right_wound > 1)
            able_to_cast = false
            break
          end
        end
      }

      # Eval Sigil of Determination if known
      if !able_to_cast && try_sigil
        able_to_cast = Util.check_determination
      end

      return able_to_cast
    end

    def self.check_determination
      return false unless Ecleanse.data.settings[:determination]
      return false unless Spell["Sigil of Determination"].known?
      return false unless Spell["Sigil of Determination"].affordable?

      Action.determination unless Effects::Buffs.active?("Sigil of Determination")

      stacked_right_scar = 0
      stacked_right_wound = 0
      stacked_left_scar = 0
      stacked_left_wound = 0
      able_to_cast = true
      XMLData.injuries.each { |area, h|
        next unless area =~ /nsys|head|(left|right)(Eye|Arm|Hand)/

        if h['scar'] > 2 || h['wound'] > 2
          able_to_cast = false
        elsif area =~ /left(Arm|Hand)/
          stacked_left_scar += h['scar']
          stacked_left_wound += h['wound']
          if (stacked_left_scar > 2 || stacked_left_wound > 2)
            able_to_cast = false
            break
          end
        elsif area =~ /right(Arm|Hand)/
          stacked_right_scar += h['scar']
          stacked_right_wound += h['wound']
          if (stacked_right_scar > 2 || stacked_right_wound > 2)
            able_to_cast = false
            break
          end
        end
      }

      return able_to_cast
    end

    def self.get_command(command, regex)
      lines = []
      regex = Regexp.union(regex, /(?:\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

      loop do
        lines = Lich::Util.issue_command(command, regex)
        break unless lines.grep(/(?:\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

        Util.wait_rt
      end

      return lines
    end

    def self.get_lines(command, regex)
      lines = []
      regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

      loop do
        lines = Lich::Util.issue_command(command, regex, silent: true, quiet: true)
        break unless lines.grep(/(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

        Util.wait_rt
      end

      return lines
    end

    def self.get_res(command, regex = nil)
      rt_regex = /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./
      regex = regex.nil? ? Regexp.union(/.*?/, rt_regex) : Regexp.union(regex, rt_regex)
      result = nil
      loop do
        result = dothistimeout(command, 3, regex)
        break unless result =~ rt_regex

        Util.wait_rt
      end

      return result
    end

    def self.get_script_version
      data = Script.list.find { |x| x.name == Script.current.name }.inspect
      return data[/version: (\d+\.\d+\.\d+)/i, 1]
    end

    def self.help
      rows = []
      rows << ["#{$lich_char}#{Script.current.name} setup", "UI configuration tool"]
      rows << ["#{$lich_char}#{Script.current.name} load", "Reloads all settings"]
      rows << ["#{$lich_char}#{Script.current.name} list", "Lists all settings"]
      rows << ["#{$lich_char}#{Script.current.name} last disarm", "Lists last disarm room"]

      table = Terminal::Table.new :title => "#{Script.current.name.capitalize} ver #{Util.get_script_version}", :rows => rows
      respond
      respond table
      respond
    end

    def self.msg(type = info, text)
      # color options - set type to use
      # yellow, orange, teal, green, plain

      if text.class == Hash
        text = text.inspect.gsub("#<", "#")
      elsif text.class == Array
        text = text.to_s
      elsif text.class == String
        text = text.gsub("#<", "#")
      end

      type = type == "debug" ? "speech" : type

      Lich::Messaging.msg(type, text)
    end

    def self.wait_rt
      sleep 0.2
      waitcastrt?
      waitrt?
      sleep 0.2
    end
  end

  def self.main_loop
    loop do
      while Ecleanse.data.event_stack.any?
        current_event = Ecleanse.data.event_stack.shift
        Action.send(current_event)
      end

      debuffs = Effects::Debuffs.to_h.keys.map(&:to_s)

      # Assignments outside conditions for clarity
      poisoned = checkpoison || debuffs.any? { |k| k =~ /Wall of Thorns Poison/ }
      rooted_pressed = debuffs.any? { |k| k =~ /Rooted|Pressed/ }
      dispell_debuffs = debuffs.any? { |k| k =~ Ecleanse.data.debuffs }
      webbed_bound = checkwebbed || checkbound
      Ecleanse.data.cloud = GameObj.loot.find { |l| l.name =~ /cloud/i && !Ecleanse.data.invalid_clouds.include?(l.name) && l.type !~ /\bgem\b/i && !Ecleanse.data.bad_targets.include?(l.id) }
      Ecleanse.data.globe = GameObj.loot.find { |l| l.name =~ Ecleanse.data.magic_globes && !Ecleanse.data.bad_targets.include?(l.id) }
      Ecleanse.data.web = GameObj.loot.find { |l| l.noun =~ /web/i && !Ecleanse.data.bad_targets.include?(l.id) }
      determination_injury = Ecleanse.data.settings[:determination] && Ecleanse.data.injury_locations.any? { |limb| XMLData.injuries[limb]["wound"] > 1 }

      conditions = {
        poisoned             => :remove_poison,
        checkdisease         => :remove_disease,
        checkstunned         => :remove_stun,
        webbed_bound         => :remove_web_bound,
        rooted_pressed       => :remove_grounded,
        dispell_debuffs      => :remove_magical,
        Ecleanse.data.cloud  => :dispel_cloud,
        Ecleanse.data.globe  => :avoid_globe,
        Ecleanse.data.web    => :avoid_webs,
        determination_injury => :determination
      }

      # Add events if conditions are met
      conditions.each do |condition, event|
        Ecleanse.data.event_stack << event if condition && !Ecleanse.data.event_stack.include?(event)
      end

      System.scripts_resume if Ecleanse.data.did_something
      sleep 0.2
    end
  end

  unless Ecleanse.data
    Ecleanse.load(Ecleanse.load_profile)
  end

  case Script.current.vars[0]
  when /^setup$/i
    Ecleanse::Setup.new(Ecleanse.data.settings).start
    Ecleanse.load(Ecleanse.load_profile)
  when /load/
    Ecleanse.load(Ecleanse.load_profile)
  when /list/
    Ecleanse::Setup.new(Ecleanse.data.settings).list
  when /last disarm/
    Util.msg("yellow", " Last recorded disarm:  Room #{UserVars.last_disarm}.")
  when nil
    Ecleanse.data.did_something = false
    Ecleanse.data.event_stack = []
    Ecleanse::System.deadmans_switch
    Ecleanse::System.set_hooks
    Ecleanse.main_loop
  else
    Ecleanse::Util.help
  end
end
