# frozen_string_literal: true

=begin
  ECure - Enhanced healing script for Gemstone IV

  A modular healing automation system for Empath characters

  To setup, please run this first:
    ;ecure setup

  Features:
    - Custom healing thresholds per body part
    - Group and room healing capabilities
    - GUI configuration interface
    - Alternative behavior modes

       author: elanthia-online
         game: Gemstone
         tags: heal, cure, empath, healing
      version: 2.0.2
     required: Lich >= 5.12.0

  Improvements:
  Major_change.feature_addition.bugfix
  v2.0.2  (2025-10-17)
    - bugfix in regex for missing hand/arm/leg extra space
  v2.0.1  (2025-09-27)
    - bugfix in wait_for_mana infinite stack level
    - fix to attempt APPRAISE up to 3 times due to failure
    - fix in regex wound array
  v2.0.0  (2025-09-27)
    - rewrite into proper module/class structure
    - regex fixes for additional injury matching
    - retry on spell hindrance
    - condense GUI window
    - add Exertion curing
  v1.0.3 (2023-07-26)
    - correct sleep/pauses for CURE usage for less than 3 second RT
  v1.0.2 (2023-07-26)
    - fix for NilClass comparison for @doneVerb
    - fix for enabling use of CoL signs but not knowing Clotting or Staunching
  v1.0.1 (2023-05-22)
    - fixed group functionality after Naijin's return
  v1.0.0 (2023-04-08)
    - Rebase cure.lic to ecure.lic
    - rubocop cleanup

=end
=begin
PRIOR cure.lic changelog:
    version 1.2 (2021-09-20) Modifications by EO to support aligned menus
    version 1.1 (2019-08-01) Fixed some messaging
    version 1.0              Initial release

This script started as a combination of Heal (by Tayre) and Healself (by Ashraam).  Talonhawke has heavily modified it since then. EO has updated it to support GTK3 (Lich5)
=end

module ECure
  # Configuration and settings management
  class Configuration
    BODY_PARTS = %w[
      head neck abdomen back chest righteye lefteye
      rightleg leftleg rightarm leftarm righthand lefthand nerves
    ].freeze

    MODES = %w[heal hunt].freeze

    # Default healing levels (0-3, where 3 means ignore)
    DEFAULT_LEVEL = 0

    def initialize(character_name)
      @character_name = character_name
      @settings = Settings[character_name] || {}
      load_defaults
    end

    attr_reader :settings

    def done_verb
      @settings['done_verb'] ||= ''
    end

    def done_verb=(value)
      @settings['done_verb'] = value
    end

    def use_signs?
      @settings['use_signs'] ||= false
    end

    def use_signs=(value)
      @settings['use_signs'] = value
    end

    def alternative_behavior?
      @settings['alternative_behavior'] ||= false
    end

    def alternative_behavior=(value)
      @settings['alternative_behavior'] = value
    end

    def use_trolls_blood?
      @settings['use_trolls_blood'] ||= Spell[1125].known?
    end

    def use_trolls_blood=(value)
      @settings['use_trolls_blood'] = value
    end

    def head_nerve_priority?
      @settings['head_nerve_priority'] ||= true
    end

    def head_nerve_priority=(value)
      @settings['head_nerve_priority'] = value
    end

    def mode
      @settings['mode'] ||= 'heal'
    end

    def mode=(value)
      @settings['mode'] = value if MODES.include?(value)
    end

    def all_wounds_level
      @settings['all_wounds_level'] ||= DEFAULT_LEVEL
    end

    def all_wounds_level=(value)
      @settings['all_wounds_level'] = value
    end

    def all_scars_level
      @settings['all_scars_level'] ||= DEFAULT_LEVEL
    end

    def all_scars_level=(value)
      @settings['all_scars_level'] = value
    end

    def wound_level(body_part, mode_type = nil)
      mode_type ||= mode
      key = "#{body_part}_wounds_#{mode_type}"
      [@settings[key] || DEFAULT_LEVEL, all_wounds_level].min
    end

    def scar_level(body_part, mode_type = nil)
      mode_type ||= mode
      key = "#{body_part}_scars_#{mode_type}"
      [@settings[key] || DEFAULT_LEVEL, all_scars_level].min
    end

    def set_wound_level(body_part, level, mode_type = nil)
      mode_type ||= mode
      key = "#{body_part}_wounds_#{mode_type}"
      @settings[key] = level
    end

    def set_scar_level(body_part, level, mode_type = nil)
      mode_type ||= mode
      key = "#{body_part}_scars_#{mode_type}"
      @settings[key] = level
    end

    def save
      Settings[@character_name] = @settings
      Settings.save
    end

    private

    def load_defaults
      BODY_PARTS.each do |part|
        MODES.each do |mode_type|
          @settings["#{part}_wounds_#{mode_type}"] ||= DEFAULT_LEVEL
          @settings["#{part}_scars_#{mode_type}"] ||= DEFAULT_LEVEL
        end
      end
    end
  end

  # Handles spell management for signs
  class SpellManager
    CLOTTING_SPELL = 9909
    STAUNCHING_SPELL = 9905
    TROLLS_BLOOD_SPELL = 1125

    def initialize(config)
      @config = config
      @sign_spell = determine_sign_spell
    end

    def check_signs
      return unless @sign_spell && @config.use_signs?
      return if Spell[@sign_spell].active?

      wait_until { Spell[@sign_spell].affordable? }
      Spell[@sign_spell].cast
    end

    def cast_trolls_blood
      return unless @config.use_trolls_blood?
      return if Spell[TROLLS_BLOOD_SPELL].active?

      if Spell[TROLLS_BLOOD_SPELL].affordable?
        Spell[TROLLS_BLOOD_SPELL].cast
      else
        respond "Waiting on mana to cast Troll's Blood..."
        wait_until { Spell[TROLLS_BLOOD_SPELL].affordable? }
        Spell[TROLLS_BLOOD_SPELL].cast
      end
    end

    private

    def determine_sign_spell
      if Spell[CLOTTING_SPELL].known?
        CLOTTING_SPELL
      elsif Spell[STAUNCHING_SPELL].known?
        STAUNCHING_SPELL
      end
    end
  end

  # Manages healing costs and body part information
  class BodyPartManager
    @cached_mappings = {}

    BODY_PART_COSTS = {
      'head' => 4, 'nerves' => 3, 'neck' => 4,
      'chest' => 5, 'abdomen' => 5, 'back' => 5,
      'rightarm' => 2, 'leftarm' => 2,
      'rightleg' => 2, 'leftleg' => 2,
      'righthand' => 2, 'lefthand' => 2,
      'righteye' => 5, 'lefteye' => 5
    }.freeze

    LICH_NAME_MAPPING = {
      'head' => 'head', 'nerves' => 'nsys', 'neck' => 'neck',
      'chest' => 'chest', 'abdomen' => 'abs', 'back' => 'back',
      'rightarm' => 'rightArm', 'leftarm' => 'leftArm',
      'rightleg' => 'rightLeg', 'leftleg' => 'leftLeg',
      'righthand' => 'rightHand', 'lefthand' => 'leftHand',
      'righteye' => 'rightEye', 'lefteye' => 'leftEye'
    }.freeze

    def self.cost_for(body_part)
      BODY_PART_COSTS[body_part] || 2
    end

    def self.lich_name_for(body_part)
      @cached_mappings[body_part] ||= LICH_NAME_MAPPING[body_part] || body_part
    end

    def self.format_name_for_command(body_part)
      body_part.gsub(/(right|left)(.*)/, '\1 \2')
    end

    def self.critical_parts
      %w[head nerves]
    end
  end

  # Handles target appraisal and wound parsing
  class TargetAppraiser
    def initialize
      @heal_target = nil
    end

    attr_reader :heal_target

    def appraise(target_name)
      wounds = []
      @heal_target = nil

      attempts = 0

      loop do
        break if attempts >= 3
        waitrt?
        lines = Lich::Util.issue_command("appraise #{target_name}", /You take a quick|Appraise what\?|^Usage:/, usexml: true, quiet: true, silent: true)

        lines.each do |line|
          case line
          when /^\s*You take a quick appraisal of <a exist="-\d+" noun=".*">(?<appraised_target>\w+)<\/a> and find that <a exist="-\d+" noun=".*">(?:he|she)<\/a> has (?<detected_wounds>..*)\./
            wounds.push(strip_xml(Regexp.last_match(:detected_wounds)))
            @heal_target = Regexp.last_match(:appraised_target)
          when /Appraise what\?|^Usage:/i
            wounds.push(line)
            @heal_target = target_name
          when /^\s*<a exist="-\d+" noun=".*">(?:He|She)<\/a> has (?<detected_scars>..*)\./
            wounds.push(Regexp.last_match(:detected_scars)) if Skills.mltransference >= 50
          when /^\s*<a exist="-\d+" noun=".*">(?:He|She)<\/a> appears to have <d cmd='transfer .+ exertion'>overexerted<\/d> (?:him|her)self\./
            wounds.push('overexerted')
          end
        end
        break unless @heal_target.nil?
        attempts += 1
      end

      return wounds
    end

    def parse_wounds(wound_line)
      return [] if wound_line =~ /no apparent injuries|no apparent wounds\z/ && wound_line !~ /overexerted/
      wound_line = clean_wound_line(wound_line)
      wound_array = extract_wound_array(wound_line)
      parse_body_parts(wound_array)
    end

    private

    def clean_wound_line(wound_line)
      wound_line.gsub(/arm and/, "arm, ")
                .gsub(/<d cmd.*?>/, "")
                .gsub(/<\/d.*?>/, "")
    end

    def extract_wound_array(wound_line)
      wound_line.scan(/a (?:black-and-blue|severe bruises and swelling around|missing|blinded|swollen|bruised) (?:left|right) eye|old battle scars on (?:his|her) (?:left|right) (?:hand|arm|leg)|mangled (?:left|right) (?:hand|arm|leg)|missing (?:left|right) (?:hand|arm|leg)|deep lacerations across (?:his|her) \w+|deep gashes and serious bleeding (?:on|from|across) (?:his|her) \w+|minor cuts and bruises on (?:his|her) (?:left|right) (?:hand|arm|leg)|a (?:fractured and bleeding|completely severed) (?:left|right) (?:hand|arm|leg)|moderate bleeding from (?:his|her) neck|snapped bones and serious bleeding from the neck|minor bruises on (?:his|her) neck|scar across (?:his|her) neck|some old neck wounds|terrible scars from some serious neck injury|minor (?:bruises|lacerations) about the head|minor cuts and bruises on (?:his|her) (?:chest|back|abdominal area)|severe head trauma and bleeding from the ears|strange case of muscle twitching|case of (?:sporadic|uncontrollable) convulsions|scar across (?:his|her) face|several facial scars|old mutilation wounds about (?:his|her) head|old battle scar across (?:his|her) (?:chest|back|abdominal area)|several painful-looking scars across (?:his|her) (?:chest|back|abdominal area)|terrible, permanent mutilation of (?:his|her) (?:chest|back|abdominal area) muscles|developed slurred speech|constant muscle spasms|a very difficult time with muscle control|overexerted/)
    end

    def parse_body_parts(wound_array)
      body_parts = []

      wound_array.each do |wound|
        case wound
        when /(?:an? )?(?:black-and-blue|severe bruises and swelling around|blinded|mangled|swollen|bruised|missing|deep lacerations across his|deep lacerations across her|cuts and bruises on his|cuts and bruises on her|fractured and bleeding|completely severed|deep gashes and serious bleeding on his|deep gashes and serious bleeding on her|deep gashes and serious bleeding from his|deep gashes and serious bleeding from her|old battle scars on his|old battle scars on her|old battle scar across (?:his|her)|several painful-looking scars across (?:his|her)|terrible, permanent mutilation of (?:his|her)) (?<rightleft>\w+)(?<bodypart> \w+)?/
          body_parts << "#{Regexp.last_match(:rightleft).strip} #{Regexp.last_match(:bodypart).strip}".strip
        when /moderate bleeding from (his|her) neck|snapped bones and serious bleeding from the neck|minor bruises on (his|her) neck|scar across (?:his|her) neck|some old neck wounds|terrible scars from some serious neck injury/
          body_parts << "neck"
        when /minor bruises about the head|minor lacerations about the head|severe head trauma and bleeding from the ears|scar across (?:his|her) face|several facial scars|old mutilation wounds about (?:his|her) head/
          body_parts << "head"
        when /strange case of muscle twitching|case of sporadic convulsions|case of uncontrollable convulsions|developed slurred speech|constant muscle spasms|a very difficult time with muscle control/
          body_parts << "nerves"
        when /overexerted/
          body_parts << "exertion"
        end
      end

      body_parts
    end
  end

  # Main healing engine
  class HealingEngine
    def initialize(config, spell_manager)
      @config = config
      @spell_manager = spell_manager
      @appraiser = TargetAppraiser.new
    end

    # Add this method to the HealingEngine class
    def execute_healing_command(command, required_mana = nil)
      max_attempts = 3
      attempt = 1

      loop do
        # Check mana if required_mana is specified
        if required_mana
          wait_for_mana(required_mana)
        end

        # Ensure we're not in roundtime before attempting
        waitrt?
        waitcastrt?

        # Execute the command and capture the result

        result = dothistimeout(command, 2, /^\[Spell Hindrance|^Cast/)

        case result
        when /^Cast/
          # Command succeeded, we're done
          break
        when /^\[Spell/
          # Spell hindrance occurred
          respond("Spell hindrance detected (attempt #{attempt}/#{max_attempts}), retrying...")
          attempt += 1

          if attempt > max_attempts
            respond("Failed after #{max_attempts} attempts due to spell hindrance")
            break
          end

          # Wait a bit before retrying, longer with each attempt
          sleep(1 + attempt)
          next
        else
          # Timeout or unknown result
          if attempt < max_attempts
            respond("Command timeout or unknown result (attempt #{attempt}/#{max_attempts}), retrying...")
            attempt += 1
            sleep(1)
            next
          else
            respond("Command failed after #{max_attempts} attempts")
            break
          end
        end
      end

      # Standard post-command waits
      sleep(0.5)
      waitcastrt?
      waitrt?
    end

    def heal_exertion
      max_attempts = 3
      attempt = 1

      loop do
        # Check mana if required_mana is specified
        wait_for_mana(7)

        # Ensure we're not in roundtime before attempting
        waitrt?
        waitcastrt?

        # Execute the command and capture the result

        result = Spell[1107].force_incant

        case result
        when /^Cast/
          # Command succeeded, we're done
          break
        when /^\[Spell/
          # Spell hindrance occurred
          respond("Spell hindrance detected (attempt #{attempt}/#{max_attempts}), retrying...")
          attempt += 1

          if attempt > max_attempts
            respond("Failed after #{max_attempts} attempts due to spell hindrance")
            break
          end

          # Wait a bit before retrying, longer with each attempt
          sleep(1 + attempt)
          next
        else
          # Timeout or unknown result
          if attempt < max_attempts
            respond("Command timeout or unknown result (attempt #{attempt}/#{max_attempts}), retrying...")
            attempt += 1
            sleep(1)
            next
          else
            respond("Command failed after #{max_attempts} attempts")
            break
          end
        end
      end

      # Standard post-command waits
      sleep(0.5)
      waitcastrt?
      waitrt?
    end

    def heal_self
      heal_exertion if Effects::Debuffs.active?("Overexerted")

      @spell_manager.cast_trolls_blood

      # Heal wounds first (priority 3 to 0)
      3.downto(0) do |level|
        BodyPartManager::BODY_PART_COSTS.keys.each do |part|
          heal_wound_if_needed(part, level)
        end
      end

      # Then heal scars (priority 3 to 0)
      3.downto(0) do |level|
        BodyPartManager::BODY_PART_COSTS.keys.each do |part|
          heal_scar_if_needed(part, level)
        end
      end

      restore_health
      perform_completion_action
    end

    def heal_target(target_name)
      wounds = @appraiser.appraise(target_name)

      if wounds.empty? || wounds.first =~ /Appraise what|Usage/
        respond("Couldn't find or no injuries on #{target_name}!")
        return
      end

      wound_line = wounds.join(", ")

      if wound_line =~ /no apparent injuries|no apparent wounds\z/ && wound_line !~ /overexerted/
        respond("#{@appraiser.heal_target} does not appear to be injured.")
        return
      end

      heal_target_wounds(wound_line)
    end

    def heal_group
      group_members = get_group_members
      group_members.each { |member| heal_target(member) }
    end

    def heal_room
      room_pcs = GameObj.pcs.map(&:noun)
      room_pcs.each { |pc| heal_target(pc) }
    end

    private

    def heal_wound_if_needed(part, level)
      lich_name = BodyPartManager.lich_name_for(part)
      current_level = Wounds.send(lich_name)
      target_level = @config.wound_level(part)
      return unless current_level == level && current_level > target_level

      handle_critical_parts(part) if BodyPartManager.critical_parts.include?(part) && @config.head_nerve_priority?

      heal_body_part(part, current_level > 1)
    end

    def heal_scar_if_needed(part, level)
      lich_name = BodyPartManager.lich_name_for(part)
      current_scar_level = Scars.send(lich_name)
      current_wound_level = Wounds.send(lich_name)
      target_level = @config.scar_level(part)

      return unless current_scar_level == level &&
                    current_wound_level == 0 &&
                    current_scar_level > target_level

      heal_body_part(part, current_scar_level > 1, true)
    end

    def heal_body_part(part, severe_injury = false, is_scar = false)
      @spell_manager.check_signs
      restore_health

      base_cost = BodyPartManager.cost_for(part)
      mana_cost = calculate_mana_cost(base_cost, severe_injury, is_scar)
      formatted_part = BodyPartManager.format_name_for_command(part)

      execute_healing_command("cure #{formatted_part}", mana_cost)
    end

    def calculate_mana_cost(base_cost, severe_injury, is_scar)
      cost = base_cost
      cost += 5 if severe_injury
      cost += 9 if is_scar
      cost
    end

    def wait_for_mana(required_mana)
      return if Char.mana >= required_mana

      respond("Waiting for mana...")
      until Char.mana >= required_mana
        sleep(1)
      end
    end

    def restore_health
      while Char.percent_health < 90
        execute_healing_command("cure blood", 1)
      end
    end

    def handle_critical_parts(part)
      # Special handling for head and nerve priority healing
      case part
      when 'head'
        heal_to_scar_level('head', 1)
      when 'nerves'
        heal_to_scar_level('nerves', 1)
      end
    end

    def heal_to_scar_level(part, target_level)
      lich_name = BodyPartManager.lich_name_for(part)

      while Scars.send(lich_name) > target_level
        while Wounds.send(lich_name) > 0
          heal_body_part(part, Wounds.send(lich_name) > 1)
        end
        heal_body_part(part, false, true)
      end
    end

    def heal_target_wounds(wound_line)
      body_parts = @appraiser.parse_wounds(wound_line)

      return if body_parts.empty?

      @spell_manager.check_signs

      body_parts.each do |part|
        transfer_wound(part)
      end

      # Continue transferring until no more wounds
      pre_health = Char.health
      post_health = 0
      total_healed = 0

      until pre_health == post_health
        if Char.health <= 75 || Char.percent_health < 51
          restore_health
          next
        end

        pre_health = Char.health
        fput("transfer #{@appraiser.heal_target}")
        post_health = Char.health
        total_healed += (pre_health - post_health)
      end

      report_healing_results(wound_line, total_healed)
      restore_health
    end

    def transfer_wound(part)
      case part
      when /^(left|right) (arm|hand|leg|eye)$/
        if Wounds.send(BodyPartManager.lich_name_for(part.gsub(' ', ''))) == 3
          heal_body_part(part.gsub(' ', ''))
        end
        fput("transfer #{@appraiser.heal_target} #{part}")
      when /abdom/
        heal_body_part('abdomen') if Wounds.abs == 3
        fput("transfer #{@appraiser.heal_target} abdomen")
        sleep(1)
      when 'nerves'
        heal_body_part('nerves') if Wounds.nerves == 3
        fput("transfer #{@appraiser.heal_target} nerves")
        sleep(1)
      when 'head', 'neck'
        heal_body_part(part) if Wounds.send(part) == 3
        fput("transfer #{@appraiser.heal_target} #{part}")
      when 'chest', 'back'
        heal_body_part(part) if Wounds.send(part) == 3
        fput("transfer #{@appraiser.heal_target} #{part}")
      when 'exertion'
        heal_exertion if Effects::Debuffs.active?("Overexerted")
        fput("transfer #{@appraiser.heal_target} #{part}")
      end
    end

    def report_healing_results(wound_description, health_healed)
      if health_healed > 0
        respond "You healed #{@appraiser.heal_target} of #{wound_description} along with #{health_healed} hitpoints."
      else
        respond "You healed #{@appraiser.heal_target} of #{wound_description}."
      end
    end

    def get_group_members
      Lich::Util.issue_command("group", /^You are/, /GROUP HELP/, usexml: false, quiet: true, silent: true)
      return Group.nouns
    end

    def perform_completion_action
      return if @config.done_verb.nil? || @config.done_verb.empty?

      fput @config.done_verb
    end
  end

  # GUI configuration interface
  class ConfigurationGUI
    def initialize(config)
      @config = config
      @window = nil
      @window_action = nil
    end

    def show
      create_gui_window
      wait_for_user_action
      cleanup_gui

      @config.save if @window_action == :save
    end

    private

    def create_gui_window
      Gtk.queue do
        @window = create_main_window
        setup_notebook_interface
        @window.show_all
      end
    end

    def create_main_window
      window = Gtk::Window.new
      window.title = "ECure Configuration"
      window.border_width = 10
      window.signal_connect('delete_event') { @window_action = :cancel }
      window
    end

    def setup_notebook_interface
      notebook = Gtk::Notebook.new

      # Create all tabs
      simple_tab = create_simple_setup_tab
      healing_tab = create_healing_setup_tab
      hunting_tab = create_hunting_setup_tab

      # Add tabs to notebook
      notebook.append_page(simple_tab, Gtk::Label.new("Basic Setup"))
      notebook.append_page(hunting_tab, Gtk::Label.new("Hunting Setup"))
      notebook.append_page(healing_tab, Gtk::Label.new("Healing Setup"))

      # Create main window layout
      main_table = Gtk::Table.new(2, 1, false)
      save_button = create_save_button

      main_table.attach(notebook, 0, 1, 0, 1)
      main_table.attach(save_button, 0, 1, 1, 2)

      @window.add(main_table)
    end

    def create_simple_setup_tab
      table = Gtk::Table.new(6, 4, false)
      table.border_width = 3

      # Row 0: Level controls - more compact with tighter spacing
      table.attach(Gtk::Label.new("Wounds:"), 0, 1, 0, 1, :shrink, :shrink, 2, 1)
      table.attach(create_all_wounds_control, 1, 2, 0, 1, :shrink, :shrink, 8, 1)
      table.attach(Gtk::Label.new("Scars:"), 2, 3, 0, 1, :shrink, :shrink, 2, 1)
      table.attach(create_all_scars_control, 3, 4, 0, 1, :shrink, :shrink, 2, 1)

      # Row 1: Mode toggle - reduced width
      mode_button = create_mode_toggle_button
      mode_button.set_size_request(200, -1)
      table.attach(mode_button, 0, 4, 1, 2, :shrink, :shrink, 2, 2)

      # Row 2-3: Checkboxes in 2x2 grid - more compact
      checkboxes = create_compact_checkbox_controls
      table.attach(checkboxes[:head_nerve_priority], 0, 2, 2, 3, :shrink, :shrink, 2, 1)
      table.attach(checkboxes[:use_trolls_blood], 2, 4, 2, 3, :shrink, :shrink, 2, 1)
      table.attach(checkboxes[:alternative_behavior], 0, 2, 3, 4, :shrink, :shrink, 2, 1)
      table.attach(checkboxes[:use_signs], 2, 4, 3, 4, :shrink, :shrink, 2, 1)

      # Row 4: Done verb - inline layout
      done_hbox = Gtk::Box.new(:horizontal, 5)
      done_hbox.pack_start(Gtk::Label.new("Done:"), expand: false, fill: false, padding: 0)
      done_entry = create_done_verb_entry
      done_entry.set_size_request(120, -1)
      done_hbox.pack_start(done_entry, expand: false, fill: false, padding: 0)
      table.attach(done_hbox, 0, 4, 4, 5, :shrink, :shrink, 2, 1)

      # Row 5: Help text - more compact
      help_label = create_compact_help_text
      help_label.set_size_request(350, -1)
      table.attach(help_label, 0, 4, 5, 6, :shrink, :shrink, 2, 2)

      table
    end

    def create_compact_checkbox_controls
      # Create more compact checkboxes with shorter labels
      head_nerve_priority = create_compact_checkbox(
        "Head/Nerve Priority",
        @config.head_nerve_priority?,
        "Heal head and nerve wounds to Level 1 scar first"
      ) { |active| @config.head_nerve_priority = active }

      use_trolls_blood = create_compact_checkbox(
        "Use Troll's Blood",
        @config.use_trolls_blood?,
        "Cast Troll's Blood before healing"
      ) { |active| @config.use_trolls_blood = active }

      alternative_behavior = create_compact_checkbox(
        "Alt Behavior",
        @config.alternative_behavior?,
        "Different behavior when targeting others"
      ) { |active| @config.alternative_behavior = active }

      use_signs = create_compact_checkbox(
        "Use Signs",
        @config.use_signs?,
        "Use CoL signs to prevent bleeding"
      ) { |active| @config.use_signs = active }

      {
        head_nerve_priority: head_nerve_priority,
        use_trolls_blood: use_trolls_blood,
        alternative_behavior: alternative_behavior,
        use_signs: use_signs
      }
    end

    def create_compact_checkbox(label, initial_state, tooltip, &callback)
      checkbox = Gtk::CheckButton.new(label)
      checkbox.set_active(initial_state)
      checkbox.set_tooltip_text(tooltip)
      checkbox.signal_connect("clicked") do
        callback.call(checkbox.active?)
      end
      checkbox
    end

    def create_done_verb_entry
      entry = Gtk::Entry.new
      entry.set_text(@config.done_verb)
      entry.set_tooltip_text("Action to perform when healing is complete")
      entry.signal_connect("changed") do
        @config.done_verb = entry.text
      end
      entry
    end

    def create_healing_setup_tab
      create_body_part_setup_tab('heal')
    end

    def create_hunting_setup_tab
      create_body_part_setup_tab('hunt')
    end

    def create_body_part_setup_tab(mode_type)
      main_box = Gtk::Box.new(:vertical, 2)
      main_box.border_width = 3

      # Compact instructions
      instructions = Gtk::Label.new("#{mode_type.capitalize}: 3=ignore, 0=heal completely")
      main_box.pack_start(instructions, expand: false, fill: false, padding: 1)

      # Create horizontal layout for wounds and scars - tighter spacing
      content_box = Gtk::Box.new(:horizontal, 5)

      # Wounds column
      wounds_frame = Gtk::Frame.new("Wounds")
      wounds_box = create_compact_body_part_grid(:wounds, mode_type)
      wounds_frame.add(wounds_box)
      content_box.pack_start(wounds_frame, expand: false, fill: false, padding: 2)

      # Scars column
      scars_frame = Gtk::Frame.new("Scars")
      scars_box = create_compact_body_part_grid(:scars, mode_type)
      scars_frame.add(scars_box)
      content_box.pack_start(scars_frame, expand: false, fill: false, padding: 2)

      main_box.pack_start(content_box, expand: false, fill: false, padding: 0)
      main_box
    end

    def create_compact_body_part_grid(injury_type, mode_type)
      table = Gtk::Table.new(7, 2, false)
      table.border_width = 2

      # Group body parts for more compact display
      compact_parts = [
        ['Head', 'head'], ['Neck', 'neck'], ['Chest', 'chest'],
        ['Abdomen', 'abdomen'], ['Back', 'back'], ['Nerves', 'nerves']
      ]

      limb_parts = [
        ['R.Arm', 'rightarm'], ['L.Arm', 'leftarm'],
        ['R.Hand', 'righthand'], ['L.Hand', 'lefthand'],
        ['R.Leg', 'rightleg'], ['L.Leg', 'leftleg'],
        ['R.Eye', 'righteye'], ['L.Eye', 'lefteye']
      ]

      row = 0

      # Add main body parts (one per row) - tighter spacing
      compact_parts.each do |display_name, part|
        label = Gtk::Label.new("#{display_name}:")
        label.set_alignment(0.0, 0.5)
        label.set_size_request(50, -1)
        spin_button = create_body_part_spin_button(part, injury_type, mode_type)

        table.attach(label, 0, 1, row, row + 1, :shrink, :shrink, 1, 1)
        table.attach(spin_button, 1, 2, row, row + 1, :shrink, :shrink, 1, 1)
        row += 1
      end

      # Add separator
      separator = Gtk::HSeparator.new
      table.attach(separator, 0, 2, row, row + 1, :fill, :shrink, 0, 1)
      row += 1

      # Add limbs in a more compact 4x2 grid within the table
      limb_table = Gtk::Table.new(4, 4, false)
      limb_row = 0
      limb_col = 0

      limb_parts.each do |display_name, part|
        box = Gtk::Box.new(:horizontal, 1)
        label = Gtk::Label.new(display_name)
        label.set_size_request(30, -1)
        spin_button = create_body_part_spin_button(part, injury_type, mode_type)
        spin_button.set_size_request(40, -1)

        box.pack_start(label, expand: false, fill: false, padding: 0)
        box.pack_start(spin_button, expand: false, fill: false, padding: 0)

        limb_table.attach(box, limb_col, limb_col + 1, limb_row, limb_row + 1, :shrink, :shrink, 1, 1)

        limb_col += 1
        if limb_col >= 2
          limb_col = 0
          limb_row += 1
        end
      end

      table.attach(limb_table, 0, 2, row, row + 1, :shrink, :shrink, 0, 0)
      table
    end

    def create_body_part_spin_button(part, injury_type, mode_type)
      current_level = if injury_type == :wounds
                        @config.wound_level(part, mode_type)
                      else
                        @config.scar_level(part, mode_type)
                      end

      spin_button = Gtk::SpinButton.new(0, 3, 1)
      spin_button.value = current_level.to_f
      spin_button.set_size_request(50, -1)

      spin_button.signal_connect("value_changed") do
        new_level = spin_button.value.to_i
        if injury_type == :wounds
          @config.set_wound_level(part, new_level, mode_type)
        else
          @config.set_scar_level(part, new_level, mode_type)
        end
      end

      spin_button
    end

    def create_instructions_label
      {
        wounds_label: Gtk::Label.new("All Wounds Target Level"),
        scars_label: Gtk::Label.new("All Scars Target Level"),
        text: Gtk::Label.new(
          "All Wounds & All Scars: Sets the level of wound or scar that will be healed down to.\n" \
          "A value of 3 will do nothing, while 0 will attempt to heal down completely.\n\n" \
          "WARNING: These buttons will override any higher values set on the Hunting and Healing Setup tabs.\n" \
          "They are here for those who want to keep things simple!"
        )
      }
    end

    def create_mode_instructions_label
      Gtk::Label.new(
        "Mode Button: Toggles between settings for Hunting and Healing which can be set on their respective tabs.\n" \
        "You can also change this by typing ;#{Script.current.name} hunt or ;#{Script.current.name} heal"
      )
    end

    def create_all_wounds_control
      control = Gtk::SpinButton.new(0, 3, 1)
      control.value = @config.all_wounds_level.to_f
      control.signal_connect("value_changed") do
        @config.all_wounds_level = control.value.to_i
      end
      control
    end

    def create_all_scars_control
      control = Gtk::SpinButton.new(0, 3, 1)
      control.value = @config.all_scars_level.to_f
      control.signal_connect("value_changed") do
        @config.all_scars_level = control.value.to_i
      end
      control
    end

    def create_mode_toggle_button
      button = Gtk::Button.new(label: @config.mode == 'heal' ? 'Healing Mode Selected' : 'Hunting Mode Selected')
      button.signal_connect('clicked') do
        @config.mode = @config.mode == 'heal' ? 'hunt' : 'heal'
        button.label = @config.mode == 'heal' ? 'Healing Mode Selected' : 'Hunting Mode Selected'
      end
      button
    end

    def create_checkbox_controls
      head_nerve_priority = create_checkbox(
        "Heal Head and Nerves First",
        @config.head_nerve_priority?,
        "If active, will cause the script to heal any head or nervous system wounds down to a Level 1 scar before doing other injuries.\nUseful if you're worried about XP loss from these injuries."
      ) { |active| @config.head_nerve_priority = active }

      use_trolls_blood = create_checkbox(
        "Use Troll's Blood",
        @config.use_trolls_blood?,
        "Checks to see if Troll's Blood is active and will cast it before any healing.\nKeep in mind, if you are low on mana, this will cause you to wait until you have enough to cast 1125."
      ) { |active| @config.use_trolls_blood = active }

      alternative_behavior = create_checkbox(
        "Alternative Behavior",
        @config.alternative_behavior?,
        "Changes script behavior so that ;#{Script.current.name} by itself will heal *you* down, but when targeting others, the script will only heal you down enough to take all their wounds."
      ) { |active| @config.alternative_behavior = active }

      use_signs = create_checkbox(
        "Use Signs",
        @config.use_signs?,
        "Uses powers from a Council (that may or may not exist) to keep you from bleeding."
      ) { |active| @config.use_signs = active }

      {
        head_nerve_priority: head_nerve_priority,
        use_trolls_blood: use_trolls_blood,
        alternative_behavior: alternative_behavior,
        use_signs: use_signs
      }
    end

    def create_checkbox(label, initial_state, tooltip, &callback)
      checkbox = Gtk::CheckButton.new(label)
      checkbox.set_active(initial_state)
      checkbox.set_tooltip_text(tooltip)
      checkbox.signal_connect("clicked") do
        callback.call(checkbox.active?)
      end
      checkbox
    end

    def create_done_verb_control
      entry = Gtk::Entry.new
      entry.set_text(@config.done_verb)
      entry.set_tooltip_text("You can enter an action to do when the script finishes. Helps let others know when you're done healing.")
      entry.signal_connect("changed") do
        @config.done_verb = entry.text
      end

      {
        label: Gtk::Label.new("Optional action for when the script finishes:"),
        entry: entry
      }
    end

    def create_welcome_text
      Gtk::Label.new(
        ";ecure <commands>:\n\n" \
        ";ecure all or ;ecure <target> all\n" \
        "Including the word 'all' will heal you down of all wounds.\n\n" \
        ";ecure group\n" \
        "Heals everyone in your group.\n\n" \
        ";ecure room\n" \
        "Heals everyone in a room. Use this responsibly!\n\n\n" \
        "This script is still very untested!"
      )
    end

    def create_advanced_instructions(mode_type)
      mode_name = mode_type.capitalize
      label = Gtk::Label.new(
        "#{mode_name} Mode:\n" \
        "Here you can set individual heal down levels for each body part. " \
        "Setting a value to 3 will cause that area to be ignored, while " \
        "setting a value to 0 will heal that location completely."
      )
      label.width_request = 300
      label.wrap = true
      label
    end

    def create_body_part_controls(injury_type, mode_type)
      box = Gtk::Box.new(:vertical, 0)

      BodyPartManager::BODY_PART_COSTS.keys.each do |part|
        # Create label
        display_name = part.gsub(/(right|left)(.*)/, '\1 \2').split.map(&:capitalize).join(' ')
        label = Gtk::Label.new("#{display_name}:")
        box.add(label)

        # Create spin button
        current_level = if injury_type == :wounds
                          @config.wound_level(part, mode_type)
                        else
                          @config.scar_level(part, mode_type)
                        end

        spin_button = Gtk::SpinButton.new(0, 3, 1)
        spin_button.value = current_level.to_f

        spin_button.signal_connect("value_changed") do
          new_level = spin_button.value.to_i
          if injury_type == :wounds
            @config.set_wound_level(part, new_level, mode_type)
          else
            @config.set_scar_level(part, new_level, mode_type)
          end
        end

        box.pack_start(spin_button, expand: true, fill: false, padding: 0)
      end

      box
    end

    def create_compact_help_text
      text = "Commands: ;ecure [targets|group|room|all] - Levels: 3=ignore 0=heal completely"
      label = Gtk::Label.new(text)
      label.wrap = true
      label.set_size_request(400, -1)
      label
    end

    def create_save_button
      button = Gtk::Button.new(label: 'Save')
      button.signal_connect('clicked') do
        respond("-=[ Settings Saved ]=-")
        @window_action = :save
      end
      button
    end

    def wait_for_user_action
      before_dying { Gtk.queue { @window&.destroy } }
      wait_while { @window_action.nil? }
      undo_before_dying
    end

    def cleanup_gui
      Gtk.queue { @window&.destroy }
    end
  end

  # Main application controller
  class Application
    def initialize
      validate_character_profession
      @config = Configuration.new(Char.name)
      @spell_manager = SpellManager.new(@config)
      @healing_engine = HealingEngine.new(@config, @spell_manager)
    end

    def run(args = [])
      return show_configuration if setup_requested?(args)
      return show_help if help_requested?(args)

      process_arguments(args)

      case determine_action(args)
      when :heal_self
        @healing_engine.heal_self
      when :heal_targets
        heal_specified_targets(args)
        @healing_engine.heal_self
      when :heal_group
        @healing_engine.heal_group
        @healing_engine.heal_self
      when :heal_room
        @healing_engine.heal_room
        @healing_engine.heal_self
      end

      exit_if_alternative_behavior(args)
    end

    private

    def validate_character_profession
      if Stats.prof != 'Empath'
        respond "Nice try, non-empath person!"
        exit
      end
    end

    def setup_requested?(args)
      args.first =~ /^setup$|^options$/i
    end

    def help_requested?(args)
      args.include?('help')
    end

    def show_configuration
      gui = ConfigurationGUI.new(@config)
      gui.show
      exit
    end

    def show_help
      display_help_text
      exit
    end

    def display_help_text
      respond "ECure - Enhanced Healing Script"
      respond "Valid options:"
      respond "  ecure         - Heal yourself"
      respond "  ecure setup   - Open configuration GUI"
      respond "  ecure <names> - Heal specific targets"
      respond "  ecure group   - Heal group members"
      respond "  ecure room    - Heal everyone in room"
      respond "  ecure all     - Heal completely (overrides settings)"
    end

    def process_arguments(args)
      if args.include?("all")
        @config.all_wounds_level = 0
        @config.all_scars_level = 0
        args.delete("all")
      end

      @config.mode = 'hunt' if args.first =~ /^hunt$/i
      @config.mode = 'heal' if args.first =~ /^heal$/i
    end

    def determine_action(args)
      return :heal_room if args.include?('room')
      return :heal_group if args.include?('group')
      return :heal_targets if find_target_players(args).any?

      :heal_self
    end

    def heal_specified_targets(args)
      targets = find_target_players(args)
      return if targets.empty?

      respond("Attempting to heal #{targets.join(', ')}")
      targets.each { |target| @healing_engine.heal_target(target) }
    end

    def find_target_players(args)
      return [] unless GameObj.pcs&.any?

      targets = []
      failed_targets = []

      args.each do |input|
        next if %w[hunt heal group room all setup options help].include?(input.downcase)

        pc = GameObj.pcs.find { |gameobj_pc| gameobj_pc.noun =~ /^#{input}/i }
        if pc
          targets << pc.noun
        else
          failed_targets << input
        end
      end

      respond("Could not find: #{failed_targets.join(', ')}") if failed_targets.any?
      targets
    end

    def exit_if_alternative_behavior(args)
      exit if @config.alternative_behavior? && args.any?
    end
  end
end

# Script execution
silence_me
before_dying { DownstreamHook.remove("Appraising") }

# Run the application
ecure_app = ECure::Application.new
ecure_app.run(Script.current.vars[1..-1])
