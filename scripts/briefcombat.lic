=begin
    author: Daedeus and Gemini, Jan 2026

    Dramatically shortens most combat text.  By default, will not shorten your own combat actions.

    USAGE:
        ;briefcombat                - will compress other players' combat messages signficantly
        ;briefcombat -x             - more aggressive settings; will silence searches, remove cast descriptions
        ;briefcombat all            - will also compress your own actions
        ;briefcombat all -x         - will also compress your own actions aggressively
        ;briefcombat --exclude=<player1 player2>  - exclude these players from being compressed
        

     author: Daedeus (updates by Tysong/Ragz) and Gemini
       name: briefcombat
       tags: brief, briefcombat, condensing, condense, combat, squelch

    version: 0.1.1 - Jan 2026
      - Refactor into a module instead of using global variables
      - Refactor most regex patterns to the top of the file
      - Start handling sentences of different structure, like ambient (no player noun) or target before verbs.
      - Added more abilities to recognize, a handful of WEAPON and SHIELD ablities.
      - Fix ignore self, by default will not compress self generated actions, unless the "all" paramter is used

    old version: 0.0.8

=end

module BriefCombat
  class Engine
    attr_accessor :extreme_mode, :excluded_players

    # --- Status Effects ---
    # If these strings match, the current target will be considered afflicted with a certain status
    STATUS_EFFECTS = {
      "stunned" => /stunned|strength of holy incantation/,
      "frozen" => /freezes|encased in a thick block of ice|stops all movement/,
      "knockdown" => /falls over|(?:dragged|knocked|down|flattening itself) to the (?:\w+)/,
      "sympathized" => /eyes begin to glow (?:purple|dark)/,
      "pinned" => /pins? (?:.*) to the/,
      "buffeted" => /buffeted by/,
      "dead" => /tries to crawl away on the (?:ground|floor) but|
                 rolls over on the (?:ground|floor) and goes still|
                 body falls to the (?:ground|floor) as it is consumed by ethereal flame|
                 (?:collapses|crashes) to the (?:ground|floor)|
                 grows dim as s?he falls to the (?:ground|floor)|
                 falls to the (ground|floor) motionless/x
    }

    HIS_OR_HER = '(?:<a[^>]+>)?(?:his|her)(?:<\/a>)?'

    # --- Verb Lists ---
    # these verbs match in standard order:  "[Player] [verb] [target]" - where target is optional
    # when a line matches, it will begin a new "combat block", which we will try to shorten
    # this ilne will be the first line in the new shortened block, unless overriden by a "spell guess"
    VERBS_STANDARD = [
      'gestures? at',                #generic spell casting
      'gestures?\.',                 #generic spell casting without target
      'channels? at',
      '(?:hurl|fire|swing|thrust)s? an? [\w \-\']+ at',
      'swings? an? [\w \-\']+ at',
      'slashes with an? [\w \-\']+ at', #Tenchin slashes with a rolaren-edged veil iron troll-claw at a deathsworn fanatic!
      'thrusts?(?: with)? a [\w \-\']+ at',
      'continues to sing a disruptive song',
      'draws an intricately glowing pattern in the air before',
      'chants a reverent litany',
      'skillfully begins to weave another verse into (?:.*) harmony',
      'voice carries the power of thunder as (?:.*) calls out an angry incantation in an unknown language',
      '(?:.*) directing the sound of (?:.*) voice at',   #bardsong
      'punches?(?: with)? an? [\w \-\']+ at',    #brawling punch
      '(?:make a precise )?attempts? to (?:punch|jab|grapple|kick)',  #uac verbs
      'An obscuring brume descends',  #i don't remember
      'take aim and fire an? [\w \-\']+',            #aimed ranged attack
      'turns and sweeps',             #weapon whirlwind
      'charges forward at',           #shield charge
      'lunges forward at',            #shield bash
      'takes a menacing step toward',  #weapon pummel
      'takes quick assessment and raises', #weapon pindown
      'exhales a virulent green mist toward',  #pestilence
      'snap your arm forward',        #shield throw
      "snaps #{HIS_OR_HER} arm forward, (?:throwing|hurling) #{HIS_OR_HER} .+? at",
      'looses arrow after arrow'      #weapon volley
    ]

    # Verbs that match in a reverse order: "[Player] ... [target] ... [verb]"
    # where the target is before the verb in the sentence
    VERBS_TARGET_FIRST = [
      'calls? down(?: the)? excoriating power',  #paladin feat excoriate
    ]

    # Ambient damage messaging, verb first and then target, no player noun
    VERBS_AMBIENT = [
      'Fiery debris explodes from the ground', #earthen fury damage cycle
      'Craggy debris explodes from the ground',
      'The earth cracks beneath',
      'Icy stalagmites burst from the ground',
      'flies out of the shadows toward', #sniper attack
      'Light and dark pockmarks appear', #pestilence
      'sickly green miasma around', 
      'Black waves billow outward from', #Hallowed Reprisal
      'long throny vine lashes out', #vine
      'charges forward and bites' #porcupine animal companion attack
    ]

    # Ambient damage messaging, target first and then verb, no player noun
    VERBS_AMBIENT_2 = [
      'convulses with a crippling affliction', #pestilence damage cycle
      'as virulent green mist passes through',
      'Large hailstones pound relentlessly',
      'spiritual malady wracks',
    ]
    # --- Spell Guessing Data Structure ---
    # Format: [Regex, Spell ID, Include Line?]
    #   - Include Line? (boolean): this will save the matching line and include it in the compressed block
    #         except on "extreme" mode
    #    
    SPELL_GUESS_PATTERNS = [
      [/arms snatch viciously|grotesque limbs/, '709', true],
      [/dark ethereal (waves|sphere)/, '410', true],
      [/(?:waves?|sphere) of .* (?:expands|moves)/, '435', true],
      [/radiant burst of light/, '135', true],
      [/multitude of sharp pieces of debris splinter off from underfoot|The surroundings advance upon/, '635', true],
      [/debris explodes from the ground beneath/, '917', true],
      [/a bolt of churning air/, '505', true],
      [/An airy mist rolls into the (?:area|room)/, '512', true],
      [/force of the sonic vibrations/, '1030', false],
      [/eyes begin to glow (?:purple|dark)/, '1120', false],
      [/pulse of pearlescent energy ripples/, '1106', false],
      [/A nebulous haze shimmers into view around/, '1115', true],
      [/(?:hurl|fire|hurtles forth)s? an? [\w \-\']+ at/, 'ball', false],
      [/hand before it takes the shape of an ethereal chain of keys|A cold mist drifts in, blanketing the area|thunderous din echoes all around as the very earth shudders beneath/, '335', true],
      [/reels under the force of the sonic vibrations/, '1030', false],
      [/utters a pious chant (.*) Suddenly a divine force radiates out from/, '1618', true],
      [/unleashes a compact swirling vortex/, '518', true],
      [/scintillating, blue-white aura encompasses/, '302', false],
      [/ambient temperature abruptly plummets/, '309', false],
      [/manifests as an ethereal, pure golden censer/, '320', false],
      [/several faintly glowing snowflakes settle/, '335', false],
      [/hazy film/, '119', false],
      [/an invisible force guides|considerably more powerful|feel the magic surge through you/, nil, false],
      [/appears more confident/, '211', false],
      [/leaving behind a sucking void/, '720', false]
    ]

    # --- Regex Components ---
    PC_OR_YOU_PATTERN = '<a exist="(-?\d+)" noun="[^"]+">[^<]+<\/a>|You'
    TARGET_PATTERN    = '<pushBold\/>(.*?)<popBold\/>'

    # --- Compiled Combat Regexes ---
    COMBAT_REGEX              = /(#{PC_OR_YOU_PATTERN}) (#{VERBS_STANDARD.join('|')})(?: (?:an? |the |some )?(#{TARGET_PATTERN}))?/

    # Alternative regex for sentences that show the target before the matching verbs
    COMBAT_TARGET_FIRST_REGEX = /(#{PC_OR_YOU_PATTERN}).*(#{TARGET_PATTERN}).*(#{VERBS_TARGET_FIRST.join('|')})/
    
    # Ambient damage or follow up attacks, tend to have no source
    COMBAT_AMBIENT_REGEX      = /^.*?(?:#{VERBS_AMBIENT.join('|')}).*?(#{TARGET_PATTERN})/

    COMBAT_AMBIENT_2_REGEX    = /^.*?(#{TARGET_PATTERN}).*?(?:#{VERBS_AMBIENT_2.join('|')})/

    # --- Filter Regexes ---
    FILTER_SELF_SPELLS_CASTTIME = /(<castTime value='\d+'\/>)/
    FILTER_SELF_SPELLS_EXIST    = /<spell exist='spell'>([\w ']+)<\/spell>/
    FILTER_SELF_SPELLS_MSG      = /Your spell(song)? is ready\.|You gesture\.|Cast Roundtime \d Seconds.?/
    FILTER_SELF_SEARCH          = /You search the <pushBold\/>|<pushBold\/>.*<popBold\/> (had nothing of interest|didn't carry any silver|had nothing else of value)/
    FILTER_OTHER_SEARCH         = /(<a exist="(?:-\d+)" noun="\w+">\w+<\/a>) searches (<pushBold\/>.*<popBold\/>)/
    FILTER_OTHER_SPELL_PREP     = /appears to be focusing (?:his|her) thoughts while chanting|traces a simple symbol as (?:he|she) reverently calls/
    FILTER_SIGILS               = /faint blue glow (?:fades|surrounds)|shimmering aura (?:fades|surrounds)/

    # Simple Squelch Filters: Any line matching these will be squelched
    SIMPLE_FILTERS = [
      /Roundtime:/,
      /incandescent veil fades/, # 1608
      /knobby layer of bark/, # 605
      /briefly before decaying into dust./, # 709 decay
      /In a breathtaking display of ability and combat mastery|spins about looking mighty stirred up|looks determined and focused/, # mstrike prep
      /removes a single(.*)from/, # get arrow
      /nocks? an?/, # arrow nock
    ]

    def initialize(script_vars)
      args = script_vars[1..-1] || []
      @extreme_mode = args.delete("-x") ? true : false
      
      if @extreme_mode
        echo "Extreme mode!  Will more aggressively shorten non-essential text, at the cost of immersion."
      else
        echo "Standard mode!  Run with -x parameter for Extreme mode."
      end

      @compress_self = args.delete("all") ? true : false

      @excluded_players = []
      
      full_line = script_vars[0] || ""
      if full_line =~ /--exclude=(["']?)(.+?)\1(?:\s+(?:-x|all)\b|$)/
         exclude_str = $2
         @excluded_players.concat(exclude_str.split(/[\s,]+/))
      end

      @excluded_players << "You" unless @compress_self
      @excluded_players.map! { |p| (p.downcase == "self" || p.downcase == "you") ? "You" : p }
      @excluded_players.uniq!

      if @excluded_players.length > 0
        echo "Will exclude actions by #{@excluded_players.join(', ')}"
      end

      # State variables
      @compressing = false
      @compressed = nil
      @compress_last = nil
      @compress_you_last = nil
      @targets_damage = nil
      @target = nil
      @targets_last_message = nil
      @targets_status = nil
      @is_no_target = false
      @is_buff = false
      @shortening_search = false 
      @is_self = false
      @compressing_spell_guess = nil
      @spell_cast_string = nil
      @compressing_better_action_message = nil
      
      fput 'set MonsterBold On'
    end

    def spell_name(id)
      if id == "709"
        return "Grasp of the Grave"
      else
        return Spell[id].name
      end
    end

    def begin_compress(s, targetstr)
      targetstr =~ /<a exist="(\d+)"/
      targetid = $1
      @is_no_target = targetid.nil?
      
      unless @compressing
        @compressing = true
        @compressing_spell_guess = nil  #a guess as to which spell is cast (string integer ie "901"), will look up the name of the spell
        @compressing_spell_guess = 9811 if s =~ /draws an intricately glowing pattern in the air before/
        @spell_cast_string = nil       #an extra line that is informative enough to include in the compressed block
        @compressing_better_action_message = nil    #a string that could be used as the first line in the compressed block
        @targets_damage = Hash.new    #a hash to tally up the damage received by each target
        @targets_last_message = Hash.new  #a hash to store the last line seen for each target
        @targets_status = Hash.new    #a hash to store the status changes for each affected target
        @compress_you_last = nil  #the last seen line that includes the word "You"
        @compress_last = nil
        @is_buff = false
        @first_line_has_damage = false

        @compressed = Array.new    
        @compressed.push(s.chomp)
        @target = nil

        unless targetid.nil?
          @target = targetid
          @targets_damage[targetid] = 0 
          @targets_last_message[targetid] = s

          if s =~ /(\d+) points? of damage/ #sometimes the first line contains damage
            @targets_damage[@target] += $1.to_i
            @first_line_has_damage = true
          end
        end

      end
    end

    def end_compress(s)
    
       # echo "END! #{s}"
      @compressing = false
      num_targets = @targets_damage.length

      # here we try to replace the vague "You gesture" with something more specific
      unless @compressing_spell_guess.nil?
        if @compressing_spell_guess == "ball"
          @compressed[0] = @compressing_better_action_message
        else
          if @is_self
            literal = "cast #{spell_name(@compressing_spell_guess)}"
            @compressed[0] = @compressed[0].gsub(/gesture/, literal)
          else
            if @compressing_spell_guess == '1030'
              literal = "weaves #{spell_name(@compressing_spell_guess)}"
              @compressed[0] = @compressed[0].gsub(/skillfully begins to weave another verse/, literal)
            elsif @compressing_spell_guess =~ /309|320|335/
              literal = "chants #{spell_name(@compressing_spell_guess)}"
              @compressed[0] = @compressed[0].gsub(/chants a reverent litany.*/, literal)
            else
              literal = "casts #{spell_name(@compressing_spell_guess)}"
              @compressed[0] = @compressed[0].gsub(/gestures/, literal)
            end
          end
        end
      end

      unless @spell_cast_string.nil? || @extreme_mode
        @compressed.push(@spell_cast_string)
      end

      if num_targets == 0
        if @spell_cast_string.nil?
          @compressed.push(@compress_last) 
        elsif !@compress_you_last.nil?
          @compressed.push(@compress_you_last)
        end
      elsif @is_no_target
        @compressed[0] += ", #{num_targets} targets affected."
      elsif num_targets > 1
        @compressed[0].chop! 
        @compressed[0] += " and 1 other." if num_targets == 2
        @compressed[0] += " and #{num_targets-1} others." if num_targets > 2
      end

      sleep 0.05

      if num_targets > 0
        num_stunned = 0
        num_knockdown = 0
        num_frozen = 0
        num_confused = 0
        num_dead = 0
        num_sympathized = 0
        num_pinned = 0
        num_buffeted = 0
        total_damage = 0
        killed = Array.new #this array is for avoiding double counting of kills
        @targets_damage.each { |targetid, damage| 
          targ = GameObj.npcs.find{ |i| i.id == targetid}
          if targ.status =~ /dead/
            num_dead += 1
            killed.push(targetid)
          end
          total_damage += damage

          if @first_line_has_damage #damage was included in the first line, just sub that number out with the total (assume there is only one target)
            @compressed[0].gsub(/(\d+)/, "#{damage}")
          end
        }

        @targets_status.each { |targetid, statusArr| 
          num_stunned += 1 if statusArr.any? "stunned"
          
          if statusArr.any? "knockdown"
            num_knockdown += 1 
          elsif statusArr.any? "buffeted"
            num_buffeted += 1 
          end
          num_frozen += 1 if statusArr.any? "frozen"
          num_pinned += 1 if statusArr.any? "pinned"
          num_sympathized += 1 if statusArr.any? "sympathized"

          num_dead += 1 if statusArr.any?("dead") && !killed.include?(targetid)
        }

        if num_dead + num_stunned + num_knockdown + num_sympathized + num_frozen + num_confused + num_pinned + num_buffeted + total_damage == 0
          @compressed.push(@compress_last) if @spell_cast_string.nil?
        else
          str = []
          str.push "#{num_dead} targets <pushBold/>KILLED<popBold/>" if num_dead > 0
          str.push "#{num_knockdown} targets knocked down" if num_knockdown > 0
          str.push "#{num_stunned} targets stunned" if num_stunned > 0
          str.push "#{num_frozen} targets frozen" if num_frozen > 0
          str.push "#{num_sympathized} targets sympathized" if num_sympathized > 0
          str.push "#{num_pinned} targets pinned" if num_pinned > 0
          str.push "#{num_buffeted} targets buffeted" if num_buffeted > 0
          str.push "#{total_damage} damage dealt" if total_damage > 0 && !@first_line_has_damage
          @compressed.push("  ... #{str.join(', ')}!") if str.length > 0
        end
      end

      @compressed.push(s)
      @compressed.push('')
      result = @compressed.join("\n")
      return result
    end

    def compress(s)
      return if s =~ /Cast Roundtime/
      @compress_last = s
      @compress_you_last = s if s =~ /You/

      s.chomp!
      
      checkstatus = proc { |str, targetid|
        STATUS_EFFECTS.each { |status, regex|
          if str =~ regex
            @targets_status[@target] = Array.new if @targets_status[@target].nil?
            @targets_status[@target].push(status)
          end
        }
      }

      if s =~ /(\d+) points? of damage/
        @targets_damage[@target] += $1.to_i
      elsif s =~ /<a exist="(\d+)"/ #switch target if line contains one
        @target = $1 if GameObj.npcs.any? {|npc| npc.id == $1}
        @targets_damage[@target] = 0 unless @targets_damage.has_key?(@target)
        checkstatus.call(s, @target)

        @targets_last_message[@target] = s
      elsif s !~ /Cast Roundtime|Forcing stance down|appears to gain succour|Feeling nervous yet|A hit|Warding failed/
        @targets_last_message[@target] = s
      elsif s =~ /CS:|AS:|UAF:/
        #just numbers
      else
        checkstatus.call(s, @target)
      end

      # here we listen for clues as to which spell or ability was used, so we can name it
      SPELL_GUESS_PATTERNS.each do |regex, id, capture|
        if s =~ regex
          @compressing_spell_guess = id if id
          @spell_cast_string = s if capture && @spell_cast_string.nil?
          @compressing_better_action_message = s if id == 'ball' #ball spells are a special case that replace the "gesture" with the action message
          break
        end
      end
    end

    def brief(s)
      no_self_spells = proc{ |str|
        if str =~ FILTER_SELF_SPELLS_CASTTIME
          return str[0,$~.end(0)]
        elsif str =~ FILTER_SELF_SPELLS_EXIST
          return $&
        end

        return nil if str =~ FILTER_SELF_SPELLS_MSG
      }

      no_self_search = proc{ |str|
        if str =~ FILTER_SELF_SEARCH
          return nil 
        end
      }

      shorten_searches = proc{ |str| 
        if str =~ FILTER_OTHER_SEARCH
          @shortening_search = true 
          return str unless @extreme_mode
          return nil
        end
      }

      if @shortening_search
        if s =~ /<prompt/
          @shortening_search = false
          return nil
        else
          return nil
        end
      end

        #A wooden arrow flies out of the shadows toward <pushBold/>a <a exist="151226829" noun="sentinel">lithe veiled sentinel</a><popBold/>!
        
      compress_combat = proc{ |str|
        if str =~ COMBAT_REGEX
            target_string = $4
            @is_self = $1 == 'You'
            
           # echo "MATCH! #{str}"
            unless @excluded_players.any? { |p| $1.include?(p) }
                begin_compress(str, target_string)
                return nil
            end
        elsif str =~ COMBAT_TARGET_FIRST_REGEX
            target_string = $3
            @is_self = $1 == 'You'
            unless @excluded_players.any? { |p| $1.include?(p) }
                begin_compress(str, target_string)
                return nil
            end
        elsif str =~ COMBAT_AMBIENT_REGEX
            target_string = $2
            begin_compress(str, target_string)
            return nil
        elsif str =~ COMBAT_AMBIENT_2_REGEX
            target_string = $1
            begin_compress(str, target_string)
            return nil
        end
      }

      if @compressing
        return end_compress(s) if s =~ /<prompt/

        compress(s)
        return nil
      end

      if !@excluded_players.nil? && @excluded_players.any? { |x| s.include? x }
        return s
      end
      
      SIMPLE_FILTERS.each { |regex| return nil if s =~ regex }

      compress_combat.call s
      no_self_spells.call s unless @excluded_players.include? "You"
      no_self_search.call s
      shorten_searches.call s

      s
    end
  end
end

engine = BriefCombat::Engine.new(script.vars)

DownstreamHook.add('brief2', proc{ |s| engine.brief(s) })
before_dying{DownstreamHook.remove('brief2')}
while true;sleep 1;end