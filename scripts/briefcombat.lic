=begin

    Dramatically shortens most combat text. By default, will not shorten your own combat actions.

    USAGE:
        ;briefcombat                        - compress other players' combat messages significantly
        ;briefcombat -x                     - extreme mode; will silence searches, remove cast descriptions
        ;briefcombat all                    - will also compress your own actions
        ;briefcombat all -x                 - will also compress your own actions aggressively
        ;briefcombat --exclude=<players>    - exclude these players from being compressed
        ;briefcombat --debug                - enable debug output for troubleshooting
        ;briefcombat --help                 - show detailed help information
        ;briefcombat --list                 - show current settings from CharSettings

        author: Daedeus
  contributors: Tysong, Ragz, Gemini AI
          name: briefcombat
          tags: brief, briefcombat, condensing, condense, combat, squelch
       version: 1.0.0

    changelog:
      1.0.0 (2026-01-25)
        - Refactor into a module instead of using global variables
        - Refactor most regex patterns to the top of the file
        - Start handling sentences of different structure, like ambient (no player noun) or target before verbs
        - Added more abilities to recognize, a handful of WEAPON and SHIELD abilities
        - Fix ignore self, by default will not compress self generated actions, unless the "all" parameter is used
        - Added CharSettings support to remember settings between runs
        - Added --help flag to display usage information
        - Added --list flag to show current settings
        - Added --debug flag to enable debug output
        - Improved parameter parsing with --no-extreme and --no-all options

=end
=begin
    old changelog:
      0.0.7 (2020-05-14)
        - Added parameter options:
            -x        Extreme mode, will squelch searches and spell messaging
            [player]  Added ability to not shorten actions by specific players
        - Removed spell number to improve immersion
        - Now retains a little bit of spell cast color, for immersion, this can be disabled with the "-x" parameter
        - Improve handling of bard song weaving
        - Fixed a known issue, now (more) accurately counts kills and status effects
        - Added indentation to kill / stunned counts
      0.0.6 (2020-05-05)
        - Revert 0.0.5 changes and added a bunch of new code
        - Detection of most common AOE spells, and more aggressive shortening of their text
          when no damage is dealt, will preserve last message. This allows most buffs (117, 515, etc) to show correctly
        - Hopefully improved detection of 709 arms decaying
      0.0.5 (2020-05-01)
        - fix for additional condensing of various casting
        - fix to now show player deaths (previously would squelch/hide)
      0.0.4 (2017-05-15)
        - added a 50ms sleep so GameObj can update npc status,
        - increasing reliability of status effects
      0.0.3 (2017-04-16)
        - add catch for polearms
      0.0.2 (unknown)
        - cleaned up some comments, unused code
      0.0.1 (unknown)
        - initial release

=end

module BriefCombat
  class Engine
    attr_accessor :extreme_mode, :excluded_players

    # --- Status Effects ---
    # If these strings match, the current target will be considered afflicted with a certain status
    @status_effects = {
      "stunned"     => /stunned|strength of holy incantation/,
      "frozen"      => /freezes|encased in a thick block of ice|stops all movement/,
      "knockdown"   => /falls over|(?:dragged|knocked|down|flattening itself) to the (?:\w+)|collapses on/,
      "sympathized" => /eyes begin to glow (?:purple|dark)/,
      "pinned"      => /pins? (?:.*) to the/,
      "webbed"      => /ensnared in thick strands of webbing/,
      "buffeted"    => /buffeted by/,
      "dead"        => /tries to crawl away on the (?:ground|floor) but|
                 rolls over on the (?:ground|floor) and goes still|
                 body falls to the (?:ground|floor) as it is consumed by ethereal flame|
                 (?:collapses|crashes) to the (?:ground|floor)|
                 grows dim as s?he falls to the (?:ground|floor)|
                 falls to the (ground|floor) motionless/x
    }.freeze

    @his_or_her = '(?:<a[^>]+>)?(?:his|her)(?:<\/a>)?'
    @himself_or_herself = '(?:<a[^>]+>)?(?:himself|herself)(?:<\/a>)?'

    # --- Verb Lists ---
    # these verbs match in standard order: "[Player] [verb] [target]" - where target is optional
    # when a line matches, it will begin a new "combat block", which we will try to shorten
    # this line will be the first line in the new shortened block, unless overridden by a "spell guess"
    @verbs_standard = [
      'gestures? at',                # generic spell casting
      'gestures?\.',                 # generic spell casting without target
      'channels? at',
      'waves? (?:your|an?) .+? at',  # wand casting (self: "wave your wand", others: "waves a wand")
      '(?:hurl|fire|swing|thrust)s? an? [\w \-\']+ at',
      'swings? an? [\w \-\']+ at',
      'slashes with an? [\w \-\']+ at', # Tenchin slashes with a rolaren-edged veil iron troll-claw at a deathsworn fanatic!
      'thrusts?(?: with)? a [\w \-\']+ at',
      'continues to sing a disruptive song',
      'draws an intricately glowing pattern in the air before',
      'chants a reverent litany',
      'skillfully begins to weave another verse into (?:.*) harmony',
      'voice carries the power of thunder as (?:.*) calls out an angry incantation in an unknown language',
      '(?:.*) directing the sound of (?:.*) voice at', # bardsong
      'punches?(?: with)? an? [\w \-\']+ at', # brawling punch
      '(?:make a precise )?attempts? to (?:punch|jab|grapple|kick)', # uac verbs
      'An obscuring brume descends', # i don't remember
      'take aim and fire an? [\w \-\']+', # aimed ranged attack
      'turns and sweeps', # executioner's stance follow up
      'lashes out again and again with the force of a reaping whirlwind', # weapon whirlwind
      'charges forward at',           # shield charge
      'lunges forward at',            # shield bash
      'takes a menacing step toward', # weapon pummel
      "brings #{@his_or_her} .+? around in a tight arc to batter", # weapon thrash cycle
      'takes quick assessment and raises', # weapon pindown
      'exhales a virulent green mist toward', # pestilence
      'snap your arm forward', # shield throw
      "snaps #{@his_or_her} arm forward, (?:throwing|hurling) #{@his_or_her} .+? at", # shield throw
      'looses arrow after arrow', # weapon volley
      "hurls #{@himself_or_herself} at", # cman tackle
      "slowly moves #{@his_or_her} hand in a (?:waving|pushing|throwing|slapping|clenching|pounding) motion" # 514
    ].freeze

    # Verbs that match in a reverse order: "[Player] ... [target] ... [verb]"
    # where the target is before the verb in the sentence
    @verbs_target_first = [
      'calls? down(?: the)? excoriating power', # paladin feat excoriate
      'deliver a sound thrashing', # weapon thrash
    ].freeze

    # Ambient damage messaging, verb first and then target, no player noun
    @verbs_ambient = [
      'Fiery debris explodes from the ground', # earthen fury damage cycle
      'Craggy debris explodes from the ground',
      'The earth cracks beneath',
      'Icy stalagmites burst from the ground',
      'flies out of the shadows toward', # sniper attack
      'Light and dark pockmarks appear', # pestilence
      'sickly green miasma around',
      'waves billow outward from', # Hallowed Reprisal
      'long thorny vine lashes out', # vine
      'charges forward and bites', # porcupine animal companion attack
      'raging sandstorm swirls around', # 914
      'burst of flame leaps from', # 915 fire
      'devastating inferno of flaming rocks ignites the entire sky', # 525 meteor swarm cycle
      'flaming rocks burst from the sky and smite the area', # 525
      'Ripples of cold white flame flare up around', # cleric cycle
      'several faintly glowing snowflakes settle upon', # 335 cycle
    ].freeze

    # Ambient damage messaging, target first and then verb, no player noun
    @verbs_ambient_2 = [
      'convulses with a crippling affliction', # pestilence damage cycle
      'as virulent green mist passes through',
      'Large hailstones pound relentlessly',
      'spiritual malady wracks',
    ].freeze

    # --- Spell Guessing Data Structure ---
    # Format: [Regex, Spell ID, Include Line?]
    #   - Include Line? (boolean): this will save the matching line and include it in the compressed block
    #         except on "extreme" mode
    #
    @spell_guess_patterns = [
      [/radiant burst of light/, '135', true],
      [/shoot strands of webbing/, 'ball', false], # treat 118 evoke as a ball spell- will use this sentence as the first message, replace generic "gesture"
      [/hazy film/, '119', false],
      [/appears more confident/, '211', false],
      [/scintillating, blue-white aura encompasses/, '302', false],
      [/ambient temperature abruptly plummets/, '309', false],
      [/manifests as an ethereal, pure golden censer/, '320', false],
      [/several faintly glowing snowflakes settle/, '335', false],
      [/hand before it takes the shape of an ethereal chain of keys|A cold mist drifts in, blanketing the area|thunderous din echoes all around as the very earth shudders beneath/, '335', true],
      [/dark ethereal (waves|sphere)/, '410', true],
      [/(?:waves?|sphere) of .* (?:expands|moves)/, '435', true],
      [/surrounded by a circle of flickering flame/, '502', false], # 502 fire
      [/a bolt of churning air/, 'ball', false],
      [/An airy mist rolls into the (?:area|room)/, '512', true],
      [/unleashes a compact swirling vortex/, '518', true],
      [/Wisps of black smoke swirl around/, '519', true],
      [/multitude of sharp pieces of debris splinter off from underfoot|The surroundings advance upon/, '635', true],
      [/arms snatch viciously|grotesque limbs/, '709', true],
      [/leaving behind a sucking void/, '720', false],
      [/gust of wind tugs at your sleeves/, '912', false],
      [/debris explodes from the ground beneath/, '917', true],
      [/force of the sonic vibrations/, '1030', false],
      [/reels under the force of the sonic vibrations/, '1030', false],
      [/pulse of pearlescent energy ripples/, '1106', false],
      [/A nebulous haze shimmers into view around/, '1115', true],
      [/eyes begin to glow (?:purple|dark)/, '1120', false],
      [/utters a pious chant (.*) Suddenly a divine force radiates out from/, '1618', true],
      [/(?:hurl|fire|hurtles forth)s? an? [\w \-\']+ at/, 'ball', false], # special case for "ball" spells, replace "gesture" line with this line
      [/an invisible force guides|considerably more powerful|feel the magic surge through you/, nil, false],

    ].freeze

    # --- Regex Components ---
    @pc_or_you_pattern = '<a exist="(-?\d+)" noun="[^"]+">[^<]+<\/a>|You'
    @target_pattern    = '<pushBold/>(.*?)<popBold/>'

    # --- Compiled Combat Regexes ---
    @combat_regex              = /(#{@pc_or_you_pattern}) (#{@verbs_standard.join('|')})(?: (?:an? |the |some )?(#{@target_pattern}))?/

    # Alternative regex for sentences that show the target before the matching verbs
    @combat_target_first_regex = /(#{@pc_or_you_pattern}).*(#{@target_pattern}).*(#{@verbs_target_first.join('|')})/

    # Ambient damage or follow up attacks, tend to have no source
    @combat_ambient_regex      = /^.*?(?:#{@verbs_ambient.join('|')}).*?(#{@target_pattern})/

    @combat_ambient_2_regex    = /^.*?(#{@target_pattern}).*?(?:#{@verbs_ambient_2.join('|')})/

    # --- Filter Regexes ---
    @filter_self_spells_casttime = /(<castTime value='\d+'\/>)/
    @filter_self_spells_exist    = /<spell exist='spell'>([\w ']+)<\/spell>/
    @filter_self_spells_msg      = /Your spell(song)? is ready\.|You gesture\.|Cast Roundtime \d Seconds.?/
    @filter_self_search          = /You search the <pushBold\/>|<pushBold\/>.*<popBold\/> (had nothing of interest|didn't carry any silver|had nothing else of value)/
    @filter_other_search         = /(<a exist="(?:-\d+)" noun="\w+">\w+<\/a>) searches (<pushBold\/>.*<popBold\/>)/
    @filter_other_spell_prep     = /appears to be focusing (?:his|her) thoughts while chanting|traces a simple symbol as (?:he|she) reverently calls/
    @filter_sigils               = /faint blue glow (?:fades|surrounds)|shimmering aura (?:fades|surrounds)/

    # Simple Squelch Filters: Any line matching these will be squelched
    @simple_filters = [
      /Roundtime:/,
      /incandescent veil fades/, # 1608
      /knobby layer of bark/, # 605
      /briefly before decaying into dust./, # 709 decay
      /In a breathtaking display of ability and combat mastery|spins about looking mighty stirred up|looks determined and focused/, # mstrike prep
      /removes a single(.*)from/, # get arrow
      /nocks? an?/, # arrow nock
    ].freeze

    def initialize(script_vars)
      args = script_vars[1..-1] || []

      # Handle --help first
      if args.include?("--help") || args.include?("-h")
        show_help
        exit
      end

      # Initialize or load settings from CharSettings
      CharSettings['briefcombat'] ||= {}
      @settings = CharSettings['briefcombat']

      # Handle --list
      if args.include?("--list")
        show_settings
        exit
      end

      # Check for --debug flag
      @debug = args.delete("--debug") || args.delete("-d")

      # Check for extreme mode
      if args.include?("-x") || args.include?("--extreme")
        args.delete("-x")
        args.delete("--extreme")
        @extreme_mode = true
        @settings['extreme_mode'] = true
      elsif args.include?("--no-extreme")
        args.delete("--no-extreme")
        @extreme_mode = false
        @settings['extreme_mode'] = false
      else
        # Use saved setting or default to false
        @extreme_mode = @settings['extreme_mode'] || false
        @settings['extreme_mode'] = @extreme_mode # Save the value even if it's the default
      end

      # Check for compress self/all
      if args.include?("all") || args.include?("--all")
        args.delete("all")
        args.delete("--all")
        @compress_self = true
        @settings['compress_self'] = true
      elsif args.include?("--no-all")
        args.delete("--no-all")
        @compress_self = false
        @settings['compress_self'] = false
      else
        # Use saved setting or default to false
        @compress_self = @settings['compress_self'] || false
        @settings['compress_self'] = @compress_self # Save the value even if it's the default
      end

      # Handle excluded players
      @excluded_players = []
      full_line = script_vars[0] || ""
      if full_line =~ /--exclude=(["']?)(.+?)\1(?:\s+|$)/
        exclude_string = Regexp.last_match(2)
        @excluded_players.concat(exclude_string.split(/[\s,]+/))
        @settings['excluded_players'] = @excluded_players
      elsif @settings['excluded_players'] && !@settings['excluded_players'].empty?
        @excluded_players = @settings['excluded_players'].dup
      else
        # Initialize to empty array if not set
        @settings['excluded_players'] = []
      end

      # Always exclude "You" unless compress_self is true
      @excluded_players << "You" unless @compress_self
      @excluded_players.map! { |player| (player.downcase == "self" || player.downcase == "you") ? "You" : player }
      @excluded_players.uniq!

      # Display startup messages
      if @extreme_mode
        echo("Extreme mode! Will more aggressively shorten non-essential text, at the cost of immersion.")
      else
        echo("Standard mode! Run with -x parameter for Extreme mode.")
      end

      echo("Will exclude actions by #{@excluded_players.join(', ')}") unless @excluded_players.empty?
      echo("DEBUG MODE ENABLED") if @debug

      # Save settings back to CharSettings to ensure persistence
      CharSettings['briefcombat'] = @settings

      # State variables
      @compressing = false
      @compressed = nil
      @compress_last = nil
      @compress_you_last = nil
      @targets_damage = nil
      @target = nil
      @targets_last_message = nil
      @targets_status = nil
      @is_no_target = false
      @is_buff = false
      @shortening_search = false
      @is_self = false
      @compressing_spell_guess = nil
      @spell_cast_string = nil
      @compressing_better_action_message = nil

      fput('set MonsterBold On')
    end

    def show_help
      help_lines = [
        "",
        "===========================================================================",
        "                                BRIEFCOMBAT HELP",
        "===========================================================================",
        "",
        "Dramatically shortens most combat text.",
        "",
        "USAGE:",
        "  ;briefcombat [OPTIONS]",
        "",
        "OPTIONS:",
        "  all, --all              Compress your own combat actions (default: false)",
        "  --no-all                Don't compress your own actions",
        "  ",
        "  -x, --extreme           Extreme mode - more aggressive compression (default: false)",
        "  --no-extreme            Disable extreme mode",
        "  ",
        "  --exclude=<players>     Exclude specific players from compression",
        "                          (comma or space separated)",
        "                          Example: --exclude=\"Player1,Player2\"",
        "  ",
        "  -d, --debug             Enable debug output",
        "  --list                  Show current settings",
        "  -h, --help              Show this help message",
        "",
        "EXAMPLES:",
        "  ;briefcombat                                  # Basic mode, exclude self",
        "  ;briefcombat all                              # Compress everything including self",
        "  ;briefcombat all -x                           # Aggressive, compress all",
        "  ;briefcombat --exclude=\"Thomas,George\"        # Exclude specific players",
        "  ;briefcombat all -x --debug                   # Full compression with debug",
        "  ;briefcombat --list                           # View current settings",
        "",
        "NOTES:",
        "  - Settings are saved in CharSettings and persist between runs",
        "  - Use --list to view your current configuration",
        "  - Debug mode shows detailed regex matching information",
        "",
        "===========================================================================",
        ""
      ]
      help_lines.each { |line| respond line }
    end

    def show_settings
      settings_lines = [
        "",
        "===========================================================================",
        "                            BRIEFCOMBAT CURRENT SETTINGS",
        "===========================================================================",
        "",
        "Extreme Mode:       #{@settings['extreme_mode'] || false}",
        "Compress Self:      #{@settings['compress_self'] || false}",
        "Excluded Players:   #{(@settings['excluded_players'] || []).join(', ')}",
        "",
        "To change settings, restart the script with desired options.",
        "Use --help to see all available options.",
        "",
        "===========================================================================",
        ""
      ]
      settings_lines.each { |line| respond line }
    end

    def spell_name(spell_id)
      if spell_id == "709"
        return "Grasp of the Grave"
      else
        return Spell[spell_id].name
      end
    end

    def begin_compress(line, target_string)
      target_string =~ /<a exist="(\d+)"/
      target_id = Regexp.last_match(1)
      @is_no_target = target_id.nil?

      unless @compressing
        @compressing = true
        @compressing_spell_guess = nil # a guess as to which spell is cast (string integer ie "901"), will look up the name of the spell
        @compressing_spell_guess = '9811' if line =~ /draws an intricately glowing pattern in the air before/
        @spell_cast_string = nil # an extra line that is informative enough to include in the compressed block
        @compressing_better_action_message = nil # a string that could be used as the first line in the compressed block
        @targets_damage = Hash.new # a hash to tally up the damage received by each target
        @targets_last_message = Hash.new # a hash to store the last line seen for each target
        @targets_status = Hash.new # a hash to store the status changes for each affected target
        @compress_you_last = nil # the last seen line that includes the word "You"
        @compress_last = nil
        @is_buff = false
        @first_line_has_damage = false

        @compressed = Array.new
        @compressed.push(line.chomp)
        @target = nil

        unless target_id.nil?
          @target = target_id
          @targets_damage[target_id] = 0
          @targets_last_message[target_id] = line

          if line =~ /(\d+) points? of damage/ # sometimes the first line contains damage
            @targets_damage[@target] += Regexp.last_match(1).to_i
            @first_line_has_damage = true
          end
        end

      end
    end

    def end_compress(line)
      # echo "END! #{line}"
      @compressing = false
      num_targets = @targets_damage.length

      # here we try to replace the vague "You gesture" with something more specific
      unless @compressing_spell_guess.nil?
        if @compressing_spell_guess == "ball"
          @compressed[0] = @compressing_better_action_message
        else
          if @is_self
            literal = "cast #{spell_name(@compressing_spell_guess)}"
            @compressed[0] = @compressed[0].gsub(/gesture/, literal)
          else
            if @compressing_spell_guess == '1030'
              literal = "weaves #{spell_name(@compressing_spell_guess)}"
              @compressed[0] = @compressed[0].gsub(/skillfully begins to weave another verse/, literal)
            elsif @compressing_spell_guess =~ /309|320|335/
              literal = "chants #{spell_name(@compressing_spell_guess)}"
              @compressed[0] = @compressed[0].gsub(/chants a reverent litany.*/, literal)
            else
              literal = "casts #{spell_name(@compressing_spell_guess)}"
              @compressed[0] = @compressed[0].gsub(/gestures/, literal)
            end
          end
        end
      end

      unless @spell_cast_string.nil? || @extreme_mode
        @compressed.push(@spell_cast_string)
      end

      if num_targets == 0
        if @spell_cast_string.nil?
          @compressed.push(@compress_last)
        elsif !@compress_you_last.nil?
          @compressed.push(@compress_you_last)
        end
      elsif @is_no_target
        @compressed[0] += ", #{num_targets} targets affected."
      elsif num_targets > 1
        @compressed[0].chop!
        @compressed[0] += " and 1 other." if num_targets == 2
        @compressed[0] += " and #{num_targets - 1} others." if num_targets > 2
      end

      sleep(0.05)

      if num_targets > 0
        num_stunned = 0
        num_knockdown = 0
        num_frozen = 0
        num_confused = 0
        num_dead = 0
        num_sympathized = 0
        num_pinned = 0
        num_buffeted = 0
        num_webbed = 0
        total_damage = 0
        killed = Array.new # this array is for avoiding double counting of kills
        @targets_damage.each { |target_id, damage|
          target = GameObj.npcs.find { |npc| npc.id == target_id }
          if target.status =~ /dead/
            num_dead += 1
            killed.push(target_id)
          end
          total_damage += damage

          if @first_line_has_damage # damage was included in the first line, just sub that number out with the total (assume there is only one target)
            @compressed[0].gsub!(/(\d+)/, damage.to_s)
          end
        }

        @targets_status.each { |target_id, status_array|
          num_stunned += 1 if status_array.any?("stunned")

          if status_array.any?("knockdown")
            num_knockdown += 1
          elsif status_array.any?("buffeted")
            num_buffeted += 1
          end
          num_frozen += 1 if status_array.any?("frozen")
          num_pinned += 1 if status_array.any?("pinned")
          num_sympathized += 1 if status_array.any?("sympathized")
          num_webbed += 1 if status_array.any?("webbed")

          num_dead += 1 if status_array.any?("dead") && !killed.include?(target_id)
        }

        if num_dead + num_stunned + num_knockdown + num_sympathized + num_frozen + num_confused + num_pinned + num_buffeted + total_damage == 0
          @compressed.push(@compress_last) if @spell_cast_string.nil?
        else
          summary_parts = []
          summary_parts.push("#{num_dead} targets <pushBold/>KILLED<popBold/>") if num_dead > 0
          summary_parts.push("#{num_knockdown} targets knocked down") if num_knockdown > 0
          summary_parts.push("#{num_stunned} targets stunned") if num_stunned > 0
          summary_parts.push("#{num_frozen} targets frozen") if num_frozen > 0
          summary_parts.push("#{num_sympathized} targets sympathized") if num_sympathized > 0
          summary_parts.push("#{num_pinned} targets pinned") if num_pinned > 0
          summary_parts.push("#{num_buffeted} targets buffeted") if num_buffeted > 0
          summary_parts.push("#{total_damage} damage dealt") if total_damage > 0 && !@first_line_has_damage
          @compressed.push("  ... #{summary_parts.join(', ')}!") if summary_parts.length > 0
        end
      end

      @compressed.push(line)
      @compressed.push('')
      result = @compressed.join("\n")
      return result
    end

    def compress(line)
      return if line =~ /Cast Roundtime/
      @compress_last = line
      @compress_you_last = line if line =~ /You/

      line.chomp!

      check_status(line, @target)

      if line =~ /(\d+) points? of damage/
        damage_amount = Regexp.last_match(1).to_i
        # Fixed: Check @target is not nil before updating @targets_damage
        @targets_damage[@target] += damage_amount unless @target.nil?
      elsif line =~ /<a exist="(\d+)"/ # switch target if line contains one
        potential_target = Regexp.last_match(1)
        if GameObj.npcs.any? { |npc| npc.id == potential_target }
          @target = potential_target
          @targets_damage[@target] = 0 unless @targets_damage.key?(@target)
          check_status(line, @target)

          @targets_last_message[@target] = line
        end
      elsif line !~ /Cast Roundtime|Forcing stance down|appears to gain succour|Feeling nervous yet|A hit|Warding failed/
        @targets_last_message[@target] = line
      elsif line =~ /CS:|AS:|UAF:|1d100:/
        # just numbers
      else
        check_status(line, @target)
      end

      # here we listen for clues as to which spell or ability was used, so we can name it
      @spell_guess_patterns.each do |regex, spell_id, capture|
        if line =~ regex
          @compressing_spell_guess = spell_id if spell_id
          @spell_cast_string = line if capture && @spell_cast_string.nil?
          @compressing_better_action_message = line if spell_id == 'ball' # ball spells are a special case that replace the "gesture" with the action message
          break
        end
      end
    end

    def check_status(line, target_id)
      @status_effects.each { |status, regex|
        if line =~ regex
          @targets_status[target_id] = Array.new if @targets_status[target_id].nil?
          @targets_status[target_id].push(status)
        end
      }
    end

    def filter_self_spells(line)
      if line =~ @filter_self_spells_casttime
        return line[0, Regexp.last_match.end(0)]
      elsif line =~ @filter_self_spells_exist
        return Regexp.last_match[0]
      end

      return nil if line =~ @filter_self_spells_msg
      line
    end

    def filter_self_search(line)
      return nil if line =~ @filter_self_search
      line
    end

    def filter_other_search(line)
      if line =~ @filter_other_search
        @shortening_search = true
        return line unless @extreme_mode
        return nil
      end
      line
    end

    def brief(line)
      if @shortening_search
        if line =~ /<prompt/
          @shortening_search = false
          return nil
        else
          return nil
        end
      end

      # A wooden arrow flies out of the shadows toward <pushBold/>a <a exist="151226829" noun="sentinel">lithe veiled sentinel</a><popBold/>!

      if @compressing
        return end_compress(line) if line =~ /<prompt/

        compress(line)
        return nil
      end

      if !@excluded_players.nil? && @excluded_players.any? { |player| line.include?(player) }
        echo "DEBUG: Line excluded (contains excluded player)" if @debug
        return line
      end

      @simple_filters.each { |regex| return nil if line =~ regex }

      # Try compress_combat
      echo "DEBUG: Calling compress_combat for: #{line[0..100]}" if @debug
      compressed_result = compress_combat(line)
      return compressed_result if compressed_result.nil?

      # Apply filters and use their return values
      unless @excluded_players.include?("You")
        filtered = filter_self_spells(line)
        return filtered if filtered.nil? || filtered != line
      end

      filtered = filter_self_search(line)
      return filtered if filtered.nil?

      filtered = filter_other_search(line)
      return filtered if filtered.nil?

      line
    end

    def compress_combat(line)
      # Strip castTime tags before matching combat patterns
      clean_line = line.sub(/<castTime value='\d+'\/?>/, '')

      # Debug: show what we're trying to match
      if @debug && line =~ /wave.*wand/i
        echo "DEBUG: Wand line detected!"
        echo "  Original: #{line[0..120]}"
        echo "  Cleaned:  #{clean_line[0..120]}"
      end

      if clean_line =~ @combat_regex
        target_string = Regexp.last_match(4)
        @is_self = Regexp.last_match(1) == 'You'

        if @debug
          echo "DEBUG: @combat_regex matched!"
          echo "  Player: #{Regexp.last_match(1)}"
          echo "  Verb: #{Regexp.last_match(3)}"
          echo "  Target: #{target_string}"
          echo "  Excluded?: #{@excluded_players.any? { |player| Regexp.last_match(1).include?(player) }}"
        end

        unless @excluded_players.any? { |player| Regexp.last_match(1).include?(player) }
          begin_compress(line, target_string)
          return nil
        end
      elsif clean_line =~ @combat_target_first_regex
        target_string = Regexp.last_match(3)
        @is_self = Regexp.last_match(1) == 'You'
        unless @excluded_players.any? { |player| Regexp.last_match(1).include?(player) }
          begin_compress(line, target_string)
          return nil
        end
      elsif clean_line =~ @combat_ambient_regex
        target_string = Regexp.last_match(2)
        begin_compress(line, target_string)
        return nil
      elsif clean_line =~ @combat_ambient_2_regex
        target_string = Regexp.last_match(1)
        begin_compress(line, target_string)
        return nil
      end
      line
    end
  end
end

engine = BriefCombat::Engine.new(Script.current.vars)

DownstreamHook.add('brief2', proc { |line| engine.brief(line) })
before_dying { DownstreamHook.remove('brief2') }
while true; sleep(1); end
