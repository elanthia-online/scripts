##quiet
## vim: set ft=ruby:
=begin

    Does all bounties except gem, escorts, and bandits. Gems should
    be handled via your loot with stockpiling.

 maintainer: Elanthia-Online
	 author: spiffyjr
       name: SpiffyBounty
       tags: bounty
    version: 1.1

	  changelog:
			1.1 (2021-10-11) updates to support GTK3  
			1.0 * Initial release

=end

# Vaalor guards
Room[5827].tags.push('advguard2') unless Room[5827].tags.include?('advguard2')

$sbounty = CharSettings.to_hash

$sbounty[:hunter] ||= 'sbounty-bigshot'

$sbounty[:enable_cull]      = $sbounty[:enable_cull].nil? ? true : $sbounty[:enable_cull]
$sbounty[:enable_dangerous] = $sbounty[:enable_dangerous].nil? ? true : $sbounty[:enable_dangerous]
$sbounty[:enable_forage]    = $sbounty[:enable_forage].nil? ? true : $sbounty[:enable_forage]
$sbounty[:enable_loot]      = $sbounty[:enable_loot].nil? ? true : $sbounty[:enable_loot]
$sbounty[:enable_rescue]    = $sbounty[:enable_rescue].nil? ? true : $sbounty[:enable_rescue]
$sbounty[:enable_search]    = $sbounty[:enable_search].nil? ? true : $sbounty[:enable_search]
$sbounty[:enable_bandit]    = $sbounty[:enable_bandit].nil? ? false : $sbounty[:enable_bandit]
$sbounty[:enable_skin]      = $sbounty[:enable_skin].nil? ? true : $sbounty[:enable_skin]
$sbounty[:enable_expedite]  = $sbounty[:enable_expedite].nil? ? true : $sbounty[:enable_expedite]

$sbounty[:enable_hunt_complete] = $sbounty[:enable_hunt_complete].nil? ? true : $sbounty[:enable_hunt_complete]

$sbounty[:hunting_scripts]       ||= ['spellactive']
$sbounty[:enable_bandit_script]  ||= false
$sbounty[:bandit_script]         ||= 'sbounty-bandit-example'
$sbounty[:pre_search_commands]   ||= ['store all']
$sbounty[:post_search_commands]  ||= ['gird']
$sbounty[:pre_forage_commands]   ||= ['store all']
$sbounty[:post_forage_commands]  ||= ['gird']
$sbounty[:forage_retry_delay]    ||= 300
$sbounty[:loot_script]           ||= 'sloot'
$sbounty[:turn_in_percent]       ||= 95
$sbounty[:enable_turn_in_bounty] ||= $sbounty[:enable_turn_in_bounty].nil? ? true : $sbounty[:enable_turn_in_bounty]

$sbounty[:should_hunt_mind]    ||= 75
$sbounty[:should_hunt_mana]    ||= 0
$sbounty[:should_hunt_spirit]  ||= 7
$sbounty[:hunt_pre_commands]   ||= ['gird']
$sbounty[:should_rest_mind]    ||= 100
$sbounty[:should_rest_mana]    ||= 0
$sbounty[:should_rest_encum]   ||= 20
$sbounty[:should_rest_wounded] ||= StringProc.new('bleeding? || XMLData.injuries.any?{|key,value| value["wound"] > 1} || percenthealth <= 50')

$sbounty[:rest_room]       ||= ''
$sbounty[:boundaries]      ||= ''
$sbounty[:rest_in_commands]    ||= ['go table, sit']
$sbounty[:rest_out_commands]   ||= ['stand', 'out']
$sbounty[:rest_pre_commands]   ||= ['store all']
$sbounty[:rest_scripts]        ||= ['useherbs --buy-missing=on', 'sloot sell', 'waggle']
$sbounty[:rest_sleep_interval] ||= 30

$sbounty[:locations] ||= {}

$sbounty_rest        = false
$sbounty_rest_reason = nil
in_rest_area         = false
rest_reason          = nil
hunt_reason          = nil
can_do_bounty_cache  = nil
expedite_left        = true
last_forage_attempt  = 0
last_forage_delay    = 300
first_run            = true

if UserVars.lootsack.nil? or UserVars.lootsack.empty?
    echo '** lootsack has not been set, set it with ;set change lootsack [container]'
    exit
end

if $sbounty[:enable_skin] and (UserVars.skinsack.nil? or UserVars.skinsack.empty?)
    echo '** skinsack has not been set, set it with ;set change skinsack [container]'
    exit
end

lootsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.lootsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }
skinsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.skinsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }

if lootsack.nil?
    echo '** failed to find your lootsack, set it with ;set change lootsack [container]'
    exit
end

if $sbounty[:enable_skin] and skinsack.nil?
    echo '** failed to find your skinsack, set it with ;set change skinsack [container]'
    exit
end

# You have been tasked to recover a peridot-inset pewter ring that an unfortunate citizen lost after being attacked by a storm giant in the Upper Trollfang near Wehnimer's Landing.  The heirloom can be identified by the initials MG engraved upon it.  Hunt down the creature and LOOT the item from its corpse.

bounty_patterns = {
    'none' => '^You are not currently assigned a task\.',

    # help
    'help_bandit'    => 'It appears they have a bandit problem',
    'help_creature'  => 'It appears they have a creature problem they\'d like you to solve\.',
    'help_resident'  => 'It appears that a local resident urgently needs our help in some matter\.',
    'help_heirloom'  => 'It appears they need your help in tracking down some kind of lost heirloom\.',
    'help_gemdealer' => 'The local gem dealer, .*, has an order to fill and wants our help\.',
    'help_herbalist' => 'local herbalist|local healer|local alchemist',
    'help_furrier'   => 'The local furrier',

    # in progress
    'task_bandit'    => '^You have been tasked to suppress bandit activity (?:in|on|near) (?:the )?(.*)\s(?:near|between|under|\.)',
    'task_escort'    => '^You have made contact with the child',
    'task_dangerous' => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You can',
    'task_provoked'  => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You have provoked',
    'task_dealer'    => '^The(?: local)? gem dealer',
    'task_forage'    => 'concoction that requires (?:a|an|some) (.*) found (?:in|on|near) (?:the )?(.*?)(?: near| between| under|\.).*These samples must be in pristine condition\.\s+You have been tasked to retrieve (\d+) (?:more )?samples?\.',
    'task_cull'      => 'You have been tasked to(?: help \w*)?(?: (?:retrieve an heirloom|kill a dangerous creature|rescue a missing child) by)? suppress(?:ing)? (.*) activity (?:in|on) (?:the )?(.*)(?:\s(?:near|between|under)|\.)',
    'task_search'    => 'unfortunate citizen lost after being attacked by (?:a|an) (.*?) (?:in|on|near) (?:the )?(.*?)\s?(?:near|between|under|\.  The).*SEARCH',
    'task_heirloom'  => 'unfortunate citizen lost after being attacked by (?:a|an) (.*?) (?:in|on|near) (?:the )?(.*?)\s?(?:near|between|under|\.  The).*LOOT',
    'task_found'     => 'You have located .* and should bring it back',
    'task_skin'      => '^You have been tasked to retrieve (\d+|\w+)s? (.*) of at least .*\.  You can SKIN them off the corpse of (?:a|an) (.*) or ',
    'task_rescue'    => 'A local divinist has had visions of the child fleeing from (?:a|an) (.*) (?:in|on) (?:the )?(.*) (?:near|between|under)',

    # fail
    'fail_child' => 'The child you were tasked to rescue is gone and your task is failed\.',

    # success
    'success'          => '^You have succeeded in your task and can return',
    'success_guard'    => '^You succeeded in your task and should report back to',
    'success_heirloom' => '^You have located (?:a|an|the|some) (.*) and should bring it back .*\.$'
}

setup = proc {
    script_name = script.name

    action   = nil
    @window   = nil
    notebook = nil

   nil

    locations = $sbounty[:locations].dup
    location  = nil

    error = proc { |msg|

        dlg = Gtk::MessageDialog.new(
            :parent => @window,
            :flags => [:modal, :destroy_with_parent],
      :type => :info,
            :buttons => :ok,
      :message => msg
        )
    dlg.run
    dlg.destroy
  }

    widgets = {
        :gui_widgets => {
            # buttons
            :close  => Gtk::Button.new(:label => 'Close'),
            :create => Gtk::Button.new(:label => 'Create'),
            :delete => Gtk::Button.new(:label => 'Delete'),
            :save   => Gtk::Button.new(:label => 'Save & Close'),

            # combos
            :locations => Gtk::ComboBoxText.new,

            # entries
            :new_name => Gtk::Entry.new,
        },

        :location_widgets => {
            # check buttons
            :enable_bounty_only      => Gtk::CheckButton.new('Only attack bounty critters'),
            :enable_hunting_rotation => Gtk::CheckButton.new('In hunting rotation'),
            :enable_search_only      => Gtk::CheckButton.new('Only search here (no hunting)'),

            #entries
            :location   => Gtk::Entry.new,
            :skins      => Gtk::Entry.new,
            :targets    => Gtk::Entry.new,
            :room       => Gtk::Entry.new,
            :boundaries => Gtk::Entry.new,
        },

        # check buttons
        :enable_cull          => Gtk::CheckButton.new('Cull critters'),
        :enable_dangerous     => Gtk::CheckButton.new('Dangerous critter'),
        :enable_forage        => Gtk::CheckButton.new('Forage herbs'),
        :enable_loot          => Gtk::CheckButton.new('Loot heirloom'),
        :enable_rescue        => Gtk::CheckButton.new('Rescue child'),
        :enable_search        => Gtk::CheckButton.new('Search heirloom'),
        :enable_bandit        => Gtk::CheckButton.new('Bandits'),
        :enable_skin          => Gtk::CheckButton.new('Skin critters'),
        :enable_expedite      => Gtk::CheckButton.new('Expedite bounties'),
        :enable_bandit_script => Gtk::CheckButton.new('Use bandit script'),
        :enable_hunt_complete => Gtk::CheckButton.new('Hunt until complete?'),
        :enable_turn_in_bounty => Gtk::CheckButton.new('Force turn in if new bounty'),

        # entries
        :hunting_scripts      => Gtk::Entry.new,
        :bandit_script        => Gtk::Entry.new,
        :pre_search_commands  => Gtk::Entry.new,
        :post_search_commands => Gtk::Entry.new,
        :pre_forage_commands  => Gtk::Entry.new,
        :post_forage_commands => Gtk::Entry.new,
        :forage_retry_delay   => Gtk::Entry.new,
        :loot_script          => Gtk::Entry.new,
        :turn_in_percent      => Gtk::Entry.new,

        :should_hunt_mind   => Gtk::Entry.new,
        :should_hunt_mana   => Gtk::Entry.new,
        :should_hunt_spirit => Gtk::Entry.new,

        :hunt_pre_commands => Gtk::Entry.new,
        :hunt_commands_a   => Gtk::Entry.new,
        :hunt_commands_b   => Gtk::Entry.new,
        :hunt_commands_c   => Gtk::Entry.new,

        :should_rest_mana    => Gtk::Entry.new,
        :should_rest_mind    => Gtk::Entry.new,
        :should_rest_encum   => Gtk::Entry.new,
        :should_rest_wounded => Gtk::Entry.new,

        :rest_in_commands  => Gtk::Entry.new,
        :rest_out_commands => Gtk::Entry.new,
        :rest_pre_commands => Gtk::Entry.new,
        :rest_room         => Gtk::Entry.new,
        :rest_scripts      => Gtk::Entry.new
    }

    Gtk.queue {
        update_disabled = proc {
            widgets[:location_widgets].each { |key, widget|
        if location.nil?
                    widget.set_sensitive(false)
                else
                    widget.set_sensitive(true)
                end
            }
        }

        populate_locations = proc {
            loop {
        break if not widgets[:gui_widgets][:locations].model.iter_first
                #widgets[:gui_widgets][:locations].remove_text(0)
        widgets[:gui_widgets][:locations].remove(0)
            }

            locations.keys.sort.each { |text|
        widgets[:gui_widgets][:locations].append_text(text)
            }

        }

        save_location = proc {
            widgets[:location_widgets].each { |key, widget|
                if widget.class == Gtk::CheckButton
                    value = widget.active?
                elsif [:skins, :targets, :boundaries].include?(key)
                    value = widget.text.strip.split(',').collect { |item| item.strip }
                else
                    value = widget.text.strip
                end

                locations[location][key] = value
            }
        }

        attach_signals = proc {
            widgets[:gui_widgets][:close].signal_connect 'clicked' do action = :close end
            widgets[:gui_widgets][:save].signal_connect 'clicked' do action = :save; save_location.call end
      @window.signal_connect('destroy') do action = :close end

###
### Something in here when clicking create kills the connection/exits the game
###

            widgets[:gui_widgets][:create].signal_connect 'clicked' do
                name = widgets[:gui_widgets][:new_name].text.strip

                if name.nil? or name.empty? or name == '' or name.length < 3
                    error.call('You need to enter a name!')
                elsif locations.keys.find { |n| n.downcase.strip == name.downcase.strip }
                    error.call 'A location with that name already exists!'
                else
                    locations[name] = {}
                    widgets[:gui_widgets][:new_name].text = ''
                    populate_locations.call
                    update_disabled.call
                end
            end

###
### Creation script end...
###

            widgets[:gui_widgets][:delete].signal_connect 'clicked' do
                Gtk.queue {
                    if widgets[:gui_widgets][:locations].active == -1
                        error.call 'You do not have a location selected!'
                    else
                        locations.delete(widgets[:gui_widgets][:locations].active_text)
                        widgets[:gui_widgets][:locations].remove(widgets[:gui_widgets][:locations].active)

                        widgets[:location_widgets].each { |key, widget|
                            if widget.class == Gtk::CheckButton
                                widget.active = (false)
                            else
                                widget.text = ("")
                            end
                        }
                    end
                }
            end

            widgets[:gui_widgets][:locations].signal_connect 'changed' do
                Gtk.queue {
                    save_location.call
                    location = widgets[:gui_widgets][:locations].active_text
                    if locations[location]
                        widgets[:location_widgets].each { |key, widget|
                            if widget.class == Gtk::CheckButton
                                widget.active = (!!locations[location][key])
                            elsif [:skins, :targets, :boundaries].include?(key)
                                widget.text = (locations[location][key].join(',')) if not (locations[location][key].nil?)
                            else
                                widget.text = (locations[location][key].strip)
                            end
                        }
                    end

                    update_disabled.call
                }
            end
        }

        # main window
        @window = Gtk::Window.new
        @window.border_width = 5
#        @window.keep_above = true  ## this setting prevents the modal ERROR dialog from appearing over it
        @window.resizable = true
        @window.resize 500, 300
        @window.set_window_position(:center)

        # main notebook (tabs)
        notebook = Gtk::Notebook.new
        notebook.show_border = true

        vbox_main = Gtk::Box.new(:vertical)
        vbox_main.pack_start notebook

        # sbounty options
        vbox = Gtk::Box.new(:vertical)

        frm = Gtk::Frame.new('Locations').set_border_width(3)
        tbl = Gtk::Table.new(7, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('New name: ')), 0, 1, 0, 1
        tbl.attach widgets[:gui_widgets][:new_name], 1, 3, 0, 1
        tbl.attach widgets[:gui_widgets][:create], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Locations: ')), 0, 1, 1, 2
        tbl.attach widgets[:gui_widgets][:locations], 1, 3, 1, 2
        tbl.attach widgets[:gui_widgets][:delete], 3, 4, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Location: ')), 0, 1, 3, 4
        tbl.attach widgets[:location_widgets][:location], 1, 2, 3, 4
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Skins: ')), 2, 3, 3, 4
        tbl.attach widgets[:location_widgets][:skins], 3, 4, 3, 4

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Targets: ')), 0, 1, 4, 5
        tbl.attach widgets[:location_widgets][:targets], 1, 2, 4, 5

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Room #: ')), 0, 1, 5, 6
        tbl.attach widgets[:location_widgets][:room], 1, 2, 5, 6
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Boundaries: ')), 2, 3, 5, 6
        tbl.attach widgets[:location_widgets][:boundaries], 3, 4, 5, 6

        tbl.attach widgets[:location_widgets][:enable_hunting_rotation], 0, 1, 6, 7
        tbl.attach widgets[:location_widgets][:enable_bounty_only], 1, 2, 6, 7
        tbl.attach widgets[:location_widgets][:enable_search_only], 2, 3, 6, 7

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Bounties').set_border_width(3)
        tbl = Gtk::Table.new(5, 4, true).set_border_width(3)

        tbl.attach widgets[:enable_cull], 0, 1, 0, 1; widgets[:enable_cull].active = $sbounty[:enable_cull]
        tbl.attach widgets[:enable_dangerous], 1, 2, 0, 1; widgets[:enable_dangerous].active = $sbounty[:enable_dangerous]
        tbl.attach widgets[:enable_rescue], 2, 3, 0, 1; widgets[:enable_rescue].active = $sbounty[:enable_rescue]
        tbl.attach widgets[:enable_skin], 3, 4, 0, 1; widgets[:enable_skin].active = $sbounty[:enable_skin]

        tbl.attach widgets[:enable_loot], 0, 1, 1, 2; widgets[:enable_loot].active = $sbounty[:enable_loot]
        tbl.attach widgets[:enable_search], 1, 2, 1, 2; widgets[:enable_search].active = $sbounty[:enable_search]
        tbl.attach widgets[:enable_forage], 2, 3, 1, 2; widgets[:enable_forage].active = $sbounty[:enable_forage]
        tbl.attach widgets[:enable_bandit], 3, 4, 1, 2; widgets[:enable_bandit].active = $sbounty[:enable_bandit]

        tbl.attach widgets[:enable_bandit_script], 1, 2, 2, 3; widgets[:enable_bandit_script].active = $sbounty[:enable_bandit_script]
        tbl.attach widgets[:enable_expedite], 2, 3, 2, 3; widgets[:enable_expedite].active = $sbounty[:enable_expedite]
        tbl.attach widgets[:enable_hunt_complete], 3, 4, 2, 3; widgets[:enable_hunt_complete].active = $sbounty[:enable_hunt_complete]

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('turn in when mind >= ')), 0, 1, 3, 4
        tbl.attach widgets[:turn_in_percent], 1, 2, 3, 4; widgets[:turn_in_percent].text = ($sbounty[:turn_in_percent].to_s)
        tbl.attach widgets[:enable_turn_in_bounty], 3, 4, 3, 4; widgets[:enable_turn_in_bounty].active = $sbounty[:enable_turn_in_bounty]

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('hunting scripts:')), 2, 3, 4, 5
        tbl.attach widgets[:hunting_scripts], 3, 4, 4, 5; widgets[:hunting_scripts].text = ($sbounty[:hunting_scripts].collect { |a| a.strip }.join(','))
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('bandit script:')), 0, 1, 4, 5
        tbl.attach widgets[:bandit_script], 1, 2, 4, 5; widgets[:bandit_script].text = ($sbounty[:bandit_script])

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-search commands: ')), 0, 1, 5, 6
        tbl.attach widgets[:pre_search_commands], 1, 2, 5, 6; widgets[:pre_search_commands].text = ($sbounty[:pre_search_commands].collect { |a| a.strip }.join(','))
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-search commands: ')), 2, 3, 5, 6
        tbl.attach widgets[:post_search_commands], 3, 4, 5, 6; widgets[:post_search_commands].text = ($sbounty[:post_search_commands].collect { |a| a.strip }.join(','))

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-forage commands: ')), 0, 1, 6, 7
        tbl.attach widgets[:pre_forage_commands], 1, 2, 6, 7; widgets[:pre_forage_commands].text = ($sbounty[:pre_forage_commands].collect { |a| a.strip }.join(','))
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-forage commands: ')), 2, 3, 6, 7
        tbl.attach widgets[:post_forage_commands], 3, 4, 6, 7; widgets[:post_forage_commands].text = ($sbounty[:post_forage_commands].collect { |a| a.strip }.join(','))

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('forage retry delay: ')), 0, 1, 7, 8
        tbl.attach widgets[:forage_retry_delay], 1, 2, 7, 8; widgets[:forage_retry_delay].text = ($sbounty[:forage_retry_delay].to_s)
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('loot script: ')), 2, 3, 7, 8
        tbl.attach widgets[:loot_script], 3, 4, 7, 8; widgets[:loot_script].text = ($sbounty[:loot_script].to_s)

        frm.add(tbl)
        vbox.pack_start(frm)

        notebook.append_page vbox, Gtk::Label.new('Locations / Options')

        # default options
        vbox = Gtk::Box.new(:vertical)

        frm = Gtk::Frame.new('Should Rest').set_border_width(3)
        tbl = Gtk::Table.new(3, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % >= ')), 0, 1, 0, 1
        tbl.attach widgets[:should_rest_mind], 1, 2, 0, 1; widgets[:should_rest_mind].text = ($sbounty[:should_rest_mind].to_s)
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or mana <= ')), 2, 3, 0, 1
        tbl.attach widgets[:should_rest_mana], 3, 4, 0, 1; widgets[:should_rest_mana].text = ($sbounty[:should_rest_mana].to_s)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or encumbrance % >= ')), 0, 1, 1, 2
        tbl.attach widgets[:should_rest_encum], 1, 2, 1, 2; widgets[:should_rest_encum].text = ($sbounty[:should_rest_encum].to_s)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or wounded eval: ')), 0, 1, 2, 3
        tbl.attach widgets[:should_rest_wounded], 1, 4, 2, 3; widgets[:should_rest_wounded].text = ($sbounty[:should_rest_wounded]._dump)

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Resting').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('room #: ')), 0, 1, 0, 1
        tbl.attach widgets[:rest_room], 1, 2, 0, 1; widgets[:rest_room].text = ($sbounty[:rest_room].to_s)
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-rest commands: ')), 2, 3, 0, 1
        tbl.attach widgets[:rest_pre_commands], 3, 4, 0, 1; widgets[:rest_pre_commands].text = ($sbounty[:rest_pre_commands].collect { |a| a.strip }.join(','))

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('enter commands: ')), 0, 1, 1, 2
        tbl.attach widgets[:rest_in_commands], 1, 2, 1, 2; widgets[:rest_in_commands].text = ($sbounty[:rest_in_commands].collect { |a| a.strip }.join(','))
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('exit commands: ')), 2, 3, 1, 2
        tbl.attach widgets[:rest_out_commands], 3, 4, 1, 2; widgets[:rest_out_commands].text = ($sbounty[:rest_out_commands].collect { |a| a.strip }.join(','))

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('scripts: ')), 0, 1, 2, 3
        tbl.attach widgets[:rest_scripts], 1, 4, 2, 3; widgets[:rest_scripts].text = ($sbounty[:rest_scripts].collect { |a| a.strip }.join(','))

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Should Hunt').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % <= ')), 0, 1, 0, 1
        tbl.attach widgets[:should_hunt_mind], 1, 2, 0, 1; widgets[:should_hunt_mind].text = ($sbounty[:should_hunt_mind].to_s)
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and mana >= ')), 2, 3, 0, 1
        tbl.attach widgets[:should_hunt_mana], 3, 4, 0, 1; widgets[:should_hunt_mana].text = ($sbounty[:should_hunt_mana].to_s)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and spirit >= ')), 0, 1, 1, 2
        tbl.attach widgets[:should_hunt_spirit], 1, 2, 1, 2; widgets[:should_hunt_spirit].text = ($sbounty[:should_hunt_spirit].to_s)

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Hunting').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Pre-hunt commands: ')), 0, 1, 0, 1
        tbl.attach widgets[:hunt_pre_commands], 1, 2, 0, 1; widgets[:hunt_pre_commands].text = ($sbounty[:hunt_pre_commands].collect { |a| a.strip }.join(','))
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (a): ')), 2, 3, 0, 1
        tbl.attach widgets[:hunt_commands_a], 3, 4, 0, 1; widgets[:hunt_commands_a].text = ($sbounty[:hunt_commands_a].collect { |a| a.strip }.join(',')).to_s

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (b): ')), 0, 1, 1, 2
        tbl.attach widgets[:hunt_commands_b], 1, 2, 1, 2; widgets[:hunt_commands_b].text = ($sbounty[:hunt_commands_b].collect { |a| a.strip }.join(',')).to_s
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (c): ')), 2, 3, 1, 2
        tbl.attach widgets[:hunt_commands_c], 3, 4, 1, 2; widgets[:hunt_commands_c].text = ($sbounty[:hunt_commands_c].collect { |a| a.strip }.join(',')).to_s

        frm.add(tbl)
        vbox.pack_start(frm)

        notebook.append_page vbox, Gtk::Label.new('Resting / Hunting')

        # main window widgets
        vbox = Gtk::Box.new(:vertical)
    valign = Gtk::Alignment.new(0, 1, 0, 0)
        vbox.pack_start(valign, :expand => false, :fill => false, :padding => 0)

        hbox = Gtk::Box.new(:horizontal)
        hbox.add widgets[:gui_widgets][:save]
        hbox.add widgets[:gui_widgets][:close]

        halign = Gtk::Alignment.new 1, 0, 0, 0
        halign.add hbox

        vbox.pack_start halign
        vbox_main.pack_start vbox

        # create the window
        attach_signals.call
        update_disabled.call
        populate_locations.call

        @window.add vbox_main
        @window.show_all
    }

###
### This line prevents the top right corner "X" from properly closing the gui
###

    before_dying { Gtk.queue { @window.destroy unless @window.destroyed? } }

###
### Why? I don't know...
###

    sleep 0.10 while action.nil?

    case action
        when :save
            $sbounty[:locations] = locations

            widgets.each { |key, widget|
                next if [:location_widgets, :gui_widgets].include?(key)
                if widget.class == Gtk::CheckButton
                    value = widget.active?
                elsif [:hunting_scripts, :pre_forage_commands, :post_forage_commands, :pre_search_commands, :post_search_commands, :hunt_pre_commands, :hunt_commands_a, :hunt_commands_b, :hunt_commands_c, :rest_in_commands, :rest_out_commands, :rest_pre_commands, :rest_scripts].include?(key)
                    value = widget.text.strip.split(',').collect { |item| item.strip }
                elsif key == :should_rest_wounded
                    value = StringProc.new widget.text.strip
                else
                    value = widget.text.strip
                end

                $sbounty[key] = value
            }
    end
}

change_stance = proc { |stance|
    return if Spell['Zealot'].active? or Spell['Frenzy'].active? or dead?

    while (cur_stance = checkstance) != stance
        res = dothistimeout "stance #{stance}", 2, /You are now|Roundtime|Wait|wait|Your rage causes you/
        if res =~ /Roundtime: (\d+)|wait (\d+)/i
            d = ($1 || $2).strip.to_f - 1
            if d > 0
                sleep (d)
            end
        elsif res =~ /Your rage causes you/
            Spell['Frenzy'].putup
            Spell['Frenzy'].timeleft = 30
        elsif cur_stance == 'guarded' and stance == 'defensive'
            break
        end
    end
}

kneel = proc {
    while true
        break if kneeling?
        waitrt?
        put 'kneel'
        sleep 0.50
    end
}

stand = proc {
    while true
        break if standing?
        waitrt?
        put 'stand'
        sleep 0.50
    end
}

error = proc { |msg|
    echo "** #{msg}"
    exit
}

print = proc { |msg|
    echo "-- #{msg}"
}

clean_skin = proc { |name|
    name.strip.downcase.gsub(/s$/, '').gsub(/teeth/, 'tooth').gsub(/hooves?/, 'hoof')
}

has_skins = proc {
    if bounty? =~ /#{bounty_patterns['task_skin']}/
        count = $1.to_i
        skin  = $2.downcase

        skinsack.contents.find_all { |item| item.name =~ /#{clean_skin.call(skin)}/i }.size >= (count + 3)
    else
        false
    end
}

is_bounty = proc { |types|
    result = []
  if types.class != Array
    types = [types]
  end
    types.each { |type| result.push(bounty_patterns[type]) if not bounty_patterns[type].nil? }

    !(bounty? =~ /#{result.join('|')}/).nil?
}

get_bounty_location = proc { |location, target|
    if location.nil?
        # remove search only locations for hunting areas
        locations = $sbounty[:locations].dup
        if is_bounty.call ['task_skin', 'task_heirloom', 'task_dangerous', 'task_cull', 'task_rescue']
            locations.delete_if { |name, data| data[:enable_search_only] }
        end

        if bounty? =~ /#{bounty_patterns['task_skin']}/
            # remember: don't swap the order or the global $ vars are lost!
            target   = $3.strip.downcase
            skin     = clean_skin.call($2)
            location = locations.find { |name, data| $SBOUNTY_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } and data[:skins].find { |s| skin =~ /#{s.strip.downcase}/i }}
        else
            bounty_patterns.each { |key,value|
                if bounty? =~ /#{value}/i
                    target   = $1
                    location = $2

                    break
                end
            }

            location = location.downcase.strip
            location = locations.find { |name, data|
                cleaned = $SBOUNTY_CLEAN_TARGETS.call(data[:targets])
                location =~ /#{data[:location].strip}/i and cleaned.find {
                    |t| target =~ /#{t}/i
                }
            }
        end
    end

    if location
        name = location[0].dup
        data = location[1].to_hash.dup

        if target
            targets = data[:targets].dup
            cleaned = $SBOUNTY_CLEAN_TARGETS.call(data[:targets])
            target_key = nil

            # see if they have a provoked ancient/grizzled line
            if is_bounty.call 'task_provoked'
                target_key = cleaned.find { |t|
                    t =~ /ancient|grizzled/ and (
                        "ancient #{target}" =~ /#{t}/i or
                        "grizzled #{target}" =~ /#{t}/i
                    )
                }
            end

            # regular bounties
            if target_key.nil?
                target_key = cleaned.find { |t| target =~ /#{t}/i }
            end

            index = cleaned.index(target_key)
            target = targets[index]

            if is_bounty.call 'task_provoked'
                # add the ancient|grizzled for them
                if target !~ /ancient|grizzled/i
                    new_target = target.gsub(cleaned[index], "(?:ancient|grizzled).*#{cleaned[index]}")
                    targets[target.index(target)] = new_target
                    target = new_target
                end
            end
        end

        if data[:enable_bounty_only]
            targets = [ target ]
        end

        data[:targets] = targets

        [name, data]
    else
        print.call 'could not find bounty location'
        nil
    end
}

get_herb_rooms = proc { |location, herb|
    target_list = Array.new
    names = [herb]

    if herb == 'ayana leaf'
        names = [herb, 'ayana leaf', 'ayana lichen', 'ayana weed', 'ayana berry', 'ayana root']
    elsif herb == "ayana'al leaf"
        names = [herb, 'ayana\'al leaf', 'ayana\'al lichen', 'ayana\'al weed', 'ayana\'al berry', 'ayana\'al root']
    end

    Room.list.each { |room|
        if room.tags.find { |tag| names.find { |name| tag =~ /#{name}/i } }
            target_list.push(room.id)
        end
    }

    previous, shortest_distances = Map.dijkstra(Room.current.id)

    if location
        # delete the room if it's not the correct location
        target_list.delete_if { |room_num|
            if Room[room_num].location.nil?
                Room[room_num].title[0] !~ /#{location}/i
            elsif not Room[room_num].location.nil?
                Room[room_num].location !~ /#{location}/i
            else
                false
            end
        }
    end

    if target_list.length == 0
        similar = Room.tags.find_all { |tag| tag =~ /#{herb}/i }

        if not similar.empty?
            herb = similar.join(', ')
            Room.list.each { |room| target_list.push(room.id) if room.tags.include?(herb) }

            previous, shortest_distances = Map.dijkstra(Room.current.id)

            if location
                target_list.delete_if { |room_num| (Room[room_num].location == nil && Room[room_num].title[0] !~ /#{location}/i) }
                target_list.delete_if { |room_num| (Room[room_num].location != nil && Room[room_num].location !~ /#{location}/i) }
            end
        end
    end

    previous, shortest_distances = Map.dijkstra($sbounty[:rest_room])
    target_list.delete_if { |room| shortest_distances[room].nil? or shortest_distances[room] > 600 }
}

can_turn_in = proc {
    is_bounty.call ['success', 'success_guard', 'success_heirloom'] and (
        $sbounty[:turn_in_percent].nil? or
        $sbounty[:enable_turn_in_bounty] and not Spell['Next Bounty'].active? or
        percentmind >= $sbounty[:turn_in_percent].to_i and checkmind !~ /saturated/
    )
}

can_do_bounty = proc {
    if not can_do_bounty_cache.nil?
        ; # intentionally left blank
    elsif is_bounty.call ['success', 'success_heirloom', 'success_guard']
        can_do_bounty_cache = true
    elsif is_bounty.call ['task_bandit'] and $sbounty[:enable_bandit] and bounty? !~ /Locksmehr Trail/
        can_do_bounty_cache = true
    elsif ((is_bounty.call 'task_search' and $sbounty[:enable_search] and get_bounty_location.call) or (is_bounty.call 'task_heirloom' and $sbounty[:enable_loot] and get_bounty_location.call))
        can_do_bounty_cache = true
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/ and $sbounty[:enable_forage] and not get_herb_rooms.call($2, $1).empty? and bounty? !~ /green fleshbulb/
        can_do_bounty_cache = true
        # and bounty? !~ /exceptional|outstanding|superb|magnificent/
    elsif is_bounty.call 'task_skin' and $sbounty[:enable_skin] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif is_bounty.call ['task_provoked', 'task_dangerous'] and $sbounty[:enable_dangerous] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif is_bounty.call 'task_cull' and $sbounty[:enable_cull] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif (is_bounty.call 'task_escort' and $sbounty[:enable_rescue]) or (is_bounty.call 'task_rescue' and $sbounty[:enable_rescue] and get_bounty_location.call)
        can_do_bounty_cache = true
    else
        can_do_bounty_cache = false
    end

    $sbounty_can_do_bounty = can_do_bounty_cache

    can_do_bounty_cache
}

should_hunt = proc {
  res = false

  if is_bounty.call ['success', 'success_heirloom', 'success_guard'] and not can_turn_in.call
    res = true
    # on start if less than numb then always try to do bounty
    elsif (can_do_bounty.call and not fried? and not saturated? and first_run)
        res = true
    elsif (not can_do_bounty.call or is_bounty.call ['success', 'success_heirloom', 'success_guard'] or not $sbounty[:enable_hunt_complete]) and percentmind > $sbounty[:should_hunt_mind].to_i
        hunt_reason = 'mind not clear enough'
        ;
    elsif not checkmana($sbounty[:should_hunt_mana].to_i)
        hunt_reason = 'out of mana'
        ;
    elsif not checkspirit($sbounty[:should_hunt_spirit].to_i)
        hunt_reason = 'low spirit'
        ;
    else
        res = true
    end

  res
}

should_rest = proc {
    if $sbounty[:should_rest_wounded].call
        rest_reason = 'wounded'
        true
    elsif $sbounty_rest
        if $sbounty_rest_reason
            rest_reason = $sbounty_rest_reason
        else
            rest_reason = '$sbounty_rest was set'
        end

        if $sbounty_rest_until
            if Time.now.to_i > $sbounty_rest_until
                $sbounty_rest = false
                $sbounty_rest_reason = nil
                $sbounty_rest_until = nil
            end
        else
            $sbounty_rest = false
            $sbounty_rest_reason = nil
        end

        true
    elsif not checkmana($sbounty[:should_rest_mana].to_i)
        rest_reason = 'out of mana'
        true
    elsif checkencumbrance($sbounty[:should_rest_encum].to_i)
        rest_reason = 'encumbered'
        true
    elsif is_bounty.call 'task_provoked'
        false
    elsif is_bounty.call 'task_forage' and can_do_bounty.call and Time.now.to_i < last_forage_attempt + last_forage_delay and percentmind >= $sbounty[:should_rest_mind].to_i
        rest_reason = 'mind is full (waiting on foraging cooldown)'
        true
    elsif ((not can_turn_in.call and is_bounty.call ['success', 'success_guard', 'success_heirloom']) or not can_do_bounty.call or not $sbounty[:enable_hunt_complete]) and percentmind >= $sbounty[:should_rest_mind].to_i
        rest_reason = 'mind is full'
        true
    else
        rest_reason = nil
        false
    end
}

wander = proc { |boundaries|
  room = Room.current
  next_room_options = room.wayto.keys - boundaries
  next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
  next_room = next_room_options.find_all { |r| not $sbounty_wander_rooms.include?(r) }
  if next_room.empty?
    next_room = $sbounty_wander_rooms.find { |r| next_room_options.include?(r) }
  else
    next_room = next_room[rand(next_room.length)]
  end
  $sbounty_wander_rooms.delete(next_room)
  $sbounty_wander_rooms.push(next_room)
  way = room.wayto[next_room]
  if way.class == String
    move(way)
  else
    way.call
  end
}

go2 = proc { |room|
    next if Room.current.id.to_s == room.to_s

    if checkarea =~ /Table/
    if room.to_s == $sbounty[:rest_room].to_s
      next
    end

        stand.call()
        move 'out'
    end

    wait_while { running? 'go2' }
    start_script('go2', [ room.to_s, '_disable_confirm_' ], h={:quiet=>true});
    wait_while { running? 'go2' }
}

go2_nearest = proc { |list|
    room = Room[$sbounty[:rest_room]].find_nearest(list)
    if room.nil?
        error.call "failed to find nearest room"
    end

    go2.call(room)
}

go2_nearest_tag = proc { |tag|
    if checkarea =~ /Table/i
        stand.call()
        fput 'out'
    end

    town = Room[$sbounty[:rest_room]].find_nearest_by_tag('town')
    room = Room[town].find_nearest_by_tag(tag)

    if room.nil?
        error.call "failed to find room by tag: #{tag}"
    end

    go2.call(room)
}

run_commands = proc { |commands|
    next if commands.empty?

    if commands.class != Array
        error.call "run_commands expects an input Array"
    end

    commands.each { |command|
        if command[0] == ';'
            scriptname = command[1..-1]
            start_script scriptname
            wait_while { running? scriptname }
        else
            fput command
        end
    }
}

run_scripts = proc { |scripts|
    scripts.each { |script|
        args   = script.split(' ')
        script = args.shift

        start_script(script, args, true)
        wait_while { running? script }
    }
}

run_loot_script = proc {
    wait_while { running? $sbounty[:loot_script] }
    start_script($sbounty[:loot_script], [], true)
    wait_while { running? $sbounty[:loot_script] }
}

hunt_prepare = proc {
    run_commands.call($sbounty[:hunt_pre_commands])
}

start_hunting_scripts = proc {
    $sbounty[:hunting_scripts].each { |script|
        start_script(script, [], h={:quiet=>true}) if not running?(script)
    }
}

kill_hunting_scripts = proc {
    $sbounty[:hunting_scripts].each { |script|
        stop_script(script) if running?(script)
    }
}

rest_goto = proc {
    next if in_rest_area
    go2.call($sbounty[:rest_room])
}

rest_exit = proc {
    next unless in_rest_area
    if Room.current.id != $sbounty[:rest_room] and Room.current.path_to($sbounty[:rest_room]).nil?
    run_commands.call($sbounty[:rest_out_commands])
    end
    in_rest_area = false
}

rest_enter = proc {
    next if in_rest_area
    if Room.current.id != $sbounty[:rest_room] and Room.current.path_to($sbounty[:rest_room]).nil?
        run_commands.call($sbounty[:rest_in_commands])
    end
    in_rest_area = true
}

rest_run_scripts = proc {
    rest_exit.call
    run_scripts.call($sbounty[:rest_scripts])
}

reload_hunter = proc {
    $SBOUNTY_HUNTER_SETUP.call($sbounty.to_hash.dup, get_bounty_location.call)
    $SBOUNTY_HUNTER_RELOAD.call
}

start_hunter = proc { |location|
    $SBOUNTY_HUNTER_SETUP.call($sbounty.to_hash.dup, location)
    $SBOUNTY_CURRENT_LOCATION = location
    start_script($SBOUNTY_HUNTER_NAME, [], false)
}

finish_hunt = proc {
    if running? $SBOUNTY_HUNTER_NAME
        stop_script($SBOUNTY_HUNTER_NAME)
        wait_while { running? $SBOUNTY_HUNTER_NAME }
    end

    stop_script 'go2' if running? 'go2'
    change_stance.call('defensive')

    # pause to make sure looter isn't running
    wait_while { running? $sbounty[:loot_script] }

    # run loot script in case the hunter wasn't able to clean up
    if GameObj.npcs.find { |npc| npc.status =~ /dead/ } or is_bounty.call 'success_heirloom'
        run_loot_script.call
    end
}

remove_bounty = proc {
    next if (not $sbounty[:enable_expedite] and Spell['Next Bounty'].active?) or is_bounty.call 'none'

    rest_exit.call

    kill_script 'go2' if running? 'go2'

    go2_nearest_tag.call('advguild')

    print.call 'removing bounty, you have five seconds to kill me'
    sleep 5.00

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

    res = dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?want to be removed|Trying to sneak/
    if res =~ /Trying to sneak/
        fput "ask #{npc} about bounty"
    else
        dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?have removed you/
    end

    can_do_bounty_cache = nil
}

expedite_bounty = proc {
    print.call 'expediting bounty, you have five seconds to kill me'
    sleep 5.00

    remove_bounty.call

    rest_exit.call
    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

    res = dothistimeout "ask #{npc} about expedite", 5, /I'll expedite|You don't seem to have any expedited task reassignment|I still need to complete/
    if res =~ /expedited/
        expedite_left = false
    end

    can_do_bounty_cache = nil
}

get_bounty = proc {
    rest_exit.call

    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    res = dothistimeout "ask ##{npc.id} for bounty", 2, /(?:protective escort|creature problem|local gem dealer|local furrier|lost heirloom|local healer|local herbalist|local alchemist|local resident|bandit problem|I'm kind of busy right now|I don't seem to have any)/

    if res.nil?
        error.call 'invalid response from taskmaster'
    elsif res =~ /in about (\d+) minutes|in about a minute/
        time = $1.nil? ? 1 : $1.to_i

        Spell['Next Bounty'].putup
        Spell['Next Bounty'].timeleft = time
    elsif res =~ /but I don't seem to have/
        Spell['Next Bounty'].putup
        Spell['Next Bounty'].timeleft = 9999
    elsif res =~ /bandit/
        remove_bounty.call
    end

    can_do_bounty_cache = nil
}

talk_to_herbalist = proc {
    go2_nearest.call([ 3824, 1851, 10396, 640, 5722, 2406, 11002, 9505 ])

    if Room.current.id == 10396
        npc = 'maraene'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /brother Barnstel|scarred Agarnil kris|healer|herbalist|merchant Kelph|famed baker Leaftoe|Akrash|old Mistress Lomara/i }
    end

    if is_bounty.call 'help_herbalist'
        res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
        if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
            print.call "received bounty from herbalist [#{$1} #{$2}]"
        end
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/
        herb_name = $1.gsub(/s?$/,'')
        herbs     = lootsack.contents.find_all { |item| item.name =~ /#{herb_name}/ }

        if herbs.empty?
            error.call 'no herbs to turn in, why are you here?'
        end

        prev_item = nil
        if GameObj.right_hand
            prev_item = GameObj.right_hand

            fput 'store right' if checkright
            fput 'stow right' if checkright
        end

        herbs.each { |herb|
            fput "get ##{herb.id} from ##{lootsack.id}"
            result = dothistimeout "give ##{herb.id} to #{npc}", 3, /This looks perfect|That looks like it has been partially used up/

            if result !~ /perfect/
                fput "drop ##{herb.id}"
            end
        }

        if prev_item
            fput "get ##{prev_item.id}"
        end
    else
        error.call 'why are you at the herbalist?'
    end
}

talk_to_gemdealer = proc {
    go2_nearest_tag.call('gemshop')

    if Room.current.id == 10327
        npc = 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|gem dealer|jeweler|Zirconia/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /interested in purchasing an? (.*?)\. .* go round up ([0-9]+) of them/
        name  = $1
        count = $2.to_i

        print.call "-- received bounty from gem dealer [#{count} #{name}]"
    end
}

talk_to_furrier = proc {
    go2_nearest_tag.call('furrier')

    if Room.current.id == 10327
        npc 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|furrier/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
        print.call "received bounty from furrier [#{$1} #{$2}]"
    end
}

get_guard_npc = proc {
    if Room.current.id == 10915
        'purser'
    else
        GameObj.npcs.find { |npc| npc.name =~ /guard|sergeant|guardsman|purser|Belle/i }
    end
}

find_guard = proc {
    go2_nearest_tag.call('advguard')
    npc = get_guard_npc.call

    if npc.nil?
        go2_nearest_tag.call('advguard2')
        npc = get_guard_npc.call
    end

    if npc.nil?
        error.call "failed to locate guard"
    end

    npc
}

talk_to_guard = proc {
    npc = find_guard.call

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, we do have a task for you|Ah, so you have returned/
    if res.nil?
        print.call "unknown response from guard: #{res}"
    end
}

get_random_location = proc {
    keys = []
    $sbounty[:locations].each { |key, data|
        if data[:enable_hunting_rotation]
            keys.push(key)
        end
    }
    name = keys[rand(keys.size)]

    if name.nil?
        error.call 'failed to find a hunting area'
    end

    [ name, $sbounty[:locations][name] ]
}

task_escort = proc { |target|
    print.call "escorting child to #{target}"

    path  = []
    step2 = proc { |destination_room|
        unless path and (s = path.index(Room.current.id)) and (d = path.index(destination_room)) and (s < d)
            previous, shortest_distances = Map.dijkstra(Room.current.id, destination_room)
            unless previous[destination_room]
                echo "error: failed to find a path between your current room (#{Room.current.id}) and destination room (#{destination_room})"
                exit
            end
            path = [ destination_room ]
            path.push(previous[path[-1]]) until previous[path[-1]].nil?
            path.reverse!
            previous = shortest_distances = nil
        end

        way = Room.current.wayto[path[path.index(Room.current.id)+1].to_s]

        if way.class == String
            move way
        elsif way.class == Proc
            way.call
        end
    }

    waitrt?
    fput 'stance defensive' unless checkstance('guarded')

    destination = Room[$sbounty[:rest_room]].find_nearest_by_tag(target)
    while Room.current.id != destination and is_bounty.call 'task_escort'
        if GameObj.npcs.find { |n| n.name =~ /child/i }
            step2.call(destination)
        end
        sleep 0.25
    end

    if is_bounty.call 'fail_child'
        print.call 'failed to escort child or child was killed'
    elsif npc = get_guard_npc.call
        print.call 'waiting for child to arrive'
        wait_until { GameObj.npcs.find { |n| n.name =~ /child/ } }

    if npc.class == String
      fput "ask #{npc} for bounty"
    else
      fput "ask ##{npc.id} for bounty"
    end
    elsif target == 'advguard'
        task_escort.call 'advguard2'
    else
        error.call 'failed to find guard for escort'
    end
}

task_search = proc {
    if bounty? !~ /#{bounty_patterns['task_search']}/
        error.call 'you are not on a search bounty'
    end

    print.call 'searching for heirloom'

    name, location = get_bounty_location.call
    song_of_peace  = false
    invalid_rooms  = []
    last_room      = nil

    hunt_prepare.call
    rest_exit.call

    go2.call location[:room]

    start_hunting_scripts.call

    while is_bounty.call 'task_search' and not $sbounty[:should_rest_wounded].call
        if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
            Spell[1011].cast
            song_of_peace = true
    elsif Spell[506].known? and Spell[506].affordable? and not Spell[506].active?
      Spell[506].cast
        end

        wander.call location[:boundaries]

        stand.call()
        change_stance.call('defensive')

        if (GameObj.npcs.empty? or GameObj.npcs.nil?) and Room.current.location =~ /#{location[:location].downcase.strip}/i and not invalid_rooms.include?(Room.current.id) and Room.current.id != last_room
            run_commands.call($sbounty[:pre_search_commands])

            kneel.call()

            res = dothistimeout 'search', 1, /You intently search the area|You put your head to the/
            if res =~ /You intently search the area|You put your head to the/
                last_room = Room.current.id
            else
                print.call 'invalid room, skipping in the future'
                invalid_rooms.push Room.current.id
            end

            waitrt?

            run_commands.call $sbounty[:post_search_commands]

            while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead|gone/ }.nil?)
                fput 'stance offensive'
        sleep 0.10
            end

            stand.call()
            change_stance.call('defensive')

            if is_bounty.call 'task_found'
                run_loot_script.call
                break
            end
        end
    end

    waitrt?

    if song_of_peace
        fput "stop 1011"
    end

    kill_hunting_scripts.call
}

task_bandit = proc {
    # You have been tasked to suppress bandit activity on the Icemule Trail between Wehnimer's Landing
    # and Icemule Trace.  You need to kill 4 more of them to complete your task.

    if $sbounty[:enable_bandit_script] and not Script.exists?($sbounty[:bandit_script])
        error.call('bandit script is enabled and could not be found')
    end

    if bounty? !~ /#{bounty_patterns['task_bandit']}/
        error.call('you are not on a bandits bounty')
    end

    location = $1.strip.downcase

    get_rooms = proc {
        # get the list of rooms that match
        rooms = Room.list.find_all { |r| r.location =~ /#{location}/i }.collect { |r| r.id }
        previous, shortest_distances = Map.dijkstra($sbounty[:rest_room])
        # delete rooms with no distance or some rooms in Ta'Illistim that are unavailable
        rooms.delete_if { |room_num| shortest_distances[room_num].nil? or [38, 39, 40].include?(room_num) }

        # get 10 rooms only
        rooms = rooms.sort { |a,b| shortest_distances[a] <=> shortest_distances[b] }[0..10]

        # resort rooms by distance
        previous, shortest_distances = Map.dijkstra(Room.current)
        rooms.delete_if { |room_num| room_num == Room.current.id }
        rooms.sort! { |a,b| shortest_distances[a] <=> shortest_distances[b] }
    }

    print.call('culling bandits')

    my_ambush = false
    ambush_room_count = XMLData.room_count
    start_hunting_scripts.call

    while not $sbounty[:should_rest_wounded].call and is_bounty.call('task_bandit')
        get_rooms.call.each { |room|
            waitrt?
            waitcastrt?

            print.call 'moving to room ' + room.to_s

            change_stance.call('defensive')

            go2.call(room)

            print.call('waiting for attack')

            start = Time.now.to_i
            while true
                if Time.now.to_i - start > 2
                    break
                end

                if GameObj.npcs.find { |npc| npc.type =~ /bandit/ }
                    break
                end

                sleep 0.25
            end

            while not $sbounty[:should_rest_wounded].call()
                npcs = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status !~ /dead/ }
                dead = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status =~ /dead/ }

                if npcs.empty?
                    break
                elsif $sbounty[:enable_bandit_script]
                    waitrt?
                    waitcastrt?

                    if not dead.empty?
                        run_loot_script.call()
                    else
                        start_script($sbounty[:bandit_script], npcs.collect { |n| n.id }, h={:quiet=>true})
                        wait_while { running?($sbounty[:bandit_script]) }
                    end
                else
                    print.call('kill them all!')
                    script.pause
                end

                sleep 0.25
            end

            break if $sbounty[:should_rest_wounded].call or not is_bounty.call('task_bandit')
        }

        sleep 0.1
    end

    kill_hunting_scripts.call
}

task_forage = proc {
    if bounty? !~ /#{bounty_patterns['task_forage']}/
        error.call 'you are not on a forage bounty'
    end

    herb     = $1
    location = $2
    count    = $3.to_i

    print.call("foraging for #{count} #{herb} at #{location}")

    herb = herb.downcase

    refresh_spells = proc {
        [506, 603, 9704, 'Sigil of Resolve'].each { |spell|
            if Spell[spell].known? and not Spell[spell].active? and Spell[spell].affordable?
                waitrt?
                waitcastrt?

                Spell[spell].cast
                sleep 0.50
            end
        }

        yierka          = Spell['AA: Yierka']
        yierka_cooldown = Spell['AA: Yierka Cooldown']

        if yierka.known? and yierka.affordable? and not yierka_cooldown.active?
            yierka.cast
        end
    }

    get_herb_count = proc {
        lootsack.contents.find_all { |item| item.name =~ /#{herb.gsub(/s?$/,'')}/i }.size
    }

    last_forage_attempt = Time.now.to_i

    if get_herb_count.call < count
        hunt_prepare.call
        rest_exit.call

        rooms = get_herb_rooms.call(location, herb)
        bright_rooms = []

        cur_room  = 0
        num_tries = 0

        song_of_peace = false

        start_hunting_scripts.call

        while get_herb_count.call < count and not $sbounty[:should_rest_wounded].call and num_tries < 3
            sanct_cast = false
            light_cast = false

            go2.call(rooms[cur_room])
            cur_room = cur_room + 1

            if cur_room >= rooms.length
                cur_room  = 0
                num_tries = num_tries + 1
            end

            while get_herb_count.call < count and rooms.length > 0 and not $sbounty[:should_rest_wounded].call
                if not kneeling? and GameObj.pcs.any?
                    break
                end

                if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
                    Spell[1011].cast
                    song_of_peace = true
                end

                waitrt?
                change_stance.call('defensive')

                refresh_spells.call

                if not song_of_peace and not GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead|gone/ }.nil?
                    break
                end

                if not kneeling?
                    run_commands.call($sbounty[:pre_forage_commands])
                    kneel.call()
                end

                if Spell[213].known? and Spell[213].affordable? and not sanct_cast
                    sanct_cast = true
                    fput "incant 213"
                    waitcastrt?
                end

                if Spell[205].known? and Spell[205].affordable? and not bright_rooms.include?(cur_room) and not light_cast
                    light_cast = true
                    fput "incant 205"
                    bright_rooms.push(cur_room)
                    waitcastrt?
                end

                if Skills.stalkingandhiding >= 50
                    fput 'hide' until hidden?
                end

                herb = herb.gsub(/(?:(?:handful|bunch|sprig) of|fragrant|fetid)\s+/, '')
                herb = herb.gsub(/dark pink\s+/, '')
                herb = herb.gsub('mass of ', '')
                herb = herb.gsub('slime-covered ', '')
                herb = herb.gsub('layer of ', '')

                res = dothistimeout "forage #{herb}", 1, /find no trace of what|not even positive|it could be|it could even be found|and manage to find|Roundtime|In order to forage|foraging here recently/

          if res =~ /it could be|it could even be found|not even positive|find no trace of what/
                    rooms.delete_at(cur_room)
            break
                elsif res =~ /and manage to find/
                    while checkleft && (checkleft =~ /#{herb}/ || herb =~ /#{checkleft}/)
                        fput "put #{checkleft} in ##{lootsack.id}"
                    end
                    while checkright && (checkright =~ /#{herb}/ || herb =~ /#{checkright}/)
                        fput "put #{checkright} in ##{lootsack.id}"
                    end

            print.call "-- success, found #{get_herb_count.call} of #{count} #{herb}"
          elsif res =~ /In order to forage/
            fput "stow all"
          elsif res =~ /foraging here recently/
                    print.call 'herb can not be found here, skipping room...'
                    rooms.delete_at(cur_room)
            break
          else
              print.call "failure, found #{get_herb_count.call} of #{count} #{herb}"
          end
            end

            # Sanity check, cleanup any remaining herbs
            while checkleft && (checkleft =~ /#{herb}/ || herb =~ /#{checkleft}/)
                fput "put #{checkleft} in ##{lootsack.id}"
            end
            while checkright && (checkright =~ /#{herb}/ || herb =~ /#{checkright}/)
                fput "put #{checkright} in ##{lootsack.id}"
            end

            if not standing?
                run_commands.call($sbounty[:post_forage_commands])

                while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead/ }.nil?)
                    fput 'stance offensive'
          sleep 0.10
                end

                stand.call()
                change_stance.call('defensive')
            end
        end
    end

    if song_of_peace
        fput "stop 1011"
    end

    if get_herb_count.call >= count
        talk_to_herbalist.call
        last_forage_attempt = 0
    end

    kill_hunting_scripts.call
}

success_heirloom = proc {
    print.call 'turning in heirloom'

    npc = find_guard.call

    empty_hands

    close = false
    if lootsack.contents.nil?
        open_result = dothistimeout "open ##{lootsack.id}", 5, /^You open|^That is already open\.$/
        if open_result =~ /^You open/
            close = true
        else
            dothistimeout "look in ##{lootsack.id}", 5, /In .*? you see/
        end
    end

    found = false
    bounty? =~ /#{bounty_patterns['success_heirloom']}/
    heirloom = $1
    print.call "looking for #{$1}"

    lootsack.contents.each { |item|
        if item.name !~ /#{heirloom}/
            next
        end

        res = dothistimeout "look ##{item.id}", 2, /^Engraved .* initials|^You see nothing unusual\.$|^The ring appears|^It takes you a moment|^It is difficult to see/
        if res =~ /^Engraved .* initials/
            fput "get ##{item.id}"
            fput "give ##{item.id} to #{npc}"
            found = true

            break
        end
    }

    fput "close ##{lootsack.id}" if close

    if not found
        error.call 'failed to find heirloom for guard'
    end

    fill_hands
}

turn_in = proc {
    rest_exit.call

    if is_bounty.call 'success_guard'
        talk_to_guard.call
    elsif is_bounty.call 'success_heirloom'
        success_heirloom.call
    end

    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    res = dothistimeout "ask #{npc} about bounty", 5, /^#{npc}.*?done with that assignment/
    10.times {
        if line = get? and line =~ /You have earned ([0-9]+) bounty points?, ([0-9]+) experience points, and ([0-9]+) silver\./
            print.call "finished task (#{$1} points, #{$2} exp, #{$3} silver)"
            break
        end

        sleep 0.1
    }

    run_loot_script.call
    can_do_bounty_cache = nil
    $sbounty_can_do_bounty = nil
}

talk_to_npc = proc {
    if is_bounty.call ['help_creature', 'help_resident', 'help_heirloom', 'success_guard']
        talk_to_guard.call
    # separate bandits so we don't trigger them on accident while walking
    elsif is_bounty.call ['help_bandit'] and $sbounty[:enable_bandit]
        talk_to_guard.call
    elsif is_bounty.call 'help_furrier'
        talk_to_furrier.call
    elsif is_bounty.call 'help_herbalist'
        talk_to_herbalist.call
    elsif is_bounty.call 'help_gemdealer'
        talk_to_gemdealer.call
    end
}

help = proc {
    respond
    respond 'SpiffyBounty by SpiffyJr (theman@spiffyjr.me)'
    respond 'usage: ;sbounty [hunter=bigshot]'
    respond
}

if script.vars[1] =~ /^setup$/i
    setup.call
    exit
elsif script.vars[1] =~ /^help$/i
    help.call
    exit
elsif script.vars[1] =~ /^forage$/i
    task_forage.call
    exit
elsif script.vars[1] =~ /^bandits?$/i
    task_bandit.call
    exit
elsif script.vars[1] =~ /^npc$/i
    talk_to_npc.call
    exit
elsif script.vars[1] =~ /^load$/i
    start_script($sbounty[:hunter], nil, true)
    wait_while { running? $sbounty[:hunter] }

    location = nil
    if script.vars[2]
        target = script.vars[2]
        locations = $sbounty[:locations].dup
        location = locations.find { |name, data| $SBOUNTY_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } }
    end
    $SBOUNTY_HUNTER_SETUP.call($sbounty.to_hash.dup, get_bounty_location.call(location, target))
    exit
elsif script.vars[1] =~ /^check$/i
    can_do_bounty.call
    exit
elsif script.vars[1]
    $sbounty[:hunter] = "sbounty-#{script.vars[1]}"
end

hunter        = $sbounty[:hunter]
task_accepted = false
resting       = false

start_script(hunter, nil, true)
wait_while { running? hunter }

if not defined? $SBOUNTY_HUNTER_SETUP
    error.call 'hunter setup was not defined'
elsif not defined? $SBOUNTY_HUNTER_NAME
    error.call 'hunter name was not defined'
elsif not defined? $SBOUNTY_HUNTER_RELOAD
    error.call 'hunter reload was not defined'
end

before_dying {
    kill_script($SBOUNTY_HUNTER_NAME) if running?($SBOUNTY_HUNTER_NAME)
    kill_hunting_scripts.call
}

Thread.new {
    wait_until { dead? }
    exit
}

while true
    talk_to_npc.call

    if can_do_bounty.call and not $sbounty[:should_rest_wounded].call
        if is_bounty.call 'task_search'
            task_search.call
        elsif is_bounty.call 'task_forage' and Time.now.to_i >= last_forage_attempt + last_forage_delay
            task_forage.call
        end
    elsif Spell['Next Bounty'].active? and (expedite_left and not is_bounty.call 'none' and not can_do_bounty.call and $sbounty[:enable_expedite]) and not is_bounty.call ['success']
        expedite_bounty.call
        next
    end

    if is_bounty.call 'task_escort' and GameObj.npcs.find { |npc| npc.name =~ /child/ }
        task_escort.call 'advguard'
    elsif is_bounty.call 'task_fail'
        can_do_bounty_cache = nil
    elsif is_bounty.call 'success_heirloom'
        success_heirloom.call
    end

    exit if dead?

    if can_turn_in.call
        turn_in.call
        resting = false
    else
        if not can_do_bounty.call and not Spell['Next Bounty'].active? and not is_bounty.call ['success']
            remove_bounty.call
            get_bounty.call
        elsif should_hunt.call and not should_rest.call and not has_skins.call
            resting   = false
            provoked  = false
            success   = false
            first_run = false
            bounty    = bounty?

            rest_exit.call
            hunt_prepare.call

            # default hunter location
            if can_do_bounty.call
                # order is important here - bandits and regular culling look similar
                if is_bounty.call ['task_bandit']
                    task_bandit.call
                elsif is_bounty.call ['task_cull', 'task_dangerous', 'task_heirloom', 'task_rescue', 'task_skin']
                    start_hunter.call(get_bounty_location.call)
                else
                    start_hunter.call(get_random_location.call)
                end
            else
                start_hunter.call(get_random_location.call)
            end

            while not should_rest.call and running? $SBOUNTY_HUNTER_NAME
                if bounty? =~ /#{bounty_patterns['task_provoked']}/ and not provoked
                    reload_hunter.call
                    provoked = true
                elsif is_bounty.call 'task_escort'
                    break
                elsif has_skins.call
                    break
                elsif not success and (bounty? != bounty and (is_bounty.call [ 'success', 'success_heirloom' ] or (provoked and is_bounty.call 'success_guard')))
                    finish_hunt.call
                    start_hunter.call(get_random_location.call)

                    success = true
                elsif can_turn_in.call
                    break
                elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
                    break
                #elsif true and percentmind >= 100 and not is_bounty.call ['success', 'success_heirloom']
                    # use long term boost
                end

                sleep 0.10
            end

            finish_hunt.call
        elsif not can_turn_in.call
            rest_goto.call

            if not resting or $sbounty[:should_rest_wounded].call
                rest_run_scripts.call
                rest_goto.call
            end

            rest_enter.call

            while should_rest.call or not should_hunt.call
                if can_turn_in.call
                    break
                elsif $sbounty[:should_rest_wounded].call
                    break
                elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
                    break
                end

                fput 'exp'

                if rest_reason.nil?
                    rest_reason = hunt_reason
                end
                print.call "still resting because: #{rest_reason}"

                sleep $sbounty[:rest_sleep_interval]
            end

            resting = true
            rest_exit.call
        end
    end

    sleep 0.10
end