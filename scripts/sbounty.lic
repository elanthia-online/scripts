# #quiet
## vim: set ft=ruby:
=begin

    Does all bounties except gem, escorts, and bandits. Gems should
    be handled via your loot with stockpiling.

 maintainer: Elanthia-Online
   author: spiffyjr
       name: SpiffyBounty
       tags: bounty
    version: 1.2

    changelog:
      1.2 (2025-10-21) fix for proper class/type detection, rubocop cleanup
      1.1 (2021-10-11) updates to support GTK3
      1.0 * Initial release
=end

# Vaalor guards
Room[5827].tags.push('advguard2') unless Room[5827].tags.include?('advguard2')

$sbounty = CharSettings.to_hash

$sbounty[:hunter] ||= 'sbounty-bigshot'

$sbounty[:enable_cull]      = $sbounty[:enable_cull].nil? ? true : $sbounty[:enable_cull]
$sbounty[:enable_dangerous] = $sbounty[:enable_dangerous].nil? ? true : $sbounty[:enable_dangerous]
$sbounty[:enable_forage]    = $sbounty[:enable_forage].nil? ? true : $sbounty[:enable_forage]
$sbounty[:enable_loot]      = $sbounty[:enable_loot].nil? ? true : $sbounty[:enable_loot]
$sbounty[:enable_rescue]    = $sbounty[:enable_rescue].nil? ? true : $sbounty[:enable_rescue]
$sbounty[:enable_search]    = $sbounty[:enable_search].nil? ? true : $sbounty[:enable_search]
$sbounty[:enable_bandit]    = $sbounty[:enable_bandit].nil? ? false : $sbounty[:enable_bandit]
$sbounty[:enable_skin]      = $sbounty[:enable_skin].nil? ? true : $sbounty[:enable_skin]
$sbounty[:enable_expedite]  = $sbounty[:enable_expedite].nil? ? true : $sbounty[:enable_expedite]

$sbounty[:enable_hunt_complete] = $sbounty[:enable_hunt_complete].nil? ? true : $sbounty[:enable_hunt_complete]

$sbounty[:hunting_scripts]       ||= ['spellactive']
$sbounty[:enable_bandit_script]  ||= false
$sbounty[:bandit_script]         ||= 'sbounty-bandit-example'
$sbounty[:pre_search_commands]   ||= ['store all']
$sbounty[:post_search_commands]  ||= ['gird']
$sbounty[:pre_forage_commands]   ||= ['store all']
$sbounty[:post_forage_commands]  ||= ['gird']
$sbounty[:forage_retry_delay]    ||= 300
$sbounty[:loot_script]           ||= 'sloot'
$sbounty[:turn_in_percent]       ||= 95
$sbounty[:enable_turn_in_bounty] ||= $sbounty[:enable_turn_in_bounty].nil? ? true : $sbounty[:enable_turn_in_bounty]

$sbounty[:should_hunt_mind]    ||= 75
$sbounty[:should_hunt_mana]    ||= 0
$sbounty[:should_hunt_spirit]  ||= 7
$sbounty[:hunt_pre_commands]   ||= ['gird']
$sbounty[:should_rest_mind]    ||= 100
$sbounty[:should_rest_mana]    ||= 0
$sbounty[:should_rest_encum]   ||= 20
$sbounty[:should_rest_wounded] ||= StringProc.new('bleeding? || XMLData.injuries.any?{|key,value| value["wound"] > 1} || percenthealth <= 50')

$sbounty[:rest_room]       ||= ''
$sbounty[:boundaries]      ||= ''
$sbounty[:rest_in_commands]    ||= ['go table, sit']
$sbounty[:rest_out_commands]   ||= ['stand', 'out']
$sbounty[:rest_pre_commands]   ||= ['store all']
$sbounty[:rest_scripts]        ||= ['useherbs --buy-missing=on', 'sloot sell', 'waggle']
$sbounty[:rest_sleep_interval] ||= 30

$sbounty[:locations] ||= {}

$sbounty_rest        = false
$sbounty_rest_reason = nil
in_rest_area         = false
rest_reason          = nil
hunt_reason          = nil
can_do_bounty_cache  = nil
expedite_left        = true
last_forage_attempt  = 0
last_forage_delay    = 300
first_run            = true

if UserVars.lootsack.nil? or UserVars.lootsack.empty?
  echo '** lootsack has not been set, set it with ;set change lootsack [container]'
  exit
end

if $sbounty[:enable_skin] and (UserVars.skinsack.nil? or UserVars.skinsack.empty?)
  echo '** skinsack has not been set, set it with ;set change skinsack [container]'
  exit
end

lootsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.lootsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }
skinsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.skinsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }

if lootsack.nil?
  echo '** failed to find your lootsack, set it with ;set change lootsack [container]'
  exit
end

if $sbounty[:enable_skin] and skinsack.nil?
  echo '** failed to find your skinsack, set it with ;set change skinsack [container]'
  exit
end

# You have been tasked to recover a peridot-inset pewter ring that an unfortunate citizen lost after being attacked by a storm giant in the Upper Trollfang near Wehnimer's Landing.  The heirloom can be identified by the initials MG engraved upon it.  Hunt down the creature and LOOT the item from its corpse.

bounty_patterns = {
  'none'             => '^You are not currently assigned a task\.',

  # help
  'help_bandit'      => 'It appears they have a bandit problem',
  'help_creature'    => 'It appears they have a creature problem they\'d like you to solve\.',
  'help_resident'    => 'It appears that a local resident urgently needs our help in some matter\.',
  'help_heirloom'    => 'It appears they need your help in tracking down some kind of lost heirloom\.',
  'help_gemdealer'   => 'The local gem dealer, .*, has an order to fill and wants our help\.',
  'help_herbalist'   => 'local herbalist|local healer|local alchemist',
  'help_furrier'     => 'The local furrier',

  # in progress
  'task_bandit'      => '^You have been tasked to suppress bandit activity (?:in|on|near) (?:the )?(.*)\s(?:near|between|under|\.)',
  'task_escort'      => '^You have made contact with the child',
  'task_dangerous'   => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You can',
  'task_provoked'    => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near) (?:the )?(.*)(?:\s(?:near|between|under)|\.)\s+You have provoked',
  'task_dealer'      => '^The(?: local)? gem dealer',
  'task_forage'      => 'concoction that requires (?:a|an|some) (.*) found (?:in|on|near) (?:the )?(.*?)(?: near| between| under|\.).*These samples must be in pristine condition\.\s+You have been tasked to retrieve (\d+) (?:more )?samples?\.',
  'task_cull'        => 'You have been tasked to(?: help \w*)?(?: (?:retrieve an heirloom|kill a dangerous creature|rescue a missing child) by)? suppress(?:ing)? (.*) activity (?:in|on) (?:the )?(.*)(?:\s(?:near|between|under)|\.)',
  'task_search'      => 'unfortunate citizen lost after being attacked by (?:a|an) (.*?) (?:in|on|near) (?:the )?(.*?)\s?(?:near|between|under|\.  The).*SEARCH',
  'task_heirloom'    => 'unfortunate citizen lost after being attacked by (?:a|an) (.*?) (?:in|on|near) (?:the )?(.*?)\s?(?:near|between|under|\.  The).*LOOT',
  'task_found'       => 'You have located .* and should bring it back',
  'task_skin'        => '^You have been tasked to retrieve (\d+|\w+)s? (.*) of at least .*\.  You can SKIN them off the corpse of (?:a|an) (.*) or ',
  'task_rescue'      => 'A local divinist has had visions of the child fleeing from (?:a|an) (.*) (?:in|on) (?:the )?(.*) (?:near|between|under)',

  # fail
  'fail_child'       => 'The child you were tasked to rescue is gone and your task is failed\.',

  # success
  'success'          => '^You have succeeded in your task and can return',
  'success_guard'    => '^You succeeded in your task and should report back to',
  'success_heirloom' => '^You have located (?:a|an|the|some) (.*) and should bring it back .*\.$'
}

setup = proc {
  script.name

  action = nil
  @window = nil
  notebook = nil

  locations = $sbounty[:locations].dup
  location  = nil

  error = proc { |msg|
    dlg = Gtk::MessageDialog.new(
      :parent  => @window,
      :flags   => [:modal, :destroy_with_parent],
      :type    => :info,
      :buttons => :ok,
      :message => msg
    )
    dlg.run
    dlg.destroy
  }

  widgets = {
    :gui_widgets           => {
      # buttons
      :close     => Gtk::Button.new(:label => 'Close'),
      :create    => Gtk::Button.new(:label => 'Create'),
      :delete    => Gtk::Button.new(:label => 'Delete'),
      :save      => Gtk::Button.new(:label => 'Save & Close'),

      # combos
      :locations => Gtk::ComboBoxText.new,

      # entries
      :new_name  => Gtk::Entry.new,
    },

    :location_widgets      => {
      # check buttons
      :enable_bounty_only      => Gtk::CheckButton.new('Only attack bounty critters'),
      :enable_hunting_rotation => Gtk::CheckButton.new('In hunting rotation'),
      :enable_search_only      => Gtk::CheckButton.new('Only search here (no hunting)'),

      # entries
      :location                => Gtk::Entry.new,
      :skins                   => Gtk::Entry.new,
      :targets                 => Gtk::Entry.new,
      :room                    => Gtk::Entry.new,
      :boundaries              => Gtk::Entry.new,
    },

    # check buttons
    :enable_cull           => Gtk::CheckButton.new('Cull critters'),
    :enable_dangerous      => Gtk::CheckButton.new('Dangerous critter'),
    :enable_forage         => Gtk::CheckButton.new('Forage herbs'),
    :enable_loot           => Gtk::CheckButton.new('Loot heirloom'),
    :enable_rescue         => Gtk::CheckButton.new('Rescue child'),
    :enable_search         => Gtk::CheckButton.new('Search heirloom'),
    :enable_bandit         => Gtk::CheckButton.new('Bandits'),
    :enable_skin           => Gtk::CheckButton.new('Skin critters'),
    :enable_expedite       => Gtk::CheckButton.new('Expedite bounties'),
    :enable_bandit_script  => Gtk::CheckButton.new('Use bandit script'),
    :enable_hunt_complete  => Gtk::CheckButton.new('Hunt until complete?'),
    :enable_turn_in_bounty => Gtk::CheckButton.new('Force turn in if new bounty'),

    # entries
    :hunting_scripts       => Gtk::Entry.new,
    :bandit_script         => Gtk::Entry.new,
    :pre_search_commands   => Gtk::Entry.new,
    :post_search_commands  => Gtk::Entry.new,
    :pre_forage_commands   => Gtk::Entry.new,
    :post_forage_commands  => Gtk::Entry.new,
    :forage_retry_delay    => Gtk::Entry.new,
    :loot_script           => Gtk::Entry.new,
    :turn_in_percent       => Gtk::Entry.new,

    :should_hunt_mind      => Gtk::Entry.new,
    :should_hunt_mana      => Gtk::Entry.new,
    :should_hunt_spirit    => Gtk::Entry.new,

    :hunt_pre_commands     => Gtk::Entry.new,
    :hunt_commands_a       => Gtk::Entry.new,
    :hunt_commands_b       => Gtk::Entry.new,
    :hunt_commands_c       => Gtk::Entry.new,

    :should_rest_mana      => Gtk::Entry.new,
    :should_rest_mind      => Gtk::Entry.new,
    :should_rest_encum     => Gtk::Entry.new,
    :should_rest_wounded   => Gtk::Entry.new,

    :rest_in_commands      => Gtk::Entry.new,
    :rest_out_commands     => Gtk::Entry.new,
    :rest_pre_commands     => Gtk::Entry.new,
    :rest_room             => Gtk::Entry.new,
    :rest_scripts          => Gtk::Entry.new
  }

  Gtk.queue {
    update_disabled = proc {
      widgets[:location_widgets].each { |_key, widget|
        if location.nil?
          widget.set_sensitive(false)
        else
          widget.set_sensitive(true)
        end
      }
    }

    populate_locations = proc {
      loop {
        break if not widgets[:gui_widgets][:locations].model.iter_first
        # widgets[:gui_widgets][:locations].remove_text(0)
        widgets[:gui_widgets][:locations].remove(0)
      }

      locations.keys.sort.each { |text|
        widgets[:gui_widgets][:locations].append_text(text)
      }
    }

    save_location = proc {
      widgets[:location_widgets].each { |key, widget|
        if widget.is_a?(Gtk::CheckButton)
          value = widget.active?
        elsif [:skins, :targets, :boundaries].include?(key)
          value = widget.text.strip.split(',').collect { |item| item.strip }
        else
          value = widget.text.strip
        end

        locations[location][key] = value
      }
    }

    attach_signals = proc {
      widgets[:gui_widgets][:close].signal_connect 'clicked' do action = :close end
      widgets[:gui_widgets][:save].signal_connect 'clicked' do action = :save; save_location.call end
      @window.signal_connect('destroy') do action = :close end

      ###
      ### Something in here when clicking create kills the connection/exits the game
      ###

      widgets[:gui_widgets][:create].signal_connect 'clicked' do
        name = widgets[:gui_widgets][:new_name].text.strip

        if name.nil? or name.empty? or name == '' or name.length < 3
          error.call('You need to enter a name!')
        elsif locations.keys.find { |n| n.downcase.strip == name.downcase.strip }
          error.call 'A location with that name already exists!'
        else
          locations[name] = {}
          widgets[:gui_widgets][:new_name].text = ''
          populate_locations.call
          update_disabled.call
        end
      end

      ###
      ### Creation script end...
      ###

      widgets[:gui_widgets][:delete].signal_connect 'clicked' do
        Gtk.queue {
          if widgets[:gui_widgets][:locations].active == -1
            error.call 'You do not have a location selected!'
          else
            locations.delete(widgets[:gui_widgets][:locations].active_text)
            widgets[:gui_widgets][:locations].remove(widgets[:gui_widgets][:locations].active)

            widgets[:location_widgets].each { |_key, widget|
              if widget.is_a?(Gtk::CheckButton)
                widget.active = (false)
              else
                widget.text = ("")
              end
            }
          end
        }
      end

      widgets[:gui_widgets][:locations].signal_connect 'changed' do
        Gtk.queue {
          save_location.call
          location = widgets[:gui_widgets][:locations].active_text
          if locations[location]
            widgets[:location_widgets].each { |key, widget|
              if widget.is_a?(Gtk::CheckButton)
                widget.active = (!!locations[location][key])
              elsif [:skins, :targets, :boundaries].include?(key)
                widget.text = (locations[location][key].join(',')) if not (locations[location][key].nil?)
              else
                widget.text = (locations[location][key].strip)
              end
            }
          end

          update_disabled.call
        }
      end
    }

    # main window
    @window = Gtk::Window.new
    @window.border_width = 5
    #        @window.keep_above = true  ## this setting prevents the modal ERROR dialog from appearing over it
    @window.resizable = true
    @window.resize 500, 300
    @window.set_window_position(:center)

    # main notebook (tabs)
    notebook = Gtk::Notebook.new
    notebook.show_border = true

    vbox_main = Gtk::Box.new(:vertical)
    vbox_main.pack_start notebook

    # sbounty options
    vbox = Gtk::Box.new(:vertical)

    frm = Gtk::Frame.new('Locations').set_border_width(3)
    tbl = Gtk::Table.new(7, 4, true).set_border_width(3)

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('New name: ')), 0, 1, 0, 1
    tbl.attach widgets[:gui_widgets][:new_name], 1, 3, 0, 1
    tbl.attach widgets[:gui_widgets][:create], 3, 4, 0, 1

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Locations: ')), 0, 1, 1, 2
    tbl.attach widgets[:gui_widgets][:locations], 1, 3, 1, 2
    tbl.attach widgets[:gui_widgets][:delete], 3, 4, 1, 2

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Location: ')), 0, 1, 3, 4
    tbl.attach widgets[:location_widgets][:location], 1, 2, 3, 4
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Skins: ')), 2, 3, 3, 4
    tbl.attach widgets[:location_widgets][:skins], 3, 4, 3, 4

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Targets: ')), 0, 1, 4, 5
    tbl.attach widgets[:location_widgets][:targets], 1, 2, 4, 5

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Room #: ')), 0, 1, 5, 6
    tbl.attach widgets[:location_widgets][:room], 1, 2, 5, 6
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Boundaries: ')), 2, 3, 5, 6
    tbl.attach widgets[:location_widgets][:boundaries], 3, 4, 5, 6

    tbl.attach widgets[:location_widgets][:enable_hunting_rotation], 0, 1, 6, 7
    tbl.attach widgets[:location_widgets][:enable_bounty_only], 1, 2, 6, 7
    tbl.attach widgets[:location_widgets][:enable_search_only], 2, 3, 6, 7

    frm.add(tbl)
    vbox.pack_start(frm)

    frm = Gtk::Frame.new('Bounties').set_border_width(3)
    tbl = Gtk::Table.new(5, 4, true).set_border_width(3)

    tbl.attach widgets[:enable_cull], 0, 1, 0, 1; widgets[:enable_cull].active = $sbounty[:enable_cull]
    tbl.attach widgets[:enable_dangerous], 1, 2, 0, 1; widgets[:enable_dangerous].active = $sbounty[:enable_dangerous]
    tbl.attach widgets[:enable_rescue], 2, 3, 0, 1; widgets[:enable_rescue].active = $sbounty[:enable_rescue]
    tbl.attach widgets[:enable_skin], 3, 4, 0, 1; widgets[:enable_skin].active = $sbounty[:enable_skin]

    tbl.attach widgets[:enable_loot], 0, 1, 1, 2; widgets[:enable_loot].active = $sbounty[:enable_loot]
    tbl.attach widgets[:enable_search], 1, 2, 1, 2; widgets[:enable_search].active = $sbounty[:enable_search]
    tbl.attach widgets[:enable_forage], 2, 3, 1, 2; widgets[:enable_forage].active = $sbounty[:enable_forage]
    tbl.attach widgets[:enable_bandit], 3, 4, 1, 2; widgets[:enable_bandit].active = $sbounty[:enable_bandit]

    tbl.attach widgets[:enable_bandit_script], 1, 2, 2, 3; widgets[:enable_bandit_script].active = $sbounty[:enable_bandit_script]
    tbl.attach widgets[:enable_expedite], 2, 3, 2, 3; widgets[:enable_expedite].active = $sbounty[:enable_expedite]
    tbl.attach widgets[:enable_hunt_complete], 3, 4, 2, 3; widgets[:enable_hunt_complete].active = $sbounty[:enable_hunt_complete]

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('turn in when mind >= ')), 0, 1, 3, 4
    tbl.attach widgets[:turn_in_percent], 1, 2, 3, 4; widgets[:turn_in_percent].text = ($sbounty[:turn_in_percent].to_s)
    tbl.attach widgets[:enable_turn_in_bounty], 3, 4, 3, 4; widgets[:enable_turn_in_bounty].active = $sbounty[:enable_turn_in_bounty]

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('hunting scripts:')), 2, 3, 4, 5
    tbl.attach widgets[:hunting_scripts], 3, 4, 4, 5; widgets[:hunting_scripts].text = ($sbounty[:hunting_scripts].collect { |a| a.strip }.join(','))
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('bandit script:')), 0, 1, 4, 5
    tbl.attach widgets[:bandit_script], 1, 2, 4, 5; widgets[:bandit_script].text = ($sbounty[:bandit_script])

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-search commands: ')), 0, 1, 5, 6
    tbl.attach widgets[:pre_search_commands], 1, 2, 5, 6; widgets[:pre_search_commands].text = ($sbounty[:pre_search_commands].collect { |a| a.strip }.join(','))
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-search commands: ')), 2, 3, 5, 6
    tbl.attach widgets[:post_search_commands], 3, 4, 5, 6; widgets[:post_search_commands].text = ($sbounty[:post_search_commands].collect { |a| a.strip }.join(','))

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-forage commands: ')), 0, 1, 6, 7
    tbl.attach widgets[:pre_forage_commands], 1, 2, 6, 7; widgets[:pre_forage_commands].text = ($sbounty[:pre_forage_commands].collect { |a| a.strip }.join(','))
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-forage commands: ')), 2, 3, 6, 7
    tbl.attach widgets[:post_forage_commands], 3, 4, 6, 7; widgets[:post_forage_commands].text = ($sbounty[:post_forage_commands].collect { |a| a.strip }.join(','))

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('forage retry delay: ')), 0, 1, 7, 8
    tbl.attach widgets[:forage_retry_delay], 1, 2, 7, 8; widgets[:forage_retry_delay].text = ($sbounty[:forage_retry_delay].to_s)
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('loot script: ')), 2, 3, 7, 8
    tbl.attach widgets[:loot_script], 3, 4, 7, 8; widgets[:loot_script].text = ($sbounty[:loot_script].to_s)

    frm.add(tbl)
    vbox.pack_start(frm)

    notebook.append_page vbox, Gtk::Label.new('Locations / Options')

    # default options
    vbox = Gtk::Box.new(:vertical)

    frm = Gtk::Frame.new('Should Rest').set_border_width(3)
    tbl = Gtk::Table.new(3, 4, true).set_border_width(3)

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % >= ')), 0, 1, 0, 1
    tbl.attach widgets[:should_rest_mind], 1, 2, 0, 1; widgets[:should_rest_mind].text = ($sbounty[:should_rest_mind].to_s)
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or mana <= ')), 2, 3, 0, 1
    tbl.attach widgets[:should_rest_mana], 3, 4, 0, 1; widgets[:should_rest_mana].text = ($sbounty[:should_rest_mana].to_s)

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or encumbrance % >= ')), 0, 1, 1, 2
    tbl.attach widgets[:should_rest_encum], 1, 2, 1, 2; widgets[:should_rest_encum].text = ($sbounty[:should_rest_encum].to_s)

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or wounded eval: ')), 0, 1, 2, 3
    tbl.attach widgets[:should_rest_wounded], 1, 4, 2, 3; widgets[:should_rest_wounded].text = ($sbounty[:should_rest_wounded]._dump)

    frm.add(tbl)
    vbox.pack_start(frm)

    frm = Gtk::Frame.new('Resting').set_border_width(3)
    tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('room #: ')), 0, 1, 0, 1
    tbl.attach widgets[:rest_room], 1, 2, 0, 1; widgets[:rest_room].text = ($sbounty[:rest_room].to_s)
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-rest commands: ')), 2, 3, 0, 1
    tbl.attach widgets[:rest_pre_commands], 3, 4, 0, 1; widgets[:rest_pre_commands].text = ($sbounty[:rest_pre_commands].collect { |a| a.strip }.join(','))

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('enter commands: ')), 0, 1, 1, 2
    tbl.attach widgets[:rest_in_commands], 1, 2, 1, 2; widgets[:rest_in_commands].text = ($sbounty[:rest_in_commands].collect { |a| a.strip }.join(','))
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('exit commands: ')), 2, 3, 1, 2
    tbl.attach widgets[:rest_out_commands], 3, 4, 1, 2; widgets[:rest_out_commands].text = ($sbounty[:rest_out_commands].collect { |a| a.strip }.join(','))

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('scripts: ')), 0, 1, 2, 3
    tbl.attach widgets[:rest_scripts], 1, 4, 2, 3; widgets[:rest_scripts].text = ($sbounty[:rest_scripts].collect { |a| a.strip }.join(','))

    frm.add(tbl)
    vbox.pack_start(frm)

    frm = Gtk::Frame.new('Should Hunt').set_border_width(3)
    tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % <= ')), 0, 1, 0, 1
    tbl.attach widgets[:should_hunt_mind], 1, 2, 0, 1; widgets[:should_hunt_mind].text = ($sbounty[:should_hunt_mind].to_s)
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and mana >= ')), 2, 3, 0, 1
    tbl.attach widgets[:should_hunt_mana], 3, 4, 0, 1; widgets[:should_hunt_mana].text = ($sbounty[:should_hunt_mana].to_s)

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and spirit >= ')), 0, 1, 1, 2
    tbl.attach widgets[:should_hunt_spirit], 1, 2, 1, 2; widgets[:should_hunt_spirit].text = ($sbounty[:should_hunt_spirit].to_s)

    frm.add(tbl)
    vbox.pack_start(frm)

    frm = Gtk::Frame.new('Hunting').set_border_width(3)
    tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Pre-hunt commands: ')), 0, 1, 0, 1
    tbl.attach widgets[:hunt_pre_commands], 1, 2, 0, 1; widgets[:hunt_pre_commands].text = ($sbounty[:hunt_pre_commands].collect { |a| a.strip }.join(','))
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (a): ')), 2, 3, 0, 1
    tbl.attach widgets[:hunt_commands_a], 3, 4, 0, 1; widgets[:hunt_commands_a].text = ($sbounty[:hunt_commands_a].collect { |a| a.strip }.join(',')).to_s

    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (b): ')), 0, 1, 1, 2
    tbl.attach widgets[:hunt_commands_b], 1, 2, 1, 2; widgets[:hunt_commands_b].text = ($sbounty[:hunt_commands_b].collect { |a| a.strip }.join(',')).to_s
    tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (c): ')), 2, 3, 1, 2
    tbl.attach widgets[:hunt_commands_c], 3, 4, 1, 2; widgets[:hunt_commands_c].text = ($sbounty[:hunt_commands_c].collect { |a| a.strip }.join(',')).to_s

    frm.add(tbl)
    vbox.pack_start(frm)

    notebook.append_page vbox, Gtk::Label.new('Resting / Hunting')

    # main window widgets
    vbox = Gtk::Box.new(:vertical)
    valign = Gtk::Alignment.new(0, 1, 0, 0)
    vbox.pack_start(valign, :expand => false, :fill => false, :padding => 0)

    hbox = Gtk::Box.new(:horizontal)
    hbox.add widgets[:gui_widgets][:save]
    hbox.add widgets[:gui_widgets][:close]

    halign = Gtk::Alignment.new 1, 0, 0, 0
    halign.add hbox

    vbox.pack_start halign
    vbox_main.pack_start vbox

    # create the window
    attach_signals.call
    update_disabled.call
    populate_locations.call

    @window.add vbox_main
    @window.show_all
  }

  ###
  ### This line prevents the top right corner "X" from properly closing the gui
  ###

  before_dying { Gtk.queue { @window.destroy unless @window.destroyed? } }

  ###
  ### Why? I don't know...
  ###

  sleep 0.10 while action.nil?

  case action
  when :save
    $sbounty[:locations] = locations

    widgets.each { |key, widget|
      next if [:location_widgets, :gui_widgets].include?(key)
      if widget.is_a?(Gtk::CheckButton)
        value = widget.active?
      elsif [:hunting_scripts, :pre_forage_commands, :post_forage_commands, :pre_search_commands, :post_search_commands, :hunt_pre_commands, :hunt_commands_a, :hunt_commands_b, :hunt_commands_c, :rest_in_commands, :rest_out_commands, :rest_pre_commands, :rest_scripts].include?(key)
        value = widget.text.strip.split(',').collect { |item| item.strip }
      elsif key == :should_rest_wounded
        value = StringProc.new widget.text.strip
      else
        value = widget.text.strip
      end

      $sbounty[key] = value
    }
  end
}

change_stance = proc { |stance|
  return if Spell['Zealot'].active? or Spell['Frenzy'].active? or dead?

  while (cur_stance = checkstance) != stance
    res = dothistimeout "stance #{stance}", 2, /You are now|Roundtime|Wait|wait|Your rage causes you/
    if res =~ /Roundtime: (\d+)|wait (\d+)/i
      d = ($1 || $2).strip.to_f - 1
      if d > 0
        sleep(d)
      end
    elsif res =~ /Your rage causes you/
      Spell['Frenzy'].putup
      Spell['Frenzy'].timeleft = 30
    elsif cur_stance == 'guarded' and stance == 'defensive'
      break
    end
  end
}

kneel = proc {
  while true
    break if kneeling?
    waitrt?
    put 'kneel'
    sleep 0.50
  end
}

stand = proc {
  while true
    break if standing?
    waitrt?
    put 'stand'
    sleep 0.50
  end
}

error = proc { |msg|
  echo "** #{msg}"
  exit
}

print = proc { |msg|
  echo "-- #{msg}"
}

clean_skin = proc { |name|
  name.strip.downcase.gsub(/s$/, '').gsub(/teeth/, 'tooth').gsub(/hooves?/, 'hoof')
}

has_skins = proc {
  if bounty? =~ /#{bounty_patterns['task_skin']}/
    count = $1.to_i
    skin  = $2.downcase

    skinsack.contents.find_all { |item| item.name =~ /#{clean_skin.call(skin)}/i }.size >= (count + 3)
  else
    false
  end
}

is_bounty = proc { |types|
  result = []
  if !types.is_a?(Array)
    types = [types]
  end
  types.each { |type| result.push(bounty_patterns[type]) if not bounty_patterns[type].nil? }

  !(bounty? =~ /#{result.join('|')}/).nil?
}

get_bounty_location = proc { |location, target|
  if location.nil?
    # remove search only locations for hunting areas
    locations = $sbounty[:locations].dup
    if is_bounty.call ['task_skin', 'task_heirloom', 'task_dangerous', 'task_cull', 'task_rescue']
      locations.delete_if { |_name, data| data[:enable_search_only] }
    end

    if bounty? =~ /#{bounty_patterns['task_skin']}/
      # remember: don't swap the order or the global $ vars are lost!
      target   = $3.strip.downcase
      skin     = clean_skin.call($2)
      location = locations.find { |_name, data| $SBOUNTY_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } and data[:skins].find { |s| skin =~ /#{s.strip.downcase}/i } }
    else
      bounty_patterns.each { |_key, value|
        if bounty? =~ /#{value}/i
          target   = $1
          location = $2

          break
        end
      }

      location = location.downcase.strip
      location = locations.find { |_name, data|
        cleaned = $SBOUNTY_CLEAN_TARGETS.call(data[:targets])
        location =~ /#{data[:location].strip}/i and cleaned.find { |t|
          target =~ /#{t}/i
        }
      }
    end
  end

  if location
    name = location[0].dup
    data = location[1].to_hash.dup

    if target
      targets = data[:targets].dup
      cleaned = $SBOUNTY_CLEAN_TARGETS.call(data[:targets])
      target_key = nil

      # see if they have a provoked ancient/grizzled line
      if is_bounty.call 'task_provoked'
        target_key = cleaned.find { |t|
          t =~ /ancient|grizzled/ and (
                "ancient #{target}" =~ /#{t}/i or
                "grizzled #{target}" =~ /#{t}/i
              )
        }
      end

      # regular bounties
      if target_key.nil?
        target_key = cleaned.find { |t| target =~ /#{t}/i }
      end

      index = cleaned.index(target_key)
      target = targets[index]

      if is_bounty.call 'task_provoked'
        # add the ancient|grizzled for them
        if target !~ /ancient|grizzled/i
          new_target = target.gsub(cleaned[index], "(?:ancient|grizzled).*#{cleaned[index]}")
          targets[target.index(target)] = new_target
          target = new_target
        end
      end
    end

    if data[:enable_bounty_only]
      targets = [target]
    end

    data[:targets] = targets

    [name, data]
  else
    print.call 'could not find bounty location'
    nil
  end
}

get_herb_rooms = proc { |location, herb|
  target_list = Array.new
  names = [herb]

  if herb == 'ayana leaf'
    names = [herb, 'ayana leaf', 'ayana lichen', 'ayana weed', 'ayana berry', 'ayana root']
  elsif herb == "ayana'al leaf"
    names = [herb, 'ayana\'al leaf', 'ayana\'al lichen', 'ayana\'al weed', 'ayana\'al berry', 'ayana\'al root']
  end

  Room.list.each { |room|
    if room.tags.find { |tag| names.find { |name| tag =~ /#{name}/i } }
      target_list.push(room.id)
    end
  }

  _, shortest_distances = Map.dijkstra(Room.current.id)

  if location
    # delete the room if it's not the correct location
    target_list.delete_if { |room_num|
      if Room[room_num].location.nil?
        Room[room_num].title[0] !~ /#{location}/i
      elsif not Room[room_num].location.nil?
        Room[room_num].location !~ /#{location}/i
      else
        false
      end
    }
  end

  if target_list.length == 0
    similar = Room.tags.find_all { |tag| tag =~ /#{herb}/i }

    if not similar.empty?
      herb = similar.join(', ')
      Room.list.each { |room| target_list.push(room.id) if room.tags.include?(herb) }

      _, shortest_distances = Map.dijkstra(Room.current.id)

      if location
        target_list.delete_if { |room_num| (Room[room_num].location == nil && Room[room_num].title[0] !~ /#{location}/i) }
        target_list.delete_if { |room_num| (Room[room_num].location != nil && Room[room_num].location !~ /#{location}/i) }
      end
    end
  end

  _, shortest_distances = Map.dijkstra($sbounty[:rest_room])
  target_list.delete_if { |room| shortest_distances[room].nil? or shortest_distances[room] > 600 }
}

can_turn_in = proc {
  is_bounty.call ['success', 'success_guard', 'success_heirloom'] and (
      $sbounty[:turn_in_percent].nil? or
      $sbounty[:enable_turn_in_bounty] and not Spell['Next Bounty'].active? or
      percentmind >= $sbounty[:turn_in_percent].to_i and checkmind !~ /saturated/
    )
}

can_do_bounty = proc {
  if not can_do_bounty_cache.nil?
      ; # intentionally left blank
  elsif is_bounty.call ['success', 'success_heirloom', 'success_guard']
    can_do_bounty_cache = true
  elsif is_bounty.call ['task_bandit'] and $sbounty[:enable_bandit] and bounty? !~ /Locksmehr Trail/
    can_do_bounty_cache = true
  elsif ((is_bounty.call 'task_search' and $sbounty[:enable_search] and get_bounty_location.call) or (is_bounty.call 'task_heirloom' and $sbounty[:enable_loot] and get_bounty_location.call))
    can_do_bounty_cache = true
  elsif bounty? =~ /#{bounty_patterns['task_forage']}/ and $sbounty[:enable_forage] and not get_herb_rooms.call($2, $1).empty? and bounty? !~ /green fleshbulb/
    can_do_bounty_cache = true
  # and bounty? !~ /exceptional|outstanding|superb|magnificent/
  elsif is_bounty.call 'task_skin' and $sbounty[:enable_skin] and get_bounty_location.call
    can_do_bounty_cache = true
  elsif is_bounty.call ['task_provoked', 'task_dangerous'] and $sbounty[:enable_dangerous] and get_bounty_location.call
    can_do_bounty_cache = true
  elsif is_bounty.call 'task_cull' and $sbounty[:enable_cull] and get_bounty_location.call
    can_do_bounty_cache = true
  elsif (is_bounty.call 'task_escort' and $sbounty[:enable_rescue]) or (is_bounty.call 'task_rescue' and $sbounty[:enable_rescue] and get_bounty_location.call)
    can_do_bounty_cache = true
  else
    can_do_bounty_cache = false
  end

  $sbounty_can_do_bounty = can_do_bounty_cache

  can_do_bounty_cache
}

should_hunt = proc {
  res = false

  if is_bounty.call ['success', 'success_heirloom', 'success_guard'] and not can_turn_in.call
    res = true
    # on start if less than numb then always try to do bounty
  elsif (can_do_bounty.call and not fried? and not saturated? and first_run)
    res = true
  elsif (not can_do_bounty.call or is_bounty.call ['success', 'success_heirloom', 'success_guard'] or not $sbounty[:enable_hunt_complete]) and percentmind > $sbounty[:should_hunt_mind].to_i
    hunt_reason = 'mind not clear enough'
        ;
  elsif not checkmana($sbounty[:should_hunt_mana].to_i)
    hunt_reason = 'out of mana'
        ;
  elsif not checkspirit($sbounty[:should_hunt_spirit].to_i)
    hunt_reason = 'low spirit'
        ;
  else
    res = true
  end

  res
}

should_rest = proc {
  if $sbounty[:should_rest_wounded].call
    rest_reason = 'wounded'
    true
  elsif $sbounty_rest
    if $sbounty_rest_reason
      rest_reason = $sbounty_rest_reason
    else
      rest_reason = '$sbounty_rest was set'
    end

    if $sbounty_rest_until
      if Time.now.to_i > $sbounty_rest_until
        $sbounty_rest = false
        $sbounty_rest_reason = nil
        $sbounty_rest_until = nil
      end
    else
      $sbounty_rest = false
      $sbounty_rest_reason = nil
    end

    true
  elsif not checkmana($sbounty[:should_rest_mana].to_i)
    rest_reason = 'out of mana'
    true
  elsif checkencumbrance($sbounty[:should_rest_encum].to_i)
    rest_reason = 'encumbered'
    true
  elsif is_bounty.call 'task_provoked'
    false
  elsif is_bounty.call 'task_forage' and can_do_bounty.call and Time.now.to_i < last_forage_attempt + last_forage_delay and percentmind >= $sbounty[:should_rest_mind].to_i
    rest_reason = 'mind is full (waiting on foraging cooldown)'
    true
  elsif ((not can_turn_in.call and is_bounty.call ['success', 'success_guard', 'success_heirloom']) or not can_do_bounty.call or not $sbounty[:enable_hunt_complete]) and percentmind >= $sbounty[:should_rest_mind].to_i
    rest_reason = 'mind is full'
    true
  else
    rest_reason = nil
    false
  end
}

wander = proc { |boundaries|
  room = Room.current
  next_room_options = room.wayto.keys - boundaries
  next_room_options.delete_if { |room_id| (room.timeto[room_id].is_a?(StringProc)) and room.timeto[room_id].call.nil? }
  next_room = next_room_options.find_all { |r| not $sbounty_wander_rooms.include?(r) }
  if next_room.empty?
    next_room = $sbounty_wander_rooms.find { |r| next_room_options.include?(r) }
  else
    next_room = next_room[rand(next_room.length)]
  end
  $sbounty_wander_rooms.delete(next_room)
  $sbounty_wander_rooms.push(next_room)
  way = room.wayto[next_room]
  if way.is_a?(String)
    move(way)
  else
    way.call
  end
}

go2 = proc { |room|
  next if Room.current.id.to_s == room.to_s

  if checkarea =~ /Table/
    if room.to_s == $sbounty[:rest_room].to_s
      next
    end

    stand.call()
    move 'out'
  end

  wait_while { running? 'go2' }
  start_script('go2', [room.to_s, '_disable_confirm_'], { :quiet=>true });
  wait_while { running? 'go2' }
}

go2_nearest = proc { |list|
  room = Room[$sbounty[:rest_room]].find_nearest(list)
  if room.nil?
    error.call "failed to find nearest room"
  end

  go2.call(room)
}

go2_nearest_tag = proc { |tag|
  if checkarea =~ /Table/i
    stand.call()
    fput 'out'
  end

  town = Room[$sbounty[:rest_room]].find_nearest_by_tag('town')
  room = Room[town].find_nearest_by_tag(tag)

  if room.nil?
    error.call "failed to find room by tag: #{tag}"
  end

  go2.call(room)
}

run_commands = proc { |commands|
  next if commands.empty?

  if !commands.is_a?(Array)
    error.call "run_commands expects an input Array"
  end

  commands.each { |command|
    if command[0] == ';'
      scriptname = command[1..-1]
      start_script scriptname
      wait_while { running? scriptname }
    else
      fput command
    end
  }
}

run_scripts = proc { |scripts|
  scripts.each { |script|
    args = script.split(' ')
    script = args.shift

    start_script(script, args, true)
    wait_while { running? script }
  }
}

run_loot_script = proc {
  wait_while { running? $sbounty[:loot_script] }
  start_script($sbounty[:loot_script], [], true)
  wait_while { running? $sbounty[:loot_script] }
}

hunt_prepare = proc {
  run_commands.call($sbounty[:hunt_pre_commands])
}

start_hunting_scripts = proc {
  $sbounty[:hunting_scripts].each { |script|
    start_script(script, [], { :quiet=>true }) if not running?(script)
  }
}

kill_hunting_scripts = proc {
  $sbounty[:hunting_scripts].each { |script|
    stop_script(script) if running?(script)
  }
}

rest_goto = proc {
  next if in_rest_area
  go2.call($sbounty[:rest_room])
}

rest_exit = proc {
  next unless in_rest_area
  if Room.current.id != $sbounty[:rest_room] and Room.current.path_to($sbounty[:rest_room]).nil?
    run_commands.call($sbounty[:rest_out_commands])
  end
  in_rest_area = false
}

rest_enter = proc {
  next if in_rest_area
  if Room.current.id != $sbounty[:rest_room] and Room.current.path_to($sbounty[:rest_room]).nil?
    run_commands.call($sbounty[:rest_in_commands])
  end
  in_rest_area = true
}

rest_run_scripts = proc {
  rest_exit.call
  run_scripts.call($sbounty[:rest_scripts])
}

reload_hunter = proc {
  $SBOUNTY_HUNTER_SETUP.call($sbounty.to_hash.dup, get_bounty_location.call)
  $SBOUNTY_HUNTER_RELOAD.call
}

start_hunter = proc { |location|
  $SBOUNTY_HUNTER_SETUP.call($sbounty.to_hash.dup, location)
  $SBOUNTY_CURRENT_LOCATION = location
  start_script($SBOUNTY_HUNTER_NAME, [], false)
}

finish_hunt = proc {
  if running? $SBOUNTY_HUNTER_NAME
    stop_script($SBOUNTY_HUNTER_NAME)
    wait_while { running? $SBOUNTY_HUNTER_NAME }
  end

  stop_script 'go2' if running? 'go2'
  change_stance.call('defensive')

  # pause to make sure looter isn't running
  wait_while { running? $sbounty[:loot_script] }

  # run loot script in case the hunter wasn't able to clean up
  if GameObj.npcs.find { |npc| npc.status =~ /dead/ } or is_bounty.call 'success_heirloom'
    run_loot_script.call
  end
}

remove_bounty = proc {
  next if (not $sbounty[:enable_expedite] and Spell['Next Bounty'].active?) or is_bounty.call 'none'

  rest_exit.call

  kill_script 'go2' if running? 'go2'

  go2_nearest_tag.call('advguild')

  print.call 'removing bounty, you have five seconds to kill me'
  sleep 5.00

  npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
  if npc.nil?
    error.call 'failed to find taskmaster'
  end

  res = dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?want to be removed|Trying to sneak/
  if res =~ /Trying to sneak/
    fput "ask #{npc} about bounty"
  else
    dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?have removed you/
  end

  can_do_bounty_cache = nil
}

expedite_bounty = proc {
  print.call 'expediting bounty, you have five seconds to kill me'
  sleep 5.00

  remove_bounty.call

  rest_exit.call
  go2_nearest_tag.call('advguild')

  npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
  if npc.nil?
    error.call 'failed to find taskmaster'
  end

  res = dothistimeout "ask #{npc} about expedite", 5, /I'll expedite|You don't seem to have any expedited task reassignment|I still need to complete/
  if res =~ /expedited/
    expedite_left = false
  end

  can_do_bounty_cache = nil
}

get_bounty = proc {
  rest_exit.call

  go2_nearest_tag.call('advguild')

  npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
  res = dothistimeout "ask ##{npc.id} for bounty", 2, /(?:protective escort|creature problem|local gem dealer|local furrier|lost heirloom|local healer|local herbalist|local alchemist|local resident|bandit problem|I'm kind of busy right now|I don't seem to have any)/

  if res.nil?
    error.call 'invalid response from taskmaster'
  elsif res =~ /in about (\d+) minutes|in about a minute/
    time = $1.nil? ? 1 : $1.to_i

    Spell['Next Bounty'].putup
    Spell['Next Bounty'].timeleft = time
  elsif res =~ /but I don't seem to have/
    Spell['Next Bounty'].putup
    Spell['Next Bounty'].timeleft = 9999
  elsif res =~ /bandit/
    remove_bounty.call
  end

  can_do_bounty_cache = nil
}

talk_to_herbalist = proc {
  go2_nearest.call([3824, 1851, 10396, 640, 5722, 2406, 11002, 9505])

  if Room.current.id == 10396
    npc = 'maraene'
  else
    npc = GameObj.npcs.find { |t| t.name =~ /brother Barnstel|scarred Agarnil kris|healer|herbalist|merchant Kelph|famed baker Leaftoe|Akrash|old Mistress Lomara/i }
  end

  if is_bounty.call 'help_herbalist'
    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
      print.call "received bounty from herbalist [#{$1} #{$2}]"
    end
  elsif bounty? =~ /#{bounty_patterns['task_forage']}/
    herb_name = $1.gsub(/s?$/, '')
    herbs     = lootsack.contents.find_all { |item| item.name =~ /#{herb_name}/ }

    if herbs.empty?
      error.call 'no herbs to turn in, why are you here?'
    end

    prev_item = nil
    if GameObj.right_hand
      prev_item = GameObj.right_hand

      fput 'store right' if checkright
      fput 'stow right' if checkright
    end

    herbs.each { |herb|
      fput "get ##{herb.id} from ##{lootsack.id}"
      result = dothistimeout "give ##{herb.id} to #{npc}", 3, /This looks perfect|That looks like it has been partially used up/

      if result !~ /perfect/
        fput "drop ##{herb.id}"
      end
    }

    if prev_item
      fput "get ##{prev_item.id}"
    end
  else
    error.call 'why are you at the herbalist?'
  end
}

talk_to_gemdealer = proc {
  go2_nearest_tag.call('gemshop')

  if Room.current.id == 10327
    npc = 'areacne'
  else
    npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|gem dealer|jeweler|Zirconia/i }
  end

  res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
  if res =~ /interested in purchasing an? (.*?)\. .* go round up ([0-9]+) of them/
    name  = $1
    count = $2.to_i

    print.call "-- received bounty from gem dealer [#{count} #{name}]"
  end
}

talk_to_furrier = proc {
  go2_nearest_tag.call('furrier')

  if Room.current.id == 10327
    npc 'areacne'
  else
    npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|furrier/i }
  end

  res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
  if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
    print.call "received bounty from furrier [#{$1} #{$2}]"
  end
}

get_guard_npc = proc {
  if Room.current.id == 10915
    'purser'
  else
    GameObj.npcs.find { |npc| npc.name =~ /guard|sergeant|guardsman|purser|Belle/i }
  end
}

find_guard = proc {
  go2_nearest_tag.call('advguard')
  npc = get_guard_npc.call

  if npc.nil?
    go2_nearest_tag.call('advguard2')
    npc = get_guard_npc.call
  end

  if npc.nil?
    error.call "failed to locate guard"
  end

  npc
}

talk_to_guard = proc {
  npc = find_guard.call

  res = dothistimeout "ask #{npc} about bounty", 5, /Yes, we do have a task for you|Ah, so you have returned/
  if res.nil?
    print.call "unknown response from guard: #{res}"
  end
}

get_random_location = proc {
  keys = []
  $sbounty[:locations].each { |key, data|
    if data[:enable_hunting_rotation]
      keys.push(key)
    end
  }
  name = keys[rand(keys.size)]

  if name.nil?
    error.call 'failed to find a hunting area'
  end

  [name, $sbounty[:locations][name]]
}

task_escort = proc { |target|
  print.call "escorting child to #{target}"

  path  = []
  step2 = proc { |destination_room|
    unless path and (s = path.index(Room.current.id)) and (d = path.index(destination_room)) and (s < d)
      previous, _ = Map.dijkstra(Room.current.id, destination_room)
      unless previous[destination_room]
        echo "error: failed to find a path between your current room (#{Room.current.id}) and destination room (#{destination_room})"
        exit
      end
      path = [destination_room]
      path.push(previous[path[-1]]) until previous[path[-1]].nil?
      path.reverse!
      nil
    end

    way = Room.current.wayto[path[path.index(Room.current.id) + 1].to_s]

    if way.is_a?(String)
      move way
    elsif way.is_a?(StringProc)
      way.call
    end
  }

  waitrt?
  fput 'stance defensive' unless checkstance('guarded')

  destination = Room[$sbounty[:rest_room]].find_nearest_by_tag(target)
  while Room.current.id != destination and is_bounty.call 'task_escort'
    if GameObj.npcs.find { |n| n.name =~ /child/i }
      step2.call(destination)
    end
    sleep 0.25
  end

  if is_bounty.call 'fail_child'
    print.call 'failed to escort child or child was killed'
  elsif (npc = get_guard_npc.call)
    print.call 'waiting for child to arrive'
    wait_until { GameObj.npcs.find { |n| n.name =~ /child/ } }

    if npc.is_a?(String)
      fput "ask #{npc} for bounty"
    else
      fput "ask ##{npc.id} for bounty"
    end
  elsif target == 'advguard'
    task_escort.call 'advguard2'
  else
    error.call 'failed to find guard for escort'
  end
}

task_search = proc {
  if bounty? !~ /#{bounty_patterns['task_search']}/
    error.call 'you are not on a search bounty'
  end

  print.call 'searching for heirloom'

  _, location = get_bounty_location.call
  song_of_peace  = false
  invalid_rooms  = []
  last_room      = nil

  hunt_prepare.call
  rest_exit.call

  go2.call location[:room]

  start_hunting_scripts.call

  while is_bounty.call 'task_search' and not $sbounty[:should_rest_wounded].call
    if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
      Spell[1011].cast
      song_of_peace = true
    elsif Spell[506].known? and Spell[506].affordable? and not Spell[506].active?
      Spell[506].cast
    end

    wander.call location[:boundaries]

    stand.call()
    change_stance.call('defensive')

    if (GameObj.npcs.empty? or GameObj.npcs.nil?) and Room.current.location =~ /#{location[:location].downcase.strip}/i and not invalid_rooms.include?(Room.current.id) and Room.current.id != last_room
      run_commands.call($sbounty[:pre_search_commands])

      kneel.call()

      res = dothistimeout 'search', 1, /You intently search the area|You put your head to the/
      if res =~ /You intently search the area|You put your head to the/
        last_room = Room.current.id
      else
        print.call 'invalid room, skipping in the future'
        invalid_rooms.push Room.current.id
      end

      waitrt?

      run_commands.call $sbounty[:post_search_commands]

      while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead|gone/ }.nil?)
        fput 'stance offensive'
        sleep 0.10
      end

      stand.call()
      change_stance.call('defensive')

      if is_bounty.call 'task_found'
        run_loot_script.call
        break
      end
    end
  end

  waitrt?

  if song_of_peace
    fput "stop 1011"
  end

  kill_hunting_scripts.call
}

task_bandit = proc {
  # You have been tasked to suppress bandit activity on the Icemule Trail between Wehnimer's Landing
  # and Icemule Trace.  You need to kill 4 more of them to complete your task.

  if $sbounty[:enable_bandit_script] and not Script.exists?($sbounty[:bandit_script])
    error.call('bandit script is enabled and could not be found')
  end

  if bounty? !~ /#{bounty_patterns['task_bandit']}/
    error.call('you are not on a bandits bounty')
  end

  location = $1.strip.downcase

  get_rooms = proc {
    # get the list of rooms that match
    rooms = Room.list.find_all { |r| r.location =~ /#{location}/i }.collect { |r| r.id }
    _, shortest_distances = Map.dijkstra($sbounty[:rest_room])
    # delete rooms with no distance or some rooms in Ta'Illistim that are unavailable
    rooms.delete_if { |room_num| shortest_distances[room_num].nil? or [38, 39, 40].include?(room_num) }

    # get 10 rooms only
    rooms = rooms.sort { |a, b| shortest_distances[a] <=> shortest_distances[b] }[0..10]

    # resort rooms by distance
    _, shortest_distances = Map.dijkstra(Room.current)
    rooms.delete_if { |room_num| room_num == Room.current.id }
    rooms.sort! { |a, b| shortest_distances[a] <=> shortest_distances[b] }
  }

  print.call('culling bandits')
  XMLData.room_count
  start_hunting_scripts.call

  while not $sbounty[:should_rest_wounded].call and is_bounty.call('task_bandit')
    get_rooms.call.each { |room|
      waitrt?
      waitcastrt?

      print.call 'moving to room ' + room.to_s

      change_stance.call('defensive')

      go2.call(room)

      print.call('waiting for attack')

      start = Time.now.to_i
      while true
        if Time.now.to_i - start > 2
          break
        end

        if GameObj.npcs.find { |npc| npc.type =~ /bandit/ }
          break
        end

        sleep 0.25
      end

      while not $sbounty[:should_rest_wounded].call()
        npcs = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status !~ /dead/ }
        dead = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status =~ /dead/ }

        if npcs.empty?
          break
        elsif $sbounty[:enable_bandit_script]
          waitrt?
          waitcastrt?

          if not dead.empty?
            run_loot_script.call()
          else
            start_script($sbounty[:bandit_script], npcs.collect { |n| n.id }, { :quiet=>true })
            wait_while { running?($sbounty[:bandit_script]) }
          end
        else
          print.call('kill them all!')
          script.pause
        end

        sleep 0.25
      end

      break if $sbounty[:should_rest_wounded].call or not is_bounty.call('task_bandit')
    }

    sleep 0.1
  end

  kill_hunting_scripts.call
}

task_forage = proc {
  if bounty? !~ /#{bounty_patterns['task_forage']}/
    error.call 'you are not on a forage bounty'
  end

  herb     = $1
  location = $2
  count    = $3.to_i

  print.call("foraging for #{count} #{herb} at #{location}")

  herb = herb.downcase

  refresh_spells = proc {
    [506, 603, 9704, 'Sigil of Resolve'].each { |spell|
      if Spell[spell].known? and not Spell[spell].active? and Spell[spell].affordable?
        waitrt?
        waitcastrt?

        Spell[spell].cast
        sleep 0.50
      end
    }

    yierka          = Spell['AA: Yierka']
    yierka_cooldown = Spell['AA: Yierka Cooldown']

    if yierka.known? and yierka.affordable? and not yierka_cooldown.active?
      yierka.cast
    end
  }

  get_herb_count = proc {
    lootsack.contents.find_all { |item| item.name =~ /#{herb.gsub(/s?$/, '')}/i }.size
  }

  last_forage_attempt = Time.now.to_i

  if get_herb_count.call < count
    hunt_prepare.call
    rest_exit.call

    rooms = get_herb_rooms.call(location, herb)
    bright_rooms = []

    cur_room  = 0
    num_tries = 0

    song_of_peace = false

    start_hunting_scripts.call

    while get_herb_count.call < count and not $sbounty[:should_rest_wounded].call and num_tries < 3
      sanct_cast = false
      light_cast = false

      go2.call(rooms[cur_room])
      cur_room = cur_room + 1

      if cur_room >= rooms.length
        cur_room  = 0
        num_tries = num_tries + 1
      end

      while get_herb_count.call < count and rooms.length > 0 and not $sbounty[:should_rest_wounded].call
        if not kneeling? and GameObj.pcs.any?
          break
        end

        if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
          Spell[1011].cast
          song_of_peace = true
        end

        waitrt?
        change_stance.call('defensive')

        refresh_spells.call

        if not song_of_peace and not GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead|gone/ }.nil?
          break
        end

        if not kneeling?
          run_commands.call($sbounty[:pre_forage_commands])
          kneel.call()
        end

        if Spell[213].known? and Spell[213].affordable? and not sanct_cast
          sanct_cast = true
          fput "incant 213"
          waitcastrt?
        end

        if Spell[205].known? and Spell[205].affordable? and not bright_rooms.include?(cur_room) and not light_cast
          light_cast = true
          fput "incant 205"
          bright_rooms.push(cur_room)
          waitcastrt?
        end

        if Skills.stalkingandhiding >= 50
          fput 'hide' until hidden?
        end

        herb = herb.gsub(/(?:(?:handful|bunch|sprig) of|fragrant|fetid)\s+/, '')
        herb = herb.gsub(/dark pink\s+/, '')
        herb = herb.gsub('mass of ', '')
        herb = herb.gsub('slime-covered ', '')
        herb = herb.gsub('layer of ', '')

        res = dothistimeout "forage #{herb}", 1, /find no trace of what|not even positive|it could be|it could even be found|and manage to find|Roundtime|In order to forage|foraging here recently/

        if res =~ /it could be|it could even be found|not even positive|find no trace of what/
          rooms.delete_at(cur_room)
          break
        elsif res =~ /and manage to find/
          while checkleft && (checkleft =~ /#{herb}/ || herb =~ /#{checkleft}/)
            fput "put #{checkleft} in ##{lootsack.id}"
          end
          while checkright && (checkright =~ /#{herb}/ || herb =~ /#{checkright}/)
            fput "put #{checkright} in ##{lootsack.id}"
          end

          print.call "-- success, found #{get_herb_count.call} of #{count} #{herb}"
        elsif res =~ /In order to forage/
          fput "stow all"
        elsif res =~ /foraging here recently/
          print.call 'herb can not be found here, skipping room...'
          rooms.delete_at(cur_room)
          break
        else
          print.call "failure, found #{get_herb_count.call} of #{count} #{herb}"
        end
      end

      # Sanity check, cleanup any remaining herbs
      while checkleft && (checkleft =~ /#{herb}/ || herb =~ /#{checkleft}/)
        fput "put #{checkleft} in ##{lootsack.id}"
      end
      while checkright && (checkright =~ /#{herb}/ || herb =~ /#{checkright}/)
        fput "put #{checkright} in ##{lootsack.id}"
      end

      if not standing?
        run_commands.call($sbounty[:post_forage_commands])

        while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.type =~ /aggressive/ && npc.status !~ /dead/ }.nil?)
          fput 'stance offensive'
          sleep 0.10
        end

        stand.call()
        change_stance.call('defensive')
      end
    end
  end

  if song_of_peace
    fput "stop 1011"
  end

  if get_herb_count.call >= count
    talk_to_herbalist.call
    last_forage_attempt = 0
  end

  kill_hunting_scripts.call
}

success_heirloom = proc {
  print.call 'turning in heirloom'

  npc = find_guard.call

  empty_hands

  close = false
  if lootsack.contents.nil?
    open_result = dothistimeout "open ##{lootsack.id}", 5, /^You open|^That is already open\.$/
    if open_result =~ /^You open/
      close = true
    else
      dothistimeout "look in ##{lootsack.id}", 5, /In .*? you see/
    end
  end

  found = false
  bounty? =~ /#{bounty_patterns['success_heirloom']}/
  heirloom = $1
  print.call "looking for #{$1}"

  lootsack.contents.each { |item|
    if item.name !~ /#{heirloom}/
      next
    end

    res = dothistimeout "look ##{item.id}", 2, /^Engraved .* initials|^You see nothing unusual\.$|^The ring appears|^It takes you a moment|^It is difficult to see/
    if res =~ /^Engraved .* initials/
      fput "get ##{item.id}"
      fput "give ##{item.id} to #{npc}"
      found = true

      break
    end
  }

  fput "close ##{lootsack.id}" if close

  if not found
    error.call 'failed to find heirloom for guard'
  end

  fill_hands
}

turn_in = proc {
  rest_exit.call

  if is_bounty.call 'success_guard'
    talk_to_guard.call
  elsif is_bounty.call 'success_heirloom'
    success_heirloom.call
  end

  go2_nearest_tag.call('advguild')

  npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
  dothistimeout "ask #{npc} about bounty", 5, /^#{npc}.*?done with that assignment/
  10.times {
    if (line = get?) and line =~ /You have earned ([0-9]+) bounty points?, ([0-9]+) experience points, and ([0-9]+) silver\./
      print.call "finished task (#{$1} points, #{$2} exp, #{$3} silver)"
      break
    end

    sleep 0.1
  }

  run_loot_script.call
  can_do_bounty_cache = nil
  $sbounty_can_do_bounty = nil
}

talk_to_npc = proc {
  if is_bounty.call ['help_creature', 'help_resident', 'help_heirloom', 'success_guard']
    talk_to_guard.call
  # separate bandits so we don't trigger them on accident while walking
  elsif is_bounty.call ['help_bandit'] and $sbounty[:enable_bandit]
    talk_to_guard.call
  elsif is_bounty.call 'help_furrier'
    talk_to_furrier.call
  elsif is_bounty.call 'help_herbalist'
    talk_to_herbalist.call
  elsif is_bounty.call 'help_gemdealer'
    talk_to_gemdealer.call
  end
}

help = proc {
  respond
  respond 'SpiffyBounty by SpiffyJr (theman@spiffyjr.me)'
  respond 'usage: ;sbounty [hunter=bigshot]'
  respond
}

if script.vars[1] =~ /^setup$/i
  setup.call
  exit
elsif script.vars[1] =~ /^help$/i
  help.call
  exit
elsif script.vars[1] =~ /^forage$/i
  task_forage.call
  exit
elsif script.vars[1] =~ /^bandits?$/i
  task_bandit.call
  exit
elsif script.vars[1] =~ /^npc$/i
  talk_to_npc.call
  exit
elsif script.vars[1] =~ /^load$/i
  start_script($sbounty[:hunter], nil, true)
  wait_while { running? $sbounty[:hunter] }

  location = nil
  if script.vars[2]
    target = script.vars[2]
    locations = $sbounty[:locations].dup
    location = locations.find { |_name, data| $SBOUNTY_CLEAN_TARGETS.call(data[:targets]).find { |t| target =~ /#{t}/i } }
  end
  $SBOUNTY_HUNTER_SETUP.call($sbounty.to_hash.dup, get_bounty_location.call(location, target))
  exit
elsif script.vars[1] =~ /^check$/i
  can_do_bounty.call
  exit
elsif script.vars[1]
  $sbounty[:hunter] = "sbounty-#{script.vars[1]}"
end

hunter = $sbounty[:hunter]
resting = false

start_script(hunter, nil, true)
wait_while { running? hunter }

if not defined? $SBOUNTY_HUNTER_SETUP
  error.call 'hunter setup was not defined'
elsif not defined? $SBOUNTY_HUNTER_NAME
  error.call 'hunter name was not defined'
elsif not defined? $SBOUNTY_HUNTER_RELOAD
  error.call 'hunter reload was not defined'
end

before_dying {
  kill_script($SBOUNTY_HUNTER_NAME) if running?($SBOUNTY_HUNTER_NAME)
  kill_hunting_scripts.call
}

Thread.new {
  wait_until { dead? }
  exit
}

while true
  talk_to_npc.call

  if can_do_bounty.call and not $sbounty[:should_rest_wounded].call
    if is_bounty.call 'task_search'
      task_search.call
    elsif is_bounty.call 'task_forage' and Time.now.to_i >= last_forage_attempt + last_forage_delay
      task_forage.call
    end
  elsif Spell['Next Bounty'].active? and (expedite_left and not is_bounty.call 'none' and not can_do_bounty.call and $sbounty[:enable_expedite]) and not is_bounty.call ['success']
    expedite_bounty.call
    next
  end

  if is_bounty.call 'task_escort' and GameObj.npcs.find { |npc| npc.name =~ /child/ }
    task_escort.call 'advguard'
  elsif is_bounty.call 'task_fail'
    can_do_bounty_cache = nil
  elsif is_bounty.call 'success_heirloom'
    success_heirloom.call
  end

  exit if dead?

  if can_turn_in.call
    turn_in.call
    resting = false
  else
    if not can_do_bounty.call and not Spell['Next Bounty'].active? and not is_bounty.call ['success']
      remove_bounty.call
      get_bounty.call
    elsif should_hunt.call and not should_rest.call and not has_skins.call
      resting = false
      provoked  = false
      success   = false
      first_run = false
      bounty    = bounty?

      rest_exit.call
      hunt_prepare.call

      # default hunter location
      if can_do_bounty.call
        # order is important here - bandits and regular culling look similar
        if is_bounty.call ['task_bandit']
          task_bandit.call
        elsif is_bounty.call ['task_cull', 'task_dangerous', 'task_heirloom', 'task_rescue', 'task_skin']
          start_hunter.call(get_bounty_location.call)
        else
          start_hunter.call(get_random_location.call)
        end
      else
        start_hunter.call(get_random_location.call)
      end

      while not should_rest.call and running? $SBOUNTY_HUNTER_NAME
        if bounty? =~ /#{bounty_patterns['task_provoked']}/ and not provoked
          reload_hunter.call
          provoked = true
        elsif is_bounty.call 'task_escort'
          break
        elsif has_skins.call
          break
        elsif not success and (bounty? != bounty and (is_bounty.call ['success', 'success_heirloom'] or (provoked and is_bounty.call 'success_guard')))
          finish_hunt.call
          start_hunter.call(get_random_location.call)

          success = true
        elsif can_turn_in.call
          break
        elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
          break
          # elsif true and percentmind >= 100 and not is_bounty.call ['success', 'success_heirloom']
          # use long term boost
        end

        sleep 0.10
      end

      finish_hunt.call
    elsif not can_turn_in.call
      rest_goto.call

      if not resting or $sbounty[:should_rest_wounded].call
        rest_run_scripts.call
        rest_goto.call
      end

      rest_enter.call

      while should_rest.call or not should_hunt.call
        if can_turn_in.call
          break
        elsif $sbounty[:should_rest_wounded].call
          break
        elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
          break
        end

        fput 'exp'

        if rest_reason.nil?
          rest_reason = hunt_reason
        end
        print.call "still resting because: #{rest_reason}"

        sleep $sbounty[:rest_sleep_interval]
      end

      resting = true
      rest_exit.call
    end
  end

  sleep 0.10
end
