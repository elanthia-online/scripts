=begin
  keymaster.lic: I am Vinz, Vinz Clortho, Keymaster of Gozer...
                  Volguus Zildrohoar, Lord of the Seboullia. Are you the Gatekeeper?

  A script to scan through all your existing worn containers and find any lock & key.
  Will first try to combine non-rainbow-hued lock/keys.
  Then second it will use any rainbow-hued lock/keys with any leftover of same tier.
  Will NOT combine to create new rainbow-hued variants.
  Uses stow container for found rewards.

            author: elanthia-online
              game: Gemstone
              tags: loot, lock, key
           version: 1.0.0
  Improvements:
  Major_change.feature_addition.bugfix
    v1.0.0  (2026-01-20)
      - initial release

=end

module KeyMaster
  TIERS = ["vibrant", "radiant"] unless defined?(TIERS)
  COLORS = ["blood red", "forest green", "frosty white", "royal blue"] unless defined?(COLORS)
  WILDCARD = "rainbow-hued" unless defined?(WILDCARD)

  class Processor
    attr_reader :rewards

    def initialize
      @rewards = []
      @processed_keys = []
      @processed_locks = []
      @pairs_by_tier = Hash.new(0)
      @rewards_by_tier = Hash.new { |h, k| h[k] = Hash.new(0) }
    end

    def run
      keys, locks = find_items

      # Phase 1: Process exact tier+color matches (non-wildcard only)
      process_exact_matches(keys, locks)

      # Phase 2: Process leftovers with rainbow-hued wildcards
      process_wildcard_matches(keys, locks)

      print_report

      @rewards
    end

    private

    def find_items
      keys = []
      locks = []

      # Build exact patterns for all valid combinations
      valid_keys = []
      valid_locks = []

      TIERS.each do |tier|
        COLORS.each do |color|
          valid_keys << "#{tier} #{color} key"
          valid_locks << "#{tier} #{color} lock"
        end
        # Add wildcard variants
        valid_keys << "#{tier} #{WILDCARD} key"
        valid_locks << "#{tier} #{WILDCARD} lock"
      end

      GameObj.inv.each do |inv_item|
        next unless GameObj.containers.keys.include?(inv_item.id)
        inv_item.contents.each do |item|
          keys.push(item) if valid_keys.include?(item.name)
          locks.push(item) if valid_locks.include?(item.name)
        end
      end

      [keys, locks]
    end

    def process_exact_matches(keys, locks)
      TIERS.each do |tier|
        # Only process the 4 regular colors, NOT the wildcard
        COLORS.each do |color|
          process_matches(keys, locks, tier, color, tier, color)
        end
      end
    end

    def process_wildcard_matches(keys, locks)
      TIERS.each do |tier|
        # Try to match leftover colored keys with rainbow locks
        COLORS.each do |color|
          process_matches(keys, locks, tier, color, tier, WILDCARD)
        end

        # Try to match leftover colored locks with rainbow keys
        COLORS.each do |color|
          process_matches(keys, locks, tier, WILDCARD, tier, color)
        end
      end
    end

    def process_matches(keys, locks, key_tier, key_color, lock_tier, lock_color)
      available_keys = keys.select { |k|
        !@processed_keys.include?(k.id) && matches_pattern?(k.name, key_tier, key_color, :key)
      }

      available_locks = locks.select { |l|
        !@processed_locks.include?(l.id) && matches_pattern?(l.name, lock_tier, lock_color, :lock)
      }

      available_keys.each do |key|
        lock = available_locks.shift
        break unless lock

        # Use the key's tier (they should match anyway)
        unlock_pair(key, lock, key_tier)
      end
    end

    def matches_pattern?(name, tier, color, type)
      expected = "#{tier} #{color} #{type}"
      name == expected
    end

    def unlock_pair(key, lock, tier)
      fput("get ##{key.id}")
      fput("get ##{lock.id}")
      fput("open my lock")

      # Break both baubles
      2.times do
        if [GameObj.right_hand.noun, GameObj.left_hand.noun].include?("bauble")
          fput("break my bauble")

          # Collect rewards and track by tier
          if GameObj.left_hand.id
            @rewards.push(GameObj.left_hand)
            @rewards_by_tier[tier][GameObj.left_hand.name] += 1
          end
          if GameObj.right_hand.id
            @rewards.push(GameObj.right_hand)
            @rewards_by_tier[tier][GameObj.right_hand.name] += 1
          end
        end
      end

      fput("stow all")

      # Mark as processed and track tier
      @processed_keys.push(key.id)
      @processed_locks.push(lock.id)
      @pairs_by_tier[tier] += 1
    end

    def print_report
      return if @rewards.empty?

      _respond ""
      _respond "=" * 60
      _respond "KeyMaster Rewards Summary"
      _respond "=" * 60

      # Breakdown by tier
      TIERS.each do |tier|
        next if @pairs_by_tier[tier] == 0

        _respond ""
        _respond "#{tier.capitalize} Tier:"
        _respond "  Pairs processed: #{@pairs_by_tier[tier]}"

        if @rewards_by_tier[tier].any?
          _respond "  Rewards:"
          @rewards_by_tier[tier].each do |name, count|
            _respond "    #{name} x#{count}"
          end
        end
      end

      _respond ""
      _respond "-" * 60
      _respond "Total pairs processed: #{@processed_keys.length}"
      _respond "Total rewards: #{@rewards.length}"
      _respond "=" * 60
      _respond ""
    end
  end

  def self.process
    processor = Processor.new
    processor.run
  end
end

# Usage:
empty_hands
KeyMaster.process
fill_hands
