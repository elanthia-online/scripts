=begin
  keymaster.lic: I am Vinz, Vinz Clortho, Keymaster of Gozer...
                  Volguus Zildrohoar, Lord of the Seboullia. Are you the Gatekeeper?

  A script to scan through all your existing worn containers and find any lock & key.
  Will first try to combine non-rainbow-hued lock/keys.
  Then second it will use any rainbow-hued lock/keys with any leftover of same tier.
  Will NOT combine to create new rainbow-hued variants.
  Uses stow container for found rewards.

            author: elanthia-online
              game: Gemstone
              tags: loot, lock, key
           version: 1.0.0
  Improvements:
  Major_change.feature_addition.bugfix
    v1.0.0  (2026-01-20)
      - initial release

=end

# KeyMaster automates the processing of tier-based locks and keys found in containers.
#
# The module scans through all worn containers to find matching locks and keys,
# then processes them in a specific order:
# 1. First processes exact tier+color matches (non-rainbow)
# 2. Then processes leftovers using rainbow-hued wildcards
#
# @example Basic usage
#   empty_hands
#   KeyMaster.process
#   fill_hands
#
# @author elanthia-online
# @since 1.0.0
module KeyMaster
  # Valid tier types for locks and keys
  # @return [Array<String>] array of tier names
  TIERS = ["vibrant", "radiant"] unless defined?(TIERS)

  # Valid color types for locks and keys
  # @return [Array<String>] array of color names
  COLORS = ["blood red", "forest green", "frosty white", "royal blue"] unless defined?(COLORS)

  # Wildcard color that matches any regular color within the same tier
  # @return [String] the wildcard color identifier
  WILDCARD = "rainbow-hued" unless defined?(WILDCARD)

  # Core processor class that handles the lock and key matching logic.
  #
  # The Processor maintains state about which items have been processed and
  # generates a summary report of rewards received.
  #
  # @example Creating and running a processor
  #   processor = KeyMaster::Processor.new
  #   rewards = processor.run
  #
  # @since 1.0.0
  class Processor
    # @!attribute [r] rewards
    #   @return [Array<GameObj>] collection of reward items received from processing pairs
    attr_reader :rewards

    # Initialize a new Processor instance.
    #
    # Sets up tracking arrays and hashes for processed items, pair counts,
    # and reward categorization by tier.
    def initialize
      @rewards = []
      @processed_keys = []
      @processed_locks = []
      @pairs_by_tier = Hash.new(0)
      @rewards_by_tier = Hash.new { |h, k| h[k] = Hash.new(0) }
    end

    # Execute the main processing workflow.
    #
    # Scans containers, processes matches in two phases (exact matches first,
    # then wildcard matches), prints a summary report, and returns all rewards.
    #
    # @return [Array<GameObj>] all reward items collected during processing
    #
    # @example
    #   processor = KeyMaster::Processor.new
    #   rewards = processor.run
    #   puts "Collected #{rewards.length} rewards"
    def run
      keys, locks = find_items

      # Phase 1: Process exact tier+color matches (non-wildcard only)
      process_exact_matches(keys, locks)

      # Phase 2: Process leftovers with rainbow-hued wildcards
      process_wildcard_matches(keys, locks)

      print_report

      @rewards
    end

    private

    # Scan all worn containers to find keys and locks.
    #
    # Builds valid pattern lists for all tier+color combinations and searches
    # container contents for matching items.
    #
    # @return [Array<(Array<GameObj>, Array<GameObj>)>] tuple of [keys, locks] arrays
    def find_items
      keys = []
      locks = []

      # Build exact patterns for all valid combinations
      valid_keys = []
      valid_locks = []

      TIERS.each do |tier|
        COLORS.each do |color|
          valid_keys << "#{tier} #{color} key"
          valid_locks << "#{tier} #{color} lock"
        end
        # Add wildcard variants
        valid_keys << "#{tier} #{WILDCARD} key"
        valid_locks << "#{tier} #{WILDCARD} lock"
      end

      # Get containers and ensure contents are populated
      containers = get_containers

      # Scan containers for keys and locks
      containers.each do |container|
        next unless container.contents.is_a?(Array)
        container.contents.each do |item|
          keys.push(item) if valid_keys.include?(item.name)
          locks.push(item) if valid_locks.include?(item.name)
        end
      end

      [keys, locks]
    end

    # Retrieve all worn containers and populate their contents.
    #
    # Issues "inventory containers" command to get container list, then
    # uses "look in" command to populate contents for any containers that
    # haven't been examined yet.
    #
    # @return [Array<GameObj>] array of container GameObjects with populated contents
    def get_containers
      look_in_regex = Regexp.union(
        /^I could not find what you were referring to./,
        /^Surrounded by some swirling mist is /,
        /^In the /,
        /contains (?:DOSE|TINCTURE)s of the following /,
        /There is nothing in there\./,
        /<exposeContainer/,
        /<dialogData/,
        /<container/,
        /you glance/,
        /That is closed\./
      )

      item_regex = %r{<a exist="(?<id>[^"]+)" noun="(?<noun>[^"]+)">(?<name>[^<]+)</a>}

      # Collect all containers from inventory
      waitrt?
      results = Lich::Util.issue_command("inventory containers", /^You are holding /, timeout: 3, silent: true, quiet: true)
      containers = results.flat_map { |line|
        line.scan(item_regex).map { |id, _noun, _name| GameObj[id] }
      }.compact

      # Ensure that container contents is populated by looking in them if not.
      containers.each do |container|
        next if container.contents.is_a?(Array)
        waitrt?
        Lich::Util.issue_command(
          "look in ##{container.id}",
          look_in_regex,
          timeout: 2,
          silent: true,
          quiet: true
        )
      end

      containers
    end

    # Process exact tier and color matches between keys and locks.
    #
    # Only processes non-wildcard combinations, pairing keys with locks of
    # identical tier and color.
    #
    # @param keys [Array<GameObj>] array of available key items
    # @param locks [Array<GameObj>] array of available lock items
    # @return [void]
    def process_exact_matches(keys, locks)
      TIERS.each do |tier|
        # Only process the 4 regular colors, NOT the wildcard
        COLORS.each do |color|
          process_matches(keys, locks, tier, color, tier, color)
        end
      end
    end

    # Process leftover items using rainbow-hued wildcards.
    #
    # Attempts to match remaining colored items with rainbow-hued partners
    # of the same tier. Tries both directions: colored key with rainbow lock,
    # and rainbow key with colored lock.
    #
    # @param keys [Array<GameObj>] array of available key items
    # @param locks [Array<GameObj>] array of available lock items
    # @return [void]
    def process_wildcard_matches(keys, locks)
      TIERS.each do |tier|
        # Try to match leftover colored keys with rainbow locks
        COLORS.each do |color|
          process_matches(keys, locks, tier, color, tier, WILDCARD)
        end

        # Try to match leftover colored locks with rainbow keys
        COLORS.each do |color|
          process_matches(keys, locks, tier, WILDCARD, tier, color)
        end
      end
    end

    # Process matches between keys and locks with specified tier/color criteria.
    #
    # Filters available (unprocessed) keys and locks matching the specified patterns,
    # then pairs them up and unlocks them until one set runs out.
    #
    # @param keys [Array<GameObj>] array of all key items
    # @param locks [Array<GameObj>] array of all lock items
    # @param key_tier [String] tier requirement for keys
    # @param key_color [String] color requirement for keys
    # @param lock_tier [String] tier requirement for locks
    # @param lock_color [String] color requirement for locks
    # @return [void]
    def process_matches(keys, locks, key_tier, key_color, lock_tier, lock_color)
      available_keys = keys.select { |k|
        !@processed_keys.include?(k.id) && matches_pattern?(k.name, key_tier, key_color, :key)
      }

      available_locks = locks.select { |l|
        !@processed_locks.include?(l.id) && matches_pattern?(l.name, lock_tier, lock_color, :lock)
      }

      available_keys.each do |key|
        lock = available_locks.shift
        break unless lock

        # Use the key's tier (they should match anyway)
        unlock_pair(key, lock, key_tier)
      end
    end

    # Check if an item name matches the expected tier/color/type pattern.
    #
    # @param name [String] the item's name to check
    # @param tier [String] expected tier value
    # @param color [String] expected color value
    # @param type [Symbol] expected type (:key or :lock)
    # @return [Boolean] true if the name exactly matches the expected pattern
    def matches_pattern?(name, tier, color, type)
      expected = "#{tier} #{color} #{type}"
      name == expected
    end

    # Unlock and process a key+lock pair, collecting rewards.
    #
    # Gets both items, opens the lock, breaks the resulting baubles,
    # collects rewards, stows everything, and updates tracking data.
    #
    # @param key [GameObj] the key item to use
    # @param lock [GameObj] the lock item to open
    # @param tier [String] the tier level for tracking purposes
    # @return [void]
    def unlock_pair(key, lock, tier)
      fput("get ##{key.id}")
      fput("get ##{lock.id}")
      dothistimeout("open my lock", 3, /^You slowly insert /)

      sleep(0.5) until [GameObj.right_hand.noun, GameObj.left_hand.noun].include?("bauble")
      # Break both baubles
      if [GameObj.right_hand.noun, GameObj.left_hand.noun].include?("bauble")
        fput("break my bauble")
        fput("break my bauble")
        sleep(0.5) until ![GameObj.right_hand.noun, GameObj.left_hand.noun].include?("bauble")

        # Collect rewards and track by tier
        if GameObj.left_hand.id
          @rewards.push(GameObj.left_hand)
          @rewards_by_tier[tier][GameObj.left_hand.name] += 1
        end
        if GameObj.right_hand.id
          @rewards.push(GameObj.right_hand)
          @rewards_by_tier[tier][GameObj.right_hand.name] += 1
        end
      end

      fput("stow all")

      # Mark as processed and track tier
      @processed_keys.push(key.id)
      @processed_locks.push(lock.id)
      @pairs_by_tier[tier] += 1
    end

    # Print a formatted summary report of all processed pairs and rewards.
    #
    # Displays a breakdown by tier showing pairs processed and rewards received,
    # followed by overall totals. Only prints if rewards were collected.
    #
    # @return [void]
    def print_report
      return if @rewards.empty?

      _respond ""
      _respond "=" * 60
      _respond "KeyMaster Rewards Summary"
      _respond "=" * 60

      # Breakdown by tier
      TIERS.each do |tier|
        next if @pairs_by_tier[tier] == 0

        _respond ""
        _respond "#{tier.capitalize} Tier:"
        _respond "  Pairs processed: #{@pairs_by_tier[tier]}"

        if @rewards_by_tier[tier].any?
          _respond "  Rewards:"
          @rewards_by_tier[tier].each do |name, count|
            _respond "    #{name} x#{count}"
          end
        end
      end

      _respond ""
      _respond "-" * 60
      _respond "Total pairs processed: #{@processed_keys.length}"
      _respond "Total rewards: #{@rewards.length}"
      _respond "=" * 60
      _respond ""
    end
  end

  # Execute the KeyMaster processing workflow.
  #
  # Convenience method that creates a new Processor instance and runs it.
  # This is the primary entry point for the module.
  #
  # @return [Array<GameObj>] all reward items collected during processing
  #
  # @example
  #   empty_hands
  #   rewards = KeyMaster.process
  #   fill_hands
  def self.process
    processor = Processor.new
    processor.run
  end
end

# Usage:
empty_hands
KeyMaster.process
fill_hands
