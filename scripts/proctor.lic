=begin
  A utility for editing StringProc objects in the MapDB
  
  Required: Lich 4.3.12
  Tags: core, util, mapdb
  Author: Ondreian


=end

if $SAFE > 0
  echo "error: This script needs to be trusted to work. (;trust #{script.name})"
  exit
end

module Proctor
  require "ostruct"
  ##
  ## minimal options parser
  ##
  module Opts
    FLAG_PREFIX    = "--"
    
    def self.parse_command(h, c)
      h[c.to_sym] = true
    end

    def self.parse_flag(h, f)
      (name, val) = f[2..-1].split("=")
      if val.nil?
        h[name.to_sym] = true
      else
        val = val.split(",")

        h[name.to_sym] = val.size == 1 ? val.first : val
      end
    end

    def self.parse(args = Script.current.vars[1..-1])        
      OpenStruct.new(**args.to_a.reduce(Hash.new) do |opts, v|
        if v.start_with?(FLAG_PREFIX)
          Opts.parse_flag(opts, v)
        else
          Opts.parse_command(opts, v)
        end
        opts
      end)
    end

    def self.method_missing(method, *args)
      parse.send(method, *args)
    end
  end
end

module Proctor
  ##
  ## contextual logging
  ##
  module Log
    def self.bold(msg)
      _respond "<pushBold/>#{msg}<popBold/>"
    end
    
    def self.out(msg, label: :debug)
      #return unless Opts.to_h.fetch(:debug, false)

      if msg.is_a?(Exception)
        msg = %{
          #{msg.message}
          #{msg.backtrace.join("\n")}
        }
      end
      # don't overflow
      if (msg.is_a?(Array))
        msg = msg.take(5).inspect
      end

      _respond _view(msg, label)
    end

    def self._view(msg, label)
      label = [Script.current.name, label].flatten.compact.join(".")
      %{[#{label}] #{msg}}
    end

    def self.pp(msg, label = :debug)
      respond _view(msg, label)
    end

    def self.dump(*args)
      pp *args
    end
  end
end

module Proctor
  module FS
    def self.sanitize(name) 
      name
        .gsub(/^.*(\\|\/)/, '')
        .gsub(/[^0-9A-Za-z.\-]/, '_') # Strip out the non-ascii character
        .gsub(/^_/, "")
        .gsub(/_$/, "")
        .gsub(/_+/, "_").downcase
    end

    def self.file_name(room, wayto_id, sproc, tail = DateTime.now.strftime('%Q'))
      PROC_DIR + %{#{sanitize(room.title.first)}_#{room.id}_#{wayto_id}_#{tail}.rb}
    end

    def self.lookup(room, wayto_id, sproc)
      Dir[file_name(room, wayto_id, sproc, "*")].sort
    end

    def self.compare(room, wayto_id, string_proc)
      current_checksum = Compiler.checksum(string_proc)
      FS.lookup(room, wayto_id, string_proc).each do |file|
        yield(current_checksum, Digest::SHA256.file(file).hexdigest, file)
      end
    end
  end
end

module Proctor
  module Task
    def self.setup()
      return self if File.exist?(PROC_DIR)
      Log.out("creating #{PROC_DIR}", 
        label: %i[setup])
      FileUtils.mkdir_p(PROC_DIR)
      return self
    end
  end
end

module Proctor
  module Compiler
    require 'digest'
    require 'digest/bubblebabble'

    def self.checksum(sproc_or_string)
      sproc_or_string = sproc_or_string._dump if sproc_or_string.is_a?(StringProc)
      Digest::SHA256.hexdigest sproc_or_string.to_s
    end

    def self.expand(sproc)
      fail Exception, %[Compiler#expand does not work on #{sproc.class.name}] unless sproc.is_a?(StringProc)
      StringProc.new sproc._dump.split(";").join("\n")
    end

    def self.compress(sproc)
      fail Exception, %[Compiler#compress does not work on #{sproc.class.name}] unless sproc.is_a?(StringProc)
      StringProc.new sproc._dump.split("\n").join(";")
    end
  end
end

module Proctor
  module Validate
    require 'open3'

    def self.room_and_wayto(room_id, wayto_id)
      room = Room[room_id] or fail Exception, %(could not find Room[#{room_id} in --room])
      string_proc = room.wayto.fetch(wayto_id, false) or fail Exception, %(could not find a wayto #{wayto_id} in Room[#{room_id} from argument --wayto]\n\n#{Room[room_id].wayto})
      fail Exception, %[this wayto is not a StringProc] unless string_proc.is_a?(StringProc)
      [room, string_proc]
    end

    def self.no_duplicates(room, wayto_id, string_proc)
      FS.compare(room, wayto_id, string_proc) do |current_checksum, sibling_checksum, file|
        current_checksum.eql?(sibling_checksum) and
          fail Exception, <<-ERROR
            \n 
            checksum duplicate detected
            
            coords: #{room.title.first}:#{room.id} -> #{Room[wayto_id].title.first}:#{wayto_id} 

            file:

            #{file}
          ERROR
      end
    end

    def self.no_uncommited_changes(room, wayto_id, string_proc)
      FS.compare(room, wayto_id, string_proc) do |current_checksum, sibling_checksum, file|
        current_checksum.eql?(sibling_checksum) or
          fail Exception, <<-ERROR
            \n 
            detected uncommitted changes 
            
            coords: #{room.title.first}:#{room.id} -> #{Room[wayto_id].title.first}:#{wayto_id} 

            file:

            #{file}
          ERROR
      end
    end

    def self.has_uncommited_change(room, wayto_id, string_proc)
      FS.compare(room, wayto_id, string_proc) do |current_checksum, sibling_checksum, file|
        current_checksum.eql?(sibling_checksum) and
          fail Exception, <<-ERROR
            \n 
            no uncommited changes detected 
            
            coords: #{room.title.first}:#{room.id} -> #{Room[wayto_id].title.first}:#{wayto_id} 

            file:

            #{file}
          ERROR
      end
    end

    def self.verify_syntax(file)
      (stdin, stdout, stderr) = Open3.popen3(%[ruby -c #{file}])
      stdin.close
      result = stdout.read
      stdout.close
      return [:ok, result] if result.strip.eql?(%[Syntax OK])
      err = stderr.read
      stderr.close
      return [:err, err]
    end
  end
end

module Proctor
  module Filter
    def self.is_string_proc?
      -> t { t.is_a?(StringProc) }
    end

    def self.has_wayto_string_proc?
      -> room { room.wayto.values.any?(&Filter.is_string_proc?) }
    end
  end
end

module Proctor
  module To
    def self.room
      -> id { Room[id] }
    end

    def self.string_proc_array
      -> sproc { sproc._dump.split(";") }
    end
  end
end 

module Proctor
  module CLI
    def self.index()
      Proctor.rooms_with_string_procs
      .take(Opts.index.is_a?(TrueClass) ? 5 : Opts.index.to_i)
      .each do |room|
        room.wayto.select do |_, way| way.is_a?(StringProc) end
        .each do |id, sproc| 
          label =  %i[index id] + [room.id]
          Log.out((["-"] * 50).join, 
            label: label)
          Log.out("<b>#{room.title.first}:#{room.id} to #{Room[id].title.first}:#{id}</b>",
            label: label)
          To.string_proc_array.(sproc).each do |line|
            Log.out(line, 
              label: label)
          end
        end
      end
    end

    def self.edit(room_id, wayto_id)
      (room, string_proc) = Validate.room_and_wayto(room_id, wayto_id)
      out = FS.file_name(room, wayto_id, string_proc)
      pretty_string_proc = Compiler.expand(string_proc)._dump
      Validate.no_duplicates(room, wayto_id, string_proc)
      Validate.no_uncommited_changes(room, wayto_id, string_proc)
      File.open(out, "w") do |f| f.write(pretty_string_proc) end
      Log.out("wrote StringProc to #{out}", 
        label: %i[edit])
    end

    def self.commit(room_id, wayto_id)
      room = Room[room_id]
      # for fresh changes we need a common fallback
      # so we don't need to litter our code with Maybe type
      string_proc = room.wayto.fetch(wayto_id, NOOP_STRING_PROC)
      Validate.has_uncommited_change(room, wayto_id, string_proc)
      candidates = FS.lookup(room, wayto_id, string_proc)
      candidates.size.eql?(1) or fail Exception, %[multiple unstaged commits for this coord, keep only one]
      commit = candidates.first
      (outcome, message) = Validate.verify_syntax(commit)

      if outcome.eql?(:err)
        Log.out("<b>refusing to commit</b>", label: %i[error fatal])
        return Log.out("ERROR:\n\n#{message}", label: %i[error fatal])
      end

      Log.out(commit, label: %i[compile], label: %i[commit])
      code = File.read(commit)
      minified = Compiler.compress(
        StringProc.new(code))
        
      room.wayto[wayto_id] = minified
      Log.out(Room[room.id].wayto[wayto_id]._dump, label: %i[string_proc])
    end

    def self.help()
      _respond <<-HELP
        <b>proctor</b>

        proctor is a tool for editing and maintaining StringProc objects in the MapDB

        commands:
          edit --room={room_id} --wayto={wayto_id}   dump the StringProc at Room[room_id].wayto[wayto_id] to string_procs/
      HELP
    end
  end
end

module Proctor
  require "pathname"
  require "fileutils"

  PROC_DIR = Pathname.new($lich_dir) + %[string_procs]
  NOOP_STRING_PROC = StringProc.new("")

  def self.rooms_with_string_procs()
    Room.list.select(&Filter.has_wayto_string_proc?)
  end

  def self.sort_by_distance(from: Room.current, rooms: [])
    target_list = rooms.map(&:to_i)
    Log.out(target_list.size)
    previous, shortest_distances = Map.dijkstra(from.id, target_list)
    target_list.delete_if { |room_num| shortest_distances[room_num].nil? }
    Log.out(target_list.size)
    target_list.sort { |a,b| shortest_distances[a] <=> shortest_distances[b] }.map(&To.room)
  end

  def self.main()
    return CLI.index() if Opts.index
    return CLI.edit(Opts.room, Opts.wayto) if Opts.edit
    return CLI.commit(Opts.room, Opts.wayto) if Opts.commit
    return CLI.help()
  end

  Task.setup() unless Opts.help
  Proctor.main()
end