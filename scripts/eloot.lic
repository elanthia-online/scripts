# frozen_string_literal: true

=begin
  eloot.lic: eLoot is fork/update/rewrite of sloot.

  Some primary changes from sloot include using in-game STOW settings instead of variables.
  Locksmith pool handling, loot room, exclusion support, appraise limits.
  eloot also auto-writes settings to your Lich5/Data/eloot folder per character.

   original author: SpiffyJr (sloot)
        maintainer: elanthia-online
      contributors: SpiffyJr, Athias, Demandred, Tysong, Deysh, Ondreian
              game: Gemstone
              tags: loot
           version: 1.5.32
  Improvements:
  v1.5.32 (2023-05-12)
    - reworked method for cursed items to support eonake gauntlets
=end
=begin
  v1.5.31 (2023-04-12)
    - bugfix for never loot section not working correctly with regex
  v1.5.30 (2023-04-07)
    - split drag method to wear and drag and added RT check for wearing containers after bulk sell.
  v1.5.29 (2023-04-04)
    - added regex for pirate harnesses
  v1.5.28 (2023-03-30)
    - bugfix for trashcans
  v1.5.27 (2023-03-30)
    - additional find_trash method changes to utilize meta:trashcan
  v1.5.26 (2023-03-30)
    - added "wastebin" to list of trashcans
  v1.5.25 (2023-03-25)
    - another try at finding the trashcan
  v1.5.24 (2023-03-23)
    - added additional trashcan identification if no room description available
  v1.5.23 (2023-03-22)
    - added open regex for container
  v1.5.22 (2023-03-08)
    - bugfix for updating setting on nil for Ruby v3
  v1.5.21 (2023-03-06)
    - bugfix for bag_loot method
  v1.5.20 (2023-02-25)
    - bugfix for scroll selling in setup
  v1.5.19 (2023-02-22)
    - added toggle for unlootable tracking
  v1.5.18 (2023-02-07)
    - added additional error checking for autoclose bags
  v1.5.17 (2023-02-01)
    - added support for Assume Aspect - Lion (650)
  v1.5.16 (2023-01-31)
    - added child to unlootable list
  v1.5.15 (2023-01-30)
    - bug fix for wait_for_disk method
  v1.5.14 (2023-01-22)
    - added support for plinite looting
  v1.5.13 (2023-01-22)
    - add RT check to retrieving weapon/shield after looting
    - added support to not sell alchemy items: ;eloot sell alchemy_mode
  v1.5.12 (2023-01-17)
    - add check to prevent trying to loot something that's not yours
  v1.5.11 (2023-01-13)
    - add extra output to eloot test (disk and full containers)

  v1.5.10 (2022-12-23)
    - fixed location bug for locksmithing in KF

  v1.5.9 (2022-12-05)
    - added unlootable list to the UI (bottom of loot tab)
    - bugfix for trying to put loot in full container

  v1.5.8 (2022-12-05)
    - added word boundary checks for container setup
    - bug fix for phased box's

  v1.5.7 (2022-11-27)
    - removed custom quiet command to use Lich command instead
    - fixed bug if encumbered at the locksmith and can't get the box out of the disk
    - fixed bug for ice elemental looting

  v1.5.6 (2022-11-11)
    - added an "Always Loot" list
    - added support for auto closing bags
    - bug fix for handling reliquaries
    - bug fix for skinning without a designated skinning tool

  v1.5.5 (2022-11-03)
    -bugfix for unlootable tracking

  v1.5.4 (2022-11-01)
    - bugfix for silver totals

  v1.5.3 (2022-10-31)
    - added check for unlootable items

  v1.5.2 (2022-10-29)
    - added muck and cloud to unlootable list

  v1.5.1 (2022-10-28)
    - bugfix for terminal-table silver breakdown

  v1.5.0 (2022-10-09)
    - removed dependancy on separate UI file and associated code
    - cleaned up inventory & looting logic
    - added support to always check the locksmith pool
    - fixed bug that was looting cursed items in boxes
    - added validation check for setup
    - silver summary at end of selling using terminal-table
    - archived change log before 1.4.0
    - adds CLI interface to update settings

  v1.4.22 (2022-09-25)
    - bug fix for cursed items in boxes

  v1.4.21 (2022-09-23)
    - added support for hidden skin sheathes
    - bug fix for crumbly bandit bandanas
    - locksmith pool functionality added: over encumbered coin deposit and box drop off only option
    - fixed bug in track_full_sacks default setting
    - fixed bug when trying to do initial load when in RT
    - added small delay to ;eloot start

  v1.4.20
    - bug fix for cursed items and some crumbly ones

  v1.4.19
    - fixed looting logic when its flagged as two items with one not wanted (eg. uncommon & clothing). It will pick up the item to prevent valuable items getting left behind
    - additional error checking for empty box's in containers
    - additional error checking for looting
    - added support to use left hand for looting
    - added support for users who don't sell with eloot (full container tracking)
    - added secondary overflow container
    - moved UI check only when loading or setup

  v1.4.18
    - followup typo fix for default crumbly list

  v1.4.17
    - add rough leather quiver to the default crumbly items

  v1.4.16 (2022-08-23)
    - fixed typo in overflow setting

  v1.4.15 (2022-08-23)
    - changed regex for scabbards again

  v1.4.14 (2022-08-19)
    - will sell bounty items in original town if selling in FWI
    - added regex for custom scabbard
    - reworked data loading, should be faster now
    - changed the container indentification to skip non-worn containers (helps with getting the correct skinning sheath)

  v1.4.13
    - empty gold, silver, mithril boxes if selling them
    - fixed trying to loot gangplank
    - fix for stancing with verbose turned on

  v1.4.12
    - fixed duplicate container saving
    - fixed bug in box looting that wasn't recognizing box found armor/weapons

  v1.4.11 (2022-08-02)
    - added support for looting coins on the ground

  v1.4.10 (2022-07-28)
    - more edits for locksmithpool not recognizing worker

  v1.4.9 (2022-07-28)
    - another edit to the locksmith pool

  v1.4.8 (2022-07-20)
    - close sacks function had a bug preventing it from working
    - additional changes for the load delay in locksmith pool

  v1.4.7 (2022-07-09)
    - fix for object load delay in locksmith pool

  v1.4.6 (2022-07-09)
    - added option to deposit coins/notes without sell routine
    - fixed bug in empty box selling causing it to duplicate

  v1.4.5
    - performance improvement in selling and storing items
    - added logic to address having a box in hand at start of sell routine.
    - added support to loot a box in hand then exit - ;eloot box

  v1.4.4
    - added skin matching for alchemically ruined skins

  v1.4.3
    - added support for skinning rotting chimera's when they have scorpion tails

  v1.4.2 (2022-06-15)
    - bug fix in blunt skinning

  v1.4.1 (2022-06-15)
    - bug fix for disks

  v1.4.0 (2022-06-10)
    - added support for shroud and glamour
    - added check in valid loot routine to exclude disks

=end

require 'yaml'

begin
  require 'terminal-table'
rescue LoadError
  # not defined.
  # use defined?(Terminal)
  # for checking of load
end

# eloot is a looter for Gemstone that focuses on performance
module ELoot
  ELoot_version = '1.5.32'

  @@data ||= nil

  ##### Data & Setup Start #####

  def self.version_check
    # Check version of Lich for compatibility
    lich_gem_requires = '5.4.1'
    infomon_gem_requires = '1.18.11'
    infomon_version = '0.0.0'
    infomon_data = File.open("#{SCRIPT_DIR}/infomon.lic", 'r').read
    if infomon_data =~ /^=begin\r?\n?(.+?)^=end/m
      comments = $1.split("\n")
    else
      comments = []
      infomon_data.split("\n").each { |line|
        if line =~ /^[\t\s]*#/
          comments.push(line)
        elsif line !~ /^[\t\s]*$/
          break
        end
      }
    end
    for line in comments
      if line =~ /^[\s\t#]*version:[\s\t]*([\w,\s\.\d]+)/i
        infomon_version = $1.sub(/\s\(.*?\)/, '').strip
      end
    end

    if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires) || Gem::Version.new(infomon_version) < Gem::Version.new(infomon_gem_requires)
      if $frontend == 'stormfront' || $frontend == 'profanity'
        _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
        _respond "\<preset id=\"thought\"\>" + "Script: #{Script.self} now requires a newer version of Lich(#{lich_gem_requires}+) & Infomon (#{infomon_gem_requires}) to run." + "\<\/preset\>"
        _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
        _respond ""
        _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
        _respond "\<preset id=\"thought\"\>" + "Currently Running Infomon Version: #{Gem::Version.new(infomon_version)}" + "\<\/preset\>"
        _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
        _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
      else
        _respond "##" + "########################################"
        _respond ">" + "Script: #{Script.name} now requires a newer version of Lich(#{lich_gem_requires}+) & Infomon (#{infomon_gem_requires}) to run."
        _respond ">" + "Please update to a newer version."
        _respond ">" + ""
        _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
        _respond ">" + "Currently Running Infomon Version: #{Gem::Version.new(infomon_version)}"
        _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
        _respond "##" + "########################################"
      end
      exit
    end
  end

  def self.launch_settings_ui
    Setup.new(data.settings).start
    ELoot.load(load_profile)
    set_inventory
  end

  def self.load_defaults()
    default_hash = {
      :loot_types                      => ["alchemy", "armor", "box", "clothing", "collectible", "food", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
      :loot_exclude                    => ["black ora", "urglaes"],
      :loot_phase                      => false,
      :use_disk                        => true,
      :loot_defensive                  => false,
      :coin_hand                       => false,
      :coin_hand_name                  => "",
      :overflow_container              => "",
      :secondary_overflow              => "",
      :sell_loot_types                 => ["alchemy", "armor", "clothing", "food", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand", "box"],
      :sell_container                  => ["default", "overflow", "box", "collectible", "forageable", "gem", "herb", "lockpick", "potion", "reagent", "scroll", "skin", "treasure", "trinket", "wand"],
      :sell_exclude                    => [],
      :sell_keep_scrolls               => [],
      :sell_appraise_types             => ["jewelry", "magic", "uncommon", "valuable"],
      :sell_appraise_gemshop           => 14999,
      :sell_appraise_pawnshop          => 34999,
      :sell_collectibles               => true,
      :sell_gold_rings                 => false,
      :sell_locksmith                  => false,
      :sell_locksmith_pool             => true,
      :always_check_pool               => false,
      :display_box_contents            => false,
      :sell_locksmith_pool_tip         => 15,
      :sell_locksmith_pool_tip_percent => true,
      :sell_share_silvers              => false,
      :sell_fwi                        => false,
      :sell_shroud                     => false,
      :sell_aspect                     => false,
      :sell_keep_silver                => 0,
      :skin_enable                     => false,
      :skin_kneel                      => false,
      :skin_604                        => false,
      :skin_resolve                    => false,
      :skin_sheath                     => "",
      :skin_weapon                     => "",
      :skin_sheath_blunt               => "",
      :skin_weapon_blunt               => "",
      :silence                         => true,
      :debug                           => false,
      :unskinnable                     => [],
      :unlootable                      => [],
      :auto_close                      => [],
      :crumbly                         => [],
      :keep_closed                     => false,
      :track_full_sacks                => true,
      :favor_left                      => false,
      :log_unlootables                 => false
    }

    Dir.mkdir("#{$data_dir}#{XMLData.game}") unless File.exist?("#{$data_dir}#{XMLData.game}")
    Dir.mkdir("#{$data_dir}#{XMLData.game}/#{Char.name}") unless File.exist?("#{$data_dir}#{XMLData.game}/#{Char.name}")

    File.write("#{$data_dir}#{XMLData.game}/#{Char.name}/eloot.yaml", default_hash.to_yaml)

    default_hash
  end

  def self.load_profile(name: Char.name)
    if name != nil
      filename = "#{$data_dir}#{XMLData.game}/#{name}/eloot.yaml"
      if File.exist?("#{filename}") && name == Char.name
        settings_hash = YAML.load_file(filename)
      elsif !File.exist?("#{filename}") && name != Char.name
        ELoot.msg("error", " ELoot.load_profile: Attempt to load a profile that does not exist.")
      elsif !File.exist?("#{filename}") && name == Char.name
        ELoot.msg("info", " No current settings found.  Loading defaults...")
        settings_hash = ELoot.load_defaults()
      else
        ELoot.msg("error", " ELoot.load_profile: There was an unknown error with loading a profile")
      end
    else
      ELoot.msg("error", " ELoot.load_profile: name not defined")
    end

    settings_hash
  end

  def self.save_profile(name: Char.name)
    # This adds it to the profile for backward compatability
    ELoot.data.settings[:display_box_contents] = false unless ELoot.data.settings.has_key?(:display_box_contents)
    ELoot.data.settings[:use_disk] = true unless ELoot.data.settings.has_key?(:use_disk)
    ELoot.data.settings[:keep_closed] = false unless ELoot.data.settings.has_key?(:keep_closed)
    ELoot.data.settings[:track_full_sacks] = true unless ELoot.data.settings.has_key?(:track_full_sacks)
    ELoot.data.settings[:favor_left] = false unless ELoot.data.settings.has_key?(:favor_left)

    # Remove overflow container name from settings. We don't need to save it
    default_settings = ["default", "overflow", "box", "collectible", "forageable", "gem", "herb", "lockpick", "potion", "reagent", "scroll", "skin", "treasure", "trinket", "wand"]

    ELoot.data.settings[:sell_container].each { |container|
      ELoot.data.settings[:sell_container].delete(container) unless default_settings.include?(container)
    }

    if name != nil
      filename = "#{$data_dir}#{XMLData.game}/#{Char.name}/eloot.yaml"
      if name == Char.name
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg("info", " Settings saved to file: #{filename}.")
      elsif File.exist?("#{filename}") && name != Char.name
        ELoot.msg("info", " You are attempt to overwrite another profile!")
        ELoot.msg("info", " If you wish to overwrite, please ;unpause eloot.")
        ELoot.msg("info", " Else ;kill eloot and choose another filename.")
        pause_script
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg("info", " Settings saved to file: #{filename}.")
      elsif !File.exist?("#{filename}") && name != Char.name
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg("info", " Settings are being saved to another profile!")
        ELoot.msg("info", " Settings saved to file: #{filename}.")
      else
        ELoot.msg("error", " ELoot.save_profile: There was an unknown error with saving a profile")
      end
    end
  end

  def self.load(settings)
    @@data = Data.new(settings)
  end

  def self.data
    @@data
  end

  def self.update_setting(input)
    setting_to_update = normalize_setting_name(input.first)
    ELoot.msg("debug", "Normalized #{input.first} as #{setting_to_update}")

    if ELoot.data.settings.keys.include?(setting_to_update)
      default_value = ELoot.data.settings[setting_to_update].dup
      ELoot.msg("debug", "recognized #{setting_to_update} as as valid #{default_value.class} setting")
      new_value = coerce_setting_value(setting_to_update, default_value, input[1..-1])
      ELoot.msg("debug", "Normalized #{input[1..-1]} as #{new_value.inspect}")

      data.settings[setting_to_update] = new_value
      ELoot.msg("info", " Updated #{setting_to_update} to #{new_value}")
      ELoot.save_profile()
    else
      ELoot.msg("error", " #{setting_to_update} is not a recognized setting. Recognized setting names:")
      ELoot.msg("error", ELoot.data.settings.keys.sort.join("\n"))
    end
  end

  def self.coerce_setting_value(setting_name, default, input)
    case default
    when TrueClass, FalseClass
      fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
      fix_option.fetch(input[0]) do |v|
        ELoot.msg("error", %{Expected a boolean (true/false/yes/no) value for "#{setting_name} but got "#{v}"})
        exit
      end
    when Array
      input
    when Integer
      v = input[0]
      if v =~ /\A[+-]?\d+\z/
        v.to_i
      else
        ELoot.msg("error", %{Expected an integer value for #{setting_name} value but got "#{v}"})
        exit
      end
    when String
      input.join(" ")
    else
      ELoot.msg("error", "Recognized #{setting_name} but don't know how to normalize a #{default.class} type setting")
      exit
    end
  end

  def self.normalize_setting_name(input)
    input.downcase.tr('-', '_').to_sym
  end

  def self.issue_command(command, start_pattern, loud = true, end_pattern = /<prompt/, include_end = false, timeout = 5)
    result = []
    name = "Sell:: -#{Time.now.tv_sec}.#{Time.now.tv_usec}-#{Random.rand(10000)}"
    filter = false
    save_want_downstream = Script.current.want_downstream
    save_want_downstream_xml = Script.current.want_downstream_xml
    Script.current.want_downstream = false
    Script.current.want_downstream_xml = true

    begin
      Timeout::timeout(timeout, Interrupt) {
        DownstreamHook.add(name, proc { |xml|
          is_loud = loud ? xml : nil
          if filter
            if xml =~ end_pattern
              DownstreamHook.remove(name)
              filter = false
            else
              next(is_loud)
            end
          elsif xml =~ start_pattern
            filter = true
            next(is_loud)
          else
            # echo "xml: #{xml}"
            # xml
            next(is_loud)
          end
        })
        if loud
          fput command
        else
          $_SERVER_.puts command
        end
        until (xml = get) =~ start_pattern; end
        result << xml.rstrip
        until (xml = get) =~ end_pattern
          result << xml.rstrip
        end
        if include_end
          result << xml.rstrip
        end
      }
    rescue Interrupt
      nil
    ensure
      DownstreamHook.remove(name)
      Script.current.want_downstream_xml = save_want_downstream_xml
      Script.current.want_downstream = save_want_downstream
    end
    #  echo result
    return result
  end

  def self.get_command(command, regex)
    lines = []
    regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

    loop {
      lines = ELoot.issue_command(command, regex)
      ELoot.msg("debug", " get_lines: command: #{command} | lines - #{lines}")
      if lines.any? { |l| l =~ /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i }
        waitrt?
        next
      else
        break
      end
    }

    return lines
  end

  def self.get_lines(command, regex)
    lines = []
    regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

    loop do
      lines = Lich::Util.quiet_command_xml(command, regex)
      ELoot.msg("debug", " get_lines: command: #{command} | lines - #{lines}")
      break unless lines.grep(/(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

      ELoot.wait_rt
    end

    return lines
  end

  def self.get_res(command, regex = nil)
    rt_regex = /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./
    regex = regex.nil? ? Regexp.union(/.*?/, rt_regex) : Regexp.union(regex, rt_regex)
    result = nil
    loop do
      result = dothistimeout(command, 3, regex)
      break unless result =~ rt_regex

      ELoot.wait_rt
    end

    return result
  end

  def self.sell
    Sell.sell
  end

  def self.set_inventory
    waitrt?

    # Find the Containers we need: stow, overflow, skin sheathes, ready sheathes
    # Finding the Stow list
    container_match = /<a exist="([^"]+)" noun="[^"]+">[^(.]+\(([a-z]+)\)/
    loop {
      container_lines = ELoot.get_lines("stow list", /<output class="mono"\/>/)

      container_lines.each { |line|
        if line =~ container_match
          ELoot.data.sacks.store(Regexp.last_match(2), GameObj.inv.find { |i| i.id == Regexp.last_match(1) })
          ELoot.data.sacks.delete(Regexp.last_match(2)) unless ELoot.data.sacks[Regexp.last_match(2)]
        end
      }

      if container_lines.any? { |l| l =~ /(none)/ }
        ELoot.msg("error", " No containers are set. Please see the ingame 'stow' command")
        exit
      elsif !container_lines.any? { |l| l =~ /default/ }
        ELoot.msg("error", " Set stow container using STOW SET before using this script")
        exit
      elsif !container_lines.any? { |l| l =~ /You have the following containers set as stow targets/ }
        ELoot.msg("info", " Stow containers didn't load right. Trying again!")
        next
      else
        break
      end
    }

    # Add the overflow sacks
    ELoot.data.sacks.store(ELoot.data.settings[:overflow_container].to_s, GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:overflow_container]}\b/i })
    ELoot.data.sacks.store(ELoot.data.settings[:secondary_overflow].to_s, GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:secondary_overflow]}\b/i })
    ELoot.data.sacks.delete("")

    ELoot.data.settings[:sell_container].push(ELoot.data.settings[:overflow_container].to_s) if ELoot.data.settings[:sell_container].include?("overflow")
    ELoot.data.settings[:sell_container].push(ELoot.data.settings[:secondary_overflow].to_s) if ELoot.data.settings[:sell_container].include?("overflow")
    ELoot.data.settings[:sell_container].delete("")

    # Add the skin sheathes if set
    ELoot.data.ready_list.store("skin_sheath", GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:skin_sheath]}\b/i if !ELoot.data.settings[:skin_sheath].empty? && !ELoot.data.settings[:skin_sheath].nil? })
    ELoot.msg("debug", " ELoot.data.ready_list['skin_sheath']: #{ELoot.data.ready_list['skin_sheath']}")

    # Is it hidden?
    if !ELoot.data.settings[:skin_sheath].empty? && !ELoot.data.settings[:skin_sheath].nil? && ELoot.data.ready_list["skin_sheath"].nil?
      ELoot.msg("debug", " ELoot.data.ready_list['skin_sheath'] not found but in setup")
      lines = Lich::Util.quiet_command_xml("pull my sheath", /You reach down|I'm afraid that/)
      ELoot.msg("debug", " Is sheath hidden? : #{lines}")
      if lines.any? { |line| line =~ /You reach down/i }
        Lich::Util.quiet_command_xml("inventory full", /You are (holding|wearing)/)
        ELoot.msg("debug", " If it was hidden did the GameObj populate? : #{GameObj.inv}")
        ELoot.data.ready_list.store("skin_sheath", GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:skin_sheath]}\b/i if !ELoot.data.settings[:skin_sheath].empty? && !ELoot.data.settings[:skin_sheath].nil? })
        Lich::Util.quiet_command_xml("push my #{ELoot.data.settings[:skin_sheath]}", /You reach down|I'm afraid that you can't pull that/)
      end

    end

    ELoot.data.ready_list.store("skin_sheath_blunt", GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:skin_sheath_blunt]}\b/i if !ELoot.data.settings[:skin_sheath_blunt].empty? && !ELoot.data.settings[:skin_sheath_blunt].nil? })
    ELoot.data.ready_list.delete("")

    # Finding the ready list sheathes
    sheath_list_match = /(?:sheath|secondary sheath):\s+<d\scmd="store\s(\w+)\sclear">[^<]+<a\sexist="(\d+)"\snoun="[^"]+">([^<]+)<\/a>(?:\s[^<]+)?<\/d>/

    ready_lines = []
    loop {
      ready_lines = ELoot.get_lines("ready list", /<output class="mono"\/>/)

      if !ready_lines.any? { |l| l =~ /Your current settings are/ }
        ELoot.msg("info", " Ready List didn't load right. Trying again!")
        next
      else
        break
      end
    }
    ready_lines.each { |line|
      if line =~ sheath_list_match
        ELoot.data.ready_list.store(Regexp.last_match(1).to_s.downcase, GameObj.inv.find { |i| i.id == Regexp.last_match(2) })
      end
    }

    # Open the bags so we have the contents
    all_bags = ELoot.data.sacks.merge(ELoot.data.ready_list)
    items_opened = Array.new

    all_bags.each { |_k, item|
      next if items_opened.include?(item)

      items_opened.push(item)
      Inventory.open_single_container(item)
    }

    # Lets grab the inventory
    items = []
    exist = %r{<a exist=(?:'|")(?<id>.*?)(?:'|") noun=(?:'|")(?<noun>.*?)(?:'|")>(?<name>.*?)</a>}

    lines = ELoot.get_lines("inventory full", /<streamWindow/)

    lines.each do |line| line.scan(exist).each do |matches| items << GameObj.new(*matches) unless items.any? { |i| i.id =~ /#{matches[0]}/ } end end

    # Make sure to include what's in our hands
    items << GameObj.right_hand if checkright
    items << GameObj.left_hand if checkleft

    # Finding the ready list items
    ready_list_match = /(?:shield|weapon|secondary weapon|ranged weapon):\s+<d\scmd="store\s(\w+)\sclear">[^<]+<a\sexist="(\d+)"\snoun="[^"]+">([^<]+)<\/a>(?:\s[^<]+)?<\/d>\s+\(<d\scmd='store set'>([^<]+)<\/d>\)/
    ready_lines.each { |line|
      if line =~ ready_list_match
        ELoot.data.ready_list.store(Regexp.last_match(1).to_s.downcase, items.find { |i| i.id == Regexp.last_match(2) })
        ELoot.data.ready_method.store(Regexp.last_match(1).to_s.downcase, Regexp.last_match(4))
      end
    }

    # Finding the bladed skinner - check sheath first
    unless ELoot.data.ready_list["skin_sheath"].nil?
      # Lets see if the edged skin weapon is in the sheath
      ELoot.msg("debug", " ELoot.data.ready_list['skin_sheath'].contents: #{ELoot.data.ready_list['skin_sheath'].contents}")
      unless ELoot.data.settings[:skin_weapon].empty?
        ELoot.data.skin_edged = ELoot.data.ready_list["skin_sheath"].contents.find { |i| i.name =~ /\b#{ELoot.data.settings[:skin_weapon]}\b/i }
        ELoot.msg("debug", " ELoot.data.skin_edged: #{ELoot.data.skin_edged}")
      end
    end

    # Finding the blunt skinner - check sheath first
    unless ELoot.data.ready_list["skin_sheath_blunt"].nil?
      # Lets see if the blunt skin weapon is in the blunt sheath
      ELoot.msg("debug", " ELoot.data.ready_list['skin_sheath_blunt'].contents: #{ELoot.data.ready_list['skin_sheath_blunt'].contents}")
      unless ELoot.data.settings[:skin_weapon_blunt].empty?
        ELoot.data.skin_blunt = ELoot.data.ready_list["skin_sheath_blunt"].contents.find { |i| i.name =~ /\b#{ELoot.data.settings[:skin_weapon_blunt]}\b/i }
      end
    end

    # If not in the sheath maybe its someplace else
    if (ELoot.data.skin_edged.nil? && !ELoot.data.settings[:skin_weapon].empty?) || (ELoot.data.skin_blunt.nil? && !ELoot.data.settings[:skin_weapon_blunt].empty?)
      if ELoot.data.skin_edged.nil?
        ELoot.data.skin_edged = items.find { |i| i.type =~ /weapon/i && i.name =~ /\b#{ELoot.data.settings[:skin_weapon]}\b/i }
      end

      if ELoot.data.skin_blunt.nil?
        ELoot.data.skin_blunt = items.find { |i| i.type =~ /weapon/i && i.name =~ /\b#{ELoot.data.settings[:skin_weapon_blunt]}\b/i }
      end
    end

    # Are we using a coin hand?
    if ELoot.data.settings[:coin_hand] && (ELoot.data.settings[:coin_hand_name].empty? || ELoot.data.settings[:coin_hand_name].nil?)
      ELoot.msg("warn", " Use Coin Hand is checked but no name given! Eloot can't use the coin hand.")
    elsif !ELoot.data.settings[:coin_hand] && ELoot.data.settings[:coin_hand_name].length.positive?
      ELoot.msg("warn", " Use Coin Hand is NOT checked but a name is given! Eloot can't use the coin hand.")
    elsif ELoot.data.settings[:coin_hand] && !ELoot.data.settings[:coin_hand_name].empty? && !ELoot.data.settings[:coin_hand_name].nil?
      # #Are we wearing the coin hand?
      ELoot.data.coin_hand = GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:coin_hand_name]}\b/i }
      unless ELoot.data.coin_hand
        # Guess not so loop thru inv and see if we can find it
        GameObj.inv.each { |item|
          if !items_opened.include?(item)
            Inventory.open_single_container(item)
          end
          ELoot.data.coin_hand = item.contents.find { |thing| thing.name =~ /\b#{ELoot.data.settings[:coin_hand_name]}\b/i }
          if ELoot.data.coin_hand
            ELoot.data.coin_container = item
            break
          end
        }
      end
    end

    if ELoot.data.settings[:coin_hand] && ELoot.data.coin_hand.nil? && !ELoot.data.settings[:coin_hand_name].empty?
      ELoot.msg("warn", " Use Coin Hand is checked but can't find the coin hand! Eloot can't use the coin hand.")
    end

    # Using a disk?
    ELoot.disk_usage

    # If ELoot.data.settings[:keep_closed] close anything we opened
    Inventory.close_sell_containers

    ELoot.validate_setup
  end

  def self.manage_sorter
    if running? "sorter"
      kill_script("sorter")
      before_dying { Script.start('sorter') }
    end
  end

  def self.disk_usage
    return if DownstreamHook.list.include?("eloot-disk") && ELoot.data.settings[:use_disk]

    if ELoot.data.settings[:use_disk]
      15.times do
        break if (ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} (?:disk|coffin)$/ })

        sleep(0.1)
      end

      DownstreamHook.add('eloot-disk',
                         proc do |line|
                           if line =~ /^Your <a exist="(\d+)" noun="(disk|coffin)">(disk|coffin)<\/a> arrives|^A small circular container suddenly appears/
                             ELoot.data.disk_full = false if ELoot.data.disk.nil?
                             ELoot.data.disk = GameObj.loot.find { |obj| obj.id == Regexp.last_match(1).to_s }
                           end
                           line
                         end)
    else
      ELoot.data.disk = nil
      DownstreamHook.remove("eloot-disk")
    end
  end

  def self.msg(type = "info", text)
    # color options - set type to use
    # yellow, orange, teal, green, plain

    return if type == "debug" && !ELoot.data.settings[:debug]

    if text.class == Hash
      text = text.inspect.gsub("#<", "#")
    elsif text.class == Array
      text = text.to_s
    elsif text.class == String
      text = text.gsub("#<", "#")
    end

    type = type == "debug" ? "speech" : type

    Lich::Messaging.msg(type, text)
  end

  def self.fwi?(room)
    (room.location =~ /Four Winds|Mist Harbor|Western Harbor/)
  end

  def self.test
    echo " Eloot Version: #{ELoot_version}"
    echo ""
    echo "--------------- Settings ---------------"
    echo(*ELoot.data.settings)
    echo ""
    echo "--------------- Sacks ------------------"
    echo(*ELoot.data.sacks)
    echo ""
    echo "--------------- Disk -------------------"
    echo ELoot.data.disk.inspect
    echo ""
    echo "--------------- Full Disk/Sack Check ---"
    echo "Disk Full: #{ELoot.data.disk_full.inspect}"
    echo "Sacks Full: #{ELoot.data.sacks_full.inspect}"
    echo ""
    echo "--------------- Contents ---------------"

    items_opened = Array.new
    ELoot.data.sacks.keys.each { |item|
      next if items_opened.include?(ELoot.data.sacks[item].id)

      items_opened.push(ELoot.data.sacks[item].id)
      Inventory.open_single_container(ELoot.data.sacks[item])
      ELoot.data.sacks[item].contents.each { |thing|
        echo "Container: #{ELoot.data.sacks[item]} | Item: #{thing.name} | Type: #{thing.type} | Sellable: #{thing.sellable}"
      }
    }

    echo ""
    echo "--------------- Ready List -------------"

    ELoot.data.ready_list.each { |item|
      echo item
    }

    echo ""
    echo "--------------- Skinning Weapons -------------"

    echo "Edged Skinner: #{ELoot.data.skin_edged.inspect}"
    echo "Blunt Skinner: #{ELoot.data.skin_blunt.inspect}"

    echo ""
    echo "--------------- Coin Hand -------------"

    echo "Coin Hand: #{ELoot.data.coin_hand.inspect}"
    echo "Coin Container: #{ELoot.data.coin_container.inspect}"

    echo "--------------GameObj Types-------------"
    echo GameObj.type_data.map { |k, _v| k }.sort.join(', ')
  end

  def self.validate_setup
    # Checks:
    # Sacks
    # Overflow Primary
    # Overflow Secondary
    # Bladed Skinning Sheath
    # Blunt Skinning Sheath
    # Bladed Skinner
    # Blunt Skinner
    # Coin Hand

    # Checks:
    # Sacks
    # Overflow Primary
    # Overflow Secondary
    # Bladed Skinning Sheath
    # Blunt Skinning Sheath
    # Bladed Skinner
    # Blunt Skinner

    valid_setup = true

    if ELoot.data.sacks.nil?
      ELoot.msg("error", " Unable to find your stow sacks.")
      valid_setup = false
    end

    if ELoot.data.settings[:overflow_container].length.positive? && ELoot.data.sacks[ELoot.data.settings[:overflow_container]].nil?
      ELoot.msg("error", " Unable to find your primary overflow container.")
      valid_setup = false
    end

    if ELoot.data.settings[:secondary_overflow].length.positive? && ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]].nil?
      ELoot.msg("error", " Unable to find your secondary overflow container.")
      valid_setup = false
    end

    if ELoot.data.settings[:skin_sheath].length.positive? && !ELoot.data.ready_list["skin_sheath"]
      ELoot.msg("error", " Unable to find your bladed skinning sheath.")
      valid_setup = false
    end

    if ELoot.data.settings[:skin_sheath_blunt].length.positive? && ELoot.data.ready_list["skin_sheath_blunt"].nil?
      ELoot.msg("error", " Unable to find your blunt skinning sheath.")
      valid_setup = false
    end

    if ELoot.data.settings[:skin_weapon].length.positive? && ELoot.data.skin_edged.nil?
      ELoot.msg("error", " Unable to find your bladed skinning weapon.")
      valid_setup = false
    end

    if ELoot.data.settings[:skin_weapon_blunt].length.positive? && ELoot.data.skin_blunt.nil?
      ELoot.msg("error", " Unable to find your blunt skinning weapon.")
      valid_setup = false
    end

    if !valid_setup
      ELoot.msg("error", " Something went wrong initializing eloot. Please check ;eloot setup. Exiting...")
      exit
    end
  end

  ##### Data & Setup End #####

  def self.box_phase(box)
    return unless box.type =~ /box/
    return box unless ELoot.data.settings[:loot_phase] && Spell[704].known? && Spell[704].affordable? && box.name !~ /enruned|mithril/i

    loop {
      cast_result = Spell[704].cast("at ##{box.id}")
      break unless cast_result =~ /^\[Spell Hindrance for/ && Spell[704].affordable?
    }
  end

  def self.box_unphase(box)
    lines = ELoot.get_lines("look at ##{box.id}", /You see/)
    return box unless lines.any? { |line| line =~ /shifting/i }

    dothistimeout("drop ##{box.id}", 3, /flickers in and out of existence/)
    sleep 0.5

    ELoot.get_lines("glance hands", /<(right|left)/)

    return GameObj.right_hand if GameObj.right_hand.type =~ /box/
    return GameObj.left_hand if GameObj.left_hand.type =~ /box/
  end

  def self.capitalize_words(string)
    cap_string = string.to_s.split.each { |i| i.capitalize! }.join(' ')
    return cap_string
  end

  def self.change_stance(stance)
    return if Effects::Debuffs.active?("Frenzy") || dead?
    return if checkstance(stance.strip)
    return if stance == 'defensive' && checkstance('guarded')

    expiry = Time.now + 2
    while checkstance != stance
      res = dothistimeout("stance #{stance}", 2, /You are now|You move into|Roundtime|wait|Your rage causes you/i)
      if res =~ /Roundtime: (\d+)|wait (\d+)/i
        sleep((Regexp.last_match(1) || Regexp.last_match(2)).strip.to_f - 1)
        expiry = Time.now + 2
      elsif Time.now > expiry
        break
      else
        break
      end
      sleep 0.5
    end
  end

  def self.use_coin_hand
    return unless ELoot.data.settings[:coin_hand] && ELoot.silver_check.positive?
    return if ELoot.data.coin_hand.nil?

    unless ELoot.data.coin_container.nil?
      Inventory.free_hand
      Inventory.open_single_container(ELoot.data.coin_container)
      Inventory.drag(ELoot.data.coin_hand)
    end

    dothistimeout("close ##{ELoot.data.coin_hand.id}", 1, /You feel your pockets lighten/)

    unless ELoot.data.coin_container.nil?
      Inventory.store_item(ELoot.data.coin_container, ELoot.data.coin_hand)
    end
  end

  def self.decurse(obj)
    return true unless obj.type =~ /cursed/
    return false unless ELoot.data.settings[:loot_types].include?("cursed")

    if Spell[315].known? && !Spell[315].affordable?
      mana_regex = Regexp.union(
        /An invigorating rush of mana pulses through you/i,
        /You are too mentally fatigued to attempt this ability/i,
        /You're already at full mana./i,
        /Your mana control skills are not yet advanced/i,
      )
      dothistimeout "mana pulse", 2, mana_regex
    end

    if Spell[315].known? && !Spell[315].affordable?
      ELoot.msg("info", "** #{obj.name} is cursed and you don't have enough mana to cast 315.")
      return false
    end

    if Spell[315].known? && Spell[315].affordable?
      Spell[315].cast("at ##{obj.id}")
    end

    return true
  end

  def self.find_boxes
    box_sacks = Array.new
    box_sacks.push(ELoot.data.sacks["box"]) if ELoot.data.settings[:sell_container].include?("box")
    box_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
    box_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]]) if ELoot.data.settings[:sell_container].include?("overflow")
    box_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]]) if ELoot.data.settings[:sell_container].include?("overflow")

    ELoot.msg("debug", " box_sacks: #{box_sacks}")

    items = Array.new
    checked_containers = Array.new
    box_sacks.each { |sack|
      next if sack.nil? || checked_containers.include?(sack.id)

      checked_containers.push(sack.id)
      Inventory.open_single_container(sack)
      items += sack.contents.to_a.find_all { |obj| obj.type =~ /box/ }
    }

    if ELoot.data.settings[:use_disk]
      ELoot.wait_for_disk
      Inventory.open_single_container(ELoot.data.disk)
      items += ELoot.data.disk.contents.to_a.find_all { |obj| obj.type =~ /box/ }
    end

    ELoot.msg("debug", " box_list before: #{items}")

    box_list = items.uniq

    ELoot.msg("debug", " box_list after: #{box_list}")

    box_list.dup.each { |box|
      lines = ELoot.get_lines("look in ##{box.id}", /<container|That is closed|You see the shifting form/)

      if lines.any? { |line| line =~ /In the|There is nothing/i }
        if box.contents.length.positive?
          unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
            Inventory.drag(box)
          end
          Loot.box_loot(box)
        end
        box_list.delete(box)

      end
    }

    return box_list
  end

  def self.find_trash
    trashcan = nil

    can = Regexp.last_match(1) if Room.current.tags.find { |t| t =~ /meta:trashcan:(.*)/ }

    # Most common scenario - meta:trashcan is defined and GameObj.room_desc is available or trashcan is in GameObj.loot
    trashcan = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.name =~ Regexp.union(can.to_a) }
    return trashcan unless trashcan.nil?

    # Still here? Either the meta:can isn't defined or the room description isn't unavailable. Either way we have to use the noun.
    can = ["barrel", "bin", "basket", "bucket", "canister", "case", "casket", "crate", "hearth", "pit", "stump", "urn", "wastebasket", "wastebin", "wastecan"]
    trash = (Room.current.description.to_s + GameObj.loot.to_s).scan(Regexp.union(can)).uniq

    # Check to make sure it's actually a trashcan and not a custom disk/container
    trash.each { |item|
      lines = ELoot.get_lines("look in #{item}", /<container|I could not find what you were referring to.|The(.*?)is filled with a variety of garbage/)

      if lines.grep(/variety of garbage/).any?
        trashcan = GameObj.new(Regexp.last_match(1), item, item) if lines.find { |l| l =~ /^<container id='(-?[0-9]+)' title/ }
      end

      break unless trashcan.nil?
    }

    return trashcan
  end

  def self.find_worker
    worker = nil
    lines = nil
    name = $1 if Room.current.tags.find { |w| w =~ /meta:boxpool:npc:(.*)/ }

    unless name
      name = ["worker", "trickster", "Jahck", "woman", "attendant", "gnome", "merchant", "dwarf"]
    end

    20.times {
      worker = (GameObj.npcs).find { |obj| obj.name =~ Regexp.union(name) }
      break if worker

      lines = ELoot.get_lines("look", /<resource picture/)
      sleep 0.1
    }

    if worker.nil?
      ELoot.msg("info", " Failed to find the locksmith pool NPC")
      ELoot.msg("info", " GameObj.npcs: #{GameObj.npcs}")
      ELoot.msg("info", " Lines: #{lines}")

      ELoot.msg("info", " Update your map db; ;repository download-mapdb")
      ELoot.msg("info", " If the error persists then report this to Elanthia-Online")
      exit
    end

    return worker
  end

  def self.format_number(number)
    whole, decimal = number.to_s.split('.')
    if whole.to_i < -999 || whole.to_i > 999
      whole.reverse!.gsub!(/(\d{3})(?=\d)/, '\\1,').reverse!
    end
    [whole, decimal].compact.join('.')
  end

  def self.go2(place)
    fput('unhide') if (hidden? || invisible?)

    # If we're going to a place we do it based on the sell_fwi settings
    if place.class == String && ELoot.data.settings[:sell_fwi]
      fwi_place = Room.list.find { |room| room.tags.include?(place) && ELoot.fwi?(room) }

      place = fwi_place.id if fwi_place
    end

    return if Room.current.id == place || Room.current.tags.include?(place)

    if Room.current.id.nil?
      if ELoot.data.settings[:debug]
        ELoot.msg "info", "unknown room location: hope you know what you're doing"
      else
        ELoot.msg "error", 'unknown room location'
      end
    end
    Script.run('go2', "#{place} --disable-confirm", { quiet: true })
  end

  def self.help
    ELoot.msg("yellow", "")
    ELoot.msg("yellow", " ELoot is a looter script designed to make looting as fast and easy as possible.")
    ELoot.msg("yellow", "")
    ELoot.msg("teal",   " Basic usage: #{$lich_char}eloot")
    ELoot.msg("teal",   " Autostart hint: #{$lich_char}autostart add eloot start")
    ELoot.msg("teal",   " (Loads eloot data at start of game session)")
    ELoot.msg("yellow", "")
    ELoot.msg("green",  " Extra commands:")
    ELoot.msg("teal",   "  help           shows this help message")
    ELoot.msg("teal",   "  list             lists current settings")
    ELoot.msg("teal",   "  sell            sells your loot")
    ELoot.msg("teal",   "  sell alchemy_mode           tries not to sell alchemy reagents (in-testing)")
    ELoot.msg("teal",   "  pool          does just the locksmith pool")
    ELoot.msg("teal",   "  pool deposit  just does box drop off at the locksmith pool")
    ELoot.msg("teal",   "  deposit       just deposits coins and notes")
    ELoot.msg("teal",   "  --debug=on/off        toggles debug messages")
    ELoot.msg("yellow", "")
    ELoot.msg("orange", "  Warning     *** Mark ANYTHING you don't want to lose. ELoot is not perfect! ***")
    ELoot.msg("yellow", "")
  end

  def self.loot
    if Spell['Berserk'].active?
      ELoot.msg("info", " Your current status prevents you from looting.")
      return
    end

    sleep 0.2

    # remember what is in our hands
    ELoot.data.right_hand = GameObj.right_hand
    ELoot.data.left_hand = GameObj.left_hand

    ELoot.change_stance('defensive') if ELoot.data.settings[:loot_defensive]
    ELoot.msg("debug", "ELoot.loot: Defensive Stance") if ELoot.data.settings[:loot_defensive]

    ELoot.msg("debug", "ELoot.loot: Begin Skinning") if ELoot.data.settings[:skin_enable]
    Loot.skin if ELoot.data.settings[:skin_enable]

    ELoot.msg("debug", "ELoot.loot: Searching")
    Loot.search
    sleep(0.1)

    ELoot.msg("debug", "ELoot.loot: Looting the Room")
    Loot.room

    # use coin hand if we have it
    ELoot.use_coin_hand

    Inventory.return_hands
  end

  def self.read_note
    result = 0
    note = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /note|scrip|chit/ }
    return unless note

    line = ELoot.get_res("read #{note}", /Hold in right hand to use/)

    if line =~ /has a value of (.*?) silver and reads/
      result = $1.delete(",").to_i
    end

    return result
  end

  def self.silver_check
    return Lich::Util.silver_count
  end

  def self.silver_deposit
    ending_silver = ELoot.silver_check
    keep_silvers = ELoot.data.settings[:sell_keep_silver].to_i
    note = ELoot.data.sacks["default"].contents.find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }

    return unless keep_silvers.positive? || ending_silver > 0 || note

    ELoot.go2('bank')
    fput('share all') if ELoot.data.settings[:sell_share_silvers] && ending_silver > 1
    fput('deposit all') if ending_silver > 0 || note
    fput("withdraw #{keep_silvers}") if keep_silvers.positive?
  end

  def self.silver_withdraw(amount)
    if ELoot.silver_check > amount && percentencumbrance < 20
      return
    end

    ELoot.go2('bank')

    ELoot.silver_deposit

    # TODO: handle not enough silver case
    fput("withdraw #{amount} silvers")
  end

  def self.unlootable(item)
    return unless ELoot.data.settings[:log_unlootables]
    return unless item.type.nil?

    ELoot.msg("info", " #{item.name} was not lootable, adding to list.")
    ELoot.data.settings[:unlootable].push(item.name)
    ELoot.save_profile()
  end

  def self.wait_for_disk
    return unless ELoot.data.disk || !ELoot.data.settings[:use_disk]

    if ELoot.data.disk.status =~ /gone/ || !GameObj.loot.find { |l| l.name =~ /#{Char.name} (?:disk|coffin)$/ }
      ELoot.msg("info", " Waiting for your disk to arrive")
      50.times do
        break if (ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} (?:disk|coffin)$/ })

        sleep(0.1)
      end
    end

    return unless ELoot.data.disk && ELoot.data.disk.status !~ /gone/ && ELoot.data.disk.contents.nil?

    Inventory.open_single_container(ELoot.data.disk)
  end

  def self.wait_rt
    sleep 0.2
    wait_while { checkrt > 0 }
    sleep 0.2
  end

  # Global data used by ELoot
  class Data
    attr_accessor :disk, :disk_full, :sacks_full, :ready_list, :ready_method, :sacks, :settings, :skinners, :skinsheath, :silent_open, :checked_bags,
                  :close_regex, :look_regex, :sacks_closed, :all_loot_categories, :regex_gold_rings, :right_hand, :left_hand, :skin_edged, :skin_blunt,
                  :coin_hand, :coin_container, :silver_breakdown, :get_regex, :alchemy_mode, :sell_containers, :local_gemshop, :local_furrier, :log_unlootables, :exclude

    def initialize(settings)
      @disk = nil
      @disk_full = false
      @ready_list = {}
      @ready_method = {}
      @sacks = {}
      @settings = settings
      @skinners = {}
      @skinsheath = nil
      @skin_edged = nil
      @skin_blunt = nil
      @sacks_full = Array.new
      @sacks_closed = Array.new
      @right_hand = ""
      @left_hand = ""
      @checked_bags = Array.new
      @coin_hand = nil
      @coin_container = nil
      @silver_breakdown = Hash.new
      @alchemy_mode = false
      @sell_containers = Array.new
      @local_gemshop = nil
      @local_furrier = nil

      $sell_ignore = Array.new

      default_crumbly = [
        # Kraken Fall
        "gnarled dark wooden crook",
        "twisted obsidian dagger",
        "immense fel-hafted handaxe",
        "gold-tipped heavy spear",
        "notched bone handaxe",
        "rough pinewood crook",
        "swirling sanguine orb",
        "battered antique faewood crate",
        "copper-traced dark steel hatchet",
        "huge black alloy greatsword",
        "rough leather quiver",

        # Atoll
        "twisted soot black runestaff",
        "corroded bronze Hammer of Kai",
        "dried seaweed-wrapped longbow",
        "bronze-bound driftwood greatshield",
        "coral-hilted heavy ball and chain",
        "coral-hilted sharply tapered longsword",
      ]

      @settings[:crumbly] ||= []
      @settings[:crumbly] = (default_crumbly + @settings[:crumbly]).uniq

      @settings[:track_full_sacks] = true if @settings[:track_full_sacks].nil?

      @settings[:unlootable] ||= []
      @settings[:unlootable] = @settings[:unlootable].uniq

      @settings[:auto_close] ||= []
      @settings[:auto_close] = @settings[:auto_close].uniq

      @settings[:unskinnable] = @settings[:unskinnable].uniq

      @settings[:sell_container] ||= ["default", "overflow", "box", "collectible", "forageable", "gem", "herb", "lockpick", "potion", "reagent", "scroll", "skin", "treasure", "trinket", "wand"]

      @exclude = @settings[:loot_exclude].map { |r| r.is_a?(String) ? Regexp.new(r) : r }
      @exclude = '' if @exclude.nil?

      @get_regex = Regexp.union(
        /^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly )?(?:remove|draw|grab|reach|slip|tuck|retrieve|already have|unsheathe|detach|swap)/,
        /^Get what\?$/,
        /^Why don't you leave some for others\?$/,
        /^You need a free hand|^You already have that/,
        /Reaching over your shoulder/
      )

      @look_regex = Regexp.union(
        /Peering into the <a exist=.*? noun="toolkit">/i,
        /That is closed/i,
        /is shut too tightly to see its contents/i,
        /In the(.*?)you see/i,
        /In the(.*?):/i,
        /There is nothing/i,
        /You glance/i,
        /^Attached to a.*keyring/i,
        /.*?[.*?]:/i,
        /The <a exist="\d+" noun="\w+">[^<]+<\/a> has (?:an? <a exist="\d+" noun="\w+">[^<]+<\/a> |nothing )?in.*scabbard and (?:an? <a exist="\d+" noun="\w+">[^<]+<\/a> |nothing )?in.*scabbard\./i,
        /^I could not find what you were referring to\./i,
        /Hidden within the depths of a cloakwing moth greatcloak/,
        /<exposeContainer|<dialogData|<container/i,
      )

      @silent_open = Regexp.union(
        /You throw back/i,
        /You open/i,
        /Oh no! It's already/i,
        /You pick at the knot/i,
        /already open/i,
        /is open already/i,
        /You unfasten/i,
        /You glance around suspiciously/i,
        /^What were you referring to\?/i,
        /^I could not find what you were referring to\./i,
        /You pull the long strips of leather/i,
        /With a flick of your wrist/i,
        /Sliding the lever on the side/i,
        /You rub your hand/i,
        /There doesn't seem to be any way/i,
        /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i,
        /crumbles? and decays? away/,
        /Myriad spectral moths pull a cloakwing/,
        /<exposeContainer|<container/i,
        /You undo each of the/
      )

      @close_regex = Regexp.union(
        /You close .*/,
        /That is already closed/,
        /What were you referring to/,
        /seem to be any way to do that/,
        /You tie/,
        /You fasten the/
      )

      @regex_gold_rings = /^(dingy|plain|braided|twisted|intricate|large|thin|wide|polished|scratched|thick|dull|faded|small|flawless|inlaid|dirt\-caked|ornate|exquisite|shiny|bright|narrow) gold ring$|^gold ring$/

      @all_loot_categories = ["alchemy", "armor", "box", "clothing", "collectible", "cursed", "food", "gem", "herb", "jewelry", "junk", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand", "weapon"]
    end
  end

  # Setup is an extension of Gtk::Builder for Gtk setup
  class Setup < Gtk::Builder
    @@categories = {
      loot: {
        loot_types: {
          # :loot_types=>["alchemy", "armor", "box", "clothing", "collectible", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
          default: []
        },
        loot_exclude: {
          default: ["black ora", "urglaes"],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
        loot_keep: {
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
        critter_exclude: {
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
        unlootable: {
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
        loot_phase: { default: false },
        use_disk: { default: true },
        loot_defensive: { default: false },
        overflow_container: { default: '' },
        secondary_overflow: { default: '' },
        coin_hand: { default: false },
        coin_hand_name: { default: '' },
        keep_closed: { default: false },
        track_full_sacks: { default: true },
        favor_left: { default: false },
        log_unlootables: { default: false },

      },
      sell: {
        sell_loot_types: {
          # :sell_loot_types=>["alchemy", "armor", "clothing", "gem", "jewelry", "junk", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
          default: []
        },
        sell_container: { default: [] },
        sell_exclude: {
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
        sell_keep_scrolls: {
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              if Spell[text].num.nil?
                setting.delete(text)
              else
                iter = store.append
                iter[0] = Spell[text].num
                iter[1] = Spell[text].name
              end
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(Spell[selected.get_value(0)].num)
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)
            next if Spell[text].nil?

            setting.push(Spell[text].num)
            setting.uniq!.sort!
          end
        },
        sell_appraise_types: { default: ["jewelry", "magic", "uncommon", "valuable"] },
        sell_appraise_gemshop: { default: 14_999 },
        sell_appraise_pawnshop: { default: 34_999 },
        sell_collectibles: { default: true },
        sell_gold_rings: { default: false },
        sell_locksmith: { default: false },
        sell_locksmith_pool: { default: true },
        always_check_pool: { default: false },
        display_box_contents: { default: false },
        sell_locksmith_pool_tip: { default: 15 },
        sell_locksmith_pool_tip_percent: { default: true },
        sell_share_silvers: { default: false },
        sell_fwi: { default: false },
        sell_shroud: { default: false },
        sell_aspect: { default: false },
        sell_keep_silver: { default: 0 }
      },
      skin: {
        skin_enable: { default: false },
        skin_kneel: { default: false },
        skin_604: { default: false },
        skin_resolve: { default: false },
        skin_sheath: { default: '' },
        skin_weapon: { default: '' },
        skin_sheath_blunt: { default: '' },
        skin_weapon_blunt: { default: '' },
        skin_exclude: {
          default: [],
          load: proc do |store, setting|
            store.clear
            setting.each do |text|
              iter = store.append
              iter[0] = text
            end
          end,
          delete: proc do |_, selected, setting|
            setting.delete(selected.get_value(0))
            setting.uniq!.sort!
          end,
          set: proc do |_, text, setting|
            next if setting.include?(text)

            setting.push(text)
            setting.uniq!.sort!
          end
        },
      },
      internal: {
        silence: { default: true },
        debug: { default: false },
        unskinnable: { default: [] },
        unlootable: { default: [] },
        crumbly: { default: [] },
        auto_close: { default: [] },
      }
    }

    def self.eloot_ui
      '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkListStore" id="critter_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkListStore" id="loot_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/>
      </columns></object><object class="GtkListStore" id="loot_keep_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkAdjustment" id="sell_appraise_gemshop_adjustment"><property name="upper">1000000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="sell_appraise_gemshop_pawnshop"><property name="upper">1000000</property><property name="step-increment">1</property><property name="page-increment">10</property>
      </object><object class="GtkListStore" id="sell_exclude_store"><columns><!-- column-name Exclusion --><column type="gchararray"/></columns></object><object class="GtkListStore" id="sell_keep_scrolls_store"><columns><!-- column-name Spell --><column type="gint"/><!-- column-name Spell1 --><column type="gchararray"/></columns></object><object class="GtkAdjustment" id="sell_keep_silver_adjustment"><property name="upper">999999</property><property name="step-increment">1</property><property name="page-increment">10</property>
      </object><object class="GtkAdjustment" id="sell_locksmith_pool_tip_adjustment"><property name="upper">999999</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="skin_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkListStore" id="unlootable_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkWindow" id="main"><property name="width-request">750</property><property name="height-request">505</property><property name="can-focus">False</property><property name="title" translatable="yes">ELoot Setup</property><property name="modal">True</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=6 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="loot_types:alchemy"><property name="label" translatable="yes">Alchemy</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:armor"><property name="label" translatable="yes">Armor</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkCheckButton" id="loot_types:box"><property name="label" translatable="yes">Box</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:clothing"><property name="label" translatable="yes">Clothing</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:collectible"><property name="label" translatable="yes">Collectible</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkCheckButton" id="loot_types:cursed"><property name="label" translatable="yes">Cursed</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:food"><property name="label" translatable="yes">Food</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkCheckButton" id="loot_types:herb"><property name="label" translatable="yes">Herb</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:junk"><property name="label" translatable="yes">Junk</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkCheckButton" id="loot_types:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkCheckButton" id="loot_types:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">4</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkCheckButton" id="loot_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:weapon"><property name="label" translatable="yes">Weapon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">5</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Please scroll down for additional options</property><attributes><attribute name="foreground" value="#ffff00000000"/>
      </attributes></object><packing><property name="left-attach">1</property><property name="top-attach">4</property><property name="width">4</property></packing></child><child><object class="GtkCheckButton" id="loot_types:coins"><property name="label" translatable="yes">Coins (ground)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Loot Types</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="loot_defensive"><property name="label" translatable="yes">Loot in defensive (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Swap to defensive before looting if there are hostile enemies.</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_phase"><property name="label" translatable="yes">Phase boxes(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Phases boxes if you are able to.</property><property name="halign">start</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_disk"><property name="label" translatable="yes">Disking(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Utilizes your disk for boxes if checked</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="label" translatable="yes">Coin Hand Name:</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkEntry" id="coin_hand_name"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="track_full_sacks"><property name="label" translatable="yes">Track Full Containers(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Eloot will try to keep track of full sacks (turn off if not selling with eloot)</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="favor_left"><property name="label" translatable="yes">Favor Left(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will favor left hand to stow for looting (defaults to right)</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="keep_closed"><property name="label" translatable="yes">Keep sacks shut(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Will keep sacks closed (Performance hit!)</property><property name="halign">start</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="coin_hand"><property name="label" translatable="yes">Use Coin Hand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkCheckButton" id="log_unlootables"><property name="label" translatable="yes">Log unlootable items(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">This will log items you can not loot into the Unlootable section (bottom of this tab) otherwise it will ignore that section. </property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Other Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Primary Overflow:</property><property name="xalign">0</property><property name="yalign">0</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="overflow_container"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Enter the name of your overflow container.  This container will be used when the targeted STOW container is full.</property><property name="margin-start">5</property><property name="margin-end">10</property><property name="margin-bottom">5</property><property name="hexpand">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Secondary Overflow:</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="secondary_overflow"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Enter the name of your secondary overflow container.  This container will be used when the primary overflow container is full.</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="vexpand">False</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Overflow Containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="loot_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="loot_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="loot_exclude_entry"><property name="width-request">225</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. urglaes fang)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="loot_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">loot_exclude_store</property><property name="headers-visible">False</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
      </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time. Regular expressions are supported.

      Enter "(?:aquamarine|gold) wand" and "gold ring" as separate entries.</property><property name="label" translatable="yes">Never Loot(?)</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">3</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="loot_keep_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="loot_keep_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="loot_keep_entry"><property name="width-request">225</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter addition (e.g. uncut diamond)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="loot_keep"><property name="visible">True</property><property name="can-focus">True</property><property name="model">loot_keep_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
      </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Always loot these items. They should be entered one line at a time. Regular expressions are supported.

      Enter "(?:aquamarine|gold) wand" and "gold ring" as separate entries.</property><property name="label" translatable="yes">Always Loot(?)</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">4</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="critter_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="critter_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="critter_exclude_entry"><property name="width-request">225</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. giant rat)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="critter_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">critter_exclude_store</property><property name="headers-visible">False</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
      </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time. Regular expressions are supported.

      Enter "(?:big ugly|mongrel) kobold" and "Vvrael destroyer" as separate entries.</property><property name="label" translatable="yes">Creature Exclusions (?)</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">5</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="unlootable_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="unlootable_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="unlootable_entry"><property name="width-request">225</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter unlootable item</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="unlootable"><property name="visible">True</property><property name="can-focus">True</property><property name="model">unlootable_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
      </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Unlootable items should be entered one line at a time. Regular expressions are supported.
      </property><property name="label" translatable="yes">Unlootable(?)</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">6</property></packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Looting</property></object><packing><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=6 n-rows=6 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_loot_types:alchemy"><property name="label" translatable="yes">Alchemy</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:armor"><property name="label" translatable="yes">Armor</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:box"><property name="label" translatable="yes">Box (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Sells empty gold, mithril, and silver boxes to the pawnshop</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:clothing"><property name="label" translatable="yes">Clothing</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:cursed"><property name="label" translatable="yes">Cursed</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:food"><property name="label" translatable="yes">Food (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Food will be thrown away or dropped since it can\'t be sold</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">5</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:herb"><property name="label" translatable="yes">Herb (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Herbs will be thrown away or dropped since they can\'t be sold</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:junk"><property name="label" translatable="yes">Junk (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Junk will be thrown away or dropped since they can\'t be sold</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:scarab"><property name="label" translatable="yes">Scarab</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:weapon"><property name="label" translatable="yes">Weapon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Warning - Mark anything you don\'t want accidentally sold - Eloot is not perfect!</property><attributes><attribute name="foreground" value="#ffff00000000"/></attributes></object><packing><property name="left-attach">1</property><property name="top-attach">4</property><property name="width">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Please scroll down for additional options</property><attributes><attribute name="foreground" value="#ffff00000000"/>
      </attributes></object><packing><property name="left-attach">1</property><property name="top-attach">5</property><property name="width">4</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Sell Types</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=5 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_container:default"><property name="label" translatable="yes">Default</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:overflow"><property name="label" translatable="yes">Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:box"><property name="label" translatable="yes">Box</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:collectible"><property name="label" translatable="yes">Collectible</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:forageable"><property name="label" translatable="yes">Forageable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:herb"><property name="label" translatable="yes">Herb</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:potion"><property name="label" translatable="yes">Potion</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:treasure"><property name="label" translatable="yes">Treasure</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:trinket"><property name="label" translatable="yes">Trinket</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">4</property><property name="top-attach">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Only sell from these STOW containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="sell_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="sell_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="sell_exclude_entry"><property name="width-request">225</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. uncut diamond)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="sell_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">sell_exclude_store</property><property name="headers-visible">False</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
      </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child><child><placeholder/></child><child><placeholder/>
      </child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time. Regular expressions are supported.

      Enter "(?:aquamarine|gold) wand" and "gold ring" as separate entries.</property><property name="label" translatable="yes">Exclusions (?)</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="sell_keep_scrolls_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="sell_keep_scrolls_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="sell_keep_scrolls_entry"><property name="width-request">225</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. 215)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="sell_keep_scrolls"><property name="height-request">-1</property><property name="visible">True</property><property name="can-focus">True</property><property name="model">sell_keep_scrolls_store</property><property name="headers-visible">False</property><child internal-child="selection"><object class="GtkTreeSelection"/>
      </child><child><object class="GtkTreeViewColumn"><property name="title" translatable="yes">Spell Number</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="title" translatable="yes">Spell Name</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">1</attribute></attributes></child></object></child></object></child></object>
      </child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Add spells to this list to prevent selling scrolls that have spells matching.</property><property name="label" translatable="yes">Keep Scrolls</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">3</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_appraise_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="label" translatable="yes">Gemshop Limit</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="sell_appraise_gemshop"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="adjustment">sell_appraise_gemshop_adjustment</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="label" translatable="yes">Pawnshop Limit</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="sell_appraise_pawnshop"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="adjustment">sell_appraise_gemshop_pawnshop</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Appraisals</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">4</property></packing>
      </child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_locksmith_pool"><property name="label" translatable="yes">Use locksmith pool</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_locksmith"><property name="label" translatable="yes">Use town locksmith</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="display_box_contents"><property name="label" translatable="yes">Display box contents</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="label" translatable="yes">Locksmith Pool Tip</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkSpinButton" id="sell_locksmith_pool_tip"><property name="visible">True</property><property name="can-focus">True</property><property name="adjustment">sell_locksmith_pool_tip_adjustment</property><property name="numeric">True</property><property name="value">-2.2351741812000001e-10</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkCheckButton" id="sell_locksmith_pool_tip_percent"><property name="label" translatable="yes">Tip using percentage</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="always_check_pool"><property name="label" translatable="yes">Always check pool (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">If checked eloot will always check the pool for retruned boxes.
      Default behavior is to only check if there is a box to drop off.</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Locksmithing</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">5</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="sell_collectibles"><property name="label" translatable="yes">Deposit Collectibles</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_fwi"><property name="label" translatable="yes">Sell in FWI</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
      </packing></child><child><object class="GtkCheckButton" id="sell_gold_rings"><property name="label" translatable="yes">Gold Rings to Chrono.</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
      </packing></child><child><object class="GtkCheckButton" id="sell_shroud"><property name="label" translatable="yes">Use Shroud (1212) &amp; Glamour (1205)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property>
      </packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><placeholder/></child><child><placeholder/></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkSpinButton" id="sell_keep_silver"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-top">5</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_keep_silver_adjustment</property><property name="numeric">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_share_silvers"><property name="label" translatable="yes">Share silvers</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Setting this will ensure you keep a certain number of silvers on you after selling. This is useful for places like Icemule Trace that have a gate fee.</property><property name="halign">start</property><property name="margin-start">30</property><property name="label" translatable="yes">Keep Silvers (?)</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_aspect"><property name="label" translatable="yes">Use Assume Aspect - Lion (650)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Other Settings</property>
      </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">6</property></packing></child></object></child></object></child></object><packing><property name="position">1</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Selling</property></object><packing><property name="position">1</property><property name="tab-fill">False</property>
      </packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_enable"><property name="label" translatable="yes">Enable skinning</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkCheckButton" id="skin_kneel"><property name="label" translatable="yes">Kneel to skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_resolve"><property name="label" translatable="yes">Use Sigil of Resolve</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
      </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_604"><property name="label" translatable="yes">Use 604</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property>
      </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
      </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="label" translatable="yes">Skin Sheath (edged)</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_sheath"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="width-chars">20</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="label" translatable="yes">Skin Weapon (edged)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_weapon"><property name="visible">True</property><property name="can-focus">True</property><property name="width-chars">20</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="label" translatable="yes">Skin Sheath (blunt)</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="skin_sheath_blunt"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="width-chars">20</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="label" translatable="yes">Skin Weapon (blunt)</property>
      </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkEntry" id="skin_weapon_blunt"><property name="visible">True</property><property name="can-focus">True</property><property name="width-chars">20</property></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/>
      </child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Skin Weapons</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
      </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="skin_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
      </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="skin_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
      </packing></child><child><object class="GtkEntry" id="skin_exclude_entry"><property name="width-request">225</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter skinning exclusion (e.g. giant rat)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="skin_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">skin_exclude_store</property><property name="headers-visible">False</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
      </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child><child><placeholder/></child><child><placeholder/>
      </child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time. Regular expressions are supported.

      Enter "(?:big ugly|mongrel) kobold" and "Vvrael destroyer" as separate entries.</property><property name="label" translatable="yes">Skinning Exclusions (?)</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">3</property>
      </packing></child></object></child></object></child></object><packing><property name="position">2</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Skinning</property></object><packing><property name="position">2</property><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
      </packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Your changes are saved automatically.</property><attributes><attribute name="style" value="italic"/>
      </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">15</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
      </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
    end

    def self.get_category(key)
      @@categories.each { |category, data| return category unless data[key].nil? }
      nil
    end

    def self.get_setting(key)
      cat = Setup.get_category(key)
      return nil if cat.nil?

      @@categories[cat].each { |setting, data| return data if setting == key }
      nil
    end

    def initialize(settings)
      super()

      @settings = settings

      # set default values if they don't exist
      @@categories.each do |_, data|
        data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
      end

      # remove settings that doesn't exist
      @settings.delete_if { |key, _| next Setup.get_category(key).nil? }

      # only sorcerers can phase
      @settings[:loot_phase] = false unless Char.prof == 'Sorcerer'

      # 604 support
      @settings[:skin_604] = false unless Spell[604].known?

      # GoS only for Sigil of Resolve
      @settings[:skin_resolve] = false unless Society.status == 'Guardians of Sunfist' && Society.rank >= 4

      # use a GTK Builder to setup all the basics of the window then expand on that base
      return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

      Gtk.queue do
        # add_from_file("#{$data_dir}eloot.ui")
        add_from_string(Setup.eloot_ui)
        load_settings

        self['main'].keep_above = true
        self['main'].set_title "ELoot Setup v#{ELoot_version}"

        # connect signals after settings are loaded to a bunch of handlers don't trigger
        connect_signals { |handler| method(handler) }
      end
    end

    # This is connected to automatically during load_settings and syncs data back to CharSettings.
    def on_update(obj)
      Gtk.queue do
        key = obj.builder_name.to_sym
        setting = Setup.get_setting(key)
        return if setting.nil?

        if obj.class == Gtk::CheckButton
          @settings[key] = obj.active?
        elsif obj.class == Gtk::Entry
          @settings[key] = obj.text.strip
        elsif obj.class == Gtk::SpinButton
          # update from text entry
          obj.update

          # force int, we don't use floats anywhere
          @settings[key] = obj.adjustment.value.to_i
        end
      end
    end

    def on_close_clicked
      ELoot.save_profile()
      self['main'].destroy
    end

    def on_destroy
      Gtk.queue { @running = false }
    end

    # iterate all objects and for any that match a setting name directly we set the default
    def load_settings
      Gtk.queue do
        # load up the generic settings which are just matching by name of the widget
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)

          key = obj.builder_name.to_sym
          next if (setting = Setup.get_setting(key)).nil?

          # set the default value
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("skin_resolve")) && !Spell[9704].known?
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("skin_604")) && !Spell[604].known?
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("sell_shroud")) && (!Spell[1205].known? || !Spell[1212].known?)
          obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("sell_aspect")) && !Spell[650].known?
          if obj.class == Gtk::CheckButton
            obj.active = @settings[key]
            obj.signal_connect('toggled') { on_update(obj) }
          elsif obj.class == Gtk::Entry
            obj.text = @settings[key].strip
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::SpinButton
            obj.value = @settings[key]
            obj.adjustment.value = @settings[key]
            obj.signal_connect('changed') { on_update(obj) }
          elsif obj.class == Gtk::TreeView
            if (store = self["#{key}_store"]).nil?
              respond "** failed to find store for treeview #{key}"
              next
            elsif setting[:load].nil?
              respond "** no :load defined #{key}"
              next
            end

            setting[:load].call(store, @settings[key])

            # setup the signals
            if (add = self["#{key}_add"]).nil?
              respond "** failed to find add for treeview #{key}"
              next
            elsif (delete = self["#{key}_delete"]).nil?
              respond "** failed to find delete for treeview #{key}"
              next
            elsif (entry = self["#{key}_entry"]).nil?
              respond "** failed to find entry for treeview #{key}"
              next
            end

            add.signal_connect('clicked') do
              if setting[:set].nil?
                respond "** no :set defined for #{key}"
                next
              elsif entry.text.empty?
                next
              end
              setting[:set].call(store, entry.text, @settings[key])
              setting[:load].call(store, @settings[key])
            end

            delete.signal_connect('clicked') do
              if setting[:delete].nil?
                respond "** no :delete defined for #{key}"
                next
              elsif (selected = obj.selection.selected).nil?
                next
              end
              setting[:delete].call(store, selected, @settings[key])
              setting[:load].call(store, @settings[key])
            end
          end
        end

        # checkboxes for array storage with id's <setting>:<value>
        # this is primarily used by the loot types
        objects.each do |obj|
          next unless obj.methods.include?(:builder_name)
          next unless obj.builder_name =~ /^([^:]+):(.*)$/i
          next unless obj.class == Gtk::CheckButton

          key = Regexp.last_match(1).to_sym
          value = Regexp.last_match(2).to_s
          next if Setup.get_setting(key).nil?

          obj.active = @settings[key].include?(value)

          # add in hook
          obj.signal_connect('toggled') do
            @settings[key].delete(value)
            if obj.active?
              @settings[key].push(value)
              @settings[key].uniq!.sort!
            end
          end
        end
      end
    end

    def start
      @running = true

      Gtk.queue { self['main'].show_all }

      wait_while { @running }
    end

    def list(cat_to_list: 'all')
      indent_size = 2
      print_array =
        proc do |key, value, indent|
          _respond("#{' ' * indent_size * indent.to_i}#{key}:")
          value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
        end

      print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

      categories = cat_to_list == 'all' ? %w[loot sell skin internal] : [cat_to_list]
      if $frontend == 'stormfront'
        output = "<output class=\"mono\"/>\n"
      else
        output = String.new
      end
      categories.each do |opt|
        _respond("#{output}") if !output.empty?
        _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
        @@categories[opt.to_sym].each do |id, _|
          value = @settings[id]
          value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
        end
      end
      _respond("#{monsterbold_start}= GameObj Types =#{monsterbold_end}\n")
      _respond("#{GameObj.type_data.map { |k, _v| k }.sort.join(', ')}")
      if $frontend == 'stormfront'
        output = "<output class=\"\"/>\n"
        _respond("#{output}")
      end
    end

    def self.update_setting(key, value)
      setting = Setup.get_setting(key)
      ELoot.msg("error", "** Setting \"#{key}\" does not exist") if setting.nil?

      action = nil

      if value.to_s =~ /^([+-])(.*)$/
        action = Regexp.last_match(1)
        value = Regexp.last_match(2).strip.downcase
      end

      if value.to_s == 'reset'
        @settings.delete(key)
        ELoot.msg("info", " Reset #{key}")
      elsif @settings[key].class == Array
        if value =~ /\d/ && @settings[key][value.to_i]
          @settings[key].delete_at(value.to_i)
        else
          @settings[key].delete(value)
        end

        if action == '-'
          ELoot.msg("info", " \"#{value}\" removed from \"#{key}\"")
        else
          @settings[key].push(value)
          ELoot.msg("info", " \"#{value}\" added to \"#{key}\"")
        end

        ELoot.msg("info", " \"#{key}\" is now \"#{@settings[key].join(', ')}\"")
      else
        if @settings[key].class == FalseClass || @settings[key].class == TrueClass
          value = value =~ /^true|1|yes|on/ ? true : false
        elsif @settings[key].class == Integer
          value = value.to_i
        end

        ELoot.msg("info", " \"#{key}\" has been set to \"#{value}\"")
        @settings[key] = value
      end
    end
  end

  # Inventory handles inventory
  module Inventory
    def self.check_auto_closer
      return if ELoot.data.settings[:auto_close].empty?

      items_opened = []
      ELoot.data.sacks.keys.each { |bag|
        bag_obj = ELoot.data.sacks[bag]
        next if items_opened.include?(bag_obj.name)

        items_opened.push(bag_obj.name)
        next unless ELoot.data.settings[:auto_close].include?(bag_obj.name)

        ELoot.get_lines("open ##{bag_obj.id}", ELoot.data.silent_open)
      }
    end

    def self.close_container(bag)
      ELoot.get_res("close ##{bag.id}", ELoot.data.close_regex)
    end

    def self.close_sell_containers
      return unless ELoot.data.settings[:keep_closed]

      ELoot.data.sell_containers.each { |sack|
        # Don't close ready list containers or storage and retrieval of weapons/shields gets messed up
        next if ELoot.data.ready_list.find { |_k, v| v.id == sack.id }

        Inventory.close_container(sack)
      }
    end

    def self.drag(item, to = "hand") # drags things from inventory to a hand
      return if item.nil? || item.empty? || item.name == "Empty"

      if to == "hand"
        to = GameObj.right_hand.id.nil? ? 'right' : 'left'
      end

      line = ELoot.get_res("_drag ##{item.id} #{to}")

      20.times {
        return true if ([GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))
        break if line =~ /Get what|I could not find what you were referring to/

        sleep 0.1
      }

      if line =~ /Get what|I could not find what you were referring to/
        ELoot.msg("info", "Can't find #{item.name}. Going to look in all the bags in case it got misplaced.")
        ELoot.data.sacks.keys.each { |bag|
          bag_obj = ELoot.data.sacks[bag]
          next if GameObj.containers.keys.include?(bag_obj.id) && bag_obj.contents.is_a?(Array)

          Inventory.open_single_container(bag_obj)
          Inventory.drag(item, to)
        }
      end

      return false
    end

    def self.wear(item)
      return false if item.nil? || item.empty? || item.name == "Empty"

      line = ELoot.get_res("_drag ##{item.id} wear")

      # Give it time to update and confirm action
      20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)) && (GameObj.inv.map(&:id).compact.include?(item.id))
        break if line =~ /You can't wear that/
        sleep 0.1
      }

      # Still here? Something is wrong, inform the player and exit.
      if [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
        ELoot.msg("warn", " Something is wrong. Unable to wear the #{item}. Exiting to avoid losing items.")
        ELoot.msg("warn", " Please grab a short log of what just happened and post it to the scripting discord for debugging")
        exit
      end
    end

    def self.free_hand
      unless (GameObj.right_hand.id.nil? and ([Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max < 3)) or (GameObj.left_hand.id.nil? and ([Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max < 3))

        if ELoot.data.settings[:favor_left]
          if GameObj.left_hand.id and ([Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max < 3 or [Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max == 3)
            waitrt?
            Inventory.free_hands(left: true)
          else
            waitrt?
            Inventory.free_hands(right: true)
          end
        else
          if GameObj.right_hand.id and ([Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max < 3 or [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max == 3)
            waitrt?
            Inventory.free_hands(right: true)
          else
            waitrt?
            Inventory.free_hands(left: true)
          end
        end
      end
    end

    def self.free_hands(right: false, left: false, both: false)
      if (right || both) && checkright
        # Are we holding a ready_list weapon? If so put it into its sheath
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == GameObj.right_hand.id }[0])
          Inventory.stow_ready_list(ready_item, GameObj.right_hand)
        end
        if !GameObj.right_hand.id.nil?
          Inventory.single_drag(GameObj.right_hand) # drags single item into container
        end
      end

      if (left || both) && checkleft
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == GameObj.left_hand.id }[0])
          Inventory.stow_ready_list(ready_item, GameObj.left_hand)
        end
        if !GameObj.left_hand.id.nil?
          Inventory.single_drag(GameObj.left_hand) # drags single item into container
        end
      end
    end

    def self.open_loot_containers(item)
      # Method intended for opening containers that will receive loot from the loot room or loot item command
      ELoot.msg("debug", " Start of open_loot_containers(item)")
      return unless ELoot.data.settings[:keep_closed]

      Inventory.open_single_container(ELoot.data.sacks["default"])
      Inventory.open_single_container(ELoot.data.settings[:overflow_container])
      Inventory.open_single_container(ELoot.data.settings[:secondary_overflow])

      containers = Array.new
      item.each { |loot|
        next if ELoot.data.sacks[loot.type].nil?

        unless containers.include?(ELoot.data.sacks[loot.type].id)
          Inventory.open_single_container(ELoot.data.sacks[loot.type])
          containers.push(ELoot.data.sacks[loot.type].id)
        end
      }
    end

    def self.open_single_container(sack)
      ELoot.msg("debug", "Inventory.open_single_container: sack = #{sack}")

      return if sack.nil? || sack.empty?

      container = sack.class == GameObj ? sack : ELoot.data.sacks[sack]
      ELoot.msg("debug", " open_single_container(sack): before open sack - #{sack} container: #{container}")

      # If its in the game obj and contents.is_a?(Array) return
      return if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)

      # Still here? Assume the container is closed and open it
      ELoot.get_lines("open ##{container.id}", ELoot.data.silent_open)

      # check out whats inside
      lines = ELoot.get_lines("look in ##{container.id}", ELoot.data.look_regex)
      return if lines.any? { |l| l =~ /You glance|There is nothing/i }

      20.times {
        break if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)

        sleep 0.1
      }

      ELoot.data.sell_containers.push(container) unless ELoot.data.sell_containers.include?(container)
    end

    def self.return_hands
      # Nothing to do
      return if ELoot.data.right_hand.id == GameObj.right_hand.id && ELoot.data.left_hand.id == GameObj.left_hand.id

      # Check Right Hand
      unless ELoot.data.right_hand.id == GameObj.right_hand.id
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == ELoot.data.right_hand.id }[0])
          Inventory.return_ready_list(ready_item, ELoot.data.right_hand, "right")
        else
          Inventory.drag(ELoot.data.right_hand, 'right')
        end
      end

      # Check Left Hand
      unless ELoot.data.left_hand.id == GameObj.left_hand.id && ELoot.data.right_hand.name !~ /sonic/i
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == ELoot.data.left_hand.id }[0])
          Inventory.return_ready_list(ready_item, ELoot.data.left_hand, "left")
        else
          Inventory.drag(ELoot.data.left_hand, 'left')
        end
      end
    end

    def self.return_ready_list(ready_item, item, _hand)
      10.times {
        ELoot.get_res("ready #{ready_item}", ELoot.data.get_regex)
        sleep 0.2
        return true if [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
      }

      return false
    end

    def self.single_drag(item, phase_thing = true) # drags single item into container
      return if item.nil?

      if item.type =~ /box/
        # item = ELoot.box_phase(item)

        if ELoot.data.disk && !ELoot.data.disk_full && ELoot.data.settings[:use_disk]
          # Wait for disk to arrive
          ELoot.wait_for_disk
          if ELoot.data.disk
            result = Inventory.store_item(ELoot.data.disk, item)
            if result
              return
            end

            # inform user it didn't fit if !result
            ELoot.msg("info", " The #{item} won't fit in the #{ELoot.data.disk}. Trying different container.")
            ELoot.data.disk_full = true
          end
        end
      end

      # If we are still here lets see if a sack type was identified
      if ELoot.data.sacks[item.type] && !ELoot.data.sacks_full.include?(ELoot.data.sacks[item.type])
        result = Inventory.store_item(ELoot.data.sacks[item.type], item)
        if result
          ELoot.box_phase(item) if phase_thing
          return
        end
        # inform user it didn't fit
        ELoot.msg("info", " The #{item} won't fit in the #{ELoot.data.sacks[item.type]}. Trying default container.")
      end

      # Still here? Try the default
      if !ELoot.data.sacks_full.include?(ELoot.data.sacks["default"])
        result = Inventory.store_item(ELoot.data.sacks["default"], item)

        if result
          ELoot.box_phase(item) if phase_thing
          return
        end
      end

      # inform user it didn't fit
      ELoot.msg("info", " The #{item} won't fit in the #{ELoot.data.sacks["default"]}. Trying overflow container.")

      # try the overflow
      if ELoot.data.settings[:overflow_container].empty?
        ELoot.msg("info", " You have not set an OVERFLOW container.")
        ELoot.msg("info", " You're carrying too much stuff. Unload a bit! Exiting...")
        exit
      else
        result = Inventory.store_item(ELoot.data.sacks[ELoot.data.settings[:overflow_container]], item)
        if result
          ELoot.box_phase(item) if phase_thing
          return
        end
      end

      # inform user it didn't fit
      ELoot.msg("info", " The #{item} won't fit in the #{ELoot.data.sacks[ELoot.data.settings[:overflow_container]]}. Trying secondary overflow container.")

      # try secondary overflow
      if ELoot.data.settings[:secondary_overflow].empty?
        ELoot.msg("info", " You have not set a Secondary OVERFLOW container.")
        ELoot.msg("info", " You're carrying too much stuff. Unload a bit! Exiting...")
        exit
      else
        result = Inventory.store_item(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]], item)
        if result
          ELoot.box_phase(item) if phase_thing
          return
        end
        ELoot.msg("info", " Your Secondary OVERFLOW container cannot hold this item.")
        ELoot.msg("info", " You're carrying too much stuff. Unload a bit! Exiting...")
        exit
      end
    end

    def self.single_loot(item) # loots a single item
      # Fixme - cleanup
      return if item.nil?

      if ELoot.data.sacks[item.type] && !ELoot.data.sacks_full.include?(ELoot.data.sacks[item.type])
        bag = ELoot.data.sacks[item.type]
      else
        bag = ELoot.data.sacks["default"]
      end

      Inventory.check_auto_closer

      loop {
        lines = fput "loot ##{item.id}"
        if lines =~ /You can't.*?It's closed!/ && GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)
          # Must be an auto closer. Their ID and contents don't drop from GameObj.container when closed
          ELoot.data.settings[:auto_close].push(bag.name)
          Inventory.open_single_container(bag)
          ELoot.msg("info", " #{bag.name} must be an autocloser, adding to list.")
          ELoot.save_profile()
          next
        else
          break
        end
      }

      20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and ELoot.data.sacks[item.type].contents.to_a.map(&:id).include?(item.id))
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and ELoot.data.sacks["default"].contents.to_a.map(&:id).include?(item.id))
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and item.type =~ /skin/)

        sleep 0.1
      }

      ELoot.msg("debug", "Inventory.single_loot: opening bag")
      # Still here? Bag must be closed
      Inventory.open_single_container(bag)

      # Now that the bags open lets try again
      fput "loot ##{item.id}"

      10.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and ELoot.data.sacks[item.type].contents.to_a.map(&:id).include?(item.id))
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and ELoot.data.sacks["default"].contents.to_a.map(&:id).include?(item.id))

        sleep 0.1
      }

      # Still here? inform user it didn't fit
      ELoot.msg("info", " The #{item} wasn't looted. Trying overflow container.")

      # still here so try overflow
      if ELoot.data.settings[:overflow_container].empty?
        ELoot.msg("info", " You have not set an OVERFLOW container.")
        ELoot.msg("info", " You're carrying too much stuff. Unload a bit! Exiting...")
        exit
      else
        result = Inventory.store_item(ELoot.data.sacks[ELoot.data.settings[:overflow_container]], item)
        if result
          ELoot.box_phase(item)
          return
        end
      end

      # inform user it didn't fit
      ELoot.msg("info", " The #{item} won't fit in the #{ELoot.data.sacks[ELoot.data.settings[:overflow_container]]}. Trying secondary overflow container.")

      # try secondary overflow
      if ELoot.data.settings[:secondary_overflow].empty?
        ELoot.msg("info", " You have not set a Secondary OVERFLOW container.")
        ELoot.msg("info", " You're carrying too much stuff. Unload a bit! Exiting...")
        exit
      else
        result = Inventory.store_item(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]], item)
        if result
          ELoot.box_phase(item)
          return
        end
        ELoot.msg("info", " Your Secondary OVERFLOW container cannot hold this item.")
        ELoot.msg("info", " You're carrying too much stuff. Unload a bit! Exiting...")
        exit
      end
    end

    def self.store_item(bag, item, is_skinner = false)
      # Fixme - cleanup
      return if item.nil? || item.name == "Empty"

      Inventory.check_auto_closer

      lines = ELoot.get_command("_drag ##{item.id} ##{bag.id}", /You|Spreading your wings|I could not find what you were referring to|Draping the|Heedful of your surroundings|won't fit|crumbles? and decays? away|That is not yours|Hey, that belongs to .+\.  Get yer own disk\!|Get what\?/i)

      return true if lines.any? { |l| l =~ /You are unable to handle the additional load|That is not yours|Hey, that belongs to .+\.  Get yer own disk\!|Get what\?/ }

      if lines.any? { |l| l =~ /put something that you can't hold/ }
        ELoot.unlootable(item)
        return true
      end

      if lines.any? { |l| l =~ /You can't.*?It's closed!/ }
        if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)
          # Must be an auto closer. Their ID and contents don't drop from GameObj.container when closed
          ELoot.data.settings[:auto_close].push(bag.name)
          ELoot.msg("info", " #{bag.name} must be an autocloser, adding to list.")
          ELoot.save_profile()
        end
        ELoot.get_res("open ##{bag.id}", ELoot.data.silent_open)
        Inventory.store_item(bag, item, is_skinner)
      end

      # False positive?
      if lines.any? { |l| l =~ /I could not find what you were referring to/i }
        return true
      end

      # Check if full
      if lines.any? { |l| l =~ /won't fit/i }
        ELoot.data.sacks_full.push(bag)
        return false
      end

      if lines.any? { |l| l =~ /crumbles? and decays? away/i }
        ELoot.msg("info", " This item was crumbly, adding to list")
        ELoot.data.settings[:crumbly].push(item.name)
        ELoot.save_profile()
        return true
      end

      20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) && bag.contents.to_a.map(&:id).include?(item.id))

        # Lousy weapon displayers don't have contents
        if is_skinner
          return true if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
        end
        sleep 0.1
      }

      # Still here? Assume bag is closed
      ELoot.msg("debug", "Inventory.single_loot: opening bag")
      Inventory.open_single_container(bag)

      # Try it again
      fput "_drag ##{item.id} ##{bag.id}"

      10.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) && bag.contents.to_a.map(&:id).include?(item.id))

        sleep 0.1
      }

      # Give up and return false
      return false
    end

    def self.stow_ready_list(ready_item, item)
      if ELoot.data.ready_method[ready_item] =~ /put in sheath/
        Inventory.open_single_container(ELoot.data.ready_list["sheath"])
      elsif ELoot.data.ready_method[ready_item] =~ /put in secondary/
        Inventory.open_single_container(ELoot.data.ready_list["2sheath"])
      end

      ELoot.get_res("store #{ready_item}", /You|Spreading your wings|Draping the|Heedful of your surroundings|Reaching over your shoulder/)

      20.times {
        return true if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)

        sleep 0.1
      }

      return false
    end
  end # End of Inventory

  # Loot handles the room looting for ELoot
  module Loot
    def self.bag_loot(bag) # loots bags dropped from critters that have treasure in them
      return if ELoot.data.checked_bags.include?(bag.id)

      lines = ELoot.get_lines("open ##{bag.id}", /crumbles? and decays? away|<exposeContainer|That is already open|<container|There doesn't seem to be any way to do that|I could not find what you were referring to/)

      if lines.any? { |l| l =~ /crumbles? and decays? away/i }
        unless bag.name =~ /bandana|flowing robes/
          ELoot.msg("info", " #{bag} was crumbly, adding to list")
          ELoot.data.settings[:crumbly].push(bag.name)
          ELoot.save_profile()
        end
        return "crumbly"
      end

      if lines.any? { |line| line =~ /There doesn't seem to be any way to do that|I could not find what you were referring to/i }
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      lines = ELoot.get_lines("look in ##{bag.id}", /<container|That is closed/)

      # False positive?
      if lines.any? { |line| line =~ /I could not find what you were referring to/i }
        return false
      end

      objs = Loot.reject_invalid_loot(bag.contents)

      if objs.empty?
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      objs = Loot.loot_specials(objs)

      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      if objs.empty?
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      Loot.loot_regular(objs)

      ELoot.data.checked_bags.push(bag.id)
    end

    def self.box_loot(box, location = nil, data = nil) # Loots box contents
      if box.type == "box"
        line = ELoot.get_res("open ##{box.id}", /open|locked/)
        return Inventory.single_drag(box) if line =~ /locked/

        if ELoot.data.settings[:display_box_contents]
          ELoot.get_res("look in ##{box.id}", ELoot.data.look_regex)
        else
          ELoot.get_lines("look in ##{box.id}", ELoot.data.look_regex)
        end

        if box.contents.any? { |obj| obj.name =~ /silver coins/ }
          start_silvers = ELoot.silver_check
          res = ELoot.get_res("get coins from ##{box.id}", /You gather the remaining|Get what\?/)
          ELoot.msg("info", " Unknown get coin result") if res !~ /You gather the remaining/
          sleep 0.5
          waitrt?
          data[location] += ELoot.silver_check - start_silvers
        end

        objs = box.contents
        if objs.empty?
          Sell.save_trash_box(box)
          return
        end

        objs = Loot.loot_specials(objs)

        # Anything left after boxes, collectibles, and uncommon weapon/armor?
        if objs.empty?
          Sell.save_trash_box(box)
          return
        end

        Loot.loot_regular(objs, "Box", box)
        Sell.save_trash_box(box)
      elsif box.type == "plinite"
        ELoot.get_res("pluck ##{box.id}", /You carefully pluck/)
        Inventory.free_hands(both: true)
      end
    end

    def self.loot_all(items) # loots entire room
      waitrt?

      Inventory.check_auto_closer

      Inventory.free_hand

      res = ELoot.get_command('loot room', /<dialogData|There is no loot|You need a free hand to do that|With a discerning eye|You note some treasure of interest|You can't.*?It's closed!/)

      if res.any? { |l| l =~ /There is no loot/ }
        items.each { |item| ELoot.unlootable(item) }
        return true
      end

      if res.any? { |l| l =~ /You can't.*?It's closed!/ }

        items_opened = Array.new
        items.each { |item|
          if ELoot.data.sacks[item.type] && !ELoot.data.sacks_full.include?(ELoot.data.sacks[item.type])
            bag = ELoot.data.sacks[item.type]
          else
            bag = ELoot.data.sacks["default"]
          end

          next if items_opened.include?(bag.name)

          items_opened.push(bag.name)

          if GameObj.containers.keys.include?(bag.id) && bag.contents.is_a?(Array)
            # check if open
            lines = ELoot.get_lines("look in ##{bag.id}", ELoot.data.look_regex)

            if lines.any? { |l| l =~ /That is closed./ }
              # This must be our lousy autocloser
              ELoot.data.settings[:auto_close].push(bag.name)
              ELoot.msg("info", " #{bag.name} must be an autocloser, adding to list.")
              ELoot.save_profile()
            end
          end
        }

      end

      # Didn't get it all?...something in-hand?
      if res.any? { |l| l =~ /(?:gather|pick) up and stow (?:what|as much) treasure .+ manage|but quickly realize|before realizing you have no room/ }
        Inventory.single_drag(GameObj.right_hand) if items.any? { |thing| thing.id == GameObj.right_hand.id }
        Inventory.single_drag(GameObj.left_hand) if items.any? { |thing| thing.id == GameObj.left_hand.id }

        # Anything left?
        objs = Loot.reject_invalid_loot(GameObj.loot.to_a)
        return if objs.empty?

        # Still here so rerun Loot.room
        Loot.room

      end
    end

    def self.loot_regular(objs, from_where = nil, box = nil)
      valid = Loot.valid_objs(objs.clone)
      invalid = Loot.invalid_objs(objs.clone)

      ELoot.msg("debug", " Loot.room - valid: #{valid}")
      ELoot.msg("debug", " Loot.room - invalid: #{invalid}")

      # Is there anything else we care about?
      if valid.empty? && !invalid.empty?
        invalids = []
        invalid.each { |t| invalids.push(t.name) unless valid.include?(t) }
        ELoot.msg("info", " Left the following invalid lootables: #{invalids.join(', ')}.") if !invalids.empty?
      elsif invalid.empty? && !valid.empty?
        # Make sure we have a hand free
        Inventory.free_hand
        ELoot.msg("debug", " Loot.loot_regular: Calling Loot.loot_all")

        if from_where == "Room"
          Loot.loot_all(valid)
        elsif from_where == "Box"
          res = ELoot.get_res("loot ##{box.id}", /You search through|You can't.*?It's closed!|There is no loot/i)
          ELoot.msg("info", " Failed to LOOT box") if res.nil?

          sleep(0.10)

          if box.contents.length.positive?
            lootsack = ELoot.data.sacks['default']
            res = dothistimeout("empty ##{box.id} in ##{lootsack.id}", 3, /You try to empty/)
            sleep 0.5
            waitrt?
            if res.nil?
              ELoot.msg("info", " Failed to EMPTY box")
              ELoot.msg("info", " Exiting the script to handle yourself")
              fput "look in ##{box.id}"
              exit
            end
          end
        else
          # Make sure we have a hand free
          Inventory.free_hand
          valid.each do |thing|
            Inventory.single_drag(thing)
          end
        end
      else
        # Make sure we have a hand free
        Inventory.free_hand
        if from_where == "Room"

          valid.each do |obj|
            if obj.type !~ /clothing|jewelry|gem|herb|skin|wand|scroll|potion|reagent|trinket|lockpick|treasure|forageable|magic|collectible/

              Inventory.single_drag(obj)
            else
              Inventory.single_loot(obj)
            end
          end
        else
          valid.each do |thing|
            Inventory.single_drag(thing)
          end
        end
        invalids = []
        invalid.each { |t| invalids.push(t.name) unless valid.include?(t) }
        ELoot.msg("info", " Left the following invalid lootables: #{invalids.join(', ')}.") if !invalids.empty?
      end

      ELoot.msg("debug", " Loot.loot_regular: End of method")
    end

    def self.loot_specials(objs)
      # Open sacks for looting the room
      Inventory.open_loot_containers(objs)

      # Boxes go first. If handled, we reject them since they're already looted.
      types = ["box", "clothing", "collectible", "cursed", "jewelry", "food"]

      objs = objs.reject do |thing|
        result = Loot.bag_loot(thing) if thing.type =~ /clothing/

        next true if result == "crumbly"
        next false if ELoot.data.settings[:loot_exclude].length.positive? && thing.name.match(Regexp.union(ELoot.data.exclude))
        next false if (thing.name.eql?("shard of oblivion quartz") and Char.level.eql?(100) && ELoot.data.settings[:loot_types].include?("gem"))
        next false if (thing.name =~ /doomstone|urglaes fang/ && !ELoot.data.settings[:loot_types].include?("cursed"))

        unless (thing.type =~ Regexp.union(ELoot.data.settings[:loot_types]) && thing.type =~ Regexp.union(types)) \
          || (ELoot.data.settings[:loot_keep].length.positive? && thing.name =~ Regexp.union(ELoot.data.settings[:loot_keep])) \
          || (thing.type =~ /cursed/i && ELoot.data.settings[:loot_types].include?("cursed")) \
          || (thing.type =~ /weapon/i && thing.type =~ /uncommon/) && ELoot.data.settings[:loot_types].include?("weapon") \
          || (thing.type =~ /armor/i && thing.type =~ /uncommon/) && ELoot.data.settings[:loot_types].include?("armor") \
          || (thing.name =~ /orb/ && thing.type =~ /magic/ && ELoot.data.settings[:loot_types].include?("magic")) \
          || (thing.name =~ /silver coin/ && ELoot.data.settings[:loot_types].include?("coins"))

          next false
        end

        if thing.name =~ /silver coin/
          ELoot.get_res("get coins", /you gather/i)
        else
          # Make sure we have a hand free
          Inventory.free_hand
          Inventory.single_drag(thing) if ELoot.decurse(thing)
        end

        next true
      end

      ELoot.msg("debug", " Loot.loot_specials: After specials check")

      return objs
    end

    def self.occassional_skinner(obj)
      # Fixme: leave this? edge case
      if obj.name =~ /rotting chimera/
        lines = ELoot.get_lines("describe chimera", /The twisted and confused form/)
        if lines.any? { |line| line =~ /A huge scorpion tail rises high from the rear/ }
          return true
        end
      end

      return false
    end

    def self.reject_invalid_loot(objs) # rejects items from the GamObj.loot object
      objs.reject do |obj|
        next if ELoot.data.settings[:loot_keep].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:loot_keep])

        obj.name =~ /\bsevered\b|rotting tree stump|jagged crater|rolton droppings|point of elemental instability|child/i ||
          obj.id.to_i.negative? ||
          (obj.type =~ /weapon|armor/i && obj.type !~ /uncommon|clothing/i) ||
          obj.noun =~ /^(?:disk|coffin|gangplank|muck|space|cloud|kitten|puppy|mist|door|staircase|maw|cyclone)$/ ||
          (ELoot.data.settings[:unlootable].include?(obj.name) && ELoot.data.settings[:log_unlootables]) ||
          obj.name =~ /\b(?:vine|bramble|widgeonweed|vathor club|swallowwort|smilax|creeper|briar|ivy|tumbleweed|slender silvery thread|slippery wooden chute|sealed fissure|massive icicle)\b/i ||
          ELoot.data.settings[:crumbly].index(obj.name) > -1
      end
    end

    def self.should_grab_item?(thing)
      # If its on the exclude list return
      return false if !ELoot.data.settings[:loot_exclude].empty? && thing.name.match(Regexp.union(ELoot.data.exclude))

      # oblivion quartz isn't cursed if you are level 100
      return true  if thing.name.eql?("shard of oblivion quartz") and Char.level.eql?(100) && ELoot.data.settings[:loot_types].include?("gem")

      # Cursed items need to be handled separate due to gems
      return false if thing.type =~ /cursed/i && !ELoot.data.settings[:loot_types].include?("cursed")

      # Keep it if it's a type we want
      return true if thing.type =~ Regexp.union(ELoot.data.settings[:loot_types])

      # If the type is something we don't want return false
      not_wanted = ELoot.data.all_loot_categories - ELoot.data.settings[:loot_types]
      return false if thing.type =~ Regexp.union(not_wanted)

      # Anything left lets take
      return true
    end

    def self.valid_objs(objs) # finds valid loot
      objs.select { |o| self.should_grab_item?(o) }
    end

    def self.invalid_objs(objs) # finds non-valid loot
      objs.reject { |o| self.should_grab_item?(o) }
    end

    def self.room # method that loots the room
      objs = Loot.reject_invalid_loot(GameObj.loot.to_a)

      unless objs.empty?
        objs = loot_specials(objs)
      end

      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      unless objs.empty?
        Loot.loot_regular(objs, "Room")
      end
    end

    def self.search(objs = GameObj.dead.to_a) # searches dead critters
      return if objs.empty?

      inhand_critters = /skayl|glacei|tumbleweed|plant|shrub|creeper|vine|bush|caedera|golem|elemental/

      objs.each do |thing|
        next if (ELoot.data.settings[:critter_exclude].length.positive? && thing.name =~ Regexp.union(ELoot.data.settings[:critter_exclude]))
        next if thing.status =~ /gone/

        ELoot.change_stance('defensive') if ELoot.data.settings[:loot_defensive]

        if thing.name =~ inhand_critters
          Inventory.free_hand
          if GameObj.right_hand.id.nil? && GameObj.left_hand.id.nil?
            free_hand = "left"
          else
            free_hand = GameObj.right_hand.id.nil? ? "right" : "left"
          end

        end

        # Loot it
        3.times do
          waitrt?
          res = dothistimeout("loot ##{thing.id}", 1, /You (search|plunge|break)|not in any condition|see well enough to search|You can only loot creatures/)
          break if res =~ /You (search|plunge|break)|not in any condition|see well enough to search|You can only loot creatures/ || thing.status =~ /gone/ || thing.nil?
        end

        # Some creatures put an item directly in your hand
        if thing.name =~ inhand_critters
          check_hand = free_hand == "right" ? GameObj.right_hand : GameObj.left_hand

          if check_hand.name != "Empty"
            if ELoot.data.settings[:keep_closed]
              Inventory.open_single_container(ELoot.data.sacks["default"])
              Inventory.open_single_container(ELoot.data.sacks["gem"])
              Inventory.open_single_container(ELoot.data.sacks["skin"])
              Inventory.open_single_container(ELoot.data.settings[:overflow_container])
              Inventory.open_single_container(ELoot.data.settings[:secondary_overflow])
            end

            Inventory.single_drag(check_hand, false)
          end
        end
      end

      # if the setting is on always end in defensive
      ELoot.change_stance('defensive') if ELoot.data.settings[:loot_defensive]
    end

    def self.skin_obj_types(objs, type) # skins type (blunt/dagger) group of dead critters
      return if objs.empty?

      dont_stow = false
      waitrt?

      if type == :blunt
        skinner = ELoot.data.skin_blunt
        ELoot.msg("debug", " blunt skinner: #{skinner} blunt skinner.id: #{skinner.id}")
        unless skinner
          ELoot.msg("info", " No blunt weapon found. Please run setup and make sure its listed.")
          return
        end
        Inventory.free_hands(both: true)
      else
        if ELoot.data.settings[:skin_enable] && ELoot.data.skin_edged.to_s.empty?
          skinner = GameObj.right_hand
          dont_stow = true
        else
          skinner = ELoot.data.skin_edged
        end
        ELoot.msg("debug", " edged skinner: #{skinner} edged skinner.id: #{skinner.id}")
        unless skinner.id || ELoot.data.skin_edged.to_s.empty?
          skinner = GameObj.right_hand
          dont_stow = true
          ELoot.msg("info", " No edged skin weapon found. Using whatever is in your hand.")
          ELoot.msg("info", " Please run setup and make sure the sheath and weapon are listed and the weapon is inside the sheath")
        end
        Inventory.free_hand unless skinner.id == GameObj.right_hand.id || ELoot.data.skin_edged.to_s.empty?
      end

      unless [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id) || ELoot.data.skin_edged.to_s.empty?
        waitrt?
        Inventory.drag(skinner)
      end

      skinner_hand = skinner.id == GameObj.left_hand.id ? 'left' : 'right'

      # Safe to kneel?
      while GameObj.targets.empty? && ELoot.data.settings[:skin_kneel] && !kneeling?
        dothistimeout('kneel', 3, /You kneel down\.$|You move to|You are already kneeling\.$/)
      end

      # Sigil of Resolve?
      if ELoot.data.settings[:skin_resolve] &&
         Spell['Sigil of Resolve'].affordable? &&
         !Spell['Sigil of Resolve'].active?
        Spell['Sigil of Resolve'].cast
      end

      # 604 stuff
      if ELoot.data.settings[:skin_604] && Spell[604].affordable? && (!Spell[604].active? || (Spell[604].timeleft * 60).truncate() <= 10)
        until Spell[604].active? && (Spell[604].timeleft * 60).truncate() > 5
          Spell[604].cast
          sleep(0.1)
        end
      end

      skin_match = Regexp.union(
        /You skinned/i,
        /You botched/i,
        /already been/i,
        /cannot skin/i,
        /must be a member/i,
        /can only skin/i,
        /You are unable to break through/i,
        /You break through the crust of the/i,
        /You crack open a portion/i,
        /Because your account is free/i,
        /it's not possible to get a worthwhile/i,
      )

      break_match = Regexp.union(
        /You break through the crust of the .+ and withdraw (.+)!/i,
        /You crack open a portion of the .+ and uncover (.+)!/i,
      )

      # Skin em
      objs.each do |obj|
        res = dothistimeout("skin ##{obj.id} #{skinner_hand}", 2, skin_match)
        if res =~ /You cannot skin/
          ELoot.data.settings[:unskinnable].push(obj.name)
          ELoot.save_profile()
        elsif res =~ break_match
          fput "stow gem ##{GameObj.left_hand.id}"
        end
      end

      waitrt?

      return if dont_stow

      if type == :blunt
        bag = ELoot.data.ready_list["skin_sheath_blunt"].nil? ? ELoot.data.sacks["default"] : ELoot.data.ready_list["skin_sheath_blunt"]
      else
        bag = ELoot.data.ready_list["skin_sheath"].nil? ? ELoot.data.sacks["default"] : ELoot.data.ready_list["skin_sheath"]
      end

      Inventory.store_item(bag, skinner, true)

      if [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
        Inventory.store_item(ELoot.data.sacks["default"], skinner)
      end
    end

    def self.skin(objs = GameObj.dead.to_a) # determines what to skin
      objs = objs.reject do |obj|
        (ELoot.data.settings[:unskinnable].include?(obj.name) && !Loot.occassional_skinner(obj)) ||
          obj.type =~ /bandit/ ||
          obj.name =~ /(?:ethereal|ghostly|unwordly|Grimswarm)/ ||
          ELoot.data.settings[:skin_exclude].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:skin_exclude])
      end

      return if objs.empty?

      blunts = objs.find_all { |obj| obj.name =~ /krynch|stone mastiff|krag dweller|cavern urchin/i }
      normals = objs.reject { |obj| obj.name =~ /krynch|stone mastiff|krag dweller|cavern urchin/i }

      skin_obj_types(normals, :normal)
      skin_obj_types(blunts, :blunt)

      stance = checkstance
      unless standing?
        ELoot.change_stance('offensive') if GameObj.targets.empty?
        dothistimeout('stand', 3, /You stand|You quickly roll|You are already standing/) until standing?
        ELoot.change_stance(stance) if checkstance != stance
      end
    end
  end # End of Loot

  # Sell is a module that handles selling loot
  module Sell
    def self.box_in_hand
      return unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")

      # Make sure the box is in the right hand
      if GameObj.left_hand.type == "box"
        fput "swap"
      end

      box = GameObj.right_hand
      Inventory.free_hands(left: true) unless GameObj.left_hand.type == "box"
      Loot.box_loot(box)

      # Only drop if Shattered
      if XMLData.game == "GSF" && GameObj.right_hand.type == "box"
        fput "drop ##{GameObj.right_hand.id}"
      end
    end

    def self.breakdown
      return if ELoot.data.silver_breakdown.empty?
      return unless defined?(Terminal)

      total_silver = 0
      rows = []
      ELoot.data.silver_breakdown.each { |location, amount|
        total_silver += amount
        rows << [location, "   " + ELoot.format_number(amount)]
      }

      rows << :separator
      rows << ["Total", ELoot.format_number(total_silver)]

      table = Terminal::Table.new :title => "Silver Breakdown", :rows => rows # , :style => {:all_separators => true}
      table.align_column(1, :right)

      respond table

      return
    end

    def self.check_bounty
      return unless ELoot.data.settings[:sell_fwi]

      need_furrier = false
      need_gemshop = false

      if checkbounty =~ /You have been tasked to retrieve (\d+) (.*) of at least \w+ quality for (?:the )?\w+ (?:in|on|near) (?:(.*) (?:under|near|between) )?(?:the Company Store in )?([^.]+)\./
        skin = $2

        bundled_skins = skin.match(/(\w+)\s+(\w+)\s*\Z/)

        # fucked up skins
        skin = skin.strip.downcase
                   .gsub(/s$/, "")
                   .gsub(/teeth/, "tooth")
                   .gsub(/hooves?/, "hoof")
                   .gsub(/ruffs?/, "ruff")

        skin_sacks = Array.new
        skin_sacks.push(ELoot.data.sacks["skin"]) if ELoot.data.settings[:sell_container].include?("skin")
        skin_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
        if ELoot.data.settings[:sell_container].include?("overflow")
          skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
          skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
        end

        skin_sacks.each { |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ /#{skin}|#{bundled_skins}/ }.empty?

          need_furrier = true
        }
      elsif checkbounty =~ /The gem dealer in .*, .*, has received orders from multiple customers requesting (?:a|an|some) (.*).  You have been tasked to retrieve (\d+) (?:more of|of) them.  You can SELL them to the gem dealer as you find them./i
        gem = $1.chop

        gem_sacks = Array.new
        gem_sacks.push(ELoot.data.sacks["gem"]) if ELoot.data.settings[:sell_container].include?("gem")
        gem_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
        if ELoot.data.settings[:sell_container].include?("overflow")
          gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
          gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
        end

        gem_sacks.each { |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ /#{gem}/ }.empty?

          need_gemshop = true
        }
      end

      if need_furrier
        ELoot.go2(ELoot.data.local_furrier)
        start_silvers = ELoot.silver_check
        bulk_note = 0

        ELoot.msg("debug", "  check_bounty | skin_sacks: #{skin_sacks}")
        skin_sacks.each { |sack|
          next if sack.nil?
          next unless ELoot.data.settings[:sell_loot_types].include?("skin") || ELoot.data.settings[:sell_loot_types].include?("reagent")
          next if sack.contents.find_all { |obj| obj.name =~ /#{skin}|#{bundled_skins}/ }.empty?

          bulk_sell = true
          bulk_sell = false if sack.contents.find_all { |obj| obj.name =~ /bundle of/ }.length.positive?
          unless ELoot.data.settings[:sell_exclude].empty?
            if sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /furrier/ }.length.positive?
              bulk_sell = false
            end
          end

          bulk_sell = false if sack.contents.find_all { |obj| obj.name !~ /#{skin}/ && obj.sellable =~ /furrier/ }.length.positive?

          if bulk_sell
            ELoot.msg("debug", " check_bounty | bulk_sell: #{bulk_sell} using sack: #{sack}")
            Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

            # Fixme: add checks here
            dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
            Inventory.wear(sack)

            bulk_note = ELoot.read_note.to_i

            if bulk_note > 0
              ELoot.data.silver_breakdown["Furrier"] += bulk_note
            end

            sleep 0.5
          else
            sack.contents.each do |item|
              next if $sell_ignore.include?(item.id)
              next unless item.sellable =~ /furrier/
              next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/

              $sell_ignore.push(item.id)
              Inventory.drag(item)

              if item.name =~ /bundle/
                # grab the bundle ID
                bundle_id = !GameObj.right_hand.id.nil? ? GameObj.right_hand.id : GameObj.left_hand.id

                until ![GameObj.right_hand.id, GameObj.left_hand.id].include?(bundle_id)
                  # remove a skin
                  result = dothistimeout "bundle remove", 5, /You remove|Those were the last two/

                  if result =~ /Those were the last two/
                    Sell.sell_item(GameObj.right_hand, "Furrier", ELoot.data.silver_breakdown)
                    Sell.sell_item(GameObj.left_hand, "Furrier", ELoot.data.silver_breakdown)
                  else
                    # get the skin id
                    skin = GameObj.right_hand.id != bundle_id ? GameObj.right_hand : GameObj.left_hand
                    # Sell.sell_item(skin)
                    Sell.sell_item(skin, "Furrier", ELoot.data.silver_breakdown)
                  end

                end

              else
                Sell.sell_item(item, "Furrier", ELoot.data.silver_breakdown)
                # Sell.sell_item(item)
              end
            end
          end

          Inventory.free_hands(both: true)
          ELoot.msg("debug", "  check_bounty | bottom of each using sack: #{sack}")
        }

        ELoot.data.silver_breakdown["Furrier"] += (ELoot.silver_check - start_silvers)
      end

      if need_gemshop
        ELoot.go2(ELoot.data.local_gemshop)
        start_silvers = ELoot.silver_check
        bulk_note = 0

        Inventory.free_hands(both: true)

        gem_sacks.each { |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ /#{gem}/ }.empty?

          bulk_sell = true
          bulk_sell = false if sack.contents.find_all { |obj| obj.name !~ /#{gem}/ && obj.type =~ /gem/ }.length.positive?
          unless ELoot.data.settings[:sell_exclude].empty?
            if sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /gemshop/ }.length.positive?
              bulk_sell = false
            end
          end
          # Bulk sell sack if it has gems and no exclusions
          if bulk_sell
            Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?
            dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
            Inventory.wear(sack)
            sleep 0.5
            bulk_note = ELoot.read_note.to_i
            if bulk_note > 0
              ELoot.data.silver_breakdown["Gemshop"] += bulk_note
            end

            Inventory.free_hands(both: true)

          else
            sack.contents.each do |item|
              next unless item.name =~ /#{gem}/

              Inventory.drag(item)
              Sell.sell_item(item, "Gemshop", ELoot.data.silver_breakdown)
              Inventory.free_hands(both: true)
            end
          end
        }

        ELoot.data.silver_breakdown["Gemshop"] += (ELoot.silver_check - start_silvers)

      end
    end

    def self.glam_and_shroud
      glam = Spell[1205]
      shroud = Spell[1212]

      if glam.known? && glam.affordable? && Effects::Spells.time_left("Glamour") < 1
        wait_until { glam.affordable? }
        glam.cast(Char.name)
      end

      if shroud.known?
        shroud_races = ['human',
                        'giantman',
                        'half-elf',
                        'sylvankind',
                        'dark elf',
                        'elf',
                        'dwarf',
                        'halfling',
                        'forest gnome',
                        'burghal gnome',
                        'half-krolvin',
                        'erithian',
                        'aelotoi']
        shroud_race_hash = { "vo"  => "human",
                             "ifw" => "dwarf",
                             "wl"  => "human",
                             "imt" => "halfling",
                             "rr"  => "human",
                             "kf"  => "human",
                             "en"  => "elf",
                             "ti"  => "dwarf",
                             "zl"  => "dwarf" }
        town = Room[Room.current.find_nearest_by_tag("town")]
        town_key = town.image.split("-")[0]
        if town.image =~ /zul/i
          town_key = "zl"
        end
        desired_race = shroud_race_hash[town_key]

        lines = ELoot.get_lines("fame", /<output class="mono"\/>/)

        if lines.any? { |line| line =~ /You are a level (?:\d+) ([\w\- ]+) (?:[\w\- ]+)\./ }
          current_race = $1.downcase()
          current_race_setting = shroud_races.index(current_race) + 1
        end

        return true if current_race == desired_race

        race_setting = shroud_races.index(desired_race) + 1
        if Effects::Spells.time_left("Shroud of Deception") < 2
          waitcastrt?
          wait_until { shroud.affordable? }
          shroud.cast(Char.name)
        end

        lines = ELoot.get_lines("shroud profile", /You are currently using profile/)

        if lines.any? { |line| line =~ /You are currently using profile <d cmd='shroud view [0-9]+'>([0-9]+)<\/d>./ }
          shroud_profile = $1
        end

        before_dying { fput("shroud set #{shroud_profile} race #{current_race_setting}") }
        fput("shroud set #{shroud_profile} race #{race_setting}")
      end
    end

    def self.save_trash_box(box)
      # Lets not toss Reliquaries
      if box.name =~ /reliquary/i
        Inventory.single_drag(box, false)
        return
      end

      ELoot.msg("debug", " save_trash_box(box): looking for a trashcan")
      trash = ELoot.find_trash

      unless trash
        # going here because they have trash cans. Don't want to litter
        ELoot.go2('locksmith pool')
        trash = ELoot.find_trash
      end

      if ELoot.data.settings[:sell_loot_types].include?("box") && box.name =~ /gold|mithril|silver/ && !box.contents.find { |obj| obj.type =~ /cursed/ }
        ELoot.msg("debug", " save_trash_box(box): inside first if")
        if !box.contents.empty?
          box.contents.each { |item|
            Inventory.drag(item)
            fput("put ##{item.id} in ##{trash.id}")
            sleep(0.5)
            if [GameObj.right_hand.id, GameObj.left_hand.id].include?(item.id)
              ELoot.msg("info", " #{item.name} isn't gone so maybe its special...keepin it.")
              Inventory.single_drag(item)
            end
          }
        end
        Inventory.single_drag(box, false)
        return
      end

      if trash.nil?
        fput("drop ##{box.id}")
      else
        ELoot.msg("debug", " save_trash_box(box): putting it in trash")
        # use a loop, dothistimeout and a timer - getting stuck with a ...wait after getting coins
        t = Time.now + 3
        loop {
          dothistimeout "put ##{box.id} in ##{trash.id}", 1, /As you place|If you wish to continue/
          if ![GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id) || Time.now > t
            break
          end
        }
      end

      fput("drop ##{box.id}") if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
    end

    def self.dump_herbs_junk
      # What stuff are we supposed to dump?
      dump_stuff = Array.new
      ["herb", "junk", "food"].each { |item|
        if ELoot.data.settings[:sell_loot_types].include?(item)
          dump_stuff.push(item)
        end
      }

      # Return if nothing
      if dump_stuff.empty?
        return
      end

      # Do we have anything to dump?
      dump_items = Array.new
      sacks = [ELoot.data.sacks["default"], ELoot.data.sacks[ELoot.data.settings[:overflow_container]], ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]]]
      sacks.each { |sack|
        sack.contents.each { |item|
          if item.type =~ Regexp.union(dump_stuff) || (ELoot.data.alchemy_mode && item.name =~ /^some ground|flask of pure water|some powdered|some mashed|handful of sea salt|spirit shard|tincture of/)
            if ELoot.data.alchemy_mode
              next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
            end
            dump_items.push(item)
          end
        }
      }

      # No items to dump so return
      if dump_items.empty?
        return
      end

      # Is there a trash can here?
      trash = ELoot.find_trash

      unless trash
        # going here because they have trash cans. Don't want to litter
        ELoot.go2('locksmith pool')
        trash = ELoot.find_trash
      end

      if trash.nil?
        ELoot.msg("info", " No trashcan found! Skipping herb/junk/food disposal so as not to litter and be a pest.")
        return
      end

      dump_items.each { |item|
        Inventory.drag(item)
        fput("put ##{item.id} in ##{trash.id}")
        sleep(0.25)
        if [GameObj.right_hand.id, GameObj.left_hand.id].include?(item.id)
          ELoot.msg("info", " #{item.name} isn't gone so maybe its special...keepin it.")
          Inventory.single_drag(item)
        end
      }

      Inventory.free_hands(both: true)
    end

    def self.appraise(item, location, _data = nil)
      return if item.type =~ /jewelry/ && location == "pawnshop"

      amount = 0
      raw = nil

      limit = location =~ /gemshop/i ? ELoot.data.settings[:sell_appraise_gemshop] : ELoot.data.settings[:sell_appraise_pawnshop]

      high_value = /not buying anything this valuable today/
      denied = Regexp.union(
        /That thing's worth less/,
        /Can't say I'm interested/,
        /That's basically worthless here/,
        /He hands it back to you, saying/,
        /Not my line, really/,
        /not quite my field/,
        /only deal in gems and jewelry/,
        /There is nothing of value to me/,
        /Trying to pull a fast one on old Hortemeyer, are you\?/,
        /no use for that/,
        /Appraise what\?\?\?/,
      )
      appraised = /([,0-9]+) (?:silver|for it if you want to sell|for this if you'd like)/
      sold = Regexp.union(
        /(?:pays|hands) you [,0-9]+ silver/,
        /I don't have that much spare silver, I will have to give you a bank note for it/,
        /I'm afraid I don't have that much silver on hand.+so I'll have to give you a .+ for it./,
      )
      item_selling_match = Regexp.union(high_value, denied, appraised, sold)

      res = dothistimeout "appraise ##{item.id}", 3, item_selling_match

      if res =~ appraised
        raw = $1
        amount = $1.delete(",").to_i
      end

      if amount > limit.to_i
        ELoot.msg("info", " The #{item} appraises for #{raw}. That's above your settings.")
        Inventory.single_drag(item)
      elsif amount <= limit.to_i && amount != 0
        Sell.sell_item(item, location, ELoot.data.silver_breakdown)
      # Sell.sell_item(item)
      else
        Inventory.single_drag(item)
      end
    end

    def self.locksmith_pool(boxes, deposit = false)
      # if we're here, assume we emptied out the disk some
      ELoot.data.disk_full = false

      if boxes.length.positive?
        ELoot.silver_withdraw(8000)
      end

      ELoot.go2('locksmith pool')

      worker = ELoot.find_worker

      Inventory.free_hands(both: true)
      ELoot.wait_for_disk

      boxes.each do |box|
        lines = ELoot.get_lines("look in ##{box.id}", /<container|That is closed|You see the shifting form/)

        next unless lines.any? { |line| line =~ /That is closed|You see the shifting form/i }

        Inventory.drag(box)

        box = ELoot.box_unphase(box)

        percent = ELoot.data.settings[:sell_locksmith_pool_tip_percent] ? ' PERCENT' : ''

        match = /You want a locksmith|You don't have that much|takes your|already holding as many boxes|already (unlocked|open)/
        result = dothistimeout("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}", 3, match)

        if result =~ /already (unlocked|open)/
          Loot.box_loot(box, "Locksmith Pool", ELoot.data.silver_breakdown)
        else
          res = dothistimeout("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}", 3, match)
          if res =~ /Your tip of (.*) silvers?/
            ELoot.data.silver_breakdown["Locksmith Pool"] += -1 * $1.delete(",").to_i
          end
          if res =~ /You don't have that much/
            ELoot.silver_withdraw(8000)
            ELoot.go2('locksmith pool')
            fput("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}")
            dothistimeout("give ##{worker.id} #{ELoot.data.settings[:sell_locksmith_pool_tip]}#{percent}", 3, match)
            if res =~ /Your tip of (.*) silvers?/
              ELoot.data.silver_breakdown["Locksmith Pool"] += -1 * $1.delete(",").to_i
            end
          elsif res =~ /already holding as many boxes/
            sleep(0.250)
            Inventory.single_drag(box)
            break
          elsif res =~ /already (unlocked|open)/
            Loot.box_loot(box, "Locksmith Pool", ELoot.data.silver_breakdown)
          end
        end
        sleep(0.250)
        Inventory.single_drag(box) if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
      end

      # Return if its just drop off
      return if deposit

      # retrieve (and loot) any boxes in the pool
      loop do
        match = /We don't have any boxes ready for you|We don't seem to have that box|Alright, here's your|You need to lighten your load first/
        res = dothistimeout("ask ##{worker.id} for return", 3, match)
        # no more boxes left
        break if res !~ /Alright, here's your|You need to lighten your load first/

        if res =~ /You need to lighten your load first/
          ELoot.msg("debug", " Too much weight! Depositing coins and trying again")
          room = Room.current.id
          ELoot.silver_deposit
          ELoot.go2(room)
        else
          box = nil
          if GameObj.right_hand.type =~ /box|plinite/
            box = GameObj.right_hand
          elsif GameObj.left_hand.type =~ /box|plinite/
            box = GameObj.left_hand
          else
            ELoot.msg("error", " Failed to find the box you were supposed to get; report this to Elanthia-Online")
          end

          Loot.box_loot(box, "Locksmith Pool", ELoot.data.silver_breakdown)
        end

        sleep(0.250)
      end
    end

    def self.locksmith(boxes)
      # if we're here, assume we emptied out the disk some
      ELoot.data.disk_full = false

      ELoot.silver_withdraw(8000)

      ELoot.go2('locksmith')
      move "east" if Room.current.uid.include?(7118381)
      ELoot.wait_for_disk

      if (table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /(?:table|counter)$/ })
        dothistimeout("look on ##{table.id}", 3, /On the/) if table.contents.nil?

        if table.contents.nil?
          error('failed to find table contents')
        else
          activator = nil
          if table.contents.any? { |obj| obj.noun == 'bell' }
            activator = 'ring bell'
          elsif table.contents.any? { |obj| obj.noun == 'keys' }
            activator = 'pull keys'
          elsif table.contents.any? { |obj| obj.noun == 'chime' } || GameObj.loot.any? { |obj| obj.noun == 'chime' }
            activator = 'ring chime'
          end

          if activator
            boxes.each { |box|
              Inventory.free_hands(both: true)
              Sell.locksmith_open(box, activator)
            }
          else
            ELoot.msg("error", " Failed to find a bell, keys, or chime on the table")
          end
        end
      else
        ELoot.msg("error", " Failed to find a table")
      end
    end

    def self.locksmith_open(box, activator)
      lines = ELoot.get_lines("look in ##{box.id}", /<container|That is closed|You see the shifting form/)
      return unless lines.any? { |line| line =~ /That is closed|You see the shifting form/i }

      Inventory.drag(box)
      box = ELoot.box_unphase(box)

      res = dothistimeout(activator, 3, /Gimme ([\d,]+) silvers/)
      if res =~ /Gimme ([\d,]+) silvers/
        ELoot.data.silver_breakdown["Locksmith Pool"] += -1 * $1.delete(",").to_i
      end
      ELoot.msg "info", 'unknown locksmith response' unless res

      res = dothistimeout('pay', 3, /accepts|have enough/)
      if res =~ /have enough/
        Inventory.single_drag(box, false)
        ELoot.silver_withdraw(8000)
        ELoot.go2('locksmith')

        return Sell.locksmith_open(box, activator)
      end

      Loot.box_loot(box, "Locksmith", ELoot.data.silver_breakdown)
    end

    def self.gold_rings
      return unless ELoot.data.settings[:sell_gold_rings]

      ELoot.go2("chronomage")

      Inventory.free_hands(both: true)

      unless (npc = GameObj.npcs.find { |n| n.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant|guard/ })
        npc = GameObj.room_desc.find { |n| n.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant|guard/ }
      end

      unless npc.nil?
        chrono_sacks = Array.new
        chrono_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
        if ELoot.data.settings[:sell_container].include?("overflow")
          chrono_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
          chrono_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
        end

        chrono_sacks.each { |sack| Inventory.open_single_container(sack) }

        chrono_sacks.each { |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ ELoot.data.regex_gold_rings }.empty?

          sack.contents.each do |item|
            next if $sell_ignore.include?(item.id)
            next unless item.name =~ ELoot.data.regex_gold_rings

            $sell_ignore.push(item.id)
            Inventory.drag(item)
            # Fixme: add checks
            fput "give ##{item.id} to ##{npc.id}"

            20.times {
              break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))

              sleep 0.1
            }

            Inventory.free_hands(both: true)
          end
        }
      end
    end

    def self.collectibles
      return unless ELoot.data.settings[:sell_collectibles]

      places = Array.new
      places.push(Room.current.find_nearest_by_tag("collectible")) unless Room.current.find_nearest_by_tag("collectible").nil?
      places.push(Room.current.find_nearest_by_tag("collectibles")) unless Room.current.find_nearest_by_tag("collectibles").nil?

      go_place = Room.current.find_nearest(places)

      ELoot.go2(go_place)

      Inventory.free_hands(both: true)

      # Lousy autoclosers
      Inventory.check_auto_closer

      ELoot.data.sacks.keys.each { |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        ELoot.data.sacks[item].contents.each { |thing|
          next if $sell_ignore.include?(thing.id)
          next unless thing.type == "collectible"
          next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
          next if (thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
          next if thing.name =~ /bound/

          $sell_ignore.push(thing.id)
          Inventory.drag(thing)
          dothistimeout("deposit ##{thing.id}", 3, /You hand your/)

          20.times {
            break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(thing.id))

            sleep 0.1
          }

          Inventory.free_hands(both: true)
        }
      }
    end

    def self.furrier
      ELoot.go2("furrier")
      start_silvers = ELoot.silver_check
      bulk_note = 0

      Inventory.free_hands(both: true)

      skin_match = /You have been tasked to retrieve (\d+) (.*) of at least \w+ quality for (?:the )?\w+ (?:in|on|near) (?:(.*) (?:under|near|between) )?(?:the Company Store in )?([^.]+)\./

      skin_sacks = Array.new
      skin_sacks.push(ELoot.data.sacks["skin"]) if ELoot.data.settings[:sell_container].include?("skin")
      skin_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      # Lousy autoclosers
      Inventory.check_auto_closer

      ELoot.msg("debug", " skin_sacks: #{skin_sacks}")
      skin_sacks.each { |sack|
        ELoot.msg("debug", " Beginning of skin_sack.each: #{sack}")
        next if sack.nil?
        next unless ELoot.data.settings[:sell_loot_types].include?("skin") || ELoot.data.settings[:sell_loot_types].include?("reagent")
        next if sack.contents.find_all { |obj| obj.sellable =~ /furrier/ }.empty?

        ELoot.msg("debug", " Contents after next: #{sack.contents} using sack: #{sack}")
        bulk_sell = true
        bulk_sell = false if bounty? =~ skin_match && sack.contents.find_all { |obj| obj.name =~ /bundle/ }.length.positive?
        bulk_sell = false if ELoot.data.alchemy_mode
        unless ELoot.data.settings[:sell_exclude].empty?
          if sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /furrier/ }.length.positive?
            bulk_sell = false
          end
        end

        if bulk_sell
          ELoot.msg("debug", " bulk_sell: #{bulk_sell} using sack: #{sack}")
          Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

          ELoot.silver_check

          # Fixme: add checks here
          dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
          Inventory.wear(sack)

          bulk_note = ELoot.read_note.to_i

          if bulk_note > 0
            ELoot.data.silver_breakdown["Furrier"] += bulk_note
          end

          sleep 0.5
        else
          sack.contents.each do |item|
            next if $sell_ignore.include?(item.id)
            next unless item.sellable =~ /furrier/
            next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/

            if ELoot.data.alchemy_mode
              next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
            end
            $sell_ignore.push(item.id)
            Inventory.drag(item)

            if item.name =~ /bundle/
              # grab the bundle ID
              bundle_id = !GameObj.right_hand.id.nil? ? GameObj.right_hand.id : GameObj.left_hand.id

              until ![GameObj.right_hand.id, GameObj.left_hand.id].include?(bundle_id)
                # remove a skin
                result = dothistimeout "bundle remove", 5, /You remove|Those were the last two/

                if result =~ /Those were the last two/
                  Sell.sell_item(GameObj.right_hand, "Furrier", ELoot.data.silver_breakdown)
                  Sell.sell_item(GameObj.left_hand, "Furrier", ELoot.data.silver_breakdown)
                else
                  # get the skin id
                  skin = GameObj.right_hand.id != bundle_id ? GameObj.right_hand : GameObj.left_hand
                  # Sell.sell_item(skin)
                  Sell.sell_item(skin, "Furrier", ELoot.data.silver_breakdown)
                end

              end

            else
              Sell.sell_item(item, "Furrier", ELoot.data.silver_breakdown)
              # Sell.sell_item(item)
            end
          end
        end

        Inventory.free_hands(both: true)
        ELoot.msg("debug", " bottom of each using sack: #{sack}")
      }

      ELoot.data.silver_breakdown["Furrier"] += (ELoot.silver_check - start_silvers)
    end

    def self.gemshop
      ELoot.go2("gemshop")
      start_silvers = ELoot.silver_check
      bulk_note = 0

      Inventory.free_hands(both: true)

      gem_sacks = Array.new
      gem_sacks.push(ELoot.data.sacks["gem"]) if ELoot.data.settings[:sell_container].include?("gem")
      gem_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      # Lousy autoclosers
      Inventory.check_auto_closer

      gem_sacks.each { |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.sellable.include?("gemshop") }.empty?

        # Bulk sell sack if it has gems and no exclusions
        if (ELoot.data.settings[:sell_exclude].empty? || (sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.type =~ /gem/ }).empty?) && sack.contents.find_all { |obj| obj.type =~ /gem/ }.length.positive? && ELoot.data.settings[:sell_loot_types].include?("gem") && !ELoot.data.alchemy_mode
          Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

          dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)

          Inventory.wear(sack)
          sleep 0.5

          bulk_note = ELoot.read_note.to_i

          if bulk_note > 0
            ELoot.data.silver_breakdown["Gemshop"] += bulk_note
          end

          Inventory.free_hands(both: true)
        end

        # Loop thru remaining contents and sell/appraise whatever is left
        sack.contents.each do |item|
          next if $sell_ignore.include?(item.id)
          next unless item.sellable.include?("gemshop") || item.noun =~ /thorn|berry/ || item.type =~ /scarab/
          next unless item.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
          next if ELoot.data.settings[:sell_gold_rings] && item.name =~ ELoot.data.regex_gold_rings

          if ELoot.data.alchemy_mode
            next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(item.id)
          if item.type =~ /cursed/ && !ELoot.data.settings[:sell_loot_types].include?("cursed")
            ELoot.msg("info", "** #{item.name} is cursed. Can't touch that. You'll need to take a look")
            next
          elsif item.type =~ /cursed/ && Spell[315].known? && Spell[315].affordable? && ELoot.data.settings[:sell_loot_types].include?("cursed")
            Spell[315].cast("at ##{item.id}")
          end

          Inventory.drag(item)

          if item.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?
            Sell.appraise(item, "Gemshop", ELoot.data.silver_breakdown)
          else
            Sell.sell_item(item, "Gemshop", ELoot.data.silver_breakdown)
          end

          Inventory.free_hands(both: true)
        end
      }

      ELoot.data.silver_breakdown["Gemshop"] += (ELoot.silver_check - start_silvers)
    end

    def self.consignment
      ELoot.go2("consignment")
      start_silvers = ELoot.silver_check
      Inventory.free_hands(both: true)

      consignment_sacks = Array.new
      consignment_sacks.push(ELoot.data.sacks["reagent"]) if ELoot.data.settings[:sell_container].include?("reagent")
      consignment_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        consignment_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        consignment_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      # Lousy autoclosers
      Inventory.check_auto_closer

      consignment_sacks.each { |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.sellable.include?("consignment") }.empty?

        sack.contents.each { |thing|
          next if $sell_ignore.include?(thing.id)
          next unless thing.sellable.include?("consignment")
          next unless thing.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
          next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
          next if thing.name =~ /bound/

          if ELoot.data.alchemy_mode
            next if thing.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(thing.id)
          Inventory.drag(thing)
          # Sell.sell_item(thing)
          Sell.sell_item(thing, "Consignment", ELoot.data.silver_breakdown)

          Inventory.free_hands(both: true)
        }
      }

      ELoot.data.silver_breakdown["Consignment"] += (ELoot.silver_check - start_silvers)
    end

    def self.pawnshop
      ELoot.go2("pawnshop")
      start_silvers = ELoot.silver_check
      Inventory.free_hands(both: true)

      all_contents = Array.new
      ELoot.data.sacks.keys.each { |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        all_contents += ELoot.data.sacks[item].contents.to_a
      }

      if ELoot.data.settings[:use_disk]
        ELoot.wait_for_disk
        Inventory.open_single_container(ELoot.data.disk)
        all_contents += ELoot.data.disk.contents.to_a
      end

      # Lousy autoclosers
      Inventory.check_auto_closer

      all_contents.each { |thing|
        next if $sell_ignore.include?(thing.id)
        next unless (thing.sellable.include?("pawnshop") && !thing.sellable.include?("gemshop")) || thing.type == "box"
        next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
        next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
        next unless thing.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
        next if thing.name =~ /bound/
        next if ELoot.data.settings[:sell_gold_rings] && thing.name =~ ELoot.data.regex_gold_rings

        $sell_ignore.push(thing.id)
        if thing.type =~ /scroll/ && ELoot.data.settings[:sell_keep_scrolls].length.positive?
          lines = ELoot.get_lines("read ##{thing.id}", /It takes you a moment|There is nothing there to read|You can't do that/)
          next if lines.any? { |line| line =~ /\((?:#{ELoot.data.settings[:sell_keep_scrolls].join("|")})\)/i }
        end
        next unless ELoot.decurse(thing)

        if thing.type =~ /cursed/ && !ELoot.data.settings[:sell_loot_types].include?("cursed")
          ELoot.msg("info", "** #{thing.name} is cursed. Can't touch that. You'll need to take a look")
          next
        elsif thing.type =~ /cursed/ && Spell[315].known? && Spell[315].affordable? && ELoot.data.settings[:sell_loot_types].include?("cursed")
          Spell[315].cast("at ##{thing.id}")
        end

        Inventory.drag(thing)
        if (thing.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?) || thing.type =~ /uncommon|weapon|armor/
          Sell.appraise(thing, "Pawnshop", ELoot.data.silver_breakdown)
        elsif thing.type =~ /box/
          line = ELoot.get_res("look in ##{thing.id}", ELoot.data.look_regex)
          if line =~ /There is nothing|In the/i

            thing.contents.each { |box_item|
              if box_item.type =~ /cursed/ && Spell[315].known? && Spell[315].affordable? && ELoot.data.settings[:sell_loot_types].include?("cursed")
                Spell[315].cast("at ##{box_item.id}")
              elsif box_item.type =~ /cursed/ && !ELoot.data.settings[:sell_loot_types].include?("cursed")
                ELoot.msg("info", "** #{box_item.name} is cursed. Stowing box. You'll need to take a look")
                Inventory.single_drag(thing, false)
              else
                Inventory.single_drag(box_item, false)
              end
            }
            # Sell.sell_item(thing)
            Sell.sell_item(thing, "Pawnshop", ELoot.data.silver_breakdown)
          elsif lines =~ /That is closed/i
            # This shouldn't happen
            ELoot.msg("info", "** #{thing.name} is closed. Storing box...")
            Inventory.single_drag(thing, false)
          end
        else
          Sell.sell_item(thing, "Pawnshop", ELoot.data.silver_breakdown)
        end

        Inventory.free_hands(both: true)
      }

      ELoot.data.silver_breakdown["Pawnshop"] += (ELoot.silver_check - start_silvers)
    end

    def self.pool(deposit = false)
      # Make sure we can see all the containers
      ELoot.data.sacks.keys.each { |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        Inventory.open_single_container(item)
      }

      room = Room.current.id
      ELoot.disk_usage
      boxes = ELoot.find_boxes
      ELoot.data.right_hand = GameObj.right_hand
      ELoot.data.left_hand = GameObj.left_hand
      Inventory.free_hands(both: true)
      Sell.locksmith_pool(boxes, deposit)
      ELoot.go2(room)
      Inventory.return_hands
    end

    def self.sell_item(item, place = nil, data = nil)
      return if item.nil? || item.name == "Empty"

      lines = ELoot.get_res("sell ##{item.id}", /You (offer to sell|ask)/)

      return if lines =~ /That's not quite my field|That's basically worthless here|Can't say I'm interested in that|This is a pawnshop, sir, not a junkshop|The company don't buy trash|as if you were a lunatic/

      20.times {
        break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))

        sleep 0.1
      }

      bulk_note = ELoot.read_note.to_i

      if bulk_note > 0
        data[place] += bulk_note
      end
    end

    def self.sell
      $sell_ignore ||= Array.new
      ELoot.data.silver_breakdown = Hash.new
      ELoot.data.local_gemshop = Room.current.find_nearest_by_tag("gemshop")
      ELoot.data.local_furrier = Room.current.find_nearest_by_tag("furrier")

      # Assume bags will be emptied after sell routine
      ELoot.data.sacks_full = Array.new

      fput('unhide') if (hidden? || invisible?)

      2.times { Sell.box_in_hand }

      # remember what is in our hands
      ELoot.data.right_hand = GameObj.right_hand
      ELoot.data.left_hand = GameObj.left_hand

      # Empty hands
      Inventory.free_hands(both: true)

      if checkright || checkleft
        ELoot.msg("error", "** Something is wrong. Can't empty hands! Report this to Elanthia-Online. A log is helpful. Exiting...")
        exit
      end

      ELoot.msg("debug", "ELoot.sell: Locating boxes")

      boxes = ELoot.find_boxes

      cur_len = boxes.length.to_i
      ELoot.msg("debug", "ELoot.sell: Boxes length = #{cur_len}")

      # Process boxes in the locksmithpool
      if (ELoot.data.settings[:sell_locksmith_pool] && boxes.length.positive?) || ELoot.data.settings[:always_check_pool]
        Sell.locksmith_pool(boxes)

        # refresh the boxes
        boxes = ELoot.find_boxes
      end

      # Sell off any remaining boxes
      Sell.locksmith(boxes) if ELoot.data.settings[:sell_locksmith] && boxes.length.positive?

      # Check Bounties
      Sell.check_bounty

      selling = Array.new
      all_contents = Array.new

      ELoot.data.sacks.keys.each { |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        Inventory.open_single_container(item)
        all_contents += ELoot.data.sacks[item].contents.to_a
      }

      if ELoot.data.settings[:use_disk]
        ELoot.wait_for_disk
        Inventory.open_single_container(ELoot.data.disk)
        all_contents += ELoot.data.disk.contents.to_a
      end

      all_contents.each { |thing|
        next if $sell_ignore.include?(thing.id)
        next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
        next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
        next if thing.name =~ /bound/
        next if selling.include?(thing.type) && !thing.type.nil?

        if ELoot.data.alchemy_mode
          next if thing.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          next if thing.noun =~ /^(?:jar|beaker|bottle)$/ and thing.after_name.nil?
        end

        if thing.name =~ ELoot.data.regex_gold_rings && ELoot.data.settings[:sell_gold_rings]
          selling.push("chronomage") unless selling.include?("chronomage")
        elsif thing.type =~ /scarab/ && ELoot.data.settings[:sell_loot_types].include?("scarab")
          selling.push("gemshop") unless selling.include?("gemshop")
        elsif thing.type == "gem" && ELoot.data.settings[:sell_loot_types].include?("gem") && thing.noun =~ /thorn|berry/
          selling.push("gemshop") unless selling.include?("gemshop")
        elsif thing.type == "collectible" && ELoot.data.settings[:sell_collectibles]
          selling.push("collectibles") unless selling.include?("collectibles")
        elsif ELoot.data.settings[:sell_loot_types].include?("box") && thing.type == "box"
          selling.push("pawnshop") unless selling.include?("pawnshop")
        elsif !thing.sellable.nil? && thing.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          thing.sellable.to_s.split(',').each { |location|
            selling.push(location) unless selling.include?(location)
          }
        end
      }

      ELoot.msg("debug", "Places to go: #{selling}")

      if selling.length.positive?

        Sell.glam_and_shroud if ELoot.data.settings[:sell_shroud]

        if ELoot.data.settings[:sell_aspect]
          if Spell[650].known? && Spell[650].affordable? && !Spell[650].active? && !Spell[9039].active?
            Spell[650].cast
            sleep 1
            waitcastrt?
            fput "assume lion"
          elsif Spell[650].active? && !Spell[9039].active?
            waitcastrt?
            fput "assume lion"
          end
        end

        rooms = Array.new
        selling.each { |shop|
          if shop == "collectibles"
            col = Array.new
            col.push(Room.current.find_nearest_by_tag("collectible")) unless Room.current.find_nearest_by_tag("collectible").nil?
            col.push(Room.current.find_nearest_by_tag("collectibles")) unless Room.current.find_nearest_by_tag("collectibles").nil?
            rooms.push(Room.current.find_nearest(col))
          elsif shop == "chronomage"
            next if Room.current.location =~ /Mist Harbor|Isle of Four Winds|Western Harbor/

            rooms.push(Room.current.find_nearest_by_tag(shop))
          else
            rooms.push(Room.current.find_nearest_by_tag(shop))
          end
        }

        rooms = rooms.reject do |room| room.nil? end

        _where_is_previous_var, where_is_shortest_distances_var = Room.current.dijkstra
        shortest_path = rooms.uniq.sort { |a, b| where_is_shortest_distances_var[a] <=> where_is_shortest_distances_var[b] }

        shortest_path.each { |location|
          if percentencumbrance > 80
            ELoot.use_coin_hand
            ELoot.silver_deposit
          end
          Sell.furrier if Room[location].tags.include?("furrier")
          Sell.gemshop if Room[location].tags.include?("gemshop")
          Sell.consignment if Room[location].tags.include?("consignment")
          Sell.pawnshop if Room[location].tags.include?("pawnshop")
          Sell.collectibles if Room[location].tags.include?("collectibles") || Room[location].tags.include?("collectible")
          Sell.gold_rings if Room[location].tags.include?("chronomage")
        }
      end

      # use coin hand if we have it
      ELoot.use_coin_hand

      ELoot.silver_deposit

      # If herb or junk is checked for selling we dump it. Only default and overflow
      Sell.dump_herbs_junk

      Inventory.return_hands

      # Close any containers that were opened
      Inventory.close_sell_containers if ELoot.data.settings[:keep_closed]
    end
  end # End of Sell
end

ELoot.version_check

if script.vars.any? { |var| var =~ /^--debug=(on|off|true|false|yes|no)$/i }
  fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
  ELoot.load(ELoot.load_profile()) unless ELoot.data
  ELoot::Setup.update_setting(:debug, fix_option[$1])
  ELoot.data.settings[:debug] = fix_option[$1]
  ELoot.save_profile()
  exit
end

if script.vars[1] =~ /ver/i
  echo "   Eloot Version: #{ELoot::ELoot_version}"
  exit
end

if Spell['Berserk'].active?
  ELoot.msg("info", " Berserk is active, preventing you from looting.")
  exit
end

# Silence
silence_me if ELoot.data.settings[:silence]

sleep 2 if script.vars[1] =~ /start/

# Initialize default settings
unless ELoot.data
  waitrt?
  ELoot.load(ELoot.load_profile())
  ELoot.set_inventory
end

if !ELoot.data.settings[:track_full_sacks]
  ELoot.data.sacks_full = Array.new
  ELoot.data.disk_full = false
end

# Sorter shows inventory checks so we kill it and restart
ELoot.manage_sorter

# Default to loot
if script.vars[1].nil?

  # Kill script if dead
  Thread.new { loop { Script.self.kill if dead?; sleep(5); } }

  ELoot.disk_usage

  ELoot.loot

  # Close any containers that were opened
  ELoot::Inventory.close_sell_containers if ELoot.data.settings[:keep_closed]

  exit
end

# This allows partial matches the same way Gemstone works.
# e.g., ;eloot sel would match ;eloot sell
command = '^box^help^settings^setup^sell^pool^load^list^test^deposit^start'

# No match - show help message
unless (index = (command =~ /\^#{script.vars[1]}/))
  ELoot.help
  exit
end

# Got a match, strip the command down to the parts in between the ^
start = index + 1
stop = command.index('^', index + 1) - 1
room = Room.current.id

case command[start..stop]
when 'help'
  ELoot.help
when 'list'
  ELoot::Setup.new(ELoot.data.settings).list if script.vars[2].nil?
  ELoot::Setup.new(ELoot.data.settings).list(cat_to_list: script.vars[2]) if !script.vars[2].nil?
when 'box'
  if GameObj.right_hand.type =~ /box/
    box = GameObj.right_hand
    ELoot::Inventory.free_hands(left: true)
  elsif GameObj.left_hand.type =~ /box/
    box = GameObj.left_hand
    ELoot::Inventory.free_hands(right: true)
  end
  ELoot::Loot.box_loot(box)
  ELoot.go2(room)
when 'sell'
  if script.vars[2] == "alchemy_mode"
    ELoot.data.alchemy_mode = true
  end
  ELoot.disk_usage
  ELoot.sell
  ELoot.go2(room)
  ELoot::Sell.breakdown
  ELoot.data.alchemy_mode = false
when 'pool'
  deposit = script.vars[2] =~ /depo/ ? true : false
  ELoot.disk_usage
  ELoot::Sell.pool(deposit)
when 'settings'
  if Script.current.vars[2]
    ELoot.update_setting(script.vars[2..-1])
  else
    ELoot.launch_settings_ui
  end
when 'setup'
  ELoot.launch_settings_ui
when 'load'
  waitrt?
  ELoot.load(ELoot.load_profile)
  ELoot.set_inventory
when 'deposit'
  ELoot.silver_deposit
  ELoot.go2(room)
when 'test'
  ELoot.test
end
