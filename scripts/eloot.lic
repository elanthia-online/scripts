# frozen_string_literal: true

=begin
  eloot.lic: eLoot is fork/update/rewrite of sloot.

  Some primary changes from sloot include using in-game STOW settings instead of variables.
  Locksmith pool handling, loot room, exclusion support, appraise limits.
  eloot also auto-writes settings to your Lich5/Data/eloot folder per character.

            author: elanthia-online
   original author: SpiffyJr (sloot)
        maintainer: elanthia-online
      contributors: SpiffyJr, Athias, Demandred, Tysong, Deysh, Ondreian, Lieo, Lobe, Etheirys
              wiki: https://gswiki.play.net/Lich:Script_Eloot
              game: Gemstone
              tags: loot
          required: Lich >= 5.9.0
           version: 2.4.0
  Improvements:
  Major_change.feature_addition.bugfix
  v2.4.0 (2025-05-21)
    - add CLI option to skin only
    - fix regex for sellable/type/sell CLI to make = optional to match help text
  v2.3.12 (2025-05-10)
    - fix for Pinefar banker withdraw/deposit
    - fix for disk/container contents being nil prior to storing an item
  v2.3.11 (2025-05-05)
    - fix find_boxes to now clear sacks found with boxes from sacks_full
    - bugfix in regex for pool parameters to match help text
    - general sanitation of GTK values on load and close of GTK window
    - bugfix in incremental tipping display chart
    - bugfix in locksmith_pool_count due to truncated results list returning incorrect list of boxes unopened
    - correctly display incremental tipping chart starting at base 0
  v2.3.10 (2025-04-28)
    - bugfix in locksmith_tip to ensure numerics incase of string values saved in yaml
  v2.3.9 (2025-04-27)
    - bugfix add coin bag full msg'ing to regex
  v2.3.8 (2025-04-22)
    - bugfix for older Ruby 2.6 users and Bounty.task.assigned?
  v2.3.7 (2025-03-27)
    - add ;eloot pool return to options
    - bugfix for Rift talons gem hoarding
    - bugfix in get_regex to support hidden dagger harness
    - bugfix in check_type for hoarding HW hyphenated gem names
    - bugfix for locker reset while hoarding
    - bugfix in wait_for_disk logic
    - bugfix for spinbutton
    - add additional in_region boundaries and convert to UID lookup
    - bugfix for note deposit when using urchin guide and bounties
  v2.3.6 (2025-03-15)
    - typo for horde to hoard
    - bugfix to deposit local note if selling in FWI
    - bugfix in gem name standardization
    - remove deprecated percentstance & percentencumbrance calls
    - bugfix to not timeout on creatures that get ressurrected
    - bugfix on find_weapons_ready_list
    - bugfix in looting gemstone jewels if both hands currently used
    - bugfix in validate_setup when toggling on/off skinning
  v2.3.5 (2025-03-14)
    - additional updates to put_regex and get_regex
    - bugfix to not Regexp escape loot_keep
  v2.3.4 (2025-03-11)
    - bugfix for spin buttons not saving properly
    - add debug for loot method
  v2.3.2 (2025-03-10)
    - update to appraise method
    - fix for monsterbold gemstone jewel drop msging at feet
  v2.3.1 (2025-03-09)
    - add space for regex_at_feet
  v2.3.0 (2025-03-09)
    - add support for gambling kits
    - update for gemstones
    - bugfix when ELoot.data.settings[:loot_keep] is nil
    - bugfix when emptying jars to add to empty jar count
    - bugfix in store_item when gem hoarding
    - bugfix for weapon displayer
    - bugfix for container_contents
    - broke up the set_inventory method into smaller sections
    - bugfix add daybringer put_regex match
    - bugfix for swordbelts and neck sheaths
  v2.2.3  (2025-03-03)
    - added support for Lock & Key gameobj types to loot_special and loot_regular
    - bugfix in Bounty.task usage for gem/skin
  v2.2.2  (2025-02-28)
    - bugfix in Region.in_region for HW/Cold River
  v2.2.1  (2025-02-26)
    - bugfix in check_bounty_gems using furrier instead of gemshop
    - bugfix for neck sheath containers not populating contents
  v2.2.0  (2025-02-20)
    - updated required lich version to 5.8.0
    - added support for house lockers
    - added additional container content checks
    - added check for selling bounty items in the correct town
    - misc improvements to UI functionality
  v2.1.6  (2025-02-10)
    - bugfix for selling boxtraps
    - modified hoarding bugfix to be more comprehensive. Was failing on an end of line condition
    - bugfix for standard account gem inventory
  v2.1.5  (2025-02-07)
    - bugfix for hoarding inventory when using a family vault
  v2.1.4  (2025-01-25
    - rework coin bag logic to reduce excessive inspect calls
  v2.1.3  (2025-01-24)
    - bugfix in incrimental tipping
  v2.1.2  (2025-01-23)
    - added support for looting/selling locksmith traps
    - bugfix for breakdown calc
  v2.1.1  (2025-01-23)
    - add support for keeping vibrant scrolls. Enter the scroll number (Ex:101v or 101 vibrant) in the Keep Scrolls section
    - add box detail to selling output
    - added support for looting/selling locksmith traps
  v2.1.0  (2025-01-13)
    - added option to output debug information to file
  v2.0.10 (2025-01-11)
    - bugfix for box inhand and full locksmith pool
  v2.0.9  (2025-01-01)
    - bugfix for locksmith pool box list
  v2.0.8  (2024-12-21)
    - additional error checking for looting to avoid false pauses
    - removed get_lines method and combined it with get_command
    - add custom vine name
    - bugfix in loot_regular method when looting a box and default container is full
  v2.0.7  (2024-12-12)
    - add HW uncommon loot to loot_specials method
    - update reject loot method for 335 Deity effects
    - added automatic data reload if new version downloaded
  v2.0.6  (2024-12-06)
    - temporarily disable raiding from house lockers
    - bugfix in account type comparison
    - bugfix for running results report when nothing to report
  v2.0.5  (2024-12-06)
    - bugfix for house lockers check
    - bugfix for thinking bags were full when actually stunned.
  v2.0.4  (2024-12-01)
    - temporarily disable hoarding for house lockers
    - bugfix to hoarding regex when creating inventory
  v2.0.3  (2024-11-23)
    - will try to selling clothing at the gemshop first, then the pawnshop if applicable
    - bugfix in put_regex
    - bugfix in store_item
  v2.0.2  (2024-11-20)
    - bugfix in single_loot method
    - bugfix in hoarding process
    - bugfix for urchin guide
  v2.0.1  (2024-11-12)
    - bugfix to only buff for selling if something to sell
    - bugfix to exit if insufficient funds at bank
  v2.0.0  (2024-09-04)
    - support for hoarding gems and alchemy ingredients
    - support for in-between script to run. This runs between finishing the pool and before selling. Usecase: totems, hoarding, supplies, whatever
    - addition of CLI selling options: sellable, type, and itemized
    - disk usage tracking improvements
    - incremental tipping added for locksmith pool
    - added appraisal container to store items appraised over limit.
    - added crumble messaging for the bowels
    - bugfix for selling in HW
    - bugfix for closed coin bag
    - bugfix for favor_left skinning
    - bugfix for silver_deposit if keeper_silvers returns a note
    - bugfix for coin hand bank deposit
    - changes to UI
    - bugfix for coin bag capacity check
    - bugfix for shattered urchin usage
    - bugfix for 1205 Glamour
    - updated changelog on wiki
    - removed changelog in script before 1.6.20
=end

# Check version of Lich for compatibility
lich_gem_requires = '5.9.0'

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires)
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
    _respond "##" + "########################################"
  end
  exit
end

require 'yaml'
require 'terminal-table'

module ELoot # Writes debug output to a file
  class DebugLogger
    attr_accessor :logger, :log_file, :script_name

    def initialize
      @script_name = Script.current.name
      # Ensure the debug folder exists
      debug_dir = File.join(LOG_DIR, 'debug', "#{XMLData.game}-#{XMLData.name}")
      FileUtils.mkdir_p(debug_dir) unless Dir.exist?(debug_dir)

      # Set up logger
      @log_writer = Queue.new
      @log_file = File.join(debug_dir, "#{@script_name}.log")
      @logger = Logger.new(@log_file, 'daily')
      @logger.formatter = proc do |_, datetime, _, msg|
        formatted_time = datetime.strftime("%Y-%m-%d %H:%M:%S") # Excludes timezone
        "[#{formatted_time}]: #{msg}\n"
      end

      # Start logging automatically after initialization
      start_logging
    end

    def start_logging
      # Startup Message
      if ELoot.data == ELoot.data.details_check
        log("Starting up!")
      else
        ELoot.data.details_check = ELoot.data
        eloot_details = ELoot.test(true)
        log("Starting up!\n#{eloot_details}")
      end

      @worker_thread = Thread.new {
        UpstreamHook.add("debug_upstream_hook", proc { |data|
          @log_writer << ">#{data.sub(/^<c>/, '')}".strip
          data
        })

        DownstreamHook.add("debug_downstream_hook", proc { |data|
          @log_writer << data.strip
          data
        })

        loop do
          current_last = $_LASTUPSTREAM_
          @log_writer.push current_last.sub(/^<c>/, '').strip
          while current_last == $_LASTUPSTREAM_
            sleep 0.1
          end
        end
      }

      @writer_thread = Thread.new do
        loop do
          line = @log_writer.pop
          @logger.info(@script_name) { line } unless line.to_s.strip.empty?
        end
      end

      before_dying {
        @logger.info(@script_name) { "Closing up!" }

        respond("")
        Lich::Messaging.msg("bold", "You've started #{Script.current.name} with debug to file on.")
        Lich::Messaging.msg("bold", "Please remember to turn this option off once done needing to debug.")
        Lich::Messaging.msg("bold", "Currently debugging to #{@log_file}")
        Lich::Messaging.msg("bold", "To turn off, execute #{$clean_lich_char}#{Script.current.name} debug file")
        respond("")

        UpstreamHook.remove("debug_upstream_hook")
        DownstreamHook.remove("debug_downstream_hook")
        @worker_thread.kill
        @writer_thread.kill
        @logger.close
        ELoot.data.debug_logger = nil
      }

      respond("")
      Lich::Messaging.msg("bold", "You've started #{Script.current.name} with debug to file on.")
      Lich::Messaging.msg("bold", "Please remember to turn this option off once done needing to debug.")
      Lich::Messaging.msg("bold", "Currently debugging to #{@log_file}")
      Lich::Messaging.msg("bold", "To turn off, execute #{$clean_lich_char}#{Script.current.name} debug file")
      respond("")
    end

    # Method to log a custom message
    def log(message)
      @log_writer << message
    end
  end
end

module ELoot # Data
  class Data
    attr_accessor :disk, :disk_full, :sacks_full, :ready_list, :ready_method, :sacks, :settings, :skinners, :skinsheath, :silent_open, :checked_bags,
                  :close_regex, :look_regex, :sacks_closed, :all_loot_categories, :regex_gold_rings, :right_hand, :left_hand, :skin_edged, :skin_blunt,
                  :coin_hand, :coin_container, :silver_breakdown, :get_regex, :put_regex, :alchemy_mode, :sell_containers, :local_gemshop, :local_furrier, :log_unlootables, :exclude,
                  :charm, :gauntlet, :coin_bag, :account_type, :locker, :container_settings, :everything_list, :everything,
                  :only_list, :only, :inventory, :gem_inventory, :alchemy_inventory, :hoard_type, :cache, :locker_city, :use_hoarding, :stash,
                  :items_to_hoard, :hoard_deposit, :inv_save, :deposit_regex, :withdraw_regex, :disk_nouns_regex, :sigil_determination_on_fail, :start_room, :last_called,
                  :urchin_msg, :gemshop_first, :reject_loot_names, :reject_loot_nouns, :version, :debug_logger, :details_check, :coin_bag_full,
                  :use_house_locker, :che_rooms, :che_entry, :che_exit, :towns, :gambling_kit, :gambling_kit_full, :ready_lines, :weapon_inv

    def initialize(settings)
      @settings = settings
      @start_room = nil
      @last_called = {}
      @version = ELoot.get_script_version
      @debug_logger = nil
      @details_check = nil
      @towns ||= Map.list.select { |r| r.tags.include? "town" }

      # inventory type
      @sacks = {}
      @sacks_closed = []
      @sacks_full = []
      @checked_bags = []
      @sell_containers = []
      @ready_lines = []
      @weapon_inv = []

      @coin_hand = nil
      @coin_container = nil

      @charm = nil
      @gauntlet = nil
      @coin_bag = nil
      @coin_bag_full = false

      @gambling_kit = nil
      @gambling_kit_full = false

      @disk = nil
      @disk_full = false

      @ready_list = {}
      @ready_method = {}

      @skinners = {}
      @skinsheath = nil
      @skin_edged = nil
      @skin_blunt = nil

      @right_hand = ""
      @left_hand = ""

      # Hoarding/bounty type
      @hoard_type = nil
      @hoard_deposit = nil
      @items_to_hoard = nil
      @container_settings = nil
      @everything_list = nil
      @everything = nil
      @only_list = nil
      @only = nil
      @inventory = nil
      @gem_inventory = nil
      @alchemy_inventory = nil
      @locker_city = nil
      @locker = nil
      @cache = nil
      @use_hoarding = nil
      @stash = nil
      @use_house_locker = nil
      @che_rooms = []
      @che_entry = ""

      @alchemy_mode = false

      @local_gemshop = nil
      @local_furrier = nil

      # Misc
      @account_type = nil
      @silver_breakdown = {}
      @inv_save = true

      $sell_ignore = []
      @gemshop_first = false

      default_crumbly = [
        # Kraken Fall
        "gnarled dark wooden crook",
        "twisted obsidian dagger",
        "immense fel-hafted handaxe",
        "gold-tipped heavy spear",
        "notched bone handaxe",
        "rough pinewood crook",
        "swirling sanguine orb",
        "battered antique faewood crate",
        "copper-traced dark steel hatchet",
        "huge black alloy greatsword",
        "rough leather quiver",

        # Atoll
        "twisted soot black runestaff",
        "corroded bronze Hammer of Kai",
        "dried seaweed-wrapped longbow",
        "bronze-bound driftwood greatshield",
        "coral-hilted heavy ball and chain",
        "coral-hilted sharply tapered longsword",
      ]

      @settings[:crumbly] ||= []
      @settings[:crumbly] += default_crumbly
      @settings[:crumbly].uniq!

      @settings[:track_full_sacks] = true if @settings[:track_full_sacks].nil?

      @settings[:unlootable] ||= []
      @settings[:unlootable]&.uniq!

      @settings[:auto_close] ||= []
      @settings[:auto_close]&.uniq!

      @settings[:unskinnable]&.uniq!

      @exclude = @settings[:loot_exclude].map { |r| r.is_a?(String) ? Regexp.new(r) : r }

      @deposit_regex = Regexp.union(
        /You deposit (?<silver>[\d,]+) silvers? into your account/,
        /That's a total of (?<silver>[\d,]+) silver/,
        /That's (?<silver>[\d,]+) silver|silvers? to your account/,
        /You deposit your note worth (?<silver>[\d,]+) into your account/,
        /You hand your notes to the teller, who glances over each one and scribbles the amounts in a book.  She says, "They add up to (?<silver>[\d,]+) (?:silver|silvers)/,
        /You have no coins to deposit/,
        /Smiling greedily, Hurshal takes your silvers and says, "Heh, I'll put dese in ye 'Mule bank account right quick\."/,
      )

      @withdraw_regex = Regexp.union(
        /I have a (?<debt>bill) of (?<silver>[\d,]+) silvers? (?:presented by your creditors|that I suggest you pay immediately)/,
        /Very well, a withdrawal of (?<silver>[\d,]+) silver/,
        /teller scribbles the transaction into a book and hands you (?<silver>[\d,]+) silver/,
        /teller carefully records the transaction, (?:and then )?hands you (?<silver>[\d,]+) silver/,
        /The banker nods and says, "Alright, here ye go\.  Ye understand I be takin' a little more than that from ye account in the 'Mule\.  I don't works for free!"/,
      )

      @get_regex = Regexp.union(
        /^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly |slowly )?(?:remove|draw|equip|grab|reach|slip|tuck|retrieve|already have|unsheathe|detach|swap|sling|withdraw)/,
        /^With subtle movements, you sneak a hand/,
        /^Get what\?$/,
        /^Why don't you leave some for others\?$/,
        /^You need a free hand/,
        /^You already have that/,
        /Reaching over your shoulder/,
        /^As you draw/,
        /^Ribbons of.*?light/,
        /^You are already holding/,
      )

      @put_regex = Regexp.union(
        /You/,
        /Spreading your wings/,
        /I could not find what you were referring to/,
        /Draping the/,
        /Heedful of your surroundings/,
        /won't fit/,
        /crumbles? and decays? away/,
        /crumbles? into a pile of dust/,
        /That is not yours/,
        /Hey, that belongs to/,
        /Get what/,
        /Reaching over your shoulder/,
        /An ethereal.*?light swirls/,
        /As you move to put away your (?:<a exist="\d+" noun="\w+">[^<]+<\/a>|[\w-]+), it reverts to its normal state\./,
      )

      @look_regex = Regexp.union(
        /Peering into the <a exist=.*? noun="toolkit">/i,
        /That is closed/i,
        /is shut too tightly to see its contents/i,
        /In the(.*?)you see/i,
        /In the(.*?):/i,
        /There is nothing/i,
        /You glance/i,
        /^Attached to a.*keyring/i,
        /.*?[.*?]:/i,
        /The <a exist="\d+" noun="\w+">[^<]+<\/a> has (?:an? <a exist="\d+" noun="\w+">[^<]+<\/a> |nothing )?in.*scabbard and (?:an? <a exist="\d+" noun="\w+">[^<]+<\/a> |nothing )?in.*scabbard\./i,
        /^I could not find what you were referring to\./i,
        /Hidden within the depths of a cloakwing moth greatcloak/,
        /<exposeContainer|<dialogData|<container/i,
        /stuffed with a variety of shredded up paper and cloth/,
        /As much as you'd like to open it, its not closed\./,
        /^Looking at the .*?, you notice:/i, # neck sheath, no proper gameobjs viewable
        /^The .+? has .+? in its left-hand scabbard and .+? in its right-hand scabbard\.$/i, # swordbelt scabbards, no proper gameobjs viewable
      )

      @silent_open = Regexp.union(
        /You throw back/i,
        /You open/i,
        /Oh no! It's already/i,
        /You pick at the knot/i,
        /already open/i,
        /is open already/i,
        /You unfasten/i,
        /You glance around suspiciously/i,
        /^What were you referring to\?/i,
        /^I could not find what you were referring to\./i,
        /You pull the long strips of leather/i,
        /With a flick of your wrist/i,
        /Sliding the lever on the side/i,
        /You rub your hand/i,
        /There doesn't seem to be any way/i,
        /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i,
        /crumbles? and decays? away/,
        /crumbles? into a pile of dust/,
        /Myriad spectral moths pull a cloakwing/,
        /<exposeContainer|<container/i,
        /You undo each of the/,
        /stuffed with a variety of shredded up paper and cloth/,
      )

      @close_regex = Regexp.union(
        /You close .*/,
        /(?:That|It) is already closed/,
        /What were you referring to/,
        /seem to be any way to do that/,
        /You tie/,
        /You fasten the/,
      )

      @urchin_msg = Regexp.union(
        /You (flag|summon|ask|consult|stride|go|inventory|recollect|offer|strut|sweep|casually|hear|currently) /,
        /An elven page/,
        /Unsure exactly/,
        /A bloom of wildflowers/,
        /A thin layer of hoarfrost/,
        /Making a decision/,
        /With a cautious glance/,
        /As if sensing your/,
        /Sudden gusts of wind/,
        /Motes of light blink/,
        /A single mote of/,
        /A dense fog rolls/,
        /Shadowy tendrils rise/,
      )

      # There are a lot of disk nouns so breaking out to a single list to maintain
      @disk_nouns_regex = /\b(?:bassinet|cassone|chest|coffer|coffin|coffret|disk|hamper|saucer|sphere|trunk|tureen)\b/

      @regex_gold_rings = /^(dingy|plain|braided|twisted|intricate|large|thin|wide|polished|scratched|thick|dull|faded|small|flawless|inlaid|dirt\-caked|ornate|exquisite|shiny|bright|narrow) gold ring$|^gold ring$/

      @reject_loot_names = [
        # 335 Diety
        "golden light",
        "jet black scimitar",
        "midnight black flames",
        "reddish haze",
        "sourceless shadow",
        "swirling blue-green pillar of water",

        # Ranger vines
        "bramble",
        "briar",
        "clutch of twisted branches",
        "creeper",
        "ivy",
        "smilax",
        "swallowwort",
        "tumbleweed",
        "vine",
        "widgeonweed",

        # Misc
        "child",
        "jagged crater",
        "massive icicle",
        "point of elemental instability",
        "rolton droppings",
        "rotting tree stump",
        "sealed fissure",
        "severed",
        "slender silvery thread",
        "slippery wooden chute",
        "small puddle",
        "vathor club",
      ]

      @reject_loot_nouns = [
        "cloud",
        "cyclone",
        "door",
        "gangplank",
        "kitten",
        "maw",
        "mist",
        "muck",
        "puppy",
        "space",
        "staircase",
      ]

      @all_loot_categories = ["alchemy", "armor", "box", "clothing", "collectible", "cursed", "food", "gem", "herb", "jewelry", "junk", "lockpick", "lm trap", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand", "weapon"]
    end
  end
end

module ELoot # UI Setup
  if defined?(Gtk)
    # Setup is an extension of Gtk::Builder for Gtk setup
    class Setup < Gtk::Builder
      @@categories = {
        loot: {
          loot_types: {
            default: []
          },
          loot_exclude: {
            default: ["black ora", "urglaes"],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          loot_keep: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          critter_exclude: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          unlootable: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          loot_phase: { default: false },
          use_disk: { default: true },
          loot_defensive: { default: false },
          overflow_container: { default: '' },
          secondary_overflow: { default: '' },
          coin_hand_name: { default: '' },
          charm_name: { default: '' },
          sigil_determination_on_fail: { default: false },
          keep_closed: { default: false },
          track_full_sacks: { default: true },
          favor_left: { default: false },
          log_unlootables: { default: false },
          gambling_toss_min: { default: 1_000 },
        },
        boxes: {
          use_standard_tipping: { default: true },
          sell_locksmith: { default: false },
          sell_locksmith_pool: { default: true },
          always_check_pool: { default: false },
          display_box_contents: { default: true },
          sell_locksmith_pool_tip: { default: 15 },
          sell_locksmith_pool_tip_percent: { default: true },
          use_incremental_tipping: { default: false },
          base_tip: { default: 200 },
          max_tip: { default: 2000 },
          alpha_rate: { default: 2.5 },
          tipping_test: { default: [] },
        },
        sell: {
          sell_loot_types: {
            default: []
          },
          sell_container: { default: [] },
          sell_exclude: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          sell_keep_scrolls: {
            default: [],
            load: proc do |store, setting|
              store.clear

              # Ensure uniqueness first
              setting.uniq!

              # Sort the array with numeric values first, then alphanumeric values
              setting.sort! do |a, b|
                # Extract numeric part from each item
                a_num = a.to_s.match(/^\d+/) ? a.to_s.match(/^\d+/)[0].to_i : Float::INFINITY
                b_num = b.to_s.match(/^\d+/) ? b.to_s.match(/^\d+/)[0].to_i : Float::INFINITY

                if a_num == b_num
                  # If numeric part is the same, place alphanumeric values after pure numbers
                  a.match?(/\D/) ? 1 : -1
                else
                  # Sort by numeric value first
                  a_num <=> b_num
                end
              end

              setting.each do |text|
                spell_no = text.to_s[/^\d+/]

                if spell_no.nil?
                  setting.delete(text)
                else
                  iter = store.append
                  iter[0] = Spell[spell_no].num
                  iter[1] = Spell[spell_no].name
                  iter[2] = '     Vibrant' if text.to_s =~ /v/i
                end
              end
            end,
            delete: proc do |_, selected, setting|
              if selected.get_value(2).nil?
                setting.delete_if { |item| item == selected.get_value(0).to_s || item == selected.get_value(0) }
              else
                thing = setting.find { |item| item.to_s =~ /#{selected.get_value(0)}\s?+(?:v|vib)/i }
                setting.delete(thing)
              end
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              spell_no = text[/^\d+/]
              next if Spell[spell_no].nil?

              setting.push(text)
            end
          },
          sell_appraise_types: { default: [] },
          sell_appraise_gemshop: { default: 14_999 },
          sell_appraise_pawnshop: { default: 34_999 },
          appraisal_container: { default: '' },

          sell_collectibles: { default: true },
          sell_gold_rings: { default: false },

          sell_share_silvers: { default: false },
          sell_fwi: { default: false },
          sell_shroud: { default: false },
          sell_aspect: { default: false },
          sell_keep_silver: { default: 0 },
          sell_deposit_coinhand: { default: false },
        },
        skin: {
          skin_enable: { default: false },
          skin_kneel: { default: false },
          skin_604: { default: false },
          skin_resolve: { default: false },
          skin_sheath: { default: '' },
          skin_weapon: { default: '' },
          skin_sheath_blunt: { default: '' },
          skin_weapon_blunt: { default: '' },
          skin_exclude: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          between: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
        },
        hoard: {
          gem_horde_turnin: { default: false },
          gem_horde_inv: { default: [] },
          gem_horde: { default: false },
          gem_horde_locker: { default: false },
          gem_everything_list: { default: false },
          gem_only_list: { default: false },
          gem_horde_container: { default: '' },
          gem_horde_containers: { default: ['default', 'gem', 'overflow1', 'overflow2'] },
          gem_locker: { default: '' },
          gem_locker_name: { default: '' },
          gem_horde_locker_che: { default: false },
          gem_horde_che_rooms: { default: '' },
          gem_horde_che_entry: { default: '' },
          gem_horde_che_exit: { default: '' },
          gem_everything: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          gem_list: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          alchemy_horde_inv: { default: [] },
          alchemy_horde: { default: false },
          alchemy_horde_locker: { default: false },
          alchemy_everything_list: { default: false },
          alchemy_only_list: { default: false },
          alchemy_horde_container: { default: '' },
          alchemy_horde_containers: { default: ['default', 'reagent', 'overflow1', 'overflow2'] },
          alchemy_locker: { default: '' },
          alchemy_locker_name: { default: '' },
          alchemy_horde_locker_che: { default: false },
          alchemy_horde_che_rooms: { default: '' },
          alchemy_horde_che_entry: { default: '' },
          alchemy_horde_che_exit: { default: '' },
          alchemy_everything: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          alchemy_list: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
        },
        internal: {
          silence: { default: false },
          debug: { default: false },
          debug_file: { default: false },
          unskinnable: { default: [] },
          unlootable: { default: [] },
          crumbly: { default: [] },
          auto_close: { default: [] },
        }
      }

      def self.eloot_ui
        '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkListStore" id="alchemy_everything_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/></columns></object><object class="GtkListStore" id="alchemy_list_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/>
        </columns></object><object class="GtkAdjustment" id="alpha_adjustment"><property name="upper">100</property><property name="step-increment">0.10</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="base_tip_adjustment"><property name="upper">100000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="between_store"><columns><!-- column-name exclusion --><column type="gchararray"/>
        </columns></object><object class="GtkListStore" id="critter_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkAdjustment" id="gambling_adjustment"><property name="upper">25000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="gem_everything_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/></columns></object><object class="GtkListStore" id="gem_list_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/>
        </columns></object><object class="GtkListStore" id="loot_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkListStore" id="loot_keep_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkAdjustment" id="max_tip_adjustment"><property name="upper">100000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="sell_appraise_gemshop_adjustment"><property name="upper">1000000</property><property name="step-increment">1</property><property name="page-increment">10</property>
        </object><object class="GtkAdjustment" id="sell_appraise_gemshop_pawnshop"><property name="upper">1000000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="sell_exclude_store"><columns><!-- column-name Exclusion --><column type="gchararray"/></columns></object><object class="GtkListStore" id="sell_keep_scrolls_store"><columns><!-- column-name Spell --><column type="gint"/><!-- column-name Spell1 --><column type="gchararray"/><!-- column-name Spell2 --><column type="gchararray"/>
        </columns></object><object class="GtkAdjustment" id="sell_keep_silver_adjustment"><property name="upper">999999</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="sell_locksmith_pool_tip_adjustment"><property name="upper">999999</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="skin_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/>
        </columns></object><object class="GtkListStore" id="unlootable_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkWindow" id="main"><property name="width-request">790</property><property name="height-request">640</property><property name="can-focus">False</property><property name="title" translatable="yes">Eloot Setup</property><property name="modal">True</property><property name="default-width">800</property><property name="default-height">830</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=6 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="loot_types:alchemy"><property name="label" translatable="yes">Alchemy</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:armor"><property name="label" translatable="yes">Armor</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:box"><property name="label" translatable="yes">Box</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:clothing"><property name="label" translatable="yes">Clothing</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:collectible"><property name="label" translatable="yes">Collectible</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:cursed"><property name="label" translatable="yes">Cursed</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:food"><property name="label" translatable="yes">Food</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:herb"><property name="label" translatable="yes">Herb</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:junk"><property name="label" translatable="yes">Junk</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:weapon"><property name="label" translatable="yes">Weapon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">5</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:coins"><property name="label" translatable="yes">Coins (ground)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:breakable"><property name="label" translatable="yes">Breakable(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Porous chunks of rock released as part of The Hive 12/17/2023</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:lm trap"><property name="label" translatable="yes">Locksmith Traps</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Loot Types</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="loot_defensive"><property name="label" translatable="yes">Loot in defensive (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Swap to defensive before looting if there are hostile enemies.</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_phase"><property name="label" translatable="yes">Phase boxes(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Phases boxes if you are able to.</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_disk"><property name="label" translatable="yes">Disking(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Utilizes your disk for boxes if checked</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="track_full_sacks"><property name="label" translatable="yes">Track Full Containers(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Eloot will try to keep track of full sacks (turn off if not selling with eloot)</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="favor_left"><property name="label" translatable="yes">Favor Left(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will favor left hand to stow for looting (defaults to right)</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="keep_closed"><property name="label" translatable="yes">Keep sacks shut(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Will keep sacks closed (Performance hit!)</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="log_unlootables"><property name="label" translatable="yes">Log unlootable items(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">This will log items you can not loot into the Unlootable section (Loot Grid) otherwise it will ignore that section. </property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="sigil_determination_on_fail"><property name="label" translatable="yes">Sigil of Determination(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will use Sigil of Determination if you fail to loot because you are too injured.</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=1 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Fossil Charm Name:</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="charm_name"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">15</property><property name="margin-end">15</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Originally from Mushroom Spore Giftbox 07/29/2023</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="width">2</property><property name="height">4</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Other Settings</property>
        </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=1 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Primary Overflow:</property><property name="xalign">0</property><property name="yalign">0</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="overflow_container"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Enter the name of your overflow container.  This container will be used when the targeted STOW container is full.</property><property name="margin-start">5</property><property name="margin-end">15</property><property name="margin-bottom">5</property><property name="hexpand">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Secondary Overflow:</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkEntry" id="secondary_overflow"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Enter the name of your secondary overflow container.  This container will be used when the primary overflow container is full.</property><property name="margin-start">5</property><property name="margin-end">15</property><property name="margin-bottom">10</property><property name="hexpand">True</property><property name="vexpand">False</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Overflow Containers</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=1 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Coin Bag / Coin Hand / Gambling Kit</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="coin_hand_name"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">15</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Name of item</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Gambling Kit Silvers (?)</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkSpinButton" id="gambling_toss_min"><property name="width-request">130</property><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Minimum number of coins before tossing in your gambling kit
        Note: Incurs a 2 second rt</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">gambling_adjustment</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Weightless Coin Containers</property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property>
        </packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Looting</property></object><packing><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="loot_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="loot_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="loot_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. urglaes fang)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="loot_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">loot_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time.
        Regular expressions are supported.
        Example: Enter "(?:aquamarine|gold) wand" and "gold ring" as separate entries.</property><property name="label" translatable="yes">Never Loot(?)</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="loot_keep_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="loot_keep_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="loot_keep_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter addition (e.g. uncut diamond)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="loot_keep"><property name="visible">True</property><property name="can-focus">True</property><property name="model">loot_keep_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Always loot these items. They should be entered one line at a time.
        Regular expressions are supported.
        Example: Enter "(?:aquamarine|gold) wand" and "gold ring" as separate entries.</property><property name="label" translatable="yes">Always Loot(?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="critter_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="critter_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="critter_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. giant rat)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="critter_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">critter_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time.
        Regular expressions are supported.
        Example: Enter "(?:big ugly|mongrel) kobold" and "Vvrael destroyer" as separate entries.</property><property name="label" translatable="yes">Creature Exclusions (?)</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="unlootable_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="unlootable_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="unlootable_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter unlootable item</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="unlootable"><property name="visible">True</property><property name="can-focus">True</property><property name="model">unlootable_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Unlootable items should be entered one line at a time.
        Regular expressions are supported.
              </property><property name="label" translatable="yes">Unlootable(?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child></object></child></object><packing><property name="position">1</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Looting Grid</property></object><packing><property name="position">1</property><property name="tab-fill">False</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_locksmith_pool"><property name="label" translatable="yes">Use locksmith pool</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_locksmith"><property name="label" translatable="yes">Use town locksmith</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="display_box_contents"><property name="label" translatable="yes">Display box contents</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="always_check_pool"><property name="label" translatable="yes">Always check pool (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">If checked eloot will always check the pool for retruned boxes.
              Default behavior is to only check if there is a box to drop off.</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Locksmithing</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="between_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="between_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="between_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Scripts between the pool and selling</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="between"><property name="visible">True</property><property name="can-focus">True</property><property name="model">between_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Enter the name of the script with any options.
          Ex: &lt;script name&gt; &lt;option1 option2 option3&gt;

        The script(s) will run after finishing the locksmith pool.
        This will allow finer control of inventory storage for
            things like gem singing, loresing or anything else you might want.</property><property name="label" translatable="yes">In-between Scripts (?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="height">2</property></packing></child><child><object class="GtkFrame" id="standard_tipping_frame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=1 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-top">10</property><property name="label" translatable="yes">Locksmith Pool Tip</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="sell_locksmith_pool_tip"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-top">10</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_locksmith_pool_tip_adjustment</property><property name="numeric">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_locksmith_pool_tip_percent"><property name="label" translatable="yes">Tip using percentage</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="use_standard_tipping"><property name="label" translatable="yes">Use Standard Tipping</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Standard Pool Tipping</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame" id="incremental_tipping_frame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=1 n-rows=7 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="label" translatable="yes">Base Tip</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="base_tip"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="adjustment">base_tip_adjustment</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="label" translatable="yes">Maximum Tip</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkSpinButton" id="max_tip"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="adjustment">max_tip_adjustment</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="label" translatable="yes">α (alpha)</property></object><packing><property name="left-attach">0</property><property name="top-attach">5</property>
        </packing></child><child><object class="GtkSpinButton" id="alpha_rate"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">20</property><property name="adjustment">alpha_adjustment</property><property name="digits">1</property></object><packing><property name="left-attach">0</property><property name="top-attach">6</property>
        </packing></child><child><object class="GtkCheckButton" id="use_incremental_tipping"><property name="label" translatable="yes">Use Incremental Tipping</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">100</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><!-- n-columns=1 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-end">70</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="valign">start</property><property name="margin-top">20</property><property name="label" translatable="yes">As your box count in the pool climbs, so does your tip.
        This pushes your box higher in the queue resulting in a faster return.

        The formula being used:
             Tip = Base Tip+( Boxes in Pool / 100 )^α ×(Max Tip−Base Tip)

        base_tip  = minimum tip to start
        max_tip   = maximum tip
        α (alpha) = determines how fast tip rises </property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="tipping_test"><property name="label" translatable="yes">Test Formula Values</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Prints a sample distribution to the screen.
        </property><property name="halign">start</property><property name="margin-top">25</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><placeholder/></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Incremental Tipping</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property>
        </packing></child></object></child></object></child></object><packing><property name="position">2</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Boxes</property></object><packing><property name="position">2</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=6 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_loot_types:alchemy"><property name="label" translatable="yes">Alchemy</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:armor"><property name="label" translatable="yes">Armor</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:box"><property name="label" translatable="yes">Box(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Sells empty gold, mithril, and silver boxes to the pawnshop</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:clothing"><property name="label" translatable="yes">Clothing</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:cursed"><property name="label" translatable="yes">Cursed</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:food"><property name="label" translatable="yes">Food (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Food will be thrown away or dropped since it can\'t be sold</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:herb"><property name="label" translatable="yes">Herb(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Herbs will be thrown away or dropped since they can\'t be sold</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:junk"><property name="label" translatable="yes">Junk(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Junk will be thrown away or dropped since they can\'t be sold</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:scarab"><property name="label" translatable="yes">Scarab</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:weapon"><property name="label" translatable="yes">Weapon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Warning - Mark anything you don\'t want accidentally sold - Eloot is not perfect!</property><attributes><attribute name="foreground" value="#ffff00000000"/>
        </attributes></object><packing><property name="left-attach">1</property><property name="top-attach">4</property><property name="width">4</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:breakable"><property name="label" translatable="yes">Breakable(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Porous chunks of rock released as part of The Hive 12/17/2023
        They need to be broken so the contents can be sold</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:lm trap"><property name="label" translatable="yes">Locksmith Traps</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Sell Types</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=5 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_container:default"><property name="label" translatable="yes">Default</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:overflow"><property name="label" translatable="yes">Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:box"><property name="label" translatable="yes">Box</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:collectible"><property name="label" translatable="yes">Collectible</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:forageable"><property name="label" translatable="yes">Forageable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:herb"><property name="label" translatable="yes">Herb</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:potion"><property name="label" translatable="yes">Potion</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:treasure"><property name="label" translatable="yes">Treasure</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:trinket"><property name="label" translatable="yes">Trinket</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Only sell from these STOW containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">135</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=5 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="sell_appraise_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-top">10</property><property name="label" translatable="yes">Gemshop Limit</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property>
        </packing></child><child><object class="GtkSpinButton" id="sell_appraise_gemshop"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_appraise_gemshop_adjustment</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Pawnshop Limit</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property><property name="width">2</property></packing></child><child><object class="GtkSpinButton" id="sell_appraise_pawnshop"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_appraise_gemshop_pawnshop</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">75</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="label" translatable="yes">Container to store items exceeding appraisal limit</property></object><packing><property name="left-attach">4</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="appraisal_container"><property name="visible">True</property><property name="can-focus">True</property><property name="valign">start</property><property name="margin-start">75</property><property name="margin-top">5</property><property name="placeholder-text" translatable="yes">If blank will return items to original container</property></object><packing><property name="left-attach">4</property><property name="top-attach">1</property><property name="height">2</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Appraisals</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property>
        </packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="sell_collectibles"><property name="label" translatable="yes">Deposit Collectibles</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_fwi"><property name="label" translatable="yes">Sell in FWI</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_gold_rings"><property name="label" translatable="yes">Gold Rings to Chrono.</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_shroud"><property name="label" translatable="yes">Use Shroud (1212) &amp; Glamour (1205)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Setting this will ensure you keep a certain number of silvers on you after selling. This is useful for places like Icemule Trace that have a gate fee.</property><property name="halign">start</property><property name="margin-start">30</property><property name="label" translatable="yes">Keep Silvers (?)</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_aspect"><property name="label" translatable="yes">Use Assume Aspect - Lion (650)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_deposit_coinhand"><property name="label" translatable="yes">Deposit coinhand/gambling kit</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_share_silvers"><property name="label" translatable="yes">Share silvers</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkSpinButton" id="sell_keep_silver"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-top">5</property><property name="margin-bottom">30</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_keep_silver_adjustment</property><property name="numeric">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property><property name="height">2</property>
        </packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Other Settings</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">3</property>
        </packing></child></object></child></object></child></object><packing><property name="position">3</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Selling</property></object><packing><property name="position">3</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="sell_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="sell_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="sell_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. uncut diamond)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="sell_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">sell_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time.
        Regular expressions are supported.
        Enter "(?:aquamarine|gold) wand" and "gold ring" as separate entries.</property><property name="label" translatable="yes">Exclusions (?)</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="sell_keep_scrolls_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="sell_keep_scrolls_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="sell_keep_scrolls_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. 215)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="sell_keep_scrolls"><property name="height-request">-1</property><property name="visible">True</property><property name="can-focus">True</property><property name="model">sell_keep_scrolls_store</property><property name="headers-visible">False</property><property name="search-column">0</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="title" translatable="yes">Spell Number</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="title" translatable="yes">Spell Name</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">1</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="title" translatable="yes">Vibrant</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">2</attribute>
        </attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Add spells to this list to prevent selling scrolls that have matching spells.
        Vibrant scrolls are supported
        Example: Enter "101v" or "101 vibrant" for the vibrant scrolls
          Enter just the spell number otherwise - "101"</property><property name="label" translatable="yes">Keep Scrolls (?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child></object></child></object><packing><property name="position">4</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Selling Grid</property>
        </object><packing><property name="position">4</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow" id="skinning_scrolled_window"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="border-width">10</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_enable"><property name="label" translatable="yes">Enable skinning</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="skin_kneel"><property name="label" translatable="yes">Kneel to skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_resolve"><property name="label" translatable="yes">Use Sigil of Resolve</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_604"><property name="label" translatable="yes">Use 604</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><!-- n-columns=2 n-rows=8 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Skin Sheath (blunt)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_sheath_blunt"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Skin Weapon (blunt)</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_weapon_blunt"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">20</property><property name="margin-end">10</property><property name="margin-bottom">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Blunt Skinning</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Skin Sheath (edged)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_sheath"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Skin Weapon (edged)</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_weapon"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">20</property><property name="margin-end">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Edged Skinning</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="skin_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="skin_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="skin_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter skinning exclusion (e.g. giant rat)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="skin_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">skin_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time.
        Regular expressions are supported.
        Example: Enter "(?:big ugly|mongrel) kobold" and "Vvrael destroyer" separately.</property><property name="label" translatable="yes">Skinning Exclusions (?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="height">8</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child><child><placeholder/>
        </child></object></child></object></child></object><packing><property name="position">5</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Skinning</property></object><packing><property name="position">5</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow" id="gem_scrolled_window"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="gem_horde"><property name="label" translatable="yes">Hoard Gems (defaults to all gems unless modified below)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_locker"><property name="label" translatable="yes">Hoard gems in a public locker</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_horde_container"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">14</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="width-chars">20</property><property name="placeholder-text" translatable="yes">ex: bin or chest or trunk</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_turnin"><property name="label" translatable="yes">Use hoarded gems for bounties</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkComboBoxText" id="gem_locker"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">22</property><property name="margin-bottom">17</property><property name="has-entry">True</property><child internal-child="entry"><object class="GtkEntry" id="gem_locker_name"><property name="can-focus">True</property><property name="placeholder-text" translatable="yes">Select Locker Location</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property><property name="height">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-top">13</property><property name="label" translatable="yes">Name of strorage container (even for lockers)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_locker_che"><property name="label" translatable="yes">Hoard gems in a house locker</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkEntry" id="gem_horde_che_rooms"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Will try to enter the locker at each location.
        If it is occupied it will go to the next one.
        If it gets to the end of the list it will pause for 10 seconds,
        then start from the beginning.</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">Comma separated list of room #\'s OUTSIDE the locker</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_horde_che_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">go arch or tap panel or other</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkEntry" id="gem_horde_che_exit"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">whatever gets you out</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Will try to enter the locker at each location.
        If it is occupied it will go to the next one.
        If it gets to the end of the list it will pause for 10 seconds,
        then start from the beginning.</property><property name="halign">end</property><property name="margin-start">25</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Locations(?)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Entry Verb</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Exit Verb</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="margin-start">15</property><property name="margin-top">20</property><property name="label" translatable="yes">Hoarding Notes:
        Requires jars to store gems
        Able to use any size jar
        Able to use empty jars for new gems
        Does not buy jars
        Will skip over full jars</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="gem_horde_containers:default"><property name="label" translatable="yes">Default</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_containers:overflow1"><property name="label" translatable="yes">First Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_containers:overflow2"><property name="label" translatable="yes">Second Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_containers:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Only Hoard Gems from these Containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="gem_everything_list"><property name="label" translatable="yes">Hoard all gems except those excluded below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_only_list"><property name="label" translatable="yes">ONLY hoard gems listed below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame" id="gem_everything_frame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="gem_everything_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="gem_everything_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_everything_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Gems to Exclude</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="gem_everything"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">gem_everything_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame" id="gem_only_frame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="gem_list_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="gem_list_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_list_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Gems to Include</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="gem_list"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">gem_list_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property></packing></child></object></child></object></child></object><packing><property name="position">6</property>
        </packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Gem Hoarding</property></object><packing><property name="position">6</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow" id="alchemy_scrolled_window"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=6 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="alchemy_horde_locker"><property name="label" translatable="yes">Hoard reagents  in a locker?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_horde_container"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="width-chars">20</property><property name="placeholder-text" translatable="yes">ex: bin or chest or trunk</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde"><property name="label" translatable="yes">Hoard Reagents (defaults to all unless modified below)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkComboBoxText" id="alchemy_locker"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">22</property><property name="has-entry">True</property><child internal-child="entry"><object class="GtkEntry" id="alchemy_locker_name"><property name="can-focus">True</property><property name="placeholder-text" translatable="yes">Select Locker Location</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property><property name="height">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="label" translatable="yes">Name of strorage container (even for lockers)</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkEntry" id="alchemy_horde_che_rooms"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Will try to enter the locker at each location.
        If it is occupied it will go to the next one.
        If it gets to the end of the list it will pause for 10 seconds,
        then start from the beginning.</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">Comma separated list of room #\'s OUTSIDE the locker</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_horde_che_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">go arch or tap panel or other</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkEntry" id="alchemy_horde_che_exit"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">whatever gets you out</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Will try to enter the locker at each location.
        If it is occupied it will go to the next one.
        If it gets to the end of the list it will pause for 10 seconds,
        then start from the beginning.</property><property name="halign">end</property><property name="margin-start">25</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Locations(?)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Entry Verb</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Exit Verb</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_locker_che"><property name="label" translatable="yes">Hoard reagents  in a house locker?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="valign">end</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="margin-start">15</property><property name="margin-top">20</property><property name="label" translatable="yes">Hoarding Notes:
        Requires jars to store reagents
        Able to use any size jar
        Able to use empty jars for new reagents
        Does not buy jars
        Will skip over full jars</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="alchemy_horde_containers:default"><property name="label" translatable="yes">Default</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_containers:overflow1"><property name="label" translatable="yes">First Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_containers:overflow2"><property name="label" translatable="yes">Second Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_containers:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Only Hoard Alchemy Ingredients from these Containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="alchemy_everything_list"><property name="label" translatable="yes">Hoard all alchemy ingredients except those excluded below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_only_list"><property name="label" translatable="yes">ONLY hoard alchemy ingredients listed below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame" id="alchemy_everything_frame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="alchemy_everything_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-left">5</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="alchemy_everything_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-right">5</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_everything_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Ingredients to Exclude</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="alchemy_everything"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">alchemy_everything_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame" id="alchemy_only_frame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="alchemy_list_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-left">5</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="alchemy_list_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-right">5</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_list_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Ingredients to Include</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="alchemy_list"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">alchemy_list_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property></packing></child></object></child></object></child></object><packing><property name="position">7</property>
        </packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Alchemy Hoarding</property></object><packing><property name="position">7</property><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Your changes are saved automatically.</property><attributes><attribute name="style" value="italic"/>
        </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">15</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
        </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
      end

      def self.get_category(key)
        @@categories.each { |category, data| return category unless data[key].nil? }
        nil
      end

      def self.get_setting(key)
        cat = Setup.get_category(key)
        return nil if cat.nil?

        @@categories[cat].each { |setting, data| return data if setting == key }
        nil
      end

      def validate_settings
        # set default values if they don't exist and correct Integer, Float and String types if saved settings are wrong class
        @@categories.each do |_, data|
          data.each { |key, value|
            if @settings[key].nil?
              @settings[key] = value[:default]
            elsif @settings[key].class != value[:default].class && !@settings[key].is_a?(TrueClass) && !@settings[key].is_a?(FalseClass)
              if value[:default].is_a?(Integer)
                @settings[key] = @settings[key].to_i
              elsif value[:default].is_a?(Float)
                @settings[key] = @settings[key].to_f
              elsif value[:default].is_a?(String)
                @settings[key] = @settings[key].to_s
              else
                echo("Key: #{key} default value class #{value[:default].class} does not match current class #{@settings[key].class}")
                echo("Report this to Elanthia-Online team!")
              end
            end
          }
        end
      end

      def initialize(settings)
        super()
        @settings = settings
        version = ELoot.get_script_version
        validate_settings

        # remove settings that doesn't exist
        @settings.delete_if { |key, _| next Setup.get_category(key).nil? }

        # use a GTK Builder to setup all the basics of the window then expand on that base
        return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

        Gtk.queue do
          # add_from_file("#{$data_dir}eloot.ui")
          add_from_string(Setup.eloot_ui)
          load_settings
          set_initial_conditions

          self['main'].keep_above = true
          self['main'].set_title "ELoot Setup v#{version}"

          # connect signals after settings are loaded to a bunch of handlers don't trigger
          connect_signals { |handler| method(handler) }
        end
      end

      def start
        @running = true
        Gtk.queue { self['main'].show_all }
        wait_while { @running }
      end

      def on_close_clicked
        # correct class types due to GTK elements converting class
        validate_settings
        ELoot.save_profile()
        self['main'].destroy
      end

      def on_destroy
        Gtk.queue { @running = false }
      end

      # iterate all objects and for any that match a setting name directly we set the default
      def load_settings
        Gtk.queue do
          # load up the generic settings which are just matching by name of the widget
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)

            key = obj.builder_name.to_sym
            next if (setting = Setup.get_setting(key)).nil?

            if obj.is_a?(Gtk::CheckButton)
              obj.active = @settings[key]
              obj.signal_connect('toggled') { on_update(obj) }
            elsif obj.class == Gtk::Button
              if key == :tipping_test
                tipping_test
              end
            elsif obj.class == Gtk::Entry
              obj.text = @settings[key].strip
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::SpinButton
              obj.value = @settings[key]
              obj.adjustment.value = @settings[key]
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::ComboBoxText
              if obj.builder_name =~ /gem_locker|alchemy_locker/
                on_locker_load(obj.builder_name)
              end
            elsif obj.class == Gtk::TreeView
              next unless treeview_check(key)

              store = self["#{key}_store"]
              add = self["#{key}_add"]
              delete = self["#{key}_delete"]
              entry = self["#{key}_entry"]

              setting[:load].call(store, @settings[key])

              add.signal_connect('clicked') do
                next if entry.text.empty?

                setting[:set].call(store, entry.text, @settings[key])
                setting[:load].call(store, @settings[key])
                entry.text = ''
              end

              delete.signal_connect('clicked') do
                next if obj.selection.selected.nil?

                setting[:delete].call(store, obj.selection.selected, @settings[key])
                setting[:load].call(store, @settings[key])
              end
            end
          end

          # checkboxes for array storage with id's <setting>:<value>
          # this is primarily used by the loot types
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)
            next unless obj.builder_name =~ /^([^:]+):(.*)$/i
            next unless obj.class == Gtk::CheckButton

            key = Regexp.last_match(1).to_sym
            value = Regexp.last_match(2).to_s

            next if Setup.get_setting(key).nil?

            obj.active = @settings[key].include?(value)

            # add in hook
            obj.signal_connect('toggled') do
              @settings[key].delete(value)
              if obj.active?
                @settings[key].push(value)
                @settings[key].uniq!.sort!
              end
            end
          end
        end
      end

      def treeview_check(key)
        msg = []
        setting = Setup.get_setting(key)

        msg << "*** No :load defined for #{key}" unless setting[:load]

        %w[store add delete entry].each do |suffix|
          msg << "** Failed to find #{suffix} for treeview #{key}" unless self["#{key}_#{suffix}"]
        end

        return true if msg.empty?

        msg.each { |error| respond error }
        return false
      end

      def tipping_test
        self[:tipping_test].signal_connect("clicked") do
          rows = []
          rows << [{ value: "Box depositing starts at 1", colspan: 4, alignment: :center }]
          rows << :separator
          rows << ['Box No', 'Tip', 'Box No', 'Tip']
          rows << :separator

          first_half = [0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45]
          second_half = (50..100).step(5).to_a

          max_length = [first_half.length, second_half.length].max

          # # Add nil entries if the second half is shorter
          first_half += [nil] * (max_length - first_half.length)
          second_half += [nil] * (max_length - second_half.length)

          max_length.times do |i|
            first_item = "#{first_half[i]}  "
            second_item = "#{second_half[i]}  "

            tip_1 = first_item ? Sell.locksmith_tip(first_item, @settings[:base_tip], @settings[:max_tip], @settings[:alpha_rate]) : nil
            tip_1 = tip_1.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
            tip_1 = i == 0 ? @settings[:base_tip].to_i.round(0).to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse : tip_1

            tip_2 = !second_item.strip.empty? ? Sell.locksmith_tip(second_item, @settings[:base_tip], @settings[:max_tip], @settings[:alpha_rate]) : nil
            tip_2 = tip_2.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse

            rows << [first_item, tip_1, second_item, tip_2]
          end
          alpha = @settings[:alpha_rate].to_f.round(1)
          table = Terminal::Table.new :title => "Incremental Tipping (alpha: #{alpha})", :rows => rows
          (0..3).each do |i|
            table.align_column(i, :right)
          end
          respond
          respond table
          respond
        end
      end

      def on_locker_load(item)
        public_location = []
        public = Map.list.find_all { |room| room.tags.any?(/publiclockers/) }

        public.each { |room|
          if room.tags.any?(/publiclockers/)
            public_location << room.location.gsub(/the town of /, '')
          end
        }

        self[item].remove_all

        unless UserVars.mapdb_fwi_trinket
          public_location.delete_if { |place|
            place == 'Mist Harbor'
          }
        end

        self[item].append_text('')

        public_location.compact!  # Remove nil values
        public_location.uniq!     # Remove duplicates
        public_location.sort!     # Sort the array

        public_location.each { |place| self[item].append_text(place) }
      end

      # This is connected to automatically during load_settings.
      def on_update(obj)
        Gtk.queue do
          key = obj.builder_name.to_sym
          setting = Setup.get_setting(key)
          return if setting.nil?

          if obj.class == Gtk::CheckButton
            @settings[key] = obj.active?
            # Boxes Tab
            if obj.builder_name == "sell_locksmith_pool"
              if obj.active?
                enable_all(self["standard_tipping_frame"])
                enable_all(self["incremental_tipping_frame"])
              else
                disable_all(self["standard_tipping_frame"], exception: self["sell_locksmith_pool"])
                disable_all(self["incremental_tipping_frame"], exception: self["sell_locksmith_pool"])
              end
            end

            if key == :use_standard_tipping && obj.active?
              self['use_incremental_tipping'].active = false
              @settings[:use_incremental_tipping] = false
            end

            if key == :use_incremental_tipping && obj.active?
              self['use_standard_tipping'].active = false
              @settings[:use_standard_tipping] = false
            end

            # Hoarding
            if obj.builder_name =~ /gem_horde\b|alchemy_horde\b/
              type = obj.builder_name == 'gem_horde' ? 'gem' : 'alchemy'
              if obj.active?
                enable_all(self["#{type}_scrolled_window"])
                manage_hoard(nil, type.to_sym)
              else
                disable_all(self["#{type}_scrolled_window"], exception: self["#{type}_horde"])
              end
            end

            manage_hoard(key)

            # Skinning Tab
            if obj.builder_name == "skin_enable"
              if obj.active?
                enable_all(self["skinning_scrolled_window"])
                set_initial_conditions
              else
                disable_all(self["skinning_scrolled_window"], exception: self["skin_enable"])
              end
            end
          elsif obj.class == Gtk::Entry
            @settings[key] = obj.text.strip
          elsif obj.class == Gtk::SpinButton
            @settings[key] = obj.buffer.text
          end
        end
      end

      def set_initial_conditions
        disabled_conditions = {
          "loot_phase"                  => Stats.prof != 'Sorcerer',
          "skin_resolve"                => !Spell[9704].known?,
          "sigil_determination_on_fail" => !Spell[9716].known?,
          "skin_604"                    => !Spell[604].known?,
          "sell_shroud"                 => (!Spell[1205].known? && !Spell[1212].known?),
          "sell_aspect"                 => !Spell[650].known?,
        }

        Gtk.queue do
          manage_hoard

          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)
            if disabled_conditions[obj.builder_name]
              obj.set_sensitive(false)
              self[obj.builder_name].active = false
              @settings[obj.builder_name.to_sym] = false
            end
          end

          # Boxes Tab
          unless self["sell_locksmith_pool"].active?
            disable_all(self["standard_tipping_frame"], exception: self["sell_locksmith_pool"])
            disable_all(self["incremental_tipping_frame"], exception: self["sell_locksmith_pool"])
          end

          # Skinning Tab
          unless self["skin_enable"].active?
            disable_all(self["skinning_scrolled_window"], exception: self["skin_enable"])
          end

          # Gem and Alchemy tabs
          ['gem', 'alchemy'].each do |type|
            unless self["#{type}_horde"].active?
              disable_all(self["#{type}_scrolled_window"], exception: self["#{type}_horde"])
            end
          end
        end
      end

      def manage_hoard(key = nil, type = :all)
        types = type == :all ? [:gem, :alchemy] : [type]

        types.each do |t|
          type_prefix = t.to_s
          valid_keys = [
            "#{type_prefix}_everything_list".to_sym,
            "#{type_prefix}_only_list".to_sym,
            "#{type_prefix}_horde_locker".to_sym,
            "#{type_prefix}_horde_locker_che".to_sym
          ]

          # Return early if key is provided but not in valid_keys
          next if key && !valid_keys.include?(key)

          keys = key ? [key] : valid_keys

          keys.each do |k|
            case k
            when :"#{type_prefix}_everything_list"
              if self[k.to_s].active?
                self["#{type_prefix}_only_list"].active = false
                @settings[:"#{type_prefix}_only_list"] = false
                enable_all(self["#{type_prefix}_everything_frame"])
                disable_all(self["#{type_prefix}_only_frame"])
              end
            when :"#{type_prefix}_only_list"
              if self[k.to_s].active?
                self["#{type_prefix}_everything_list"].active = false
                @settings[:"#{type_prefix}_everything_list"] = false
                enable_all(self["#{type_prefix}_only_frame"])
                disable_all(self["#{type_prefix}_everything_frame"])
              end
            when :"#{type_prefix}_horde_locker"
              if self[k.to_s].active?
                self["#{type_prefix}_horde_locker_che"].active = false
                @settings[:"#{type_prefix}_horde_locker_che"] = false
                self["#{type_prefix}_locker"].set_sensitive(true)
                toggle_che_widgets(type_prefix, false)
              end
            when :"#{type_prefix}_horde_locker_che"
              if self[k.to_s].active?
                self["#{type_prefix}_horde_locker"].active = false
                @settings[:"#{type_prefix}_horde_locker"] = false
                self["#{type_prefix}_locker"].set_sensitive(false)
                toggle_che_widgets(type_prefix, true)
              end
            end
          end

          # Handle case when neither locker is active
          if !self["#{type_prefix}_horde_locker"].active? && !self["#{type_prefix}_horde_locker_che"].active?
            self["#{type_prefix}_locker"].set_sensitive(false)
            toggle_che_widgets(type_prefix, false)
          end

          # Handle case when neither list is active
          if !self["#{type_prefix}_everything_list"].active? && !self["#{type_prefix}_only_list"].active?
            disable_all(self["#{type_prefix}_everything_frame"])
            disable_all(self["#{type_prefix}_only_frame"])
          end
        end
      end

      def toggle_che_widgets(type, value)
        self["#{type}_horde_che_rooms"].set_sensitive(value)    # turn on/off CHE locker locations
        self["#{type}_horde_che_entry"].set_sensitive(value)    # turn on/off CHE locker entry verb
        self["#{type}_horde_che_exit"].set_sensitive(value)     # turn on/off CHE locker exit verb
      end

      def disable_all(container, exception: nil)
        container.each do |widget|
          next if exception && widget == exception # Skip the exception if provided

          # Disable interactive widgets
          if [Gtk::ComboBox, Gtk::ToggleButton, Gtk::Button, Gtk::TreeView].any? { |type| widget.is_a?(type) }
            widget.set_sensitive(false)
          elsif widget.is_a?(Gtk::Container)
            disable_all(widget, exception: exception) # Recurse into child containers
          else
            widget.set_sensitive(false) # Disable other non-container widgets
          end
        end
      end

      def enable_all(container)
        container.each do |child|
          child.set_sensitive(true)
          enable_all(child) if child.is_a?(Gtk::Container)
        end
      end

      def list(cat_to_list: 'all')
        indent_size = 2
        print_array =
          proc do |key, value, indent|
            _respond("#{' ' * indent_size * indent.to_i}#{key}:")
            value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
          end

        print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

        categories = cat_to_list == 'all' ? %w[loot sell skin internal] : [cat_to_list]
        if $frontend == 'stormfront'
          output = "<output class=\"mono\"/>\n"
        else
          output = String.new
        end
        categories.each do |opt|
          _respond("#{output}") if !output.empty?
          _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
          @@categories[opt.to_sym].each do |id, _|
            value = @settings[id]
            value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
          end
        end
        _respond("#{monsterbold_start}= GameObj Types =#{monsterbold_end}\n")
        _respond("#{GameObj.type_data.map { |k, _v| k }.sort.join(', ')}")
        if $frontend == 'stormfront'
          output = "<output class=\"\"/>\n"
          _respond("#{output}")
        end
      end

      def self.update_setting(key, value)
        setting = Setup.get_setting(key)
        ELoot.msg(type: "error", text: "** Setting \"#{key}\" does not exist") if setting.nil?

        action = nil

        if value.to_s =~ /^([+-])(.*)$/
          action = Regexp.last_match(1)
          value = Regexp.last_match(2).strip.downcase
        end

        if value.to_s == 'reset'
          @settings.delete(key)
          ELoot.msg(type: "info", text: " Reset #{key}")
        elsif @settings[key].class == Array
          if value =~ /\d/ && @settings[key][value.to_i]
            @settings[key].delete_at(value.to_i)
          else
            @settings[key].delete(value)
          end

          if action == '-'
            ELoot.msg(type: "info", text: " \"#{value}\" removed from \"#{key}\"")
          else
            @settings[key].push(value)
            ELoot.msg(type: "info", text: " \"#{value}\" added to \"#{key}\"")
          end

          ELoot.msg(type: "info", text: " \"#{key}\" is now \"#{@settings[key].join(', ')}\"")
        else
          if @settings[key].class == FalseClass || @settings[key].class == TrueClass
            value = value =~ /^true|1|yes|on/ ? true : false
          elsif @settings[key].class == Integer
            value = value.to_i
          end

          respond
          ELoot.msg(type: "yellow", text: " #{key.capitalize} has been set to #{value}")
          respond

          @settings[key] = value
        end
      end
    end
  end
end

module ELoot # Profile loading/saving and settings
  def self.coerce_setting_value(setting_name, default, input)
    case default
    when TrueClass, FalseClass
      fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
      fix_option.fetch(input[0]) do |v|
        ELoot.msg(type: "error", text: %{Expected a boolean (true/false/yes/no) value for "#{setting_name} but got "#{v}"})
        exit
      end
    when Array
      input
    when Integer
      v = input[0]
      if v =~ /\A[+-]?\d+\z/
        v.to_i
      else
        ELoot.msg(type: "error", text: %{Expected an integer value for #{setting_name} value but got "#{v}"})
        exit
      end
    when String
      input.join(" ")
    else
      ELoot.msg(type: "error", text: "Recognized #{setting_name} but don't know how to normalize a #{default.class} type setting")
      exit
    end
  end

  def self.launch_settings_ui
    Setup.new(data.settings).start
    ELoot.load(load_profile)
    set_inventory
  end

  def self.load(settings)
    @@data = Data.new(settings)
  end

  def self.load_defaults()
    default_hash = {
      :loot_types                      => ["alchemy", "armor", "box", "breakable", "clothing", "collectible", "food", "gem", "jewelry", "lockpick", "lm trap", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
      :loot_exclude                    => ["black ora", "urglaes"],
      :loot_phase                      => false,
      :use_disk                        => true,
      :loot_defensive                  => false,
      :coin_hand_name                  => "",
      :sigil_determination_on_fail     => false,
      :charm_name                      => "",
      :overflow_container              => "",
      :secondary_overflow              => "",
      :sell_loot_types                 => ["alchemy", "armor", "breakable", "clothing", "food", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand", "box", "lm trap"],
      :sell_container                  => ["default", "overflow", "box", "collectible", "forageable", "gem", "herb", "lockpick", "potion", "reagent", "scroll", "skin", "treasure", "trinket", "wand"],
      :sell_exclude                    => [],
      :sell_keep_scrolls               => [],
      :sell_appraise_types             => ["jewelry", "magic", "uncommon", "valuable"],
      :sell_appraise_gemshop           => 14999,
      :sell_appraise_pawnshop          => 34999,
      :sell_collectibles               => true,
      :sell_gold_rings                 => false,
      :sell_locksmith                  => false,
      :sell_locksmith_pool             => true,
      :always_check_pool               => false,
      :display_box_contents            => true,
      :sell_locksmith_pool_tip         => 15,
      :sell_locksmith_pool_tip_percent => true,
      :sell_share_silvers              => false,
      :sell_fwi                        => false,
      :sell_shroud                     => false,
      :sell_aspect                     => false,
      :sell_keep_silver                => 0,
      :skin_enable                     => false,
      :skin_kneel                      => false,
      :skin_604                        => false,
      :skin_resolve                    => false,
      :skin_sheath                     => "",
      :skin_weapon                     => "",
      :skin_sheath_blunt               => "",
      :skin_weapon_blunt               => "",
      :silence                         => false,
      :debug                           => false,
      :unskinnable                     => [],
      :unlootable                      => [],
      :auto_close                      => [],
      :crumbly                         => [],
      :keep_closed                     => false,
      :track_full_sacks                => true,
      :favor_left                      => false,
      :log_unlootables                 => false
    }

    Dir.mkdir("#{$data_dir}#{XMLData.game}") unless File.exist?("#{$data_dir}#{XMLData.game}")
    Dir.mkdir("#{$data_dir}#{XMLData.game}/#{Char.name}") unless File.exist?("#{$data_dir}#{XMLData.game}/#{Char.name}")

    File.write("#{$data_dir}#{XMLData.game}/#{Char.name}/eloot.yaml", default_hash.to_yaml)

    default_hash
  end

  def self.load_profile(name: Char.name)
    if name != nil
      filename = "#{$data_dir}#{XMLData.game}/#{name}/eloot.yaml"
      if File.exist?("#{filename}") && name == Char.name
        settings_hash = YAML.load_file(filename)
      elsif !File.exist?("#{filename}") && name != Char.name
        ELoot.msg(type: "error", text: " ELoot.load_profile: Attempt to load a profile that does not exist.")
      elsif !File.exist?("#{filename}") && name == Char.name
        ELoot.msg(type: "info", text: " No current settings found.  Loading defaults...")
        settings_hash = ELoot.load_defaults()
      else
        ELoot.msg(type: "error", text: " ELoot.load_profile: There was an unknown error with loading a profile")
      end
    else
      ELoot.msg(type: "error", text: " ELoot.load_profile: name not defined")
    end

    settings_hash
  end

  def self.normalize_setting_name(input)
    input.downcase.tr('-', '_').to_sym
  end

  def self.save_hoard_profile
    # Saves profile for gems/reagents inventory syncs
    ELoot.data.inv_save = true

    if ELoot.data.hoard_type == 'gem'
      ELoot.data.gem_inventory = ELoot.data.inventory
    elsif ELoot.data.hoard_type == 'alchemy'
      ELoot.data.alchemy_inventory = ELoot.data.inventory
    end

    before_dying {
      if ELoot.data.inv_save
        ELoot.msg(type: "default", text: " Saving profile to sync gem/reagent inventories.")
        ELoot.data.settings[:gem_horde_inv] = ELoot.data.gem_inventory
        ELoot.data.settings[:alchemy_horde_inv] = ELoot.data.alchemy_inventory
        ELoot.save_profile
        ELoot.data.inv_save = false
      end
    }
  end

  def self.save_profile(silent: false)
    filename = "#{$data_dir}#{XMLData.game}/#{Char.name}/eloot.yaml"
    File.write(filename, ELoot.data.settings.to_yaml)
    ELoot.msg(type: "info", text: " Settings saved to file: #{filename}.") unless silent
  end

  def self.update_setting(input)
    setting_to_update = normalize_setting_name(input.first)
    ELoot.msg(type: "debug", text: "Normalized #{input.first} as #{setting_to_update}")

    if ELoot.data.settings.keys.include?(setting_to_update)
      default_value = ELoot.data.settings[setting_to_update].dup
      ELoot.msg(type: "debug", text: "recognized #{setting_to_update} as as valid #{default_value.class} setting")
      new_value = coerce_setting_value(setting_to_update, default_value, input[1..-1])
      ELoot.msg(type: "debug", text: "Normalized #{input[1..-1]} as #{new_value.inspect}")

      data.settings[setting_to_update] = new_value
      ELoot.msg(type: "info", text: " Updated #{setting_to_update} to #{new_value}")
      ELoot.save_profile()
    else
      ELoot.msg(type: "error", text: " #{setting_to_update} is not a recognized setting. Recognized setting names:")
      ELoot.msg(type: "error", text: ELoot.data.settings.keys.sort.join("\n"))
    end
  end
end

module ELoot # Sets Inventory
  def self.get_setup_data
    # Need the ready list
    loop do
      ELoot.data.ready_lines = ELoot.get_command("ready list", /<output class="mono"\/>/, silent: true, quiet: true)

      if ELoot.data.ready_lines.any? { |l| l =~ /Your current settings are/ }
        break
      else
        ELoot.msg(type: "info", text: "Ready List didn't load right. Trying again!")
      end
    end

    # Also need the weapon inventory
    exist = %r{<a exist=(?:'|")(?<id>.*?)(?:'|") noun=(?:'|")(?<noun>.*?)(?:'|")>(?<name>.*?)</a>}

    lines = ELoot.get_command("inventory full weapons", /<streamWindow/, silent: true, quiet: true)

    lines.each do |line|
      line.scan(exist) do |id, noun, name|
        unless ELoot.data.weapon_inv.any? { |weapon| weapon.id =~ /#{id}/ }
          ELoot.data.weapon_inv << GameObj.new(id, noun, name)
        end
      end
    end

    # Make sure to include what's in our hands
    ELoot.data.weapon_inv << GameObj.right_hand if checkright
    ELoot.data.weapon_inv << GameObj.left_hand if checkleft
  end

  def self.find_coin_containers
    return if ELoot.data.settings[:coin_hand_name].to_s.empty?

    # #Are we wearing the coin hand?
    ELoot.data.coin_hand = GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:coin_hand_name]}\b/i }

    # If not wearing it loop thru inv and see if we can find it
    unless ELoot.data.coin_hand
      GameObj.inv.each do |item|
        next unless GameObj.containers[item.id]

        Inventory.open_single_container(item)

        ELoot.data.coin_hand = item.contents&.find { |thing| thing.name =~ /\b#{ELoot.data.settings[:coin_hand_name]}\b/i }
        if ELoot.data.coin_hand
          ELoot.data.coin_container = item
          break
        end
      end
    end

    # Return if not found or if it's a coin hand
    return unless ELoot.data.coin_hand && ELoot.data.coin_hand.name !~ /\b(coin|hand)\b.*\b(coin|hand)\b/

    # Is it a bag or a gambling kit?
    lines = ELoot.get_command("analyze ##{ELoot.data.coin_hand.id}", /You analyze/, silent: true, quiet: true)

    if lines.any? { |l| l =~ /noun must remain "pouch," "bag," or "purse," immediately preceded by the word "coin."/ }
      ELoot.data.coin_bag = ELoot.data.coin_hand
    elsif lines.any? { |l| l =~ /Gambling Kit/ }
      ELoot.data.gambling_kit = ELoot.data.coin_hand
    end
  end

  def self.find_containers_stow
    container_match = /<a exist="([^"]+)" noun="[^"]+">[^(.]+\(([a-z]+)\)/
    max_retries = 3
    attempt = 0

    loop do
      container_lines = ELoot.get_command("stow list", /<output class="mono"\/>/, silent: true, quiet: true)

      container_lines.each do |line|
        if line =~ container_match
          item_id, sack_type = Regexp.last_match(1), Regexp.last_match(2)
          ELoot.data.sacks[sack_type] = GameObj.inv.find { |i| i.id == item_id }
        end
      end

      ELoot.data.sacks.compact!

      if container_lines.any? { |l| l =~ /(none)/ }
        ELoot.msg(type: "error", text: " No containers are set. Please see the ingame 'stow' command")
        exit
      elsif !container_lines.any? { |l| l =~ /default/ }
        ELoot.msg(type: "error", text: " Set stow container using STOW SET before using this script")
        exit
      elsif !container_lines.any? { |l| l =~ /You have the following containers set as stow targets/ }
        attempt += 1
        if attempt >= max_retries
          ELoot.msg(type: "error", text: " Failed to load stow containers after #{max_retries} attempts.")
          exit
        end
        ELoot.msg(type: "info", text: " Stow containers didn't load right. Trying again! (Attempt #{attempt}/#{max_retries})")
        next
      else
        break
      end
    end
  end

  def self.find_containers_other
    # Add appraisal and overflow containers
    containers = [:appraisal_container, :overflow_container, :secondary_overflow]
    containers.each do |key|
      container_name = ELoot.data.settings[key].to_s
      next if container_name.empty?

      # Store container in ELoot.data.sacks
      if (container = GameObj.inv.find { |i| i.name =~ /\b#{container_name}\b/i })
        ELoot.data.sacks[container_name] = container
      end

      if key != :appraisal_container && ELoot.data.settings[:sell_container].include?("overflow") && !ELoot.data.settings[:sell_container].include?(container_name)
        ELoot.data.settings[:sell_container] << container_name
      end
    end
  end

  def self.find_sheathes_ready_list
    # Finding the ready list sheaths
    sheath_list_match = /(?:sheath|secondary sheath):\s+<d\scmd="store\s(\w+)\sclear">[^<]+<a\sexist="(\d+)"\snoun="[^"]+">([^<]+)<\/a>(?:\s[^<]+)?<\/d>/

    ELoot.data.ready_lines.each do |line|
      next unless line =~ sheath_list_match

      sheath_key  = Regexp.last_match(1).to_s.downcase
      sheath_id   = Regexp.last_match(2)

      if (sheath = GameObj.inv.find { |i| i.id == sheath_id })
        ELoot.data.ready_list[sheath_key] = sheath
      end
    end
  end

  def self.find_sheath_hidden(sheath_name, type)
    # Fixme: needs expanded as more hidden sheathe are found (pun intended)
    ELoot.msg(type: "debug", text: "ELoot.data.ready_list[#{type}] not found but is in setup")

    lines = Lich::Util.quiet_command_xml("pull my sheath", /You reach down|I'm afraid that/, /<prompt/, true, 2, true)
    ELoot.msg(type: "debug", text: "Is sheath hidden? : #{lines}")

    if lines.any? { |line| line =~ /You reach down/i }
      # Store the sheath if found
      if (skin_sheath = GameObj.inv.find { |i| i.name =~ /\b#{sheath_name}\b/i })
        ELoot.data.ready_list[type] = skin_sheath
      end

      Lich::Util.quiet_command_xml("push my #{sheath_name}", /You reach down|I'm afraid that you can't pull that/, /<prompt/, true, 2, true)
    end
  end

  def self.find_sheathes_skin
    return unless ELoot.data.settings[:skin_enable]

    # Add the skin sheathes if set
    [:skin_sheath, :skin_sheath_blunt].each do |key|
      sheath_name = ELoot.data.settings[key].to_s
      next if sheath_name.empty?

      sheath = GameObj.inv.find { |i| i.name =~ /\b#{sheath_name}\b/i }
      ELoot.data.ready_list[key.to_s] = sheath if sheath

      # Check if it's a hidden sheath
      ELoot.find_sheath_hidden(sheath_name, key.to_s) if ELoot.data.ready_list[key.to_s].nil?
    end
  end

  def self.find_weapons_ready_list
    ready_list_match = /(?:shield|weapon|secondary weapon|ranged weapon):\s+<d\scmd="store\s(\w+)\sclear">[^<]+<a\sexist="(\d+)"\snoun="[^"]+">([^<]+)<\/a>(?:\s[^<]+)?<\/d>\s+\(<d\scmd='store set'>([^<]+)<\/d>\)/
    ELoot.data.ready_lines.each do |line|
      next unless line =~ ready_list_match

      key = Regexp.last_match(1).downcase
      item_id = Regexp.last_match(2)
      method = Regexp.last_match(4)

      ELoot.data.ready_list[key] = ELoot.data.weapon_inv.find { |i| i.id == item_id }
      ELoot.data.ready_method[key] = method
    end
  end

  def self.find_weapons_skin
    return unless ELoot.data.settings[:skin_enable]

    ['edged', 'blunt'].each do |item|
      sheath = item == 'edged' ? "skin_sheath" : "skin_sheath_blunt"
      weapon_name = item == 'edged' ? :skin_weapon : :skin_weapon_blunt
      weapon_attr = item == 'edged' ? :skin_edged= : :skin_blunt=

      next if ELoot.data.ready_list[sheath].to_s.empty?
      next if ELoot.data.settings[weapon_name].to_s.empty?

      # First, try finding the weapon inside the sheath
      weapon = ELoot.data.ready_list[sheath].contents&.find { |i| i.name =~ /\b#{ELoot.data.settings[weapon_name]}\b/i }

      # If not found in the sheath, check weapon inventory
      weapon ||= ELoot.data.weapon_inv.find { |i| i.type =~ /weapon/i && i.name =~ /\b#{ELoot.data.settings[weapon_name]}\b/i }

      # Assign the found weapon
      ELoot.data.send(weapon_attr, weapon)
    end
  end

  def self.set_inventory
    # Check account type
    ELoot.data.account_type = Account.subscription

    # Get data - ready list and weapon inventory
    ELoot.get_setup_data

    # Find the stow containers we need: stow, overflow, appraisal
    ELoot.find_containers_stow

    # Find the overflow and appraisal containers
    ELoot.find_containers_other

    # Find sheathes
    ELoot.find_sheathes_ready_list
    ELoot.find_sheathes_skin

    # Make sure the bags are open and contents available
    all_bags = ELoot.data.sacks.merge(ELoot.data.ready_list)

    all_bags.values.uniq.compact.each do |item|
      Inventory.open_single_container(item)
    end

    # Find the weapons
    ELoot.find_weapons_ready_list
    ELoot.find_weapons_skin

    # Are we using weighless coin containers?
    ELoot.find_coin_containers

    # Do we have a fossil charm?
    unless (charm_name = ELoot.data.settings[:charm_name].to_s).empty?
      ELoot.data.charm = GameObj.inv.find { |i| i.name =~ /\b#{charm_name}\b/i }
    end

    # Have an eonake gauntlet?
    ELoot.data.gauntlet = GameObj.inv.find { |i| i.name =~ /\beonake gauntlet\b/i }

    # Using a disk?
    ELoot.disk_usage

    # If ELoot.data.settings[:keep_closed] close anything we opened
    Inventory.close_sell_containers

    ELoot.validate_setup
  end

  def self.validate_setup
    setup_checks = [
      [proc { ELoot.data.sacks.nil? }, " Not able to find the stow sacks."],
      [proc { !ELoot.data.settings[:overflow_container].to_s.empty? && ELoot.data.sacks[ELoot.data.settings[:overflow_container]].nil? }, " Not able to find the primary overflow container: #{ELoot.data.settings[:overflow_container]}"],
      [proc { !ELoot.data.settings[:secondary_overflow].to_s.empty? && ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]].nil? }, " Not able to find the secondary overflow container: #{ELoot.data.settings[:secondary_overflow]}"],
      [proc { ELoot.data.settings[:skin_enable] && !ELoot.data.settings[:skin_sheath].to_s.empty? && !ELoot.data.ready_list["skin_sheath"] }, " Not able to find the bladed skinning sheath: #{ELoot.data.settings[:skin_sheath]}"],
      [proc { ELoot.data.settings[:skin_enable] && !ELoot.data.settings[:skin_sheath_blunt].to_s.empty? && ELoot.data.ready_list["skin_sheath_blunt"].nil? }, " Not able to find the blunt skinning sheath: #{ELoot.data.settings[:skin_sheath_blunt]}"],
      [proc { ELoot.data.settings[:skin_enable] && !ELoot.data.settings[:skin_weapon].to_s.empty? && ELoot.data.skin_edged.nil? }, " Not able to find the bladed skinning weapon: #{ELoot.data.settings[:skin_weapon]}"],
      [proc { ELoot.data.settings[:skin_enable] && !ELoot.data.settings[:skin_weapon_blunt].to_s.empty? && ELoot.data.skin_blunt.nil? }, " Not able to find the blunt skinning weapon: #{ELoot.data.settings[:skin_weapon_blunt]}"],
      [proc { !ELoot.data.settings[:coin_hand_name].to_s.empty? && ELoot.data.coin_hand.nil? }, " Not able to find the coin storage: #{ELoot.data.settings[:coin_hand_name]}"],
      [proc { !ELoot.data.settings[:charm_name].to_s.empty? && ELoot.data.charm.nil? }, " Not able to find the fossil charm: #{ELoot.data.settings[:charm_name]}"],
    ]

    valid_setup = true

    setup_checks.each do |condition, message|
      if condition.call
        ELoot.msg(text: message)
        valid_setup = false
      end
    end

    unless valid_setup
      ELoot.msg(text: " Something went wrong initializing eloot. Please check ;eloot setup. Exiting...", space: true)
      exit
    end
  end
end

module ELoot # Main methods
  @@data ||= nil

  def self.data
    @@data
  end

  def self.loot
    if Spell['Berserk'].active?
      ELoot.msg(type: "info", text: " Your current status prevents you from looting.")
      return
    end

    sleep 0.2

    # remember what is in our hands
    ELoot.data.right_hand = GameObj.right_hand
    ELoot.data.left_hand = GameObj.left_hand

    ELoot.change_stance(100) if ELoot.data.settings[:loot_defensive]
    ELoot.msg(type: "debug", text: "ELoot.loot: Defensive Stance") if ELoot.data.settings[:loot_defensive]

    ELoot.msg(type: "debug", text: "ELoot.loot: Begin Skinning") if ELoot.data.settings[:skin_enable]
    Loot.skin if ELoot.data.settings[:skin_enable]

    ELoot.msg(type: "debug", text: "ELoot.loot: Searching")
    Loot.search
    sleep(0.1)

    ELoot.msg(type: "debug", text: "ELoot.loot: Looting the Room")
    Loot.room

    # use coin hand if we have it
    ELoot.use_coin_hand

    Inventory.return_hands
  end

  def self.sell
    Sell.sell
  end
end

module ELoot # Regional bounty Selling
  module Region
    def self.by_town(tag)
      ELoot.data.towns.to_h { |town| [town.location, Room[town.find_nearest_by_tag(tag)]] }
    end

    def self.tag_for_town(town, tag)
      self.by_town(tag).find { |k, _v| k.downcase.include?(town.downcase) }.last
    end

    def self.in_region(place) # Determine if the bounty town is within the characters region
      # vaalor ferry, west cart, east cart, RR boot
      boundaries = [
        Map.ids_from_uid(14001002).first, # Ta'Vaalor Ferry
        Map.ids_from_uid(13002021).first, # Western Spine Mine Cart
        Map.ids_from_uid(13003019).first, # Eastern Spine Mine Cart
        Map.ids_from_uid(373014).first,   # River's Rest Boot
        Map.ids_from_uid(7503001).first,  # Hinterwilds Caravan Dropoff
        Map.ids_from_uid(13205202).first, # EN Hinterwilds Transport
        Map.ids_from_uid(4132054).first,  # IMT Hinterwilds Transport
        Map.ids_from_uid(7111).first,     # Portmaster - Wehnimer's Landing
        Map.ids_from_uid(3002033).first,  # Portmaster - Teras Isle
        Map.ids_from_uid(2101030).first,  # Portmaster - River's Rest
        Map.ids_from_uid(4744014).first,  # Portmaster - Solhaven
        Map.ids_from_uid(7118259).first,  # Portmaster - Kraken's Fall
        Map.ids_from_uid(7136032).first,  # Portmaster - Ta'Vaalor
        Map.ids_from_uid(7133026).first,  # Portmaster - Icemule Trace
      ]

      bounty_town = Bounty.town == "Cold River" ? "Hinterwilds" : Bounty.town

      place = self.tag_for_town(bounty_town, place).id
      path = Room.current.path_to(Room[place])

      return place if path && boundaries.none? { |fence| path.include?(fence) }
    end

    def self.furrier
      self.in_region("furrier")
    end

    def self.gemshop
      self.in_region("gemshop")
    end
  end
end

module ELoot # Script utility type methods
  def self.capitalize_words(string)
    cap_string = string.to_s.split.each { |i| i.capitalize! }.join(' ')
    return cap_string
  end

  def self.disk_usage
    return if DownstreamHook.list.include?("eloot-diskintegration") && ELoot.data.settings[:use_disk] && !ELoot.data.disk.nil?

    if ELoot.data.settings[:use_disk]
      if ELoot.data.disk.nil?
        # Longer search if hook isn't already present
        if DownstreamHook.list.include?("eloot-diskintegration")
          ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{XMLData.name} #{ELoot.data.disk_nouns_regex}\b/ }
        else
          15.times do
            ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{XMLData.name} #{ELoot.data.disk_nouns_regex}\b/ }
            break if ELoot.data.disk
            sleep(0.1)
          end
        end
      end

      # Add downstream hook if not already present
      unless DownstreamHook.list.include?("eloot-diskintegration")
        DownstreamHook.add(
          'eloot-diskintegration',
          proc do |line|
            if line =~ /The \<a exist\=\"\d+\" noun\=\"#{ELoot.data.disk.noun}\"\>#{ELoot.data.disk.name}\<\/a\>.+ disintegrates\./
              ELoot.data.disk = nil
              ELoot.data.disk_full = false
            end
            line
          end
        )
      end

    else
      # Clear disk and remove downstream hook if not using disk
      ELoot.data.disk = nil
      DownstreamHook.remove("eloot-diskintegration")
    end
  end

  def self.format_number(number)
    whole, decimal = number.to_s.split('.')
    if whole.to_i < -999 || whole.to_i > 999
      whole.reverse!.gsub!(/(\d{3})(?=\d)/, '\\1,').reverse!
    end
    [whole, decimal].compact.join('.')
  end

  def self.get_command(command, regex, silent: nil, quiet: false)
    if ELoot.data.settings[:debug]
      silent = nil
      quiet = false
    end

    lines = []
    rt_regex = /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i
    regex = Regexp.union(regex, rt_regex)

    begin
      lines = Lich::Util.issue_command(command, regex, usexml: true, silent: silent, quiet: quiet)

      ELoot.msg(type: "debug", text: " get_command: command: #{command} | lines - #{lines}")
      raise if lines.any? { |l| l =~ rt_regex }
    rescue
      ELoot.wait_rt
      retry
    end

    return lines
  end

  def self.get_res(command, regex = nil)
    rt_regex = /(?:Roundtime:|\.\.\.wait|Wait) (\d+) [Ss]ec(?:onds?)?\.?|An uncontrollable urge to scratch the rash/
    regex = regex.nil? ? Regexp.union(/.*?/, rt_regex) : Regexp.union(regex, rt_regex)
    result = nil
    loop do
      result = dothistimeout(command, 3, regex)
      break unless result =~ rt_regex

      ELoot.wait_rt
    end

    return result
  end

  def self.get_script_version
    data = Script.list.find { |x| x.name == Script.current.name }.inspect
    return data[/version: (\d+\.\d+\.\d+)/i, 1]
  end

  def self.help
    rows = []
    rows << [{ value: "*** Mark ANYTHING you don't want to lose. #{Script.current.name.capitalize} is not perfect! ***", colspan: 2, alignment: :center }]
    rows << :separator
    rows << ['Command', 'Description']
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} setup", "UI configuration tool"]
    rows << [' ', ' ']
    rows << ["#{$lich_char}#{Script.current.name}", "Loots items/creatures"]
    rows << ["#{$lich_char}#{Script.current.name} sell", "Sells loot based on UI options"]
    rows << ["#{$lich_char}#{Script.current.name} sell alchemy_mode", "Doesn't sell alchemy reagents"]
    rows << ["#{$lich_char}#{Script.current.name} deposit", "Deposits coins and notes"]
    rows << [' ', ' ']
    rows << ["#{$lich_char}#{Script.current.name} pool", "Only does the locksmith pool"]
    rows << ["#{$lich_char}#{Script.current.name} pool deposit", "Only deposits boxes"]
    rows << ["#{$lich_char}#{Script.current.name} pool return", "Only returns boxes"]
    rows << :separator
    rows << [{ value: 'Command Line Options', colspan: 2, alignment: :center }]
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} --sellable <categories>", "Items that match GameObj sellable categories"]
    rows << ["#{$lich_char}#{Script.current.name} --type <things>", "Items that match GameObj types"]
    rows << ["#{$lich_char}#{Script.current.name} --sell <items>", "Specific items"]
    rows << :separator
    rows << [{ value: 'Hoarding', colspan: 2, alignment: :center }]
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} list <gem/reagent>", "Lists hoarded inventory"]
    rows << ["#{$lich_char}#{Script.current.name} reset <gem/reagent>", "Resets hoarded inventory"]
    rows << ["#{$lich_char}#{Script.current.name} deposit <gem/reagent>", "Deposits item(s) into hoard"]
    rows << ["#{$lich_char}#{Script.current.name} raid <gem/reagent> <item> x<amount>", "Raids hoard for item(s)"]
    rows << ["#{$lich_char}#{Script.current.name} bounty", "Raids hoard for bounty gems"]
    rows << :separator
    rows << [{ value: 'Troubleshooting', colspan: 2, alignment: :center }]
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} debug", "Toggles debugging on or off"]
    rows << ["#{$lich_char}#{Script.current.name} debug file", "Toggles logging to a file on or off"]
    rows << ["#{$lich_char}#{Script.current.name} list", "Lists script settings"]
    rows << ["#{$lich_char}#{Script.current.name} test", "Lists variables and their values"]
    rows << :separator
    rows << [{ value: "*** Mark ANYTHING you don't want to lose. #{Script.current.name.capitalize} is not perfect! ***", colspan: 2, alignment: :center }]

    table = Terminal::Table.new :title => "#{Script.current.name.capitalize} Help", :rows => rows
    table.align_column(1, :right)
    respond
    respond table
    respond
  end

  def self.manage_sorter
    if running? "sorter"
      kill_script("sorter")
      before_dying { Script.start('sorter') }
    end
  end

  def self.msg(type: "yellow", text: nil, space: false)
    # color options - set type to use
    # yellow, orange, teal, green, plain

    return if type == "debug" && (!ELoot.data.settings[:debug] && !ELoot.data.settings[:debug_file])

    if text.class == Hash
      text = text.inspect.gsub("#<", "#")
    elsif text.class == Array
      text = text.to_s
    elsif text.class == String
      text = text.gsub("#<", "#")
    end

    respond '' if space
    if type == 'debug' && ELoot.data.settings[:debug]
      begin
        Lich::Messaging.mono(Lich::Messaging.xml_encode(text))
      rescue NoMethodError
        respond(text)
      end
    elsif type != 'debug'
      Lich::Messaging.msg(type, text)
    end
    respond '' if space

    if ELoot.data.settings[:debug_file]
      ELoot.data.debug_logger.log(text)
    end
  end

  def self.test(debug = false)
    rows = []
    rows << :separator
    rows << [{ value: "   *** Settings ***", colspan: 7 }]
    rows << :separator
    rows << ["Parameter", { value: "Value", colspan: 6 }]
    rows << :separator
    ELoot.data.settings.each do |item|
      setting_value = item[0].to_s =~ /gem_horde_inv|alchemy_horde_inv/ ? item[1].join("\n") : ELoot.word_wrap(item[1].to_s)
      rows << [item[0], { value: setting_value, colspan: 6 }]
    end

    rows << :separator
    rows << [{ value: " *** Sacks ***", colspan: 7 }]
    rows << :separator
    rows << ["Type", "ID", { value: "Name", colspan: 5 }]
    rows << :separator
    ELoot.data.sacks.each do |key, value|
      rows << [key, value.id, { value: value.name, colspan: 5 }]
    end

    rows << :separator
    rows << [{ value: " *** Disk ***", colspan: 7 }]
    rows << :separator
    rows << ["ID", { value: "Name", colspan: 6 }]
    rows << :separator
    rows << [ELoot.data.disk.id, { value: ELoot.data.disk.name, colspan: 6 }]

    rows << :separator
    rows << [{ value: " *** Full Disk/Sack Check ***", colspan: 7 }]
    rows << :separator
    rows << [{ value: "Disk Full: #{ELoot.data.disk_full.inspect}", colspan: 7 }]
    rows << [{ value: "Sacks Full: #{ELoot.data.sacks_full.map(&:name)}", colspan: 7 }]

    rows << :separator
    rows << [{ value: " *** Contents ***", colspan: 7 }]
    rows << :separator
    rows << ["Container", "Item", "Type", { value: "Sellable", colspan: 4 }]
    rows << :separator
    items_opened = []
    ELoot.data.sacks.each_value do |sack|
      next if items_opened.include?(sack.id)

      items_opened << sack.id
      Inventory.open_single_container(sack)

      sack.contents.each do |thing|
        rows << [sack.noun.capitalize, ELoot.word_wrap(thing.name, 25), thing.type.split(',').join("\n"), { value: thing.sellable, colspan: 4 }]
      end
    end

    rows << :separator
    rows << [{ value: " *** Ready List ***", colspan: 7 }]
    rows << :separator
    rows << ["Type", "ID", { value: "Name", colspan: 5 }]
    rows << :separator
    ELoot.data.ready_list.each do |key, value|
      rows << [key, value.id, { value: value.name, colspan: 5 }]
    end

    rows << :separator
    rows << [{ value: " *** Skinning Weapons ***", colspan: 7 }]
    rows << :separator
    rows << ["Type", "ID", { value: "Name", colspan: 5 }]
    rows << :separator
    rows << ["Edged Skinner", ELoot.data.skin_edged.id, { value: ELoot.data.skin_edged.name, colspan: 5 }]
    rows << ["Blunt Skinner", ELoot.data.skin_blunt.id, { value: ELoot.data.skin_blunt.name, colspan: 5 }]

    rows << :separator
    rows << [{ value: " *** Coin Hand ***", colspan: 7 }]
    rows << :separator
    rows << ["Type", "ID", { value: "Name", colspan: 5 }]
    rows << :separator
    rows << ["Coin Hand", ELoot.data.coin_hand.id, { value: ELoot.data.coin_hand.name, colspan: 5 }]
    rows << ["Coin Container", ELoot.data.coin_container.id, { value: ELoot.data.coin_container.name, colspan: 5 }]

    rows << :separator
    rows << [{ value: " *** GameObj Types ***", colspan: 7 }]
    rows << :separator
    rows << [{ value: "#{ELoot.word_wrap(GameObj.type_data.map { |k, _v| k }.sort.join(', '), 100)}", colspan: 7 }]

    table = Terminal::Table.new :title => "#{Script.current.name.capitalize} v#{ELoot.get_script_version}", :rows => rows

    if debug
      return table
    else
      respond
      respond table
      respond
    end
  end

  def self.time_between(method_name, gap)
    current_time = Time.now

    # Check if the method was previously called and if the time gap is satisfied
    if ELoot.data.last_called[method_name]
      time_diff = current_time - ELoot.data.last_called[method_name]
      return false if time_diff < gap
    end

    ELoot.data.last_called[method_name] = current_time
    return true # Return true if either it's the first call or enough time has passed
  end

  def self.unlootable(item)
    return unless ELoot.data.settings[:log_unlootables]
    return unless item.type.nil?

    ELoot.msg(type: "info", text: " #{item.name} was not lootable, adding to list.")
    ELoot.data.settings[:unlootable].push(item.name)
    ELoot.save_profile()
  end

  def self.word_wrap(text, width = 60)
    text.gsub(/(.{1,#{width}})(\s+|\Z)/, "\\1\n").strip
  end

  def self.wait_rt
    sleep 0.2
    waitcastrt?
    waitrt?
    sleep 0.2
  end
end

module ELoot # Game utility type methods
  def self.box_phase(box)
    return unless box.type =~ /box/
    return if box.name =~ /enruned|mithril/i
    return unless ELoot.data.settings[:loot_phase] && Spell[704].known? && Spell[704].affordable?

    loop {
      cast_result = Spell[704].cast("at ##{box.id}")
      break unless cast_result =~ /^\[Spell Hindrance for/ && Spell[704].affordable?
    }
  end

  def self.box_unphase(box)
    lines = ELoot.get_command("look at ##{box.id}", /You see/, silent: true, quiet: true)
    return box unless lines.any? { |line| line =~ /shifting/i }

    dothistimeout("drop ##{box.id}", 3, /flickers in and out of existence/)
    ELoot.wait_rt

    ELoot.get_command("glance hands", /<(right|left)/, silent: true, quiet: true)

    return [GameObj.right_hand, GameObj.left_hand].find { |hand| hand.type =~ /box/ }
  end

  def self.change_stance(new_stance)
    return if Effects::Debuffs.active?("Frenzy") || dead?
    return if Char.percent_stance >= new_stance
    return if new_stance == 100 && Char.percent_stance >= 80

    stances = {
      0   => 'offensive',
      20  => 'advanced',
      40  => 'forward',
      60  => 'neutral',
      80  => 'guarded',
      100 => 'defensive'
    }
    if CMan.available?('Stance Perfection') && ![0, 20, 40, 60, 80, 100].include?(new_stance)
      cmd = "cman stance #{new_stance}"
    elsif stances[new_stance]
      cmd = "stance #{stances[new_stance]}"
    else
      cmd = 'stance defensive'
    end

    expiry = Time.now + 2
    while Char.percent_stance != new_stance
      res = dothistimeout(cmd, 2, /You are now|You move into|Roundtime|wait|Your rage causes you/i)
      if res =~ /Roundtime: (\d+)|wait (\d+)/i
        sleep((Regexp.last_match(1) || Regexp.last_match(2)).strip.to_f - 1)
        expiry = Time.now + 2
      elsif Time.now > expiry
        break
      else
        break
      end
      sleep 0.5
    end
  end

  def self.decurse(obj)
    return true unless obj.type =~ /cursed/
    return false unless ELoot.data.settings[:loot_types].include?("cursed")

    if Spell[315].known? && !Spell[315].affordable?
      mana_regex = Regexp.union(
        /An invigorating rush of mana pulses through you/i,
        /You are too mentally fatigued to attempt this ability/i,
        /You're already at full mana./i,
        /Your mana control skills are not yet advanced/i,
      )
      dothistimeout "mana pulse", 2, mana_regex
    end

    if Spell[315].known? && !Spell[315].affordable?
      ELoot.msg(type: "info", text: "** #{obj.name} is cursed and you don't have enough mana to cast 315.", space: true)
      return false
    end

    if Spell[315].known? && Spell[315].affordable?
      Spell[315].cast("at ##{obj.id}")
      return true
    end

    unless ELoot.data.gauntlet.nil?
      lines = ELoot.get_command("look ##{ELoot.data.gauntlet.id}", /You are currently wearing the eonake gauntlet/, silent: true, quiet: true)
      if lines.any? { |l| l =~ /(right|left) hand/ }
        gauntlet_hand = Regexp.last_match(1)
      end

      if GameObj.right_hand.name == 'Empty'
        return true if gauntlet_hand == 'right'
        if gauntlet_hand == 'left'
          ELoot.get_res("remove ##{ELoot.data.gauntlet.id}", /You slip the gauntlet from/)
          ELoot.get_res("swap", /You swap/) unless GameObj.right_hand.id == ELoot.data.gauntlet.id
          ELoot.get_res("wear ##{ELoot.data.gauntlet.id}", /You slip the eonake gauntlet over/)
          return true
        end
      end

      if GameObj.left_hand.name == 'Empty'
        return true if gauntlet_hand == 'left'
        if gauntlet_hand == 'right'
          ELoot.get_res("remove ##{ELoot.data.gauntlet.id}", /You slip the gauntlet from/)
          ELoot.get_res("swap", /You swap/) unless GameObj.left_hand.id == ELoot.data.gauntlet.id
          ELoot.get_res("wear ##{ELoot.data.gauntlet.id}", /You slip the eonake gauntlet over/)
          return true
        end
      end
    end

    return false
  end

  def self.find_boxes
    box_sacks = Array.new
    box_sacks.push(ELoot.data.sacks["box"]) if ELoot.data.settings[:sell_container].include?("box")
    box_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
    box_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]]) if ELoot.data.settings[:sell_container].include?("overflow")
    box_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]]) if ELoot.data.settings[:sell_container].include?("overflow")

    ELoot.msg(type: "debug", text: " box_sacks: #{box_sacks}")

    items = []
    checked_containers = []
    box_sacks.each { |sack|
      next if sack.nil? || checked_containers.include?(sack.id)

      checked_containers.push(sack.id)
      Inventory.open_single_container(sack)
      found_boxes = sack.contents.to_a.find_all { |obj| obj.type =~ /box/ }
      unless found_boxes.nil? || found_boxes.empty?
        items += found_boxes
        ELoot.data.sacks_full.delete(sack)
      end
    }

    if ELoot.data.settings[:use_disk]
      ELoot.wait_rt
      ELoot.wait_for_disk
      Inventory.open_single_container(ELoot.data.disk)
      items += ELoot.data.disk.contents.to_a.find_all { |obj| obj.type =~ /box/ }
    end

    ELoot.msg(type: "debug", text: " box_list before: #{items}")

    box_list = items.uniq

    ELoot.msg(type: "debug", text: " box_list after: #{box_list}")

    box_list.reject! { |box| box.contents.empty? }

    box_list.dup.each do |box|
      lines = ELoot.get_command("look in ##{box.id}", /<container|That is closed|You see the shifting form/, silent: true, quiet: true)

      if lines.any? { |line| line =~ /In the|There is nothing/i }
        # Makes sure the item's contents are available
        Inventory.container_contents(box)

        if box.contents.length.positive?
          unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
            Inventory.drag(box)
          end
          Loot.box_loot(box)
        end
        box_list.delete(box)
      end
    end

    return box_list
  end

  def self.find_trash
    trashcan = nil
    trash_id = nil

    # Use new trash verb first
    lines = ELoot.get_command('trash', /You could discard items|You do not notice/, silent: true, quiet: true)

    lines.each do |line|
      if (match_data = line.match(/You could discard items in an? <a exist="(-?\d+)" noun=".*?">.*?<\/a>/))
        trash_id = match_data[1]
      end
    end

    unless trash_id.nil?
      trashcan = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.id == trash_id }
      return trashcan unless trashcan.nil?
    end

    # Still here see if the meta tag is present
    can = Regexp.last_match(1) if Room.current.tags.find { |t| t =~ /meta:trashcan:(.*)/ }

    # Most common scenario - meta:trashcan is defined and GameObj.room_desc is available or trashcan is in GameObj.loot
    trashcan = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.name =~ Regexp.union(can.to_a) }
    return trashcan unless trashcan.nil?

    # Still here? Either the meta:can isn't defined or the room description isn't available. Either way we have to use the noun.
    can = ["barrel", "bin", "basket", "bucket", "canister", "case", "casket", "crate", "hearth", "pit", "stump", "urn", "wastebasket", "wastebin", "wastecan"]
    trash = (Room.current.description.to_s + GameObj.room_desc.to_s + GameObj.loot.to_s).scan(Regexp.union(can)).uniq

    # Check to make sure it's actually a trashcan and not a custom disk/container
    trash.each { |item|
      lines = ELoot.get_command("look in #{item}", /<container|I could not find what you were referring to.|The(.*?)is filled with a variety of garbage/, silent: true, quiet: true)

      if lines.grep(/variety of garbage/).any?
        trashcan = GameObj.new(Regexp.last_match(1), item, item) if lines.find { |l| l =~ /^<container id='(-?[0-9]+)' title/ }
      end

      break unless trashcan.nil?
    }

    return trashcan
  end

  def self.find_worker
    worker = nil
    lines = nil
    name = $1 if Room.current.tags.find { |w| w =~ /meta:boxpool:npc:(.*)/ }

    unless name
      name = ["worker", "trickster", "Jahck", "woman", "attendant", "gnome", "merchant", "dwarf"]
    end

    20.times {
      worker = (GameObj.npcs).find { |obj| obj.name =~ Regexp.union(name) }
      break if worker

      lines = ELoot.get_command("look", /<resource picture/, silent: true, quiet: true)
      sleep 0.1
    }

    if worker.nil?
      ELoot.msg(type: "info", text: " Failed to find the locksmith pool NPC")
      ELoot.msg(type: "info", text: " GameObj.npcs: #{GameObj.npcs}")
      ELoot.msg(type: "info", text: " Lines: #{lines}")

      ELoot.msg(type: "info", text: " Update your map db; ;repository download-mapdb")
      ELoot.msg(type: "info", text: " If the error persists then report this to Elanthia-Online")
      exit
    end

    return worker
  end

  def self.fwi?(room)
    (room.location =~ /Four Winds|Mist Harbor|Western Harbor/)
  end

  def self.fwi_return
    current_town = Room.current.find_nearest_by_tag("town")

    if current_town == 3668
      if UserVars.mapdb_fwi_trinket.nil?
        ELoot.msg(type: "yellow", text: "  Please set your FWI trinket in go2 setup. \n")
        exit
      end

      ELoot.go2(3669)
      if UserVars.mapdb_fwi_return_room.nil?
        worn = GameObj[UserVars.mapdb_fwi_trinket].nil? ? false : true
        fput "get my #{UserVars.mapdb_fwi_trinket}" unless worn
        fput "turn ##{GameObj[UserVars.mapdb_fwi_trinket].id}"
        fput "stow my #{UserVars.mapdb_fwi_trinket}" unless worn
      else
        ELoot.go2(UserVars.mapdb_fwi_return_room)
      end
    end
  end

  def self.f2p?
    return false if XMLData.game == 'GST'
    ELoot.data.account_type =~ /F2P|Free/i
  end

  def self.go2(place)
    ELoot.msg(type: "debug", text: " go2 called by #{caller[0]} | place: #{place}")
    fput('unhide') if (hidden? || invisible?)

    # If we're going to a place we do it based on the sell_fwi settings
    if place.class == String && ELoot.data.settings[:sell_fwi]
      fwi_place = Room.list.find { |room| room.tags.include?(place) && ELoot.fwi?(room) }

      place = fwi_place.id if fwi_place
    end

    return if Room.current.id == place || Room.current.tags.include?(place)

    if Room.current.id.nil?
      ELoot.msg(type: "error", text: ' unknown room location')
    end

    if place.class == String && UserVars.mapdb_use_urchins && UserVars.mapdb_urchins_expire.positive? && XMLData.game != 'GSIV' && Room.current.location !~ /the Hinterwilds/

      case place
      when 'locksmith pool'
        place = 'locksmithpool'
      when 'pawnshop'
        place = 'pawn'
      when 'consignment'
        place = 'alchemy'
      end

      Script.run('go2', "town --disable-confirm", { quiet: true }) if Room.current.tags.any?(/nexus/)

      result = dothistimeout("urchin guide #{place}", 3, ELoot.data.urchin_msg)
      if result =~ /You currently have no access to the urchin/
        UserVars.mapdb_use_urchins = false
        Script.run('go2', "#{place} --disable-confirm", { quiet: true })
      elsif result.nil?
        ELoot.msg(type: "error", text: " Unknown result from urchin guide usage.")
      end
    else
      Script.run('go2', "#{place} --disable-confirm", { quiet: true })
    end
  end

  def self.deposit_note
    return unless (note = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /\b(?:note|scrip|chit)\b/ })

    current_room = Room.current.id

    _where_is_previous_var, shortest_distances = Room.current.dijkstra

    bank_rooms = Room.list.find_all { |room| room.tags.include?('bank') && !ELoot.fwi?(room) }.map(&:id)

    # Filter out rooms that have no path (distance is nil)
    reachable_banks = bank_rooms.select { |room_id| shortest_distances[room_id] }

    # Pick the bank room with the shortest distance
    local_bank = reachable_banks.min_by { |room_id| shortest_distances[room_id] }

    ELoot.go2(local_bank)

    fput("deposit note")

    20.times do
      break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(note.id))
      sleep 0.1
    end

    ELoot.go2(current_room)
  end

  def self.read_note
    result = 0
    note = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /\b(?:note|scrip|chit)\b/ }
    return unless note

    line = ELoot.get_res("read ##{note.id}", /Hold in right hand to use/)

    if line =~ /has a value of (.*?) silver and reads/
      result = $1.delete(",").to_i
    end

    return result
  end

  def self.silver_check
    wealth_pattern = /^You have (no|[,\d]+|but one) silver with you/
    wealth = ELoot.get_command("wealth quiet", wealth_pattern, silent: true, quiet: true).join(" ")
    coins = 0
    if wealth.gsub('but one', '1') =~ wealth_pattern
      coins = $1.gsub(',', '').to_i
    end
    return coins
  end

  def self.silver_deposit(deposit_bag = false)
    if ELoot.data.coin_hand && deposit_bag && ELoot.data.settings[:sell_deposit_coinhand]
      # Remove the coin hand from a container if needed
      unless ELoot.data.coin_container.nil?
        Inventory.free_hand
        Inventory.open_single_container(ELoot.data.coin_container)
        Inventory.drag(ELoot.data.coin_hand)
      end

      if ELoot.data.coin_bag.nil? && ELoot.data.gambling_kit.nil?
        fput "open ##{ELoot.data.coin_hand.id}"
        ELoot.wait_rt
      else
        begin
          lines = ELoot.get_command("look in ##{ELoot.data.coin_hand.id}", /Inside the|There is nothing|That is closed/i, silent: true, quiet: true)

          if lines.any? { |l| l =~ /That is closed/i }
            ELoot.get_command("open ##{ELoot.data.coin_hand.id}", ELoot.data.silent_open)
            raise
          end

          if lines.any? { |l| l =~ /Inside the .* you see approximately [,\d]+ silver coins\.|Get a job/i }
            ELoot.get_res("get coins from ##{ELoot.data.coin_bag.id}", /You reach into your/)
            ELoot.data.coin_bag_full = false
            ELoot.wait_rt
          elsif lines.any? { |l| l =~ /There are [,\d]+ silvers scattered/ }
            ELoot.get_res("gather ##{ELoot.data.gambling_kit.id}", /You dig inside/)
            ELoot.data.gambling_kit_full = false
            ELoot.wait_rt
          end
        rescue
          retry
        end
      end

      # Return it to the container if needed
      unless ELoot.data.coin_container.nil?
        Inventory.store_item(ELoot.data.coin_container, ELoot.data.coin_hand)
      end
    end

    current_silvers = ELoot.silver_check
    keep_silvers = [ELoot.data.settings[:sell_keep_silver].to_i, 0].max
    share_silvers = current_silvers - keep_silvers

    # Share silvers
    if ELoot.data.settings[:sell_share_silvers] && share_silvers.positive?
      fput("share #{share_silvers}")
    end

    # use coin hand if we have it and don't want to deposit the coins
    ELoot.use_coin_hand unless ELoot.data.settings[:sell_deposit_coinhand]

    # Any notes on us?
    note = ELoot.data.sacks["default"].contents.find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }

    # Head over to the bank if something to do.
    current_silvers = ELoot.silver_check
    return unless (current_silvers != keep_silvers) || (note && !ELoot.f2p?)

    ELoot.go2('bank')

    unless ELoot.f2p?
      if XMLData.room_title == '[Pinefar, Depository]'
        dothistimeout "give banker #{current_silvers} silver", 2, ELoot.data.deposit_regex
      else
        dothistimeout "deposit all", 2, ELoot.data.deposit_regex
      end
    else
      # F2P accounts have to be handled a little different due to bank capacity
      loop do
        lines = ELoot.get_command("bank account", /You currently have an account/, silent: true, quiet: true)

        if lines.find { |line| line.match(/in the amount of (?<silver>[\d,]+) silver/) }
          silver_balance = Regexp.last_match[:silver].gsub(',', '').to_i
        end

        if lines.find { |line| line.match(/a maximum of (?<silver>[\d,]+) silvers/) }
          silver_max = Regexp.last_match[:silver].gsub(',', '').to_i
        end

        # Make sure we have the correct current silvers
        current_silvers = ELoot.silver_check

        # Do we have enough to deposit without taking out a note?
        if (silver_balance + current_silvers) < silver_max
          result = dothistimeout("deposit #{current_silvers}", 2, Regexp.union(ELoot.data.deposit_regex, /you don't have access/i)) if current_silvers.positive?
          if result =~ /you don't have access/i
            ELoot.msg("info", " You don't have a bank in this town. Exiting...")
            exit
          end
          break
        else
          deposit_size = silver_max - silver_balance
          dothistimeout("deposit #{deposit_size}", 2, ELoot.data.deposit_regex)

          # Do we have enough to pull a full note and still have 10,000 buffer to deposit?
          current_silvers = ELoot.silver_check

          note_size = current_silvers >= 10000 ? silver_max : (silver_max - (10000 - current_silvers))
          dothistimeout("withdraw #{note_size}", 2, /The teller/)
          note = [GameObj.right_hand, GameObj.left_hand].find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }
          Inventory.single_drag(note)
        end
      end
    end

    # Finally withdraw any keeper silvers and stow note if given
    if XMLData.room_title == '[Pinefar, Depository]'
      dothistimeout("ask banker for #{keep_silvers} silvers", 2, ELoot.data.withdraw_regex) if keep_silvers.positive?
    else
      dothistimeout("withdraw #{keep_silvers}", 2, ELoot.data.withdraw_regex) if keep_silvers.positive?
    end
    note = [GameObj.right_hand, GameObj.left_hand].find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }
    Inventory.single_drag(note) if note
    ELoot.wait_rt
  end

  def self.silver_withdraw(amount)
    if ELoot.silver_check >= amount && Char.percent_encumbrance < 20
      return
    end

    ELoot.go2('bank')

    ELoot.silver_deposit

    if XMLData.room_title == '[Pinefar, Depository]'
      fput("ask banker for #{amount} silvers")
    else
      fput("withdraw #{amount} silvers")
    end

    if ELoot.silver_check < amount
      ELoot.msg(type: "info", text: " Not enough silver in current area's bank.")
      exit
    end
  end

  def self.use_coin_hand
    return if ELoot.data.coin_hand.nil?
    available_silver = ELoot.silver_check
    return unless available_silver.positive?

    # If we don't have enough silver to bother with the gambling kit then return
    return if ELoot.data.gambling_kit && available_silver < (ELoot.data.settings[:gambling_toss_min] || 0)

    unless ELoot.data.coin_container.nil?
      Inventory.free_hand
      Inventory.open_single_container(ELoot.data.coin_container)
      Inventory.drag(ELoot.data.coin_hand)
    end

    if ELoot.data.coin_bag.nil? && ELoot.data.gambling_kit.nil?
      dothistimeout("close ##{ELoot.data.coin_hand.id}", 1, /You feel your pockets lighten/)
    elsif (ELoot.data.coin_bag && !ELoot.data.coin_bag_full) || (ELoot.data.gambling_kit && !ELoot.data.gambling_kit_full)
      Inventory.free_hand

      begin
        if ELoot.data.coin_bag
          get_coins = "put #{available_silver} silver in ##{ELoot.data.coin_bag.id}"
        else
          get_coins = "toss ##{ELoot.data.gambling_kit.id}"
        end

        lines = Lich::Util.issue_command(get_coins, /You (?:place|toss)|There is only room|That might work better|needs to be open|cannot find room|coin (?:pouch|bag|purse) is already full!$/i)

        ELoot.wait_rt if ELoot.data.gambling_kit

        if lines.any? { |l| l =~ /That might work better if you opened|needs to be open/i }
          ELoot.get_command("open ##{ELoot.data.coin_hand.id}", ELoot.data.silent_open)
          raise
        elsif lines.find { |line| line.match(/coin (?:pouch|bag|purse) is already full!$/) }
          ELoot.data.coin_bag_full = true
        elsif lines.find { |line| line.match(/There is only room for (?<silver>[\d,]+) more coins inside/) }
          capacity = Regexp.last_match[:silver].gsub(',', '').to_i
          ELoot.get_res("put #{capacity} silver in ##{ELoot.data.coin_bag.id}", /You place/)
          ELoot.data.coin_bag_full = true
        elsif lines.find { |line| line.match(/You cannot find room to store any more silver/) }
          ELoot.data.gambling_kit_full = true
          ELoot.wait_rt
        end
      rescue
        retry
      end
    end

    unless ELoot.data.coin_container.nil?
      Inventory.store_item(ELoot.data.coin_container, ELoot.data.coin_hand)
    end
  end

  def self.wait_for_disk
    return unless ELoot.data.disk
    return unless ELoot.data.settings[:use_disk]

    if ELoot.data.disk.status =~ /gone/ || !GameObj.loot.find { |l| l.name =~ /#{Char.name} #{ELoot.data.disk_nouns_regex}\b/ }
      ELoot.msg(type: "info", text: " Waiting for your disk to arrive")
      50.times do
        break if (ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} #{ELoot.data.disk_nouns_regex}\b/ })

        sleep(0.1)
      end
      ELoot.wait_rt
    end

    return unless ELoot.data.disk && ELoot.data.disk.status !~ /gone/ && ELoot.data.disk.contents.nil?

    Inventory.open_single_container(ELoot.data.disk)
  end
end

module ELoot # Inventory methods
  module Inventory
    def self.container_contents(container, time: 3)
      wait_time = time * 10 # check in tenth of a second increments
      wait_time.times {
        return true if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)
        sleep 0.1
      }
      echo "This failed the first time. Trying again. | Container: #{container.name} | GameObj.containers.keys: #{GameObj.containers.keys.include?(container.id)} | container.contents.is_a?: #{container.contents.is_a?(Array)} caller: #{caller[0]}"

      # still here? Try one more time, goofy things happen
      lines = ELoot.get_command("look in ##{container.id}", ELoot.data.look_regex, silent: true, quiet: true)

      wait_time.times {
        return true if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)
        return true if lines.any? { |l| l =~ /The wide leather belt|You glance|There is nothing|stuffed with a variety of shredded up paper and cloth|Looking at the .*?, you notice:/i }
        sleep 0.1
      }
      echo "This failed the second time. | Container: #{container.inspect} | calller: #{caller[0]}"
      ELoot.msg(type: "info", text: " Not able to determine the contents of  #{container.name}.")
      ELoot.msg(type: "info", text: " Pausing the script to handle it yourself")
      ELoot.msg(type: "info", text: " ;unpause #{Script.current.name} after addressing to continue!")

      Script.current.pause
    end

    def self.check_auto_closer
      return if ELoot.data.settings[:auto_close].empty?

      ELoot.data.sacks.each_value do |bag_obj|
        if ELoot.data.settings[:auto_close].include?(bag_obj.name)
          Inventory.open_single_container(bag_obj)
        end
      end
    end

    def self.clear_hands
      # remember what is in our hands
      ELoot.data.right_hand = GameObj.right_hand
      ELoot.data.left_hand = GameObj.left_hand

      # Empty hands
      Inventory.free_hands(both: true)

      if checkright || checkleft
        ELoot.msg(type: "error", text: "** Something is wrong. Can't empty hands! Report this to Elanthia-Online. A log is helpful. Exiting...", space: true)
        exit
      end
    end

    def self.close_container(bag)
      ELoot.get_res("close ##{bag.id}", ELoot.data.close_regex)
    end

    def self.close_sell_containers
      return unless ELoot.data.settings[:keep_closed]

      ELoot.data.sell_containers.each { |sack|
        # Don't close ready list containers or storage and retrieval of weapons/shields gets messed up
        next if ELoot.data.ready_list.find { |_k, v| v.id == sack.id }

        Inventory.close_container(sack)
      }
    end

    def self.drag(item, to = "hand") # drags things from inventory to a hand
      return if item.nil? || item.empty? || item.name == "Empty"

      # make sure the hand we want is free
      case to
      when "hand"
        Inventory.free_hand
        to = GameObj.right_hand.id.nil? ? 'right' : 'left'
      when "right"
        Inventory.free_hands(right: true)
      when "left"
        Inventory.free_hands(left: true)
      end

      line = ELoot.get_res("_drag ##{item.id} #{to}")

      20.times {
        return true if ([GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))
        break if line =~ /Get what|I could not find what you were referring to/
        sleep 0.1
      }

      if line =~ /Get what|I could not find what you were referring to/
        ELoot.data.sacks.each_value do |bag_obj|
          Inventory.open_single_container(bag_obj)
        end

        lost_item = Sell.check_inventory.find { |obj| obj.id == item.id }
        if lost_item
          Inventory.drag(lost_item, to)
        else
          ELoot.msg(type: "info", text: " Can't find #{item.name}. Looked in all the bags in case it got misplaced.")
        end

      end

      return false
    end

    def self.wear(item)
      return false if item.nil? || item.empty? || item.name == "Empty"

      line = ELoot.get_res("_drag ##{item.id} wear")

      # Give it time to update and confirm action
      20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)) && (GameObj.inv.map(&:id).compact.include?(item.id))
        break if line =~ /You can't wear that/
        sleep 0.1
      }

      # Still here? Something is wrong, inform the player and exit.
      if [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
        ELoot.msg(type: "warn", text: " Something is wrong. Unable to wear the #{item}. Exiting to avoid losing items.")
        ELoot.msg(type: "warn", text: " Please grab a short log of what just happened and post it to the scripting discord for debugging")
        exit
      end
    end

    def self.free_hand
      right_usable = [Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max < 3
      right_hand_free = GameObj.right_hand.id.nil? && right_usable

      left_usable = [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max < 3
      left_hand_free = GameObj.left_hand.id.nil? && left_usable
      return if right_hand_free || left_hand_free

      waitrt?

      favor_left = ELoot.data.settings[:favor_left]
      right_damaged = [Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max == 3

      if (favor_left && left_usable) || right_damaged
        Inventory.free_hands(left: true)
      elsif right_usable
        Inventory.free_hands(right: true)
      else
        ELoot.msg(type: "yellow", text: " Neither hand is usable. Looks like you need an Empath!", space: true)
        exit
      end
    end

    def self.free_hands(right: false, left: false, both: false)
      if (right || both) && checkright
        # Are we holding a ready_list weapon? If so put it into its sheath
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == GameObj.right_hand.id }[0])
          Inventory.stow_ready_list(ready_item, GameObj.right_hand)
        end
        if checkright
          Inventory.single_drag(GameObj.right_hand) # drags single item into container
        end
      end

      if (left || both) && checkleft
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == GameObj.left_hand.id }[0])
          Inventory.stow_ready_list(ready_item, GameObj.left_hand)
        end
        if checkleft
          Inventory.single_drag(GameObj.left_hand) # drags single item into container
        end
      end
    end

    def self.open_loot_containers(item)
      # Method intended for opening containers that will receive loot from the loot room or loot item command
      ELoot.msg(type: "debug", text: " Start of open_loot_containers(item)")

      # makes sure any auto-closers are open before looting
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      return unless ELoot.data.settings[:keep_closed]

      Inventory.open_single_container(ELoot.data.sacks["default"])
      Inventory.open_single_container(ELoot.data.settings[:overflow_container])
      Inventory.open_single_container(ELoot.data.settings[:secondary_overflow])

      containers = Array.new
      item.each { |loot|
        next if ELoot.data.sacks[loot.type].nil?

        unless containers.include?(ELoot.data.sacks[loot.type].id)
          Inventory.open_single_container(ELoot.data.sacks[loot.type])
          containers.push(ELoot.data.sacks[loot.type].id)
        end
      }
    end

    def self.open_single_container(sack)
      ELoot.msg(type: "debug", text: " Inventory.open_single_container: sack = #{sack}")

      return if sack.nil? || sack.empty?

      container = sack.class == GameObj ? sack : ELoot.data.sacks[sack]
      ELoot.msg(type: "debug", text: " open_single_container(sack): before open sack - #{sack} container: #{container}")

      # If its in the game obj and contents.is_a?(Array) return
      return if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)

      # Still here? Assume the container is closed and open it
      ELoot.get_command("open ##{container.id}", ELoot.data.silent_open, silent: true, quiet: true)

      # check out whats inside
      lines = ELoot.get_command("look in ##{container.id}", ELoot.data.look_regex, silent: true, quiet: true)
      return if lines.any? { |l| l =~ /You glance|There is nothing|stuffed with a variety of shredded up paper and cloth|^Looking at the .*?, you notice:|^The .+? has .+? in its left-hand scabbard and .+? in its right-hand scabbard\.$/i }

      ELoot.data.sell_containers.push(container) unless ELoot.data.sell_containers.include?(container)
    end

    def self.return_hands
      # Nothing to do
      return if ELoot.data.right_hand.id == GameObj.right_hand.id && ELoot.data.left_hand.id == GameObj.left_hand.id

      # Check Right Hand
      unless ELoot.data.right_hand.id == GameObj.right_hand.id
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == ELoot.data.right_hand.id }[0])
          Inventory.return_ready_list(ready_item, ELoot.data.right_hand)
        else
          Inventory.drag(ELoot.data.right_hand, 'right')
        end
      end

      # Check Left Hand
      unless ELoot.data.left_hand.id == GameObj.left_hand.id
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == ELoot.data.left_hand.id }[0])
          Inventory.return_ready_list(ready_item, ELoot.data.left_hand)
        else
          Inventory.drag(ELoot.data.left_hand, 'left')
        end
      end
    end

    def self.return_ready_list(ready_item, item)
      10.times {
        ELoot.get_res("ready #{ready_item}", ELoot.data.get_regex)
        sleep 0.2
        return true if [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
      }

      return false
    end

    def self.single_drag(item, phase_thing = true) # drags single item into container
      stored = false
      return if item&.name == "Empty"
      return if Inventory.single_drag_box(item)

      # Try sacks in order of priority: item-specific, default, overflow, secondary overflow
      containers = [
        ELoot.data.sacks[item.type],
        ELoot.data.sacks["default"],
        ELoot.data.sacks[ELoot.data.settings[:overflow_container]],
        ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]]
      ]

      begin
        containers.each_with_index do |bag, index|
          if stunned?
            ELoot.wait_rt
            raise
          end
          next if ELoot.data.sacks_full.include?(bag)

          if bag.nil?
            case index
            when 1
              ELoot.msg(type: "yellow", text: " No default container identified. This shouldn't happen.")
              ELoot.msg(type: "yellow", text: "   Check your STOW settings. Exiting")
              exit
            when 2
              ELoot.msg(type: "info", text: " Skipping primary overflow.   No container identified.")
            when 3
              ELoot.msg(type: "info", text: " Skipping secondary overflow. No container identified.")
            end
          else
            result = Inventory.store_item(bag, item)
            if result
              ELoot.box_phase(item) if phase_thing
              stored = true
              break
            end
          end
        end
      rescue
        retry
      end

      # If item wasn't stored, pause and address
      unless stored
        ELoot.msg(type: "info", text: " Failed to store the #{item.name}.")
        ELoot.msg(type: "info", text: " Pausing the script to handle it yourself")
        ELoot.msg(type: "info", text: " ;unpause #{Script.current.name} after addressing to continue!")

        Script.current.pause
      end
    end

    def self.single_drag_box(item)
      return false unless item.type =~ /box/
      return false unless ELoot.data.settings[:use_disk]
      return false if ELoot.data.disk_full

      ELoot.wait_for_disk
      return false unless ELoot.data.disk

      # still here so lets try to put the box in the disk
      result = Inventory.store_item(ELoot.data.disk, item)
      return true if result

      # inform user it didn't fit if !result
      ELoot.msg(type: "info", text: " The #{item} won't fit in the #{ELoot.data.disk}. Trying different container.")
      ELoot.data.disk_full = true

      return false
    end

    def self.single_loot(item) # loots a single item
      return if item.nil?

      # loot item will fallback to the default sack but if both are full we need to loot manually
      bag = ELoot.data.sacks[item.type]
      bag = nil if bag.nil? || ELoot.data.sacks_full.include?(bag)
      bag ||= ELoot.data.sacks["default"]
      bag = nil if bag.nil? || ELoot.data.sacks_full.include?(bag)

      unless bag
        Inventory.single_drag(item)
        return
      end

      lines = ELoot.get_command("loot ##{item.id}", ELoot.data.put_regex)

      if lines.any? { |line| line =~ /<\/inv>You can't put your <a exist=".*?" noun=".*?">.*?<\/a> in the <a exist="(\d+)" noun=".*?">.*?<\/a>.  It's closed!/ }
        bag_id = $1
        bag = GameObj.inv.find { |i| i.id == bag_id }
        # Must be an auto closer. Their ID and contents don't drop from GameObj.container when closed
        if GameObj.containers.keys.include?(bag.id) && bag.contents.is_a?(Array)
          ELoot.data.settings[:auto_close].push(bag.name)
          Inventory.open_single_container(bag)
          ELoot.msg(type: "info", text: " #{bag.name} must be an autocloser, adding to list.")
          ELoot.save_profile()
        end
      end

      20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and ELoot.data.sacks[item.type].contents.to_a.map(&:id).include?(item.id))
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and ELoot.data.sacks["default"].contents.to_a.map(&:id).include?(item.id))
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and item.type =~ /skin/)

        sleep 0.1
      }

      # edge case of treasure system mismatch
      return true if Sell.check_inventory.any? { |obj| obj.id == item.id }

      # still here so just loot it manually
      Inventory.single_drag(item)
    end

    def self.store_item(bag, item, is_skinner = false)
      return unless item&.name != "Empty"

      5.times do
        lines = ELoot.get_command("_drag ##{item.id} ##{bag.id}", ELoot.data.put_regex)

        if lines.any? { |l| l =~ /You can't.*?It's closed!/ }
          if GameObj.containers.keys.include?(bag.id) && bag.contents.is_a?(Array)
            # Must be an auto closer. Their ID and contents don't drop from GameObj.container when closed
            ELoot.data.settings[:auto_close].push(bag.name)
            ELoot.msg(type: "info", text: " #{bag.name} must be an autocloser, adding to list.")
            ELoot.save_profile()
          end
          ELoot.get_res("open ##{bag.id}", ELoot.data.silent_open)
          lines = ELoot.get_command("_drag ##{item.id} ##{bag.id}", ELoot.data.put_regex)
        end

        return true if lines.any? { |l| l =~ /You are unable to handle|That is not yours|Hey, that belongs to|Get what|I could not find what you were referring/ }

        if lines.any? { |l| l =~ /put something that you can't hold/ }
          ELoot.unlootable(item)
          return true
        end

        # Check if full
        if lines.any? { |l| l =~ /won't fit/i }
          ELoot.data.sacks_full.push(bag)
          return false
        end

        if lines.any? { |l| l =~ /crumbles? and decays? away|crumbles? into a pile of dust/i }
          ELoot.msg(type: "info", text: " This item was crumbly, adding to list")
          ELoot.data.settings[:crumbly].push(item.name)
          ELoot.save_profile()
          return true
        end

        Inventory.open_single_container(bag) unless bag.contents.is_a?(Array) || is_skinner

        20.times do
          return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) && bag.contents.to_a.map(&:id).include?(item.id))

          # Lousy weapon displayers don't have contents
          if is_skinner
            return true if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
          end
          sleep 0.1
        end

        waitrt?
      end

      # Give up and return false
      return false
    end

    def self.stow_ready_list(ready_item, item)
      if ELoot.data.ready_method[ready_item] =~ /put in sheath/
        Inventory.open_single_container(ELoot.data.ready_list["sheath"])
      elsif ELoot.data.ready_method[ready_item] =~ /put in secondary/
        Inventory.open_single_container(ELoot.data.ready_list["2sheath"])
      end

      10.times {
        ELoot.get_res("store #{ready_item}", ELoot.data.put_regex)
        sleep 0.2
        return true if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
      }

      return false
    end
  end # End of Inventory
end

module ELoot # Gem and Reagent hoarding
  module Hoard
    def self.set_type_vars(type)
      return if type == ELoot.data.hoard_type
      ELoot.data.hoard_type = type

      # Sets the working variables based on the type of hoarding
      ELoot.data.container_settings = ELoot.data.settings["#{type}_horde_containers".to_sym] # This is the container list to hoard FROM
      ELoot.data.everything_list = ELoot.data.settings["#{type}_everything_list".to_sym]     # Hoard everything toggle
      ELoot.data.everything = ELoot.data.settings["#{type}_everything".to_sym]               # List of excluded gems
      ELoot.data.only_list = ELoot.data.settings["#{type}_only_list".to_sym]                 # Only hoard specific items toggle
      ELoot.data.only = ELoot.data.settings["#{type}_list".to_sym]                           # List of specific items
      ELoot.data.locker_city = ELoot.data.settings["#{type}_locker_name".to_sym]             # This is the name of the city where the locker is
      ELoot.data.locker = ELoot.data.settings["#{type}_horde_locker".to_sym]                 # True/False toggle to use locker
      ELoot.data.cache = ELoot.data.settings["#{type}_horde_container".to_sym]               # This is container name in UI
      ELoot.data.inventory = ELoot.data.settings["#{type}_horde_inv".to_sym]                 # Gem inventory
      ELoot.data.use_hoarding = ELoot.data.settings["#{type}_horde".to_sym]                  # True/False toggle to hoard gems
      ELoot.data.use_house_locker = ELoot.data.settings["#{type}_horde_locker_che".to_sym]   # Toggle for CHE locker
      ELoot.data.che_rooms = ELoot.data.settings["#{type}_horde_che_rooms".to_sym]           # Array of locations outside CHE locker room
      ELoot.data.che_entry = ELoot.data.settings["#{type}_horde_che_entry".to_sym]           # Entry string into CHE locker
      ELoot.data.che_exit = ELoot.data.settings["#{type}_horde_che_exit".to_sym]             # Exit string from CHE locker
    end

    def self.validate_hoarding_settings
      need_return = false

      if ELoot.data.locker && ELoot.data.locker_city.empty?
        ELoot.msg(text: " Hoard #{ELoot.data.hoard_type} in a locker is toggled on the UI but location is empty")
        need_return = true
      end

      if ELoot.data.cache.empty?
        ELoot.msg(text: " A gem hoarding container is not identified (yes, you need it for a locker too)")
        need_return = true
      end

      if ELoot.data.container_settings.length.zero?
        ELoot.msg(text: " No containers identified to hoard #{ELoot.data.hoard_type}s from.")
        ELoot.msg(text: " Please make selection in UI Gem/Alchemy Hoarding Tab")
        need_return = true
      end

      if need_return
        ELoot.msg(text: " The hoarding settings need updated.", space: true)
        return false
      end

      return true
    end

    def self.check_type(item)
      obj_type = ELoot.data.hoard_type == 'alchemy' ? 'reagent' : ELoot.data.hoard_type

      item = item.gsub(/teeth/, "tooth")
      noun = item.split.last

      if item =~ GameObj.type_data[obj_type][:exclusion]
        return false
      elsif GameObj.type_data[obj_type][:name].to_s.match?(/\b#{item}\b/) || GameObj.type_data[obj_type][:noun].to_s.match?(/\b#{noun}\b/)
        return true
      elsif item =~ GameObj.type_data[obj_type][:name] || noun =~ GameObj.type_data[obj_type][:noun]
        return true
      elsif obj_type == 'reagent' && Room.list.any? { |r| r.tags.any? { |tag| (tag.end_with? item) || ((item.start_with? tag) && item =~ /ayana/) || (item.end_with? tag) } }
        return true
      elsif obj_type == 'reagent' && item =~ /kezmonian honey beryl|faintly glimmering dust/i
        return true
      elsif obj_type == 'gem' && item =~ /(?:deep blue sapphire|fiery ruby|glistening onyx|sparkling emerald) talon/i
        return true
      else
        return false
      end
    end

    def self.normalize_name(name)
      return if name.nil?
      if name.is_a?(String)
        case name
        when /essences? of (air|earth|water|fire)/
          return "essence of #{$1}"
        when /golden seed/
          return "tiny golden seed"
        when /motes? of essence/
          name = name.gsub(/motes?/, 'mote')
        end
      end

      name_rules = {
        'ies'    => 'y',
        'onyxes' => 'onyx',
        'zes'    => 'z',
        's'      => '',
      }

      name = name.full_name if name.is_a?(GameObj)
      name = name.downcase

      sizes = "tiny|small|medium|large|blue-violet|pyrite-capped vibrant"
      articles = "some|an? |the"
      descriptors = "\\w+s? of(?: polished)?|polished"

      pattern = /^\s*(?:containing )?(?:#{articles})?\s*(?:#{sizes})?\s*(?:#{descriptors})?\s*(?:#{sizes})?\s*(.*?)\s*$/

      unless name =~ pattern
        raise 'FIXME: normalize pattern did not match but should match anything'
      end
      name = $1

      if name =~ /^(.*?)(#{name_rules.keys.map { |x| Regexp::escape(x) }.join('|')})$/
        return "#{$1}#{name_rules[$2]}"
      else
        return name
      end
    end

    def self.go2_locker
      if ELoot.data.use_house_locker
        lockers = ELoot.data.che_rooms.split(',').map { |num| Room[num.to_i] }
      else
        lockers = Map.list.find_all { |room| (room.tags.any?(/meta:che:#{ELoot.data.locker_city}/) && room.tags.any?(/locker/)) || (room.tags.any?(/publiclockers/) && room.location =~ /#{ELoot.data.locker_city}/) }
      end

      locker_town = Room[Room[lockers.first.id].find_nearest_by_tag("town")].location
      current_town = Room[Room.current.find_nearest_by_tag("town")].location

      if locker_town =~ /the Isle of Four Winds/i && current_town != locker_town
        fwi_place = Room.list.find { |room| room.tags.include?('town') && ELoot.fwi?(room) }
        ELoot.go2(fwi_place.id)

        locker_town = Room[Room[lockers.first.id].find_nearest_by_tag("town")].location
        current_town = Room[Room.current.find_nearest_by_tag("town")].location
      end

      unless current_town == locker_town
        ELoot.msg(text: " Not able to hoard. Your hoarding locker is in #{locker_town}.", space: true)
        return
      end

      unless ELoot.data.account_type =~ /premium/i
        ELoot.silver_withdraw(1500)
      end

      index = 0

      if lockers.any? { |location| location.id == Room.current.id }
        index = lockers.find_index { |location| location.id == Room.current.id }
      end

      loop do
        place = lockers[index]
        ELoot.go2(place.id)
        ELoot.wait_rt

        # some rooms go directly to the locker instead of just outside
        break if GameObj.loot.find { |item| item.name == "dark stained antique oak trunk" }

        if ELoot.data.use_house_locker
          way_in = ELoot.data.che_entry
        else
          way_in_obj = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain|tapestry)$/ }
          way_in_obj.noun = "opening" if way_in_obj.noun == "tapestry"
          way_in = "go #{way_in_obj.noun}"
        end

        result = move "#{way_in}"

        break if result == true

        if index == lockers.length - 1 # Pause for 10 seconds if it's the last iteration
          respond
          ELoot.msg(text: " Not able to enter a locker. They might all be taken. Waiting 10 seconds then trying again.", space: true)
          respond
          sleep(10)
        end

        index = (index + 1) % lockers.length # Increment index, wrapping around if it exceeds the array length
      end
      ELoot.wait_rt
    end

    def self.open_locker(reset: false)
      ELoot.data.stash = nil
      retries = 0
      max_retries = 3
      error_log = []

      ELoot.wait_rt

      begin
        unless reset
          open_result = ELoot.get_command('open locker', /exist=".*?" noun="(?:locker|chest)"|That is already open.|<prompt time=".*?">&gt;<\/prompt>/)
        end

        ELoot.wait_rt

        ELoot.data.stash = GameObj.loot.find { |item| item.name =~ /#{ELoot.data.cache}/ }

        # maybe its on a counter
        if ELoot.data.stash.nil?
          counter = GameObj.room_desc.find { |item| item.name =~ /counter/ }
          ELoot.get_command("look on ##{counter.id}", /<container id='.*?' title=/, silent: true, quiet: true)
          ELoot.data.stash = counter.contents.find { |item| item.name =~ /#{ELoot.data.cache}/ }
        end

        raise StandardError if ELoot.data.stash.nil?
      rescue StandardError
        if retries < max_retries
          retries += 1
          ELoot.msg(text: " Something went wrong. Retrying... (Retry #{retries} of #{max_retries}).", space: true)
          error_log.push(open_result)
          sleep 1
          retry
        else
          ELoot.msg(text: " Not able to find the container in your locker for #{ELoot.data.hoard_type} hoarding.")
          ELoot.msg(text: " Please send the EO team the following on the discord scripting channel...")
          ELoot.msg(text: " Room: #{Room.current.id} | container_name: #{ELoot.data.cache}")
          error_log.push("Type: #{ELoot.data.hoard_type}")
          ELoot.msg(text: " Errors: #{error_log}")
          Hoard.leave_locker
        end
      else
        ELoot.get_command("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/, silent: true, quiet: true)
      end
    end

    def self.leave_locker
      locker_item = GameObj.loot.find { |item| item.name =~ /dark stained antique oak trunk|counter|locker/ }
      is_locksmith_room = Room.current.tags.include?('locksmith')

      return if locker_item.nil? || is_locksmith_room

      ELoot.get_res('close locker', /^You/)

      if ELoot.data.use_house_locker
        way_out = ELoot.data.che_exit
      else
        way_out_obj = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain|tapestry)$/ }
        way_out_obj.noun = "opening" if way_out_obj.noun == "tapestry"
        way_out = "go #{way_out_obj.noun}"
      end

      move "#{way_out}"
      ELoot.wait_rt
    end

    def self.build_inventory(refresh = false)
      return unless ELoot.data.inventory.empty? || refresh

      if (ELoot.data.locker || ELoot.data.use_house_locker) && ELoot.data.account_type =~ /premium/i
        result = Hoard.build_premium_locker_inventory
        return if result
      end

      ELoot.data.inventory = []
      percent_complete = 0

      ELoot.get_command("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/, silent: true, quiet: true)
      total_items = ELoot.data.stash.contents.count { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && !obj.after_name.nil? }
      empty_jars = ELoot.data.stash.contents.count { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && obj.after_name.nil? }

      if empty_jars.positive?
        ELoot.data.inventory << { :item => '*** empty jars ***', :count => empty_jars, :full => '  -' }
      end

      ELoot.data.stash.contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && !obj.after_name.nil? }.each_with_index do |jar, index|
        lines = ELoot.get_command("look in ##{jar.id} from ##{ELoot.data.stash.id}", /^Inside .*? you see [0-9]+ portion/, silent: true, quiet: true)

        if (lines.find { |line| line =~ /^Inside .*? you see ([0-9]+) portion/ })
          count = Regexp.last_match[1].to_i
          item = Hoard.normalize_name(jar.after_name).strip
          full = lines.any?(/It is full/)

          if Hoard.check_type(item)
            ELoot.data.inventory << { :item => item, :count => count, :full => full }
          end
        end

        percent_complete = (((index + 1).to_f / total_items) * 100).round(2)
        respond " percent complete: #{percent_complete}%"
      end

      ELoot.save_hoard_profile
    end

    def self.build_premium_locker_inventory
      if ELoot.data.use_house_locker
        lockers = ELoot.data.che_rooms.split(',').map(&:to_i)
        ELoot.data.locker_city = Room[Room[lockers.first].find_nearest_by_tag("town")].location.gsub(/the (town|city|village) of/, '').strip
      end

      all_lockers = ["Wehnimer's Landing", "Teras Isle", "Solhaven", "River's Rest", "Icemule Trace", "Zul Logoth", "Ta'Illistim", "Ta'Vaalor", "Mist Harbor", "Cysaegir", "Kraken's Fall", "Family Vault"]
      locker_town = "Family Vault" if ELoot.data.cache =~ /trunk/i

      locker_town ||= {
        'Kharam-Dzu'             => 'Teras Isle',
        'the Isle of Four Winds' => 'Mist Harbor'
      }[ELoot.data.locker_city] || ELoot.data.locker_city

      return false unless all_lockers.include?(locker_town)
      ELoot.data.inventory = []

      case ELoot.data.cache
      when /trunk/i
        start_from = "bound in wrought iron"
      when /chest/i
        start_from = "deep chest"
      when /rack/i
        start_from = "weapon rack"
      when /stand/i
        start_from = "armor stand"
      when /bin/i
        start_from = "magical item bin"
      when /wardrobe/i
        start_from = "clothing wardrobe"
      end

      lines = ELoot.get_command("locker manifest #{locker_town}", /Thinking back, you recall the contents|Looking in front of you/, silent: true, quiet: true)

      # Find the index of the line starting with the container name
      start_index = lines.index { |line| line.include?(start_from) }

      unless start_index # Return empty if not found
        ELoot.data.inventory = []
        return
      end

      end_index = lines[start_index + 1..-1].index { |line| line.strip.empty? }
      end_index = end_index.nil? ? lines.size : end_index + start_index + 1

      extracted_elements = lines[(start_index + 1)...end_index]

      empty_jars = extracted_elements.count { |line| line.match?(/(?:jar|bottle|beaker)/) && !line.include?("containing") }

      if empty_jars.positive?
        ELoot.data.inventory << { :item => '*** empty jars ***', :count => empty_jars, :full => '  -' }
      end

      extracted_elements.each do |line|
        match = line.match(/containing\s(?<item>.*?)\s+\((?<stored>\d+)\/(?<capacity>\d+)\)(?:\s+\(.*?\))?\z/)

        if match
          item = Hoard.normalize_name(match[:item]).strip
          stored = match[:stored].strip.to_i
          capacity = match[:capacity].strip.to_i
          full = stored == capacity

          if Hoard.check_type(item)
            ELoot.data.inventory << { :item => item, :count => stored, :full => full }
          end
        end
      end

      return true
    end

    def self.list_inventory(type)
      Hoard.set_type_vars(type)

      sorted_data = ELoot.data.inventory.sort_by { |entry| entry[:item] }

      rows = []
      rows << ["#{type.capitalize}s", 'Amount', 'Full?']
      rows << :separator
      sorted_data.each do |entry|
        rows << [ELoot.capitalize_words(entry[:item]), entry[:count], entry[:full]]
      end

      table = Terminal::Table.new :title => "#{type.capitalize} Inventory", :rows => rows
      table.align_column(1, :right)
      respond
      respond table
      respond
    end

    def self.reset_inventory(type)
      Hoard.set_type_vars(type)
      return unless Hoard.validate_hoarding_settings

      start_room = Room.current.id

      # Find the stash container and/or goto locker
      unless (ELoot.data.locker || ELoot.data.use_house_locker) && ELoot.data.account_type =~ /premium/i
        Hoard.hoard_prep
      end

      # Build inventory if needed
      Hoard.build_inventory(true)

      # Leave the locker if needed
      Hoard.leave_locker

      # Go back to original room
      ELoot.go2(start_room)

      # Save the new inventory
      ELoot.save_hoard_profile
    end

    def self.hoard_prep
      if ELoot.data.locker || ELoot.data.use_house_locker
        locker_item = GameObj.loot.find { |item| item.name =~ /dark stained antique oak trunk|counter|locker/ }
        is_locksmith_room = Room.current.tags.include?('locksmith')

        Hoard.go2_locker if is_locksmith_room || locker_item.nil?

        Hoard.open_locker
        # ELoot.data.stash variable set when opening locker
      else
        ELoot.data.stash = GameObj.inv.find { |i| i.name =~ /#{ELoot.data.cache}\b/ }
        Inventory.open_single_container(ELoot.data.stash)
      end
    end

    def self.need_to_hoard?(deposit = false)
      return true if deposit
      return true if ELoot.data.inventory.empty?
      bounty_gems = []

      if ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/ && ELoot.data.hoard_type == 'gem'

        gem_name, gem_number = Hoard.check_gem_bounty

        ELoot.data.items_to_hoard.each do |item|
          if item.name =~ /#{gem_name}/ && bounty_gems.length.to_i < gem_number
            bounty_gems.push(item)
          end
        end

        have_stock = ELoot.data.inventory.find { |item| item[:item] == gem_name }
        need_gems = gem_number - bounty_gems.length.to_i

        return true if need_gems.positive? && !have_stock.nil?
      end

      remaining_items = ELoot.data.items_to_hoard - bounty_gems

      remaining_items.each do |thing|
        result = ELoot.data.inventory.find { |item| item[:item] =~ /#{Hoard.normalize_name(thing.name)}/ }[:full]

        next if result == true

        if result.nil?
          result = ELoot.data.inventory.find { |item| item[:item] =~ /empty jar/ }
        end

        return true unless result.nil?
      end

      return false
    end

    def self.check_gem_bounty # Returns gem bounty name and count
      # return unless ELoot.data.settings[:gem_horde_turnin] && Bounty.task.gem? && !Bounty.task.assigned? # update to this post 5.11.2+
      return unless ELoot.data.settings[:gem_horde_turnin] && Bounty.task.gem? && !Bounty.task.type.to_s.end_with?("assignment")

      gem_name = Hoard.normalize_name(Bounty.task.gem)
      gem_number = Bounty.task.number

      return gem_name, gem_number
    end

    def self.hoard_items(type = nil, just_deposit = false)
      ELoot.data.hoard_deposit = []
      start_room = Room.current.id

      ['gem', 'alchemy'].each do |item|
        next if !type.nil? && type != item
        Hoard.set_type_vars(item)
        next unless ELoot.data.use_hoarding
        next unless Hoard.validate_hoarding_settings

        # Create the list of items to store
        Hoard.hoarding_list

        # Next unless there is something for use to do
        next unless Hoard.need_to_hoard?(just_deposit)

        # Find the stash container and/or goto locker
        Hoard.hoard_prep

        # Build inventory if needed
        Hoard.build_inventory

        # Finally store the items
        Hoard.store_items(just_deposit)

        # Withdraw bounty gems if needed
        if ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/ && ELoot.data.hoard_type == 'gem' && !just_deposit

          gem_name, gem_number = Hoard.check_gem_bounty
          gem_list = Hoard.hoarding_list(gem_name)

          if gem_list.count < gem_number
            need_for_bounty = gem_number - gem_list.count
            Hoard.shake(need_for_bounty, gem_name) unless need_for_bounty.zero?
          end
        end
      end

      # Leave the locker if needed
      Hoard.leave_locker

      # Go back to original room
      ELoot.go2(start_room)
    end

    def self.shake(number, name)
      ELoot.msg(type: "debug", text: "shake(number, name) | name: #{name}")
      # Refresh the cache because lockers are special
      ELoot.get_command("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/, silent: true, quiet: true)

      jar = ELoot.data.stash.contents.find { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && Hoard.normalize_name(obj.after_name) =~ /^#{name}$/ }
      ELoot.msg(type: "debug", text: "shake(number, name) | jar: #{jar}")

      return if jar.nil?

      3.times do
        Inventory.drag(jar)
        break if [GameObj.right_hand.id, GameObj.left_hand.id].include?(jar.id)
        # assuming if we are still here and its a locker it reset on us
        if ELoot.data.locker || ELoot.data.use_house_locker
          Hoard.open_locker(reset: true)
        end
      end

      number.times {
        lines = ELoot.get_command("shake ##{jar.id}", /You give your <a exist=".*?"/)
        item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.id !~ /#{jar.id}/ }
        Inventory.store_item(ELoot.data.sacks["default"], item)
        if lines.any?(/That was the last/)
          ELoot.data.inventory.delete_if { |obj| obj[:item] == name }
          ELoot.save_hoard_profile
          break
        end
      }

      Hoard.check_jar(name)

      # Need to refresh the locker contents because lockers are special
      ELoot.get_command("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/, silent: true, quiet: true)

      3.times do
        Inventory.store_item(ELoot.data.stash, jar)
        break unless [GameObj.right_hand.id, GameObj.left_hand.id].include?(jar.id)
        # assuming if we are still here and its a locker it reset on us
        if ELoot.data.locker || ELoot.data.use_house_locker
          Hoard.open_locker(reset: true)
        end
      end
    end

    def self.check_jar(item_name)
      need_save = false
      jar = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:jar|bottle|beaker)$/ }

      return if jar.nil?

      jar_lines = ELoot.get_command("look in ##{jar.id}", /^Inside .*? you see [0-9]+ portion|^The <a exist=".*?is empty/, silent: true, quiet: true)

      if (jar_lines.find { |line| line =~ /^Inside .*? you see ([0-9]+) portion/ })
        count = Regexp.last_match[1].to_i
        full = jar_lines.any?(/It is full/)

        index_to_update = ELoot.data.inventory.find_index { |item| item[:item] =~ /^#{item_name}$/ }
        if index_to_update
          ELoot.data.inventory[index_to_update][:count] = count
          ELoot.data.inventory[index_to_update][:full] = full
        end

        need_save = true
      elsif (jar_lines.find { |line| line =~ /^The <a exist=".*?is empty/ })
        if (index_to_update = ELoot.data.inventory.find_index { |item| item[:item] =~ /empty jar/i })
          ELoot.data.inventory[index_to_update][:count] += 1
        else
          ELoot.data.inventory << { :item => '*** empty jars ***', :count => 1, :full => '  -' }
        end

        need_save = true
      end

      ELoot.save_hoard_profile if need_save
    end

    def self.hoarding_list(single = nil)
      ELoot.data.items_to_hoard = []
      obj_type = ELoot.data.hoard_type == 'alchemy' ? 'reagent' : ELoot.data.hoard_type

      item_containers = ELoot.data.container_settings.filter_map { |key| ELoot.data.sacks[key] }

      item_containers.each do |container|
        next unless container

        Inventory.open_single_container(container)
        ELoot.data.items_to_hoard.concat(container.contents.to_a)
      end

      return ELoot.data.items_to_hoard.select { |item| item.name =~ /#{single}/ } if single

      ELoot.data.items_to_hoard.reject! { |item| item.type !~ /#{obj_type}/ }

      if ELoot.data.everything_list && ELoot.data.everything.any?
        ELoot.data.items_to_hoard.reject! { |item| item.name =~ Regexp.union(ELoot.data.everything) }
      end

      if ELoot.data.only_list && ELoot.data.only.any?
        ELoot.data.items_to_hoard.select! { |item| item.name =~ Regexp.union(ELoot.data.only) }
      end
    end

    def self.process_gems(inventory_gems)
      return inventory_gems unless ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/ && ELoot.data.hoard_type == 'gem'

      gem_name, gem_number = Hoard.check_gem_bounty
      return inventory_gems unless Hoard.normalize_name(inventory_gems.first) == gem_name

      # Do we have enough?
      if inventory_gems.count > gem_number
        gem_number.times { inventory_gems.pop }
      else
        need_for_bounty = gem_number - inventory_gems.count

        if ELoot.data.inventory.find { |thing| thing[:item] == gem_name }
          Hoard.shake(need_for_bounty, gem_name) unless need_for_bounty.zero?
          inventory_gems = []
        end
      end

      return inventory_gems
    end

    def self.get_gem_bounty
      return unless ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/

      gem_name, gem_number = Hoard.check_gem_bounty
      Hoard.hoarding_list(gem_name)

      Hoard.raid_cache(["get_gem_bounty", "raid", "gem", gem_name, "x#{gem_number}"])
    end

    def self.store_items(deposit = false)
      full_jars = []

      hoarding_items = ELoot.data.items_to_hoard.uniq { |item| item.name }.to_a

      hoarding_items.each do |item|
        jar = nil
        item_name = Hoard.normalize_name(item.name)
        ELoot.msg(type: "debug", text: "store_items | item_name: #{item_name} | item.name: #{item.name}")

        next if full_jars.include?(item_name)
        if ELoot.data.inventory.find { |thing| thing[:item] == item_name }[:full]
          full_jars << item_name
          ELoot.msg(text: " Skipping deposit of #{item.name} because its jar is full.", space: true)
          next
        end

        if ELoot.data.hoard_type == "gem"
          gem_name, _gem_number = Hoard.check_gem_bounty
          if item_name == gem_name
            ELoot.msg(text: " Skipping deposit of #{item.name} because its needed for a gem bounty.", space: true)
            next
          end
        end

        items_to_hoard = Hoard.hoarding_list(item.name)

        items_to_hoard = Hoard.process_gems(items_to_hoard) unless deposit
        next if items_to_hoard.length.zero?

        bottle = ELoot.data.stash.contents.find { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && Hoard.normalize_name(obj.after_name) =~ /^#{item_name}$/ }
        ELoot.msg(type: "debug", text: "store_items | bottle: #{bottle}")

        empty = ELoot.data.stash.contents.find { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && obj.after_name.nil? }

        if bottle
          3.times do
            Inventory.drag(bottle)
            break if [GameObj.right_hand.id, GameObj.left_hand.id].include?(bottle.id)
            # assuming if we are still here and its a locker it reset on us
            if ELoot.data.locker || ELoot.data.use_house_locker
              Hoard.open_locker(reset: true)
            end
          end

          jar = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:jar|bottle|beaker)$/ }
        elsif empty
          3.times do
            Inventory.drag(empty)
            break if [GameObj.right_hand.id, GameObj.left_hand.id].include?(empty.id)
            # assuming if we are still here and its a locker it reset on us
            if ELoot.data.locker || ELoot.data.use_house_locker
              Hoard.open_locker(reset: true)
            end
          end

          jar = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:jar|bottle|beaker)$/ }
          index_to_update = ELoot.data.inventory.find_index { |obj| obj[:item] =~ /empty jar/ }
          if index_to_update
            count = ELoot.data.stash.contents.count { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && obj.after_name.nil? }
            if count.zero?
              ELoot.data.inventory.delete_if { |obj| obj[:item] =~ /empty jar/ }
            else
              ELoot.data.inventory[index_to_update][:count] = count
            end

            ELoot.save_hoard_profile
          end
        end

        if jar.nil?
          ELoot.msg(text: " No empty jars found to store #{item.name}.", space: true)
          next
        end

        thing_name = nil
        items_to_hoard.each do |thing|
          thing_name = Hoard.normalize_name(thing.name)

          Inventory.drag(thing)

          result = ELoot.get_res("_drag ##{thing.id} ##{jar.id}", /You (add|put)|The.*?is full/)

          case result
          when /into your empty (?:jar|bottle|beaker)/
            ELoot.data.inventory << { item: thing_name, count: 1, full: false }
            ELoot.data.inventory.uniq!
          when /is full/
            ELoot.msg(text: "Something went wrong. Need to rebaseline inventory.", space: true)

            Inventory.store_item(ELoot.data.stash, jar)
            Inventory.store_item(ELoot.data.sacks["default"], thing)
            ELoot.wait_rt

            Hoard.build_inventory(true)
            break
          end

          ELoot.data.hoard_deposit << { :item => thing_name, :type => ELoot.data.hoard_type }

          break if result =~ /filling it/
        end

        Hoard.check_jar(thing_name)

        # Need to refresh the locker contents because lockers are special
        ELoot.get_command("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/, silent: true, quiet: true)

        3.times do
          Inventory.store_item(ELoot.data.stash, jar)
          break unless [GameObj.right_hand.id, GameObj.left_hand.id].include?(jar.id)
          # assuming if we are still here and its a locker it reset on us
          if ELoot.data.locker || ELoot.data.use_house_locker
            Hoard.open_locker(reset: true)
          end
        end
      end
    end

    def self.raid_cache(options)
      ELoot.msg(type: "debug", text: " Hoard.raid_cache options: #{options}")

      if options[2] !~ /gem|reagent|alchemy/
        ELoot.msg(text: " To use this option - ;eloot raid <type> <item to get> x<how many>.")
        ELoot.msg(text: " Ex ;eloot raid gem blue diamond x5")
        ELoot.msg(text: " <type> can be gem or reagent")
        exit
      end

      Inventory.clear_hands

      if options[2] =~ /reagent|alchemy/
        type = 'alchemy'
      elsif options[2] =~ /gem/
        type = 'gem'
      end

      Hoard.set_type_vars(type)

      number = (options[3..-1].find { |var| var =~ /^[Xx][0-9]+$/ }.sub(/[Xx]/, '') || 1).to_i
      options.delete_if { |line| line =~ /^[Xx]([0-9]+)$/ }

      search_string = options[3..-1].join(' ')
      item = Hoard.normalize_name(search_string).downcase
      ELoot.msg(type: "debug", text: "raid_cache | search_string: #{search_string} | item: #{item}")

      unless ELoot.data.inventory.find { |thing| thing[:item] =~ /^#{item}$/i }
        ELoot.msg(text: " Not able to find #{item} in your cache.")
        ELoot.msg(text: " Run ;eloot reset #{type} to re-baseline it if needed.")
        return
      end

      start_room = Room.current.id
      Hoard.hoard_prep

      Hoard.shake(number, item)

      Hoard.leave_locker

      ELoot.go2(start_room)
      Inventory.return_hands
    end
  end
end

module ELoot # Room looting
  module Loot
    def self.bag_loot(bag) # loots bags dropped from critters that have treasure in them
      return if ELoot.data.checked_bags.include?(bag.id)

      lines = ELoot.get_command("open ##{bag.id}", /crumbles? and decays? away|<exposeContainer|That is already open|<container|There doesn't seem to be any way to do that|I could not find what you were referring to/, silent: true, quiet: true)

      if lines.any? { |l| l =~ /crumbles? and decays? away/i }
        unless bag.name =~ /bandana|flowing robes/
          ELoot.msg(type: "info", text: " #{bag} was crumbly, adding to list")
          ELoot.data.settings[:crumbly].push(bag.name)
          ELoot.save_profile()
        end
        return "crumbly"
      end

      if lines.any? { |line| line =~ /There doesn't seem to be any way to do that|I could not find what you were referring to/i }
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      lines = ELoot.get_command("look in ##{bag.id}", /<container|That is closed/, silent: true, quiet: true)

      # False positive?
      if lines.any? { |line| line =~ /I could not find what you were referring to/i }
        return false
      end

      objs = Loot.reject_invalid_loot(bag.contents)

      if objs.empty?
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      objs = Loot.loot_specials(objs)

      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      if objs.empty?
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      Loot.loot_regular(objs)

      ELoot.data.checked_bags.push(bag.id)
    end

    def self.box_loot(box, location = nil, data = nil) # Loots box contents
      if box.type == "box"
        line = ELoot.get_res("open ##{box.id}", /open|locked/)
        return Inventory.single_drag(box) if line =~ /locked/

        quiet_msg = ELoot.data.settings[:display_box_contents] ? false : true
        ELoot.get_command("look in ##{box.id}", ELoot.data.look_regex, silent: quiet_msg, quiet: quiet_msg)

        # Makes sure the item's contents are available
        Inventory.container_contents(box)

        start_silvers = ELoot.silver_check
        while box.contents.any? { |obj| obj.name =~ /silver coins/ }
          unless ELoot.data.charm.nil?
            res = ELoot.get_res("point ##{ELoot.data.charm.id} at ##{box.id}", /You summon/)
            data[location] += ELoot.silver_check - start_silvers
          else
            res = ELoot.get_res("get coins from ##{box.id}", /You gather the remaining|Get what|You can only collect/)
            if res =~ /You gather the remaining/
              data[location] += ELoot.silver_check - start_silvers
              ELoot.wait_rt
              break
            elsif res =~ /You can only collect/
              data[location] += ELoot.silver_check - start_silvers
              ELoot.wait_rt
              room = Room.current.id
              ELoot.silver_deposit
              start_silvers = ELoot.silver_check
              ELoot.go2(room)
            else
              ELoot.msg(type: "info", text: " Unknown get coin result...Exiting!")
              exit
            end
          end
        end

        objs = box.contents
        if objs.empty?
          Sell.save_trash_box(box)
          return
        end

        objs = Loot.loot_specials(objs)

        # Anything left after boxes, collectibles, and uncommon weapon/armor?
        if objs.empty?
          Sell.save_trash_box(box)
          return
        end

        Loot.loot_regular(objs, "Box", box)
        Sell.save_trash_box(box)
      elsif box.type == "plinite"
        ELoot.get_res("pluck ##{box.id}", /You carefully pluck/)
        Inventory.free_hands(both: true)
      end
    end

    def self.loot_all(items) # loots entire room
      waitrt?

      Inventory.free_hand

      res = ELoot.get_command('loot room', /<dialogData|There is no loot|You need a free hand to do that|With a discerning eye|You note some treasure of interest|You can't.*?It's closed!/)

      if res.any? { |l| l =~ /There is no loot/ }
        items.each { |item| ELoot.unlootable(item) }
        return true
      end

      if res.any? { |l| l =~ /You can't.*?It's closed!/ }
        items_opened = Array.new
        items.each { |item|
          if ELoot.data.sacks[item.type] && !ELoot.data.sacks_full.include?(ELoot.data.sacks[item.type])
            bag = ELoot.data.sacks[item.type]
          else
            bag = ELoot.data.sacks["default"]
          end

          next if items_opened.include?(bag.name)

          items_opened.push(bag.name)

          if GameObj.containers.keys.include?(bag.id) && bag.contents.is_a?(Array)
            # check if open
            lines = ELoot.get_command("look in ##{bag.id}", ELoot.data.look_regex, silent: true, quiet: true)

            if lines.any? { |l| l =~ /That is closed./ }
              # This must be our lousy autocloser
              ELoot.data.settings[:auto_close].push(bag.name)
              ELoot.msg(type: "info", text: " #{bag.name} must be an autocloser, adding to list.")
              ELoot.save_profile()
            end
          end
        }

      end

      # Didn't get it all?...something in-hand?
      if res.any? { |l| l =~ /(?:gather|pick) up and stow (?:what|as much) treasure .+ manage|but quickly realize|before realizing you have no room/ }
        [GameObj.right_hand, GameObj.left_hand].each do |hand|
          Inventory.single_drag(hand) if items.any? { |thing| thing.id == hand.id }
        end

        # Anything left?
        objs = Loot.reject_invalid_loot(GameObj.loot.to_a)
        return if objs.empty?

        # Still here so rerun Loot.room
        Loot.room

      end
    end

    def self.loot_regular(objs, from_where = nil, box = nil)
      valid = Loot.valid_objs(objs.clone)
      invalid = Loot.invalid_objs(objs.clone)

      ELoot.msg(type: "debug", text: " Loot.room - valid: #{valid}")
      ELoot.msg(type: "debug", text: " Loot.room - invalid: #{invalid}")

      if !invalid.empty? && !valid.empty?
        Inventory.free_hand
        if from_where == "Room"
          loot_cmd_items = /clothing|jewelry|gem|herb|skin|wand|scroll|potion|reagent|trinket|lockpick|treasure|forageable|magic|collectible|lockandkey/
          valid.each do |obj|
            obj.type =~ loot_cmd_items ? Inventory.single_loot(obj) : Inventory.single_drag(obj)
          end
        else
          valid.each do |thing|
            Inventory.single_drag(thing)
          end
        end
      elsif invalid.empty? && !valid.empty?
        # Make sure we have a hand free
        Inventory.free_hand
        ELoot.msg(type: "debug", text: " Loot.loot_regular: Calling Loot.loot_all")

        if from_where == "Room"
          Loot.loot_all(valid)
        elsif from_where == "Box"
          ELoot.get_command("loot ##{box.id}", /You search through|You can't.*?It's closed!|There is no loot|In an attempt/i, silent: false, quiet: false)
          ELoot.wait_rt

          # If bag fills up it can leave an item in hand
          [GameObj.right_hand, GameObj.left_hand].each do |item|
            next if item.type == 'box'
            Inventory.single_drag(item)
          end

          # if there are still box contents the default container has filled up so just do the rest as drags
          if box.contents.length.positive?
            objs = box.contents
            remaining_valid = Loot.valid_objs(objs.clone)

            remaining_valid.each do |thing|
              Inventory.single_drag(thing)
            end
          end
        else
          valid.each do |thing|
            Inventory.single_drag(thing)
          end
        end
      end

      left_behind = invalid.map(&:name)
      ELoot.msg(type: "info", text: " Left the following item#{left_behind.length > 1 ? 's' : ''}: #{left_behind.join(', ')}.") unless left_behind.empty?

      ELoot.msg(type: "debug", text: " Loot.loot_regular: End of method")
    end

    def self.loot_specials(objs)
      # Open sacks for looting the room
      Inventory.open_loot_containers(objs)

      types = ["box", "clothing", "collectible", "cursed", "jewelry", "food", "breakable", "lm trap"]
      types_regex = Regexp.union(types)

      loot_types_regex = Regexp.union(ELoot.data.settings[:loot_types])
      loot_keep_regex = Regexp.union(ELoot.data.settings[:loot_keep].to_a)

      # Uncommon items in HW that loot room doesn't work on
      uncommon_loot = ["stygian valravn quill", "nacreous disir feather", "silver-veined black draconic idol"]
      loot_uncommon_regex = Regexp.union(uncommon_loot)

      objs = objs.reject do |thing|
        result = Loot.bag_loot(thing) if thing.type =~ /clothing/

        next true if result == "crumbly"
        next false if ELoot.data.exclude && thing.name.match(Regexp.union(ELoot.data.exclude))
        next false if (thing.name.eql?("shard of oblivion quartz") and Stats.level.eql?(100) && ELoot.data.settings[:loot_types].include?("gem"))
        next false if (thing.name =~ /doomstone|urglaes fang/ && !ELoot.data.settings[:loot_types].include?("cursed"))

        next false unless (
          (thing.type =~ loot_types_regex && thing.type =~ types_regex) ||
          (thing.type =~ /lockandkey/i) ||
          (ELoot.data.settings[:loot_keep].length.positive? && thing.name =~ loot_keep_regex) ||
          (thing.type =~ /cursed/i && ELoot.data.settings[:loot_types].include?("cursed")) ||
          (thing.type =~ /weapon/i && thing.type =~ /uncommon/ && ELoot.data.settings[:loot_types].include?("weapon")) ||
          (thing.type =~ /armor/i && thing.type =~ /uncommon/ && ELoot.data.settings[:loot_types].include?("armor")) ||
          (thing.name =~ /orb/ && thing.type =~ /magic/ && ELoot.data.settings[:loot_types].include?("magic")) ||
          (thing.name =~ loot_uncommon_regex && ELoot.data.settings[:loot_types].include?("uncommon")) ||
          (thing.name =~ /silver coin/ && ELoot.data.settings[:loot_types].include?("coins"))
        )

        if thing.name =~ /silver coin/
          coin_cmd = !ELoot.data.charm.nil? ? "rub ##{ELoot.data.charm.id}" : "get coins"
          ELoot.get_res(coin_cmd, /you (gather|summon)/i)
        else
          if ELoot.decurse(thing)
            Inventory.free_hand
            Inventory.single_drag(thing)
          end
        end

        next true
      end

      ELoot.msg(type: "debug", text: " Loot.loot_specials: After specials check objs: #{objs}")

      return objs
    end

    def self.occassional_skinner(obj)
      if obj.name =~ /rotting chimera/
        lines = ELoot.get_command("describe chimera", /The twisted and confused form/, silent: true, quiet: true)
        if lines.any? { |line| line =~ /A huge scorpion tail rises high from the rear/ }
          return true
        end
      end

      return false
    end

    def self.reject_invalid_loot(objs) # rejects items from the GamObj.loot object
      name_regex = Regexp.union(ELoot.data.reject_loot_names)
      noun_regex = Regexp.union(ELoot.data.reject_loot_nouns)

      objs.reject do |obj|
        next if ELoot.data.settings[:loot_keep].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:loot_keep])

        obj.name =~ /\b#{name_regex}\b/i ||
          obj.name =~ /[A-Z][a-z]+ #{ELoot.data.disk_nouns_regex}\b/ ||
          obj.noun =~ /\b#{noun_regex}\b/i ||
          obj.id.to_i.negative? ||
          (obj.type =~ /weapon|armor/i && obj.type !~ /uncommon|clothing/i) ||
          (ELoot.data.settings[:unlootable].include?(obj.name) && ELoot.data.settings[:log_unlootables]) ||
          ELoot.data.settings[:crumbly].index(obj.name) > -1
      end
    end

    def self.should_grab_item?(thing)
      # If its on the exclude list return
      return false if ELoot.data.exclude && thing.name.match(Regexp.union(ELoot.data.exclude))

      # oblivion quartz isn't cursed if you are level 100
      return true  if thing.name.eql?("shard of oblivion quartz") and Stats.level.eql?(100) && ELoot.data.settings[:loot_types].include?("gem")

      # Cursed items need to be handled separate due to gems
      return false if thing.type =~ /cursed/i && !ELoot.data.settings[:loot_types].include?("cursed")

      # Keep it if it's a type we want
      return true if thing.type =~ Regexp.union(ELoot.data.settings[:loot_types])

      # If the type is something we don't want return false
      not_wanted = ELoot.data.all_loot_categories - ELoot.data.settings[:loot_types]
      return false if thing.type =~ Regexp.union(not_wanted)

      # Anything left lets take
      return true
    end

    def self.valid_objs(objs) # finds valid loot
      objs.select { |o| self.should_grab_item?(o) }
    end

    def self.invalid_objs(objs) # finds non-valid loot
      objs.reject { |o| self.should_grab_item?(o) }
    end

    def self.room # method that loots the room
      objs = Loot.reject_invalid_loot(GameObj.loot.to_a)

      unless objs.empty?
        objs = loot_specials(objs)
      end

      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      unless objs.empty?
        Loot.loot_regular(objs, "Room")
      end
    end

    def self.search(objs = GameObj.dead.to_a) # searches dead critters
      return if objs.empty?

      regex_at_feet = /^<pushBold\/> \*\* A glint of light catches your eye, and you notice an? <a exist="(?<id>[\d-]+)" noun="(?<noun>[\w-]+)">(?<name>[\w\s-]+)<\/a>.*? at your feet! \*\*$/
      inhand_critters = /skayl|glacei|tumbleweed|plant|shrub|creeper|vine|bush|caedera|golem|elemental/

      objs.each do |thing|
        next if (ELoot.data.settings[:critter_exclude].length.positive? && thing.name =~ Regexp.union(ELoot.data.settings[:critter_exclude]))
        next if thing.status =~ /gone/

        ELoot.change_stance(100) if ELoot.data.settings[:loot_defensive]

        if thing.name =~ inhand_critters
          (thing.name =~ /tumbleweed|plant|shrub|creeper|vine|bush/) ? Inventory.free_hands(left: true) : Inventory.free_hand
          if GameObj.right_hand.id.nil? && GameObj.left_hand.id.nil?
            free_hand = "left"
          else
            free_hand = GameObj.right_hand.id.nil? ? "right" : "left"
          end
        end

        # Loot it
        3.times do
          waitrt?
          results = ELoot.get_command("loot ##{thing.id}", /You (search|plunge|break)|not in any condition|see well enough to search|You can only loot creatures|Geez!  It's still alive!  Not a good time for that\./, silent: false, quiet: false)
          ELoot.msg(type: "debug", text: "Thing: #{thing.id}-#{thing.name}, Results: #{results.first}")

          if results.any? { |line| line =~ /not in any condition/ } &&
             ELoot.data.settings[:sigil_determination_on_fail] &&
             Spell['Sigil of Determination'].affordable? &&
             !Spell['Sigil of Determination'].active?
            Spell['Sigil of Determination'].cast
            next
          end

          if results.any? { |line| line =~ regex_at_feet }
            results.each do |line|
              if line =~ regex_at_feet
                match = Regexp.last_match
                Inventory.free_hand
                Inventory.single_drag(GameObj.new(match[:id], match[:noun], match[:name]))
              end
            end
          end

          break if results.any? { |line| line =~ /You (search|plunge|break)|not in any condition|see well enough to search|You can only loot creatures|Geez!  It's still alive!  Not a good time for that\./ } ||
                   thing.nil? || thing.status =~ /gone/
        end

        # Some creatures put an item directly in your hand
        if thing.name =~ inhand_critters
          check_hand = (free_hand == "right") ? GameObj.right_hand : GameObj.left_hand
          Inventory.single_drag(check_hand) unless check_hand.name == "Empty"
        end
      end

      # if the setting is on always end in defensive
      ELoot.change_stance(100) if ELoot.data.settings[:loot_defensive]
    end

    def self.skin_obj_types(objs, type) # skins type (blunt/dagger) group of dead critters
      return if objs.empty?

      dont_stow = false
      waitrt?

      if type == :blunt
        skinner = ELoot.data.skin_blunt
        ELoot.msg(type: "debug", text: " blunt skinner: #{skinner} blunt skinner.id: #{skinner.id}")
        unless skinner
          ELoot.msg(type: "info", text: " No blunt weapon found. Please run setup and make sure its listed.")
          return
        end
        Inventory.free_hands(both: true)
      else
        if ELoot.data.skin_edged.to_s.empty? || ELoot.data.skin_edged.nil?
          skinner = GameObj.right_hand
          ELoot.msg(type: "info", text: " No edged skinning weapon found. Using your right hand.")
        else
          skinner = ELoot.data.skin_edged
        end

        ELoot.msg(type: "debug", text: " edged skinner: #{skinner} edged skinner.id: #{skinner.id}")

        dont_stow = true if [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)

        unless dont_stow
          Inventory.free_hand
        end
      end

      unless [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
        waitrt?
        Inventory.drag(skinner)
      end

      skinner_hand = skinner.id == GameObj.left_hand.id ? 'left' : 'right'

      # Safe to kneel?
      while GameObj.targets.empty? && ELoot.data.settings[:skin_kneel] && !kneeling?
        dothistimeout('kneel', 3, /You kneel down\.$|You move to|You are already kneeling\.$/)
      end

      # Sigil of Resolve?
      if ELoot.data.settings[:skin_resolve] &&
         Spell['Sigil of Resolve'].affordable? &&
         !Spell['Sigil of Resolve'].active?
        Spell['Sigil of Resolve'].cast
      end

      # 604 stuff
      if ELoot.data.settings[:skin_604] && Spell[604].affordable? && (!Spell[604].active? || (Spell[604].timeleft * 60).truncate() <= 10)
        until Spell[604].active? && (Spell[604].timeleft * 60).truncate() > 5
          Spell[604].cast
          sleep(0.1)
        end
      end

      skin_match = Regexp.union(
        /You skinned/i,
        /You botched/i,
        /already been/i,
        /cannot skin/i,
        /must be a member/i,
        /can only skin/i,
        /You are unable to break through/i,
        /You break through the crust of the/i,
        /You crack open a portion/i,
        /Because your account is free/i,
        /it's not possible to get a worthwhile/i,
      )

      break_match = Regexp.union(
        /You break through the crust of the .+ and withdraw (.+)!/i,
        /You crack open a portion of the .+ and uncover (.+)!/i,
      )

      # Skin em
      objs.each do |obj|
        res = dothistimeout("skin ##{obj.id} #{skinner_hand}", 2, skin_match)
        if res =~ /You cannot skin/
          ELoot.data.settings[:unskinnable].push(obj.name)
          ELoot.save_profile()
        elsif res =~ break_match
          fput "stow gem ##{GameObj.left_hand.id}"
        end
      end

      waitrt?

      return if dont_stow

      if type == :blunt
        bag = ELoot.data.ready_list["skin_sheath_blunt"].nil? ? ELoot.data.sacks["default"] : ELoot.data.ready_list["skin_sheath_blunt"]
      else
        bag = ELoot.data.ready_list["skin_sheath"].nil? ? ELoot.data.sacks["default"] : ELoot.data.ready_list["skin_sheath"]
      end

      Inventory.store_item(bag, skinner, true)

      if [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
        Inventory.store_item(ELoot.data.sacks["default"], skinner)
      end
    end

    def self.skin(objs = GameObj.dead.to_a) # determines what to skin
      objs = objs.reject do |obj|
        (ELoot.data.settings[:unskinnable].include?(obj.name) && !Loot.occassional_skinner(obj)) ||
          obj.type =~ /bandit/ ||
          obj.name =~ /(?:ethereal|ghostly|unwordly|Grimswarm)/ ||
          ELoot.data.settings[:skin_exclude].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:skin_exclude]) ||
          ELoot.data.settings[:critter_exclude].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:critter_exclude])
      end

      return if objs.empty?

      blunts = objs.find_all { |obj| obj.name =~ /krynch|stone mastiff|krag dweller|cavern urchin/i }
      normals = objs.reject { |obj| obj.name =~ /krynch|stone mastiff|krag dweller|cavern urchin/i }

      skin_obj_types(normals, :normal)
      skin_obj_types(blunts, :blunt)

      new_stance = Char.percent_stance
      unless standing?
        ELoot.change_stance(0) if GameObj.targets.empty?
        dothistimeout('stand', 3, /You stand|You quickly roll|You are already standing/) until standing?
        ELoot.change_stance(new_stance) if Char.percent_stance != new_stance
      end
    end
  end
end

module ELoot # Sells the loot
  module Sell
    def self.appraise(item, location, _data = nil)
      return if item.type =~ /jewelry/ && location == "pawnshop"

      amount = 0
      raw = nil

      limit = location =~ /gemshop/i ? ELoot.data.settings[:sell_appraise_gemshop] : ELoot.data.settings[:sell_appraise_pawnshop]

      lines = ELoot.get_command("appraise ##{item.id}", /^You ask .*to appraise/)

      if lines.any? { |l| l =~ /([,0-9]+) (?:silver|for it if you want to sell|for this if you'd like)/ }
        raw = $1
        amount = $1.delete(",").to_i
      end

      if amount > limit.to_i || lines.any? { |l| l =~ /not buying anything this valuable today/ }
        message = amount > limit.to_i ? " The #{item} appraises for #{raw}. That's above your settings." : " The #{item} appraises as too valuable to sell."
        ELoot.msg(type: "info", text: message)
        if ELoot.data.sacks[ELoot.data.settings[:appraisal_container]].to_s.empty?
          Inventory.single_drag(item)
        else
          Inventory.store_item(ELoot.data.sacks[ELoot.data.settings[:appraisal_container]], item)
        end
      elsif amount.positive? && amount <= limit.to_i
        Sell.sell_item(item, location, ELoot.data.silver_breakdown)
      else
        Inventory.single_drag(item)
      end
    end

    def self.box_in_hand(deposit = true)
      return unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")

      if [GameObj.left_hand.noun, GameObj.right_hand.noun].include?("reliquary")
        ELoot.msg(text: " Looks like you have a reliquary", space: true)
        exit
      end

      loop do
        item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" }
        break unless item && ELoot.data.settings[:sell_locksmith_pool]

        Sell.locksmith_pool([item], deposit)

        # check if still the same item. If it is then pool is full
        break if item.id == [GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" }.id
      end

      if (item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" }) && ELoot.data.settings[:sell_locksmith]
        Sell.locksmith([item])
      end

      if ([GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" })
        ELoot.msg(text: " Not able to process the box in your hand. Exiting...", space: true)
        exit
      end
    end

    def self.breakdown
      return if ELoot.data.silver_breakdown.empty? && (ELoot.data.hoard_deposit.empty? || ELoot.data.hoard_deposit.nil?)
      return unless defined?(Terminal)
      rows = []

      unless ELoot.data.silver_breakdown.empty?
        total_silver = 0

        ELoot.data.silver_breakdown.each_with_index do |(location, amount), index|
          unless location =~ /(Pool|Town) (Dropoff|Depth|Open)/
            total_silver += amount
          end
          rows << [location, "   " + ELoot.format_number(amount)]

          # Only add a separator if the location matches the pattern and is not the last one
          if location =~ /Pool Depth|Town Open/ && index < ELoot.data.silver_breakdown.size - 1
            rows << :separator
          end
        end

        rows << :separator
        rows << ["Total", ELoot.format_number(total_silver)]
      end

      if ELoot.data.hoard_deposit.length.to_i.positive?
        all_gems = ELoot.data.hoard_deposit.find_all { |item| item[:type] == 'gem' }

        unless all_gems.length.to_i.zero?
          unique_gems = all_gems.uniq { |item| item[:item] }
          rows << :separator
          rows << [{ value: 'Gems Hoarded', colspan: 2, alignment: :center }]
          rows << :separator

          unique_gems.each { |obj|
            count = ELoot.data.hoard_deposit.find_all { |item| item[:item] == obj[:item] }.length.to_i
            rows << [ELoot.capitalize_words(obj[:item]), "   " + count.to_s]
          }
        end

        all_reagents = ELoot.data.hoard_deposit.find_all { |item| item[:type] == 'reagent' }

        unless all_reagents.length.to_i.zero?
          unique_reagents = all_reagents.uniq { |item| item[:item] }
          rows << :separator
          rows << [{ value: 'Reagents Hoarded', colspan: 2, alignment: :center }]
          rows << :separator
          unique_reagents.uniq!.each { |obj|
            count = ELoot.data.hoard_deposit.find_all { |item| item[:item] == obj[:item] }.length.to_i
            rows << [ELoot.capitalize_words(obj[:item]), "   " + count.to_s]
          }
        end
      end

      table = Terminal::Table.new :title => "Eloot Breakdown", :rows => rows # , :style => {:all_separators => true}
      table.align_column(1, :right)

      ELoot.wait_rt
      respond
      respond table
      respond
      ELoot.wait_rt
      return
    end

    def self.break_rocks
      rock_sacks = Array.new
      rock_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        rock_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        rock_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      rock_sacks.each do |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.type =~ /breakable/ }.empty?
        sack.contents.each do |item|
          next unless item.type =~ /breakable/

          Inventory.drag(item)
          ELoot.get_res("break ##{item.id}", /You squeeze the chunk of rock/)

          Inventory.free_hands(both: true)
        end
      end
    end

    def self.check_bounty_furrier
      return unless ELoot.data.settings[:sell_loot_types].include?("skin")
      # return unless Bounty.task.skin? && !Bounty.task.assigned? # update to this post 5.11.2+ release
      return unless Bounty.task.skin? && !Bounty.task.type.to_s.end_with?("assignment")
      need_furrier = false

      skin = Bounty.task.skin
      bundled_skins = skin.match(/(\w+)\s+(\w+)\s*\Z/)

      # need to check all the sacks that might have skins in them
      skin_sacks = []
      skin_sacks.push(ELoot.data.sacks["skin"]) if ELoot.data.settings[:sell_container].include?("skin")
      skin_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      skin_sacks.each do |sack|
        next if sack&.contents&.none? { |obj| obj.name =~ /#{skin}|#{bundled_skins}/i }
        need_furrier = true
        break
      end

      # if we don't have the bounty skins return early
      return unless need_furrier

      # if we are sitting in FWI bring us back
      ELoot.fwi_return

      # Are we in the correct town? If not is it close?
      return unless (location = Region.furrier)
      ELoot.go2(location)

      start_silvers = ELoot.silver_check
      bulk_note = 0

      ELoot.msg(type: "debug", text: "  check_bounty | skin_sacks: #{skin_sacks}")
      skin_sacks.each do |sack|
        next if sack.nil?
        next if sack.contents.none? { |obj| obj.name =~ /#{skin}|#{bundled_skins}/i }

        bulk_sell = true
        bulk_sell = false if sack.contents.any? { |obj| obj.name =~ /bundle of/ }
        unless ELoot.data.settings[:sell_exclude].empty?
          if sack.contents.any? { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /furrier/ }
            bulk_sell = false
          end
        end

        bulk_sell = false if sack.contents.any? { |obj| obj.name !~ /#{skin}/ && obj.sellable =~ /furrier/ }

        if bulk_sell
          ELoot.msg(type: "debug", text: " check_bounty | bulk_sell: #{bulk_sell} using sack: #{sack}")
          Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

          dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
          Inventory.wear(sack)

          if (bulk_note = ELoot.read_note.to_i).positive?
            ELoot.data.silver_breakdown["Furrier"] += bulk_note

            # Deposit local note if selling in FWI
            ELoot.deposit_note if ELoot.data.settings[:sell_fwi]
          end

          sleep 0.5
        else
          sack.contents.each do |item|
            next if $sell_ignore.include?(item.id)
            next unless item.sellable =~ /furrier/
            next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
            next unless item.name =~ /#{skin}|#{bundled_skins}/i

            $sell_ignore.push(item.id)
            Inventory.drag(item)

            if item.name =~ /bundle/
              # grab the bundle ID
              bundle_id = GameObj.right_hand.id || GameObj.left_hand.id

              until ![GameObj.right_hand.id, GameObj.left_hand.id].include?(bundle_id)
                # remove a skin
                result = dothistimeout "bundle remove", 5, /You remove|Those were the last two/

                if result =~ /Those were the last two/
                  Sell.sell_item(GameObj.right_hand, "Furrier", ELoot.data.silver_breakdown)
                  Sell.sell_item(GameObj.left_hand, "Furrier", ELoot.data.silver_breakdown)
                else
                  # get the skin id
                  skin = GameObj.right_hand.id != bundle_id ? GameObj.right_hand : GameObj.left_hand
                  Sell.sell_item(skin, "Furrier", ELoot.data.silver_breakdown)
                end
              end
            else
              Sell.sell_item(item, "Furrier", ELoot.data.silver_breakdown)
            end
          end
        end

        Inventory.free_hands(both: true)
        ELoot.msg(type: "debug", text: "  check_bounty_furrier | bottom of each using sack: #{sack}")
      end

      ELoot.data.silver_breakdown["Furrier"] += (ELoot.silver_check - start_silvers)
    end

    def self.check_bounty_gems
      return unless ELoot.data.settings[:sell_loot_types].include?("gem")
      # return unless Bounty.task.gem? && !Bounty.task.assigned? # update to this post 5.11.2+ release
      return unless Bounty.task.gem? && !Bounty.task.type.to_s.end_with?("assignment")
      need_gemshop = false

      gem = Bounty.requirements[:gem]

      gem_sacks = []
      gem_sacks.push(ELoot.data.sacks["gem"]) if ELoot.data.settings[:sell_container].include?("gem")
      gem_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      gem_sacks.each do |sack|
        next if sack&.contents&.none? { |obj| obj.name =~ /#{gem}/ }
        need_gemshop = true
        break
      end

      # if we don't need the gemshop return early
      return unless need_gemshop

      # if we are sitting in FWI bring us back
      ELoot.fwi_return

      # Are we in the correct town? If not is it close?
      return unless (location = Region.gemshop)
      ELoot.go2(location)

      start_silvers = ELoot.silver_check
      bulk_note = 0

      Inventory.free_hands(both: true)

      gem_sacks.each do |sack|
        next if sack.nil?
        next if sack.contents.none? { |obj| obj.name =~ /#{gem}/i }

        bulk_sell = true
        bulk_sell = false if sack.contents.any? { |obj| obj.name !~ /#{gem}/ && obj.type =~ /gem/ }
        unless ELoot.data.settings[:sell_exclude].empty?
          if sack.contents.any? { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /gemshop/ }
            bulk_sell = false
          end
        end
        # Bulk sell sack if it has gems and no exclusions
        if bulk_sell
          Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?
          dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
          Inventory.wear(sack)
          sleep 0.5
          if (bulk_note = ELoot.read_note.to_i).positive?
            ELoot.data.silver_breakdown["Gemshop"] += bulk_note

            # Deposit local note if selling in FWI
            ELoot.deposit_note if ELoot.data.settings[:sell_fwi]
          end

          Inventory.free_hands(both: true)
        else
          sack.contents.each do |item|
            next unless item.name =~ /#{gem}/

            Inventory.drag(item)
            Sell.sell_item(item, "Gemshop", ELoot.data.silver_breakdown)
            Inventory.free_hands(both: true)
          end
        end
      end

      ELoot.data.silver_breakdown["Gemshop"] += (ELoot.silver_check - start_silvers)
    end

    def self.check_bounty
      Sell.check_bounty_furrier
      Sell.check_bounty_gems
    end

    def self.check_items(specific: nil, items: nil)
      selling = []
      ELoot.data.gemshop_first = false

      all_contents = items.nil? ? Sell.check_inventory : items

      all_contents.each { |thing|
        next if $sell_ignore.include?(thing.id)
        next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
        next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
        next if thing.name =~ /\bbound\b|^shimmering \w+ orb$/
        next if selling.include?(thing.type) && !thing.type.nil?
        if !specific.nil?
          next unless specific.include?(thing.type)
        end

        if thing.type =~ /clothing/ && thing.sellable.include?("pawnshop") && thing.sellable.include?("gemshop")
          ELoot.data.gemshop_first = true
        end

        if ELoot.data.alchemy_mode
          next if thing.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          next if thing.noun =~ /^(?:jar|beaker|bottle)$/ and thing.after_name.nil?
        end

        if thing.name =~ ELoot.data.regex_gold_rings && ELoot.data.settings[:sell_gold_rings]
          selling.push("chronomage") unless selling.include?("chronomage")
        elsif thing.type =~ /scarab/ && ELoot.data.settings[:sell_loot_types].include?("scarab")
          selling.push("gemshop") unless selling.include?("gemshop")
        elsif thing.type == "gem" && ELoot.data.settings[:sell_loot_types].include?("gem") && thing.noun =~ /thorn|berry/
          selling.push("gemshop") unless selling.include?("gemshop")
        elsif thing.type == "collectible" && ELoot.data.settings[:sell_collectibles]
          selling.push("collectibles") unless selling.include?("collectibles")
        elsif ELoot.data.settings[:sell_loot_types].include?("box") && thing.type == "box"
          selling.push("pawnshop") unless selling.include?("pawnshop")
        elsif !thing.sellable.nil? && thing.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          thing.sellable.to_s.split(',').each { |location|
            selling.push(location) unless selling.include?(location)
          }
        end
      }

      ELoot.msg(type: "debug", text: "Places to go: #{selling}")
      return selling
    end

    def self.check_inventory
      all_contents = []

      ELoot.data.sacks.keys.each do |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        Inventory.open_single_container(item)
        all_contents += ELoot.data.sacks[item].contents.to_a
      end

      if ELoot.data.settings[:use_disk]
        ELoot.wait_for_disk
        Inventory.open_single_container(ELoot.data.disk)
        all_contents += ELoot.data.disk.contents.to_a
      end

      # Remove items from all_contents if their id is in the $sell_ignore array
      all_contents.reject! { |thing| $sell_ignore.include?(thing.id) }

      return all_contents
    end

    def self.collectibles
      return unless ELoot.data.settings[:sell_collectibles]

      places = Array.new
      places.push(Room.current.find_nearest_by_tag("collectible")) unless Room.current.find_nearest_by_tag("collectible").nil?
      places.push(Room.current.find_nearest_by_tag("collectibles")) unless Room.current.find_nearest_by_tag("collectibles").nil?

      go_place = Room.current.find_nearest(places)

      ELoot.go2(go_place)

      Inventory.free_hands(both: true)

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      ELoot.data.sacks.keys.each { |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        ELoot.data.sacks[item].contents.each { |thing|
          next if $sell_ignore.include?(thing.id)
          next unless thing.type == "collectible"
          next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
          next if (thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
          next if thing.name =~ /bound/

          $sell_ignore.push(thing.id)
          Inventory.drag(thing)
          dothistimeout("deposit ##{thing.id}", 3, /You hand your/)

          20.times {
            break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(thing.id))

            sleep 0.1
          }

          Inventory.free_hands(both: true)
        }
      }
    end

    def self.consignment
      ELoot.go2("consignment")
      start_silvers = ELoot.silver_check
      Inventory.free_hands(both: true)

      consignment_sacks = Array.new
      consignment_sacks.push(ELoot.data.sacks["reagent"]) if ELoot.data.settings[:sell_container].include?("reagent")
      consignment_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        consignment_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        consignment_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      consignment_sacks.each { |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.sellable.include?("consignment") }.empty?

        # Still here so remove the sack from the array
        ELoot.data.sacks_full.delete(sack)

        sack.contents.each { |thing|
          next if $sell_ignore.include?(thing.id)
          next unless thing.sellable.include?("consignment")
          next unless thing.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
          next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
          next if thing.name =~ /bound/

          if ELoot.data.alchemy_mode
            next if thing.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(thing.id)
          Inventory.drag(thing)
          # Sell.sell_item(thing)
          Sell.sell_item(thing, "Consignment", ELoot.data.silver_breakdown)

          Inventory.free_hands(both: true)
        }
      }

      ELoot.data.silver_breakdown["Consignment"] += (ELoot.silver_check - start_silvers)
    end

    def self.custom_list(items)
      # put items into an array and clean up any weirdness
      items_array = items.gsub('/', '').split(/,|\|/).map(&:strip)

      # convert that into a regex
      items_regex = Regexp.new(items_array.join('|'))

      # get the Inventory
      all_contents = Sell.check_inventory

      # Find the items
      items_to_sell = all_contents.select { |item| item.name.match?(items_regex) }

      # check where to go for selling them
      locations = Sell.check_items(items: items_to_sell)

      # if its empty we are done
      return if locations.empty?

      Inventory.clear_hands

      # Go to each location and sell
      locations.each do |place|
        ELoot.go2(place)
        ELoot.wait_rt

        items_to_sell.each do |item|
          Inventory.drag(item)

          if item.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?
            Sell.appraise(item, place.capitalize, ELoot.data.silver_breakdown)
          else
            Sell.sell_item(item, place.capitalize, ELoot.data.silver_breakdown)
          end

          Inventory.free_hands(both: true)
        end
      end

      ELoot.silver_deposit(true)
      Inventory.return_hands
    end

    def self.custom_sellable(sellable)
      sellable_types = []

      # Split items into an array
      sellable_array = sellable.gsub('/', '').split(/,|\|/).map(&:strip)

      # Check to make sure the type exists in GameObj
      sellable_array.each { |item|
        if GameObj.sellable_data.keys.include?(item) || item =~ /collectible|chronomage/
          sellable_types << item
        else
          ELoot.msg(type: "yellow", text: "  #{item.capitalize} is not a valid sellable category.")
          tmp_sellable = GameObj.sellable_data.keys + ['collectible', 'chronomage']
          ELoot.msg(type: 'default', text: "  GameObj sellable: #{tmp_sellable}")
          exit
        end
      }

      # return unless there is a location
      return unless sellable_types.length.positive?
      locations = Sell.check_items

      Inventory.clear_hands

      Sell.check_bounty_gems if sellable_types.include?('gemshop')
      Sell.check_bounty_furrier if sellable_types.include?('furrier')

      # check if we still need to go to the gemshop or furrier
      if ['gemshop', 'furrier'].any? { |el| sellable_types.include?(el) }
        locations = Sell.check_items
      end

      remaining_sellable = locations & sellable_types

      # return if it's empty
      return if remaining_sellable.empty?

      Sell.go_sell(remaining_sellable)

      ELoot.silver_deposit(true)
      Inventory.return_hands
    end

    def self.custom_type(types)
      sell_types = []
      recheck = false

      # Split items into an array
      types_array = types.gsub('/', '').split(/,|\|/).map(&:strip)

      # Check to make sure the type exists in GameObj
      types_array.each { |type|
        if GameObj.type_data.keys.include?(type)
          sell_types << type
        else
          ELoot.msg(type: "yellow", text: "  #{type.capitalize} is not a valid GameObj type.")
          ELoot.msg(type: 'default', text: "  GameObj types: #{GameObj.type_data.keys}")
          exit
        end
      }

      # return if there are no valid types
      return unless sell_types.length.positive?

      Inventory.clear_hands

      # process boxes first
      Sell.process_boxes if sell_types.include?('box')

      # send the types thru check_items to get our selling locations
      locations = Sell.check_items(specific: sell_types)

      # if its empty we are done
      return if locations.empty?

      # buff up for sales!
      Sell.sell_buffs

      # If type is gem or skin - sell at bounty location
      if sell_types.include?('gem') && locations.include?("gemshop")
        Sell.check_bounty_gems
        recheck = true
      end

      if sell_types.include?('skin') && locations.include?("furrier")
        Sell.check_bounty_furrier
        recheck = true
      end

      # rechecking locations to see if we still need to go to the gemshop or furrier
      if recheck
        locations = Sell.check_items(specific: sell_types)
      end

      # if its empty we are done
      return if locations.empty?

      # finally lets go sell stuff
      Sell.gold_rings if locations.include?("chronomage")
      Sell.furrier if locations.include?("furrier")
      Sell.gemshop(sell_types) if locations.include?("gemshop")
      Sell.consignment if locations.include?("consignment")
      Sell.pawnshop(sell_types) if locations.include?("pawnshop")
      Sell.collectibles if locations.include?("collectibles")

      ELoot.silver_deposit(true)
      Inventory.return_hands
    end

    def self.dump_herbs_junk
      # What stuff are we supposed to dump?
      dump_stuff = Array.new
      ["herb", "junk", "food"].each { |item|
        if ELoot.data.settings[:sell_loot_types].include?(item)
          dump_stuff.push(item)
        end
      }

      # Return if nothing
      if dump_stuff.empty?
        return
      end

      # Do we have anything to dump?
      dump_items = Array.new
      sacks = [ELoot.data.sacks["default"], ELoot.data.sacks[ELoot.data.settings[:overflow_container]], ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]]]
      sacks.each { |sack|
        sack.contents.each { |item|
          if item.type =~ Regexp.union(dump_stuff) || (ELoot.data.alchemy_mode && item.name =~ /^some ground|flask of pure water|some powdered|some mashed|handful of sea salt|spirit shard|tincture of/)
            if ELoot.data.alchemy_mode
              next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
            end
            dump_items.push(item)
          end
        }
      }

      # No items to dump so return
      if dump_items.empty?
        return
      end

      # Is there a trash can here?
      trash = ELoot.find_trash

      unless trash
        # going here because they have trash cans. Don't want to litter
        if XMLData.game == 'GSF' && Room[Room.current.find_nearest_by_tag("town")].location == 'the tunnels and caverns of Zul Logoth'
          trash_spot = 1005
        else
          trash_spot = 'locksmith pool'
        end

        ELoot.go2(trash_spot)
        trash = ELoot.find_trash
      end

      if trash.nil?
        ELoot.msg(type: "info", text: " No trashcan found! Skipping herb/junk/food disposal so as not to litter and be a pest.")
        return
      end

      dump_items.each { |item|
        Inventory.drag(item)
        fput("put ##{item.id} in ##{trash.id}")

        20.times {
          break if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
          sleep 0.1
        }

        if [GameObj.right_hand.id, GameObj.left_hand.id].include?(item.id)
          ELoot.msg(type: "info", text: " #{item.name} isn't gone so maybe its special...keeping it.")
          Inventory.single_drag(item)
        end
      }

      Inventory.free_hands(both: true)
    end

    def self.furrier
      ELoot.go2("furrier")
      start_silvers = ELoot.silver_check
      bulk_note = 0

      Inventory.free_hands(both: true)

      skin_match = /You have been tasked to retrieve (\d+) (.*) of at least \w+ quality for (?:the )?\w+ (?:in|on|near) (?:(.*) (?:under|near|between) )?(?:the Company Store in )?([^.]+)\./

      skin_sacks = Array.new
      skin_sacks.push(ELoot.data.sacks["skin"]) if ELoot.data.settings[:sell_container].include?("skin")
      skin_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      ELoot.msg(type: "debug", text: " skin_sacks: #{skin_sacks}")
      skin_sacks.each do |sack|
        ELoot.msg(type: "debug", text: " Beginning of skin_sack.each: #{sack}")
        next if sack.nil?
        next unless ELoot.data.settings[:sell_loot_types].include?("skin") || ELoot.data.settings[:sell_loot_types].include?("reagent")
        next if sack.contents.find_all { |obj| obj.sellable =~ /furrier/ }.empty?

        # Still here so remove the sack from the array
        ELoot.data.sacks_full.delete(sack)

        ELoot.msg(type: "debug", text: " Contents after next: #{sack.contents} using sack: #{sack}")
        bulk_sell = true
        bulk_sell = false if bounty? =~ skin_match && sack.contents.find_all { |obj| obj.name =~ /bundle/ }.length.positive?
        bulk_sell = false if ELoot.data.alchemy_mode
        unless ELoot.data.settings[:sell_exclude].empty?
          if sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /furrier/ }.length.positive?
            bulk_sell = false
          end
        end

        if bulk_sell
          ELoot.msg(type: "debug", text: " bulk_sell: #{bulk_sell} using sack: #{sack}")
          Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

          ELoot.silver_check

          dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
          Inventory.wear(sack)

          bulk_note = ELoot.read_note.to_i

          if bulk_note > 0
            ELoot.data.silver_breakdown["Furrier"] += bulk_note
          end

          sleep 0.5
        end

        Inventory.free_hands(both: true)

        sack.contents.each do |item|
          next if $sell_ignore.include?(item.id)
          next unless item.sellable =~ /furrier/
          next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/

          if ELoot.data.alchemy_mode
            next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(item.id)
          Inventory.drag(item)

          if item.name =~ /bundle/
            # grab the bundle ID
            bundle_id = !GameObj.right_hand.id.nil? ? GameObj.right_hand.id : GameObj.left_hand.id

            until ![GameObj.right_hand.id, GameObj.left_hand.id].include?(bundle_id)
              # remove a skin
              result = dothistimeout "bundle remove", 5, /You remove|Those were the last two/

              if result =~ /Those were the last two/
                Sell.sell_item(GameObj.right_hand, "Furrier", ELoot.data.silver_breakdown)
                Sell.sell_item(GameObj.left_hand, "Furrier", ELoot.data.silver_breakdown)
              else
                # get the skin id
                skin = GameObj.right_hand.id != bundle_id ? GameObj.right_hand : GameObj.left_hand
                # Sell.sell_item(skin)
                Sell.sell_item(skin, "Furrier", ELoot.data.silver_breakdown)
              end

            end

          else
            Sell.sell_item(item, "Furrier", ELoot.data.silver_breakdown)
          end
        end

        Inventory.free_hands(both: true)
        ELoot.msg(type: "debug", text: " bottom of each using sack: #{sack}")
      end

      ELoot.data.silver_breakdown["Furrier"] += (ELoot.silver_check - start_silvers)
    end

    def self.gemshop(type = nil)
      ELoot.go2("gemshop")
      start_silvers = ELoot.silver_check
      bulk_note = 0

      Inventory.free_hands(both: true)

      gem_sacks = Array.new
      gem_sacks.push(ELoot.data.sacks["gem"]) if ELoot.data.settings[:sell_container].include?("gem")
      gem_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      gem_sacks.each { |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.sellable.include?("gemshop") }.empty?

        # Still here so remove the sack from the array
        ELoot.data.sacks_full.delete(sack)

        # Bulk sell sack if it has gems and no exclusions
        if (ELoot.data.settings[:sell_exclude].empty? || (sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.type =~ /gem/ }).empty?) && sack.contents.find_all { |obj| obj.type =~ /gem/ }.length.positive? && ELoot.data.settings[:sell_loot_types].include?("gem") && !ELoot.data.alchemy_mode
          if type.nil? || !type.nil? && type.includes?('gem')
            Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

            dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)

            Inventory.wear(sack)
            sleep 0.5

            bulk_note = ELoot.read_note.to_i

            if bulk_note > 0
              ELoot.data.silver_breakdown["Gemshop"] += bulk_note
            end

            Inventory.free_hands(both: true)
          end
        end

        # Loop thru remaining contents and sell/appraise whatever is left
        sack.contents.each do |item|
          next if $sell_ignore.include?(item.id)
          next unless item.sellable.include?("gemshop") || item.noun =~ /thorn|berry/ || item.type =~ /scarab/
          next unless item.type.split(',').any? { |obj| obj =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
          next if ELoot.data.settings[:sell_gold_rings] && item.name =~ ELoot.data.regex_gold_rings
          next if item.name =~ /\bbound\b|^shimmering \w+ orb$/
          if !type.nil?
            next unless type.include?(item.type)
          end

          if ELoot.data.alchemy_mode
            next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(item.id) unless item.type =~ /clothing/

          if item.type =~ /cursed/
            if !ELoot.data.settings[:sell_loot_types].include?("cursed") || (!Spell[315].known? && item.name =~ /urglaes fang/)
              ELoot.msg(type: "info", text: "** #{item.name} is cursed. Can't touch that. You'll need to take a look", space: true)
              next
            elsif ELoot.data.settings[:sell_loot_types].include?("cursed")
              next unless ELoot.decurse(item)
            end
          end

          Inventory.drag(item)

          if item.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?
            Sell.appraise(item, "Gemshop", ELoot.data.silver_breakdown)
          else
            Sell.sell_item(item, "Gemshop", ELoot.data.silver_breakdown)
          end

          Inventory.free_hands(both: true)
        end
      }

      ELoot.data.silver_breakdown["Gemshop"] += (ELoot.silver_check - start_silvers)
    end

    def self.glam_and_shroud
      glam = Spell[1205]
      shroud = Spell[1212]

      if glam.known? && glam.affordable? && Effects::Spells.time_left("Glamour") < 1
        wait_until { glam.affordable? }
        glam.cast(Char.name)
      end

      if shroud.known?
        shroud_races = ['human',
                        'giantman',
                        'half-elf',
                        'sylvankind',
                        'dark elf',
                        'elf',
                        'dwarf',
                        'halfling',
                        'forest gnome',
                        'burghal gnome',
                        'half-krolvin',
                        'erithian',
                        'aelotoi']
        shroud_race_hash = { "vo"  => "human",
                             "ifw" => "dwarf",
                             "wl"  => "human",
                             "imt" => "halfling",
                             "rr"  => "human",
                             "kf"  => "human",
                             "en"  => "elf",
                             "ti"  => "dwarf",
                             "zl"  => "dwarf" }
        town = Room[Room.current.find_nearest_by_tag("town")]
        town_key = town.image.split("-")[0]
        if town.image =~ /zul/i
          town_key = "zl"
        end
        desired_race = shroud_race_hash[town_key]

        lines = ELoot.get_command("fame", /<output class="mono"\/>/, silent: true, quiet: true)

        if lines.any? { |line| line =~ /You are a level (?:\d+) ([\w\- ]+) (?:[\w\- ]+)\./ }
          current_race = $1.downcase()
          current_race_setting = shroud_races.index(current_race) + 1
        end

        return true if current_race == desired_race

        race_setting = shroud_races.index(desired_race) + 1
        if Effects::Spells.time_left("Shroud of Deception") < 2
          waitcastrt?
          wait_until { shroud.affordable? }
          shroud.cast(Char.name)
        end

        lines = ELoot.get_command("shroud profile", /You are currently using profile/, silent: true, quiet: true)

        if lines.any? { |line| line =~ /You are currently using profile <d cmd='shroud view [0-9]+'>([0-9]+)<\/d>./ }
          shroud_profile = $1
        end

        before_dying { fput("shroud set #{shroud_profile} race #{current_race_setting}") }
        fput("shroud set #{shroud_profile} race #{race_setting}")
      end
    end

    def self.go_sell(selling)
      return if selling.empty?

      Sell.sell_buffs

      rooms = Array.new
      selling.each { |shop|
        if Room[Room.current.find_nearest_by_tag("town")].uid.first == 7503205 && !ELoot.data.settings[:sell_fwi] # HW doesn't have some shops
          next if shop =~ /collect|pawnshop|consignment|chronomage/
        end

        next if shop == "chronomage" && ELoot.fwi?(Room.current) # No chronomage in FWI
        if shop == "chronomage" && !ELoot.fwi?(Room.current) && ELoot.data.settings[:sell_fwi]
          Sell.gold_rings
          next
        end

        room = Room.current.find_nearest_by_tag(shop)
        rooms.push(room) unless room.nil?
      }

      while rooms.any?
        # Find closest room
        closest_room = nil
        _where_is_previous_var, where_is_shortest_distances_var = Room.current.dijkstra

        # Prioritize gemshops if needed
        if ELoot.data.gemshop_first
          gemshop_rooms = rooms.select { |room| Room[room].tags.include?("gemshop") }
          closest_room = gemshop_rooms.uniq.sort_by { |room| where_is_shortest_distances_var[room] }.first
          ELoot.data.gemshop_first = false
        end

        # Fallback to closest room if no gemshops found
        closest_room ||= rooms.uniq.sort_by { |room| where_is_shortest_distances_var[room] }.first

        if Char.percent_encumbrance > 80
          ELoot.silver_deposit
        end

        Sell.gold_rings if Room[closest_room].tags.include?("chronomage")
        Sell.furrier if Room[closest_room].tags.include?("furrier")
        Sell.gemshop if Room[closest_room].tags.include?("gemshop")
        Sell.consignment if Room[closest_room].tags.include?("consignment")
        Sell.pawnshop if Room[closest_room].tags.include?("pawnshop")
        Sell.collectibles if Room[closest_room].tags.include?("collectibles") || Room[closest_room].tags.include?("collectible")

        rooms.delete(closest_room)
      end
    end

    def self.gold_rings
      return unless ELoot.data.settings[:sell_gold_rings]

      ELoot.go2("chronomage")

      Inventory.free_hands(both: true)

      unless (npc = GameObj.npcs.find { |n| n.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant|guard/ })
        npc = GameObj.room_desc.find { |n| n.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant|guard/ }
      end

      unless npc.nil?
        chrono_sacks = Array.new
        chrono_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
        if ELoot.data.settings[:sell_container].include?("overflow")
          chrono_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
          chrono_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
        end

        chrono_sacks.each { |sack| Inventory.open_single_container(sack) }

        chrono_sacks.each { |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ ELoot.data.regex_gold_rings }.empty?

          sack.contents.each do |item|
            next if $sell_ignore.include?(item.id)
            next unless item.name =~ ELoot.data.regex_gold_rings

            $sell_ignore.push(item.id)
            Inventory.drag(item)

            fput "give ##{item.id} to ##{npc.id}"

            20.times {
              break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))

              sleep 0.1
            }

            Inventory.free_hands(both: true)
          end
        }
      end
    end

    def self.inbetween_scripts
      return unless ELoot.data.settings[:between].length.positive?

      # go back to the start room before running scripts
      ELoot.go2(ELoot.data.start_room)

      ELoot.data.settings[:between].each do |i|
        tokens = i.split(/\s+/)
        if (tokens.size > 1)
          Script.run(tokens[0], tokens[1..-1].join(", "))
        else
          Script.run(tokens[0])
        end
      end
    end

    def self.locksmith(boxes)
      ELoot.msg(type: "debug", text: " locksmith called by #{caller[0]}")
      # if we're here, assume we emptied out the disk some
      ELoot.data.disk_full = false

      ELoot.silver_withdraw(8000)

      ELoot.go2('locksmith')
      move "east" if Room.current.uid.include?(7118381)
      ELoot.wait_for_disk

      if (table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /(?:table|counter)$/ })
        dothistimeout("look on ##{table.id}", 3, /On the/) if table.contents.nil?

        if table.contents.nil?
          error('failed to find table contents')
        else
          activator = nil
          if table.contents.any? { |obj| obj.noun == 'bell' }
            activator = 'ring bell'
          elsif table.contents.any? { |obj| obj.noun == 'keys' }
            activator = 'pull keys'
          elsif table.contents.any? { |obj| obj.noun == 'chime' } || GameObj.loot.any? { |obj| obj.noun == 'chime' }
            activator = 'ring chime'
          end

          if activator
            boxes.each { |box|
              Inventory.free_hands(both: true) unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
              Sell.locksmith_open(box, activator)
            }
          else
            ELoot.msg(type: "error", text: " Failed to find a bell, keys, or chime on the table", space: true)
          end
        end
      else
        ELoot.msg(type: "error", text: " Failed to find a table", space: true)
      end
    end

    def self.locksmith_open(box, activator)
      lines = ELoot.get_command("look in ##{box.id}", /<container|That is closed|You see the shifting form/, silent: true, quiet: true)
      return unless lines.any? { |line| line =~ /That is closed|You see the shifting form/i }

      Inventory.drag(box) unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
      box = ELoot.box_unphase(box)

      lines = ELoot.get_command("open ##{box.id}", /open|locked/, silent: true, quiet: true)

      if lines.any?(/locked/)
        res = dothistimeout(activator, 2, /Gimme ([\d,]+) silvers/)
        if res =~ /Gimme ([\d,]+) silvers/
          ELoot.data.silver_breakdown["Town Locksmith"] += -1 * $1.delete(",").to_i
          ELoot.data.silver_breakdown["Town Open"] += 1
        end

        unless res
          ELoot.msg(type: "error", text: ' Unknown locksmith response.')
          Inventory.single_drag(box, false)
          return
        end

        result = dothistimeout('pay', 2, /accepts|have enough/)
        if result =~ /have enough/
          Inventory.single_drag(box, false)
          ELoot.silver_withdraw(8000)
          ELoot.go2('locksmith')

          return Sell.locksmith_open(box, activator)
        end
      end
      Loot.box_loot(box, "Town Locksmith", ELoot.data.silver_breakdown)
    end

    def self.locksmith_pool(boxes, deposit = false)
      # are we starting with a box in hand?
      box_in_hand = [GameObj.right_hand, GameObj.left_hand].any? { |hand| hand&.type =~ /box/ }

      # make sure some type of tipping was selected
      unless ELoot.data.settings[:use_standard_tipping] || ELoot.data.settings[:use_incremental_tipping]
        ELoot.msg(type: "yellow", text: ' No tipping options selected in UI')
        exit
      end

      match = /You want a locksmith|You don't have that much|takes your|already holding as many boxes|already (unlocked|open)/
      percent = ELoot.data.settings[:sell_locksmith_pool_tip_percent] ? ' PERCENT' : ''
      pool_count = 0
      result = nil

      # if we're here, assume we will empty out the disk
      ELoot.data.disk_full = false

      if boxes.length.positive? && ELoot.data.settings[:use_standard_tipping]
        amount = ELoot.data.settings[:sell_locksmith_pool_tip_percent] ? 8000 : boxes.length * ELoot.data.settings[:sell_locksmith_pool_tip].to_i
        ELoot.silver_withdraw(amount)
      end

      ELoot.go2('locksmith pool')
      original_pool = Room.current.id
      worker = ELoot.find_worker

      # if using incremental tipping, need to find out how many boxes are in the pool
      if boxes.length.positive? && ELoot.data.settings[:use_incremental_tipping]
        pool_count = Sell.locksmith_pool_count(worker)
        if pool_count > 99
          ELoot.msg(type: "yellow", text: " No room in the locksmith pool")
          return if deposit

          ELoot.msg(type: "yellow", text: " Checking to see if any boxes available for return")
          Sell.pool_return(worker)
          pool_count = Sell.locksmith_pool_count(worker)
          return if pool_count > 99
        else
          total_tips = Sell.locksmith_determine_tip(pool_count + 1, boxes.length)
          ELoot.silver_withdraw(total_tips)
          ELoot.go2(original_pool)
          worker = ELoot.find_worker
        end
      end

      Inventory.free_hands(both: true) unless [GameObj.right_hand, GameObj.left_hand].find { |hand| hand.type =~ /box/ }
      ELoot.wait_for_disk

      boxes.each do |box|
        Inventory.drag(box) unless [GameObj.right_hand, GameObj.left_hand].find { |hand| hand.type =~ /box/ }

        unless GameObj.right_hand.id == box.id
          fput "swap"
          ELoot.wait_rt
        end

        box = ELoot.box_unphase(box)

        case
        when ELoot.data.settings[:use_standard_tipping]
          tip_amount = "#{ELoot.data.settings[:sell_locksmith_pool_tip].to_i}#{percent}"
        else
          tip_amount = Sell.locksmith_determine_tip(pool_count, 1)
        end

        redo_needed = false
        2.times do
          result = dothistimeout("give ##{worker.id} #{tip_amount}", 3, match)

          case result
          when /Your tip of (.*) silvers?/
            ELoot.data.silver_breakdown["Locksmith Pool"] += -1 * $1.delete(",").to_i
            pool_count += 1
            ELoot.data.silver_breakdown["Pool Dropoff"] += 1

            if pool_count > 99
              ELoot.msg(type: "yellow", text: " That was the last spot open in the pool")
              return true if deposit

              ELoot.msg(type: "yellow", text: " Checking to see if any boxes available for return")
              Sell.pool_return(worker)
              pool_count = Sell.locksmith_pool_count(worker)
            end
          when /You don't have that much/
            ELoot.silver_withdraw(8000)
            ELoot.go2(original_pool)
            redo_needed = true
          when /already holding as many boxes/
            ELoot.wait_rt
            Inventory.single_drag(box) unless box_in_hand
            ELoot.msg(type: "yellow", text: " That was the last spot open in the pool")
            return true if deposit

            ELoot.msg(type: "yellow", text: " Checking to see if any boxes available for return")
            Sell.pool_return(worker)
            ELoot.wait_rt
            pool_count = Sell.locksmith_pool_count(worker)
            redo_needed = true
          when /already (unlocked|open)/
            Loot.box_loot(box, "Locksmith Pool", ELoot.data.silver_breakdown)
          end
        end

        break if pool_count > 99
        redo if redo_needed
      end

      Inventory.free_hands(both: true)
    end

    def self.pool_return(worker = nil)
      if worker.nil?
        ELoot.go2('locksmith pool')
        worker = ELoot.find_worker
      end

      loop do
        match = /We don't have any boxes ready for you|We don't seem to have that box|Alright, here's your|You need to lighten your load first/
        res = dothistimeout("ask ##{worker.id} for return", 3, match)

        break if res !~ /Alright, here's your|You need to lighten your load first/

        if res =~ /You need to lighten your load first/
          ELoot.msg(type: "info", text: " Too much weight! Depositing coins and trying again")
          room = Room.current.id
          ELoot.silver_deposit
          ELoot.go2(room)
        else
          box = nil
          if GameObj.right_hand.type =~ /box|plinite/
            box = GameObj.right_hand
          elsif GameObj.left_hand.type =~ /box|plinite/
            box = GameObj.left_hand
          else
            ELoot.msg(type: "error", text: " Failed to find the box you were supposed to get; report this to Elanthia-Online")
          end

          Loot.box_loot(box, "Locksmith Pool", ELoot.data.silver_breakdown)
        end

        ELoot.data.silver_breakdown["Pool Return"] += 1
        ELoot.wait_rt
      end

      ELoot.data.silver_breakdown["Pool Depth"] = Sell.locksmith_pool_count(worker)
    end

    def self.locksmith_pool_count(worker)
      current_box_amount = 0
      list_match = /here's the list of boxes we have for you\.|You haven't given us any boxes to be worked on\.|^(\d+)\./

      results = ELoot.get_command("ask ##{worker.id} about list", list_match, silent: true, quiet: true)
      previous_buffer = reget(300)

      results.reverse.each do |line|
        if line =~ /^\s*(?<amount>\d+)\.\s+An?/
          current_box_amount = Regexp.last_match[:amount].to_i
          break
        end
      end

      start_index = previous_buffer.reverse.find_index { |value| value =~ /here's the list of boxes we have for you\.|You haven't given us any boxes to be worked on\./ }
      current_box_amount = current_box_amount - (previous_buffer.drop(previous_buffer.size - start_index - 1).select { |line| line =~ /It is ready to be RETURNED\./ }.count)
    end

    def self.locksmith_determine_tip(pool_count, boxes_length)
      tip_amount = 0
      upper_limit = [pool_count + (boxes_length), 100].min
      pool_count += 1

      (pool_count..upper_limit).each do |items|
        tip_amount += Sell.locksmith_tip(items, ELoot.data.settings[:base_tip], ELoot.data.settings[:max_tip], ELoot.data.settings[:alpha_rate])
      end

      return tip_amount.ceil
    end

    def self.locksmith_tip(box_no, base_tip, max_tip, alpha)
      factor = (box_no).to_f / 100
      adjusted_tip = base_tip.to_i + (factor**alpha.to_f) * (max_tip.to_i - base_tip.to_i)
      adjusted_tip.round # return an integer
    end

    def self.pawnshop(type = nil)
      ELoot.go2("pawnshop")
      start_silvers = ELoot.silver_check
      Inventory.free_hands(both: true)

      # Assume bags will be emptied after sell routine
      # Fixme - check which bags are used
      ELoot.data.sacks_full = Array.new

      all_contents = Array.new
      ELoot.data.sacks.keys.each { |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        all_contents += ELoot.data.sacks[item].contents.to_a
      }

      if ELoot.data.settings[:use_disk]
        ELoot.wait_for_disk
        Inventory.open_single_container(ELoot.data.disk)
        all_contents += ELoot.data.disk.contents.to_a
      end

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      all_contents.each { |thing|
        next if $sell_ignore.include?(thing.id)
        next unless (thing.sellable.include?("pawnshop") && !thing.sellable.include?("gemshop")) || thing.type == "box" || thing.type =~ /clothing/
        next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
        next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
        next unless thing.type.split(',').any? { |obj| obj =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
        next if thing.name =~ /bound/
        next if thing.name =~ /\bbound\b|^shimmering \w+ orb$/
        next if ELoot.data.settings[:sell_gold_rings] && thing.name =~ ELoot.data.regex_gold_rings
        if !type.nil?
          next unless type.include?(item.type)
        end

        $sell_ignore.push(thing.id)
        if thing.type =~ /scroll/ && ELoot.data.settings[:sell_keep_scrolls].length.positive?
          no_vib = ELoot.data.settings[:sell_keep_scrolls].reject { |item| item.to_s =~ /v/i }
          no_vib_regex = /\((?:#{no_vib.join("|")})\)(?!.*vibrant)/i

          vib_scrolls = ELoot.data.settings[:sell_keep_scrolls].select { |item| item.to_s =~ /v/i }.map { |item| item.to_s[/\d+/] }
          vib_scrolls_regex = /\((?:#{vib_scrolls.join("|")})\).*vibrant/i

          lines = ELoot.get_command("read ##{thing.id}", /It takes you a moment|There is nothing there to read|You can't do that/, silent: true, quiet: true)

          next if lines.any? { |line| line =~ no_vib_regex }
          next if lines.any? { |line| line =~ vib_scrolls_regex }
        end

        if thing.type =~ /cursed/ && !ELoot.data.settings[:sell_loot_types].include?("cursed")
          ELoot.msg(type: "info", text: "** #{thing.name} is cursed. Can't touch that. You'll need to take a look", space: true)
          next
        elsif thing.type =~ /cursed/ && ELoot.data.settings[:sell_loot_types].include?("cursed")
          next unless ELoot.decurse(thing)
        end

        Inventory.drag(thing)

        lines = ELoot.get_command("analyze ##{thing.id}", /You analyze/, silent: true, quiet: true)
        if lines.any?(/ALTER 41/)
          ELoot.msg(type: "info", text: "** This analyzes as Alter 41. Keeping it **", space: true)
          Inventory.single_drag(thing)
          next
        end

        if (thing.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?) || thing.type =~ /uncommon|weapon|armor/
          Sell.appraise(thing, "Pawnshop", ELoot.data.silver_breakdown)
        elsif thing.type =~ /box/
          line = ELoot.get_res("look in ##{thing.id}", ELoot.data.look_regex)
          if line =~ /There is nothing|In the/i

            thing.contents.each { |box_item|
              if box_item.type =~ /cursed/ && Spell[315].known? && Spell[315].affordable? && ELoot.data.settings[:sell_loot_types].include?("cursed")
                Spell[315].cast("at ##{box_item.id}")
              elsif box_item.type =~ /cursed/ && !ELoot.data.settings[:sell_loot_types].include?("cursed")
                ELoot.msg(type: "info", text: "** #{box_item.name} is cursed. Stowing box. You'll need to take a look", space: true)
                Inventory.single_drag(thing, false)
              else
                Inventory.single_drag(box_item, false)
              end
            }
            # Sell.sell_item(thing)
            Sell.sell_item(thing, "Pawnshop", ELoot.data.silver_breakdown)
          elsif line =~ /That is closed/i
            # This shouldn't happen
            ELoot.msg(type: "info", text: "** #{thing.name} is closed. Storing box...")
            Inventory.single_drag(thing, false)
          end
        else
          Sell.sell_item(thing, "Pawnshop", ELoot.data.silver_breakdown)
        end

        Inventory.free_hands(both: true)
      }

      ELoot.data.silver_breakdown["Pawnshop"] += (ELoot.silver_check - start_silvers)
    end

    def self.pool(deposit: false, check: false)
      room = Room.current.id
      ELoot.data.right_hand = GameObj.right_hand
      ELoot.data.left_hand = GameObj.left_hand

      if deposit
        # Make sure we can see all the containers
        ELoot.data.sacks.keys.each { |item|
          next unless ELoot.data.settings[:sell_container].include?(item)

          Inventory.open_single_container(item)
        }

        # Remember current silver amount
        if deposit
          current_keep_silver = ELoot.data.settings[:sell_keep_silver].to_i
          ELoot.data.settings[:sell_keep_silver] = ELoot.silver_check
        end

        Sell.box_in_hand(deposit)
        boxes = ELoot.find_boxes

        return if boxes.empty? && !check

        Inventory.free_hands(both: true)
        Sell.locksmith_pool(boxes, deposit)
      end

      if check
        Inventory.free_hands(both: true)
        Sell.pool_return
      end

      # Deposit any additional silver taken out for box processing
      if deposit
        ELoot.silver_deposit
        ELoot.data.settings[:sell_keep_silver] = current_keep_silver
      end

      ELoot.go2(room)
      Inventory.return_hands
    end

    def self.process_boxes
      boxes = ELoot.find_boxes

      cur_len = boxes.length.to_i
      ELoot.msg(type: "debug", text: "ELoot.sell: Boxes length: #{cur_len}")

      # Process boxes in the locksmithpool
      if ELoot.data.settings[:always_check_pool] || (ELoot.data.settings[:sell_locksmith_pool] && boxes.any?)
        Sell.locksmith_pool(boxes) unless !ELoot.data.settings[:sell_locksmith_pool]
        Sell.pool_return # retrieve (and loot) any boxes in the pool

        # Refresh the boxes
        boxes = ELoot.find_boxes
      end

      # Sell off any remaining boxes
      Sell.locksmith(boxes) if ELoot.data.settings[:sell_locksmith] && boxes.length.positive?
    end

    def self.save_trash_box(box)
      # Lets not toss Reliquaries
      if box.name =~ /reliquary/i
        Inventory.single_drag(box, false)
        return
      end

      return_room = Room.current.id

      ELoot.msg(type: "debug", text: " save_trash_box(box): looking for a trashcan")
      trash = ELoot.find_trash

      unless trash
        # going here because they have trash cans. Don't want to litter
        if XMLData.game == 'GSF' && Room[Room.current.find_nearest_by_tag("town")].location == 'the tunnels and caverns of Zul Logoth'
          trash_spot = 1005
        else
          trash_spot = 'locksmith pool'
        end

        ELoot.go2(trash_spot)
        trash = ELoot.find_trash
      end

      if ELoot.data.settings[:sell_loot_types].include?("box") && box.name =~ /gold|mithril|silver/ && !box.contents.find { |obj| obj.type =~ /cursed/ }
        ELoot.msg(type: "debug", text: " save_trash_box(box): inside first if")
        if !box.contents.empty?
          box.contents.each { |item|
            Inventory.drag(item)
            fput("put ##{item.id} in ##{trash.id}")
            sleep(0.5)
            if [GameObj.right_hand.id, GameObj.left_hand.id].include?(item.id)
              ELoot.msg(type: "info", text: " #{item.name} isn't gone so maybe its special...keepin it.")
              Inventory.single_drag(item)
            end
          }
        end
        Inventory.single_drag(box, false)
        return
      end

      if trash.nil?
        fput("drop ##{box.id}")
      else
        ELoot.msg(type: "debug", text: " save_trash_box(box): putting it in trash")
        # use a loop, dothistimeout and a timer - getting stuck with a ...wait after getting coins
        t = Time.now + 3
        loop {
          dothistimeout "put ##{box.id} in ##{trash.id}", 1, /As you place|If you wish to continue/
          if ![GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id) || Time.now > t
            break
          end
        }
      end

      fput("drop ##{box.id}") if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
      ELoot.go2(return_room)
    end

    def self.sell # Main sell method
      fput('unhide') if (hidden? || invisible?)

      Sell.box_in_hand

      Inventory.clear_hands

      Sell.process_boxes

      Sell.inbetween_scripts

      # Break rocks
      Sell.break_rocks if ELoot.data.settings[:sell_loot_types].include?("breakable")

      # Hoard Stuff
      if ELoot.data.settings[:gem_horde] || ELoot.data.settings[:alchemy_horde]
        Hoard.hoard_items
      end

      # Check Bounties
      Sell.check_bounty

      Sell.go_sell(Sell.check_items)

      ELoot.silver_deposit(true)

      # If herb or junk is checked for selling we dump it. Only default and overflow
      Sell.dump_herbs_junk

      Inventory.return_hands

      # Close any containers that were opened
      Inventory.close_sell_containers if ELoot.data.settings[:keep_closed]
    end

    def self.sell_buffs
      Sell.glam_and_shroud if ELoot.data.settings[:sell_shroud]

      if ELoot.data.settings[:sell_aspect] && Spell[650].known? && !Spell[9018].active? && !Spell[9019].active?
        if Spell[650].affordable? && !Spell[650].active?
          multifput("prep 650", "assume lion")
        elsif Spell[650].active? && checkmana(25)
          waitcastrt?
          fput "assume lion"
        end
      end
    end

    def self.sell_item(item, place = nil, data = nil)
      return if item.nil? || item.name == "Empty"

      lines = ELoot.get_command("sell ##{item.id}", /You (offer to sell|ask)/)

      return if lines.any?(/That's not quite my field|That's basically worthless here|Can't say I'm interested in that|This is a pawnshop, sir, not a junkshop|The company don't buy trash|as if you were a lunatic/)

      20.times {
        break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))

        sleep 0.1
      }

      bulk_note = ELoot.read_note.to_i

      if bulk_note > 0
        data[place] += bulk_note
      end
    end
  end
end

module ELoot # Starts the script
  if Script.current.vars[1] =~ /ver/i
    echo "   Eloot Version: #{ELoot.get_script_version}"
    exit
  end

  if Spell['Berserk'].active?
    ELoot.msg(type: "info", text: " Berserk is active, preventing you from looting.", space: true)
    exit
  end

  # Fixme: need better way to start so it doesn't conflict with other autostart items
  sleep 2 if Script.current.vars[1] =~ /start/

  # Initialize/Load settings
  unless ELoot.data && ELoot.data.respond_to?(:version) && ELoot.data.version == ELoot.get_script_version
    waitrt?
    ELoot.load(ELoot.load_profile())
    ELoot.set_inventory
    exit if Script.current.vars[0] =~ /load/
  end

  if !ELoot.data.settings[:track_full_sacks]
    ELoot.data.sacks_full = Array.new
    ELoot.data.disk_full = false
  end

  # Sorter shows inventory checks so we kill it and restart
  ELoot.manage_sorter

  # Default to loot
  if Script.current.vars[1].nil?
    Thread.new { loop { Script.self.kill if dead?; sleep(5); } }

    if ELoot.data.settings[:debug_file]
      ELoot.data.debug_logger = ELoot::DebugLogger.new
    end

    ELoot.disk_usage
    ELoot.loot
    ELoot::Inventory.close_sell_containers if ELoot.data.settings[:keep_closed]

    exit
  end

  if Room.current.id.nil?
    ELoot.msg(type: "yellow", text: " Please start #{Script.current.name} in a mapped room", space: true)
    exit
  else
    ELoot.data.start_room = Room.current.id
  end

  $sell_ignore ||= Array.new
  ELoot.data.silver_breakdown = Hash.new

  case Script.current.vars[0]
  when /debug/
    if Script.current.vars[0].split(/[\s,|]+/).last =~ /file/
      ELoot::Setup.update_setting(:debug_file, !ELoot.data.settings[:debug_file])
      ELoot.data.settings[:debug_file] = !ELoot.data.settings[:debug_file]
    else
      ELoot::Setup.update_setting(:debug, !ELoot.data.settings[:debug])
      ELoot.data.settings[:debug] = !ELoot.data.settings[:debug]
    end

    ELoot.save_profile(silent: true)
    exit
  when 'start'
    exit
  when 'list'
    ELoot::Setup.new(ELoot.data.settings).list if Script.current.vars[2].nil?
    ELoot::Setup.new(ELoot.data.settings).list(cat_to_list: Script.current.vars[2]) if !Script.current.vars[2].nil?
  when /^box/
    if GameObj.right_hand.type =~ /box/
      box = GameObj.right_hand
      ELoot::Inventory.free_hands(left: true)
    elsif GameObj.left_hand.type =~ /box/
      box = GameObj.left_hand
      ELoot::Inventory.free_hands(right: true)
    elsif Script.current.vars[2] =~ /\A\d+\z/ # Fixme: intended to support ground looting items/boxes (mostly when picking boxes on the ground)
      box = GameObj.loot.find { |l| l.id =~ /#{Script.current.vars[2].to_i}/ }
    end

    ELoot::Loot.box_loot(box)
    ELoot.go2(ELoot.data.start_room)
  when /^sell/
    ELoot.wait_rt
    # Assume bags will be emptied after sell routine
    ELoot.data.sacks_full = []

    if Script.current.vars[2] == "alchemy_mode"
      ELoot.data.alchemy_mode = true
    end
    ELoot.disk_usage
    ELoot.sell
    ELoot.go2(ELoot.data.start_room)
    ELoot::Sell.breakdown
    ELoot.data.alchemy_mode = false
  when /pool/
    arg = Script.current.vars[2]

    if arg.nil?
      check = true
      deposit = true
    else
      check = arg =~ /check|return|loot/i
      deposit = arg =~ /depo/i
    end

    ELoot.disk_usage
    ELoot::Sell.pool(deposit: deposit, check: check)

    ELoot::Sell.breakdown
  when /--(sellable|type|sell)\b\s*=?\s*(\/?[a-zA-Z,\s|]+\/?)/
    type = Regexp.last_match(1)
    things = Regexp.last_match(2)

    ELoot::Sell.custom_sellable(things) if type == 'sellable'
    ELoot::Sell.custom_type(things) if type == 'type'
    ELoot::Sell.custom_list(things) if type == 'sell'

    ELoot.go2(ELoot.data.start_room)
    ELoot::Sell.breakdown
  when /settings|setup/i
    if Script.current.vars[2]
      ELoot.update_setting(Script.current.vars[2..-1])
    elsif defined?(Gtk)
      ELoot.launch_settings_ui
    else
      ELoot.msg(text: " Gtk is not defined. Please use CLI to change options")
      ELoot.msg(text: " Format is #{$lich_char}#{Script.current.name} settings <setting_to_change> <new_value>")
      ELoot.msg(text: " To list settings #{$lich_char}#{Script.current.name} options")
    end
  when /options/i
    ELoot.msg(type: "default", text: ELoot.data.settings.keys.sort.join("\n"))
  when /raid/
    ELoot::Hoard.raid_cache(Script.current.vars)
    ELoot.go2(ELoot.data.start_room)
  when /(list|deposit|reset) (gem|reagent|alchemy)/i
    do_what = $1
    item = $2
    if item =~ /reagent|alchemy/
      type = 'alchemy'
    elsif item =~ /gem/
      type = 'gem'
    end
    case do_what
    when /list/i
      ELoot::Hoard.list_inventory(type)
    when /deposit/i
      ELoot::Hoard.hoard_items(type, true)
    when /reset/i
      ELoot::Hoard.reset_inventory(type)
      ELoot::Hoard.list_inventory(type)
    end
    ELoot.go2(ELoot.data.start_room)
  when /bounty/i
    ELoot::Hoard.get_gem_bounty
  when /load/i
    waitrt?
    ELoot.load(ELoot.load_profile)
    ELoot.set_inventory
  when /deposit/i
    ELoot.silver_deposit(true)
    ELoot.go2(ELoot.data.start_room)
  when /^skin/i
    ELoot::Loot.skin
  when /test/i
    ELoot.test
  else
    ELoot.help
  end
end
