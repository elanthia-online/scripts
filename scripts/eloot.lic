# frozen_string_literal: true

=begin
  eloot.lic: eLoot is fork/update/rewrite of sloot.

  Some primary changes from sloot include using in-game STOW settings instead of variables.
  Locksmith pool handling, loot room, exclusion support, appraise limits.
  eloot also auto-writes settings to your Lich5/Data/eloot folder per character.

            author: elanthia-online
   original author: SpiffyJr (sloot)
        maintainer: elanthia-online
      contributors: SpiffyJr, Athias, Demandred, Tysong, Deysh, Ondreian, Lieo
              wiki: https://gswiki.play.net/Lich:Script_Eloot
              game: Gemstone
              tags: loot
           version: 2.0.2
  Improvements:
  Major_change.feature_addition.bugfix
  v2.0.2  (2024-11-20)
    - bugfix in single_loot method
    - bugfix in hording process
    - bugfix for urchin guide
  v2.0.1  (2024-11-12)
    - bugfix to only buff for selling if something to sell
    - bugfix to exit if insufficient funds at bank
  v2.0.0  (2024-09-04)
    - support for hording gems and alchemy ingredients
    - support for in-between script to run. This runs between finishing the pool and before selling. Usecase: totems, hording, supplies, whatever
    - addition of CLI selling options: sellable, type, and itemized
    - disk usage tracking improvements
    - incremental tipping added for locksmith pool
    - added appraisal container to store items appraised over limit.
    - added crumble messaging for the bowels
    - bugfix for selling in HW
    - bugfix for closed coin bag
    - bugfix for favor_left skinning
    - bugfix for silver_deposit if keeper_silvers returns a note
    - bugfix for coin hand bank deposit
    - changes to UI
    - bugfix for coin bag capacity check
    - bugfix for shattered urchin usage
    - bugfix for 1205 Glamour
    - updated changelog on wiki
    - removed changelog in script before 1.6.20
  v1.6.36 (2024-08-16)
    - pause script instead of exit when failing to empty container
  v1.6.35 (2024-08-10)
    - fix for emptying container but failing due to full bag
  v1.6.34 (2024-08-07)
    - bugfix for box_in_hand method
  v1.6.33 (2024-07-25)
    - add additional get_regex for READY WEAPON
  v1.6.32 (2024-07-20)
    - box_in_hand method updated to process both hands.
  v1.6.31 (2024-06-30)
    - add toggle for coin hand closing to be optional after selling
  v1.6.30 (2024-06-28)
    - fix for coin hand not closing after selling routine
  v1.6.29 (2024-05-13)
    - Option to use Sigil of Determination if loot fails due to injury
  v1.6.28 (2024-05-01)
    - Change bad Char.methods to Stats.method
  v1.6.27 (2024-04-28)
    - add additional disk noun bassinet
  v1.6.26 (2024-04-24)
    - fix for GST and F2P accounts
    - fix for disk noun regex word boundary
  v1.6.25 (2024-04-24)
    - handle all the new custom disk nouns
  v1.6.24 (2024-04-05)
    - update change_stance to use percentstance instead of checkstance
    - add support for CMAN STANCE in change_stance
  v1.6.23 (2024-04-05)
    - additional open/close messaging for squelching
    - reduce Lich::Util.quiet_command_xml timeout from default 5 to 2 seconds
  v1.6.22 (2024-03-29)
    - fix for Frozen Bramble creatures requiring left hand to be empty in order to loot.
  v1.6.21 (2024-03-26)
    - add messaging for valence weapons
  v1.6.20 (2024-03-16)
    - added use of trash verb
    - (F2P) withdraw a note when the max bank account balance is reached
    - fix to not "Share silvers" from the allotment of "Keep Silvers"
    - fix to locksmith rooms without trashcans
=end

require 'yaml'

begin
  require 'terminal-table' unless defined?(Terminal::Table)
rescue LoadError
  respond "You need to have the 'terminal-table' gem installed"
  respond "Please install it with the following command: gem install terminal-table"
  respond "Via your computer's local terminal/shell"
  exit
end

# eloot is a looter for Gemstone that focuses on performance
module ELoot
  @@data ||= nil

  ##### Data & Setup Start #####

  def self.get_script_version
    data = Script.list.find { |x| x.name == Script.current.name }.inspect
    return data[/version: (\d+\.\d+\.\d+)/i, 1]
  end

  def self.version_check
    # Check version of Lich for compatibility
    needs_exit = false

    scripts = {
      "infomon" => '1.18.11',
      "lich"    => '5.4.1'
    }

    versions = {}
    scripts.keys.each { |item|
      next if item == 'infomon' && defined?(Infomon)
      file_name = nil
      file_data = nil
      comments = nil

      if File.exist?(File.join(SCRIPT_DIR, "custom", "#{item}.lic"))
        file_name = File.join(SCRIPT_DIR, "custom", "#{item}.lic")
      elsif File.exist?(File.join(SCRIPT_DIR, "#{item}.lic"))
        file_name = File.join(SCRIPT_DIR, "#{item}.lic")
      end

      if item == "lich"
        versions[item] = LICH_VERSION
      elsif file_name.nil?
        versions[item] = "No file found"
      else
        file_data = File.open(file_name, 'r').read

        if file_data =~ /^=begin\r?\n?(.+?)^=end/m
          comments = $1.split("\n")
        else
          comments = []
          file_data.split("\n").each { |line|
            if line =~ /^[\t\s]*#/
              comments.push(line)
            elsif line !~ /^[\t\s]*$/
              break
            end
          }
        end
        for line in comments
          if line =~ /^[\s\t#]*version:[\s\t]*([\w,\s\.\d]+)/i
            versions[item] = $1.sub(/\s\(.*?\)/, '').strip
          end
        end
      end

      if versions[item] == "No file found"
        if $frontend == 'stormfront' || $frontend == 'profanity'
          _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
          _respond "\<preset id=\"thought\"\>" + " Required Script: #{item} was not found!" + "\<\/preset\>"
          _respond "\<preset id=\"thought\"\>" + " Please download the latest version." + "\<\/preset\>"
          if item == "infomon"
            _respond "\<preset id=\"thought\"\>" + " ;jinx script update infomon --repo=elanthia-online" + "\<\/preset\>"
          elsif item == "lich"
            _respond "\<preset id=\"thought\"\>" + " ;lich5-update --update" + "\<\/preset\>"
          end
          _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
        else
          _respond "##" + "########################################"
          _respond ">" + " Required Script: #{item} was not found!"
          _respond ">" + " Please download the latest version."
          if item == "infomon"
            _respond ">" + " ;jinx script update infomon --repo=elanthia-online"
          elsif item == "lich"
            _respond ">" + " ;lich5-update --update"
          end
          _respond "##" + "########################################"
        end
        exit
      elsif Gem::Version.new(versions[item]) < Gem::Version.new(scripts[item])
        needs_exit = true
        if $frontend == 'stormfront' || $frontend == 'profanity'
          _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
          _respond "\<preset id=\"thought\"\>" + " Required Script: #{item} needs version #{scripts[item]} to run." + "\<\/preset\>"
          _respond ""
          _respond "\<preset id=\"thought\"\>" + " Currently Running Version: #{versions[item]}" + "\<\/preset\>"
          _respond "\<preset id=\"thought\"\>" + " Please update to the latest version." + "\<\/preset\>"
          if item == "infomon"
            _respond "\<preset id=\"thought\"\>" + " ;jinx script update infomon --repo=elanthia-online --force" + "\<\/preset\>"
            _respond "\<preset id=\"thought\"\>" + " then kill infomon and restart it" + "\<\/preset\>"
          elsif item == "lich"
            _respond "\<preset id=\"thought\"\>" + " ;lich5-update --update" + "\<\/preset\>"
          end
          _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
        else
          _respond "##" + "########################################"
          _respond ">" + " Required Script: #{item} needs version #{scripts[item]} to run."
          _respond ">" + ""
          _respond ">" + " Currently Running Version: #{versions[item]}"
          _respond ">" + " Please update to the latest version."
          if item == "infomon"
            _respond ">" + " ;jinx script update infomon --repo=elanthia-online --force"
            _respond ">" + " then kill infomon and restart it"
          elsif item == "lich"
            _respond ">" + " ;lich5-update --update"
          end
          _respond "##" + "########################################"
        end
      end
    }
    exit if needs_exit
  end

  def self.launch_settings_ui
    Setup.new(data.settings).start
    ELoot.load(load_profile)
    set_inventory
  end

  def self.load_defaults()
    default_hash = {
      :loot_types                      => ["alchemy", "armor", "box", "breakable", "clothing", "collectible", "food", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
      :loot_exclude                    => ["black ora", "urglaes"],
      :loot_phase                      => false,
      :use_disk                        => true,
      :loot_defensive                  => false,
      :coin_hand_name                  => "",
      :sigil_determination_on_fail     => false,
      :charm_name                      => "",
      :overflow_container              => "",
      :secondary_overflow              => "",
      :sell_loot_types                 => ["alchemy", "armor", "breakable", "clothing", "food", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand", "box"],
      :sell_container                  => ["default", "overflow", "box", "collectible", "forageable", "gem", "herb", "lockpick", "potion", "reagent", "scroll", "skin", "treasure", "trinket", "wand"],
      :sell_exclude                    => [],
      :sell_keep_scrolls               => [],
      :sell_appraise_types             => ["jewelry", "magic", "uncommon", "valuable"],
      :sell_appraise_gemshop           => 14999,
      :sell_appraise_pawnshop          => 34999,
      :sell_collectibles               => true,
      :sell_gold_rings                 => false,
      :sell_locksmith                  => false,
      :sell_locksmith_pool             => true,
      :always_check_pool               => false,
      :display_box_contents            => false,
      :sell_locksmith_pool_tip         => 15,
      :sell_locksmith_pool_tip_percent => true,
      :sell_share_silvers              => false,
      :sell_fwi                        => false,
      :sell_shroud                     => false,
      :sell_aspect                     => false,
      :sell_keep_silver                => 0,
      :skin_enable                     => false,
      :skin_kneel                      => false,
      :skin_604                        => false,
      :skin_resolve                    => false,
      :skin_sheath                     => "",
      :skin_weapon                     => "",
      :skin_sheath_blunt               => "",
      :skin_weapon_blunt               => "",
      :silence                         => false,
      :debug                           => false,
      :unskinnable                     => [],
      :unlootable                      => [],
      :auto_close                      => [],
      :crumbly                         => [],
      :keep_closed                     => false,
      :track_full_sacks                => true,
      :favor_left                      => false,
      :log_unlootables                 => false
    }

    Dir.mkdir("#{$data_dir}#{XMLData.game}") unless File.exist?("#{$data_dir}#{XMLData.game}")
    Dir.mkdir("#{$data_dir}#{XMLData.game}/#{Char.name}") unless File.exist?("#{$data_dir}#{XMLData.game}/#{Char.name}")

    File.write("#{$data_dir}#{XMLData.game}/#{Char.name}/eloot.yaml", default_hash.to_yaml)

    default_hash
  end

  def self.load_profile(name: Char.name)
    if name != nil
      filename = "#{$data_dir}#{XMLData.game}/#{name}/eloot.yaml"
      if File.exist?("#{filename}") && name == Char.name
        settings_hash = YAML.load_file(filename)
      elsif !File.exist?("#{filename}") && name != Char.name
        ELoot.msg(type: "error", text: " ELoot.load_profile: Attempt to load a profile that does not exist.")
      elsif !File.exist?("#{filename}") && name == Char.name
        ELoot.msg(type: "info", text: " No current settings found.  Loading defaults...")
        settings_hash = ELoot.load_defaults()
      else
        ELoot.msg(type: "error", text: " ELoot.load_profile: There was an unknown error with loading a profile")
      end
    else
      ELoot.msg(type: "error", text: " ELoot.load_profile: name not defined")
    end

    settings_hash
  end

  def self.save_profile(name: Char.name, silent: false)
    # This adds it to the profile for backward compatability
    ELoot.data.settings[:display_box_contents] = false unless ELoot.data.settings.has_key?(:display_box_contents)
    ELoot.data.settings[:use_disk] = true unless ELoot.data.settings.has_key?(:use_disk)
    ELoot.data.settings[:keep_closed] = false unless ELoot.data.settings.has_key?(:keep_closed)
    ELoot.data.settings[:track_full_sacks] = true unless ELoot.data.settings.has_key?(:track_full_sacks)
    ELoot.data.settings[:favor_left] = false unless ELoot.data.settings.has_key?(:favor_left)

    # Remove overflow container name from settings. We don't need to save it
    default_settings = ["default", "overflow", "box", "collectible", "forageable", "gem", "herb", "lockpick", "potion", "reagent", "scroll", "skin", "treasure", "trinket", "wand"]

    ELoot.data.settings[:sell_container].each { |container|
      ELoot.data.settings[:sell_container].delete(container) unless default_settings.include?(container)
    }

    if name != nil
      filename = "#{$data_dir}#{XMLData.game}/#{Char.name}/eloot.yaml"
      if name == Char.name
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg(type: "info", text: " Settings saved to file: #{filename}.") unless silent
      elsif File.exist?("#{filename}") && name != Char.name
        ELoot.msg(type: "info", text: " You are attempt to overwrite another profile!")
        ELoot.msg(type: "info", text: " If you wish to overwrite, please ;unpause eloot.")
        ELoot.msg(type: "info", text: " Else ;kill eloot and choose another filename.")
        pause_script
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg(type: "info", text: " Settings saved to file: #{filename}.")
      elsif !File.exist?("#{filename}") && name != Char.name
        File.write(filename, ELoot.data.settings.to_yaml)
        ELoot.msg(type: "info", text: " Settings are being saved to another profile!")
        ELoot.msg(type: "info", text: " Settings saved to file: #{filename}.")
      else
        ELoot.msg(type: "error", text: " ELoot.save_profile: There was an unknown error with saving a profile")
      end
    end
  end

  def self.load(settings)
    @@data = Data.new(settings)
  end

  def self.data
    @@data
  end

  def self.update_setting(input)
    setting_to_update = normalize_setting_name(input.first)
    ELoot.msg(type: "debug", text: "Normalized #{input.first} as #{setting_to_update}")

    if ELoot.data.settings.keys.include?(setting_to_update)
      default_value = ELoot.data.settings[setting_to_update].dup
      ELoot.msg(type: "debug", text: "recognized #{setting_to_update} as as valid #{default_value.class} setting")
      new_value = coerce_setting_value(setting_to_update, default_value, input[1..-1])
      ELoot.msg(type: "debug", text: "Normalized #{input[1..-1]} as #{new_value.inspect}")

      data.settings[setting_to_update] = new_value
      ELoot.msg(type: "info", text: " Updated #{setting_to_update} to #{new_value}")
      ELoot.save_profile()
    else
      ELoot.msg(type: "error", text: " #{setting_to_update} is not a recognized setting. Recognized setting names:")
      ELoot.msg(type: "error", text: ELoot.data.settings.keys.sort.join("\n"))
    end
  end

  def self.coerce_setting_value(setting_name, default, input)
    case default
    when TrueClass, FalseClass
      fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
      fix_option.fetch(input[0]) do |v|
        ELoot.msg(type: "error", text: %{Expected a boolean (true/false/yes/no) value for "#{setting_name} but got "#{v}"})
        exit
      end
    when Array
      input
    when Integer
      v = input[0]
      if v =~ /\A[+-]?\d+\z/
        v.to_i
      else
        ELoot.msg(type: "error", text: %{Expected an integer value for #{setting_name} value but got "#{v}"})
        exit
      end
    when String
      input.join(" ")
    else
      ELoot.msg(type: "error", text: "Recognized #{setting_name} but don't know how to normalize a #{default.class} type setting")
      exit
    end
  end

  def self.normalize_setting_name(input)
    input.downcase.tr('-', '_').to_sym
  end

  def self.issue_command(command, start_pattern, end_pattern = /<prompt/, include_end: true, timeout: 5, silent: nil, usexml: true, quiet: false)
    result = []
    name = "ELoot:: -#{Time.now.tv_sec}.#{Time.now.tv_usec}-#{Random.rand(10000)}"
    filter = false

    save_script_silent = Script.current.silent
    save_want_downstream = Script.current.want_downstream
    save_want_downstream_xml = Script.current.want_downstream_xml

    Script.current.silent = silent if !silent.nil?
    Script.current.want_downstream = !usexml
    Script.current.want_downstream_xml = usexml

    begin
      Timeout::timeout(timeout, Interrupt) {
        DownstreamHook.add(name, proc { |line|
          if filter
            if line =~ end_pattern
              DownstreamHook.remove(name)
              filter = false
              if quiet
                next(nil)
              else
                line
              end
            else
              if quiet
                next(nil)
              else
                line
              end
            end
          elsif line =~ start_pattern
            filter = true
            if quiet
              next(nil)
            else
              line
            end
          else
            line
          end
        })
        fput command

        until (line = get) =~ start_pattern; end
        result << line.rstrip
        until (line = get) =~ end_pattern
          result << line.rstrip
        end
        if include_end
          result << line.rstrip
        end
      }
    rescue Interrupt
      nil
    ensure
      DownstreamHook.remove(name)
      Script.current.silent = save_script_silent if !silent.nil?
      Script.current.want_downstream = save_want_downstream
      Script.current.want_downstream_xml = save_want_downstream_xml
    end
    return result
  end

  def self.get_command(command, regex)
    lines = []
    regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

    loop {
      lines = ELoot.issue_command(command, regex)
      ELoot.msg(type: "debug", text: " get_lines: command: #{command} | lines - #{lines}")
      if lines.any? { |l| l =~ /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i }
        waitrt?
        next
      else
        break
      end
    }

    return lines
  end

  def self.get_lines(command, regex)
    lines = []
    regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)

    loop do
      lines = Lich::Util.quiet_command_xml(command, regex, /<prompt/, true, 2, true)
      ELoot.msg(type: "debug", text: " get_lines: command: #{command} | lines - #{lines}")
      break unless lines.grep(/(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i).any?

      ELoot.wait_rt
    end

    return lines
  end

  def self.get_res(command, regex = nil)
    rt_regex = /(?:Roundtime:|\.\.\.wait|Wait) (\d+) [Ss]ec(?:onds?)?\.?|An uncontrollable urge to scratch the rash/
    regex = regex.nil? ? Regexp.union(/.*?/, rt_regex) : Regexp.union(regex, rt_regex)
    result = nil
    loop do
      result = dothistimeout(command, 3, regex)
      break unless result =~ rt_regex

      ELoot.wait_rt
    end

    return result
  end

  def self.sell
    Sell.sell
  end

  def self.set_inventory
    waitrt?

    # Check account type
    if defined?(Account.subscription)
      ELoot.data.account_type = Account.subscription
    else
      lines = ELoot.get_lines('account', /Game Instance/)
      ELoot.data.account_type = $1 if lines.any?(/Account Type: (\w+)/)
    end

    # Find the Containers we need: stow, overflow, skin sheathes, ready sheathes
    # Finding the Stow list
    container_match = /<a exist="([^"]+)" noun="[^"]+">[^(.]+\(([a-z]+)\)/
    loop {
      container_lines = ELoot.get_lines("stow list", /<output class="mono"\/>/)

      container_lines.each { |line|
        if line =~ container_match
          ELoot.data.sacks.store(Regexp.last_match(2), GameObj.inv.find { |i| i.id == Regexp.last_match(1) })
          ELoot.data.sacks.delete(Regexp.last_match(2)) unless ELoot.data.sacks[Regexp.last_match(2)]
        end
      }

      if container_lines.any? { |l| l =~ /(none)/ }
        ELoot.msg(type: "error", text: " No containers are set. Please see the ingame 'stow' command")
        exit
      elsif !container_lines.any? { |l| l =~ /default/ }
        ELoot.msg(type: "error", text: " Set stow container using STOW SET before using this script")
        exit
      elsif !container_lines.any? { |l| l =~ /You have the following containers set as stow targets/ }
        ELoot.msg(type: "info", text: " Stow containers didn't load right. Trying again!")
        next
      else
        break
      end
    }

    # Add appraisal container if entered
    unless ELoot.data.settings[:appraisal_container].to_s.empty?
      ELoot.data.sacks.store(ELoot.data.settings[:appraisal_container].to_s, GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:appraisal_container]}\b/i })
    end

    # Add the overflow sacks
    ELoot.data.sacks.store(ELoot.data.settings[:overflow_container].to_s, GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:overflow_container]}\b/i })
    ELoot.data.sacks.store(ELoot.data.settings[:secondary_overflow].to_s, GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:secondary_overflow]}\b/i })
    ELoot.data.sacks.delete("")

    ELoot.data.settings[:sell_container].push(ELoot.data.settings[:overflow_container].to_s) if ELoot.data.settings[:sell_container].include?("overflow")
    ELoot.data.settings[:sell_container].push(ELoot.data.settings[:secondary_overflow].to_s) if ELoot.data.settings[:sell_container].include?("overflow")
    ELoot.data.settings[:sell_container].delete("")

    # Add the skin sheathes if set
    ELoot.data.ready_list.store("skin_sheath", GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:skin_sheath]}\b/i if !ELoot.data.settings[:skin_sheath].empty? && !ELoot.data.settings[:skin_sheath].nil? })
    ELoot.msg(type: "debug", text: " ELoot.data.ready_list['skin_sheath']: #{ELoot.data.ready_list['skin_sheath']}")

    # Is it hidden?
    if !ELoot.data.settings[:skin_sheath].empty? && !ELoot.data.settings[:skin_sheath].nil? && ELoot.data.ready_list["skin_sheath"].nil?
      ELoot.msg(type: "debug", text: " ELoot.data.ready_list['skin_sheath'] not found but in setup")
      lines = Lich::Util.quiet_command_xml("pull my sheath", /You reach down|I'm afraid that/, /<prompt/, true, 2, true)
      ELoot.msg(type: "debug", text: " Is sheath hidden? : #{lines}")
      if lines.any? { |line| line =~ /You reach down/i }
        Lich::Util.quiet_command_xml("inventory full", /You are (holding|wearing)/, /<prompt/, true, 2, true)
        ELoot.msg(type: "debug", text: " If it was hidden did the GameObj populate? : #{GameObj.inv}")
        ELoot.data.ready_list.store("skin_sheath", GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:skin_sheath]}\b/i if !ELoot.data.settings[:skin_sheath].empty? && !ELoot.data.settings[:skin_sheath].nil? })
        Lich::Util.quiet_command_xml("push my #{ELoot.data.settings[:skin_sheath]}", /You reach down|I'm afraid that you can't pull that/, /<prompt/, true, 2, true)
      end

    end

    ELoot.data.ready_list.store("skin_sheath_blunt", GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:skin_sheath_blunt]}\b/i if !ELoot.data.settings[:skin_sheath_blunt].empty? && !ELoot.data.settings[:skin_sheath_blunt].nil? })
    ELoot.data.ready_list.delete("")

    # Finding the ready list sheathes
    sheath_list_match = /(?:sheath|secondary sheath):\s+<d\scmd="store\s(\w+)\sclear">[^<]+<a\sexist="(\d+)"\snoun="[^"]+">([^<]+)<\/a>(?:\s[^<]+)?<\/d>/

    ready_lines = []
    loop {
      ready_lines = ELoot.get_lines("ready list", /<output class="mono"\/>/)

      if !ready_lines.any? { |l| l =~ /Your current settings are/ }
        ELoot.msg(type: "info", text: " Ready List didn't load right. Trying again!")
        next
      else
        break
      end
    }

    ready_lines.each { |line|
      if line =~ sheath_list_match
        ELoot.data.ready_list.store(Regexp.last_match(1).to_s.downcase, GameObj.inv.find { |i| i.id == Regexp.last_match(2) })
      end
    }

    # Open the bags so we have the contents
    all_bags = ELoot.data.sacks.merge(ELoot.data.ready_list)
    items_opened = Array.new

    all_bags.each { |_k, item|
      next if items_opened.include?(item)

      items_opened.push(item)
      Inventory.open_single_container(item)
    }

    # Lets grab the inventory
    items = []
    exist = %r{<a exist=(?:'|")(?<id>.*?)(?:'|") noun=(?:'|")(?<noun>.*?)(?:'|")>(?<name>.*?)</a>}

    lines = ELoot.get_lines("inventory full", /<streamWindow/)

    lines.each do |line| line.scan(exist).each do |matches| items << GameObj.new(*matches) unless items.any? { |i| i.id =~ /#{matches[0]}/ } end end

    # Make sure to include what's in our hands
    items << GameObj.right_hand if checkright
    items << GameObj.left_hand if checkleft

    # Finding the ready list items
    ready_list_match = /(?:shield|weapon|secondary weapon|ranged weapon):\s+<d\scmd="store\s(\w+)\sclear">[^<]+<a\sexist="(\d+)"\snoun="[^"]+">([^<]+)<\/a>(?:\s[^<]+)?<\/d>\s+\(<d\scmd='store set'>([^<]+)<\/d>\)/
    ready_lines.each { |line|
      if line =~ ready_list_match
        ELoot.data.ready_list.store(Regexp.last_match(1).to_s.downcase, items.find { |i| i.id == Regexp.last_match(2) })
        ELoot.data.ready_method.store(Regexp.last_match(1).to_s.downcase, Regexp.last_match(4))
      end
    }

    # Finding the bladed skinner - check sheath first
    unless ELoot.data.ready_list["skin_sheath"].nil?
      # Lets see if the edged skin weapon is in the sheath
      ELoot.msg(type: "debug", text: " ELoot.data.ready_list['skin_sheath'].contents: #{ELoot.data.ready_list['skin_sheath'].contents}")
      unless ELoot.data.settings[:skin_weapon].empty?
        ELoot.data.skin_edged = ELoot.data.ready_list["skin_sheath"].contents.find { |i| i.name =~ /\b#{ELoot.data.settings[:skin_weapon]}\b/i }
        ELoot.msg(type: "debug", text: " ELoot.data.skin_edged: #{ELoot.data.skin_edged}")
      end
    end

    # Finding the blunt skinner - check sheath first
    unless ELoot.data.ready_list["skin_sheath_blunt"].nil?
      # Lets see if the blunt skin weapon is in the blunt sheath
      ELoot.msg(type: "debug", text: " ELoot.data.ready_list['skin_sheath_blunt'].contents: #{ELoot.data.ready_list['skin_sheath_blunt'].contents}")
      unless ELoot.data.settings[:skin_weapon_blunt].empty?
        ELoot.data.skin_blunt = ELoot.data.ready_list["skin_sheath_blunt"].contents.find { |i| i.name =~ /\b#{ELoot.data.settings[:skin_weapon_blunt]}\b/i }
      end
    end

    # If not in the sheath maybe its someplace else
    if (ELoot.data.skin_edged.nil? && !ELoot.data.settings[:skin_weapon].empty?) || (ELoot.data.skin_blunt.nil? && !ELoot.data.settings[:skin_weapon_blunt].empty?)
      if ELoot.data.skin_edged.nil?
        ELoot.data.skin_edged = items.find { |i| i.type =~ /weapon/i && i.name =~ /\b#{ELoot.data.settings[:skin_weapon]}\b/i }
      end

      if ELoot.data.skin_blunt.nil?
        ELoot.data.skin_blunt = items.find { |i| i.type =~ /weapon/i && i.name =~ /\b#{ELoot.data.settings[:skin_weapon_blunt]}\b/i }
      end
    end

    # Do we have a fossil charm?
    unless ELoot.data.settings[:charm_name].to_s.empty?
      ELoot.data.charm = GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:charm_name]}\b/i }
    end
    ELoot.msg(type: "debug", text: " ELoot.data.settings[:charm_name]: #{ELoot.data.settings[:charm_name].inspect} ELoot.data.coin_hand: #{ELoot.data.charm.inspect}")

    # Are we using a coin hand?
    unless ELoot.data.settings[:coin_hand_name].to_s.empty?
      # #Are we wearing the coin hand?
      ELoot.data.coin_hand = GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:coin_hand_name]}\b/i }

      unless ELoot.data.coin_hand
        # Guess not so loop thru inv and see if we can find it
        GameObj.inv.each { |item|
          if !items_opened.include?(item)
            Inventory.open_single_container(item)
          end
          ELoot.data.coin_hand = item.contents.find { |thing| thing.name =~ /\b#{ELoot.data.settings[:coin_hand_name]}\b/i }
          if ELoot.data.coin_hand
            ELoot.data.coin_container = item
            break
          end
        }
      end
    end
    ELoot.msg(type: "debug", text: " ELoot.data.settings[:coin_hand_name]: #{ELoot.data.settings[:coin_hand_name].inspect} ELoot.data.coin_hand: #{ELoot.data.coin_hand.inspect}")

    # Have an eonake gauntlet?
    ELoot.data.gauntlet = GameObj.inv.find { |i| i.name =~ /\beonake gauntlet\b/i }

    # Using a disk?
    ELoot.disk_usage

    # If ELoot.data.settings[:keep_closed] close anything we opened
    Inventory.close_sell_containers

    ELoot.validate_setup
  end

  def self.time_between(method_name, gap)
    current_time = Time.now

    # Check if the method was previously called and if the time gap is satisfied
    if ELoot.data.last_called[method_name]
      time_diff = current_time - ELoot.data.last_called[method_name]
      return false if time_diff < gap
    end

    ELoot.data.last_called[method_name] = current_time
    return true # Return true if either it's the first call or enough time has passed
  end

  def self.manage_sorter
    if running? "sorter"
      kill_script("sorter")
      before_dying { Script.start('sorter') }
    end
  end

  def self.disk_usage
    return if DownstreamHook.list.include?("eloot-diskintegration") && ELoot.data.settings[:use_disk] && !ELoot.data.disk.nil?

    if ELoot.data.settings[:use_disk]
      if ELoot.data.disk.nil?
        # Longer search if hook isn't already present
        if DownstreamHook.list.include?("eloot-diskintegration")
          ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{XMLData.name} #{ELoot.data.disk_nouns_regex}\b/ }
        else
          15.times do
            ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{XMLData.name} #{ELoot.data.disk_nouns_regex}\b/ }
            break if ELoot.data.disk
            sleep(0.1)
          end
        end
      end

      # Add downstream hook if not already present
      unless DownstreamHook.list.include?("eloot-diskintegration")
        DownstreamHook.add(
          'eloot-diskintegration',
          proc do |line|
            if line =~ /The \<a exist\=\"\d+\" noun\=\"#{ELoot.data.disk.noun}\"\>#{ELoot.data.disk.name}\<\/a\>.+ disintegrates\./
              ELoot.data.disk = nil
              ELoot.data.disk_full = false
            end
            line
          end
        )
      end

    else
      # Clear disk and remove downstream hook if not using disk
      ELoot.data.disk = nil
      DownstreamHook.remove("eloot-diskintegration")
    end
  end

  def self.msg(type: "yellow", text: nil, space: false)
    # color options - set type to use
    # yellow, orange, teal, green, plain

    return if type == "debug" && !ELoot.data.settings[:debug]

    if text.class == Hash
      text = text.inspect.gsub("#<", "#")
    elsif text.class == Array
      text = text.to_s
    elsif text.class == String
      text = text.gsub("#<", "#")
    end

    respond '' if space
    if type == 'debug'
      begin
        Lich::Messaging.mono(Lich::Messaging.xml_encode(text))
      rescue NoMethodError
        respond(text)
      end
    else
      Lich::Messaging.msg(type, text)
    end
    respond '' if space
  end

  def self.fwi?(room)
    (room.location =~ /Four Winds|Mist Harbor|Western Harbor/)
  end

  def self.return_from_fwi
    current_town = Room.current.find_nearest_by_tag("town")

    if current_town == 3668
      if UserVars.mapdb_fwi_trinket.nil?
        ELoot.msg(type: "yellow", text: "  Please set your FWI trinket in go2 setup. \n")
        exit
      end

      ELoot.go2(3669)
      if UserVars.mapdb_fwi_return_room.nil?
        worn = GameObj[UserVars.mapdb_fwi_trinket].nil? ? false : true
        fput "get my #{UserVars.mapdb_fwi_trinket}" unless worn
        fput "turn ##{GameObj[UserVars.mapdb_fwi_trinket].id}"
        fput "stow my #{UserVars.mapdb_fwi_trinket}" unless worn
      else
        ELoot.go2(UserVars.mapdb_fwi_return_room)
      end
    end
  end

  def self.test
    echo " Eloot Version: #{ELoot.get_script_version}"
    echo ""
    echo "--------------- Settings ---------------"
    echo(*ELoot.data.settings)
    echo ""
    echo "--------------- Sacks ------------------"
    echo(*ELoot.data.sacks)
    echo ""
    echo "--------------- Disk -------------------"
    echo ELoot.data.disk.inspect
    echo ""
    echo "--------------- Full Disk/Sack Check ---"
    echo "Disk Full: #{ELoot.data.disk_full.inspect}"
    echo "Sacks Full: #{ELoot.data.sacks_full.inspect}"
    echo ""
    echo "--------------- Contents ---------------"

    items_opened = Array.new
    ELoot.data.sacks.keys.each { |item|
      next if items_opened.include?(ELoot.data.sacks[item].id)

      items_opened.push(ELoot.data.sacks[item].id)
      Inventory.open_single_container(ELoot.data.sacks[item])
      ELoot.data.sacks[item].contents.each { |thing|
        echo "Container: #{ELoot.data.sacks[item]} | Item: #{thing.name} | Type: #{thing.type} | Sellable: #{thing.sellable}"
      }
    }

    echo ""
    echo "--------------- Ready List -------------"

    ELoot.data.ready_list.each { |item|
      echo item
    }

    echo ""
    echo "--------------- Skinning Weapons -------------"

    echo "Edged Skinner: #{ELoot.data.skin_edged.inspect}"
    echo "Blunt Skinner: #{ELoot.data.skin_blunt.inspect}"

    echo ""
    echo "--------------- Coin Hand -------------"

    echo "Coin Hand: #{ELoot.data.coin_hand.inspect}"
    echo "Coin Container: #{ELoot.data.coin_container.inspect}"

    echo "--------------GameObj Types-------------"
    echo GameObj.type_data.map { |k, _v| k }.sort.join(', ')
  end

  def self.validate_setup
    # Checks:
    # Sacks
    # Overflow Primary
    # Overflow Secondary
    # Bladed Skinning Sheath
    # Blunt Skinning Sheath
    # Bladed Skinner
    # Blunt Skinner
    # Coin Hand

    # Checks:
    # Sacks
    # Overflow Primary
    # Overflow Secondary
    # Bladed Skinning Sheath
    # Blunt Skinning Sheath
    # Bladed Skinner
    # Blunt Skinner

    valid_setup = true

    if ELoot.data.sacks.nil?
      ELoot.msg(text: " Unable to find your stow sacks.")
      valid_setup = false
    end

    if ELoot.data.settings[:overflow_container].length.positive? && ELoot.data.sacks[ELoot.data.settings[:overflow_container]].nil?
      ELoot.msg(text: " Unable to find your primary overflow container.")
      valid_setup = false
    end

    if ELoot.data.settings[:secondary_overflow].length.positive? && ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]].nil?
      ELoot.msg(text: " Unable to find your secondary overflow container.")
      valid_setup = false
    end

    if ELoot.data.settings[:skin_sheath].length.positive? && !ELoot.data.ready_list["skin_sheath"]
      ELoot.msg(text: " Unable to find your bladed skinning sheath.")
      valid_setup = false
    end

    if ELoot.data.settings[:skin_sheath_blunt].length.positive? && ELoot.data.ready_list["skin_sheath_blunt"].nil?
      ELoot.msg(text: " Unable to find your blunt skinning sheath.")
      valid_setup = false
    end

    if ELoot.data.settings[:skin_weapon].length.positive? && ELoot.data.skin_edged.nil?
      ELoot.msg(text: " Unable to find your bladed skinning weapon.")
      valid_setup = false
    end

    if ELoot.data.settings[:skin_weapon_blunt].length.positive? && ELoot.data.skin_blunt.nil?
      ELoot.msg(text: " Unable to find your blunt skinning weapon.")
      valid_setup = false
    end

    if !valid_setup
      ELoot.msg(text: " Something went wrong initializing eloot. Please check ;eloot setup. Exiting...", space: true)

      exit
    end
  end

  ##### Data & Setup End #####

  def self.box_phase(box)
    return unless box.type =~ /box/
    return if box.name =~ /enruned|mithril/i
    return unless ELoot.data.settings[:loot_phase] && Spell[704].known? && Spell[704].affordable?

    loop {
      cast_result = Spell[704].cast("at ##{box.id}")
      break unless cast_result =~ /^\[Spell Hindrance for/ && Spell[704].affordable?
    }
  end

  def self.box_unphase(box)
    lines = ELoot.get_lines("look at ##{box.id}", /You see/)
    return box unless lines.any? { |line| line =~ /shifting/i }

    dothistimeout("drop ##{box.id}", 3, /flickers in and out of existence/)
    ELoot.wait_rt

    ELoot.get_lines("glance hands", /<(right|left)/)

    return [GameObj.right_hand, GameObj.left_hand].find { |hand| hand.type =~ /box/ }
  end

  def self.capitalize_words(string)
    cap_string = string.to_s.split.each { |i| i.capitalize! }.join(' ')
    return cap_string
  end

  def self.change_stance(new_stance)
    return if Effects::Debuffs.active?("Frenzy") || dead?
    return if percentstance(new_stance)
    return if new_stance == 100 && percentstance(80)

    stances = {
      0   => 'offensive',
      20  => 'advanced',
      40  => 'forward',
      60  => 'neutral',
      80  => 'guarded',
      100 => 'defensive'
    }
    if CMan.available?('Stance Perfection') && ![0, 20, 40, 60, 80, 100].include?(new_stance)
      cmd = "cman stance #{new_stance}"
    elsif stances[new_stance]
      cmd = "stance #{stances[new_stance]}"
    else
      cmd = 'stance defensive'
    end

    expiry = Time.now + 2
    while percentstance != new_stance
      res = dothistimeout(cmd, 2, /You are now|You move into|Roundtime|wait|Your rage causes you/i)
      if res =~ /Roundtime: (\d+)|wait (\d+)/i
        sleep((Regexp.last_match(1) || Regexp.last_match(2)).strip.to_f - 1)
        expiry = Time.now + 2
      elsif Time.now > expiry
        break
      else
        break
      end
      sleep 0.5
    end
  end

  def self.use_coin_hand
    return unless ELoot.silver_check.positive?
    return if ELoot.data.coin_hand.nil?

    unless ELoot.data.coin_container.nil?
      Inventory.free_hand
      Inventory.open_single_container(ELoot.data.coin_container)
      Inventory.drag(ELoot.data.coin_hand)
    end

    lines = ELoot.get_lines("inspect ##{ELoot.data.coin_hand.id}", /You carefully inspect/)

    if lines.any? { |l| l =~ /can store a approximately (\d+) silver coins/ }
      capacity = Regexp.last_match(1).to_i
      # How many are there?
      coins = 0
      coin_lines = ELoot.get_lines("look in ##{ELoot.data.coin_hand.id}", /inside the|There is nothing|that is closed/i)

      if coin_lines.any? { |lines| lines =~ /That is closed/i }
        Inventory.open_single_container(ELoot.data.coin_hand)
        coin_lines = ELoot.get_lines("look in ##{ELoot.data.coin_hand.id}", /inside the|There is nothing|that is closed/i)
      end

      if coin_lines.any? { |c| c =~ /you see approximately (\d+) silver coins/ }
        coins = Regexp.last_match(1).to_i
      end
      bag_capacity = capacity - coins
      available_coins = ELoot.silver_check
      coin_storage = available_coins > bag_capacity ? bag_capacity : available_coins

      unless coin_storage.zero?
        Inventory.free_hand
        ELoot.get_res("put #{coin_storage} silver in ##{ELoot.data.coin_hand.id}", /You place/)
        Inventory.return_hands
      end

      ELoot.data.coin_bag = true
    else
      dothistimeout("close ##{ELoot.data.coin_hand.id}", 1, /You feel your pockets lighten/)
      ELoot.data.coin_bag = false
    end

    unless ELoot.data.coin_container.nil?
      Inventory.store_item(ELoot.data.coin_container, ELoot.data.coin_hand)
    end
  end

  def self.decurse(obj)
    return true unless obj.type =~ /cursed/
    return false unless ELoot.data.settings[:loot_types].include?("cursed")

    if Spell[315].known? && !Spell[315].affordable?
      mana_regex = Regexp.union(
        /An invigorating rush of mana pulses through you/i,
        /You are too mentally fatigued to attempt this ability/i,
        /You're already at full mana./i,
        /Your mana control skills are not yet advanced/i,
      )
      dothistimeout "mana pulse", 2, mana_regex
    end

    if Spell[315].known? && !Spell[315].affordable?
      ELoot.msg(type: "info", text: "** #{obj.name} is cursed and you don't have enough mana to cast 315.", space: true)
      return false
    end

    if Spell[315].known? && Spell[315].affordable?
      Spell[315].cast("at ##{obj.id}")
      return true
    end

    unless ELoot.data.gauntlet.nil?
      lines = ELoot.get_lines("look ##{ELoot.data.gauntlet.id}", /You are currently wearing the eonake gauntlet/)
      if lines.any? { |l| l =~ /(right|left) hand/ }
        gauntlet_hand = Regexp.last_match(1)
      end

      if GameObj.right_hand.name == 'Empty'
        return true if gauntlet_hand == 'right'
        if gauntlet_hand == 'left'
          ELoot.get_res("remove ##{ELoot.data.gauntlet.id}", /You slip the gauntlet from/)
          ELoot.get_res("swap", /You swap/) unless GameObj.right_hand.id == ELoot.data.gauntlet.id
          ELoot.get_res("wear ##{ELoot.data.gauntlet.id}", /You slip the eonake gauntlet over/)
          return true
        end
      end

      if GameObj.left_hand.name == 'Empty'
        return true if gauntlet_hand == 'left'
        if gauntlet_hand == 'right'
          ELoot.get_res("remove ##{ELoot.data.gauntlet.id}", /You slip the gauntlet from/)
          ELoot.get_res("swap", /You swap/) unless GameObj.left_hand.id == ELoot.data.gauntlet.id
          ELoot.get_res("wear ##{ELoot.data.gauntlet.id}", /You slip the eonake gauntlet over/)
          return true
        end
      end
    end

    return false
  end

  def self.f2p?
    return false if XMLData.game == 'GST'
    ELoot.data.account_type =~ /F2P|Free/i
  end

  def self.find_boxes
    box_sacks = Array.new
    box_sacks.push(ELoot.data.sacks["box"]) if ELoot.data.settings[:sell_container].include?("box")
    box_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
    box_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]]) if ELoot.data.settings[:sell_container].include?("overflow")
    box_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]]) if ELoot.data.settings[:sell_container].include?("overflow")

    ELoot.msg(type: "debug", text: " box_sacks: #{box_sacks}")

    items = Array.new
    checked_containers = Array.new
    box_sacks.each { |sack|
      next if sack.nil? || checked_containers.include?(sack.id)

      checked_containers.push(sack.id)
      Inventory.open_single_container(sack)
      items += sack.contents.to_a.find_all { |obj| obj.type =~ /box/ }
    }

    if ELoot.data.settings[:use_disk]
      ELoot.wait_for_disk
      Inventory.open_single_container(ELoot.data.disk)
      items += ELoot.data.disk.contents.to_a.find_all { |obj| obj.type =~ /box/ }
    end

    ELoot.msg(type: "debug", text: " box_list before: #{items}")

    box_list = items.uniq

    ELoot.msg(type: "debug", text: " box_list after: #{box_list}")

    box_list.reject! { |box| box.contents.empty? }

    box_list.dup.each do |box|
      lines = ELoot.get_lines("look in ##{box.id}", /<container|That is closed|You see the shifting form/)

      if lines.any? { |line| line =~ /In the|There is nothing/i }
        if box.contents.length.positive?
          unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
            Inventory.drag(box)
          end
          Loot.box_loot(box)
        end
        box_list.delete(box)
      end
    end

    return box_list
  end

  def self.find_trash
    trashcan = nil
    trash_id = nil

    # Use new trash verb first
    lines = ELoot.get_lines('trash', /You could discard items|You do not notice/)

    lines.each do |line|
      if (match_data = line.match(/You could discard items in an? <a exist="(-?\d+)" noun=".*?">.*?<\/a>/))
        trash_id = match_data[1]
      end
    end

    unless trash_id.nil?
      trashcan = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.id == trash_id }
      return trashcan unless trashcan.nil?
    end

    # Still here see if the meta tag is present
    can = Regexp.last_match(1) if Room.current.tags.find { |t| t =~ /meta:trashcan:(.*)/ }

    # Most common scenario - meta:trashcan is defined and GameObj.room_desc is available or trashcan is in GameObj.loot
    trashcan = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.name =~ Regexp.union(can.to_a) }
    return trashcan unless trashcan.nil?

    # Still here? Either the meta:can isn't defined or the room description isn't available. Either way we have to use the noun.
    can = ["barrel", "bin", "basket", "bucket", "canister", "case", "casket", "crate", "hearth", "pit", "stump", "urn", "wastebasket", "wastebin", "wastecan"]
    trash = (Room.current.description.to_s + GameObj.room_desc.to_s + GameObj.loot.to_s).scan(Regexp.union(can)).uniq

    # Check to make sure it's actually a trashcan and not a custom disk/container
    trash.each { |item|
      lines = ELoot.get_lines("look in #{item}", /<container|I could not find what you were referring to.|The(.*?)is filled with a variety of garbage/)

      if lines.grep(/variety of garbage/).any?
        trashcan = GameObj.new(Regexp.last_match(1), item, item) if lines.find { |l| l =~ /^<container id='(-?[0-9]+)' title/ }
      end

      break unless trashcan.nil?
    }

    return trashcan
  end

  def self.find_worker
    worker = nil
    lines = nil
    name = $1 if Room.current.tags.find { |w| w =~ /meta:boxpool:npc:(.*)/ }

    unless name
      name = ["worker", "trickster", "Jahck", "woman", "attendant", "gnome", "merchant", "dwarf"]
    end

    20.times {
      worker = (GameObj.npcs).find { |obj| obj.name =~ Regexp.union(name) }
      break if worker

      lines = ELoot.get_lines("look", /<resource picture/)
      sleep 0.1
    }

    if worker.nil?
      ELoot.msg(type: "info", text: " Failed to find the locksmith pool NPC")
      ELoot.msg(type: "info", text: " GameObj.npcs: #{GameObj.npcs}")
      ELoot.msg(type: "info", text: " Lines: #{lines}")

      ELoot.msg(type: "info", text: " Update your map db; ;repository download-mapdb")
      ELoot.msg(type: "info", text: " If the error persists then report this to Elanthia-Online")
      exit
    end

    return worker
  end

  def self.format_number(number)
    whole, decimal = number.to_s.split('.')
    if whole.to_i < -999 || whole.to_i > 999
      whole.reverse!.gsub!(/(\d{3})(?=\d)/, '\\1,').reverse!
    end
    [whole, decimal].compact.join('.')
  end

  def self.go2(place)
    ELoot.msg(type: "debug", text: " go2 called by #{caller[0]} | place: #{place}")
    fput('unhide') if (hidden? || invisible?)

    # If we're going to a place we do it based on the sell_fwi settings
    if place.class == String && ELoot.data.settings[:sell_fwi]
      fwi_place = Room.list.find { |room| room.tags.include?(place) && ELoot.fwi?(room) }

      place = fwi_place.id if fwi_place
    end

    return if Room.current.id == place || Room.current.tags.include?(place)

    if Room.current.id.nil?
      ELoot.msg(type: "error", text: ' unknown room location')
    end

    if place.class == String && UserVars.mapdb_use_urchins && UserVars.mapdb_urchins_expire.positive? && XMLData.game != 'GSIV' && Room.current.location !~ /the Hinterwilds/

      case place
      when 'locksmith pool'
        place = 'locksmithpool'
      when 'pawnshop'
        place = 'pawn'
      when 'consignment'
        place = 'alchemy'
      end

      Script.run('go2', "town --disable-confirm", { quiet: true }) if Room.current.tags.any?(/nexus/)

      result = dothistimeout("urchin guide #{place}", 3, /You flag down a nearby urchin|You currently have no access to the urchin|As if sensing your desired destination/)
      if result =~ /You currently have no access to the urchin/
        UserVars.mapdb_use_urchins = false
        Script.run('go2', "#{place} --disable-confirm", { quiet: true })
      elsif result.nil?
        ELoot.msg(type: "error", text: " Unknown result from urchin guide usage.")
      end
    else
      Script.run('go2', "#{place} --disable-confirm", { quiet: true })
    end
  end

  def self.help
    rows = []
    rows << [{ value: "*** Mark ANYTHING you don't want to lose. #{Script.current.name.capitalize} is not perfect! ***", colspan: 2, alignment: :center }]
    rows << :separator
    rows << ['Command', 'Description']
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} setup", "UI configuration tool"]
    rows << [' ', ' ']
    rows << ["#{$lich_char}#{Script.current.name}", "Loots items/creatures"]
    rows << ["#{$lich_char}#{Script.current.name} sell", "Sells loot based on UI options"]
    rows << ["#{$lich_char}#{Script.current.name} sell alchemy_mode", "Doesn't sell alchemy reagents"]
    rows << ["#{$lich_char}#{Script.current.name} deposit", "Deposits coins and notes"]
    rows << [' ', ' ']
    rows << ["#{$lich_char}#{Script.current.name} pool", "Only does the locksmith pool"]
    rows << ["#{$lich_char}#{Script.current.name} pool deposit", "Only deposits boxes, not retrieve"]
    rows << :separator
    rows << [{ value: 'Command Line Options', colspan: 2, alignment: :center }]
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} --sellable <categories>", "items that match GameObj sellable categories"]
    rows << ["#{$lich_char}#{Script.current.name} --type <things>", "items that match GameObj types"]
    rows << ["#{$lich_char}#{Script.current.name} --sell <items>", "specific items"]
    rows << :separator
    rows << [{ value: 'Hording', colspan: 2, alignment: :center }]
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} list <gem/reagent>", "Lists horded inventory"]
    rows << ["#{$lich_char}#{Script.current.name} reset <gem/reagent>", "Resets horded inventory"]
    rows << ["#{$lich_char}#{Script.current.name} deposit <gem/reagent>", "Deposits item(s) into horde"]
    rows << ["#{$lich_char}#{Script.current.name} raid <gem/reagent> <item> x<amount>", "Raids horde for item(s)"]
    rows << ["#{$lich_char}#{Script.current.name} bounty", "Raids horde for bounty gems"]
    rows << :separator
    rows << [{ value: 'Troubleshooting', colspan: 2, alignment: :center }]
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} debug", "Toggles debugging on or off"]
    rows << ["#{$lich_char}#{Script.current.name} list", "Lists script settings"]
    rows << ["#{$lich_char}#{Script.current.name} test", "Lists variables and their values"]
    rows << :separator
    rows << [{ value: "*** Mark ANYTHING you don't want to lose. #{Script.current.name.capitalize} is not perfect! ***", colspan: 2, alignment: :center }]

    table = Terminal::Table.new :title => "#{Script.current.name.capitalize} Help", :rows => rows
    table.align_column(1, :right)
    respond
    respond table
    respond
  end

  def self.loot
    if Spell['Berserk'].active?
      ELoot.msg(type: "info", text: " Your current status prevents you from looting.")
      return
    end

    sleep 0.2

    # remember what is in our hands
    ELoot.data.right_hand = GameObj.right_hand
    ELoot.data.left_hand = GameObj.left_hand

    ELoot.change_stance(100) if ELoot.data.settings[:loot_defensive]
    ELoot.msg(type: "debug", text: "ELoot.loot: Defensive Stance") if ELoot.data.settings[:loot_defensive]

    ELoot.msg(type: "debug", text: "ELoot.loot: Begin Skinning") if ELoot.data.settings[:skin_enable]
    Loot.skin if ELoot.data.settings[:skin_enable]

    ELoot.msg(type: "debug", text: "ELoot.loot: Searching")
    Loot.search
    sleep(0.1)

    ELoot.msg(type: "debug", text: "ELoot.loot: Looting the Room")
    Loot.room

    # use coin hand if we have it
    ELoot.use_coin_hand

    Inventory.return_hands
  end

  def self.read_note
    result = 0
    note = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /\b(?:note|scrip|chit)\b/ }
    return unless note

    line = ELoot.get_res("read ##{note.id}", /Hold in right hand to use/)

    if line =~ /has a value of (.*?) silver and reads/
      result = $1.delete(",").to_i
    end

    return result
  end

  def self.silver_check
    wealth_pattern = /^You have (no|[,\d]+|but one) silver with you/
    wealth = ELoot.get_lines("wealth quiet", wealth_pattern).join(" ")
    coins = 0
    if wealth.gsub('but one', '1') =~ wealth_pattern
      coins = $1.gsub(',', '').to_i
    end
    return coins
  end

  def self.silver_deposit(deposit_bag = false)
    if ELoot.data.coin_hand && deposit_bag && ELoot.data.settings[:sell_deposit_coinhand]
      # Remove the coin hand from a container if needed
      unless ELoot.data.coin_container.nil?
        Inventory.free_hand
        Inventory.open_single_container(ELoot.data.coin_container)
        Inventory.drag(ELoot.data.coin_hand)
      end

      lines = ELoot.get_lines("inspect ##{ELoot.data.coin_hand.id}", /You carefully inspect/)
      if lines.any? { |l| l =~ /can store a approximately (\d+) silver coins/ } # these are the coin bags
        ELoot.data.coin_bag = true
        coin_lines = ELoot.get_lines("look in ##{ELoot.data.coin_hand.id}", /inside the|There is nothing/i)
        if coin_lines.any? { |c| c =~ /you see approximately (\d+) silver coins/ }
          coins = Regexp.last_match(1).to_i
          ELoot.get_res("get #{coins} silver from ##{ELoot.data.coin_hand.id}", /You reach into/)
          ELoot.wait_rt
        end
      else
        ELoot.data.coin_bag = false
        fput "open ##{ELoot.data.coin_hand.id}"
        ELoot.wait_rt
      end

      # Return it to the container if needed
      unless ELoot.data.coin_container.nil?
        Inventory.store_item(ELoot.data.coin_container, ELoot.data.coin_hand)
      end
    end

    current_silvers = ELoot.silver_check
    keep_silvers = [ELoot.data.settings[:sell_keep_silver].to_i, 0].max
    share_silvers = current_silvers - keep_silvers

    # Share silvers
    if ELoot.data.settings[:sell_share_silvers] && share_silvers.positive?
      fput("share #{share_silvers}")
    end

    # use coin hand if we have it and don't want to deposit the coins
    ELoot.use_coin_hand unless ELoot.data.settings[:sell_deposit_coinhand]

    # Any notes on us?
    note = ELoot.data.sacks["default"].contents.find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }

    # Head over to the bank if something to do.
    return unless (ELoot.silver_check != keep_silvers) || (note && !ELoot.f2p?)

    ELoot.go2('bank')

    unless ELoot.f2p?
      dothistimeout "deposit all", 2, ELoot.data.deposit_regex
    else
      # F2P accounts have to be handled a little different due to bank capacity
      loop do
        lines = ELoot.get_lines("bank account", /You currently have an account/)

        if lines.find { |line| line.match(/in the amount of (?<silver>[\d,]+) silver/) }
          silver_balance = Regexp.last_match[:silver].gsub(',', '').to_i
        end

        if lines.find { |line| line.match(/a maximum of (?<silver>[\d,]+) silvers/) }
          silver_max = Regexp.last_match[:silver].gsub(',', '').to_i
        end

        # Make sure we have the correct current silvers
        current_silvers = ELoot.silver_check

        # Do we have enough to deposit without taking out a note?
        if (silver_balance + current_silvers) < silver_max
          result = dothistimeout("deposit #{current_silvers}", 2, Regexp.union(ELoot.data.deposit_regex, /you don't have access/i)) if current_silvers.positive?
          if result =~ /you don't have access/i
            ELoot.msg("info", " You don't have a bank in this town. Exiting...")
            exit
          end
          break
        else
          deposit_size = silver_max - silver_balance
          dothistimeout("deposit #{deposit_size}", 2, ELoot.data.deposit_regex)

          # Do we have enough to pull a full note and still have 10,000 buffer to deposit?
          current_silvers = ELoot.silver_check

          note_size = current_silvers >= 10000 ? silver_max : (silver_max - (10000 - current_silvers))
          dothistimeout("withdraw #{note_size}", 2, /The teller/)
          note = [GameObj.right_hand, GameObj.left_hand].find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }
          Inventory.single_drag(note)
        end
      end
    end

    # Finally withdraw any keeper silvers and stow note if given
    dothistimeout("withdraw #{keep_silvers}", 2, ELoot.data.withdraw_regex) if keep_silvers.positive?
    note = [GameObj.right_hand, GameObj.left_hand].find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }
    Inventory.single_drag(note) if note
    ELoot.wait_rt
  end

  def self.silver_withdraw(amount)
    if ELoot.silver_check >= amount && percentencumbrance < 20
      return
    end

    ELoot.go2('bank')

    ELoot.silver_deposit

    fput("withdraw #{amount} silvers")

    if ELoot.silver_check < amount
      ELoot.msg(type: "info", text: " Not enough silver in current area's bank.")
      exit
    end
  end

  def self.unlootable(item)
    return unless ELoot.data.settings[:log_unlootables]
    return unless item.type.nil?

    ELoot.msg(type: "info", text: " #{item.name} was not lootable, adding to list.")
    ELoot.data.settings[:unlootable].push(item.name)
    ELoot.save_profile()
  end

  def self.save_horde_profile
    # Saves profile for gems/reagents inventory syncs
    ELoot.data.inv_save = true

    if ELoot.data.horde_type == 'gem'
      ELoot.data.gem_inventory = ELoot.data.inventory
    elsif ELoot.data.horde_type == 'reagent'
      ELoot.data.alchemy_inventory = ELoot.data.inventory
    end

    before_dying {
      if ELoot.data.inv_save
        ELoot.msg(type: "default", text: " Saving profile to sync gem/reagent inventories.")
        ELoot.data.settings[:gem_horde_inv] = ELoot.data.gem_inventory
        ELoot.data.settings[:reagent_horde_inv] = ELoot.data.alchemy_inventory
        ELoot.save_profile
        ELoot.data.inv_save = false
      end
    }
  end

  def self.wait_for_disk
    return unless ELoot.data.disk || !ELoot.data.settings[:use_disk]

    if ELoot.data.disk.status =~ /gone/ || !GameObj.loot.find { |l| l.name =~ /#{Char.name} #{ELoot.data.disk_nouns_regex}\b/ }
      ELoot.msg(type: "info", text: " Waiting for your disk to arrive")
      50.times do
        break if (ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} #{ELoot.data.disk_nouns_regex}\b/ })

        sleep(0.1)
      end
    end

    return unless ELoot.data.disk && ELoot.data.disk.status !~ /gone/ && ELoot.data.disk.contents.nil?

    Inventory.open_single_container(ELoot.data.disk)
  end

  def self.wait_rt
    sleep 0.2
    waitcastrt?
    waitrt?
    sleep 0.2
  end

  # Global data used by ELoot
  class Data
    attr_accessor :disk, :disk_full, :sacks_full, :ready_list, :ready_method, :sacks, :settings, :skinners, :skinsheath, :silent_open, :checked_bags,
                  :close_regex, :look_regex, :sacks_closed, :all_loot_categories, :regex_gold_rings, :right_hand, :left_hand, :skin_edged, :skin_blunt,
                  :coin_hand, :coin_container, :silver_breakdown, :get_regex, :put_regex, :alchemy_mode, :sell_containers, :local_gemshop, :local_furrier, :log_unlootables, :exclude,
                  :charm, :gauntlet, :coin_bag, :reagent_horde_inv, :account_type, :gem_regex, :locker, :container_settings, :everything_list, :everything,
                  :only_list, :only, :inventory, :gem_inventory, :alchemy_inventory, :horde_type, :cache, :locker_city, :use_hording, :stash,
                  :items_to_horde, :horde_deposit, :inv_save, :deposit_regex, :withdraw_regex, :disk_nouns_regex, :sigil_determination_on_fail, :start_room, :last_called

    def initialize(settings)
      @settings = settings
      @start_room = nil
      @last_called = {}

      # inventory type
      @sacks = {}
      @sacks_closed = []
      @sacks_full = []
      @checked_bags = []
      @sell_containers = []

      @coin_hand = nil
      @coin_container = nil

      @charm = nil
      @gauntlet = nil
      @coin_bag = nil

      @disk = nil
      @disk_full = false

      @ready_list = {}
      @ready_method = {}

      @skinners = {}
      @skinsheath = nil
      @skin_edged = nil
      @skin_blunt = nil

      @right_hand = ""
      @left_hand = ""

      # Hording/bounty type
      @horde_type = nil
      @horde_deposit = nil
      @items_to_horde = nil
      @container_settings = nil
      @everything_list = nil
      @everything = nil
      @only_list = nil
      @only = nil
      @inventory = nil
      @gem_inventory = nil
      @alchemy_inventory = nil
      @locker_city = nil
      @locker = nil
      @cache = nil
      @use_hording = nil
      @stash = nil

      @alchemy_mode = false

      @local_gemshop = nil
      @local_furrier = nil

      # Misc
      @account_type = nil
      @silver_breakdown = {}
      @inv_save = true

      $sell_ignore = []

      default_crumbly = [
        # Kraken Fall
        "gnarled dark wooden crook",
        "twisted obsidian dagger",
        "immense fel-hafted handaxe",
        "gold-tipped heavy spear",
        "notched bone handaxe",
        "rough pinewood crook",
        "swirling sanguine orb",
        "battered antique faewood crate",
        "copper-traced dark steel hatchet",
        "huge black alloy greatsword",
        "rough leather quiver",

        # Atoll
        "twisted soot black runestaff",
        "corroded bronze Hammer of Kai",
        "dried seaweed-wrapped longbow",
        "bronze-bound driftwood greatshield",
        "coral-hilted heavy ball and chain",
        "coral-hilted sharply tapered longsword",
      ]

      @settings[:crumbly] ||= []
      @settings[:crumbly] += default_crumbly
      @settings[:crumbly].uniq!

      @settings[:track_full_sacks] = true if @settings[:track_full_sacks].nil?

      @settings[:unlootable] ||= []
      @settings[:unlootable]&.uniq!

      @settings[:auto_close] ||= []
      @settings[:auto_close]&.uniq!

      @settings[:unskinnable]&.uniq!

      if @settings[:use_standard_tipping].nil?
        @settings[:use_standard_tipping] = true
      end

      @settings[:sell_container] ||= ["default", "overflow", "box", "collectible", "forageable", "gem", "herb", "lockpick", "potion", "reagent", "scroll", "skin", "treasure", "trinket", "wand"]

      @exclude = @settings[:loot_exclude].map { |r| r.is_a?(String) ? Regexp.new(r) : r }

      @gem_regex = /^The gem dealer in (?<town>[^,]+), [^,]+, has received orders from multiple customers requesting (?:an?|some) (?<gem>[^.]+)\.  You have been tasked to retrieve (?<number>\d+) (?:more\s+)?of them\.  You can SELL them to the gem dealer as you find them\.$/

      @deposit_regex = Regexp.union(
        /You deposit (?<silver>[\d,]+) silvers? into your account/,
        /That's a total of (?<silver>[\d,]+) silver/,
        /That's (?<silver>[\d,]+) silver|silvers? to your account/,
        /You deposit your note worth (?<silver>[\d,]+) into your account/,
        /You hand your notes to the teller, who glances over each one and scribbles the amounts in a book.  She says, "They add up to (?<silver>[\d,]+) (?:silver|silvers)/,
        /You have no coins to deposit/
      )

      @withdraw_regex = Regexp.union(
        /I have a (?<debt>bill) of (?<silver>[\d,]+) silvers? (?:presented by your creditors|that I suggest you pay immediately)/,
        /Very well, a withdrawal of (?<silver>[\d,]+) silver/,
        /teller scribbles the transaction into a book and hands you (?<silver>[\d,]+) silver/,
        /teller carefully records the transaction, (?:and then )?hands you (?<silver>[\d,]+) silver/,
      )

      @get_regex = Regexp.union(
        /^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly |slowly )?(?:remove|draw|grab|reach|slip|tuck|retrieve|already have|unsheathe|detach|swap|sling)/,
        /^Get what\?$/,
        /^Why don't you leave some for others\?$/,
        /^You need a free hand/,
        /^You already have that/,
        /Reaching over your shoulder/,
        /^As you draw/,
        /^Ribbons of.*?light/,
        /^You are already holding/
      )

      @put_regex = Regexp.union(
        /You/i,
        /Spreading your wings/,
        /I could not find what you were referring to/,
        /Draping the/,
        /Heedful of your surroundings/,
        /won't fit/,
        /crumbles? and decays? away/,
        /crumbles? into a pile of dust/,
        /That is not yours/,
        /Hey, that belongs to/,
        /Get what/,
        /Reaching over your shoulder/,
        /An ethereal.*?light swirls/
      )

      @look_regex = Regexp.union(
        /Peering into the <a exist=.*? noun="toolkit">/i,
        /That is closed/i,
        /is shut too tightly to see its contents/i,
        /In the(.*?)you see/i,
        /In the(.*?):/i,
        /There is nothing/i,
        /You glance/i,
        /^Attached to a.*keyring/i,
        /.*?[.*?]:/i,
        /The <a exist="\d+" noun="\w+">[^<]+<\/a> has (?:an? <a exist="\d+" noun="\w+">[^<]+<\/a> |nothing )?in.*scabbard and (?:an? <a exist="\d+" noun="\w+">[^<]+<\/a> |nothing )?in.*scabbard\./i,
        /^I could not find what you were referring to\./i,
        /Hidden within the depths of a cloakwing moth greatcloak/,
        /<exposeContainer|<dialogData|<container/i,
        /stuffed with a variety of shredded up paper and cloth/,
        /As much as you'd like to open it, its not closed\./,
        /Looking at the/i,
        /The <a exist=".*" noun="swordbelt">dark leather swordbelt/i
      )

      @silent_open = Regexp.union(
        /You throw back/i,
        /You open/i,
        /Oh no! It's already/i,
        /You pick at the knot/i,
        /already open/i,
        /is open already/i,
        /You unfasten/i,
        /You glance around suspiciously/i,
        /^What were you referring to\?/i,
        /^I could not find what you were referring to\./i,
        /You pull the long strips of leather/i,
        /With a flick of your wrist/i,
        /Sliding the lever on the side/i,
        /You rub your hand/i,
        /There doesn't seem to be any way/i,
        /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i,
        /crumbles? and decays? away/,
        /crumbles? into a pile of dust/,
        /Myriad spectral moths pull a cloakwing/,
        /<exposeContainer|<container/i,
        /You undo each of the/,
        /stuffed with a variety of shredded up paper and cloth/
      )

      @close_regex = Regexp.union(
        /You close .*/,
        /(?:That|It) is already closed/,
        /What were you referring to/,
        /seem to be any way to do that/,
        /You tie/,
        /You fasten the/
      )

      # There are a lot of disk nouns so breaking out to a single list to maintain
      @disk_nouns_regex = /\b(?:bassinet|cassone|chest|coffer|coffin|coffret|disk|hamper|saucer|sphere|trunk|tureen)\b/

      @regex_gold_rings = /^(dingy|plain|braided|twisted|intricate|large|thin|wide|polished|scratched|thick|dull|faded|small|flawless|inlaid|dirt\-caked|ornate|exquisite|shiny|bright|narrow) gold ring$|^gold ring$/

      @all_loot_categories = ["alchemy", "armor", "box", "clothing", "collectible", "cursed", "food", "gem", "herb", "jewelry", "junk", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand", "weapon"]
    end
  end

  if defined?(Gtk)
    # Setup is an extension of Gtk::Builder for Gtk setup
    class Setup < Gtk::Builder
      @@categories = {
        loot: {
          loot_types: {
            # :loot_types=>["alchemy", "armor", "box", "clothing", "collectible", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
            default: []
          },
          loot_exclude: {
            default: ["black ora", "urglaes"],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          loot_keep: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          critter_exclude: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          unlootable: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          loot_phase: { default: false },
          use_disk: { default: true },
          loot_defensive: { default: false },
          overflow_container: { default: '' },
          secondary_overflow: { default: '' },
          coin_hand_name: { default: '' },
          charm_name: { default: '' },
          sigil_determination_on_fail: { default: false },
          keep_closed: { default: false },
          track_full_sacks: { default: true },
          favor_left: { default: false },
          log_unlootables: { default: false },

        },
        boxes: {
          use_standard_tipping: { default: true },
          sell_locksmith: { default: false },
          sell_locksmith_pool: { default: true },
          always_check_pool: { default: false },
          display_box_contents: { default: true },
          sell_locksmith_pool_tip: { default: 15 },
          sell_locksmith_pool_tip_percent: { default: true },
          use_incremental_tipping: { default: false },
          base_tip: { default: 200 },
          max_tip: { default: 2000 },
          alpha_rate: { default: 2.5 },
          tipping_test: { default: [] },
        },
        sell: {
          sell_loot_types: {
            # :sell_loot_types=>["alchemy", "armor", "clothing", "gem", "jewelry", "junk", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
            default: []
          },
          sell_container: { default: [] },
          sell_exclude: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          sell_keep_scrolls: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                if Spell[text].num.nil?
                  setting.delete(text)
                else
                  iter = store.append
                  iter[0] = Spell[text].num
                  iter[1] = Spell[text].name
                end
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(Spell[selected.get_value(0)].num)
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)
              next if Spell[text].nil?

              setting.push(Spell[text].num)
              setting.uniq!.sort!
            end
          },
          sell_appraise_types: { default: ["jewelry", "magic", "uncommon", "valuable"] },
          sell_appraise_gemshop: { default: 14_999 },
          sell_appraise_pawnshop: { default: 34_999 },
          appraisal_container: { default: '' },

          sell_collectibles: { default: true },
          sell_gold_rings: { default: false },

          sell_share_silvers: { default: false },
          sell_fwi: { default: false },
          sell_shroud: { default: false },
          sell_aspect: { default: false },
          sell_keep_silver: { default: 0 },
          sell_deposit_coinhand: { default: false },
        },
        skin: {
          skin_enable: { default: false },
          skin_kneel: { default: false },
          skin_604: { default: false },
          skin_resolve: { default: false },
          skin_sheath: { default: '' },
          skin_weapon: { default: '' },
          skin_sheath_blunt: { default: '' },
          skin_weapon_blunt: { default: '' },
          skin_exclude: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          between: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
        },
        horde: {
          gem_horde_turnin: { default: false },
          gem_horde_inv: { default: [] },
          gem_horde: { default: false },
          gem_horde_locker: { default: false },
          gem_everything_list: { default: true },
          gem_only_list: { default: false },
          gem_horde_container: { default: '' },
          gem_horde_containers: { default: ['default', 'gem', 'overflow1', 'overflow2'] },
          gem_locker: { default: '' },
          gem_locker_name: { default: '' },
          gem_everything: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          gem_list: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          reagent_horde_inv: { default: [] },
          alchemy_horde: { default: false },
          alchemy_horde_locker: { default: false },
          alchemy_everything_list: { default: false },
          alchemy_only_list: { default: false },
          alchemy_horde_container: { default: '' },
          alchemy_horde_containers: { default: [] },
          alchemy_locker: { default: '' },
          alchemy_locker_name: { default: '' },
          alchemy_everything: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          alchemy_list: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
        },
        internal: {
          silence: { default: false },
          debug: { default: false },
          unskinnable: { default: [] },
          unlootable: { default: [] },
          crumbly: { default: [] },
          auto_close: { default: [] },
        }
      }

      def self.eloot_ui
        '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkListStore" id="alchemy_everything_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/></columns></object><object class="GtkListStore" id="alchemy_list_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/>
        </columns></object><object class="GtkAdjustment" id="alpha_adjustment"><property name="upper">100</property><property name="step-increment">0.10</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="base_tip_adjustment"><property name="upper">100000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="between_store"><columns><!-- column-name exclusion --><column type="gchararray"/>
        </columns></object><object class="GtkListStore" id="critter_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkListStore" id="gem_everything_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/></columns></object><object class="GtkListStore" id="gem_list_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/></columns></object><object class="GtkListStore" id="loot_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/>
        </columns></object><object class="GtkListStore" id="loot_keep_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkAdjustment" id="max_tip_adjustment"><property name="upper">100000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="sell_appraise_gemshop_adjustment"><property name="upper">1000000</property><property name="step-increment">1</property><property name="page-increment">10</property>
        </object><object class="GtkAdjustment" id="sell_appraise_gemshop_pawnshop"><property name="upper">1000000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="sell_exclude_store"><columns><!-- column-name Exclusion --><column type="gchararray"/></columns></object><object class="GtkListStore" id="sell_keep_scrolls_store"><columns><!-- column-name Spell --><column type="gint"/><!-- column-name Spell1 --><column type="gchararray"/>
        </columns></object><object class="GtkAdjustment" id="sell_keep_silver_adjustment"><property name="upper">999999</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="sell_locksmith_pool_tip_adjustment"><property name="upper">999999</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="skin_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/>
        </columns></object><object class="GtkListStore" id="unlootable_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkWindow" id="main"><property name="width-request">760</property><property name="height-request">650</property><property name="can-focus">False</property><property name="title" translatable="yes">Eloot Setup</property><property name="modal">True</property><property name="default-height">700</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=6 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="loot_types:alchemy"><property name="label" translatable="yes">Alchemy</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:armor"><property name="label" translatable="yes">Armor</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:box"><property name="label" translatable="yes">Box</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:clothing"><property name="label" translatable="yes">Clothing</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:collectible"><property name="label" translatable="yes">Collectible</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:cursed"><property name="label" translatable="yes">Cursed</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:food"><property name="label" translatable="yes">Food</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:herb"><property name="label" translatable="yes">Herb</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:junk"><property name="label" translatable="yes">Junk</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:weapon"><property name="label" translatable="yes">Weapon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">5</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:coins"><property name="label" translatable="yes">Coins (ground)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:breakable"><property name="label" translatable="yes">Breakable(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Porous chunks of rock released as part of The Hive 12/17/2023</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Loot Types</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="loot_defensive"><property name="label" translatable="yes">Loot in defensive (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Swap to defensive before looting if there are hostile enemies.</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_phase"><property name="label" translatable="yes">Phase boxes(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Phases boxes if you are able to.</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_disk"><property name="label" translatable="yes">Disking(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Utilizes your disk for boxes if checked</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="label" translatable="yes">Coin Bag/Hand Name:</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="coin_hand_name"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">15</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">1</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="track_full_sacks"><property name="label" translatable="yes">Track Full Containers(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Eloot will try to keep track of full sacks (turn off if not selling with eloot)</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="favor_left"><property name="label" translatable="yes">Favor Left(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will favor left hand to stow for looting (defaults to right)</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="keep_closed"><property name="label" translatable="yes">Keep sacks shut(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Will keep sacks closed (Performance hit!)</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="log_unlootables"><property name="label" translatable="yes">Log unlootable items(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">This will log items you can not loot into the Unlootable section (Loot Grid) otherwise it will ignore that section. </property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="label" translatable="yes">Fossil Charm Name:</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="charm_name"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">15</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">Originally from Mushroom Spore Giftbox 07/29/2023</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">3</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="sigil_determination_on_fail"><property name="label" translatable="yes">Sigil of Determination(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Will use Sigil of Determination if you fail to loot because you are too injured.</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Other Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=1 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Primary Overflow:</property><property name="xalign">0</property><property name="yalign">0</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="overflow_container"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Enter the name of your overflow container.  This container will be used when the targeted STOW container is full.</property><property name="margin-start">5</property><property name="margin-end">15</property><property name="margin-bottom">5</property><property name="hexpand">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Secondary Overflow:</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkEntry" id="secondary_overflow"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Enter the name of your secondary overflow container.  This container will be used when the primary overflow container is full.</property><property name="margin-start">5</property><property name="margin-end">15</property><property name="margin-bottom">10</property><property name="hexpand">True</property><property name="vexpand">False</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Overflow Containers</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property>
        </packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Looting</property></object><packing><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="loot_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="loot_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="loot_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. urglaes fang)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="loot_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">loot_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time. Regular expressions are supported.

              Enter "(?:aquamarine|gold) wand" and "gold ring" as separate entries.</property><property name="label" translatable="yes">Never Loot(?)</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="loot_keep_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="loot_keep_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="loot_keep_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter addition (e.g. uncut diamond)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="loot_keep"><property name="visible">True</property><property name="can-focus">True</property><property name="model">loot_keep_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Always loot these items. They should be entered one line at a time. Regular expressions are supported.

              Enter "(?:aquamarine|gold) wand" and "gold ring" as separate entries.</property><property name="label" translatable="yes">Always Loot(?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="critter_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="critter_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="critter_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. giant rat)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="critter_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">critter_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time. Regular expressions are supported.

              Enter "(?:big ugly|mongrel) kobold" and "Vvrael destroyer" as separate entries.</property><property name="label" translatable="yes">Creature Exclusions (?)</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="unlootable_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="unlootable_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="unlootable_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter unlootable item</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="unlootable"><property name="visible">True</property><property name="can-focus">True</property><property name="model">unlootable_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Unlootable items should be entered one line at a time. Regular expressions are supported.
              </property><property name="label" translatable="yes">Unlootable(?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child></object></child></object><packing><property name="position">1</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Looting Grid</property></object><packing><property name="position">1</property><property name="tab-fill">False</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="border-width">10</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_locksmith_pool"><property name="label" translatable="yes">Use locksmith pool</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_locksmith"><property name="label" translatable="yes">Use town locksmith</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="display_box_contents"><property name="label" translatable="yes">Display box contents</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="always_check_pool"><property name="label" translatable="yes">Always check pool (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">If checked eloot will always check the pool for retruned boxes.
              Default behavior is to only check if there is a box to drop off.</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Locksmithing</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="between_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="between_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="between_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Scripts between the pool and selling</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="between"><property name="visible">True</property><property name="can-focus">True</property><property name="model">between_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Enter the name of the script with any options.
          Ex: &lt;script name&gt; &lt;option1 option2 option3&gt;

        The script(s) will run after finishing the locksmith pool.
        This will allow finer control of inventory storage for
            things like gem singing, loresing or anything else you might want.</property><property name="label" translatable="yes">In-between Scripts (?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="height">2</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=1 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-top">10</property><property name="label" translatable="yes">Locksmith Pool Tip</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="sell_locksmith_pool_tip"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-top">10</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_locksmith_pool_tip_adjustment</property><property name="numeric">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_locksmith_pool_tip_percent"><property name="label" translatable="yes">Tip using percentage</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="use_standard_tipping"><property name="label" translatable="yes">Use Standard Tipping</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Standard Pool Tipping</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=1 n-rows=7 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="label" translatable="yes">Base Tip</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="base_tip"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="adjustment">base_tip_adjustment</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="label" translatable="yes">Maximum Tip</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkSpinButton" id="max_tip"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="adjustment">max_tip_adjustment</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="label" translatable="yes"> (alpha)</property></object><packing><property name="left-attach">0</property><property name="top-attach">5</property>
        </packing></child><child><object class="GtkSpinButton" id="alpha_rate"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">20</property><property name="adjustment">alpha_adjustment</property><property name="digits">1</property></object><packing><property name="left-attach">0</property><property name="top-attach">6</property>
        </packing></child><child><object class="GtkCheckButton" id="use_incremental_tipping"><property name="label" translatable="yes">Use Incremental Tipping</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">100</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><!-- n-columns=1 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-end">70</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="valign">start</property><property name="margin-top">20</property><property name="label" translatable="yes">As your box count in the pool climbs, so does your tip.
        This pushes your box higher in the queue resulting in a faster return.

        The formula being used:
             Tip = BaseTip+( Boxes in Pool / 100 )^ (MaxTipBaseTip)

        base_tip  = minimum tip to start
        max_tip   = maximum tip
         (alpha) = determines how fast tip rises </property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="tipping_test"><property name="label" translatable="yes">Test Formula Values</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Prints a sample distribution to the screen.
        </property><property name="halign">start</property><property name="margin-top">25</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><placeholder/></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Incremental Tipping</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property>
        </packing></child></object></child></object></child></object><packing><property name="position">2</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Boxes</property></object><packing><property name="position">2</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=6 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_loot_types:alchemy"><property name="label" translatable="yes">Alchemy</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:armor"><property name="label" translatable="yes">Armor</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:box"><property name="label" translatable="yes">Box(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Sells empty gold, mithril, and silver boxes to the pawnshop</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:clothing"><property name="label" translatable="yes">Clothing</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:cursed"><property name="label" translatable="yes">Cursed</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:food"><property name="label" translatable="yes">Food (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Food will be thrown away or dropped since it can\'t be sold</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:herb"><property name="label" translatable="yes">Herb(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Herbs will be thrown away or dropped since they can\'t be sold</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:junk"><property name="label" translatable="yes">Junk(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Junk will be thrown away or dropped since they can\'t be sold</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:scarab"><property name="label" translatable="yes">Scarab</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:weapon"><property name="label" translatable="yes">Weapon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Warning - Mark anything you don\'t want accidentally sold - Eloot is not perfect!</property><attributes><attribute name="foreground" value="#ffff00000000"/>
        </attributes></object><packing><property name="left-attach">1</property><property name="top-attach">4</property><property name="width">4</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:breakable"><property name="label" translatable="yes">Breakable(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Porous chunks of rock released as part of The Hive 12/17/2023
        They need to be broken so the contents can be sold</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Sell Types</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=5 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_container:default"><property name="label" translatable="yes">Default</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:overflow"><property name="label" translatable="yes">Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:box"><property name="label" translatable="yes">Box</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:collectible"><property name="label" translatable="yes">Collectible</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:forageable"><property name="label" translatable="yes">Forageable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:herb"><property name="label" translatable="yes">Herb</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:potion"><property name="label" translatable="yes">Potion</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:treasure"><property name="label" translatable="yes">Treasure</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:trinket"><property name="label" translatable="yes">Trinket</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Only sell from these STOW containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">135</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=5 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="sell_appraise_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-top">10</property><property name="label" translatable="yes">Gemshop Limit</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property>
        </packing></child><child><object class="GtkSpinButton" id="sell_appraise_gemshop"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_appraise_gemshop_adjustment</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Pawnshop Limit</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property><property name="width">2</property></packing></child><child><object class="GtkSpinButton" id="sell_appraise_pawnshop"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_appraise_gemshop_pawnshop</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">75</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="label" translatable="yes">Container to store items exceeding appraisal limit</property></object><packing><property name="left-attach">4</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="appraisal_container"><property name="visible">True</property><property name="can-focus">True</property><property name="valign">start</property><property name="margin-start">75</property><property name="margin-top">5</property><property name="placeholder-text" translatable="yes">If blank will return items to original container</property></object><packing><property name="left-attach">4</property><property name="top-attach">1</property><property name="height">2</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Appraisals</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property>
        </packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">135</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="sell_collectibles"><property name="label" translatable="yes">Deposit Collectibles</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_fwi"><property name="label" translatable="yes">Sell in FWI</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_gold_rings"><property name="label" translatable="yes">Gold Rings to Chrono.</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_shroud"><property name="label" translatable="yes">Use Shroud (1212) &amp; Glamour (1205)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Setting this will ensure you keep a certain number of silvers on you after selling. This is useful for places like Icemule Trace that have a gate fee.</property><property name="halign">start</property><property name="margin-start">30</property><property name="label" translatable="yes">Keep Silvers (?)</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_aspect"><property name="label" translatable="yes">Use Assume Aspect - Lion (650)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_deposit_coinhand"><property name="label" translatable="yes">Deposit coinhand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_share_silvers"><property name="label" translatable="yes">Share silvers</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkSpinButton" id="sell_keep_silver"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-top">5</property><property name="margin-bottom">30</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_keep_silver_adjustment</property><property name="numeric">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property><property name="height">2</property>
        </packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Other Settings</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">3</property>
        </packing></child></object></child></object></child></object><packing><property name="position">3</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Selling</property></object><packing><property name="position">3</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="sell_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="sell_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="sell_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. uncut diamond)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="sell_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">sell_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time. Regular expressions are supported.

              Enter "(?:aquamarine|gold) wand" and "gold ring" as separate entries.</property><property name="label" translatable="yes">Exclusions (?)</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="sell_keep_scrolls_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="sell_keep_scrolls_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="sell_keep_scrolls_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. 215)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="sell_keep_scrolls"><property name="height-request">-1</property><property name="visible">True</property><property name="can-focus">True</property><property name="model">sell_keep_scrolls_store</property><property name="headers-visible">False</property><property name="search-column">0</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="title" translatable="yes">Spell Number</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="title" translatable="yes">Spell Name</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">1</attribute></attributes></child></object></child></object></child></object>
        </child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Add spells to this list to prevent selling scrolls that have spells matching.</property><property name="label" translatable="yes">Keep Scrolls</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child></object></child></object><packing><property name="position">4</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Selling Grid</property>
        </object><packing><property name="position">4</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="border-width">10</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_enable"><property name="label" translatable="yes">Enable skinning</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="skin_kneel"><property name="label" translatable="yes">Kneel to skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_resolve"><property name="label" translatable="yes">Use Sigil of Resolve</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_604"><property name="label" translatable="yes">Use 604</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><!-- n-columns=2 n-rows=8 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="border-width">5</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="label" translatable="yes">Skin Sheath (blunt)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_sheath_blunt"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="label" translatable="yes">Skin Weapon (blunt)</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_weapon_blunt"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">20</property><property name="margin-end">10</property><property name="margin-bottom">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Blunt Skinning</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="border-width">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="label" translatable="yes">Skin Sheath (edged)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_sheath"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="label" translatable="yes">Skin Weapon (edged)</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_weapon"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">20</property><property name="margin-end">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Edged Skinning</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="skin_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="skin_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="skin_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter skinning exclusion (e.g. giant rat)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="skin_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">skin_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Exclusions should be entered one line at a time. Regular expressions are supported.

              Enter "(?:big ugly|mongrel) kobold" and "Vvrael destroyer" as separate entries.</property><property name="label" translatable="yes">Skinning Exclusions (?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="height">8</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child><child><placeholder/>
        </child></object></child></object></child></object><packing><property name="position">5</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Skinning</property></object><packing><property name="position">5</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="gem_horde"><property name="label" translatable="yes">Horde Gems (defaults to all gems unless modified below)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_locker"><property name="label" translatable="yes">Horde gems in a locker?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_horde_container"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">14</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="width-chars">20</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_turnin"><property name="label" translatable="yes">Use horded gems for bounties</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkComboBoxText" id="gem_locker"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">22</property><property name="margin-bottom">17</property><property name="has-entry">True</property><child internal-child="entry"><object class="GtkEntry" id="gem_locker_name"><property name="can-focus">True</property><property name="placeholder-text" translatable="yes">Select Locker Location</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property><property name="height">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-top">13</property><property name="label" translatable="yes">Name of strorage container (even for lockers)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="gem_horde_containers:default"><property name="label" translatable="yes">Default</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_containers:overflow1"><property name="label" translatable="yes">First Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_containers:overflow2"><property name="label" translatable="yes">Second Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_containers:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Only Horde Gems from these Containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="gem_everything_list"><property name="label" translatable="yes">Horde all gems except those excluded below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_only_list"><property name="label" translatable="yes">ONLY horde gems listed below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="gem_everything_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="gem_everything_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_everything_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Gems to Exclude</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="gem_everything"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">gem_everything_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="gem_list_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="gem_list_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_list_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Gems to Include</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="gem_list"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">gem_list_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property></packing></child></object></child></object></child></object><packing><property name="position">6</property>
        </packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Gem Hording</property></object><packing><property name="position">6</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="alchemy_horde_locker"><property name="label" translatable="yes">Horde alchemy  in a locker?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_horde_container"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="width-chars">20</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde"><property name="label" translatable="yes">Horde Alchemy Ingredients (defaults to all unless modified below)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkComboBoxText" id="alchemy_locker"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">22</property><property name="has-entry">True</property><child internal-child="entry"><object class="GtkEntry" id="alchemy_locker_name"><property name="can-focus">True</property><property name="placeholder-text" translatable="yes">Select Locker Location</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="label" translatable="yes">Name of strorage container (even for lockers)</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="alchemy_horde_containers:default"><property name="label" translatable="yes">Default</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_containers:overflow1"><property name="label" translatable="yes">First Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_containers:overflow2"><property name="label" translatable="yes">Second Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_containers:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Only Horde Alchemy Ingredients from these Containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="alchemy_everything_list"><property name="label" translatable="yes">Horde all alchemy ingredients except those excluded below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_only_list"><property name="label" translatable="yes">ONLY horde alchemy ingredients listed below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="alchemy_everything_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-left">5</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="alchemy_everything_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-right">5</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_everything_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Ingredients to Exclude</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="alchemy_everything"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">alchemy_everything_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="alchemy_list_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-left">5</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="alchemy_list_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-right">5</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_list_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Ingredients to Include</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="alchemy_list"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">alchemy_list_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property></packing></child></object></child></object></child></object><packing><property name="position">7</property>
        </packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Alchemy Hording</property></object><packing><property name="position">7</property><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Your changes are saved automatically.</property><attributes><attribute name="style" value="italic"/>
        </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">15</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
        </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
      end

      def self.get_category(key)
        @@categories.each { |category, data| return category unless data[key].nil? }
        nil
      end

      def self.get_setting(key)
        cat = Setup.get_category(key)
        return nil if cat.nil?

        @@categories[cat].each { |setting, data| return data if setting == key }
        nil
      end

      def initialize(settings)
        super()

        @settings = settings
        @standard_tipping = nil
        @incremental_tipping = nil
        @gem_only = nil
        @gem_everything = nil
        @alchemy_only = nil
        @alchemy_everything = nil
        @gem_locker_drop = nil
        @alchemy_locker_drop = nil

        version = ELoot.get_script_version

        # set default values if they don't exist
        @@categories.each do |_, data|
          data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
        end

        # remove settings that doesn't exist
        @settings.delete_if { |key, _| next Setup.get_category(key).nil? }

        # only sorcerers can phase
        @settings[:loot_phase] = false unless Stats.prof == 'Sorcerer'

        # 604 support
        @settings[:skin_604] = false unless Spell[604].known?

        # GoS only for Sigil of Resolve
        @settings[:skin_resolve] = false unless Society.status == 'Guardians of Sunfist' && Society.rank >= 4

        # GoS only for Sigil of Determination
        @settings[:sigil_determination_on_fail] = false unless Society.status == 'Guardians of Sunfist' && Society.rank >= 16

        # use a GTK Builder to setup all the basics of the window then expand on that base
        return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

        Gtk.queue do
          # add_from_file("#{$data_dir}eloot.ui")

          add_from_string(Setup.eloot_ui)
          load_settings

          self['main'].keep_above = true
          self['main'].set_title "ELoot Setup v#{version}"

          # connect signals after settings are loaded to a bunch of handlers don't trigger
          connect_signals { |handler| method(handler) }
        end
      end

      # This is connected to automatically during load_settings and syncs data back to CharSettings.
      def on_update(obj)
        Gtk.queue do
          key = obj.builder_name.to_sym
          setting = Setup.get_setting(key)
          return if setting.nil?

          if obj.class == Gtk::CheckButton
            @settings[key] = obj.active?

            if key == :use_standard_tipping && obj.active?
              @incremental_tipping.active = false
              @settings[:use_incremental_tipping] = false
            end

            if key == :use_incremental_tipping && obj.active?
              @standard_tipping.active = false
              @settings[:use_standard_tipping] = false
            end

            if key == :gem_everything_list && obj.active?
              @gem_only.active = false
              @settings[:gem_only_list] = false
            end

            if key == :gem_only_list && obj.active?
              @gem_everything.active = false
              @settings[:gem_everything_list] = false
            end

            if key == :alchemy_everything_list && obj.active?
              @alchemy_only.active = false
              @settings[:alchemy_only_list] = false
            end

            if key == :alchemy_only_list && obj.active?
              @alchemy_everything.active = false
              @settings[:alchemy_everything_list] = false
            end

            if key == :gem_horde_locker
              @gem_locker_drop.set_sensitive(false) if !obj.active?
              @gem_locker_drop.set_sensitive(true) if obj.active?
            end

            if key == :alchemy_horde_locker
              @alchemy_locker_drop.set_sensitive(false) if !obj.active?
              @alchemy_locker_drop.set_sensitive(true) if obj.active?
            end

          elsif obj.class == Gtk::Entry
            @settings[key] = obj.text.strip
          elsif obj.class == Gtk::SpinButton
            obj.signal_connect("changed") do
              @settings[key] = obj.value
              obj.update
            end
          end
        end
      end

      def on_close_clicked
        ELoot.save_profile()
        self['main'].destroy
      end

      def on_destroy
        Gtk.queue { @running = false }
      end

      def on_locker_load(item)
        public_location = []
        public = Map.list.find_all { |room| room.tags.any?(/publiclockers/) }

        public.each { |room|
          if room.tags.any?(/publiclockers/)
            public_location << room.location.gsub(/the town of /, '')
          end
        }

        # public_location.uniq!.sort!

        self[item].remove_all

        unless UserVars.mapdb_fwi_trinket
          public_location.delete_if { |place|
            place == 'Mist Harbor'
          }
        end

        self[item].append_text('')

        public_location.compact!  # Remove nil values
        public_location.uniq!     # Remove duplicates
        public_location.sort!     # Sort the array

        public_location.each { |place| self[item].append_text(place) }

        house_location = []
        houses = Map.list.find_all { |room| room.tags.any?(/meta:che:/) && room.tags.any?(/locker/) }

        houses.each { |room|
          result = Regexp.last_match(1) if room.tags.any? { |line| line =~ /meta:che:(.*?)\z/i }
          house_location << result if result
        }

        house_location.compact!  # Remove nil values
        house_location.uniq!     # Remove duplicates
        house_location.sort!     # Sort the array

        house_location.each { |place| self[item].append_text(place) }
      end

      # iterate all objects and for any that match a setting name directly we set the default
      def load_settings
        Gtk.queue do
          # load up the generic settings which are just matching by name of the widget
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)

            key = obj.builder_name.to_sym
            next if (setting = Setup.get_setting(key)).nil?

            # set the default value
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("skin_resolve")) && !Spell[9704].known?
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("sigil_determination_on_fail")) && !Spell[9716].known?
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("skin_604")) && !Spell[604].known?
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("sell_shroud")) && (!Spell[1205].known? && !Spell[1212].known?)
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("sell_aspect")) && !Spell[650].known?
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("gem_locker")) && !@settings[:gem_horde_locker]
            obj.set_sensitive(false) if (obj.builder_name.to_s.eql?("alchemy_locker")) && !@settings[:alchemy_horde_locker]

            if obj.class == Gtk::CheckButton
              @gem_everything = obj if key == :gem_everything_list
              @gem_only = obj if key == :gem_only_list

              @alchemy_everything = obj if key == :alchemy_everything_list
              @alchemy_only = obj if key == :alchemy_only_list

              @standard_tipping = obj if key == :use_standard_tipping
              @incremental_tipping = obj if key == :use_incremental_tipping

              obj.active = @settings[key]
              obj.signal_connect('toggled') { on_update(obj) }
            elsif obj.class == Gtk::Button
              if key == :tipping_test
                self[key].signal_connect("clicked") do
                  rows = []
                  rows << ['Box No', 'Tip', 'Box No', 'Tip']
                  rows << :separator

                  first_half = [1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
                  second_half = (55..100).step(5).to_a

                  max_length = [first_half.length, second_half.length].max

                  # # Add nil entries if the second half is shorter
                  first_half += [nil] * (max_length - first_half.length)
                  second_half += [nil] * (max_length - second_half.length)

                  max_length.times do |i|
                    first_item = "#{first_half[i]}  "
                    second_item = "#{second_half[i]}  "

                    tip_1 = first_item ? Sell.locksmith_tip(first_item, @settings[:base_tip], @settings[:max_tip], @settings[:alpha_rate]) : nil
                    tip_1 = tip_1.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
                    tip_1 = i == 0 ? @settings[:base_tip].round(0).to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse : tip_1

                    tip_2 = !second_item.strip.empty? ? Sell.locksmith_tip(second_item, @settings[:base_tip], @settings[:max_tip], @settings[:alpha_rate]) : nil
                    tip_2 = tip_2.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse

                    rows << [first_item, tip_1, second_item, tip_2]
                  end
                  alpha = @settings[:alpha_rate].round(1)
                  table = Terminal::Table.new :title => "Incremental Tipping (alpha: #{alpha})", :rows => rows
                  (0..3).each do |i|
                    table.align_column(i, :right)
                  end
                  respond
                  respond table
                  respond
                end
              end
            elsif obj.class == Gtk::Entry
              obj.text = @settings[key].strip
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::SpinButton
              obj.value = @settings[key]
              obj.adjustment.value = @settings[key]
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::ComboBoxText
              if key == :gem_locker
                @gem_locker_drop = obj
                on_locker_load('gem_locker')
              end
              if key == :alchemy_locker
                @alchemy_locker_drop = obj
                on_locker_load('alchemy_locker')
              end
            elsif obj.class == Gtk::TreeView
              if (store = self["#{key}_store"]).nil?
                respond "** failed to find store for treeview #{key}"
                next
              elsif setting[:load].nil?
                respond "** no :load defined #{key}"
                next
              end

              setting[:load].call(store, @settings[key])

              # setup the signals
              if (add = self["#{key}_add"]).nil?
                respond "** failed to find add for treeview #{key}"
                next
              elsif (delete = self["#{key}_delete"]).nil?
                respond "** failed to find delete for treeview #{key}"
                next
              elsif (entry = self["#{key}_entry"]).nil?
                respond "** failed to find entry for treeview #{key}"
                next
              end

              add.signal_connect('clicked') do
                if setting[:set].nil?
                  respond "** no :set defined for #{key}"
                  next
                elsif entry.text.empty?
                  next
                end
                setting[:set].call(store, entry.text, @settings[key])
                setting[:load].call(store, @settings[key])
              end

              delete.signal_connect('clicked') do
                if setting[:delete].nil?
                  respond "** no :delete defined for #{key}"
                  next
                elsif (selected = obj.selection.selected).nil?
                  next
                end
                setting[:delete].call(store, selected, @settings[key])
                setting[:load].call(store, @settings[key])
              end
            end
          end

          # checkboxes for array storage with id's <setting>:<value>
          # this is primarily used by the loot types
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)
            next unless obj.builder_name =~ /^([^:]+):(.*)$/i
            next unless obj.class == Gtk::CheckButton

            key = Regexp.last_match(1).to_sym
            value = Regexp.last_match(2).to_s
            next if Setup.get_setting(key).nil?

            obj.active = @settings[key].include?(value)

            # add in hook
            obj.signal_connect('toggled') do
              @settings[key].delete(value)
              if obj.active?
                @settings[key].push(value)
                @settings[key].uniq!.sort!
              end
            end
          end
        end
      end

      def start
        @running = true

        Gtk.queue { self['main'].show_all }

        wait_while { @running }
      end

      def list(cat_to_list: 'all')
        indent_size = 2
        print_array =
          proc do |key, value, indent|
            _respond("#{' ' * indent_size * indent.to_i}#{key}:")
            value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
          end

        print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

        categories = cat_to_list == 'all' ? %w[loot sell skin internal] : [cat_to_list]
        if $frontend == 'stormfront'
          output = "<output class=\"mono\"/>\n"
        else
          output = String.new
        end
        categories.each do |opt|
          _respond("#{output}") if !output.empty?
          _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
          @@categories[opt.to_sym].each do |id, _|
            value = @settings[id]
            value.class == Array ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
          end
        end
        _respond("#{monsterbold_start}= GameObj Types =#{monsterbold_end}\n")
        _respond("#{GameObj.type_data.map { |k, _v| k }.sort.join(', ')}")
        if $frontend == 'stormfront'
          output = "<output class=\"\"/>\n"
          _respond("#{output}")
        end
      end

      def self.update_setting(key, value)
        setting = Setup.get_setting(key)
        ELoot.msg(type: "error", text: "** Setting \"#{key}\" does not exist") if setting.nil?

        action = nil

        if value.to_s =~ /^([+-])(.*)$/
          action = Regexp.last_match(1)
          value = Regexp.last_match(2).strip.downcase
        end

        if value.to_s == 'reset'
          @settings.delete(key)
          ELoot.msg(type: "info", text: " Reset #{key}")
        elsif @settings[key].class == Array
          if value =~ /\d/ && @settings[key][value.to_i]
            @settings[key].delete_at(value.to_i)
          else
            @settings[key].delete(value)
          end

          if action == '-'
            ELoot.msg(type: "info", text: " \"#{value}\" removed from \"#{key}\"")
          else
            @settings[key].push(value)
            ELoot.msg(type: "info", text: " \"#{value}\" added to \"#{key}\"")
          end

          ELoot.msg(type: "info", text: " \"#{key}\" is now \"#{@settings[key].join(', ')}\"")
        else
          if @settings[key].class == FalseClass || @settings[key].class == TrueClass
            value = value =~ /^true|1|yes|on/ ? true : false
          elsif @settings[key].class == Integer
            value = value.to_i
          end

          ELoot.msg(type: "yellow", text: " #{key.capitalize} has been set to #{value}")
          @settings[key] = value
        end
      end
    end
  end

  # Inventory handles inventory
  module Inventory
    def self.check_auto_closer
      return if ELoot.data.settings[:auto_close].empty?

      ELoot.data.sacks.each_value do |bag_obj|
        if ELoot.data.settings[:auto_close].include?(bag_obj.name)
          ELoot.get_lines("open ##{bag_obj.id}", ELoot.data.silent_open)
        end
      end
    end

    def self.clear_hands
      # remember what is in our hands
      ELoot.data.right_hand = GameObj.right_hand
      ELoot.data.left_hand = GameObj.left_hand

      # Empty hands
      Inventory.free_hands(both: true)

      if checkright || checkleft
        ELoot.msg(type: "error", text: "** Something is wrong. Can't empty hands! Report this to Elanthia-Online. A log is helpful. Exiting...", space: true)
        exit
      end
    end

    def self.close_container(bag)
      ELoot.get_res("close ##{bag.id}", ELoot.data.close_regex)
    end

    def self.close_sell_containers
      return unless ELoot.data.settings[:keep_closed]

      ELoot.data.sell_containers.each { |sack|
        # Don't close ready list containers or storage and retrieval of weapons/shields gets messed up
        next if ELoot.data.ready_list.find { |_k, v| v.id == sack.id }

        Inventory.close_container(sack)
      }
    end

    def self.drag(item, to = "hand") # drags things from inventory to a hand
      return if item.nil? || item.empty? || item.name == "Empty"

      if to == "hand"
        to = GameObj.right_hand.id.nil? ? 'right' : 'left'
      end

      line = ELoot.get_res("_drag ##{item.id} #{to}")

      20.times {
        return true if ([GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))
        break if line =~ /Get what|I could not find what you were referring to/

        sleep 0.1
      }

      if line =~ /Get what|I could not find what you were referring to/
        ELoot.msg(type: "info", text: " Can't find #{item.name}. Going to look in all the bags in case it got misplaced.")
        ELoot.data.sacks.keys.each { |bag|
          bag_obj = ELoot.data.sacks[bag]
          next if GameObj.containers.keys.include?(bag_obj.id) && bag_obj.contents.is_a?(Array)

          Inventory.open_single_container(bag_obj)
          Inventory.drag(item, to)
        }
      end

      return false
    end

    def self.wear(item)
      return false if item.nil? || item.empty? || item.name == "Empty"

      line = ELoot.get_res("_drag ##{item.id} wear")

      # Give it time to update and confirm action
      20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)) && (GameObj.inv.map(&:id).compact.include?(item.id))
        break if line =~ /You can't wear that/
        sleep 0.1
      }

      # Still here? Something is wrong, inform the player and exit.
      if [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
        ELoot.msg(type: "warn", text: " Something is wrong. Unable to wear the #{item}. Exiting to avoid losing items.")
        ELoot.msg(type: "warn", text: " Please grab a short log of what just happened and post it to the scripting discord for debugging")
        exit
      end
    end

    def self.free_hand
      unless (GameObj.right_hand.id.nil? and ([Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max < 3)) or (GameObj.left_hand.id.nil? and ([Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max < 3))

        if ELoot.data.settings[:favor_left]
          if GameObj.left_hand.id and ([Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max < 3 or [Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max == 3)
            waitrt?
            Inventory.free_hands(left: true)
          else
            waitrt?
            Inventory.free_hands(right: true)
          end
        else
          if GameObj.right_hand.id and ([Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max < 3 or [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max == 3)
            waitrt?
            Inventory.free_hands(right: true)
          else
            waitrt?
            Inventory.free_hands(left: true)
          end
        end
      end
    end

    def self.free_hands(right: false, left: false, both: false)
      if (right || both) && checkright
        # Are we holding a ready_list weapon? If so put it into its sheath
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == GameObj.right_hand.id }[0])
          Inventory.stow_ready_list(ready_item, GameObj.right_hand)
        end
        if !GameObj.right_hand.id.nil?
          Inventory.single_drag(GameObj.right_hand) # drags single item into container
        end
      end

      if (left || both) && checkleft
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == GameObj.left_hand.id }[0])
          Inventory.stow_ready_list(ready_item, GameObj.left_hand)
        end
        if !GameObj.left_hand.id.nil?
          Inventory.single_drag(GameObj.left_hand) # drags single item into container
        end
      end
    end

    def self.open_loot_containers(item)
      # Method intended for opening containers that will receive loot from the loot room or loot item command
      ELoot.msg(type: "debug", text: " Start of open_loot_containers(item)")

      # makes sure any auto-closers are open before looting
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      return unless ELoot.data.settings[:keep_closed]

      Inventory.open_single_container(ELoot.data.sacks["default"])
      Inventory.open_single_container(ELoot.data.settings[:overflow_container])
      Inventory.open_single_container(ELoot.data.settings[:secondary_overflow])

      containers = Array.new
      item.each { |loot|
        next if ELoot.data.sacks[loot.type].nil?

        unless containers.include?(ELoot.data.sacks[loot.type].id)
          Inventory.open_single_container(ELoot.data.sacks[loot.type])
          containers.push(ELoot.data.sacks[loot.type].id)
        end
      }
    end

    def self.open_single_container(sack)
      ELoot.msg(type: "debug", text: " Inventory.open_single_container: sack = #{sack}")

      return if sack.nil? || sack.empty?

      container = sack.class == GameObj ? sack : ELoot.data.sacks[sack]
      ELoot.msg(type: "debug", text: " open_single_container(sack): before open sack - #{sack} container: #{container}")

      # If its in the game obj and contents.is_a?(Array) return
      return if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)

      # Still here? Assume the container is closed and open it
      ELoot.get_lines("open ##{container.id}", ELoot.data.silent_open)

      # check out whats inside
      lines = ELoot.get_lines("look in ##{container.id}", ELoot.data.look_regex)
      return if lines.any? { |l| l =~ /You glance|There is nothing|stuffed with a variety of shredded up paper and cloth/i }

      20.times {
        break if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)

        sleep 0.1
      }

      ELoot.data.sell_containers.push(container) unless ELoot.data.sell_containers.include?(container)
    end

    def self.return_hands
      # Nothing to do
      return if ELoot.data.right_hand.id == GameObj.right_hand.id && ELoot.data.left_hand.id == GameObj.left_hand.id

      # Check Right Hand
      unless ELoot.data.right_hand.id == GameObj.right_hand.id
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == ELoot.data.right_hand.id }[0])
          Inventory.return_ready_list(ready_item, ELoot.data.right_hand, "right")
        else
          Inventory.drag(ELoot.data.right_hand, 'right')
        end
      end

      # Check Left Hand
      unless ELoot.data.left_hand.id == GameObj.left_hand.id
        if (ready_item = ELoot.data.ready_list.find { |_k, v| v.id == ELoot.data.left_hand.id }[0])
          Inventory.return_ready_list(ready_item, ELoot.data.left_hand, "left")
        else
          Inventory.drag(ELoot.data.left_hand, 'left')
        end
      end
    end

    def self.return_ready_list(ready_item, item, _hand)
      10.times {
        ELoot.get_res("ready #{ready_item}", ELoot.data.get_regex)
        sleep 0.2
        return true if [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
      }

      return false
    end

    def self.single_drag(item, phase_thing = true) # drags single item into container
      stored = false
      return unless item&.name != "Empty"

      return if Inventory.single_drag_box(item)

      # Try sacks in order of priority: item-specific, default, overflow, secondary overflow
      containers = [
        ELoot.data.sacks[item.type],
        ELoot.data.sacks["default"],
        ELoot.data.sacks[ELoot.data.settings[:overflow_container]],
        ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]]
      ]

      containers.each_with_index do |bag, index|
        next if ELoot.data.sacks_full.include?(bag)

        if bag.nil?
          case index
          when 1
            ELoot.msg(type: "yellow", text: " No default container identified. This shouldn't happen.")
            ELoot.msg(type: "yellow", text: "   Check your STOW settings. Exiting")
            exit
          when 2
            ELoot.msg(type: "info", text: " Skipping primary overflow.   No container identified.")
          when 3
            ELoot.msg(type: "info", text: " Skipping secondary overflow. No container identified.")
          end
        else
          result = Inventory.store_item(bag, item)
          if result
            ELoot.box_phase(item) if phase_thing
            stored = true
            break
          end
        end
      end

      # If item wasn't stored, pause and address
      unless stored
        ELoot.msg(type: "info", text: " Failed to store the #{item.name}.")
        ELoot.msg(type: "info", text: " Pausing the script to handle it yourself")
        ELoot.msg(type: "info", text: " ;unpause #{Script.current.name} after addressing to continue!")

        Script.current.pause
      end
    end

    def self.single_drag_box(item)
      return false unless item.type =~ /box/
      return false unless ELoot.data.settings[:use_disk]
      return false if ELoot.data.disk_full

      ELoot.wait_for_disk
      return false unless ELoot.data.disk

      # still here so lets try to put the box in the disk
      result = Inventory.store_item(ELoot.data.disk, item)
      return true if result

      # inform user it didn't fit if !result
      ELoot.msg(type: "info", text: " The #{item} won't fit in the #{ELoot.data.disk}. Trying different container.")
      ELoot.data.disk_full = true

      return false
    end

    def self.single_loot(item) # loots a single item
      return if item.nil?

      # loot item will fallback to the default sack but if both are full we need to loot manually
      bag = ELoot.data.sacks[item.type]
      bag = nil if bag.nil? || ELoot.data.sacks_full.include?(bag)
      bag ||= ELoot.data.sacks["default"]
      bag = nil if bag.nil? || ELoot.data.sacks_full.include?(bag)

      unless bag
        Inventory.single_drag(item)
        return
      end

      lines = ELoot.get_command("loot ##{item.id}", ELoot.data.put_regex)

      if lines.any? { |line| line =~ /<\/inv>You can't put your <a exist=".*?" noun=".*?">.*?<\/a> in the <a exist="(\d+)" noun=".*?">.*?<\/a>.  It's closed!/ }
        bag_id = $1
        bag = GameObj.inv.find { |i| i.id == bag_id }
        # Must be an auto closer. Their ID and contents don't drop from GameObj.container when closed
        if GameObj.containers.keys.include?(bag.id) && bag.contents.is_a?(Array)
          ELoot.data.settings[:auto_close].push(bag.name)
          Inventory.open_single_container(bag)
          ELoot.msg(type: "info", text: " #{bag.name} must be an autocloser, adding to list.")
          ELoot.save_profile()
        end
      end

      20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and ELoot.data.sacks[item.type].contents.to_a.map(&:id).include?(item.id))
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and ELoot.data.sacks["default"].contents.to_a.map(&:id).include?(item.id))
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and item.type =~ /skin/)

        sleep 0.1
      }

      # edge case of treasure system mismatch
      return true if Sell.check_inventory.any? { |obj| obj.id == item.id }

      # still here so just loot it manually
      Inventory.single_drag(item)
    end

    def self.store_item(bag, item, is_skinner = false)
      # Fixme - cleanup
      return unless item&.name != "Empty"

      lines = ELoot.get_command("_drag ##{item.id} ##{bag.id}", ELoot.data.put_regex)

      return true if lines.any? { |l| l =~ /You are unable to handle the additional load|That is not yours|Hey, that belongs to .+\.  Get yer own disk\!|Get what\?/ }

      if lines.any? { |l| l =~ /put something that you can't hold/ }
        ELoot.unlootable(item)
        return true
      end

      if lines.any? { |l| l =~ /You can't.*?It's closed!/ }
        if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)
          # Must be an auto closer. Their ID and contents don't drop from GameObj.container when closed
          ELoot.data.settings[:auto_close].push(bag.name)
          ELoot.msg(type: "info", text: " #{bag.name} must be an autocloser, adding to list.")
          ELoot.save_profile()
        end
        ELoot.get_res("open ##{bag.id}", ELoot.data.silent_open)
        Inventory.store_item(bag, item, is_skinner)
      end

      # False positive?
      if lines.any? { |l| l =~ /I could not find what you were referring to/i }
        return true
      end

      # Check if full
      if lines.any? { |l| l =~ /won't fit/i }
        ELoot.data.sacks_full.push(bag)
        return false
      end

      if lines.any? { |l| l =~ /crumbles? and decays? away|crumbles? into a pile of dust/i }
        ELoot.msg(type: "info", text: " This item was crumbly, adding to list")
        ELoot.data.settings[:crumbly].push(item.name)
        ELoot.save_profile()
        return true
      end

      20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) && bag.contents.to_a.map(&:id).include?(item.id))

        # Lousy weapon displayers don't have contents
        if is_skinner
          return true if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
        end
        sleep 0.1
      }

      # Still here? Assume bag is closed
      ELoot.msg(type: "debug", text: " Inventory.store_item: opening #{bag.noun}")
      Inventory.open_single_container(bag)

      # Try it again
      fput "_drag ##{item.id} ##{bag.id}"

      10.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) && bag.contents.to_a.map(&:id).include?(item.id))

        # Lousy weapon displayers don't have contents
        if is_skinner
          return true if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
        end

        sleep 0.1
      }

      # Give up and return false
      return false
    end

    def self.stow_ready_list(ready_item, item)
      if ELoot.data.ready_method[ready_item] =~ /put in sheath/
        Inventory.open_single_container(ELoot.data.ready_list["sheath"])
      elsif ELoot.data.ready_method[ready_item] =~ /put in secondary/
        Inventory.open_single_container(ELoot.data.ready_list["2sheath"])
      end

      ELoot.get_res("store #{ready_item}", ELoot.data.put_regex)

      20.times {
        return true if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)

        sleep 0.1
      }

      return false
    end
  end # End of Inventory

  # Gem and Reagent hording
  module Horde
    def self.set_type_vars(type)
      return if type == ELoot.data.horde_type
      ELoot.data.horde_type = type

      case type
      when 'gem'
        ELoot.data.container_settings = ELoot.data.settings[:gem_horde_containers]  # This is the container list to horde FROM
        ELoot.data.everything_list = ELoot.data.settings[:gem_everything_list]      # Horde everything toggle
        ELoot.data.everything = ELoot.data.settings[:gem_everything]                # List of excluded gems
        ELoot.data.only_list = ELoot.data.settings[:gem_only_list]                  # Only horde specific items toggle
        ELoot.data.only = ELoot.data.settings[:gem_list]                            # List of specific items
        ELoot.data.locker_city = ELoot.data.settings[:gem_locker_name]              # This is the name of the city where the locker is
        ELoot.data.locker = ELoot.data.settings[:gem_horde_locker]                  # True/False toggle to use locker
        ELoot.data.cache = ELoot.data.settings[:gem_horde_container]                # This is container name in UI
        ELoot.data.inventory = ELoot.data.settings[:gem_horde_inv]                  # Gem inventory
        ELoot.data.use_hording = ELoot.data.settings[:gem_horde]                    # True/False toggle to horde gems
      when 'reagent'
        ELoot.data.container_settings = ELoot.data.settings[:alchemy_horde_containers]
        ELoot.data.everything_list = ELoot.data.settings[:alchemy_everything_list]
        ELoot.data.everything = ELoot.data.settings[:alchemy_everything]
        ELoot.data.only_list = ELoot.data.settings[:alchemy_only_list]
        ELoot.data.only = ELoot.data.settings[:alchemy_list]
        ELoot.data.locker_city = ELoot.data.settings[:alchemy_locker_name]
        ELoot.data.locker = ELoot.data.settings[:alchemy_horde_locker]
        ELoot.data.cache = ELoot.data.settings[:alchemy_horde_container]
        ELoot.data.inventory = ELoot.data.settings[:reagent_horde_inv]
        ELoot.data.use_hording = ELoot.data.settings[:alchemy_horde]
      end
    end

    def self.validate_hording_settings
      need_return = false

      if ELoot.data.locker && ELoot.data.locker_city.empty?
        ELoot.msg(text: " Horde #{ELoot.data.horde_type} in a locker is toggled on the UI but location is empty")
        need_return = true
      end

      if ELoot.data.cache.empty?
        ELoot.msg(text: " A gem hording container is not identified (yes, you need it for a locker too)")
        need_return = true
      end

      if ELoot.data.container_settings.length.zero?
        ELoot.msg(text: " No containers identified to horde #{ELoot.data.horde_type}s from.")
        ELoot.msg(text: " Please make selection in UI Gem/Alchemy Hording Tab")
        need_return = true
      end

      if need_return
        ELoot.msg(text: " The hording settings need updated.", space: true)
        return false
      end

      return true
    end

    def self.check_type(item)
      noun = item =~ /lapis/ ? 'lapis' : item.split.last
      item = item =~ /essence of (air|earth|water|fire)/ ? "some #{item}" : item

      if item =~ GameObj.type_data[ELoot.data.horde_type][:exclusion]
        return false
      elsif item =~ GameObj.type_data[ELoot.data.horde_type][:name] || noun =~ GameObj.type_data[ELoot.data.horde_type][:noun]
        return true
      else
        return false
      end
    end

    def self.normalize_name(name)
      return if name.nil?
      if name.is_a?(String)
        case name
        when /essences? of (air|earth|water|fire)/
          return "essence of #{$1}"
        when /(glimmering blue essence dust|glowing violet essence dust|faintly glowing dust|radiant crimson essence dust|faintly radiant dust|waxy grey caederine)/
          return "some #{$1}"
        when /golden seed/
          return "tiny golden seed"
        end
      end

      name_rules = {
        'ies'    => 'y',
        'onyxes' => 'onyx',
        'zes'    => 'z',
        's'      => '',
      }

      name = name.full_name if name.is_a?(GameObj)
      name = name.downcase

      unless name =~ /^\s*(?:(?:some|a|an|the) )?(?:(?:(?:piece|shard|slice|ribbon)s? of|polished) )?(?:(?:tiny|small|medium|large) )?(.*?)\s*$/
        raise 'FIXME: normalize pattern did not match but should match anything'
      end
      name = $1

      if name =~ /^(.*?)(#{name_rules.keys.map { |x| Regexp::escape(x) }.join('|')})$/
        return "#{$1}#{name_rules[$2]}"
      else
        return name
      end
    end

    def self.go2_locker
      lockers = Map.list.find_all { |room| (room.tags.any?(/meta:che:#{ELoot.data.locker_city}/) && room.tags.any?(/locker/)) || (room.tags.any?(/publiclockers/) && room.location =~ /#{ELoot.data.locker_city}/) }
      locker_town = Room[Room[lockers.first.id].find_nearest_by_tag("town")].location
      current_town = Room[Room.current.find_nearest_by_tag("town")].location

      if locker_town =~ /the Isle of Four Winds/i && current_town != locker_town
        fwi_place = Room.list.find { |room| room.tags.include?('town') && ELoot.fwi?(room) }
        ELoot.go2(fwi_place.id)

        locker_town = Room[Room[lockers.first.id].find_nearest_by_tag("town")].location
        current_town = Room[Room.current.find_nearest_by_tag("town")].location
      end

      unless current_town == locker_town
        ELoot.msg(text: " Not able to horde. Your hording locker is in #{locker_town}.", space: true)
        return
      end

      unless ELoot.data.account_type == 'Premium'
        ELoot.silver_withdraw(1500)
      end

      index = 0

      if lockers.any? { |location| location.id == Room.current.id }
        index = lockers.find_index { |location| location.id == Room.current.id }
      end

      loop do
        place = lockers[index]
        ELoot.go2(place.id)
        ELoot.wait_rt

        # some rooms go directly to the locker instead of just outside
        break if GameObj.loot.find { |item| item.name == "dark stained antique oak trunk" }

        # fixme: are there other ways in?
        way_in = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain|tapestry)$/ }
        way_in.noun = "opening" if way_in.noun == "tapestry"
        result = move "go #{way_in.noun}"

        break if result == true

        if index == lockers.length - 1 # Pause for 10 seconds if it's the last iteration
          respond
          ELoot.msg(text: " Not able to enter a locker. They might all be taken. Waiting 10 seconds then trying again.", space: true)
          respond
          sleep(10)
        end

        index = (index + 1) % lockers.length # Increment index, wrapping around if it exceeds the array length
      end
      ELoot.wait_rt
    end

    def self.open_locker
      ELoot.data.stash = nil
      retries = 0
      max_retries = 3
      error_log = []

      ELoot.wait_rt

      unless (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:trunk|counter|locker)$/ }
        error_log.push("Error: I'm lost - Room: #{Room.current.id} | Type: #{ELoot.data.horde_type}")
        ELoot.msg(text: "Something went wrong. Trying to enter a locker")
        ELoot.msg(text: " Please send the EO team the following on the discord scripting channel...")
        ELoot.msg(text: " Errors: #{error_log}")
        return
      end

      begin
        open_result = ELoot.get_command('open locker', /exist=".*?" noun="(?:locker|chest)"|That is already open.|<prompt time=".*?">&gt;<\/prompt>/)

        ELoot.data.stash = GameObj.loot.find { |item| item.name =~ /#{ELoot.data.cache}/ }

        # maybe its on a counter
        if ELoot.data.stash.nil?
          counter = GameObj.room_desc.find { |item| item.name =~ /counter/ }
          ELoot.get_lines("look on ##{counter.id}", /<container id='.*?' title=/)
          ELoot.data.stash = counter.contents.find { |item| item.name =~ /#{ELoot.data.cache}/ }
        end

        raise StandardError if ELoot.data.stash.nil?
      rescue StandardError
        if retries < max_retries
          retries += 1
          ELoot.msg(text: " Something went wrong. Retrying... (Retry #{retries} of #{max_retries}).", space: true)
          error_log.push(open_result)
          sleep 1
          retry
        else
          ELoot.msg(text: " Not able to find the container in your locker for #{ELoot.data.horde_type} hording.")
          ELoot.msg(text: " Please send the EO team the following on the discord scripting channel...")
          ELoot.msg(text: " Room: #{Room.current.id} | container_name: #{ELoot.data.cache}")
          error_log.push("Type: #{ELoot.data.horde_type}")
          ELoot.msg(text: " Errors: #{error_log}")
          Horde.leave_locker
        end
      else
        ELoot.get_lines("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/)
      end
    end

    def self.leave_locker
      locker_item = GameObj.loot.find { |item| item.name =~ /dark stained antique oak trunk|counter|locker/ }
      is_locksmith_room = Room.current.tags.include?('locksmith')

      return if locker_item.nil? || is_locksmith_room

      ELoot.get_res('close locker', /^You/)

      # fixme: other ways out?
      way_out = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain|tapestry)$/ }
      way_out.noun = "opening" if way_out.noun == "tapestry"
      move "go #{way_out.noun}"
      ELoot.wait_rt
    end

    def self.build_inventory(refresh = false)
      return unless ELoot.data.inventory.empty? || refresh

      if ELoot.data.locker && ELoot.data.account_type =~ /premium/i
        result = Horde.build_premium_locker_inventory
        return if result
      end

      ELoot.data.inventory = []
      percent_complete = 0

      ELoot.get_lines("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/)
      total_items = ELoot.data.stash.contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && !obj.after_name.nil? }.length.to_i
      empty_jars = ELoot.data.stash.contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && obj.after_name.nil? }.length.to_i

      if empty_jars.positive?
        ELoot.data.inventory.push(h = { :item => '*** empty jars ***', :count => empty_jars, :full => '  -' })
      end

      ELoot.data.stash.contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && !obj.after_name.nil? }.each_with_index do |jar, index|
        lines = ELoot.get_lines("look in ##{jar.id} from ##{ELoot.data.stash.id}", /^Inside .*? you see [0-9]+ portion/)

        if (match_data = lines.find { |line| line =~ /^Inside .*? you see ([0-9]+) portion/ })
          count = match_data[1].to_i
          regex_pattern = /\b(?:containing|pieces of|large|medium|small|tiny|some)\b/
          item = jar.after_name.gsub(regex_pattern, '').strip
          item = Horde.normalize_name(item).strip
          full = lines.any?(/It is full/)

          if Horde.check_type(item)
            ELoot.data.inventory.push(h = { :item => item, :count => count, :full => full })
          end
        end

        percent_complete = (((index + 1).to_f / total_items) * 100).round(2)
        respond " percent complete: #{percent_complete}%"
      end

      ELoot.save_horde_profile
    end

    def self.build_premium_locker_inventory
      all_lockers = ["Wehnimer's Landing", "Teras Isle", "Solhaven", "River's Rest", "Icemule Trace", "Zul Logoth", "Ta'Illistim", "Ta'Vaalor", "Mist Harbor", "Cysaegir", "Kraken's Fall", "Family Vault"]
      locker_town = ELoot.data.locker_city == 'Kharam-Dzu' ? 'Teras Isle' : ELoot.data.locker_city
      locker_town = "Family Vault" if ELoot.data.cache =~ /trunk/i

      return false unless all_lockers.include?(locker_town)
      ELoot.data.inventory = []

      case ELoot.data.cache
      when /trunk/i
        start_from = "bound in wrought iron"
      when /chest/i
        start_from = "deep chest"
      when /rack/i
        start_from = "weapon rack"
      when /stand/i
        start_from = "armor stand"
      when /bin/i
        start_from = "magical item bin"
      when /wardrobe/i
        start_from = "clothing wardrobe"
      end

      lines = ELoot.get_lines("locker manifest #{locker_town}", /Thinking back, you recall the contents|Looking in front of you/)

      # Find the index of the line starting with the container name
      start_index = lines.index { |line| line.include?(start_from) }
      end_index = lines[start_index + 1..-1].index('') + start_index + 1
      extracted_elements = lines[(start_index + 1)...end_index]

      empty_jars = lines.count { |line| line.match?(/(?:jar|bottle|beaker)/) && !line.include?("containing") }
      if empty_jars.positive?
        ELoot.data.inventory.push(h = { :item => '*** empty jars ***', :count => empty_jars, :full => '  -' })
      end

      extracted_elements.each do |line|
        match = line.match(/containing\s(?<item>.*?)\s+\((?<stored>\d+)\/(?<capacity>\d+)\)\z/)

        if match
          regex_pattern = /\b(?:containing|pieces of|large|medium|small|tiny|some)\b/
          item = match[:item].gsub(regex_pattern, '').strip

          item = Horde.normalize_name(item).strip
          stored = match[:stored].strip.to_i
          capacity = match[:capacity].strip.to_i
          full = stored == capacity ? true : false

          if Horde.check_type(item)
            ELoot.data.inventory.push(h = { :item => item, :count => stored, :full => full })
          end

        end
      end

      return true
    end

    def self.list_inventory(type)
      Horde.set_type_vars(type)

      sorted_data = ELoot.data.inventory.sort_by { |entry| entry[:item] }

      rows = []
      rows << ["#{type.capitalize}s", 'Amount', 'Full?']
      rows << :separator
      sorted_data.each do |entry|
        rows << [ELoot.capitalize_words(entry[:item]), entry[:count], entry[:full]]
      end

      table = Terminal::Table.new :title => "#{type.capitalize} Inventory", :rows => rows
      table.align_column(1, :right)
      respond
      respond table
      respond
    end

    def self.reset_inventory(type)
      Horde.set_type_vars(type)
      return unless Horde.validate_hording_settings

      start_room = Room.current.id

      # Find the stash container and/or goto locker
      unless ELoot.data.locker && ELoot.data.account_type =~ /premium/i
        Horde.horde_prep
      end

      # Build inventory if needed
      Horde.build_inventory(true)

      # Leave the locker if needed
      Horde.leave_locker unless ELoot.data.account_type =~ /premium/i

      # Go back to original room
      ELoot.go2(start_room)

      # Save the new inventory
      ELoot.save_horde_profile
    end

    def self.horde_prep
      if ELoot.data.locker
        locker_item = GameObj.loot.find { |item| item.name =~ /dark stained antique oak trunk|counter|locker/ }
        is_locksmith_room = Room.current.tags.include?('locksmith')

        Horde.go2_locker if is_locksmith_room || locker_item.nil?

        Horde.open_locker
        # ELoot.data.stash variable set when opening locker
      else
        ELoot.data.stash = GameObj.inv.find { |i| i.name =~ /#{ELoot.data.cache}\b/ }
        Inventory.open_single_container(ELoot.data.stash)
      end
    end

    def self.need_to_horde?(deposit = false)
      return true if deposit
      return true if ELoot.data.inventory.empty?
      bounty_gems = []

      if ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/ && ELoot.data.horde_type == 'gem'

        gem_name, gem_number = Horde.check_gem_bounty

        ELoot.data.items_to_horde.each do |item|
          if item.name =~ /#{gem_name}/ && bounty_gems.length.to_i < gem_number
            bounty_gems.push(item)
          end
        end

        have_stock = ELoot.data.inventory.find { |item| item[:item] == gem_name }
        need_gems = gem_number - bounty_gems.length.to_i

        return true if need_gems.positive? && !have_stock.nil?
      end

      remaining_items = ELoot.data.items_to_horde - bounty_gems

      remaining_items.each do |thing|
        result = ELoot.data.inventory.find { |item| item[:item] =~ /#{Horde.normalize_name(thing.name)}/ }[:full]

        next if result == true

        if result.nil?
          result = ELoot.data.inventory.find { |item| item[:item] =~ /empty jar/ }
        end

        return true unless result.nil?
      end

      return false
    end

    def self.check_gem_bounty # Returns gem bounty name and count
      return unless ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/

      match_data = checkbounty.match(ELoot.data.gem_regex)

      # Extracting values from named capture groups
      gem_name = Horde.normalize_name(match_data[:gem])
      gem_number = match_data[:number].to_i

      return gem_name, gem_number
    end

    def self.horde_items(type = nil, just_deposit = false)
      ELoot.data.horde_deposit = []
      start_room = Room.current.id

      ['gem', 'reagent'].each do |item|
        next if !type.nil? && type != item
        Horde.set_type_vars(item)
        next unless ELoot.data.use_hording
        next unless Horde.validate_hording_settings

        # Create the list of items to store
        Horde.hording_list

        # Next unless there is something for use to do
        next unless Horde.need_to_horde?(just_deposit)

        # Find the stash container and/or goto locker
        Horde.horde_prep

        # Build inventory if needed
        Horde.build_inventory

        # Finally store the items
        Horde.store_items(just_deposit)

        # Withdraw bounty gems if needed
        if ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/ && ELoot.data.horde_type == 'gem' && !just_deposit

          gem_name, gem_number = Horde.check_gem_bounty
          gem_list = Horde.hording_list(gem_name)

          if gem_list.count < gem_number
            need_for_bounty = gem_number - gem_list.count
            Horde.shake(need_for_bounty, gem_name) unless need_for_bounty.zero?
          end
        end
      end

      # Leave the locker if needed
      Horde.leave_locker

      # Go back to original room
      ELoot.go2(start_room)
    end

    def self.shake(number, name)
      # Refresh the cache because lockers are special
      ELoot.get_lines("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/)

      jar = ELoot.data.stash.contents.find { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && Horde.normalize_name(obj.after_name) =~ /\b#{name}\b/ }

      return if jar.nil?

      Inventory.drag(jar)

      number.times {
        lines = ELoot.get_command("shake ##{jar.id}", /You give your <a exist=".*?"/)
        item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.id !~ /#{jar.id}/ }
        Inventory.store_item(ELoot.data.sacks["default"], item)
        if lines.any?(/That was the last/)
          ELoot.data.inventory.delete_if { |item| item[:item] == name }
          ELoot.save_horde_profile
          break
        end
      }

      Horde.check_jar(name)

      # Need to refresh the locker contents because lockers are special
      ELoot.get_lines("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/)

      Inventory.store_item(ELoot.data.stash, jar)
    end

    def self.check_jar(item_name)
      jar = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:jar|bottle|beaker)$/ }

      return if jar.nil?

      jar_lines = ELoot.get_lines("look in ##{jar.id}", /^Inside .*? you see [0-9]+ portion|^The <a exist=".*?is empty/)

      if (match_data = jar_lines.find { |line| line =~ /^Inside .*? you see ([0-9]+) portion/ })
        count = match_data[1].to_i
        full = jar_lines.any?(/It is full/)

        index_to_update = ELoot.data.inventory.find_index { |item| item[:item] =~ /#{item_name}/ }

        if index_to_update
          ELoot.data.inventory[index_to_update][:count] = count
          ELoot.data.inventory[index_to_update][:full] = full
        end

        ELoot.save_horde_profile
      end
    end

    def self.hording_list(single = nil)
      ELoot.data.items_to_horde = []

      item_containers = ELoot.data.container_settings.map { |key| ELoot.data.sacks[key] if ELoot.data.container_settings.include?(key) }.compact

      item_containers.each do |container|
        next if container.nil?

        Inventory.open_single_container(container)
        ELoot.data.items_to_horde += container.contents.to_a
      end

      unless single.nil?
        singles = ELoot.data.items_to_horde.select { |item| item.name =~ /#{single}/ }
        return singles
      end

      ELoot.data.items_to_horde.reject! { |item| item.type !~ /#{ELoot.data.horde_type}/ }

      if ELoot.data.everything_list && ELoot.data.everything.length.positive?
        ELoot.data.items_to_horde.reject! { |item| item.name =~ Regexp.union(ELoot.data.everything) }
      end

      if ELoot.data.only_list && ELoot.data.only.length.positive?
        ELoot.data.items_to_horde.reject! { |item| item.name !~ Regexp.union(ELoot.data.only) }
      end
    end

    def self.process_gems(inventory_gems)
      return inventory_gems unless ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/ && ELoot.data.horde_type == 'gem'

      gem_name, gem_number = Horde.check_gem_bounty
      return inventory_gems unless Horde.normalize_name(inventory_gems.first) == gem_name

      # Do we have enough?
      if inventory_gems.count > gem_number
        gem_number.times { inventory_gems.pop }
      else
        need_for_bounty = gem_number - inventory_gems.count

        if ELoot.data.inventory.find { |thing| thing[:item] == gem_name }
          Horde.shake(need_for_bounty, gem_name) unless need_for_bounty.zero?
          inventory_gems = []
        end
      end

      return inventory_gems
    end

    def self.get_gem_bounty
      return unless ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/

      gem_name, gem_number = Horde.check_gem_bounty
      Horde.hording_list(gem_name)

      Horde.raid_cache(["get_gem_bounty", "raid", "gem", gem_name, "x#{gem_number}"])
    end

    def self.store_items(deposit = false)
      full_jars = []
      ELoot.data.items_to_horde.uniq.each do |item|
        jar = nil
        item_name = Horde.normalize_name(item)
        next if full_jars.include?(item_name)
        if ELoot.data.inventory.find { |thing| thing[:item] == item_name }[:full]
          full_jars << item_name
          ELoot.msg(text: " Skipping deposit of #{item.name} because its jar is full.", space: true)
          next
        end

        if ELoot.data.horde_type == "gem"
          gem_name, _gem_number = Horde.check_gem_bounty
          if item_name == gem_name
            ELoot.msg(text: " Skipping deposit of #{item.name} because its needed for a gem bounty.", space: true)
            next
          end
        end

        items_to_horde = Horde.hording_list(item.name)

        items_to_horde = Horde.process_gems(items_to_horde) unless deposit
        next if items_to_horde.length.zero?

        first_name = items_to_horde.first.instance_variable_get(:@name)
        look_for = Horde.normalize_name(first_name)

        bottle = ELoot.data.stash.contents.find { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && Horde.normalize_name(obj.after_name) =~ /\b#{look_for}\b/ }

        empty = ELoot.data.stash.contents.find { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && obj.after_name.nil? }

        if Inventory.drag(bottle)
          jar = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:jar|bottle|beaker)$/ }
        elsif Inventory.drag(empty)
          jar = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:jar|bottle|beaker)$/ }
          index_to_update = ELoot.data.inventory.find_index { |item| item[:item] =~ /empty jar/ }
          if index_to_update
            count = ELoot.data.stash.contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && obj.after_name.nil? }.length.to_i
            if count.zero?
              ELoot.data.inventory.delete_if { |item| item[:item] =~ /empty jar/ }
            else
              ELoot.data.inventory[index_to_update][:count] = count
            end

            ELoot.save_horde_profile
          end
        end

        if jar.nil?
          ELoot.msg(text: " No empty jars found to store #{item.name}.", space: true)
          next
        end

        thing_name = nil
        items_to_horde.each do |thing|
          thing_name = Horde.normalize_name(thing)

          Inventory.drag(thing)
          result = ELoot.get_res("_drag ##{thing.id} ##{jar.id}", /You (add|put)|The.*?is full/)

          if result =~ /into your empty jar/
            ELoot.data.inventory.push({ :item => thing_name, :count => 1, :full => false })
            ELoot.data.inventory.uniq!
          end

          if result =~ /is full/
            ELoot.msg(text: " Something went wrong. Need to rebaseline inventory.", space: true)

            Inventory.store_item(ELoot.data.stash, jar)
            Inventory.store_item(ELoot.data.sacks["default"], thing)
            ELoot.wait_rt

            Horde.build_inventory(true)

            break
          end
          ELoot.data.horde_deposit.push({ :item => thing_name, :type => ELoot.data.horde_type })
        end

        Horde.check_jar(thing_name)

        # Need to refresh the locker contents because lockers are special
        ELoot.get_lines("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/)

        Inventory.store_item(ELoot.data.stash, jar)
      end
    end

    def self.raid_cache(options)
      ELoot.msg(type: "debug", text: " Horde.raid_cache options: #{options}")
      if options[2] !~ /gem|reagent|alchemy/
        ELoot.msg(text: " To use this option - ;eloot raid <type> <item to get> x<how many>.")
        ELoot.msg(text: " Ex ;eloot raid gem blue diamond x5")
        ELoot.msg(text: " <type> can be gem or reagent")
        exit
      end

      Inventory.clear_hands

      if options[2] =~ /reagent|alchemy/
        type = 'reagent'
      elsif options[2] =~ /gem/
        type = 'gem'
      end

      Horde.set_type_vars(type)

      number = (options[3..-1].find { |var| var =~ /^[Xx][0-9]+$/ }.sub(/[Xx]/, '') || 1).to_i
      options.delete_if { |line| line =~ /^[Xx]([0-9]+)$/ }

      search_string = options[3..-1].join(' ')

      item = Horde.normalize_name(search_string)

      unless ELoot.data.inventory.find { |thing| thing[:item] == item }
        ELoot.msg(text: " Not able to find #{item} in your cache.")
        ELoot.msg(text: " Run ;eloot reset #{type} to re-baseline it if needed.")
        return
      end

      start_room = Room.current.id
      Horde.horde_prep

      Horde.shake(number, item)

      Horde.leave_locker

      ELoot.go2(start_room)
      Inventory.return_hands
    end
  end

  # Loot handles the room looting for ELoot
  module Loot
    def self.bag_loot(bag) # loots bags dropped from critters that have treasure in them
      return if ELoot.data.checked_bags.include?(bag.id)

      lines = ELoot.get_lines("open ##{bag.id}", /crumbles? and decays? away|<exposeContainer|That is already open|<container|There doesn't seem to be any way to do that|I could not find what you were referring to/)

      if lines.any? { |l| l =~ /crumbles? and decays? away/i }
        unless bag.name =~ /bandana|flowing robes/
          ELoot.msg(type: "info", text: " #{bag} was crumbly, adding to list")
          ELoot.data.settings[:crumbly].push(bag.name)
          ELoot.save_profile()
        end
        return "crumbly"
      end

      if lines.any? { |line| line =~ /There doesn't seem to be any way to do that|I could not find what you were referring to/i }
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      lines = ELoot.get_lines("look in ##{bag.id}", /<container|That is closed/)

      # False positive?
      if lines.any? { |line| line =~ /I could not find what you were referring to/i }
        return false
      end

      objs = Loot.reject_invalid_loot(bag.contents)

      if objs.empty?
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      objs = Loot.loot_specials(objs)

      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      if objs.empty?
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      Loot.loot_regular(objs)

      ELoot.data.checked_bags.push(bag.id)
    end

    def self.box_loot(box, location = nil, data = nil) # Loots box contents
      if box.type == "box"
        line = ELoot.get_res("open ##{box.id}", /open|locked/)
        return Inventory.single_drag(box) if line =~ /locked/

        if ELoot.data.settings[:display_box_contents]
          ELoot.get_res("look in ##{box.id}", ELoot.data.look_regex)
        else
          ELoot.get_lines("look in ##{box.id}", ELoot.data.look_regex)
        end

        start_silvers = ELoot.silver_check
        while box.contents.any? { |obj| obj.name =~ /silver coins/ }
          unless ELoot.data.charm.nil?
            res = ELoot.get_res("point ##{ELoot.data.charm.id} at ##{box.id}", /You summon/)
            data[location] += ELoot.silver_check - start_silvers
          else
            res = ELoot.get_res("get coins from ##{box.id}", /You gather the remaining|Get what|You can only collect/)
            if res =~ /You gather the remaining/
              data[location] += ELoot.silver_check - start_silvers
              ELoot.wait_rt
              break
            elsif res =~ /You can only collect/
              data[location] += ELoot.silver_check - start_silvers
              ELoot.wait_rt
              room = Room.current.id
              ELoot.silver_deposit
              start_silvers = ELoot.silver_check
              ELoot.go2(room)
            else
              ELoot.msg(type: "info", text: " Unknown get coin result...Exiting!")
              exit
            end
          end
        end

        objs = box.contents
        if objs.empty?
          Sell.save_trash_box(box)
          return
        end

        objs = Loot.loot_specials(objs)

        # Anything left after boxes, collectibles, and uncommon weapon/armor?
        if objs.empty?
          Sell.save_trash_box(box)
          return
        end

        Loot.loot_regular(objs, "Box", box)
        Sell.save_trash_box(box)
      elsif box.type == "plinite"
        ELoot.get_res("pluck ##{box.id}", /You carefully pluck/)
        Inventory.free_hands(both: true)
      end
    end

    def self.loot_all(items) # loots entire room
      waitrt?

      Inventory.free_hand

      res = ELoot.get_command('loot room', /<dialogData|There is no loot|You need a free hand to do that|With a discerning eye|You note some treasure of interest|You can't.*?It's closed!/)

      if res.any? { |l| l =~ /There is no loot/ }
        items.each { |item| ELoot.unlootable(item) }
        return true
      end

      if res.any? { |l| l =~ /You can't.*?It's closed!/ }
        items_opened = Array.new
        items.each { |item|
          if ELoot.data.sacks[item.type] && !ELoot.data.sacks_full.include?(ELoot.data.sacks[item.type])
            bag = ELoot.data.sacks[item.type]
          else
            bag = ELoot.data.sacks["default"]
          end

          next if items_opened.include?(bag.name)

          items_opened.push(bag.name)

          if GameObj.containers.keys.include?(bag.id) && bag.contents.is_a?(Array)
            # check if open
            lines = ELoot.get_lines("look in ##{bag.id}", ELoot.data.look_regex)

            if lines.any? { |l| l =~ /That is closed./ }
              # This must be our lousy autocloser
              ELoot.data.settings[:auto_close].push(bag.name)
              ELoot.msg(type: "info", text: " #{bag.name} must be an autocloser, adding to list.")
              ELoot.save_profile()
            end
          end
        }

      end

      # Didn't get it all?...something in-hand?
      if res.any? { |l| l =~ /(?:gather|pick) up and stow (?:what|as much) treasure .+ manage|but quickly realize|before realizing you have no room/ }
        [GameObj.right_hand, GameObj.left_hand].each do |hand|
          Inventory.single_drag(hand) if items.any? { |thing| thing.id == hand.id }
        end

        # Anything left?
        objs = Loot.reject_invalid_loot(GameObj.loot.to_a)
        return if objs.empty?

        # Still here so rerun Loot.room
        Loot.room

      end
    end

    def self.loot_regular(objs, from_where = nil, box = nil)
      valid = Loot.valid_objs(objs.clone)
      invalid = Loot.invalid_objs(objs.clone)

      ELoot.msg(type: "debug", text: " Loot.room - valid: #{valid}")
      ELoot.msg(type: "debug", text: " Loot.room - invalid: #{invalid}")

      # Is there anything else we care about?
      if valid.empty? && !invalid.empty?
        invalids = []
        invalid.each { |t| invalids.push(t.name) unless valid.include?(t) }
        ELoot.msg(type: "info", text: " Left the following invalid lootables: #{invalids.join(', ')}.") if !invalids.empty?
      elsif invalid.empty? && !valid.empty?
        # Make sure we have a hand free
        Inventory.free_hand
        ELoot.msg(type: "debug", text: " Loot.loot_regular: Calling Loot.loot_all")

        if from_where == "Room"
          Loot.loot_all(valid)
        elsif from_where == "Box"
          res = ELoot.get_res("loot ##{box.id}", /You search through|You can't.*?It's closed!|There is no loot|In an attempt/i)
          if res =~ /before realizing you have no space|unable to hold more items/
            item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.type !~ /box/ }
            Inventory.single_drag(item)
          end
          ELoot.msg(type: "info", text: " Failed to LOOT box") if res.nil?

          sleep(0.10)

          if box.contents.length.positive?
            lootsack = ELoot.data.sacks['default']
            res = dothistimeout("empty ##{box.id} in ##{lootsack.id}", 3, /You try to empty/)
            sleep 0.5
            waitrt?
            if res.nil? || res =~ /but nothing will fit|leaving the rest/
              # check if we have any room in other containers
              objs = box.contents
              valid = Loot.valid_objs(objs.clone)

              valid.each do |thing|
                Inventory.single_drag(thing)
              end
            end
          end
        else
          # Make sure we have a hand free
          Inventory.free_hand
          valid.each do |thing|
            Inventory.single_drag(thing)
          end
        end
      else
        # Make sure we have a hand free
        Inventory.free_hand
        if from_where == "Room"
          valid.each do |obj|
            if obj.type !~ /clothing|jewelry|gem|herb|skin|wand|scroll|potion|reagent|trinket|lockpick|treasure|forageable|magic|collectible/
              Inventory.single_drag(obj)
            else
              Inventory.single_loot(obj)
            end
          end
        else
          valid.each do |thing|
            Inventory.single_drag(thing)
          end
        end
        invalids = []
        invalid.each { |t| invalids.push(t.name) unless valid.include?(t) }
        ELoot.msg(type: "info", text: " Left the following invalid lootables: #{invalids.join(', ')}.") if !invalids.empty?
      end

      ELoot.msg(type: "debug", text: " Loot.loot_regular: End of method")
    end

    def self.loot_specials(objs)
      # Open sacks for looting the room
      Inventory.open_loot_containers(objs)

      # Boxes go first. If handled, we reject them since they're already looted.
      types = ["box", "clothing", "collectible", "cursed", "jewelry", "food", "breakable"]

      objs = objs.reject do |thing|
        result = Loot.bag_loot(thing) if thing.type =~ /clothing/

        next true if result == "crumbly"
        next false if ELoot.data.exclude && thing.name.match(Regexp.union(ELoot.data.exclude))
        next false if (thing.name.eql?("shard of oblivion quartz") and Stats.level.eql?(100) && ELoot.data.settings[:loot_types].include?("gem"))
        next false if (thing.name =~ /doomstone|urglaes fang/ && !ELoot.data.settings[:loot_types].include?("cursed"))

        unless (thing.type =~ Regexp.union(ELoot.data.settings[:loot_types]) && thing.type =~ Regexp.union(types)) \
          || (ELoot.data.settings[:loot_keep].length.positive? && thing.name =~ Regexp.union(ELoot.data.settings[:loot_keep])) \
          || (thing.type =~ /cursed/i && ELoot.data.settings[:loot_types].include?("cursed")) \
          || (thing.type =~ /weapon/i && thing.type =~ /uncommon/) && ELoot.data.settings[:loot_types].include?("weapon") \
          || (thing.type =~ /armor/i && thing.type =~ /uncommon/) && ELoot.data.settings[:loot_types].include?("armor") \
          || (thing.name =~ /orb/ && thing.type =~ /magic/ && ELoot.data.settings[:loot_types].include?("magic")) \
          || (thing.name =~ /silver coin/ && ELoot.data.settings[:loot_types].include?("coins"))

          next false
        end

        if thing.name =~ /silver coin/
          unless ELoot.data.charm.nil?
            ELoot.get_res("rub ##{ELoot.data.charm.id}", /You summon/)
          else
            ELoot.get_res("get coins", /you gather/i)
          end
        else
          # Make sure we have a hand free
          if ELoot.decurse(thing)
            Inventory.free_hand
            Inventory.single_drag(thing)
          end
        end

        next true
      end

      ELoot.msg(type: "debug", text: " Loot.loot_specials: After specials check")

      return objs
    end

    def self.occassional_skinner(obj)
      if obj.name =~ /rotting chimera/
        lines = ELoot.get_lines("describe chimera", /The twisted and confused form/)
        if lines.any? { |line| line =~ /A huge scorpion tail rises high from the rear/ }
          return true
        end
      end

      return false
    end

    def self.reject_invalid_loot(objs) # rejects items from the GamObj.loot object
      objs.reject do |obj|
        next if ELoot.data.settings[:loot_keep].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:loot_keep])

        obj.name =~ /\bsevered\b|rotting tree stump|jagged crater|rolton droppings|point of elemental instability|child/i ||
          obj.id.to_i.negative? ||
          (obj.type =~ /weapon|armor/i && obj.type !~ /uncommon|clothing/i) ||
          obj.noun =~ /^(?:disk|coffin|gangplank|muck|space|cloud|kitten|puppy|mist|door|staircase|maw|cyclone)$/ ||
          obj.name =~ /[A-Z][a-z]+ #{ELoot.data.disk_nouns_regex}\b/ ||
          (ELoot.data.settings[:unlootable].include?(obj.name) && ELoot.data.settings[:log_unlootables]) ||
          obj.name =~ /\b(?:small puddle|vine|bramble|widgeonweed|vathor club|swallowwort|smilax|creeper|briar|ivy|tumbleweed|slender silvery thread|slippery wooden chute|sealed fissure|massive icicle)\b/i ||
          ELoot.data.settings[:crumbly].index(obj.name) > -1
      end
    end

    def self.should_grab_item?(thing)
      # If its on the exclude list return
      return false if ELoot.data.exclude && thing.name.match(Regexp.union(ELoot.data.exclude))

      # oblivion quartz isn't cursed if you are level 100
      return true  if thing.name.eql?("shard of oblivion quartz") and Stats.level.eql?(100) && ELoot.data.settings[:loot_types].include?("gem")

      # Cursed items need to be handled separate due to gems
      return false if thing.type =~ /cursed/i && !ELoot.data.settings[:loot_types].include?("cursed")

      # Keep it if it's a type we want
      return true if thing.type =~ Regexp.union(ELoot.data.settings[:loot_types])

      # If the type is something we don't want return false
      not_wanted = ELoot.data.all_loot_categories - ELoot.data.settings[:loot_types]
      return false if thing.type =~ Regexp.union(not_wanted)

      # Anything left lets take
      return true
    end

    def self.valid_objs(objs) # finds valid loot
      objs.select { |o| self.should_grab_item?(o) }
    end

    def self.invalid_objs(objs) # finds non-valid loot
      objs.reject { |o| self.should_grab_item?(o) }
    end

    def self.room # method that loots the room
      objs = Loot.reject_invalid_loot(GameObj.loot.to_a)

      unless objs.empty?
        objs = loot_specials(objs)
      end

      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      unless objs.empty?
        Loot.loot_regular(objs, "Room")
      end
    end

    def self.search(objs = GameObj.dead.to_a) # searches dead critters
      return if objs.empty?

      inhand_critters = /skayl|glacei|tumbleweed|plant|shrub|creeper|vine|bush|caedera|golem|elemental/

      objs.each do |thing|
        next if (ELoot.data.settings[:critter_exclude].length.positive? && thing.name =~ Regexp.union(ELoot.data.settings[:critter_exclude]))
        next if thing.status =~ /gone/

        ELoot.change_stance(100) if ELoot.data.settings[:loot_defensive]

        if thing.name =~ inhand_critters
          (thing.name =~ /tumbleweed|plant|shrub|creeper|vine|bush/) ? Inventory.free_hands(left: true) : Inventory.free_hand
          if GameObj.right_hand.id.nil? && GameObj.left_hand.id.nil?
            free_hand = "left"
          else
            free_hand = GameObj.right_hand.id.nil? ? "right" : "left"
          end
        end

        # Loot it
        3.times do
          waitrt?
          res = dothistimeout("loot ##{thing.id}", 1, /You (search|plunge|break)|not in any condition|see well enough to search|You can only loot creatures/)

          if res =~ /not in any condition/ &&
             ELoot.data.settings[:sigil_determination_on_fail] &&
             Spell['Sigil of Determination'].affordable? &&
             !Spell['Sigil of Determination'].active?
            Spell['Sigil of Determination'].cast
            next
          end

          break if res =~ /You (search|plunge|break)|not in any condition|see well enough to search|You can only loot creatures/ ||
                   thing.nil? || thing.status =~ /gone/
        end

        # Some creatures put an item directly in your hand
        if thing.name =~ inhand_critters
          check_hand = (free_hand == "right") ? GameObj.right_hand : GameObj.left_hand
          Inventory.single_drag(check_hand) unless check_hand.name == "Empty"
        end
      end

      # if the setting is on always end in defensive
      ELoot.change_stance(100) if ELoot.data.settings[:loot_defensive]
    end

    def self.skin_obj_types(objs, type) # skins type (blunt/dagger) group of dead critters
      return if objs.empty?

      dont_stow = false
      waitrt?

      if type == :blunt
        skinner = ELoot.data.skin_blunt
        ELoot.msg(type: "debug", text: " blunt skinner: #{skinner} blunt skinner.id: #{skinner.id}")
        unless skinner
          ELoot.msg(type: "info", text: " No blunt weapon found. Please run setup and make sure its listed.")
          return
        end
        Inventory.free_hands(both: true)
      else
        if ELoot.data.skin_edged.to_s.empty? || ELoot.data.skin_edged.nil?
          skinner = GameObj.right_hand
          ELoot.msg(type: "info", text: " No edged skinning weapon found. Using your right hand.")
        else
          skinner = ELoot.data.skin_edged
        end

        ELoot.msg(type: "debug", text: " edged skinner: #{skinner} edged skinner.id: #{skinner.id}")

        dont_stow = true if [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)

        unless dont_stow
          Inventory.free_hand
        end
      end

      unless [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
        waitrt?
        Inventory.drag(skinner)
      end

      skinner_hand = skinner.id == GameObj.left_hand.id ? 'left' : 'right'

      # Safe to kneel?
      while GameObj.targets.empty? && ELoot.data.settings[:skin_kneel] && !kneeling?
        dothistimeout('kneel', 3, /You kneel down\.$|You move to|You are already kneeling\.$/)
      end

      # Sigil of Resolve?
      if ELoot.data.settings[:skin_resolve] &&
         Spell['Sigil of Resolve'].affordable? &&
         !Spell['Sigil of Resolve'].active?
        Spell['Sigil of Resolve'].cast
      end

      # 604 stuff
      if ELoot.data.settings[:skin_604] && Spell[604].affordable? && (!Spell[604].active? || (Spell[604].timeleft * 60).truncate() <= 10)
        until Spell[604].active? && (Spell[604].timeleft * 60).truncate() > 5
          Spell[604].cast
          sleep(0.1)
        end
      end

      skin_match = Regexp.union(
        /You skinned/i,
        /You botched/i,
        /already been/i,
        /cannot skin/i,
        /must be a member/i,
        /can only skin/i,
        /You are unable to break through/i,
        /You break through the crust of the/i,
        /You crack open a portion/i,
        /Because your account is free/i,
        /it's not possible to get a worthwhile/i,
      )

      break_match = Regexp.union(
        /You break through the crust of the .+ and withdraw (.+)!/i,
        /You crack open a portion of the .+ and uncover (.+)!/i,
      )

      # Skin em
      objs.each do |obj|
        res = dothistimeout("skin ##{obj.id} #{skinner_hand}", 2, skin_match)
        if res =~ /You cannot skin/
          ELoot.data.settings[:unskinnable].push(obj.name)
          ELoot.save_profile()
        elsif res =~ break_match
          fput "stow gem ##{GameObj.left_hand.id}"
        end
      end

      waitrt?

      return if dont_stow

      if type == :blunt
        bag = ELoot.data.ready_list["skin_sheath_blunt"].nil? ? ELoot.data.sacks["default"] : ELoot.data.ready_list["skin_sheath_blunt"]
      else
        bag = ELoot.data.ready_list["skin_sheath"].nil? ? ELoot.data.sacks["default"] : ELoot.data.ready_list["skin_sheath"]
      end

      Inventory.store_item(bag, skinner, true)

      if [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
        Inventory.store_item(ELoot.data.sacks["default"], skinner)
      end
    end

    def self.skin(objs = GameObj.dead.to_a) # determines what to skin
      objs = objs.reject do |obj|
        (ELoot.data.settings[:unskinnable].include?(obj.name) && !Loot.occassional_skinner(obj)) ||
          obj.type =~ /bandit/ ||
          obj.name =~ /(?:ethereal|ghostly|unwordly|Grimswarm)/ ||
          ELoot.data.settings[:skin_exclude].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:skin_exclude]) ||
          ELoot.data.settings[:critter_exclude].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:critter_exclude])
      end

      return if objs.empty?

      blunts = objs.find_all { |obj| obj.name =~ /krynch|stone mastiff|krag dweller|cavern urchin/i }
      normals = objs.reject { |obj| obj.name =~ /krynch|stone mastiff|krag dweller|cavern urchin/i }

      skin_obj_types(normals, :normal)
      skin_obj_types(blunts, :blunt)

      new_stance = percentstance
      unless standing?
        ELoot.change_stance(0) if GameObj.targets.empty?
        dothistimeout('stand', 3, /You stand|You quickly roll|You are already standing/) until standing?
        ELoot.change_stance(new_stance) if percentstance != new_stance
      end
    end
  end # End of Loot

  # Sell is a module that handles selling loot
  module Sell
    def self.appraise(item, location, _data = nil)
      return if item.type =~ /jewelry/ && location == "pawnshop"

      amount = 0
      raw = nil

      limit = location =~ /gemshop/i ? ELoot.data.settings[:sell_appraise_gemshop] : ELoot.data.settings[:sell_appraise_pawnshop]

      high_value = /not buying anything this valuable today/
      denied = Regexp.union(
        /That thing's worth less/,
        /Can't say I'm interested/,
        /That's basically worthless here/,
        /He hands it back to you, saying/,
        /Not my line, really/,
        /not quite my field/,
        /only deal in gems and jewelry/,
        /There is nothing of value to me/,
        /Trying to pull a fast one on old Hortemeyer, are you\?/,
        /no use for that/,
        /Appraise what\?\?\?/,
      )
      appraised = /([,0-9]+) (?:silver|for it if you want to sell|for this if you'd like)/
      sold = Regexp.union(
        /(?:pays|hands) you [,0-9]+ silver/,
        /I don't have that much spare silver, I will have to give you a bank note for it/,
        /I'm afraid I don't have that much silver on hand.+so I'll have to give you a .+ for it./,
      )
      item_selling_match = Regexp.union(high_value, denied, appraised, sold)

      res = dothistimeout "appraise ##{item.id}", 3, item_selling_match

      if res =~ appraised
        raw = $1
        amount = $1.delete(",").to_i
      end

      if amount > limit.to_i || res =~ high_value
        message = amount > limit.to_i ? " The #{item} appraises for #{raw}. That's above your settings." : " The #{item} appraises as too valuable to sell."
        ELoot.msg(type: "info", text: message)
        if ELoot.data.sacks[ELoot.data.settings[:appraisal_container]].to_s.empty?
          Inventory.single_drag(item)
        else
          Inventory.store_item(ELoot.data.sacks[ELoot.data.settings[:appraisal_container]], item)
        end
      elsif amount <= limit.to_i && amount != 0
        Sell.sell_item(item, location, ELoot.data.silver_breakdown)
      else
        Inventory.single_drag(item)
      end
    end

    def self.box_in_hand(deposit = true)
      return unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")

      if [GameObj.left_hand.noun, GameObj.right_hand.noun].include?("reliquary")
        ELoot.msg(text: " Looks like you have a reliquary", space: true)
        exit
      end

      loop do
        item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" }
        break unless item && ELoot.data.settings[:sell_locksmith_pool]

        Sell.locksmith_pool([item], deposit)

        # check if still the same item. If it is then pool is full
        break if item.id == [GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" }.id
      end

      if (item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" }) && ELoot.data.settings[:sell_locksmith]
        Sell.locksmith([item])
      end

      if ([GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" })
        ELoot.msg(text: " Not able to process the box in your hand. Exiting...", space: true)
        exit
      end
    end

    def self.breakdown
      return if ELoot.data.silver_breakdown.empty? && ELoot.data.horde_deposit.empty?
      return unless defined?(Terminal)
      rows = []

      unless ELoot.data.silver_breakdown.empty?
        total_silver = 0

        ELoot.data.silver_breakdown.each { |location, amount|
          total_silver += amount
          rows << [location, "   " + ELoot.format_number(amount)]
        }

        rows << :separator
        rows << ["Total", ELoot.format_number(total_silver)]
      end

      if ELoot.data.horde_deposit.length.to_i.positive?
        all_gems = ELoot.data.horde_deposit.find_all { |item| item[:type] == 'gem' }

        unless all_gems.length.to_i.zero?
          unique_gems = all_gems.uniq { |item| item[:item] }
          rows << :separator
          rows << [{ value: 'Gems Horded', colspan: 2, alignment: :center }]
          rows << :separator

          unique_gems.each { |obj|
            count = ELoot.data.horde_deposit.find_all { |item| item[:item] == obj[:item] }.length.to_i
            rows << [ELoot.capitalize_words(obj[:item]), "   " + count.to_s]
          }
        end

        all_reagents = ELoot.data.horde_deposit.find_all { |item| item[:type] == 'reagent' }

        unless all_reagents.length.to_i.zero?
          unique_reagents = all_reagents.uniq { |item| item[:item] }
          rows << :separator
          rows << [{ value: 'Reagents Horded', colspan: 2, alignment: :center }]
          rows << :separator
          unique_reagents.uniq!.each { |obj|
            count = ELoot.data.horde_deposit.find_all { |item| item[:item] == obj[:item] }.length.to_i
            rows << [ELoot.capitalize_words(obj[:item]), "   " + count.to_s]
          }
        end
      end

      table = Terminal::Table.new :title => "Eloot Breakdown", :rows => rows # , :style => {:all_separators => true}
      table.align_column(1, :right)

      ELoot.wait_rt
      respond
      respond table
      respond
      ELoot.wait_rt
      return
    end

    def self.break_rocks
      rock_sacks = Array.new
      rock_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        rock_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        rock_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      rock_sacks.each do |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.type =~ /breakable/ }.empty?
        sack.contents.each do |item|
          next unless item.type =~ /breakable/

          Inventory.drag(item)
          ELoot.get_res("break ##{item.id}", /You squeeze the chunk of rock/)

          Inventory.free_hands(both: true)
        end
      end
    end

    def self.check_bounty_furrier
      need_furrier = false

      if checkbounty =~ /You have been tasked to retrieve (\d+) (.*) of at least \w+ quality for (?:the )?\w+ (?:in|on|near) (?:(.*) (?:under|near|between) )?(?:the Company Store in )?([^.]+)\./
        skin = $2
        skin = skin =~ /antlers/ ? 'antlers' : skin

        bundled_skins = skin.match(/(\w+)\s+(\w+)\s*\Z/)

        # fucked up skins
        skin = skin.strip.downcase
                   .gsub(/s$/, "")
                   .gsub(/teeth/, "tooth")
                   .gsub(/hooves?/, "hoof")
                   .gsub(/ruffs?/, "ruff")

        skin_sacks = Array.new
        skin_sacks.push(ELoot.data.sacks["skin"]) if ELoot.data.settings[:sell_container].include?("skin")
        skin_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
        if ELoot.data.settings[:sell_container].include?("overflow")
          skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
          skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
        end

        skin_sacks.each do |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ /#{skin}|#{bundled_skins}/i }.empty?

          need_furrier = true
        end
      end

      if need_furrier && ELoot.data.settings[:sell_loot_types].include?("skin")
        ELoot.return_from_fwi
        ELoot.data.local_furrier = Room.current.find_nearest_by_tag("furrier")

        # fixme - check for actual bounty town

        ELoot.go2(ELoot.data.local_furrier)
        start_silvers = ELoot.silver_check
        bulk_note = 0

        ELoot.msg(type: "debug", text: "  check_bounty | skin_sacks: #{skin_sacks}")
        skin_sacks.each do |sack|
          next if sack.nil?
          next unless ELoot.data.settings[:sell_loot_types].include?("skin") || ELoot.data.settings[:sell_loot_types].include?("reagent")
          next if sack.contents.find_all { |obj| obj.name =~ /#{skin}|#{bundled_skins}/i }.empty?

          bulk_sell = true
          bulk_sell = false if sack.contents.find_all { |obj| obj.name =~ /bundle of/ }.length.positive?
          unless ELoot.data.settings[:sell_exclude].empty?
            if sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /furrier/ }.length.positive?
              bulk_sell = false
            end
          end

          bulk_sell = false if sack.contents.find_all { |obj| obj.name !~ /#{skin}/ && obj.sellable =~ /furrier/ }.length.positive?

          if bulk_sell
            ELoot.msg(type: "debug", text: " check_bounty | bulk_sell: #{bulk_sell} using sack: #{sack}")
            Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

            dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
            Inventory.wear(sack)

            bulk_note = ELoot.read_note.to_i

            if bulk_note.positive?
              ELoot.data.silver_breakdown["Furrier"] += bulk_note
            end

            sleep 0.5
          else
            sack.contents.each do |item|
              next if $sell_ignore.include?(item.id)
              next unless item.sellable =~ /furrier/
              next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
              next unless item.name =~ /#{skin}|#{bundled_skins}/i

              $sell_ignore.push(item.id)
              Inventory.drag(item)

              if item.name =~ /bundle/
                # grab the bundle ID
                bundle_id = !GameObj.right_hand.id.nil? ? GameObj.right_hand.id : GameObj.left_hand.id

                until ![GameObj.right_hand.id, GameObj.left_hand.id].include?(bundle_id)
                  # remove a skin
                  result = dothistimeout "bundle remove", 5, /You remove|Those were the last two/

                  if result =~ /Those were the last two/
                    Sell.sell_item(GameObj.right_hand, "Furrier", ELoot.data.silver_breakdown)
                    Sell.sell_item(GameObj.left_hand, "Furrier", ELoot.data.silver_breakdown)
                  else
                    # get the skin id
                    skin = GameObj.right_hand.id != bundle_id ? GameObj.right_hand : GameObj.left_hand
                    # Sell.sell_item(skin)
                    Sell.sell_item(skin, "Furrier", ELoot.data.silver_breakdown)
                  end

                end

              else
                Sell.sell_item(item, "Furrier", ELoot.data.silver_breakdown)
                # Sell.sell_item(item)
              end
            end
          end

          Inventory.free_hands(both: true)
          ELoot.msg(type: "debug", text: "  check_bounty | bottom of each using sack: #{sack}")
        end

        ELoot.data.silver_breakdown["Furrier"] += (ELoot.silver_check - start_silvers)
      end
    end

    def self.check_bounty_gems
      need_gemshop = false

      if checkbounty =~ /The gem dealer in .*, .*, has received orders from multiple customers requesting (?:a|an|some) (.*).  You have been tasked to retrieve (\d+) (?:more of|of) them.  You can SELL them to the gem dealer as you find them./i
        gem = $1.chop

        gem_sacks = Array.new
        gem_sacks.push(ELoot.data.sacks["gem"]) if ELoot.data.settings[:sell_container].include?("gem")
        gem_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
        if ELoot.data.settings[:sell_container].include?("overflow")
          gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
          gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
        end

        gem_sacks.each { |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ /#{gem}/ }.empty?

          need_gemshop = true
        }
      end

      if need_gemshop && ELoot.data.settings[:sell_loot_types].include?("gem")
        ELoot.return_from_fwi
        ELoot.data.local_gemshop = Room.current.find_nearest_by_tag("gemshop")

        ELoot.go2(ELoot.data.local_gemshop)
        start_silvers = ELoot.silver_check
        bulk_note = 0

        Inventory.free_hands(both: true)

        gem_sacks.each { |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ /#{gem}/ }.empty?

          bulk_sell = true
          bulk_sell = false if sack.contents.find_all { |obj| obj.name !~ /#{gem}/ && obj.type =~ /gem/ }.length.positive?
          unless ELoot.data.settings[:sell_exclude].empty?
            if sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /gemshop/ }.length.positive?
              bulk_sell = false
            end
          end
          # Bulk sell sack if it has gems and no exclusions
          if bulk_sell
            Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?
            dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
            Inventory.wear(sack)
            sleep 0.5
            bulk_note = ELoot.read_note.to_i
            if bulk_note > 0
              ELoot.data.silver_breakdown["Gemshop"] += bulk_note
            end

            Inventory.free_hands(both: true)

          else
            sack.contents.each do |item|
              next unless item.name =~ /#{gem}/

              Inventory.drag(item)
              Sell.sell_item(item, "Gemshop", ELoot.data.silver_breakdown)
              Inventory.free_hands(both: true)
            end
          end
        }

        ELoot.data.silver_breakdown["Gemshop"] += (ELoot.silver_check - start_silvers)
      end
    end

    def self.check_bounty
      Sell.check_bounty_furrier
      Sell.check_bounty_gems
    end

    def self.check_items(specific: nil, items: nil)
      selling = []

      all_contents = items.nil? ? Sell.check_inventory : items

      all_contents.each { |thing|
        next if $sell_ignore.include?(thing.id)
        next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
        next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
        next if thing.name =~ /\bbound\b|^shimmering \w+ orb$/
        next if selling.include?(thing.type) && !thing.type.nil?
        if !specific.nil?
          next unless specific.include?(thing.type)
        end

        if ELoot.data.alchemy_mode
          next if thing.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          next if thing.noun =~ /^(?:jar|beaker|bottle)$/ and thing.after_name.nil?
        end

        if thing.name =~ ELoot.data.regex_gold_rings && ELoot.data.settings[:sell_gold_rings]
          selling.push("chronomage") unless selling.include?("chronomage")
        elsif thing.type =~ /scarab/ && ELoot.data.settings[:sell_loot_types].include?("scarab")
          selling.push("gemshop") unless selling.include?("gemshop")
        elsif thing.type == "gem" && ELoot.data.settings[:sell_loot_types].include?("gem") && thing.noun =~ /thorn|berry/
          selling.push("gemshop") unless selling.include?("gemshop")
        elsif thing.type == "collectible" && ELoot.data.settings[:sell_collectibles]
          selling.push("collectibles") unless selling.include?("collectibles")
        elsif ELoot.data.settings[:sell_loot_types].include?("box") && thing.type == "box"
          selling.push("pawnshop") unless selling.include?("pawnshop")
        elsif !thing.sellable.nil? && thing.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          thing.sellable.to_s.split(',').each { |location|
            selling.push(location) unless selling.include?(location)
          }
        end
      }

      ELoot.msg(type: "debug", text: "Places to go: #{selling}")
      return selling
    end

    def self.check_inventory
      all_contents = []

      ELoot.data.sacks.keys.each do |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        Inventory.open_single_container(item)
        all_contents += ELoot.data.sacks[item].contents.to_a
      end

      if ELoot.data.settings[:use_disk]
        ELoot.wait_for_disk
        Inventory.open_single_container(ELoot.data.disk)
        all_contents += ELoot.data.disk.contents.to_a
      end

      # Remove items from all_contents if their id is in the $sell_ignore array
      all_contents.reject! { |thing| $sell_ignore.include?(thing.id) }

      return all_contents
    end

    def self.collectibles
      return unless ELoot.data.settings[:sell_collectibles]

      places = Array.new
      places.push(Room.current.find_nearest_by_tag("collectible")) unless Room.current.find_nearest_by_tag("collectible").nil?
      places.push(Room.current.find_nearest_by_tag("collectibles")) unless Room.current.find_nearest_by_tag("collectibles").nil?

      go_place = Room.current.find_nearest(places)

      ELoot.go2(go_place)

      Inventory.free_hands(both: true)

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      ELoot.data.sacks.keys.each { |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        ELoot.data.sacks[item].contents.each { |thing|
          next if $sell_ignore.include?(thing.id)
          next unless thing.type == "collectible"
          next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
          next if (thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
          next if thing.name =~ /bound/

          $sell_ignore.push(thing.id)
          Inventory.drag(thing)
          dothistimeout("deposit ##{thing.id}", 3, /You hand your/)

          20.times {
            break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(thing.id))

            sleep 0.1
          }

          Inventory.free_hands(both: true)
        }
      }
    end

    def self.consignment
      ELoot.go2("consignment")
      start_silvers = ELoot.silver_check
      Inventory.free_hands(both: true)

      consignment_sacks = Array.new
      consignment_sacks.push(ELoot.data.sacks["reagent"]) if ELoot.data.settings[:sell_container].include?("reagent")
      consignment_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        consignment_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        consignment_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      consignment_sacks.each { |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.sellable.include?("consignment") }.empty?

        # Still here so remove the sack from the array
        ELoot.data.sacks_full.delete(sack)

        sack.contents.each { |thing|
          next if $sell_ignore.include?(thing.id)
          next unless thing.sellable.include?("consignment")
          next unless thing.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
          next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
          next if thing.name =~ /bound/

          if ELoot.data.alchemy_mode
            next if thing.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(thing.id)
          Inventory.drag(thing)
          # Sell.sell_item(thing)
          Sell.sell_item(thing, "Consignment", ELoot.data.silver_breakdown)

          Inventory.free_hands(both: true)
        }
      }

      ELoot.data.silver_breakdown["Consignment"] += (ELoot.silver_check - start_silvers)
    end

    def self.custom_list(items)
      # put items into an array and clean up any weirdness
      items_array = items.gsub('/', '').split(/,|\|/).map(&:strip)

      # convert that into a regex
      items_regex = Regexp.new(items_array.join('|'))

      # get the Inventory
      all_contents = Sell.check_inventory

      # Find the items
      items_to_sell = all_contents.select { |item| item.name.match?(items_regex) }

      # check where to go for selling them
      locations = Sell.check_items(items: items_to_sell)

      # if its empty we are done
      return if locations.empty?

      Inventory.clear_hands

      # Go to each location and sell
      locations.each do |place|
        ELoot.go2(place)
        ELoot.wait_rt

        items_to_sell.each do |item|
          Inventory.drag(item)

          if item.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?
            Sell.appraise(item, place.capitalize, ELoot.data.silver_breakdown)
          else
            Sell.sell_item(item, place.capitalize, ELoot.data.silver_breakdown)
          end

          Inventory.free_hands(both: true)
        end
      end

      ELoot.silver_deposit(true)
      Inventory.return_hands
    end

    def self.custom_sellable(sellable)
      sellable_types = []

      # Split items into an array
      sellable_array = sellable.gsub('/', '').split(/,|\|/).map(&:strip)

      # Check to make sure the type exists in GameObj
      sellable_array.each { |item|
        if GameObj.sellable_data.keys.include?(item) || item =~ /collectible|chronomage/
          sellable_types << item
        else
          ELoot.msg(type: "yellow", text: "  #{item.capitalize} is not a valid sellable category.")
          tmp_sellable = GameObj.sellable_data.keys + ['collectible', 'chronomage']
          ELoot.msg(type: 'default', text: "  GameObj sellable: #{tmp_sellable}")
          exit
        end
      }

      # return unless there is a location
      return unless sellable_types.length.positive?
      locations = Sell.check_items

      Inventory.clear_hands

      Sell.check_bounty_gems if sellable_types.include?('gemshop')
      Sell.check_bounty_furrier if sellable_types.include?('furrier')

      # check if we still need to go to the gemshop or furrier
      if ['gemshop', 'furrier'].any? { |el| sellable_types.include?(el) }
        locations = Sell.check_items
      end

      remaining_sellable = locations & sellable_types

      # return if it's empty
      return if remaining_sellable.empty?

      Sell.go_sell(remaining_sellable)

      ELoot.silver_deposit(true)
      Inventory.return_hands
    end

    def self.custom_type(types)
      sell_types = []
      recheck = false

      # Split items into an array
      types_array = types.gsub('/', '').split(/,|\|/).map(&:strip)

      # Check to make sure the type exists in GameObj
      types_array.each { |type|
        if GameObj.type_data.keys.include?(type)
          sell_types << type
        else
          ELoot.msg(type: "yellow", text: "  #{type.capitalize} is not a valid GameObj type.")
          ELoot.msg(type: 'default', text: "  GameObj types: #{GameObj.type_data.keys}")
          exit
        end
      }

      # return if there are no valid types
      return unless sell_types.length.positive?

      Inventory.clear_hands

      # process boxes first
      Sell.process_boxes if sell_types.include?('box')

      # send the types thru check_items to get our selling locations
      locations = Sell.check_items(specific: sell_types)

      # if its empty we are done
      return if locations.empty?

      # buff up for sales!
      Sell.sell_buffs

      # If type is gem or skin - sell at bounty location
      if sell_types.include?('gem') && locations.include?("gemshop")
        Sell.check_bounty_gems
        recheck = true
      end

      if sell_types.include?('skin') && locations.include?("furrier")
        Sell.check_bounty_furrier
        recheck = true
      end

      # rechecking locations to see if we still need to go to the gemshop or furrier
      if recheck
        locations = Sell.check_items(specific: sell_types)
      end

      # if its empty we are done
      return if locations.empty?

      # finally lets go sell stuff
      Sell.gold_rings if locations.include?("chronomage")
      Sell.furrier if locations.include?("furrier")
      Sell.gemshop(sell_types) if locations.include?("gemshop")
      Sell.consignment if locations.include?("consignment")
      Sell.pawnshop(sell_types) if locations.include?("pawnshop")
      Sell.collectibles if locations.include?("collectibles")

      ELoot.silver_deposit(true)
      Inventory.return_hands
    end

    def self.dump_herbs_junk
      # What stuff are we supposed to dump?
      dump_stuff = Array.new
      ["herb", "junk", "food"].each { |item|
        if ELoot.data.settings[:sell_loot_types].include?(item)
          dump_stuff.push(item)
        end
      }

      # Return if nothing
      if dump_stuff.empty?
        return
      end

      # Do we have anything to dump?
      dump_items = Array.new
      sacks = [ELoot.data.sacks["default"], ELoot.data.sacks[ELoot.data.settings[:overflow_container]], ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]]]
      sacks.each { |sack|
        sack.contents.each { |item|
          if item.type =~ Regexp.union(dump_stuff) || (ELoot.data.alchemy_mode && item.name =~ /^some ground|flask of pure water|some powdered|some mashed|handful of sea salt|spirit shard|tincture of/)
            if ELoot.data.alchemy_mode
              next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
            end
            dump_items.push(item)
          end
        }
      }

      # No items to dump so return
      if dump_items.empty?
        return
      end

      # Is there a trash can here?
      trash = ELoot.find_trash

      unless trash
        # going here because they have trash cans. Don't want to litter
        if XMLData.game == 'GSF' && Room[Room.current.find_nearest_by_tag("town")].location == 'the tunnels and caverns of Zul Logoth'
          trash_spot = 1005
        else
          trash_spot = 'locksmith pool'
        end

        ELoot.go2(trash_spot)
        trash = ELoot.find_trash
      end

      if trash.nil?
        ELoot.msg(type: "info", text: " No trashcan found! Skipping herb/junk/food disposal so as not to litter and be a pest.")
        return
      end

      dump_items.each { |item|
        Inventory.drag(item)
        fput("put ##{item.id} in ##{trash.id}")

        20.times {
          break if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
          sleep 0.1
        }

        if [GameObj.right_hand.id, GameObj.left_hand.id].include?(item.id)
          ELoot.msg(type: "info", text: " #{item.name} isn't gone so maybe its special...keeping it.")
          Inventory.single_drag(item)
        end
      }

      Inventory.free_hands(both: true)
    end

    def self.furrier
      ELoot.go2("furrier")
      start_silvers = ELoot.silver_check
      bulk_note = 0

      Inventory.free_hands(both: true)

      skin_match = /You have been tasked to retrieve (\d+) (.*) of at least \w+ quality for (?:the )?\w+ (?:in|on|near) (?:(.*) (?:under|near|between) )?(?:the Company Store in )?([^.]+)\./

      skin_sacks = Array.new
      skin_sacks.push(ELoot.data.sacks["skin"]) if ELoot.data.settings[:sell_container].include?("skin")
      skin_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        skin_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      ELoot.msg(type: "debug", text: " skin_sacks: #{skin_sacks}")
      skin_sacks.each do |sack|
        ELoot.msg(type: "debug", text: " Beginning of skin_sack.each: #{sack}")
        next if sack.nil?
        next unless ELoot.data.settings[:sell_loot_types].include?("skin") || ELoot.data.settings[:sell_loot_types].include?("reagent")
        next if sack.contents.find_all { |obj| obj.sellable =~ /furrier/ }.empty?

        # Still here so remove the sack from the array
        ELoot.data.sacks_full.delete(sack)

        ELoot.msg(type: "debug", text: " Contents after next: #{sack.contents} using sack: #{sack}")
        bulk_sell = true
        bulk_sell = false if bounty? =~ skin_match && sack.contents.find_all { |obj| obj.name =~ /bundle/ }.length.positive?
        bulk_sell = false if ELoot.data.alchemy_mode
        unless ELoot.data.settings[:sell_exclude].empty?
          if sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /furrier/ }.length.positive?
            bulk_sell = false
          end
        end

        if bulk_sell
          ELoot.msg(type: "debug", text: " bulk_sell: #{bulk_sell} using sack: #{sack}")
          Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

          ELoot.silver_check

          dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
          Inventory.wear(sack)

          bulk_note = ELoot.read_note.to_i

          if bulk_note > 0
            ELoot.data.silver_breakdown["Furrier"] += bulk_note
          end

          sleep 0.5
        end

        Inventory.free_hands(both: true)

        sack.contents.each do |item|
          next if $sell_ignore.include?(item.id)
          next unless item.sellable =~ /furrier/
          next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/

          if ELoot.data.alchemy_mode
            next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(item.id)
          Inventory.drag(item)

          if item.name =~ /bundle/
            # grab the bundle ID
            bundle_id = !GameObj.right_hand.id.nil? ? GameObj.right_hand.id : GameObj.left_hand.id

            until ![GameObj.right_hand.id, GameObj.left_hand.id].include?(bundle_id)
              # remove a skin
              result = dothistimeout "bundle remove", 5, /You remove|Those were the last two/

              if result =~ /Those were the last two/
                Sell.sell_item(GameObj.right_hand, "Furrier", ELoot.data.silver_breakdown)
                Sell.sell_item(GameObj.left_hand, "Furrier", ELoot.data.silver_breakdown)
              else
                # get the skin id
                skin = GameObj.right_hand.id != bundle_id ? GameObj.right_hand : GameObj.left_hand
                # Sell.sell_item(skin)
                Sell.sell_item(skin, "Furrier", ELoot.data.silver_breakdown)
              end

            end

          else
            Sell.sell_item(item, "Furrier", ELoot.data.silver_breakdown)
          end
        end

        Inventory.free_hands(both: true)
        ELoot.msg(type: "debug", text: " bottom of each using sack: #{sack}")
      end

      ELoot.data.silver_breakdown["Furrier"] += (ELoot.silver_check - start_silvers)
    end

    def self.gemshop(type = nil)
      ELoot.go2("gemshop")
      start_silvers = ELoot.silver_check
      bulk_note = 0

      Inventory.free_hands(both: true)

      gem_sacks = Array.new
      gem_sacks.push(ELoot.data.sacks["gem"]) if ELoot.data.settings[:sell_container].include?("gem")
      gem_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
      if ELoot.data.settings[:sell_container].include?("overflow")
        gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
        gem_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
      end

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      gem_sacks.each { |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.sellable.include?("gemshop") }.empty?

        # Still here so remove the sack from the array
        ELoot.data.sacks_full.delete(sack)

        # Bulk sell sack if it has gems and no exclusions
        if (ELoot.data.settings[:sell_exclude].empty? || (sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.type =~ /gem/ }).empty?) && sack.contents.find_all { |obj| obj.type =~ /gem/ }.length.positive? && ELoot.data.settings[:sell_loot_types].include?("gem") && !ELoot.data.alchemy_mode
          if type.nil? || !type.nil? && type.includes?('gem')
            Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

            dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)

            Inventory.wear(sack)
            sleep 0.5

            bulk_note = ELoot.read_note.to_i

            if bulk_note > 0
              ELoot.data.silver_breakdown["Gemshop"] += bulk_note
            end

            Inventory.free_hands(both: true)
          end
        end

        # Loop thru remaining contents and sell/appraise whatever is left
        sack.contents.each do |item|
          next if $sell_ignore.include?(item.id)
          next unless item.sellable.include?("gemshop") || item.noun =~ /thorn|berry/ || item.type =~ /scarab/
          next unless item.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
          next if ELoot.data.settings[:sell_gold_rings] && item.name =~ ELoot.data.regex_gold_rings
          next if item.name =~ /\bbound\b|^shimmering \w+ orb$/
          if !type.nil?
            next unless type.include?(item.type)
          end

          if ELoot.data.alchemy_mode
            next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(item.id)
          if item.type =~ /cursed/
            if !ELoot.data.settings[:sell_loot_types].include?("cursed") || (!Spell[315].known? && item.name =~ /urglaes fang/)
              ELoot.msg(type: "info", text: "** #{item.name} is cursed. Can't touch that. You'll need to take a look", space: true)
              next
            elsif ELoot.data.settings[:sell_loot_types].include?("cursed")
              next unless ELoot.decurse(item)
            end
          end

          Inventory.drag(item)

          if item.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?
            Sell.appraise(item, "Gemshop", ELoot.data.silver_breakdown)
          else
            Sell.sell_item(item, "Gemshop", ELoot.data.silver_breakdown)
          end

          Inventory.free_hands(both: true)
        end
      }

      ELoot.data.silver_breakdown["Gemshop"] += (ELoot.silver_check - start_silvers)
    end

    def self.glam_and_shroud
      glam = Spell[1205]
      shroud = Spell[1212]

      if glam.known? && glam.affordable? && Effects::Spells.time_left("Glamour") < 1
        wait_until { glam.affordable? }
        glam.cast(Char.name)
      end

      if shroud.known?
        shroud_races = ['human',
                        'giantman',
                        'half-elf',
                        'sylvankind',
                        'dark elf',
                        'elf',
                        'dwarf',
                        'halfling',
                        'forest gnome',
                        'burghal gnome',
                        'half-krolvin',
                        'erithian',
                        'aelotoi']
        shroud_race_hash = { "vo"  => "human",
                             "ifw" => "dwarf",
                             "wl"  => "human",
                             "imt" => "halfling",
                             "rr"  => "human",
                             "kf"  => "human",
                             "en"  => "elf",
                             "ti"  => "dwarf",
                             "zl"  => "dwarf" }
        town = Room[Room.current.find_nearest_by_tag("town")]
        town_key = town.image.split("-")[0]
        if town.image =~ /zul/i
          town_key = "zl"
        end
        desired_race = shroud_race_hash[town_key]

        lines = ELoot.get_lines("fame", /<output class="mono"\/>/)

        if lines.any? { |line| line =~ /You are a level (?:\d+) ([\w\- ]+) (?:[\w\- ]+)\./ }
          current_race = $1.downcase()
          current_race_setting = shroud_races.index(current_race) + 1
        end

        return true if current_race == desired_race

        race_setting = shroud_races.index(desired_race) + 1
        if Effects::Spells.time_left("Shroud of Deception") < 2
          waitcastrt?
          wait_until { shroud.affordable? }
          shroud.cast(Char.name)
        end

        lines = ELoot.get_lines("shroud profile", /You are currently using profile/)

        if lines.any? { |line| line =~ /You are currently using profile <d cmd='shroud view [0-9]+'>([0-9]+)<\/d>./ }
          shroud_profile = $1
        end

        before_dying { fput("shroud set #{shroud_profile} race #{current_race_setting}") }
        fput("shroud set #{shroud_profile} race #{race_setting}")
      end
    end

    def self.go_sell(selling)
      return if selling.empty?

      Sell.sell_buffs

      rooms = Array.new
      selling.each { |shop|
        if Room[Room.current.find_nearest_by_tag("town")].uid.first == 7503205 && !ELoot.data.settings[:sell_fwi] # HW doesn't have some shops
          next if shop =~ /collect|pawnshop|consignment|chronomage/
        end

        next if shop == "chronomage" && ELoot.fwi?(Room.current) # No chronomage in FWI
        if shop == "chronomage" && !ELoot.fwi?(Room.current) && ELoot.data.settings[:sell_fwi]
          Sell.gold_rings
          next
        end

        room = Room.current.find_nearest_by_tag(shop)
        rooms.push(room) unless room.nil?
      }

      while rooms.any?
        # Find closest room
        _where_is_previous_var, where_is_shortest_distances_var = Room.current.dijkstra
        shortest_path = rooms.uniq.sort_by { |room| where_is_shortest_distances_var[room] }
        closest_room = shortest_path.first

        if percentencumbrance > 80
          ELoot.silver_deposit
        end

        Sell.gold_rings if Room[closest_room].tags.include?("chronomage")
        Sell.furrier if Room[closest_room].tags.include?("furrier")
        Sell.gemshop if Room[closest_room].tags.include?("gemshop")
        Sell.consignment if Room[closest_room].tags.include?("consignment")
        Sell.pawnshop if Room[closest_room].tags.include?("pawnshop")
        Sell.collectibles if Room[closest_room].tags.include?("collectibles") || Room[closest_room].tags.include?("collectible")

        rooms.delete(closest_room)
      end
    end

    def self.gold_rings
      return unless ELoot.data.settings[:sell_gold_rings]

      ELoot.go2("chronomage")

      Inventory.free_hands(both: true)

      unless (npc = GameObj.npcs.find { |n| n.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant|guard/ })
        npc = GameObj.room_desc.find { |n| n.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant|guard/ }
      end

      unless npc.nil?
        chrono_sacks = Array.new
        chrono_sacks.push(ELoot.data.sacks["default"]) if ELoot.data.settings[:sell_container].include?("default")
        if ELoot.data.settings[:sell_container].include?("overflow")
          chrono_sacks.push(ELoot.data.sacks[ELoot.data.settings[:overflow_container]])
          chrono_sacks.push(ELoot.data.sacks[ELoot.data.settings[:secondary_overflow]])
        end

        chrono_sacks.each { |sack| Inventory.open_single_container(sack) }

        chrono_sacks.each { |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ ELoot.data.regex_gold_rings }.empty?

          sack.contents.each do |item|
            next if $sell_ignore.include?(item.id)
            next unless item.name =~ ELoot.data.regex_gold_rings

            $sell_ignore.push(item.id)
            Inventory.drag(item)

            fput "give ##{item.id} to ##{npc.id}"

            20.times {
              break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))

              sleep 0.1
            }

            Inventory.free_hands(both: true)
          end
        }
      end
    end

    def self.inbetween_scripts
      return unless ELoot.data.settings[:between].length.positive?

      # go back to the start room before running scripts
      ELoot.go2(ELoot.data.start_room)

      ELoot.data.settings[:between].each do |i|
        tokens = i.split(/\s+/)
        if (tokens.size > 1)
          Script.run(tokens[0], tokens[1..-1].join(", "))
        else
          Script.run(tokens[0])
        end
      end
    end

    def self.locksmith(boxes)
      ELoot.msg(type: "debug", text: " locksmith called by #{caller[0]}")
      # if we're here, assume we emptied out the disk some
      ELoot.data.disk_full = false

      ELoot.silver_withdraw(8000)

      ELoot.go2('locksmith')
      move "east" if Room.current.uid.include?(7118381)
      ELoot.wait_for_disk

      if (table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /(?:table|counter)$/ })
        dothistimeout("look on ##{table.id}", 3, /On the/) if table.contents.nil?

        if table.contents.nil?
          error('failed to find table contents')
        else
          activator = nil
          if table.contents.any? { |obj| obj.noun == 'bell' }
            activator = 'ring bell'
          elsif table.contents.any? { |obj| obj.noun == 'keys' }
            activator = 'pull keys'
          elsif table.contents.any? { |obj| obj.noun == 'chime' } || GameObj.loot.any? { |obj| obj.noun == 'chime' }
            activator = 'ring chime'
          end

          if activator
            boxes.each { |box|
              Inventory.free_hands(both: true) unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
              Sell.locksmith_open(box, activator)
            }
          else
            ELoot.msg(type: "error", text: " Failed to find a bell, keys, or chime on the table", space: true)
          end
        end
      else
        ELoot.msg(type: "error", text: " Failed to find a table", space: true)
      end
    end

    def self.locksmith_open(box, activator)
      lines = ELoot.get_lines("look in ##{box.id}", /<container|That is closed|You see the shifting form/)
      return unless lines.any? { |line| line =~ /That is closed|You see the shifting form/i }

      Inventory.drag(box) unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
      box = ELoot.box_unphase(box)

      lines = ELoot.get_lines("open ##{box.id}", /open|locked/)

      if lines.any?(/locked/)
        res = dothistimeout(activator, 2, /Gimme ([\d,]+) silvers/)
        if res =~ /Gimme ([\d,]+) silvers/
          ELoot.data.silver_breakdown["Locksmith Pool"] += -1 * $1.delete(",").to_i
        end

        unless res
          ELoot.msg(type: "error", text: ' Unknown locksmith response.')
          Inventory.single_drag(box, false)
          return
        end

        result = dothistimeout('pay', 2, /accepts|have enough/)
        if result =~ /have enough/
          Inventory.single_drag(box, false)
          ELoot.silver_withdraw(8000)
          ELoot.go2('locksmith')

          return Sell.locksmith_open(box, activator)
        end
      end
      Loot.box_loot(box, "Locksmith", ELoot.data.silver_breakdown)
    end

    def self.locksmith_pool(boxes, deposit = false)
      # make sure some type of tipping was selected
      unless ELoot.data.settings[:use_standard_tipping] || ELoot.data.settings[:use_incremental_tipping]
        ELoot.msg(type: "yellow", text: ' No tipping options selected in UI')
        exit
      end

      match = /You want a locksmith|You don't have that much|takes your|already holding as many boxes|already (unlocked|open)/
      percent = ELoot.data.settings[:sell_locksmith_pool_tip_percent] ? ' PERCENT' : ''
      pool_count = 0
      result = nil

      # if we're here, assume we will empty out the disk
      ELoot.data.disk_full = false

      if boxes.length.positive? && ELoot.data.settings[:use_standard_tipping]
        amount = ELoot.data.settings[:sell_locksmith_pool_tip_percent] ? 8000 : boxes.length * ELoot.data.settings[:sell_locksmith_pool_tip].to_i
        ELoot.silver_withdraw(amount)
      end

      ELoot.go2('locksmith pool')
      original_pool = Room.current.id
      worker = ELoot.find_worker

      # if using incremental tipping, need to find out how many boxes are in the pool
      if boxes.length.positive? && ELoot.data.settings[:use_incremental_tipping]
        pool_count = Sell.locksmith_pool_count(worker)
        if pool_count > 99
          ELoot.msg(type: "yellow", text: " No room in the locksmith pool")
          return if deposit

          ELoot.msg(type: "yellow", text: " Checking to see if any boxes available for return")
          Sell.pool_return(worker)
          pool_count = Sell.locksmith_pool_count(worker)
          return if pool_count > 99
        else
          total_tips = Sell.locksmith_determine_tip(pool_count, boxes.length)
          ELoot.silver_withdraw(total_tips)
          ELoot.go2(original_pool)
          worker = ELoot.find_worker
        end
      end

      Inventory.free_hands(both: true) unless [GameObj.right_hand, GameObj.left_hand].find { |hand| hand.type =~ /box/ }
      ELoot.wait_for_disk

      boxes.each do |box|
        Inventory.drag(box) unless [GameObj.right_hand, GameObj.left_hand].find { |hand| hand.type =~ /box/ }

        unless GameObj.right_hand.id == box.id
          fput "swap"
          ELoot.wait_rt
        end

        box = ELoot.box_unphase(box)

        case
        when ELoot.data.settings[:use_standard_tipping]
          tip_amount = "#{ELoot.data.settings[:sell_locksmith_pool_tip].to_i}#{percent}"
        else
          tip_amount = Sell.locksmith_determine_tip(pool_count, 1)
        end

        redo_needed = false
        2.times do
          result = dothistimeout("give ##{worker.id} #{tip_amount}", 3, match)

          case result
          when /Your tip of (.*) silvers?/
            ELoot.data.silver_breakdown["Locksmith Pool"] += -1 * $1.delete(",").to_i
            pool_count += 1
            if pool_count > 99
              ELoot.msg(type: "yellow", text: " That was the last spot open in the pool")
              return true if deposit

              ELoot.msg(type: "yellow", text: " Checking to see if any boxes available for return")
              Sell.pool_return(worker)
              pool_count = Sell.locksmith_pool_count(worker)
            end
          when /You don't have that much/
            ELoot.silver_withdraw(8000)
            ELoot.go2(original_pool)
            redo_needed = true
          when /already holding as many boxes/
            ELoot.wait_rt
            Inventory.single_drag(box)
            ELoot.msg(type: "yellow", text: " That was the last spot open in the pool")
            return true if deposit

            ELoot.msg(type: "yellow", text: " Checking to see if any boxes available for return")
            Sell.pool_return(worker)
            pool_count = Sell.locksmith_pool_count(worker)
            redo_needed = true
          when /already (unlocked|open)/
            Loot.box_loot(box, "Locksmith Pool", ELoot.data.silver_breakdown)
          end
        end

        break if pool_count > 99
        redo if redo_needed
      end

      Inventory.free_hands(both: true)

      # Return if its just drop off
      return if deposit

      # retrieve (and loot) any boxes in the pool
      Sell.pool_return(worker)
    end

    def self.pool_return(worker)
      loop do
        match = /We don't have any boxes ready for you|We don't seem to have that box|Alright, here's your|You need to lighten your load first/
        res = dothistimeout("ask ##{worker.id} for return", 3, match)

        break if res !~ /Alright, here's your|You need to lighten your load first/

        if res =~ /You need to lighten your load first/
          ELoot.msg(type: "info", text: " Too much weight! Depositing coins and trying again")
          room = Room.current.id
          ELoot.silver_deposit
          ELoot.go2(room)
        else
          box = nil
          if GameObj.right_hand.type =~ /box|plinite/
            box = GameObj.right_hand
          elsif GameObj.left_hand.type =~ /box|plinite/
            box = GameObj.left_hand
          else
            ELoot.msg(type: "error", text: " Failed to find the box you were supposed to get; report this to Elanthia-Online")
          end

          Loot.box_loot(box, "Locksmith Pool", ELoot.data.silver_breakdown)
        end

        ELoot.wait_rt
      end
    end

    def self.locksmith_pool_count(worker)
      current_box_amount = 0
      list_match = /here's the list of boxes we have for you\.|You haven't given us any boxes to be worked on\./
      results = ELoot.get_lines("ask ##{worker.id} about list", list_match)

      results.reverse.each do |line|
        if line =~ /^\s*(?<amount>\d+)\.\s+An?/
          current_box_amount = Regexp.last_match[:amount].to_i
          break
        end
      end

      current_box_amount = current_box_amount - (results.select { |line| line =~ /ASK worker TO RETURN/ }.count) + 1
    end

    def self.locksmith_determine_tip(pool_count, boxes_length)
      tip_amount = 0
      upper_limit = [pool_count + (boxes_length - 1), 100].min

      (pool_count..upper_limit).each do |items|
        tip_amount += Sell.locksmith_tip(items, ELoot.data.settings[:base_tip], ELoot.data.settings[:max_tip], ELoot.data.settings[:alpha_rate])
      end

      return tip_amount.ceil
    end

    def self.locksmith_tip(box_no, base_tip, max_tip, alpha)
      factor = (box_no).to_f / 100
      adjusted_tip = base_tip + (factor**alpha) * (max_tip - base_tip)
      adjusted_tip.round # return an integer
    end

    def self.pawnshop(type = nil)
      ELoot.go2("pawnshop")
      start_silvers = ELoot.silver_check
      Inventory.free_hands(both: true)

      # Assume bags will be emptied after sell routine
      # Fixme - check which bags are used
      ELoot.data.sacks_full = Array.new

      all_contents = Array.new
      ELoot.data.sacks.keys.each { |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        all_contents += ELoot.data.sacks[item].contents.to_a
      }

      if ELoot.data.settings[:use_disk]
        ELoot.wait_for_disk
        Inventory.open_single_container(ELoot.data.disk)
        all_contents += ELoot.data.disk.contents.to_a
      end

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      all_contents.each { |thing|
        next if $sell_ignore.include?(thing.id)
        next unless (thing.sellable.include?("pawnshop") && !thing.sellable.include?("gemshop")) || thing.type == "box"
        next if ELoot.data.ready_list.find { |_k, v| v.id == thing.id }
        next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
        next unless thing.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
        next if thing.name =~ /bound/
        next if thing.name =~ /\bbound\b|^shimmering \w+ orb$/
        next if ELoot.data.settings[:sell_gold_rings] && thing.name =~ ELoot.data.regex_gold_rings
        if !type.nil?
          next unless type.include?(item.type)
        end

        $sell_ignore.push(thing.id)
        if thing.type =~ /scroll/ && ELoot.data.settings[:sell_keep_scrolls].length.positive?
          lines = ELoot.get_lines("read ##{thing.id}", /It takes you a moment|There is nothing there to read|You can't do that/)
          next if lines.any? { |line| line =~ /\((?:#{ELoot.data.settings[:sell_keep_scrolls].join("|")})\)/i }
        end

        if thing.type =~ /cursed/ && !ELoot.data.settings[:sell_loot_types].include?("cursed")
          ELoot.msg(type: "info", text: "** #{thing.name} is cursed. Can't touch that. You'll need to take a look", space: true)
          next
        elsif thing.type =~ /cursed/ && ELoot.data.settings[:sell_loot_types].include?("cursed")
          next unless ELoot.decurse(thing)
        end

        Inventory.drag(thing)

        lines = ELoot.get_lines("analyze ##{thing.id}", /You analyze/)
        if lines.any?(/ALTER 41/)
          ELoot.msg(type: "info", text: "** This analyzes as Alter 41. Keeping it **", space: true)
          Inventory.single_drag(thing)
          next
        end

        if (thing.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?) || thing.type =~ /uncommon|weapon|armor/
          Sell.appraise(thing, "Pawnshop", ELoot.data.silver_breakdown)
        elsif thing.type =~ /box/
          line = ELoot.get_res("look in ##{thing.id}", ELoot.data.look_regex)
          if line =~ /There is nothing|In the/i

            thing.contents.each { |box_item|
              if box_item.type =~ /cursed/ && Spell[315].known? && Spell[315].affordable? && ELoot.data.settings[:sell_loot_types].include?("cursed")
                Spell[315].cast("at ##{box_item.id}")
              elsif box_item.type =~ /cursed/ && !ELoot.data.settings[:sell_loot_types].include?("cursed")
                ELoot.msg(type: "info", text: "** #{box_item.name} is cursed. Stowing box. You'll need to take a look", space: true)
                Inventory.single_drag(thing, false)
              else
                Inventory.single_drag(box_item, false)
              end
            }
            # Sell.sell_item(thing)
            Sell.sell_item(thing, "Pawnshop", ELoot.data.silver_breakdown)
          elsif line =~ /That is closed/i
            # This shouldn't happen
            ELoot.msg(type: "info", text: "** #{thing.name} is closed. Storing box...")
            Inventory.single_drag(thing, false)
          end
        else
          Sell.sell_item(thing, "Pawnshop", ELoot.data.silver_breakdown)
        end

        Inventory.free_hands(both: true)
      }

      ELoot.data.silver_breakdown["Pawnshop"] += (ELoot.silver_check - start_silvers)
    end

    def self.pool(deposit = false)
      # Make sure we can see all the containers
      ELoot.data.sacks.keys.each { |item|
        next unless ELoot.data.settings[:sell_container].include?(item)

        Inventory.open_single_container(item)
      }

      room = Room.current.id
      ELoot.disk_usage
      Sell.box_in_hand(deposit)
      boxes = ELoot.find_boxes
      ELoot.data.right_hand = GameObj.right_hand
      ELoot.data.left_hand = GameObj.left_hand
      Inventory.free_hands(both: true)
      Sell.locksmith_pool(boxes, deposit)
      ELoot.silver_deposit(true) if deposit

      ELoot.go2(room)
      Inventory.return_hands
    end

    def self.process_boxes
      boxes = ELoot.find_boxes

      cur_len = boxes.length.to_i
      ELoot.msg(type: "debug", text: "ELoot.sell: Boxes length: #{cur_len}")

      # Process boxes in the locksmithpool
      if (ELoot.data.settings[:sell_locksmith_pool] && boxes.length.positive?) || ELoot.data.settings[:always_check_pool]
        Sell.locksmith_pool(boxes)

        # refresh the boxes
        boxes = ELoot.find_boxes
      end

      # Sell off any remaining boxes
      Sell.locksmith(boxes) if ELoot.data.settings[:sell_locksmith] && boxes.length.positive?
    end

    def self.save_trash_box(box)
      # Lets not toss Reliquaries
      if box.name =~ /reliquary/i
        Inventory.single_drag(box, false)
        return
      end

      return_room = Room.current.id

      ELoot.msg(type: "debug", text: " save_trash_box(box): looking for a trashcan")
      trash = ELoot.find_trash

      unless trash
        # going here because they have trash cans. Don't want to litter
        if XMLData.game == 'GSF' && Room[Room.current.find_nearest_by_tag("town")].location == 'the tunnels and caverns of Zul Logoth'
          trash_spot = 1005
        else
          trash_spot = 'locksmith pool'
        end

        ELoot.go2(trash_spot)
        trash = ELoot.find_trash
      end

      if ELoot.data.settings[:sell_loot_types].include?("box") && box.name =~ /gold|mithril|silver/ && !box.contents.find { |obj| obj.type =~ /cursed/ }
        ELoot.msg(type: "debug", text: " save_trash_box(box): inside first if")
        if !box.contents.empty?
          box.contents.each { |item|
            Inventory.drag(item)
            fput("put ##{item.id} in ##{trash.id}")
            sleep(0.5)
            if [GameObj.right_hand.id, GameObj.left_hand.id].include?(item.id)
              ELoot.msg(type: "info", text: " #{item.name} isn't gone so maybe its special...keepin it.")
              Inventory.single_drag(item)
            end
          }
        end
        Inventory.single_drag(box, false)
        return
      end

      if trash.nil?
        fput("drop ##{box.id}")
      else
        ELoot.msg(type: "debug", text: " save_trash_box(box): putting it in trash")
        # use a loop, dothistimeout and a timer - getting stuck with a ...wait after getting coins
        t = Time.now + 3
        loop {
          dothistimeout "put ##{box.id} in ##{trash.id}", 1, /As you place|If you wish to continue/
          if ![GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id) || Time.now > t
            break
          end
        }
      end

      fput("drop ##{box.id}") if [GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
      ELoot.go2(return_room)
    end

    def self.sell
      fput('unhide') if (hidden? || invisible?)

      Sell.box_in_hand

      Inventory.clear_hands

      Sell.process_boxes

      Sell.inbetween_scripts

      # Break rocks
      Sell.break_rocks if ELoot.data.settings[:sell_loot_types].include?("breakable")

      # Horde Stuff
      if ELoot.data.settings[:gem_horde] || ELoot.data.settings[:alchemy_horde]
        Horde.horde_items
      end

      # Check Bounties
      Sell.check_bounty

      Sell.go_sell(Sell.check_items)

      ELoot.silver_deposit(true)

      # If herb or junk is checked for selling we dump it. Only default and overflow
      Sell.dump_herbs_junk

      Inventory.return_hands

      # Close any containers that were opened
      Inventory.close_sell_containers if ELoot.data.settings[:keep_closed]
    end

    def self.sell_buffs
      Sell.glam_and_shroud if ELoot.data.settings[:sell_shroud]

      if ELoot.data.settings[:sell_aspect] && Spell[650].known? && !Spell[9018].active? && !Spell[9019].active?
        if Spell[650].affordable? && !Spell[650].active?
          multifput("prep 650", "assume lion")
        elsif Spell[650].active? && checkmana(25)
          waitcastrt?
          fput "assume lion"
        end
      end
    end

    def self.sell_item(item, place = nil, data = nil)
      return if item.nil? || item.name == "Empty"

      lines = ELoot.get_command("sell ##{item.id}", /You (offer to sell|ask)/)

      return if lines.any?(/That's not quite my field|That's basically worthless here|Can't say I'm interested in that|This is a pawnshop, sir, not a junkshop|The company don't buy trash|as if you were a lunatic/)

      20.times {
        break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))

        sleep 0.1
      }

      bulk_note = ELoot.read_note.to_i

      if bulk_note > 0
        data[place] += bulk_note
      end
    end
  end # End of Sell
end

ELoot.version_check

if Script.current.vars[1] =~ /ver/i
  echo "   Eloot Version: #{ELoot.get_script_version}"
  exit
end

if Spell['Berserk'].active?
  ELoot.msg(type: "info", text: " Berserk is active, preventing you from looting.", space: true)
  exit
end

# Fixme: need better way to start so it doesn't conflict with other autostart items
sleep 2 if Script.current.vars[1] =~ /start/

# Initialize/Load settings
unless ELoot.data
  waitrt?
  ELoot.load(ELoot.load_profile())
  ELoot.set_inventory
end

if !ELoot.data.settings[:track_full_sacks]
  ELoot.data.sacks_full = Array.new
  ELoot.data.disk_full = false
end

# Sorter shows inventory checks so we kill it and restart
ELoot.manage_sorter

# Default to loot
if Script.current.vars[1].nil?
  Thread.new { loop { Script.self.kill if dead?; sleep(5); } }
  ELoot.disk_usage
  ELoot.loot
  ELoot::Inventory.close_sell_containers if ELoot.data.settings[:keep_closed]

  exit
end

if Room.current.id.nil?
  ELoot.msg(type: "yellow", text: " Please start #{Script.current.name} in a mapped room", space: true)
  exit
else
  ELoot.data.start_room = Room.current.id
end

$sell_ignore ||= Array.new
ELoot.data.silver_breakdown = Hash.new

case Script.current.vars[0]
when /debug/
  ELoot::Setup.update_setting(:debug, !ELoot.data.settings[:debug])
  ELoot.data.settings[:debug] = !ELoot.data.settings[:debug]
  ELoot.save_profile(silent: true)
  exit
when 'start'
  exit
when 'list'
  ELoot::Setup.new(ELoot.data.settings).list if Script.current.vars[2].nil?
  ELoot::Setup.new(ELoot.data.settings).list(cat_to_list: Script.current.vars[2]) if !Script.current.vars[2].nil?
when /^box/
  if GameObj.right_hand.type =~ /box/
    box = GameObj.right_hand
    ELoot::Inventory.free_hands(left: true)
  elsif GameObj.left_hand.type =~ /box/
    box = GameObj.left_hand
    ELoot::Inventory.free_hands(right: true)
  elsif Script.current.vars[2] =~ /\A\d+\z/ # Fixme: intended to support ground looting items/boxes (mostly when picking boxes on the ground)
    box = GameObj.loot.find { |l| l.id =~ /#{Script.current.vars[2].to_i}/ }
  end

  ELoot::Loot.box_loot(box)
  ELoot.go2(ELoot.data.start_room)
when /^sell/
  # Assume bags will be emptied after sell routine
  ELoot.data.sacks_full = Array.new

  if Script.current.vars[2] == "alchemy_mode"
    ELoot.data.alchemy_mode = true
  end
  ELoot.disk_usage
  ELoot.sell
  ELoot.go2(ELoot.data.start_room)
  ELoot::Sell.breakdown
  ELoot.data.alchemy_mode = false
when /pool/
  deposit = Script.current.vars[2] =~ /depo/ ? true : false

  ELoot.disk_usage
  ELoot::Sell.pool(deposit)
when /--(sellable|type|sell)\s*=\s*(\/?[a-zA-Z,\s|]+\/?)/
  type = Regexp.last_match(1)
  things = Regexp.last_match(2)

  ELoot::Sell.custom_sellable(things) if type == 'sellable'
  ELoot::Sell.custom_type(things) if type == 'type'
  ELoot::Sell.custom_list(things) if type == 'sell'

  ELoot.go2(ELoot.data.start_room)
  ELoot::Sell.breakdown
when /settings|setup/
  if Script.current.vars[2]
    ELoot.update_setting(Script.current.vars[2..-1])
  elsif defined?(Gtk)
    ELoot.launch_settings_ui
  else
    ELoot.msg(text: " Gtk is not defined. Please use CLI to change options")
    ELoot.msg(text: " Format is #{$lich_char}#{Script.current.name} settings <setting_to_change> <new_value>")
    ELoot.msg(text: " To list settings #{$lich_char}#{Script.current.name} options")
  end
when 'options'
  ELoot.msg(type: "default", text: ELoot.data.settings.keys.sort.join("\n"))
when /raid/
  ELoot::Horde.raid_cache(Script.current.vars)
  ELoot.go2(ELoot.data.start_room)
when /(list|deposit|reset) (gem|reagent|alchemy)/
  do_what = $1
  item = $2
  if item =~ /reagent|alchemy/
    type = 'reagent'
  elsif item =~ /gem/
    type = 'gem'
  end
  case do_what
  when 'list'
    ELoot::Horde.list_inventory(type)
  when 'deposit'
    ELoot::Horde.horde_items(type, true)
  when 'reset'
    ELoot::Horde.reset_inventory(type)
    ELoot::Horde.list_inventory(type)
  end
  ELoot.go2(ELoot.data.start_room)
when /bounty/i
  ELoot::Horde.get_gem_bounty
when 'load'
  waitrt?
  ELoot.load(ELoot.load_profile)
  ELoot.set_inventory
when 'deposit'
  ELoot.silver_deposit(true)
  ELoot.go2(ELoot.data.start_room)
when 'test'
  ELoot.test
else
  ELoot.help
end
