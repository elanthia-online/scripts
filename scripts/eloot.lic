# frozen_string_literal: true

=begin
  eloot.lic: eLoot is fork/update/rewrite of sloot.

  Some primary changes from sloot include using in-game STOW settings instead of variables.
  Locksmith pool handling, loot room, exclusion support, appraise limits.
  eloot also auto-writes settings to your Lich5/Data/eloot folder per character.

            author: elanthia-online
   original author: SpiffyJr (sloot)
        maintainer: elanthia-online
      contributors: SpiffyJr, Athias, Demandred, Tysong, Deysh, Ondreian, Lieo, Lobe, Etheirys
              wiki: https://gswiki.play.net/Lich:Script_Eloot
              game: Gemstone
              tags: loot
          required: Lich >= 5.12.9
           version: 2.6.2
  Improvements:
  Major_change.feature_addition.bugfix
  v2.6.2  (2025-11-21)
    - force looting of bounty heirloom items if found
  v2.6.1  (2025-11-11)
    - bugfix in open_loot_containers
    - bugfix in get_weapon_inv
  v2.6.0  (2025-10-26)
    - add bloodband support
    - bugfix for save_trash_box method
    - bugfix box tipping default missing on first run
    - bugfix for open_single_container when using a string
    - moved tooltips out of UI xml
  v2.5.7  (2025-10-19)
    - bugfix for debt when entering locker
  v2.5.6  (2025-10-08)
    - bugfix for store/ready ranged_weapon to ranged
  v2.5.5  (2025-10-05)
    - bugfix for non-standard ready/stow list items
  v2.5.4  (2025-10-04)
    - bugfix for nil items
    - bugfix in logic for return_hands
  v2.5.3  (2025-10-03)
    - bugfix for return_hands
    - toggle righthand and lefthand off at initialization
    - minimum lich version to 5.12.9
  v2.5.2  (2025-10-02)
    - bugfix for incorrect method call typo
  v2.5.1  (2025-09-30)
    - bugfix for store/ready secondary_weapon to 2weapon
  v2.5.0  (2025-09-19)
    - switch to using Lich methods ReadyList and StowList
    - removed change log in script before 2.4.0. Full change log on the wiki
    - fix for SG trash can
  v2.4.11 (2025-09-12)
    - add option to always use the locksmith when a gem bounty is active
  v2.4.10 (2025-09-06)
    - rework box contents check to store box instead of pausing
    - bugfix for looting coins on the ground
  v2.4.9 (2025-09-05)
    - bugfix in regex for use_coin_hand method
  v2.4.8 (2025-08-30)
    - bugfix for setting ELoot.data.coin_bag_full to false when empty.
  v2.4.7 (2025-08-15)
    - if debug to file enabled, allow for when started with a parameter (sell/pool/etc)
  v2.4.6 (2025-08-12)
    - fix encumbered after box opening by depositing silvers in process_boxes
  v2.4.5 (2025-07-22)
    - bugfix for default locksmith_withdrawl_amount
  v2.4.4 (2025-07-16)
    - allow customizable locksmith tip amount withdrawal
    - typo correction in bulk sell gem method
    - force clean overflow containers from sell_container list
    - utilize File.join for save/load
    - bugfix in pool_return to allow up to 2 seconds for GameObj right/left hand to populate
    - remove Unicode characters in formula explanation for scaled box tipping (non-logic change) / Warlock
  v2.4.3 (2025-07-15)
    - bugfix for town locksmith regex to open box after return being too generic
  v2.4.2 (2025-07-09)
    - bugfix for silver withdrawals failing on f2p accounts with low bank balances
  v2.4.1 (2025-06-05)
    - bugfix for unable to lighten load during pool return and no silvers to deposit to allow more boxes to be returned
    - bugfix for box loot to deposit coins if too many coins on yourself to be able to loot coins from box
    - change class checks to is_a? checks
=end

# Check version of Lich for compatibility
lich_gem_requires = Script.list.find { |x| x.name == Script.current.name }.inspect[/required: Lich >= (\d+\.\d+\.\d+)/i, 1]

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires)
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
    _respond "##" + "########################################"
  end
  exit
end

require 'yaml'
require 'terminal-table'

module ELoot # Writes debug output to a file
  class DebugLogger
    attr_accessor :logger, :log_file, :script_name

    def initialize
      @script_name = Script.current.name
      # Ensure the debug folder exists
      debug_dir = File.join(LOG_DIR, 'debug', "#{XMLData.game}-#{XMLData.name}")
      FileUtils.mkdir_p(debug_dir) unless Dir.exist?(debug_dir)

      # Set up logger
      @log_writer = Queue.new
      @log_file = File.join(debug_dir, "#{@script_name}.log")
      @logger = Logger.new(@log_file, 'daily')
      @logger.formatter = proc do |_, datetime, _, msg|
        formatted_time = datetime.strftime("%Y-%m-%d %H:%M:%S") # Excludes timezone
        "[#{formatted_time}]: #{msg}\n"
      end

      # Start logging automatically after initialization
      start_logging
    end

    def start_logging
      # Startup Message
      if ELoot.data == ELoot.data.details_check
        log("Starting up!")
      else
        ELoot.data.details_check = ELoot.data
        eloot_details = ELoot.test(true)
        log("Starting up!\n#{eloot_details}")
      end

      @worker_thread = Thread.new {
        UpstreamHook.add("debug_upstream_hook", proc { |data|
          @log_writer << ">#{data.sub(/^<c>/, '')}".strip
          data
        })

        DownstreamHook.add("debug_downstream_hook", proc { |data|
          @log_writer << data.strip
          data
        })

        loop do
          current_last = $_LASTUPSTREAM_
          @log_writer.push current_last.sub(/^<c>/, '').strip
          while current_last == $_LASTUPSTREAM_
            sleep 0.1
          end
        end
      }

      @writer_thread = Thread.new do
        loop do
          line = @log_writer.pop
          @logger.info(@script_name) { line } unless line.to_s.strip.empty?
        end
      end

      before_dying {
        @logger.info(@script_name) { "Closing up!" }

        respond("")
        Lich::Messaging.msg("bold", "You've started #{Script.current.name} with debug to file on.")
        Lich::Messaging.msg("bold", "Please remember to turn this option off once done needing to debug.")
        Lich::Messaging.msg("bold", "Currently debugging to #{@log_file}")
        Lich::Messaging.msg("bold", "To turn off, execute #{$clean_lich_char}#{Script.current.name} debug file")
        respond("")

        UpstreamHook.remove("debug_upstream_hook")
        DownstreamHook.remove("debug_downstream_hook")
        @worker_thread.kill
        @writer_thread.kill
        @logger.close
        ELoot.data.debug_logger = nil
      }

      respond("")
      Lich::Messaging.msg("bold", "You've started #{Script.current.name} with debug to file on.")
      Lich::Messaging.msg("bold", "Please remember to turn this option off once done needing to debug.")
      Lich::Messaging.msg("bold", "Currently debugging to #{@log_file}")
      Lich::Messaging.msg("bold", "To turn off, execute #{$clean_lich_char}#{Script.current.name} debug file")
      respond("")
    end

    # Method to log a custom message
    def log(message)
      @log_writer << message
    end
  end
end

module ELoot # Data
  class Data
    attr_accessor :disk, :disk_full, :sacks_full, :ready_method, :settings, :skinners, :skinsheath, :silent_open, :checked_bags,
                  :close_regex, :look_regex, :sacks_closed, :all_loot_categories, :regex_gold_rings, :right_hand, :left_hand, :skin_edged, :skin_blunt,
                  :coin_hand, :coin_container, :silver_breakdown, :get_regex, :put_regex, :alchemy_mode, :sell_containers, :local_gemshop, :local_furrier, :log_unlootables, :exclude,
                  :charm, :gauntlet, :coin_bag, :account_type, :locker, :container_settings, :everything_list, :everything,
                  :only_list, :only, :inventory, :gem_inventory, :alchemy_inventory, :hoard_type, :cache, :locker_city, :use_hoarding, :stash,
                  :items_to_hoard, :hoard_deposit, :inv_save, :deposit_regex, :withdraw_regex, :disk_nouns_regex, :sigil_determination_on_fail, :start_room, :last_called,
                  :urchin_msg, :gemshop_first, :reject_loot_names, :reject_loot_nouns, :version, :debug_logger, :details_check, :coin_bag_full,
                  :use_house_locker, :che_rooms, :che_entry, :che_exit, :towns, :gambling_kit, :gambling_kit_full, :ready_lines, :weapon_inv, :original_readylist, :blood_band

    def initialize(settings)
      @settings = settings
      @start_room = nil
      @last_called = {}
      @version = ELoot.get_script_version
      @debug_logger = nil
      @details_check = nil
      @towns ||= Map.list.select { |r| r.tags.include? "town" }

      # inventory type
      @sacks_closed = []
      @sacks_full = []
      @checked_bags = []
      @sell_containers = []
      @ready_lines = []
      @weapon_inv = []
      @original_readylist = ReadyList.const_get(:ORIGINAL_READY_LIST)

      @coin_hand = nil
      @coin_container = nil

      @charm = nil
      @gauntlet = nil
      @coin_bag = nil
      @coin_bag_full = false
      @settings[:locksmith_withdraw_amount] ||= 8000

      @gambling_kit = nil
      @gambling_kit_full = false

      @disk = nil
      @disk_full = false

      @ready_method = {}

      @skinners = {}
      @skinsheath = nil
      @skin_edged = nil
      @skin_blunt = nil

      @blood_band = nil

      @right_hand = ""
      @left_hand = ""

      # Hoarding/bounty type
      @hoard_type = nil
      @hoard_deposit = nil
      @items_to_hoard = nil
      @container_settings = nil
      @everything_list = nil
      @everything = nil
      @only_list = nil
      @only = nil
      @inventory = nil
      @gem_inventory = nil
      @alchemy_inventory = nil
      @locker_city = nil
      @locker = nil
      @cache = nil
      @use_hoarding = nil
      @stash = nil
      @use_house_locker = nil
      @che_rooms = []
      @che_entry = ""

      @alchemy_mode = false

      @local_gemshop = nil
      @local_furrier = nil

      # Misc
      @account_type = nil
      @silver_breakdown = {}
      @inv_save = true

      $sell_ignore = []
      @gemshop_first = false

      default_crumbly = [
        # Kraken Fall
        "gnarled dark wooden crook",
        "twisted obsidian dagger",
        "immense fel-hafted handaxe",
        "gold-tipped heavy spear",
        "notched bone handaxe",
        "rough pinewood crook",
        "swirling sanguine orb",
        "battered antique faewood crate",
        "copper-traced dark steel hatchet",
        "huge black alloy greatsword",
        "rough leather quiver",

        # Atoll
        "twisted soot black runestaff",
        "corroded bronze Hammer of Kai",
        "dried seaweed-wrapped longbow",
        "bronze-bound driftwood greatshield",
        "coral-hilted heavy ball and chain",
        "coral-hilted sharply tapered longsword",
      ]

      @settings[:crumbly] ||= []
      @settings[:crumbly] += default_crumbly
      @settings[:crumbly].uniq!

      @settings[:track_full_sacks] = true if @settings[:track_full_sacks].nil?

      @settings[:unlootable] ||= []
      @settings[:unlootable]&.uniq!

      @settings[:auto_close] ||= []
      @settings[:auto_close]&.uniq!

      @settings[:unskinnable]&.uniq!

      @exclude = @settings[:loot_exclude].map { |r| r.is_a?(String) ? Regexp.new(r) : r }

      @deposit_regex = Regexp.union(
        /You deposit (?<silver>[\d,]+) silvers? into your account/,
        /That's a total of (?<silver>[\d,]+) silver/,
        /That's (?<silver>[\d,]+) silver|silvers? to your account/,
        /You deposit your note worth (?<silver>[\d,]+) into your account/,
        /You hand your notes to the teller, who glances over each one and scribbles the amounts in a book.  She says, "They add up to (?<silver>[\d,]+) (?:silver|silvers)/,
        /You have no coins to deposit/,
        /Smiling greedily, Hurshal takes your silvers and says, "Heh, I'll put dese in ye 'Mule bank account right quick\."/,
      )

      @withdraw_regex = Regexp.union(
        /I have a (?<debt>bill) of (?<silver>[\d,]+) silvers? (?:presented by your creditors|that I suggest you pay immediately)/,
        /Very well, a withdrawal of (?<silver>[\d,]+) silver/,
        /teller scribbles the transaction into a book and hands you (?<silver>[\d,]+) silver/,
        /teller carefully records the transaction, (?:and then )?hands you (?<silver>[\d,]+) silver/,
        /The banker nods and says, "Alright, here ye go\.  Ye understand I be takin' a little more than that from ye account in the 'Mule\.  I don't works for free!"/,
      )

      @get_regex = Regexp.union(
        /^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly |slowly )?(?:remove|draw|equip|grab|reach|slip|tuck|retrieve|already have|unsheathe|detach|swap|sling|withdraw)/,
        /^With subtle movements, you sneak a hand/,
        /^Get what\?$/,
        /^Why don't you leave some for others\?$/,
        /^You need a free hand/,
        /^You already have that/,
        /Reaching over your shoulder/,
        /^As you draw/,
        /^Ribbons of.*?light/,
        /^You are already holding/,
      )

      @put_regex = Regexp.union(
        /You/,
        /Spreading your wings/,
        /I could not find what you were referring to/,
        /Draping the/,
        /Heedful of your surroundings/,
        /won't fit/,
        /crumbles? and decays? away/,
        /crumbles? into a pile of dust/,
        /That is not yours/,
        /Hey, that belongs to/,
        /Get what/,
        /Reaching over your shoulder/,
        /An ethereal.*?light swirls/,
        /As you move to put away your (?:<a exist="\d+" noun="\w+">[^<]+<\/a>|[\w-]+), it reverts to its normal state\./,
      )

      @look_regex = Regexp.union(
        /Peering into the <a exist=.*? noun="toolkit">/i,
        /That is closed/i,
        /is shut too tightly to see its contents/i,
        /In the(.*?)you see/i,
        /In the(.*?):/i,
        /There is nothing/i,
        /You glance/i,
        /^Attached to a.*keyring/i,
        /.*?[.*?]:/i,
        /The <a exist="\d+" noun="\w+">[^<]+<\/a> has (?:an? <a exist="\d+" noun="\w+">[^<]+<\/a> |nothing )?in.*scabbard and (?:an? <a exist="\d+" noun="\w+">[^<]+<\/a> |nothing )?in.*scabbard\./i,
        /^I could not find what you were referring to\./i,
        /Hidden within the depths of a cloakwing moth greatcloak/,
        /<exposeContainer|<dialogData|<container/i,
        /stuffed with a variety of shredded up paper and cloth/,
        /As much as you'd like to open it, its not closed\./,
        /^Looking at the .*?, you notice:/i, # neck sheath, no proper gameobjs viewable
        /^The .+? has .+? in its left-hand scabbard and .+? in its right-hand scabbard\.$/i, # swordbelt scabbards, no proper gameobjs viewable
      )

      @silent_open = Regexp.union(
        /You throw back/i,
        /You open/i,
        /Oh no! It's already/i,
        /You pick at the knot/i,
        /already open/i,
        /is open already/i,
        /You unfasten/i,
        /You glance around suspiciously/i,
        /^What were you referring to\?/i,
        /^I could not find what you were referring to\./i,
        /You pull the long strips of leather/i,
        /With a flick of your wrist/i,
        /Sliding the lever on the side/i,
        /You rub your hand/i,
        /There doesn't seem to be any way/i,
        /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i,
        /crumbles? and decays? away/,
        /crumbles? into a pile of dust/,
        /Myriad spectral moths pull a cloakwing/,
        /<exposeContainer|<container/i,
        /You undo each of the/,
        /stuffed with a variety of shredded up paper and cloth/,
      )

      @close_regex = Regexp.union(
        /You close .*/,
        /(?:That|It) is already closed/,
        /What were you referring to/,
        /seem to be any way to do that/,
        /You tie/,
        /You fasten the/,
      )

      @urchin_msg = Regexp.union(
        /You (flag|summon|ask|consult|stride|go|inventory|recollect|offer|strut|sweep|casually|hear|currently) /,
        /An elven page/,
        /Unsure exactly/,
        /A bloom of wildflowers/,
        /A thin layer of hoarfrost/,
        /Making a decision/,
        /With a cautious glance/,
        /As if sensing your/,
        /Sudden gusts of wind/,
        /Motes of light blink/,
        /A single mote of/,
        /A dense fog rolls/,
        /Shadowy tendrils rise/,
      )

      # There are a lot of disk nouns so breaking out to a single list to maintain
      @disk_nouns_regex = /\b(?:bassinet|cassone|chest|coffer|coffin|coffret|disk|hamper|saucer|sphere|trunk|tureen)\b/

      @regex_gold_rings = /^(dingy|plain|braided|twisted|intricate|large|thin|wide|polished|scratched|thick|dull|faded|small|flawless|inlaid|dirt\-caked|ornate|exquisite|shiny|bright|narrow) gold ring$|^gold ring$/

      @reject_loot_names = [
        # 335 Diety
        "golden light",
        "jet black scimitar",
        "midnight black flames",
        "reddish haze",
        "sourceless shadow",
        "swirling blue-green pillar of water",

        # Ranger vines
        "bramble",
        "briar",
        "clutch of twisted branches",
        "creeper",
        "ivy",
        "smilax",
        "swallowwort",
        "tumbleweed",
        "vine",
        "widgeonweed",

        # Misc
        "child",
        "jagged crater",
        "massive icicle",
        "point of elemental instability",
        "rolton droppings",
        "rotting tree stump",
        "sealed fissure",
        "severed",
        "slender silvery thread",
        "slippery wooden chute",
        "small puddle",
        "vathor club",
      ]

      @reject_loot_nouns = [
        "cloud",
        "cyclone",
        "door",
        "gangplank",
        "kitten",
        "maw",
        "mist",
        "muck",
        "puppy",
        "space",
        "staircase",
      ]

      @all_loot_categories = ["alchemy", "armor", "box", "clothing", "collectible", "cursed", "food", "gem", "herb", "jewelry", "junk", "lockpick", "lm trap", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand", "weapon"]
    end
  end
end

module ELoot # UI Setup
  if defined?(Gtk)
    # Setup is an extension of Gtk::Builder for Gtk setup
    class Setup < Gtk::Builder
      @@categories = {
        loot: {
          loot_types: {
            default: []
          },
          loot_exclude: {
            default: ["black ora", "urglaes"],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          loot_keep: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          critter_exclude: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          unlootable: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          loot_phase: { default: false },
          use_disk: { default: true },
          loot_defensive: { default: false },
          overflow_container: { default: '' },
          secondary_overflow: { default: '' },
          coin_hand_name: { default: '' },
          charm_name: { default: '' },
          sigil_determination_on_fail: { default: false },
          keep_closed: { default: false },
          track_full_sacks: { default: true },
          favor_left: { default: false },
          log_unlootables: { default: false },
          use_bloodbands: { default: false },
          gambling_toss_min: { default: 1_000 },
        },
        boxes: {
          use_standard_tipping: { default: true },
          sell_locksmith: { default: false },
          sell_locksmith_pool: { default: true },
          locksmith_when_gem_bounty: { default: false },
          always_check_pool: { default: false },
          locksmith_withdraw_amount: { default: 8000 },
          display_box_contents: { default: true },
          sell_locksmith_pool_tip: { default: 15 },
          sell_locksmith_pool_tip_percent: { default: true },
          use_incremental_tipping: { default: false },
          base_tip: { default: 200 },
          max_tip: { default: 2000 },
          alpha_rate: { default: 2.5 },
          tipping_test: { default: [] },
        },
        sell: {
          sell_loot_types: {
            default: []
          },
          sell_container: { default: [] },
          sell_exclude: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          sell_keep_scrolls: {
            default: [],
            load: proc do |store, setting|
              store.clear

              # Ensure uniqueness first
              setting.uniq!

              # Sort the array with numeric values first, then alphanumeric values
              setting.sort! do |a, b|
                # Extract numeric part from each item
                a_num = a.to_s.match(/^\d+/) ? a.to_s.match(/^\d+/)[0].to_i : Float::INFINITY
                b_num = b.to_s.match(/^\d+/) ? b.to_s.match(/^\d+/)[0].to_i : Float::INFINITY

                if a_num == b_num
                  # If numeric part is the same, place alphanumeric values after pure numbers
                  a.match?(/\D/) ? 1 : -1
                else
                  # Sort by numeric value first
                  a_num <=> b_num
                end
              end

              setting.each do |text|
                spell_no = text.to_s[/^\d+/]

                if spell_no.nil?
                  setting.delete(text)
                else
                  iter = store.append
                  iter[0] = Spell[spell_no].num
                  iter[1] = Spell[spell_no].name
                  iter[2] = '     Vibrant' if text.to_s =~ /v/i
                end
              end
            end,
            delete: proc do |_, selected, setting|
              if selected.get_value(2).nil?
                setting.delete_if { |item| item == selected.get_value(0).to_s || item == selected.get_value(0) }
              else
                thing = setting.find { |item| item.to_s =~ /#{selected.get_value(0)}\s?+(?:v|vib)/i }
                setting.delete(thing)
              end
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              spell_no = text[/^\d+/]
              next if Spell[spell_no].nil?

              setting.push(text)
            end
          },
          sell_appraise_types: { default: [] },
          sell_appraise_gemshop: { default: 14_999 },
          sell_appraise_pawnshop: { default: 34_999 },
          appraisal_container: { default: '' },

          sell_collectibles: { default: true },
          sell_gold_rings: { default: false },

          sell_share_silvers: { default: false },
          sell_fwi: { default: false },
          sell_shroud: { default: false },
          sell_aspect: { default: false },
          sell_keep_silver: { default: 0 },
          sell_deposit_coinhand: { default: false },
        },
        skin: {
          skin_enable: { default: false },
          skin_kneel: { default: false },
          skin_604: { default: false },
          skin_resolve: { default: false },
          skin_sheath: { default: '' },
          skin_weapon: { default: '' },
          skin_sheath_blunt: { default: '' },
          skin_weapon_blunt: { default: '' },
          skin_exclude: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          between: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
        },
        hoard: {
          gem_horde_turnin: { default: false },
          gem_horde_inv: { default: [] },
          gem_horde: { default: false },
          gem_horde_locker: { default: false },
          gem_everything_list: { default: false },
          gem_only_list: { default: false },
          gem_horde_container: { default: '' },
          gem_horde_containers: { default: ['default', 'gem', 'overflow1', 'overflow2'] },
          gem_locker: { default: '' },
          gem_locker_name: { default: '' },
          gem_horde_locker_che: { default: false },
          gem_horde_che_rooms: { default: '' },
          gem_horde_che_entry: { default: '' },
          gem_horde_che_exit: { default: '' },
          gem_everything: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          gem_list: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          alchemy_horde_inv: { default: [] },
          alchemy_horde: { default: false },
          alchemy_horde_locker: { default: false },
          alchemy_everything_list: { default: false },
          alchemy_only_list: { default: false },
          alchemy_horde_container: { default: '' },
          alchemy_horde_containers: { default: ['default', 'reagent', 'overflow1', 'overflow2'] },
          alchemy_locker: { default: '' },
          alchemy_locker_name: { default: '' },
          alchemy_horde_locker_che: { default: false },
          alchemy_horde_che_rooms: { default: '' },
          alchemy_horde_che_entry: { default: '' },
          alchemy_horde_che_exit: { default: '' },
          alchemy_everything: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
          alchemy_list: {
            default: [],
            load: proc do |store, setting|
              store.clear
              setting.each do |text|
                iter = store.append
                iter[0] = text
              end
            end,
            delete: proc do |_, selected, setting|
              setting.delete(selected.get_value(0))
              setting.uniq!.sort!
            end,
            set: proc do |_, text, setting|
              next if setting.include?(text)

              setting.push(text)
              setting.uniq!.sort!
            end
          },
        },
        internal: {
          silence: { default: false },
          debug: { default: false },
          debug_file: { default: false },
          unskinnable: { default: [] },
          unlootable: { default: [] },
          crumbly: { default: [] },
          auto_close: { default: [] },
        }
      }

      def self.eloot_ui
        '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkListStore" id="alchemy_everything_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/></columns></object><object class="GtkListStore" id="alchemy_list_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/>
        </columns></object><object class="GtkAdjustment" id="alpha_adjustment"><property name="upper">100</property><property name="step-increment">0.10</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="base_tip_adjustment"><property name="upper">100000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="between_store"><columns><!-- column-name exclusion --><column type="gchararray"/>
        </columns></object><object class="GtkListStore" id="critter_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkAdjustment" id="gambling_adjustment"><property name="upper">25000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="gem_everything_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/></columns></object><object class="GtkListStore" id="gem_list_store"><columns><!-- column-name gchararray1 --><column type="gchararray"/>
        </columns></object><object class="GtkAdjustment" id="locksmith_withdraw_amount_adjustment"><property name="upper">100000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="loot_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkListStore" id="loot_keep_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkAdjustment" id="max_tip_adjustment"><property name="upper">100000</property><property name="step-increment">1</property><property name="page-increment">10</property>
        </object><object class="GtkAdjustment" id="sell_appraise_gemshop_adjustment"><property name="upper">1000000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="sell_appraise_gemshop_pawnshop"><property name="upper">1000000</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkListStore" id="sell_exclude_store"><columns><!-- column-name Exclusion --><column type="gchararray"/>
        </columns></object><object class="GtkListStore" id="sell_keep_scrolls_store"><columns><!-- column-name Spell --><column type="gint"/><!-- column-name Spell1 --><column type="gchararray"/><!-- column-name Spell2 --><column type="gchararray"/></columns></object><object class="GtkAdjustment" id="sell_keep_silver_adjustment"><property name="upper">999999</property><property name="step-increment">1</property><property name="page-increment">10</property></object><object class="GtkAdjustment" id="sell_locksmith_pool_tip_adjustment"><property name="upper">999999</property><property name="step-increment">1</property><property name="page-increment">10</property>
        </object><object class="GtkListStore" id="skin_exclude_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkListStore" id="unlootable_store"><columns><!-- column-name exclusion --><column type="gchararray"/></columns></object><object class="GtkWindow" id="main"><property name="width-request">790</property><property name="height-request">640</property><property name="can-focus">False</property><property name="title" translatable="yes">Eloot Setup</property><property name="modal">True</property><property name="default-width">800</property><property name="default-height">830</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=6 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="loot_types:alchemy"><property name="label" translatable="yes">Alchemy</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:armor"><property name="label" translatable="yes">Armor</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:box"><property name="label" translatable="yes">Box</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:clothing"><property name="label" translatable="yes">Clothing</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:collectible"><property name="label" translatable="yes">Collectible</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:cursed"><property name="label" translatable="yes">Cursed</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:food"><property name="label" translatable="yes">Food</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:herb"><property name="label" translatable="yes">Herb</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="loot_types:junk"><property name="label" translatable="yes">Junk</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="loot_types:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:weapon"><property name="label" translatable="yes">Weapon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object><packing><property name="left-attach">5</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="loot_types:coins"><property name="label" translatable="yes">Coins (ground)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_types:breakable"><property name="label" translatable="yes">Breakable(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="loot_types:lm trap"><property name="label" translatable="yes">Locksmith Traps</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Loot Types</property>
        </object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="loot_defensive"><property name="label" translatable="yes">Loot in defensive(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="loot_phase"><property name="label" translatable="yes">Phase boxes(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="use_disk"><property name="label" translatable="yes">Disking(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="track_full_sacks"><property name="label" translatable="yes">Track Full Containers(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="favor_left"><property name="label" translatable="yes">Favor Left(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="keep_closed"><property name="label" translatable="yes">Keep sacks shut(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="log_unlootables"><property name="label" translatable="yes">Log unlootable items(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="sigil_determination_on_fail"><property name="label" translatable="yes">Sigil of Determination(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=1 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Fossil Charm Name:</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="charm_name"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">15</property><property name="margin-end">15</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Originally from Mushroom Spore Giftbox 07/29/2023</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="width">2</property><property name="height">4</property></packing></child><child><object class="GtkCheckButton" id="use_bloodbands"><property name="label" translatable="yes">Use Bloodtooth Bands(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Other Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=1 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Primary Overflow:</property><property name="xalign">0</property><property name="yalign">0</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="overflow_container"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Enter the name of your overflow container.  This container will be used when the targeted STOW container is full.</property><property name="margin-start">5</property><property name="margin-end">15</property><property name="margin-bottom">5</property><property name="hexpand">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Secondary Overflow:</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkEntry" id="secondary_overflow"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">Enter the name of your secondary overflow container.  This container will be used when the primary overflow container is full.</property><property name="margin-start">5</property><property name="margin-end">15</property><property name="margin-bottom">10</property><property name="hexpand">True</property><property name="vexpand">False</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Overflow Containers</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=1 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Coin Bag / Coin Hand / Gambling Kit</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="coin_hand_name"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">15</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Name of item</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkLabel" id="gambling_silvers_label"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Gambling Kit Silvers (?)</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkSpinButton" id="gambling_toss_min"><property name="width-request">130</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">gambling_adjustment</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Weightless Coin Containers</property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property>
        </packing></child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Looting</property></object><packing><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="loot_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="loot_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="loot_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. urglaes fang)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="loot_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">loot_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel" id="never_loot_label"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Never Loot(?)</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="loot_keep_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="loot_keep_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="loot_keep_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter addition (e.g. uncut diamond)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="loot_keep"><property name="visible">True</property><property name="can-focus">True</property><property name="model">loot_keep_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel" id="always_loot_label"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Always Loot(?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="critter_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="critter_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="critter_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. giant rat)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="critter_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">critter_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel" id="creature_exclusion_label"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Creature Exclusions (?)</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="unlootable_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="unlootable_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="unlootable_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter unlootable item</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="unlootable"><property name="visible">True</property><property name="can-focus">True</property><property name="model">unlootable_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel" id="unlootable_label"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Unlootable(?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child></object></child></object><packing><property name="position">1</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Looting Grid</property></object><packing><property name="position">1</property><property name="tab-fill">False</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_locksmith_pool"><property name="label" translatable="yes">Use locksmith pool</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_locksmith"><property name="label" translatable="yes">Use town locksmith</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="display_box_contents"><property name="label" translatable="yes">Display box contents</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="always_check_pool"><property name="label" translatable="yes">Always check pool (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Locksmith Withdraw Amount</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkSpinButton" id="locksmith_withdraw_amount"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">How much to withdraw from the bank before going to the town locksmith.</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">5</property><property name="adjustment">locksmith_withdraw_amount_adjustment</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkCheckButton" id="locksmith_when_gem_bounty"><property name="label" translatable="yes">Default to using locksmith when gem bounty active</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="margin-start">5</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Locksmithing</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="between_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="valign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="between_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="between_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Scripts between the pool and selling</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">325</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="between"><property name="visible">True</property><property name="can-focus">True</property><property name="model">between_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel" id="in_between_label"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">In-between Scripts (?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="height">2</property></packing></child><child><object class="GtkFrame" id="standard_tipping_frame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=1 n-rows=4 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-top">10</property><property name="label" translatable="yes">Locksmith Pool Tip</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="sell_locksmith_pool_tip"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-top">10</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_locksmith_pool_tip_adjustment</property><property name="numeric">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_locksmith_pool_tip_percent"><property name="label" translatable="yes">Tip using percentage</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">50</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="use_standard_tipping"><property name="label" translatable="yes">Use Standard Tipping</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Standard Pool Tipping</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame" id="incremental_tipping_frame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=1 n-rows=7 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="label" translatable="yes">Base Tip</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkSpinButton" id="base_tip"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="adjustment">base_tip_adjustment</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="label" translatable="yes">Maximum Tip</property></object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkSpinButton" id="max_tip"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="adjustment">max_tip_adjustment</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="label" translatable="yes">a (alpha)</property></object><packing><property name="left-attach">0</property><property name="top-attach">5</property>
        </packing></child><child><object class="GtkSpinButton" id="alpha_rate"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">20</property><property name="adjustment">alpha_adjustment</property><property name="digits">1</property></object><packing><property name="left-attach">0</property><property name="top-attach">6</property>
        </packing></child><child><object class="GtkCheckButton" id="use_incremental_tipping"><property name="label" translatable="yes">Use Incremental Tipping</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-end">100</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><!-- n-columns=1 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-end">70</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="valign">start</property><property name="margin-top">20</property><property name="label" translatable="yes">As your box count in the pool climbs, so does your tip.
                This pushes your box higher in the queue resulting in a faster return.

                The formula being used:
                     Tip = Base Tip+( Boxes in Pool / 100 )^a * (Max Tip - Base Tip)

                base_tip  = minimum tip to start
                max_tip   = maximum tip
                a (alpha) = determines how fast tip rises </property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="tipping_test"><property name="label" translatable="yes">Test Formula Values</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="tooltip-text" translatable="yes">Prints a sample distribution to the screen.
        </property><property name="halign">start</property><property name="margin-top">25</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><placeholder/></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Incremental Tipping</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property>
        </packing></child></object></child></object></child></object><packing><property name="position">2</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Boxes</property></object><packing><property name="position">2</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=6 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_loot_types:alchemy"><property name="label" translatable="yes">Alchemy</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:armor"><property name="label" translatable="yes">Armor</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:box"><property name="label" translatable="yes">Box(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:clothing"><property name="label" translatable="yes">Clothing</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:cursed"><property name="label" translatable="yes">Cursed</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:food"><property name="label" translatable="yes">Food (?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:herb"><property name="label" translatable="yes">Herb(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:junk"><property name="label" translatable="yes">Junk(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">5</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:scarab"><property name="label" translatable="yes">Scarab</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">4</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">5</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">3</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_loot_types:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:weapon"><property name="label" translatable="yes">Weapon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Warning - Mark anything you don\'t want accidentally sold - Eloot is not perfect!</property><attributes><attribute name="foreground" value="#ffff00000000"/>
        </attributes></object><packing><property name="left-attach">1</property><property name="top-attach">4</property><property name="width">4</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:breakable"><property name="label" translatable="yes">Breakable(?)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_loot_types:lm trap"><property name="label" translatable="yes">Locksmith Traps</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Sell Types</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=5 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="sell_container:default"><property name="label" translatable="yes">Default</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:overflow"><property name="label" translatable="yes">Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:box"><property name="label" translatable="yes">Box</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:collectible"><property name="label" translatable="yes">Collectible</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:forageable"><property name="label" translatable="yes">Forageable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_container:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:herb"><property name="label" translatable="yes">Herb</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:lockpick"><property name="label" translatable="yes">Lockpick</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:potion"><property name="label" translatable="yes">Potion</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="sell_container:scroll"><property name="label" translatable="yes">Scroll</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:skin"><property name="label" translatable="yes">Skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:treasure"><property name="label" translatable="yes">Treasure</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:trinket"><property name="label" translatable="yes">Trinket</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="sell_container:wand"><property name="label" translatable="yes">Wand</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">4</property><property name="top-attach">2</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Only sell from these STOW containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">135</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=5 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="sell_appraise_types:magic"><property name="label" translatable="yes">Magic</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:uncommon"><property name="label" translatable="yes">Uncommon</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-top">10</property><property name="label" translatable="yes">Gemshop Limit</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">2</property>
        </packing></child><child><object class="GtkSpinButton" id="sell_appraise_gemshop"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_appraise_gemshop_adjustment</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property><property name="width">2</property>
        </packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="label" translatable="yes">Pawnshop Limit</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property><property name="width">2</property></packing></child><child><object class="GtkSpinButton" id="sell_appraise_pawnshop"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_appraise_gemshop_pawnshop</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property><property name="width">2</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:valuable"><property name="label" translatable="yes">Valuable</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_appraise_types:jewelry"><property name="label" translatable="yes">Jewelry</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">75</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="label" translatable="yes">Container to store items exceeding appraisal limit</property></object><packing><property name="left-attach">4</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="appraisal_container"><property name="visible">True</property><property name="can-focus">True</property><property name="valign">start</property><property name="margin-start">75</property><property name="margin-top">5</property><property name="placeholder-text" translatable="yes">If blank will return items to original container</property></object><packing><property name="left-attach">4</property><property name="top-attach">1</property><property name="height">2</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Appraisals</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property>
        </packing></child><child><!-- n-columns=2 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="sell_collectibles"><property name="label" translatable="yes">Deposit Collectibles</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="sell_fwi"><property name="label" translatable="yes">Sell in FWI</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_gold_rings"><property name="label" translatable="yes">Gold Rings to Chrono.</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_shroud"><property name="label" translatable="yes">Use Shroud (1212) &amp; Glamour (1205)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkLabel" id="keep_silvers_label"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">Setting this will ensure you keep a certain number of silvers on you after selling.</property><property name="halign">start</property><property name="margin-start">30</property><property name="label" translatable="yes">Keep Silvers (?)</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_aspect"><property name="label" translatable="yes">Use Assume Aspect - Lion (650)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_deposit_coinhand"><property name="label" translatable="yes">Deposit coinhand/gambling kit</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkCheckButton" id="sell_share_silvers"><property name="label" translatable="yes">Share silvers</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkSpinButton" id="sell_keep_silver"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">30</property><property name="margin-top">5</property><property name="margin-bottom">30</property><property name="text" translatable="yes">0</property><property name="adjustment">sell_keep_silver_adjustment</property><property name="numeric">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">1</property><property name="height">2</property>
        </packing></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Other Settings</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property><property name="width">2</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">3</property>
        </packing></child></object></child></object></child></object><packing><property name="position">3</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Selling</property></object><packing><property name="position">3</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="sell_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="sell_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="sell_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. uncut diamond)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="sell_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">sell_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Exclusions (?)</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="sell_keep_scrolls_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="sell_keep_scrolls_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="sell_keep_scrolls_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter exclusion (e.g. 215)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="sell_keep_scrolls"><property name="height-request">-1</property><property name="visible">True</property><property name="can-focus">True</property><property name="model">sell_keep_scrolls_store</property><property name="headers-visible">False</property><property name="search-column">0</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="title" translatable="yes">Spell Number</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="title" translatable="yes">Spell Name</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">1</attribute></attributes></child></object></child><child><object class="GtkTreeViewColumn"><property name="title" translatable="yes">Vibrant</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">2</attribute>
        </attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel" id="keep_scrolls_label"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes"></property><property name="label" translatable="yes">Keep Scrolls (?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child></object></child></object><packing><property name="position">4</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Selling Grid</property>
        </object><packing><property name="position">4</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow" id="skinning_scrolled_window"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="border-width">10</property><property name="row-spacing">2</property><property name="column-spacing">5</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_enable"><property name="label" translatable="yes">Enable skinning</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">0</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkCheckButton" id="skin_kneel"><property name="label" translatable="yes">Kneel to skin</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_resolve"><property name="label" translatable="yes">Use Sigil of Resolve</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="skin_604"><property name="label" translatable="yes">Use 604</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="draw-indicator">True</property></object><packing><property name="left-attach">3</property><property name="top-attach">0</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><!-- n-columns=2 n-rows=8 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Skin Sheath (blunt)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_sheath_blunt"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="margin-bottom">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Skin Weapon (blunt)</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_weapon_blunt"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">20</property><property name="margin-end">10</property><property name="margin-bottom">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Blunt Skinning</property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="column-homogeneous">True</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Skin Sheath (edged)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_sheath"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="xpad">5</property><property name="ypad">5</property><property name="label" translatable="yes">Skin Weapon (edged)</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="skin_weapon"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">20</property><property name="margin-end">10</property><property name="width-chars">20</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Edged Skinning</property>
        </object></child></object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="skin_exclude_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="skin_exclude_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkEntry" id="skin_exclude_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Enter skinning exclusion (e.g. giant rat)</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkScrolledWindow"><property name="height-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-end">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="skin_exclude"><property name="visible">True</property><property name="can-focus">True</property><property name="model">skin_exclude_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel" id="skinning_exclusions_label"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Skinning Exclusions (?)</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="height">8</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child><child><placeholder/>
        </child></object></child></object></child></object><packing><property name="position">5</property></packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Skinning</property></object><packing><property name="position">5</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow" id="gem_scrolled_window"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="gem_horde"><property name="label" translatable="yes">Hoard Gems (defaults to all gems unless modified below)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_locker"><property name="label" translatable="yes">Hoard gems in a public locker</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_horde_container"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-start">14</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="width-chars">20</property><property name="placeholder-text" translatable="yes">ex: bin or chest or trunk</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_turnin"><property name="label" translatable="yes">Use hoarded gems for bounties</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkComboBoxText" id="gem_locker"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">22</property><property name="margin-bottom">17</property><property name="has-entry">True</property><child internal-child="entry"><object class="GtkEntry" id="gem_locker_name"><property name="can-focus">True</property><property name="placeholder-text" translatable="yes">Select Locker Location</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property><property name="height">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-top">13</property><property name="label" translatable="yes">Name of strorage container (even for lockers)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_locker_che"><property name="label" translatable="yes">Hoard gems in a house locker</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkEntry" id="gem_horde_che_rooms"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">Comma separated list of room #\'s OUTSIDE the locker</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_horde_che_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">go arch or tap panel or other</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkEntry" id="gem_horde_che_exit"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">whatever gets you out</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel" id="gem_location_label"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">25</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Locations(?)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Entry Verb</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Exit Verb</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel" id="gem_hoarding_notes"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="margin-start">15</property><property name="margin-top">20</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="gem_horde_containers:default"><property name="label" translatable="yes">Default</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_containers:overflow1"><property name="label" translatable="yes">First Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_containers:overflow2"><property name="label" translatable="yes">Second Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_horde_containers:gem"><property name="label" translatable="yes">Gem</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Only Hoard Gems from these Containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="gem_everything_list"><property name="label" translatable="yes">Hoard all gems except those excluded below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="gem_only_list"><property name="label" translatable="yes">ONLY hoard gems listed below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame" id="gem_everything_frame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="gem_everything_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="gem_everything_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_everything_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Gems to Exclude</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="gem_everything"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">gem_everything_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame" id="gem_only_frame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="gem_list_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="gem_list_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="gem_list_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Gems to Include</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="gem_list"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">gem_list_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property></packing></child></object></child></object></child></object><packing><property name="position">6</property>
        </packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Gem Hoarding</property></object><packing><property name="position">6</property><property name="tab-fill">False</property></packing></child><child><object class="GtkScrolledWindow" id="alchemy_scrolled_window"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">10</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=6 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="alchemy_horde_locker"><property name="label" translatable="yes">Hoard reagents  in a locker?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_horde_container"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="margin-start">15</property><property name="margin-top">5</property><property name="margin-bottom">10</property><property name="width-chars">20</property><property name="placeholder-text" translatable="yes">ex: bin or chest or trunk</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde"><property name="label" translatable="yes">Hoard Reagents (defaults to all unless modified below)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkComboBoxText" id="alchemy_locker"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">22</property><property name="has-entry">True</property><child internal-child="entry"><object class="GtkEntry" id="alchemy_locker_name"><property name="can-focus">True</property><property name="placeholder-text" translatable="yes">Select Locker Location</property>
        </object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property><property name="height">2</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="margin-start">15</property><property name="label" translatable="yes">Name of strorage container (even for lockers)</property></object><packing><property name="left-attach">0</property><property name="top-attach">2</property>
        </packing></child><child><!-- n-columns=2 n-rows=3 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkEntry" id="alchemy_horde_che_rooms"><property name="width-request">300</property><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">Comma separated list of room #\'s OUTSIDE the locker</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_horde_che_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">go arch or tap panel or other</property></object><packing><property name="left-attach">1</property><property name="top-attach">1</property>
        </packing></child><child><object class="GtkEntry" id="alchemy_horde_che_exit"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-start">5</property><property name="margin-bottom">10</property><property name="placeholder-text" translatable="yes">whatever gets you out</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkLabel" id="alchemy_location_label"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">25</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Locations(?)</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Entry Verb</property></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-bottom">10</property><property name="label" translatable="yes">Exit Verb</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child></object><packing><property name="left-attach">1</property><property name="top-attach">4</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_locker_che"><property name="label" translatable="yes">Hoard reagents  in a house locker?</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="valign">end</property><property name="margin-start">20</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel" id="alchemy_hoarding_notes"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="margin-start">15</property><property name="margin-top">20</property></object><packing><property name="left-attach">0</property><property name="top-attach">4</property>
        </packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General Settings</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=4 n-rows=1 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="column-homogeneous">True</property><child><object class="GtkCheckButton" id="alchemy_horde_containers:default"><property name="label" translatable="yes">Default</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="margin-bottom">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_containers:overflow1"><property name="label" translatable="yes">First Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_containers:overflow2"><property name="label" translatable="yes">Second Overflow</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">3</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_horde_containers:reagent"><property name="label" translatable="yes">Reagent</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Only Hoard Alchemy Ingredients from these Containers</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="border-width">5</property><property name="label-xalign">0</property><child><!-- n-columns=2 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkCheckButton" id="alchemy_everything_list"><property name="label" translatable="yes">Hoard all alchemy ingredients except those excluded below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="alchemy_only_list"><property name="label" translatable="yes">ONLY hoard alchemy ingredients listed below</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-top">10</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkFrame" id="alchemy_everything_frame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="alchemy_everything_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-left">5</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="alchemy_everything_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-right">5</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_everything_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Ingredients to Exclude</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="alchemy_everything"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">alchemy_everything_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkFrame" id="alchemy_only_frame"><property name="width-request">150</property><property name="height-request">150</property><property name="visible">True</property><property name="can-focus">False</property><property name="halign">start</property><property name="valign">start</property><property name="border-width">10</property><property name="label-xalign">0</property><property name="shadow-type">none</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="valign">center</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">2</property><property name="column-spacing">5</property><child><object class="GtkButton" id="alchemy_list_add"><property name="label" translatable="yes">Add</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">start</property><property name="margin-left">5</property><property name="margin-start">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkButton" id="alchemy_list_delete"><property name="label" translatable="yes">Delete</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-right">5</property><property name="margin-end">5</property><property name="margin-bottom">5</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><object class="GtkEntry" id="alchemy_list_entry"><property name="visible">True</property><property name="can-focus">True</property><property name="margin-bottom">5</property><property name="hexpand">True</property><property name="placeholder-text" translatable="yes">Ingredients to Include</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property>
        </packing></child><child><object class="GtkScrolledWindow"><property name="height-request">200</property><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="border-width">5</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkTreeView" id="alchemy_list"><property name="visible">True</property><property name="can-focus">True</property><property name="vexpand">False</property><property name="model">alchemy_list_store</property><property name="headers-visible">False</property><property name="search-column">0</property><property name="fixed-height-mode">True</property><child internal-child="selection"><object class="GtkTreeSelection"/>
        </child><child><object class="GtkTreeViewColumn"><property name="sizing">fixed</property><property name="title" translatable="yes">Exclusion</property><child><object class="GtkCellRendererText"/><attributes><attribute name="text">0</attribute></attributes></child></object></child></object></child></object></child></object><packing><property name="left-attach">0</property><property name="top-attach">1</property><property name="width">3</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="tooltip-text" translatable="yes">
        </property></object></child></object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">2</property></packing></child></object></child></object></child></object><packing><property name="position">7</property>
        </packing></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Alchemy Hoarding</property></object><packing><property name="position">7</property><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">5</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Your changes are saved automatically.</property><attributes><attribute name="style" value="italic"/>
        </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">15</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
        </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
      end

      def set_tooltips
        # Looting Tab
        self['loot_types:breakable'].tooltip_text = "Porous chunks of rock released as part of The Hive 12/17/2023"
        self['loot_defensive'].tooltip_text = "Swap to defensive before looting if there are hostile enemies."
        self['loot_phase'].tooltip_text = "Phases boxes if you are able to."
        self['favor_left'].tooltip_text = "Will favor left hand to stow for looting (defaults to right)"
        self['log_unlootables'].tooltip_text = "This will log items you can not loot into the Unlootable section (Loot Grid) otherwise it will ignore that section."
        self['use_disk'].tooltip_text = "Utilizes your disk for boxes if checked."
        self['keep_closed'].tooltip_text = "Will keep sacks closed (Performance hit!)"
        self['track_full_sacks'].tooltip_text = "Eloot will try to keep track of full sacks (turn off if not selling with eloot)"
        self['sigil_determination_on_fail'].tooltip_text = "Will use Sigil of Determination if you fail to loot because you are too injured."
        self['gambling_silvers_label'].tooltip_text = "Minimum number of coins before tossing in your gambling kit.\nNote: Incurs a 2 second rt."

        tooltip = "Bloodtoooth Bands are leg-worn bands that utilize the wearer's blood for a variety of effects. Their counterpart is the Bloodtooth Bracer.\n"
        tooltip += "If the wearer bears both the Bloodtooth Bands and a Bloodtooth Bracer, a special ability (Blood Bank) can be activated via RAISE (at a dead creature target that can bleed) to gain charges."
        self['use_bloodbands'].tooltip_text = tooltip

        # Looting Grid
        self['never_loot_label'].tooltip_text = "Exclusions should be entered one line at a time.\nRegular expressions are supported.\nExample: Enter (?:aquamarine|gold) wand and gold ring as separate entries."
        self['always_loot_label'].tooltip_text = "Always loot these items. They should be entered one line at a time.\nRegular expressions are supported.\nExample: Enter (?:aquamarine|gold) wand and gold ring as separate entries."
        self['creature_exclusion_label'].tooltip_text = "Exclusions should be entered one line at a time.\nRegular expressions are supported.\nExample: Enter (?:big ugly|mongrel) kobold and Vvrael destroyer as separate entries."
        self['unlootable_label'].tooltip_text = "Unlootable items should be entered one line at a time.\nRegular expressions are supported."

        # Boxes Tab
        self['always_check_pool'].tooltip_text = "If checked eloot will always check the pool for retruned boxes.\nDefault behavior is to only check if there is a box to drop off."
        self['in_between_label'].tooltip_text = "Enter the name of the script with any options.\nEx: <script name> <option1 option2 option3>\nThe script(s) will run after finishing the locksmith pool."

        # Selling Tab
        self['sell_loot_types:food'].tooltip_text = "Food will be thrown away or dropped since it can't be sold."
        self['sell_loot_types:box'].tooltip_text = "Sells empty gold, mithril, and silver boxes to the pawnshop."
        self['sell_loot_types:herb'].tooltip_text = "Herbs will be thrown away or dropped since they can't be sold."
        self['sell_loot_types:breakable'].tooltip_text = "Porous chunks of rock released as part of The Hive 12/17/2023\nThey need to be broken so the contents can be sold."
        self['sell_loot_types:junk'].tooltip_text = "Junk will be thrown away or dropped since they can't be sold."
        self['keep_silvers_label'].tooltip_text = "Setting this will ensure you keep a certain number of silvers on you after selling."

        # Selling Grid
        self['exclusions_label'].tooltip_text = "Exclusions should be entered one line at a time.\nRegular expressions are supported.\nEnter (?:aquamarine|gold) wand and gold ring as separate entries."
        self['keep_scrolls_label'].tooltip_text = "Add spells to this list to prevent selling scrolls that have matching spells.\nVibrant scrolls are supported.\nExample: Enter 101v or 101 vibrant for the vibrant scrolls\nEnter just the spell number otherwise - 101"

        # Skinning Tab
        self['skinning_exclusions_label'].tooltip_text = "Exclusions should be entered one line at a time.\nRegular expressions are supported.\nExample: Enter (?:big ugly|mongrel) kobold and Vvrael destroyer separately."

        # Hoarding Tabs
        tooltip = "Will try to enter the locker at each location.\nIf it is occupied it will go to the next one.\nIf it gets to the end of the list it will pause for 10 seconds,\nthen start from the beginning."
        self['gem_location_label'].tooltip_text = tooltip
        self['alchemy_location_label'].tooltip_text = tooltip

        notes = "Hoarding Notes:\n     Requires jars to store items\n     Able to use any size jar\n     Able to use empty jars for new gems\n     Does not buy jars\n     Will skip over full jars"
        self['gem_hoarding_notes'].text = notes
        self['alchemy_hoarding_notes'].text = notes
      end

      def self.get_category(key)
        @@categories.each { |category, data| return category unless data[key].nil? }
        nil
      end

      def self.get_setting(key)
        cat = Setup.get_category(key)
        return nil if cat.nil?

        @@categories[cat].each { |setting, data| return data if setting == key }
        nil
      end

      def validate_settings
        # set default values if they don't exist and correct Integer, Float and String types if saved settings are wrong class
        @@categories.each do |_, data|
          data.each { |key, value|
            if @settings[key].nil?
              @settings[key] = value[:default]
            elsif @settings[key].class != value[:default].class && !@settings[key].is_a?(TrueClass) && !@settings[key].is_a?(FalseClass)
              if value[:default].is_a?(Integer)
                @settings[key] = @settings[key].to_i
              elsif value[:default].is_a?(Float)
                @settings[key] = @settings[key].to_f
              elsif value[:default].is_a?(String)
                @settings[key] = @settings[key].to_s
              else
                echo("Key: #{key} default value class #{value[:default].class} does not match current class #{@settings[key].class}")
                echo("Report this to Elanthia-Online team!")
              end
            end
          }
        end
      end

      def initialize(settings)
        super()
        @settings = settings
        version = ELoot.get_script_version
        validate_settings

        # remove settings that doesn't exist
        @settings.delete_if { |key, _| next Setup.get_category(key).nil? }

        # use a GTK Builder to setup all the basics of the window then expand on that base
        return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

        Gtk.queue do
          # add_from_file("#{$data_dir}eloot.ui")
          add_from_string(Setup.eloot_ui)
          load_settings
          set_initial_conditions
          set_tooltips

          self['main'].keep_above = true
          self['main'].set_title "ELoot Setup v#{version}"

          # connect signals after settings are loaded to a bunch of handlers don't trigger
          connect_signals { |handler| method(handler) }
        end
      end

      def start
        @running = true
        Gtk.queue { self['main'].show_all }
        wait_while { @running }
      end

      def on_close_clicked
        # correct class types due to GTK elements converting class
        validate_settings
        ELoot.save_profile()
        self['main'].destroy
      end

      def on_destroy
        Gtk.queue { @running = false }
      end

      # iterate all objects and for any that match a setting name directly we set the default
      def load_settings
        Gtk.queue do
          # load up the generic settings which are just matching by name of the widget
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)

            key = obj.builder_name.to_sym
            next if (setting = Setup.get_setting(key)).nil?

            if obj.is_a?(Gtk::CheckButton)
              obj.active = @settings[key]
              obj.signal_connect('toggled') { on_update(obj) }
            elsif obj.class == Gtk::Button
              if key == :tipping_test
                tipping_test
              end
            elsif obj.class == Gtk::Entry
              obj.text = @settings[key].strip
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::SpinButton
              obj.value = @settings[key]
              obj.adjustment.value = @settings[key]
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.class == Gtk::ComboBoxText
              if obj.builder_name =~ /gem_locker|alchemy_locker/
                on_locker_load(obj.builder_name)
              end
            elsif obj.class == Gtk::TreeView
              next unless treeview_check(key)

              store = self["#{key}_store"]
              add = self["#{key}_add"]
              delete = self["#{key}_delete"]
              entry = self["#{key}_entry"]

              setting[:load].call(store, @settings[key])

              add.signal_connect('clicked') do
                next if entry.text.empty?

                setting[:set].call(store, entry.text, @settings[key])
                setting[:load].call(store, @settings[key])
                entry.text = ''
              end

              delete.signal_connect('clicked') do
                next if obj.selection.selected.nil?

                setting[:delete].call(store, obj.selection.selected, @settings[key])
                setting[:load].call(store, @settings[key])
              end
            end
          end

          # checkboxes for array storage with id's <setting>:<value>
          # this is primarily used by the loot types
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)
            next unless obj.builder_name =~ /^([^:]+):(.*)$/i
            next unless obj.class == Gtk::CheckButton

            key = Regexp.last_match(1).to_sym
            value = Regexp.last_match(2).to_s

            next if Setup.get_setting(key).nil?

            obj.active = @settings[key].include?(value)

            # add in hook
            obj.signal_connect('toggled') do
              @settings[key].delete(value)
              if obj.active?
                @settings[key].push(value)
                @settings[key].uniq!.sort!
              end
            end
          end
        end
      end

      def treeview_check(key)
        msg = []
        setting = Setup.get_setting(key)

        msg << "*** No :load defined for #{key}" unless setting[:load]

        %w[store add delete entry].each do |suffix|
          msg << "** Failed to find #{suffix} for treeview #{key}" unless self["#{key}_#{suffix}"]
        end

        return true if msg.empty?

        msg.each { |error| respond error }
        return false
      end

      def tipping_test
        self[:tipping_test].signal_connect("clicked") do
          rows = []
          rows << [{ value: "Box depositing starts at 1", colspan: 4, alignment: :center }]
          rows << :separator
          rows << ['Box No', 'Tip', 'Box No', 'Tip']
          rows << :separator

          first_half = [0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45]
          second_half = (50..100).step(5).to_a

          max_length = [first_half.length, second_half.length].max

          # # Add nil entries if the second half is shorter
          first_half += [nil] * (max_length - first_half.length)
          second_half += [nil] * (max_length - second_half.length)

          max_length.times do |i|
            first_item = "#{first_half[i]}  "
            second_item = "#{second_half[i]}  "

            tip_1 = first_item ? Sell.locksmith_tip(first_item, @settings[:base_tip], @settings[:max_tip], @settings[:alpha_rate]) : nil
            tip_1 = tip_1.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
            tip_1 = i == 0 ? @settings[:base_tip].to_i.round(0).to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse : tip_1

            tip_2 = !second_item.strip.empty? ? Sell.locksmith_tip(second_item, @settings[:base_tip], @settings[:max_tip], @settings[:alpha_rate]) : nil
            tip_2 = tip_2.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse

            rows << [first_item, tip_1, second_item, tip_2]
          end
          alpha = @settings[:alpha_rate].to_f.round(1)
          table = Terminal::Table.new :title => "Incremental Tipping (alpha: #{alpha})", :rows => rows
          (0..3).each do |i|
            table.align_column(i, :right)
          end
          respond
          respond table
          respond
        end
      end

      def on_locker_load(item)
        public_location = []
        public = Map.list.find_all { |room| room.tags.any?(/publiclockers/) }

        public.each { |room|
          if room.tags.any?(/publiclockers/)
            public_location << room.location.gsub(/the town of /, '')
          end
        }

        self[item].remove_all

        unless UserVars.mapdb_fwi_trinket
          public_location.delete_if { |place|
            place == 'Mist Harbor'
          }
        end

        self[item].append_text('')

        public_location.compact!  # Remove nil values
        public_location.uniq!     # Remove duplicates
        public_location.sort!     # Sort the array

        public_location.each { |place| self[item].append_text(place) }
      end

      # This is connected to automatically during load_settings.
      def on_update(obj)
        Gtk.queue do
          key = obj.builder_name.to_sym
          setting = Setup.get_setting(key)
          return if setting.nil?

          if obj.class == Gtk::CheckButton
            @settings[key] = obj.active?
            # Boxes Tab
            if obj.builder_name == "sell_locksmith_pool"
              if obj.active?
                enable_all(self["standard_tipping_frame"])
                enable_all(self["incremental_tipping_frame"])
              else
                disable_all(self["standard_tipping_frame"], exception: self["sell_locksmith_pool"])
                disable_all(self["incremental_tipping_frame"], exception: self["sell_locksmith_pool"])
              end
            end

            if key == :use_standard_tipping && obj.active?
              self['use_incremental_tipping'].active = false
              @settings[:use_incremental_tipping] = false
            end

            if key == :use_incremental_tipping && obj.active?
              self['use_standard_tipping'].active = false
              @settings[:use_standard_tipping] = false
            end

            # Hoarding
            if obj.builder_name =~ /gem_horde\b|alchemy_horde\b/
              type = obj.builder_name == 'gem_horde' ? 'gem' : 'alchemy'
              if obj.active?
                enable_all(self["#{type}_scrolled_window"])
                manage_hoard(nil, type.to_sym)
              else
                disable_all(self["#{type}_scrolled_window"], exception: self["#{type}_horde"])
              end
            end

            manage_hoard(key)

            # Skinning Tab
            if obj.builder_name == "skin_enable"
              if obj.active?
                enable_all(self["skinning_scrolled_window"])
                set_initial_conditions
              else
                disable_all(self["skinning_scrolled_window"], exception: self["skin_enable"])
              end
            end
          elsif obj.class == Gtk::Entry
            @settings[key] = obj.text.strip
          elsif obj.class == Gtk::SpinButton
            @settings[key] = obj.buffer.text
          end
        end
      end

      def set_initial_conditions
        disabled_conditions = {
          "loot_phase"                  => Stats.prof != 'Sorcerer',
          "skin_resolve"                => !Spell[9704].known?,
          "sigil_determination_on_fail" => !Spell[9716].known?,
          "skin_604"                    => !Spell[604].known?,
          "sell_shroud"                 => (!Spell[1205].known? && !Spell[1212].known?),
          "sell_aspect"                 => !Spell[650].known?,
        }

        Gtk.queue do
          manage_hoard

          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)
            if disabled_conditions[obj.builder_name]
              obj.set_sensitive(false)
              self[obj.builder_name].active = false
              @settings[obj.builder_name.to_sym] = false
            end
          end

          # Boxes Tab
          unless self["sell_locksmith_pool"].active?
            disable_all(self["standard_tipping_frame"], exception: self["sell_locksmith_pool"])
            disable_all(self["incremental_tipping_frame"], exception: self["sell_locksmith_pool"])
          end

          # Skinning Tab
          unless self["skin_enable"].active?
            disable_all(self["skinning_scrolled_window"], exception: self["skin_enable"])
          end

          # Gem and Alchemy tabs
          ['gem', 'alchemy'].each do |type|
            unless self["#{type}_horde"].active?
              disable_all(self["#{type}_scrolled_window"], exception: self["#{type}_horde"])
            end
          end
        end
      end

      def manage_hoard(key = nil, type = :all)
        types = type == :all ? [:gem, :alchemy] : [type]

        types.each do |t|
          type_prefix = t.to_s
          valid_keys = [
            "#{type_prefix}_everything_list".to_sym,
            "#{type_prefix}_only_list".to_sym,
            "#{type_prefix}_horde_locker".to_sym,
            "#{type_prefix}_horde_locker_che".to_sym
          ]

          # Return early if key is provided but not in valid_keys
          next if key && !valid_keys.include?(key)

          keys = key ? [key] : valid_keys

          keys.each do |k|
            case k
            when :"#{type_prefix}_everything_list"
              if self[k.to_s].active?
                self["#{type_prefix}_only_list"].active = false
                @settings[:"#{type_prefix}_only_list"] = false
                enable_all(self["#{type_prefix}_everything_frame"])
                disable_all(self["#{type_prefix}_only_frame"])
              end
            when :"#{type_prefix}_only_list"
              if self[k.to_s].active?
                self["#{type_prefix}_everything_list"].active = false
                @settings[:"#{type_prefix}_everything_list"] = false
                enable_all(self["#{type_prefix}_only_frame"])
                disable_all(self["#{type_prefix}_everything_frame"])
              end
            when :"#{type_prefix}_horde_locker"
              if self[k.to_s].active?
                self["#{type_prefix}_horde_locker_che"].active = false
                @settings[:"#{type_prefix}_horde_locker_che"] = false
                self["#{type_prefix}_locker"].set_sensitive(true)
                toggle_che_widgets(type_prefix, false)
              end
            when :"#{type_prefix}_horde_locker_che"
              if self[k.to_s].active?
                self["#{type_prefix}_horde_locker"].active = false
                @settings[:"#{type_prefix}_horde_locker"] = false
                self["#{type_prefix}_locker"].set_sensitive(false)
                toggle_che_widgets(type_prefix, true)
              end
            end
          end

          # Handle case when neither locker is active
          if !self["#{type_prefix}_horde_locker"].active? && !self["#{type_prefix}_horde_locker_che"].active?
            self["#{type_prefix}_locker"].set_sensitive(false)
            toggle_che_widgets(type_prefix, false)
          end

          # Handle case when neither list is active
          if !self["#{type_prefix}_everything_list"].active? && !self["#{type_prefix}_only_list"].active?
            disable_all(self["#{type_prefix}_everything_frame"])
            disable_all(self["#{type_prefix}_only_frame"])
          end
        end
      end

      def toggle_che_widgets(type, value)
        self["#{type}_horde_che_rooms"].set_sensitive(value)    # turn on/off CHE locker locations
        self["#{type}_horde_che_entry"].set_sensitive(value)    # turn on/off CHE locker entry verb
        self["#{type}_horde_che_exit"].set_sensitive(value)     # turn on/off CHE locker exit verb
      end

      def disable_all(container, exception: nil)
        container.each do |widget|
          next if exception && widget == exception # Skip the exception if provided

          # Disable interactive widgets
          if [Gtk::ComboBox, Gtk::ToggleButton, Gtk::Button, Gtk::TreeView].any? { |type| widget.is_a?(type) }
            widget.set_sensitive(false)
          elsif widget.is_a?(Gtk::Container)
            disable_all(widget, exception: exception) # Recurse into child containers
          else
            widget.set_sensitive(false) # Disable other non-container widgets
          end
        end
      end

      def enable_all(container)
        container.each do |child|
          child.set_sensitive(true)
          enable_all(child) if child.is_a?(Gtk::Container)
        end
      end

      def list(cat_to_list: 'all')
        indent_size = 2
        print_array =
          proc do |key, value, indent|
            _respond("#{' ' * indent_size * indent.to_i}#{key}:")
            value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
          end

        print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

        categories = cat_to_list == 'all' ? %w[loot sell skin internal] : [cat_to_list]
        if $frontend == 'stormfront'
          output = "<output class=\"mono\"/>\n"
        else
          output = String.new
        end
        categories.each do |opt|
          _respond("#{output}") if !output.empty?
          _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
          @@categories[opt.to_sym].each do |id, _|
            value = @settings[id]
            value.is_a?(Array) ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
          end
        end
        _respond("#{monsterbold_start}= GameObj Types =#{monsterbold_end}\n")
        _respond("#{GameObj.type_data.map { |k, _v| k }.sort.join(', ')}")
        if $frontend == 'stormfront'
          output = "<output class=\"\"/>\n"
          _respond("#{output}")
        end
      end

      def self.update_setting(key, value)
        setting = Setup.get_setting(key)
        ELoot.msg(type: "error", text: "** Setting \"#{key}\" does not exist") if setting.nil?

        action = nil

        if value.to_s =~ /^([+-])(.*)$/
          action = Regexp.last_match(1)
          value = Regexp.last_match(2).strip.downcase
        end

        if value.to_s == 'reset'
          @settings.delete(key)
          ELoot.msg(type: "info", text: " Reset #{key}")
        elsif @settings[key].is_a?(Array)
          if value =~ /\d/ && @settings[key][value.to_i]
            @settings[key].delete_at(value.to_i)
          else
            @settings[key].delete(value)
          end

          if action == '-'
            ELoot.msg(type: "info", text: " \"#{value}\" removed from \"#{key}\"")
          else
            @settings[key].push(value)
            ELoot.msg(type: "info", text: " \"#{value}\" added to \"#{key}\"")
          end

          ELoot.msg(type: "info", text: " \"#{key}\" is now \"#{@settings[key].join(', ')}\"")
        else
          if @settings[key].is_a?(FalseClass) || @settings[key].is_a?(TrueClass)
            value = value =~ /^true|1|yes|on/ ? true : false
          elsif @settings[key].is_a?(Integer)
            value = value.to_i
          end

          respond
          ELoot.msg(type: "yellow", text: " #{key.capitalize} has been set to #{value}")
          respond

          @settings[key] = value
        end
      end
    end
  end
end

module ELoot # Profile loading/saving and settings
  def self.coerce_setting_value(setting_name, default, input)
    case default
    when TrueClass, FalseClass
      fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
      fix_option.fetch(input[0]) do |v|
        ELoot.msg(type: "error", text: %{Expected a boolean (true/false/yes/no) value for "#{setting_name} but got "#{v}"})
        exit
      end
    when Array
      input
    when Integer
      v = input[0]
      if v =~ /\A[+-]?\d+\z/
        v.to_i
      else
        ELoot.msg(type: "error", text: %{Expected an integer value for #{setting_name} value but got "#{v}"})
        exit
      end
    when String
      input.join(" ")
    else
      ELoot.msg(type: "error", text: "Recognized #{setting_name} but don't know how to normalize a #{default.class} type setting")
      exit
    end
  end

  def self.launch_settings_ui
    Setup.new(data.settings).start
    ELoot.load(load_profile)
    ELoot.set_inventory
  end

  def self.load(settings)
    @@data = Data.new(settings)
  end

  def self.load_defaults()
    default_hash = {
      :loot_types                      => ["alchemy", "armor", "box", "breakable", "clothing", "collectible", "food", "gem", "jewelry", "lockpick", "lm trap", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand"],
      :loot_exclude                    => ["black ora", "urglaes"],
      :loot_phase                      => false,
      :use_disk                        => true,
      :loot_defensive                  => false,
      :coin_hand_name                  => "",
      :sigil_determination_on_fail     => false,
      :charm_name                      => "",
      :overflow_container              => "",
      :secondary_overflow              => "",
      :sell_loot_types                 => ["alchemy", "armor", "breakable", "clothing", "food", "gem", "jewelry", "lockpick", "magic", "reagent", "scroll", "skin", "uncommon", "valuable", "wand", "box", "lm trap"],
      :sell_container                  => ["default", "overflow", "box", "collectible", "forageable", "gem", "herb", "lockpick", "potion", "reagent", "scroll", "skin", "treasure", "trinket", "wand"],
      :sell_exclude                    => [],
      :sell_keep_scrolls               => [],
      :sell_appraise_types             => ["jewelry", "magic", "uncommon", "valuable"],
      :sell_appraise_gemshop           => 14999,
      :sell_appraise_pawnshop          => 34999,
      :sell_collectibles               => true,
      :sell_gold_rings                 => false,
      :sell_locksmith                  => false,
      :sell_locksmith_pool             => true,
      :always_check_pool               => false,
      :locksmith_withdraw_amount       => 8000,
      :display_box_contents            => true,
      :use_standard_tipping            => true,
      :sell_locksmith_pool_tip         => 15,
      :sell_locksmith_pool_tip_percent => true,
      :sell_share_silvers              => false,
      :sell_fwi                        => false,
      :sell_shroud                     => false,
      :sell_aspect                     => false,
      :sell_keep_silver                => 0,
      :skin_enable                     => false,
      :skin_kneel                      => false,
      :skin_604                        => false,
      :skin_resolve                    => false,
      :skin_sheath                     => "",
      :skin_weapon                     => "",
      :skin_sheath_blunt               => "",
      :skin_weapon_blunt               => "",
      :silence                         => false,
      :debug                           => false,
      :unskinnable                     => [],
      :unlootable                      => [],
      :auto_close                      => [],
      :crumbly                         => [],
      :keep_closed                     => false,
      :track_full_sacks                => true,
      :favor_left                      => false,
      :log_unlootables                 => false
    }

    Dir.mkdir(File.join(DATA_DIR, XMLData.game)) unless File.exist?(File.join(DATA_DIR, XMLData.game))
    Dir.mkdir(File.join(DATA_DIR, XMLData.game, Char.name)) unless File.exist?(File.join(DATA_DIR, XMLData.game, Char.name))

    File.write(File.join(DATA_DIR, XMLData.game, Char.name, "eloot.yaml"), default_hash.to_yaml)

    default_hash
  end

  def self.load_profile(name: Char.name)
    if name != nil
      filename = File.join(DATA_DIR, XMLData.game, name, "eloot.yaml")
      if File.exist?(filename) && name == Char.name
        settings_hash = YAML.load_file(filename)
      elsif !File.exist?(filename) && name != Char.name
        ELoot.msg(type: "error", text: " ELoot.load_profile: Attempt to load a profile that does not exist.")
      elsif !File.exist?(filename) && name == Char.name
        ELoot.msg(type: "info", text: " No current settings found.  Loading defaults...")
        settings_hash = ELoot.load_defaults()
      else
        ELoot.msg(type: "error", text: " ELoot.load_profile: There was an unknown error with loading a profile")
      end
    else
      ELoot.msg(type: "error", text: " ELoot.load_profile: name not defined")
    end

    settings_hash
  end

  def self.normalize_setting_name(input)
    input.downcase.tr('-', '_').to_sym
  end

  def self.save_hoard_profile
    # Saves profile for gems/reagents inventory syncs
    ELoot.data.inv_save = true

    if ELoot.data.hoard_type == 'gem'
      ELoot.data.gem_inventory = ELoot.data.inventory
    elsif ELoot.data.hoard_type == 'alchemy'
      ELoot.data.alchemy_inventory = ELoot.data.inventory
    end

    before_dying {
      if ELoot.data.inv_save
        ELoot.msg(type: "default", text: " Saving profile to sync gem/reagent inventories.")
        ELoot.data.settings[:gem_horde_inv] = ELoot.data.gem_inventory
        ELoot.data.settings[:alchemy_horde_inv] = ELoot.data.alchemy_inventory
        ELoot.save_profile
        ELoot.data.inv_save = false
      end
    }
  end

  def self.save_profile(silent: false)
    filename = File.join(DATA_DIR, XMLData.game, Char.name, "eloot.yaml")
    File.write(filename, ELoot.data.settings.to_yaml)
    ELoot.msg(type: "info", text: " Settings saved to file: #{filename}.") unless silent
  end

  def self.update_setting(input)
    setting_to_update = normalize_setting_name(input.first)
    ELoot.msg(type: "debug", text: "Normalized #{input.first} as #{setting_to_update}")

    if ELoot.data.settings.keys.include?(setting_to_update)
      default_value = ELoot.data.settings[setting_to_update].dup
      ELoot.msg(type: "debug", text: "recognized #{setting_to_update} as as valid #{default_value.class} setting")
      new_value = coerce_setting_value(setting_to_update, default_value, input[1..-1])
      ELoot.msg(type: "debug", text: "Normalized #{input[1..-1]} as #{new_value.inspect}")

      data.settings[setting_to_update] = new_value
      ELoot.msg(type: "info", text: " Updated #{setting_to_update} to #{new_value}")
      ELoot.save_profile()
    else
      ELoot.msg(type: "error", text: " #{setting_to_update} is not a recognized setting. Recognized setting names:")
      ELoot.msg(type: "error", text: ELoot.data.settings.keys.sort.join("\n"))
    end
  end
end

module ELoot # Sets Inventory
  def self.ensure_items(key: nil, list: nil, inventory: nil, check_hidden: false)
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    key = key.is_a?(Symbol) ? key : key.to_sym
    inventory ||= GameObj.inv
    item_name = ELoot.data.settings[key].to_s

    return if item_name.empty?

    # Check if item exists AND has the correct name
    recorded_item = list[key]

    if recorded_item.nil? || !recorded_item.name.include?(item_name)
      # Try to find the item in the inventory
      if (item = inventory.find { |i| i.name =~ /\b#{item_name}\b/i })
        list[key] = item
      elsif check_hidden
        ELoot.find_sheath_hidden(item_name, key.to_s)
      else
        list.delete(key)
      end
    end

    if list[key].nil? && caller_locations(1, 1)[0].label != 'set_inventory'
      ELoot.msg(text: " Can't find #{key}: #{item_name}. Please check ;eloot setup.", space: true)
    end
  end

  def self.get_weapon_inv
    # Need the weapon inventory for skinning
    exist = %r{<a exist=(?:'|")(?<id>.*?)(?:'|") noun=(?:'|")(?<noun>.*?)(?:'|")>(?<name>.*?)</a>}

    lines = ELoot.get_command("inventory full weapons", /You are currently wearing:|You are carrying no weapons at this time\./, silent: true, quiet: true)

    lines.each do |line|
      line.scan(exist) do |id, noun, name|
        unless ELoot.data.weapon_inv.any? { |weapon| weapon.id =~ /#{id}/ }
          ELoot.data.weapon_inv << GameObj.new(id, noun, name)
        end
      end
    end

    # Make sure to include what's in our hands
    ELoot.data.weapon_inv << GameObj.right_hand if checkright
    ELoot.data.weapon_inv << GameObj.left_hand if checkleft
  end

  def self.find_bloodtooth
    # When both band and bracer are present: unlocks ability to raise at dead creature to fill blood
    # https://gswiki.play.net/Bloodtooth_Band

    return unless ELoot.data.settings[:use_bloodbands]

    bracer = false

    GameObj.inv.each do |item|
      next unless item.name =~ /bands|bracer/

      lines = ELoot.get_command("analyze ##{item.id}", /You analyze/, silent: true, quiet: true)
      next unless lines.any? { |l| l =~ /magically drains some of your blood/ }

      bracer = true if item.name =~ /bracer/
      ELoot.data.blood_band = item if item.name =~ /bands/

      break if bracer && ELoot.data.blood_band
    end

    ELoot.data.settings[:use_bloodbands] = (bracer && ELoot.data.blood_band)
  end

  def self.find_coin_containers
    return if ELoot.data.settings[:coin_hand_name].to_s.empty?

    # #Are we wearing the coin hand?
    ELoot.data.coin_hand = GameObj.inv.find { |i| i.name =~ /\b#{ELoot.data.settings[:coin_hand_name]}\b/i }

    # If not wearing it loop thru inv and see if we can find it
    unless ELoot.data.coin_hand
      GameObj.inv.each do |item|
        next unless GameObj.containers[item.id]

        Inventory.open_single_container(item)

        ELoot.data.coin_hand = item.contents&.find { |thing| thing.name =~ /\b#{ELoot.data.settings[:coin_hand_name]}\b/i }
        if ELoot.data.coin_hand
          ELoot.data.coin_container = item
          break
        end
      end
    end

    # Return if not found or if it's a coin hand
    return unless ELoot.data.coin_hand && ELoot.data.coin_hand.name !~ /\b(coin|hand)\b.*\b(coin|hand)\b/

    # Is it a bag or a gambling kit?
    lines = ELoot.get_command("analyze ##{ELoot.data.coin_hand.id}", /You analyze/, silent: true, quiet: true)

    if lines.any? { |l| l =~ /noun must remain "pouch," "bag," or "purse," immediately preceded by the word "coin."/ }
      ELoot.data.coin_bag = ELoot.data.coin_hand
    elsif lines.any? { |l| l =~ /Gambling Kit/ }
      ELoot.data.gambling_kit = ELoot.data.coin_hand
    end
  end

  def self.find_sheath_hidden(sheath_name, type)
    # Fixme: needs expanded as more hidden sheaths are found (pun intended)
    ELoot.msg(type: "debug", text: "#{type} not found but is in setup")

    lines = Lich::Util.quiet_command_xml("pull my sheath", /You reach down|I'm afraid that/, /<prompt/, true, 2, true)
    ELoot.msg(type: "debug", text: "Is sheath hidden? : #{lines}")

    if lines.any? { |line| line =~ /You reach down/i }
      # Store the sheath if found
      if (skin_sheath = GameObj.inv.find { |i| i.name =~ /\b#{sheath_name}\b/i })
        ReadyList.ready_list[type.to_sym] = skin_sheath
      end

      Lich::Util.quiet_command_xml("push my #{sheath_name}", /You reach down|I'm afraid that you can't pull that/, /<prompt/, true, 2, true)
    end
  end

  def self.set_inventory # main start up inventory method
    # Check account type
    ELoot.data.account_type = Account.subscription

    # Make sure flag righthand and lefthand are turned off
    ELoot.get_command("flag righthand off", /You will not attempt to pick\s?up treasure using your right hand/, silent: true, quiet: true)
    ELoot.get_command("flag lefthand off", /You will not attempt to pick\s?up treasure using your left hand/, silent: true, quiet: true)

    # Make sure StowList and ReadyList are populated
    ReadyList.check(silent: true, quiet: true) unless ReadyList.checked?
    StowList.check(silent: true, quiet: true) unless StowList.checked?

    # Remove any extra keys and repopulate them
    ReadyList.ready_list.delete_if { |k, _| [:skin_weapon, :skin_weapon_blunt, :skin_sheath, :skin_sheath_blunt].include?(k) }
    StowList.stow_list.delete_if { |k, _| [:overflow_container, :secondary_overflow, :appraisal_container].include?(k) }

    # Find the stow containers we need: stow, overflow, appraisal
    ELoot.ensure_items(key: 'overflow_container', list: StowList.stow_list)
    ELoot.ensure_items(key: 'secondary_overflow', list: StowList.stow_list)
    ELoot.ensure_items(key: 'appraisal_container', list: StowList.stow_list)

    # Find skin sheaths
    if ELoot.data.settings[:skin_enable]
      ELoot.ensure_items(key: 'skin_sheath', list: ReadyList.ready_list, check_hidden: true)
      ELoot.ensure_items(key: 'skin_sheath_blunt', list: ReadyList.ready_list, check_hidden: true)
    end

    # Make sure the bags are open and contents available
    StowList.stow_list.values.uniq.compact.each do |item|
      Inventory.open_single_container(item)
    end

    # Get weapon inventory for skinning weapons
    ELoot.get_weapon_inv

    # Find the skinning weapons
    ELoot.ensure_items(key: 'skin_weapon', list: ReadyList.ready_list, inventory: ELoot.data.weapon_inv)
    ELoot.ensure_items(key: 'skin_weapon_blunt', list: ReadyList.ready_list, inventory: ELoot.data.weapon_inv)

    # Are we using weighless coin containers?
    ELoot.find_coin_containers

    # Do we have a fossil charm?
    unless (charm_name = ELoot.data.settings[:charm_name].to_s).empty?
      ELoot.data.charm = GameObj.inv.find { |i| i.name =~ /\b#{charm_name}\b/i }
    end

    # Using a blood band?
    ELoot.find_bloodtooth

    # Have an eonake gauntlet?
    ELoot.data.gauntlet = GameObj.inv.find { |i| i.name =~ /\beonake gauntlet\b/i }

    # Using a disk?
    ELoot.disk_usage

    # If ELoot.data.settings[:keep_closed] close anything we opened
    Inventory.close_sell_containers

    ELoot.validate_setup
  end

  def self.set_selling_containers(type: nil)
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    container_array = []

    # Add the specific type container if it's in the sell list
    if type && ELoot.data.settings[:sell_container].include?(type)
      container = StowList.stow_list[type.to_sym]
      container_array << container if container
    end

    # Add the default container
    if ELoot.data.settings[:sell_container].include?("default")
      container_array << StowList.default
    end

    # Handle overflow containers
    if ELoot.data.settings[:sell_container].include?("overflow")
      [:overflow_container, :secondary_overflow].each do |key|
        ELoot.ensure_items(key: key, list: StowList.stow_list)
        container = StowList.stow_list[key]
        container_array << container if container
      end
    end

    # Remove duplicates and ensure an array is always returned
    container_array.compact.uniq
  end

  def self.validate_setup
    need_exit = false

    checks = [
      [:overflow_container, StowList.stow_list[:overflow_container], "primary overflow container"],
      [:secondary_overflow, StowList.stow_list[:secondary_overflow], "secondary overflow container"],
      [:appraisal_container, StowList.stow_list[:appraisal_container], "appraisal container"],
      [:skin_sheath, ReadyList.ready_list[:skin_sheath], "bladed skinning sheath", :skin_enable],
      [:skin_sheath_blunt, ReadyList.ready_list[:skin_sheath_blunt], "blunt skinning sheath", :skin_enable],
      [:skin_weapon, ReadyList.ready_list[:skin_weapon], "bladed skinning weapon", :skin_enable],
      [:skin_weapon_blunt, ReadyList.ready_list[:skin_weapon_blunt], "blunt skinning weapon", :skin_enable],
      [:coin_hand_name, ELoot.data.coin_hand, "coin storage"],
      [:charm_name, ELoot.data.charm, "fossil charm"],
    ]

    checks.each do |setting_key, found_obj, label, conditional_key|
      # Only check if setting is non-empty and optional condition (like :skin_enable) is satisfied
      next if ELoot.data.settings[setting_key].to_s.empty?
      next if conditional_key && !ELoot.data.settings[conditional_key]

      if found_obj.nil?
        ELoot.msg(text: " Not able to find the #{label}: #{ELoot.data.settings[setting_key]}")
        need_exit = true
      end
    end

    if need_exit
      ELoot.msg(text: " Something went wrong initializing eloot. Please check ;eloot setup. Exiting...", space: true)
      exit
    end
  end
end

module ELoot # Main methods
  @@data ||= nil

  def self.data
    @@data
  end

  def self.loot
    if Spell['Berserk'].active?
      ELoot.msg(type: "info", text: " Berserk is active and preventing you from looting.")
      return
    end

    sleep 0.2

    # remember what is in our hands
    ELoot.data.right_hand = GameObj.right_hand
    ELoot.data.left_hand = GameObj.left_hand

    ELoot.change_stance(100) if ELoot.data.settings[:loot_defensive]
    ELoot.msg(type: "debug", text: "ELoot.loot: Defensive Stance") if ELoot.data.settings[:loot_defensive]

    ELoot.msg(type: "debug", text: "ELoot.loot: Begin Skinning") if ELoot.data.settings[:skin_enable]
    Loot.skin if ELoot.data.settings[:skin_enable]

    ELoot.msg(type: "debug", text: "ELoot.loot: Searching")
    Loot.search
    sleep(0.1)

    ELoot.msg(type: "debug", text: "ELoot.loot: Looting the Room")
    Loot.room

    # use coin hand if we have it
    ELoot.use_coin_hand

    Inventory.return_hands
  end

  def self.sell
    Sell.sell
  end
end

module ELoot # Regional bounty Selling
  module Region
    def self.by_town(tag)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")
      ELoot.data.towns.to_h { |town| [town.location, Room[town.find_nearest_by_tag(tag)]] }
    end

    def self.tag_for_town(town, tag)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")
      self.by_town(tag).find { |k, _v| k.downcase.include?(town.downcase) }.last
    end

    def self.in_region(place) # Determine if the bounty town is within the characters region
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")
      # vaalor ferry, west cart, east cart, RR boot
      boundaries = [
        Map.ids_from_uid(14001002).first, # Ta'Vaalor Ferry
        Map.ids_from_uid(13002021).first, # Western Spine Mine Cart
        Map.ids_from_uid(13003019).first, # Eastern Spine Mine Cart
        Map.ids_from_uid(373014).first,   # River's Rest Boot
        Map.ids_from_uid(7503001).first,  # Hinterwilds Caravan Dropoff
        Map.ids_from_uid(13205202).first, # EN Hinterwilds Transport
        Map.ids_from_uid(4132054).first,  # IMT Hinterwilds Transport
        Map.ids_from_uid(7111).first,     # Portmaster - Wehnimer's Landing
        Map.ids_from_uid(3002033).first,  # Portmaster - Teras Isle
        Map.ids_from_uid(2101030).first,  # Portmaster - River's Rest
        Map.ids_from_uid(4744014).first,  # Portmaster - Solhaven
        Map.ids_from_uid(7118259).first,  # Portmaster - Kraken's Fall
        Map.ids_from_uid(7136032).first,  # Portmaster - Ta'Vaalor
        Map.ids_from_uid(7133026).first,  # Portmaster - Icemule Trace
      ]

      bounty_town = Bounty.town == "Cold River" ? "Hinterwilds" : Bounty.town

      place = self.tag_for_town(bounty_town, place).id
      path = Room.current.path_to(Room[place])

      return place if path && boundaries.none? { |fence| path.include?(fence) }
    end

    def self.furrier
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")
      self.in_region("furrier")
    end

    def self.gemshop
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")
      self.in_region("gemshop")
    end
  end
end

module ELoot # Script utility type methods
  def self.capitalize_words(string)
    cap_string = string.to_s.split.each { |i| i.capitalize! }.join(' ')
    return cap_string
  end

  def self.disk_usage
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    return if DownstreamHook.list.include?("eloot-diskintegration") && ELoot.data.settings[:use_disk] && !ELoot.data.disk.nil?

    if ELoot.data.settings[:use_disk]
      if ELoot.data.disk.nil?
        # Longer search if hook isn't already present
        if DownstreamHook.list.include?("eloot-diskintegration")
          ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{XMLData.name} #{ELoot.data.disk_nouns_regex}\b/ }
        else
          15.times do
            ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{XMLData.name} #{ELoot.data.disk_nouns_regex}\b/ }
            break if ELoot.data.disk
            sleep(0.1)
          end
        end
      end

      # Add downstream hook if not already present
      unless DownstreamHook.list.include?("eloot-diskintegration")
        DownstreamHook.add(
          'eloot-diskintegration',
          proc do |line|
            if line =~ /The \<a exist\=\"\d+\" noun\=\"#{ELoot.data.disk.noun}\"\>#{ELoot.data.disk.name}\<\/a\>.+ disintegrates\./
              ELoot.data.disk = nil
              ELoot.data.disk_full = false
            end
            line
          end
        )
      end

    else
      # Clear disk and remove downstream hook if not using disk
      ELoot.data.disk = nil
      DownstreamHook.remove("eloot-diskintegration")
    end
  end

  def self.fix_item_key(item)
    case item.to_s
    when 'secondary_weapon' then '2weapon'
    when 'ranged_weapon'    then 'ranged'
    else item
    end
  end

  def self.format_number(number)
    whole, decimal = number.to_s.split('.')
    if whole.to_i < -999 || whole.to_i > 999
      whole.reverse!.gsub!(/(\d{3})(?=\d)/, '\\1,').reverse!
    end
    [whole, decimal].compact.join('.')
  end

  def self.get_command(command, regex, silent: nil, quiet: false)
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    if ELoot.data.settings[:debug]
      silent = nil
      quiet = false
    end

    lines = []
    rt_regex = /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i
    regex = Regexp.union(regex, rt_regex)

    begin
      lines = Lich::Util.issue_command(command, regex, usexml: true, silent: silent, quiet: quiet)

      ELoot.msg(type: "debug", text: " get_command: command: #{command} | lines - #{lines}")
      raise if lines.any? { |l| l =~ rt_regex }
    rescue
      ELoot.wait_rt
      retry
    end

    return lines
  end

  def self.get_res(command, regex = nil)
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")
    rt_regex = /(?:Roundtime:|\.\.\.wait|Wait) (\d+) [Ss]ec(?:onds?)?\.?|An uncontrollable urge to scratch the rash/
    regex = regex.nil? ? Regexp.union(/.*?/, rt_regex) : Regexp.union(regex, rt_regex)
    result = nil
    loop do
      result = dothistimeout(command, 3, regex)
      break unless result =~ rt_regex

      ELoot.wait_rt
    end

    return result
  end

  def self.get_script_version
    data = Script.list.find { |x| x.name == Script.current.name }.inspect
    return data[/version: (\d+\.\d+\.\d+)/i, 1]
  end

  def self.help
    rows = []
    rows << [{ value: "*** Mark ANYTHING you don't want to lose. #{Script.current.name.capitalize} is not perfect! ***", colspan: 2, alignment: :center }]
    rows << :separator
    rows << ['Command', 'Description']
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} setup", "UI configuration tool"]
    rows << [' ', ' ']
    rows << ["#{$lich_char}#{Script.current.name}", "Loots items/creatures"]
    rows << ["#{$lich_char}#{Script.current.name} sell", "Sells loot based on UI options"]
    rows << ["#{$lich_char}#{Script.current.name} sell alchemy_mode", "Doesn't sell alchemy reagents"]
    rows << ["#{$lich_char}#{Script.current.name} deposit", "Deposits coins and notes"]
    rows << [' ', ' ']
    rows << ["#{$lich_char}#{Script.current.name} pool", "Only does the locksmith pool"]
    rows << ["#{$lich_char}#{Script.current.name} pool deposit", "Only deposits boxes"]
    rows << ["#{$lich_char}#{Script.current.name} pool return", "Only returns boxes"]
    rows << :separator
    rows << [{ value: 'Command Line Options', colspan: 2, alignment: :center }]
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} --sellable <categories>", "Items that match GameObj sellable categories"]
    rows << ["#{$lich_char}#{Script.current.name} --type <things>", "Items that match GameObj types"]
    rows << ["#{$lich_char}#{Script.current.name} --sell <items>", "Specific items"]
    rows << :separator
    rows << [{ value: 'Hoarding', colspan: 2, alignment: :center }]
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} list <gem/reagent>", "Lists hoarded inventory"]
    rows << ["#{$lich_char}#{Script.current.name} reset <gem/reagent>", "Resets hoarded inventory"]
    rows << ["#{$lich_char}#{Script.current.name} deposit <gem/reagent>", "Deposits item(s) into hoard"]
    rows << ["#{$lich_char}#{Script.current.name} raid <gem/reagent> <item> x<amount>", "Raids hoard for item(s)"]
    rows << ["#{$lich_char}#{Script.current.name} bounty", "Raids hoard for bounty gems"]
    rows << :separator
    rows << [{ value: 'Troubleshooting', colspan: 2, alignment: :center }]
    rows << :separator
    rows << ["#{$lich_char}#{Script.current.name} debug", "Toggles debugging on or off"]
    rows << ["#{$lich_char}#{Script.current.name} debug file", "Toggles logging to a file on or off"]
    rows << ["#{$lich_char}#{Script.current.name} list", "Lists script settings"]
    rows << ["#{$lich_char}#{Script.current.name} test", "Lists variables and their values"]
    rows << :separator
    rows << [{ value: "*** Mark ANYTHING you don't want to lose. #{Script.current.name.capitalize} is not perfect! ***", colspan: 2, alignment: :center }]

    table = Terminal::Table.new :title => "#{Script.current.name.capitalize} Help", :rows => rows
    table.align_column(1, :right)
    respond
    respond table
    respond
  end

  def self.manage_sorter
    if running? "sorter"
      kill_script("sorter")
      before_dying { Script.start('sorter') }
    end
  end

  def self.msg(type: "yellow", text: nil, space: false)
    # color options - set type to use
    # yellow, orange, teal, green, plain

    return if type == "debug" && (!ELoot.data.settings[:debug] && !ELoot.data.settings[:debug_file])

    if text.is_a?(Hash)
      text = text.inspect.gsub("#<", "#")
    elsif text.is_a?(Array)
      text = text.to_s
    elsif text.is_a?(String)
      text = text.gsub("#<", "#")
    end

    respond '' if space
    if type == 'debug' && ELoot.data.settings[:debug]
      begin
        Lich::Messaging.mono(Lich::Messaging.xml_encode(text))
      rescue NoMethodError
        respond(text)
      end
    elsif type != 'debug'
      Lich::Messaging.msg(type, text)
    end
    respond '' if space

    if ELoot.data.settings[:debug_file]
      ELoot.data.debug_logger.log(text)
    end
  end

  def self.test(debug = false)
    rows = []
    rows << :separator
    rows << [{ value: "   *** Settings ***", colspan: 7 }]
    rows << :separator
    rows << ["Parameter", { value: "Value", colspan: 6 }]
    rows << :separator
    ELoot.data.settings.each do |item|
      setting_value = item[0].to_s =~ /gem_horde_inv|alchemy_horde_inv/ ? item[1].join("\n") : ELoot.word_wrap(item[1].to_s)
      rows << [item[0], { value: setting_value, colspan: 6 }]
    end

    rows << :separator
    rows << [{ value: " *** Sacks ***", colspan: 7 }]
    rows << :separator
    rows << ["Type", "ID", { value: "Name", colspan: 5 }]
    rows << :separator
    StowList.stow_list.each do |key, value|
      rows << [key, value.id, { value: value.name, colspan: 5 }]
    end

    rows << :separator
    rows << [{ value: " *** Disk ***", colspan: 7 }]
    rows << :separator
    rows << ["ID", { value: "Name", colspan: 6 }]
    rows << :separator
    rows << [ELoot.data.disk.id, { value: ELoot.data.disk.name, colspan: 6 }]

    rows << :separator
    rows << [{ value: " *** Full Disk/Sack Check ***", colspan: 7 }]
    rows << :separator
    rows << [{ value: "Disk Full: #{ELoot.data.disk_full.inspect}", colspan: 7 }]
    rows << [{ value: "Sacks Full: #{ELoot.data.sacks_full.map(&:name)}", colspan: 7 }]

    rows << :separator
    rows << [{ value: " *** Contents ***", colspan: 7 }]
    rows << :separator
    rows << ["Container", "Item", "Type", { value: "Sellable", colspan: 4 }]
    rows << :separator
    items_opened = []

    StowList.stow_list.each_value do |sack|
      next if items_opened.include?(sack.id)
      next if sack.nil?

      items_opened << sack.id
      Inventory.open_single_container(sack)

      sack.contents.each do |thing|
        rows << [sack.noun.capitalize, ELoot.word_wrap(thing.name, 25), thing.type.split(',').join("\n"), { value: thing.sellable, colspan: 4 }]
      end
    end

    rows << :separator
    rows << [{ value: " *** Ready List ***", colspan: 7 }]
    rows << :separator
    rows << ["Type", "ID", { value: "Name", colspan: 5 }]
    rows << :separator
    ReadyList.ready_list.each do |key, value|
      rows << [key, value.id, { value: value.name, colspan: 5 }]
    end

    rows << :separator
    rows << [{ value: " *** Skinning Weapons ***", colspan: 7 }]
    rows << :separator
    rows << ["Type", "ID", { value: "Name", colspan: 5 }]
    rows << :separator
    rows << ["Edged Skinner", ReadyList.ready_list[:skin_weapon].id, { value: ReadyList.ready_list[:skin_weapon].name, colspan: 5 }]
    rows << ["Blunt Skinner", ReadyList.ready_list[:skin_weapon_blunt].id, { value: ReadyList.ready_list[:skin_weapon_blunt].name, colspan: 5 }]

    rows << :separator
    rows << [{ value: " *** Coin Hand ***", colspan: 7 }]
    rows << :separator
    rows << ["Type", "ID", { value: "Name", colspan: 5 }]
    rows << :separator
    rows << ["Coin Hand", ELoot.data.coin_hand.id, { value: ELoot.data.coin_hand.name, colspan: 5 }]
    rows << ["Coin Container", ELoot.data.coin_container.id, { value: ELoot.data.coin_container.name, colspan: 5 }]

    rows << :separator
    rows << [{ value: " *** GameObj Types ***", colspan: 7 }]
    rows << :separator
    rows << [{ value: "#{ELoot.word_wrap(GameObj.type_data.map { |k, _v| k }.sort.join(', '), 100)}", colspan: 7 }]

    table = Terminal::Table.new :title => "#{Script.current.name.capitalize} v#{ELoot.get_script_version}", :rows => rows

    if debug
      return table
    else
      respond
      respond table
      respond
    end
  end

  def self.time_between(method_name, gap)
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")
    current_time = Time.now

    # Check if the method was previously called and if the time gap is satisfied
    if ELoot.data.last_called[method_name]
      time_diff = current_time - ELoot.data.last_called[method_name]
      return false if time_diff < gap
    end

    ELoot.data.last_called[method_name] = current_time
    return true # Return true if either it's the first call or enough time has passed
  end

  def self.unlootable(item)
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    return unless ELoot.data.settings[:log_unlootables]
    return unless item.type.nil?

    ELoot.msg(type: "info", text: " #{item.name} was not lootable, adding to list.")
    ELoot.data.settings[:unlootable].push(item.name)
    ELoot.save_profile()
  end

  def self.word_wrap(text, width = 60)
    text.gsub(/(.{1,#{width}})(\s+|\Z)/, "\\1\n").strip
  end

  def self.wait_rt
    sleep 0.2
    waitcastrt?
    waitrt?
    sleep 0.2
  end
end

module ELoot # Game utility type methods
  def self.box_phase(box)
    return unless box.type =~ /box/
    return if box.name =~ /enruned|mithril/i
    return unless ELoot.data.settings[:loot_phase] && Spell[704].known? && Spell[704].affordable?

    loop {
      cast_result = Spell[704].cast("at ##{box.id}")
      break unless cast_result =~ /^\[Spell Hindrance for/ && Spell[704].affordable?
    }
  end

  def self.box_unphase(box)
    lines = ELoot.get_command("look at ##{box.id}", /You see/, silent: true, quiet: true)
    return box unless lines.any? { |line| line =~ /shifting/i }

    dothistimeout("drop ##{box.id}", 3, /flickers in and out of existence/)
    ELoot.wait_rt

    ELoot.get_command("glance hands", /<(right|left)/, silent: true, quiet: true)

    return [GameObj.right_hand, GameObj.left_hand].find { |hand| hand.type =~ /box/ }
  end

  def self.change_stance(new_stance)
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")
    return if Effects::Debuffs.active?("Frenzy") || dead?
    return if Char.percent_stance >= new_stance
    return if new_stance == 100 && Char.percent_stance >= 80

    stances = {
      0   => 'offensive',
      20  => 'advanced',
      40  => 'forward',
      60  => 'neutral',
      80  => 'guarded',
      100 => 'defensive'
    }
    if CMan.available?('Stance Perfection') && ![0, 20, 40, 60, 80, 100].include?(new_stance)
      cmd = "cman stance #{new_stance}"
    elsif stances[new_stance]
      cmd = "stance #{stances[new_stance]}"
    else
      cmd = 'stance defensive'
    end

    expiry = Time.now + 2
    while Char.percent_stance != new_stance
      res = dothistimeout(cmd, 2, /You are now|You move into|Roundtime|wait|Your rage causes you/i)
      if res =~ /Roundtime: (\d+)|wait (\d+)/i
        sleep((Regexp.last_match(1) || Regexp.last_match(2)).strip.to_f - 1)
        expiry = Time.now + 2
      elsif Time.now > expiry
        break
      else
        break
      end
      sleep 0.5
    end
  end

  def self.decurse(obj)
    return true unless obj.type =~ /cursed/
    return false unless ELoot.data.settings[:loot_types].include?("cursed")

    if Spell[315].known? && !Spell[315].affordable?
      mana_regex = Regexp.union(
        /An invigorating rush of mana pulses through you/i,
        /You are too mentally fatigued to attempt this ability/i,
        /You're already at full mana./i,
        /Your mana control skills are not yet advanced/i,
      )
      dothistimeout "mana pulse", 2, mana_regex
    end

    if Spell[315].known? && !Spell[315].affordable?
      ELoot.msg(type: "info", text: "** #{obj.name} is cursed and you don't have enough mana to cast 315.", space: true)
      return false
    end

    if Spell[315].known? && Spell[315].affordable?
      Spell[315].cast("at ##{obj.id}")
      return true
    end

    unless ELoot.data.gauntlet.nil?
      lines = ELoot.get_command("look ##{ELoot.data.gauntlet.id}", /You are currently wearing the eonake gauntlet/, silent: true, quiet: true)
      if lines.any? { |l| l =~ /(right|left) hand/ }
        gauntlet_hand = Regexp.last_match(1)
      end

      if GameObj.right_hand.name == 'Empty'
        return true if gauntlet_hand == 'right'
        if gauntlet_hand == 'left'
          ELoot.get_res("remove ##{ELoot.data.gauntlet.id}", /You slip the gauntlet from/)
          ELoot.get_res("swap", /You swap/) unless GameObj.right_hand.id == ELoot.data.gauntlet.id
          ELoot.get_res("wear ##{ELoot.data.gauntlet.id}", /You slip the eonake gauntlet over/)
          return true
        end
      end

      if GameObj.left_hand.name == 'Empty'
        return true if gauntlet_hand == 'left'
        if gauntlet_hand == 'right'
          ELoot.get_res("remove ##{ELoot.data.gauntlet.id}", /You slip the gauntlet from/)
          ELoot.get_res("swap", /You swap/) unless GameObj.left_hand.id == ELoot.data.gauntlet.id
          ELoot.get_res("wear ##{ELoot.data.gauntlet.id}", /You slip the eonake gauntlet over/)
          return true
        end
      end
    end

    return false
  end

  def self.find_boxes
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    box_sacks = ELoot.set_selling_containers(type: 'box')

    ELoot.msg(type: "debug", text: " box_sacks: #{box_sacks}")

    items = []
    checked_containers = []
    box_sacks.each { |sack|
      next if sack.nil? || checked_containers.include?(sack.id)

      checked_containers.push(sack.id)
      Inventory.open_single_container(sack)
      found_boxes = sack.contents.to_a.find_all { |obj| obj.type =~ /box/ }
      unless found_boxes.nil? || found_boxes.empty?
        items += found_boxes
        ELoot.data.sacks_full.delete(sack)
      end
    }

    if ELoot.data.settings[:use_disk]
      ELoot.wait_rt
      ELoot.wait_for_disk
      unless ELoot.data.disk.nil?
        Inventory.open_single_container(ELoot.data.disk)
        items += ELoot.data.disk.contents.to_a.find_all { |obj| obj.type =~ /box/ }
      end
    end

    ELoot.msg(type: "debug", text: " box_list before: #{items}")

    box_list = items.uniq

    ELoot.msg(type: "debug", text: " box_list after: #{box_list}")

    box_list.reject! { |box| box.contents.empty? }

    box_list.dup.each do |box|
      lines = ELoot.get_command("look in ##{box.id}", /<container|That is closed|You see the shifting form/, silent: true, quiet: true)

      if lines.any? { |line| line =~ /In the|There is nothing/i }
        if box.contents.length.positive?
          unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
            Inventory.drag(box)
          end
          Loot.box_loot(box)
        end
        box_list.delete(box)
      end
    end

    return box_list
  end

  def self.find_trash
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    trashcan = nil
    trash_id = nil

    # Use new trash verb first
    lines = ELoot.get_command('trash', /You could discard items|You do not notice/, silent: true, quiet: true)

    lines.each do |line|
      if (match_data = line.match(/You could discard items in (?:an?|the) <a exist="(-?\d+)" noun=".*?">.*?<\/a>/))
        trash_id = match_data[1]
      end
    end

    unless trash_id.nil?
      trashcan = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.id == trash_id }
      return trashcan unless trashcan.nil?
    end

    # Still here see if the meta tag is present
    can = Regexp.last_match(1) if Room.current.tags.find { |t| t =~ /meta:trashcan:(.*)/ }

    # Most common scenario - meta:trashcan is defined and GameObj.room_desc is available or trashcan is in GameObj.loot
    trashcan = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.name =~ Regexp.union(can.to_a) }
    return trashcan unless trashcan.nil?

    # Still here? Either the meta:can isn't defined or the room description isn't available. Either way we have to use the noun.
    can = ["barrel", "bin", "basket", "bucket", "canister", "case", "casket", "crate", "hearth", "pit", "stump", "urn", "wastebasket", "wastebin", "wastecan"]
    trash = (Room.current.description.to_s + GameObj.room_desc.to_s + GameObj.loot.to_s).scan(Regexp.union(can)).uniq

    # Check to make sure it's actually a trashcan and not a custom disk/container
    trash.each { |item|
      lines = ELoot.get_command("look in #{item}", /<container|I could not find what you were referring to.|The(.*?)is filled with a variety of garbage/, silent: true, quiet: true)

      if lines.grep(/variety of garbage/).any?
        trashcan = GameObj.new(Regexp.last_match(1), item, item) if lines.find { |l| l =~ /^<container id='(-?[0-9]+)' title/ }
      end

      break unless trashcan.nil?
    }

    return trashcan
  end

  def self.find_worker
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    worker = nil
    lines = nil
    name = $1 if Room.current.tags.find { |w| w =~ /meta:boxpool:npc:(.*)/ }

    unless name
      name = ["worker", "trickster", "Jahck", "woman", "attendant", "gnome", "merchant", "dwarf"]
    end

    20.times {
      worker = (GameObj.npcs).find { |obj| obj.name =~ Regexp.union(name) }
      break if worker

      lines = ELoot.get_command("look", /<resource picture/, silent: true, quiet: true)
      sleep 0.1
    }

    if worker.nil?
      ELoot.msg(type: "info", text: " Failed to find the locksmith pool NPC")
      ELoot.msg(type: "info", text: " GameObj.npcs: #{GameObj.npcs}")
      ELoot.msg(type: "info", text: " Lines: #{lines}")

      ELoot.msg(type: "info", text: " Update your map db; ;repository download-mapdb")
      ELoot.msg(type: "info", text: " If the error persists then report this to Elanthia-Online")
      exit
    end

    return worker
  end

  def self.fwi?(room)
    (room.location =~ /Four Winds|Mist Harbor|Western Harbor/)
  end

  def self.fwi_return
    current_town = Room.current.find_nearest_by_tag("town")

    if current_town == 3668
      if UserVars.mapdb_fwi_trinket.nil?
        ELoot.msg(type: "yellow", text: "  Please set your FWI trinket in go2 setup. \n")
        exit
      end

      ELoot.go2(3669)
      if UserVars.mapdb_fwi_return_room.nil?
        worn = GameObj[UserVars.mapdb_fwi_trinket].nil? ? false : true
        fput "get my #{UserVars.mapdb_fwi_trinket}" unless worn
        fput "turn ##{GameObj[UserVars.mapdb_fwi_trinket].id}"
        fput "stow my #{UserVars.mapdb_fwi_trinket}" unless worn
      else
        ELoot.go2(UserVars.mapdb_fwi_return_room)
      end
    end
  end

  def self.f2p?
    return false if XMLData.game == 'GST'
    ELoot.data.account_type =~ /F2P|Free/i
  end

  def self.go2(place)
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]} | place: #{place}")
    fput('unhide') if (hidden? || invisible?)

    # If we're going to a place we do it based on the sell_fwi settings
    if place.is_a?(String) && ELoot.data.settings[:sell_fwi]
      fwi_place = Room.list.find { |room| room.tags.include?(place) && ELoot.fwi?(room) }

      place = fwi_place.id if fwi_place
    end

    return if Room.current.id == place || Room.current.tags.include?(place)

    if Room.current.id.nil?
      ELoot.msg(type: "error", text: ' unknown room location')
    end

    if place.is_a?(String) && UserVars.mapdb_use_urchins && UserVars.mapdb_urchins_expire.positive? && XMLData.game != 'GSIV' && Room.current.location !~ /the Hinterwilds/

      case place
      when 'locksmith pool'
        place = 'locksmithpool'
      when 'pawnshop'
        place = 'pawn'
      when 'consignment'
        place = 'alchemy'
      end

      Script.run('go2', "town --disable-confirm", { quiet: true }) if Room.current.tags.any?(/nexus/)

      result = dothistimeout("urchin guide #{place}", 3, ELoot.data.urchin_msg)
      if result =~ /You currently have no access to the urchin/
        UserVars.mapdb_use_urchins = false
        Script.run('go2', "#{place} --disable-confirm", { quiet: true })
      elsif result.nil?
        ELoot.msg(type: "error", text: " Unknown result from urchin guide usage.")
      end
    else
      Script.run('go2', "#{place} --disable-confirm", { quiet: true })
    end
  end

  def self.deposit_note
    return unless (note = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /\b(?:note|scrip|chit)\b/ })

    current_room = Room.current.id

    _where_is_previous_var, shortest_distances = Room.current.dijkstra

    bank_rooms = Room.list.find_all { |room| room.tags.include?('bank') && !ELoot.fwi?(room) }.map(&:id)

    # Filter out rooms that have no path (distance is nil)
    reachable_banks = bank_rooms.select { |room_id| shortest_distances[room_id] }

    # Pick the bank room with the shortest distance
    local_bank = reachable_banks.min_by { |room_id| shortest_distances[room_id] }

    ELoot.go2(local_bank)

    fput("deposit note")

    20.times do
      break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(note.id))
      sleep 0.1
    end

    ELoot.go2(current_room)
  end

  def self.read_note
    result = 0
    note = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /\b(?:note|scrip|chit)\b/ }
    return unless note

    line = ELoot.get_res("read ##{note.id}", /Hold in right hand to use/)

    if line =~ /has a value of (.*?) silver and reads/
      result = $1.delete(",").to_i
    end

    return result
  end

  def self.silver_check
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    wealth_pattern = /^You have (no|[,\d]+|but one) silver with you/
    wealth = ELoot.get_command("wealth quiet", wealth_pattern, silent: true, quiet: true).join(" ")
    coins = 0
    if wealth.gsub('but one', '1') =~ wealth_pattern
      coins = $1.gsub(',', '').to_i
    end
    return coins
  end

  def self.silver_deposit(deposit_bag = false)
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    if ELoot.data.coin_hand && deposit_bag && ELoot.data.settings[:sell_deposit_coinhand]
      # Remove the coin hand from a container if needed
      unless ELoot.data.coin_container.nil?
        Inventory.free_hand
        Inventory.open_single_container(ELoot.data.coin_container)
        Inventory.drag(ELoot.data.coin_hand)
      end

      if ELoot.data.coin_bag.nil? && ELoot.data.gambling_kit.nil?
        fput "open ##{ELoot.data.coin_hand.id}"
        ELoot.wait_rt
      else
        begin
          lines = ELoot.get_command("look in ##{ELoot.data.coin_hand.id}", /Inside the|There is nothing|That is closed/i, silent: true, quiet: true)

          if lines.any? { |l| l =~ /That is closed/i }
            ELoot.get_command("open ##{ELoot.data.coin_hand.id}", ELoot.data.silent_open)
            raise
          end

          if lines.any? { |l| l =~ /Inside the .* you see approximately [,\d]+ silver coins\.|Get a job/i }
            ELoot.get_res("get coins from ##{ELoot.data.coin_bag.id}", /You reach into your/)
            ELoot.data.coin_bag_full = false
            ELoot.wait_rt
          elsif lines.any? { |l| l =~ /There are [,\d]+ silvers scattered/ }
            ELoot.get_res("gather ##{ELoot.data.gambling_kit.id}", /You dig inside/)
            ELoot.data.gambling_kit_full = false
            ELoot.wait_rt
          elsif lines.any? { |l| l =~ /There is nothing in there/ }
            ELoot.data.coin_bag_full = false
            ELoot.data.gambling_kit_full = false
          end
        rescue
          retry
        end
      end

      # Return it to the container if needed
      unless ELoot.data.coin_container.nil?
        Inventory.store_item(ELoot.data.coin_container, ELoot.data.coin_hand)
      end
    end

    current_silvers = ELoot.silver_check
    keep_silvers = [ELoot.data.settings[:sell_keep_silver].to_i, 0].max
    share_silvers = current_silvers - keep_silvers

    # Share silvers
    if ELoot.data.settings[:sell_share_silvers] && share_silvers.positive?
      fput("share #{share_silvers}")
    end

    # use coin hand if we have it and don't want to deposit the coins
    ELoot.use_coin_hand unless ELoot.data.settings[:sell_deposit_coinhand]

    # Any notes on us?
    note = StowList.stow_list[:default].contents.find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }

    # Head over to the bank if something to do.
    current_silvers = ELoot.silver_check
    return unless (current_silvers != keep_silvers) || (note && !ELoot.f2p?)

    ELoot.go2('bank')

    unless ELoot.f2p?
      if XMLData.room_title == '[Pinefar, Depository]'
        dothistimeout "give banker #{current_silvers} silver", 2, ELoot.data.deposit_regex
      else
        dothistimeout "deposit all", 2, ELoot.data.deposit_regex
      end
    else
      # F2P accounts have to be handled a little different due to bank capacity
      loop do
        lines = ELoot.get_command("bank account", /You currently have an account/, silent: true, quiet: true)

        if lines.find { |line| line.match(/in the amount of (?<silver>[\d,]+) silver/) }
          silver_balance = Regexp.last_match[:silver].gsub(',', '').to_i
        end

        if lines.find { |line| line.match(/a maximum of (?<silver>[\d,]+) silvers/) }
          silver_max = Regexp.last_match[:silver].gsub(',', '').to_i
        end

        # Make sure we have the correct current silvers
        current_silvers = ELoot.silver_check

        # Do we have enough to deposit without taking out a note?
        if (silver_balance + current_silvers) < silver_max
          result = dothistimeout("deposit #{current_silvers}", 2, Regexp.union(ELoot.data.deposit_regex, /you don't have access/i)) if current_silvers.positive?
          if result =~ /you don't have access/i
            ELoot.msg("info", " You don't have a bank in this town. Exiting...")
            exit
          end
          break
        else
          deposit_size = silver_max - silver_balance
          dothistimeout("deposit #{deposit_size}", 2, ELoot.data.deposit_regex)

          # Do we have enough to pull a full note and still have 10,000 buffer to deposit?
          current_silvers = ELoot.silver_check

          note_size = current_silvers >= 10000 ? silver_max : (silver_max - (10000 - current_silvers))
          dothistimeout("withdraw #{note_size}", 2, /The teller/)
          note = [GameObj.right_hand, GameObj.left_hand].find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }
          Inventory.single_drag(note)
        end
      end
    end

    # Finally withdraw any keeper silvers and stow note if given
    if XMLData.room_title == '[Pinefar, Depository]'
      dothistimeout("ask banker for #{keep_silvers} silvers", 2, ELoot.data.withdraw_regex) if keep_silvers.positive?
    else
      dothistimeout("withdraw #{keep_silvers}", 2, ELoot.data.withdraw_regex) if keep_silvers.positive?
    end
    note = [GameObj.right_hand, GameObj.left_hand].find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }
    Inventory.single_drag(note) if note
    ELoot.wait_rt
  end

  def self.f2p_silver_withdraw(amount)
    # f2p accounts have a max balance, and the silver_deposit() function will withdraw notes when the
    # max balance is reached. sometimes eloot needs to withdraw sums such as 8k silvers to run errands,
    # but a f2p bank account will frequently not have that much available. when that happens, this will
    # deposit the note(s) on hand to make enough silver available for the desired withdrawal.

    balance = 0
    lines = ELoot.get_command("check balance", /(?:The|A prim) teller/, silent: true, quiet: true)
    if lines.find { |line| line.match(/Your balance is currently at (?<silver>[\d,]+)/) }
      balance = Regexp.last_match[:silver].gsub(',', '').to_i
    end

    if balance >= amount
      dothistimeout("withdraw #{amount} silver", 2, /The teller/)
      return
    end

    bag = StowList.stow_list[:default]
    5.times do
      note = bag.contents.find { |obj| obj.noun =~ /^(?:note|scrip|chit)$/ }
      break if note.nil?

      # drain the account to make room for a note that could be as large as the f2p max balance
      if balance > 0
        dothistimeout("withdraw #{balance} silver", 2, /The teller/)
        amount -= balance
        balance = 0
      end

      # deposit the note and then attempt to withdraw the amount of silver needed
      Inventory.drag(note)
      lines = ELoot.get_command("deposit ##{note.id}", /You (?:deposit|hand your)/, silent: true, quiet: true)
      break if lines.find { |line| line.match(/worth (?<silver>[\d,]+)/) }.nil?
      note_amount = Regexp.last_match[:silver].gsub(',', '').to_i
      withdraw_amount = note_amount >= amount ? amount : note_amount
      dothistimeout("withdraw #{withdraw_amount} silver", 2, /The teller/)
      amount -= withdraw_amount
      break if amount <= 0
    end
  end

  def self.silver_withdraw(amount)
    if ELoot.silver_check >= amount && Char.percent_encumbrance < 20
      return
    end

    ELoot.go2('bank')

    ELoot.silver_deposit

    if XMLData.room_title == '[Pinefar, Depository]'
      fput("ask banker for #{amount} silvers")
    elsif ELoot.f2p?
      f2p_silver_withdraw(amount)
    else
      fput("withdraw #{amount} silvers")
    end

    if ELoot.silver_check < amount
      ELoot.msg(type: "info", text: " Not enough silver in current area's bank.")
      exit
    end
  end

  def self.use_coin_hand
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    return if ELoot.data.coin_hand.nil?
    available_silver = ELoot.silver_check
    return unless available_silver.positive?

    # If we don't have enough silver to bother with the gambling kit then return
    return if ELoot.data.gambling_kit && available_silver < (ELoot.data.settings[:gambling_toss_min] || 0)

    unless ELoot.data.coin_container.nil?
      Inventory.free_hand
      Inventory.open_single_container(ELoot.data.coin_container)
      Inventory.drag(ELoot.data.coin_hand)
    end

    if ELoot.data.coin_bag.nil? && ELoot.data.gambling_kit.nil?
      dothistimeout("close ##{ELoot.data.coin_hand.id}", 1, /You feel your pockets lighten/)
    elsif (ELoot.data.coin_bag && !ELoot.data.coin_bag_full) || (ELoot.data.gambling_kit && !ELoot.data.gambling_kit_full)
      Inventory.free_hand

      begin
        if ELoot.data.coin_bag
          get_coins = "put #{available_silver} silver in ##{ELoot.data.coin_bag.id}"
        else
          get_coins = "toss ##{ELoot.data.gambling_kit.id}"
        end

        lines = Lich::Util.issue_command(get_coins, /You (?:place|toss)|There is only room|That might work better|needs to be open|cannot find room|coin .+ is already full!$/i)

        ELoot.wait_rt if ELoot.data.gambling_kit

        if lines.any? { |l| l =~ /That might work better if you opened|needs to be open/i }
          ELoot.get_command("open ##{ELoot.data.coin_hand.id}", ELoot.data.silent_open)
          raise
        elsif lines.find { |line| line.match(/coin .+ is already full!$/) }
          ELoot.data.coin_bag_full = true
        elsif lines.find { |line| line.match(/There is only room for (?<silver>[\d,]+) more coins inside/) }
          capacity = Regexp.last_match[:silver].gsub(',', '').to_i
          ELoot.get_res("put #{capacity} silver in ##{ELoot.data.coin_bag.id}", /You place/)
          ELoot.data.coin_bag_full = true
        elsif lines.find { |line| line.match(/You cannot find room to store any more silver/) }
          ELoot.data.gambling_kit_full = true
          ELoot.wait_rt
        end
      rescue
        retry
      end
    end

    unless ELoot.data.coin_container.nil?
      Inventory.store_item(ELoot.data.coin_container, ELoot.data.coin_hand)
    end
  end

  def self.wait_for_disk
    ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

    return unless ELoot.data.disk
    return unless ELoot.data.settings[:use_disk]

    if ELoot.data.disk.status =~ /gone/ || !GameObj.loot.find { |l| l.name =~ /#{Char.name} #{ELoot.data.disk_nouns_regex}\b/ }
      ELoot.msg(type: "info", text: " Waiting for your disk to arrive")
      50.times do
        break if (ELoot.data.disk = GameObj.loot.find { |l| l.name =~ /#{Char.name} #{ELoot.data.disk_nouns_regex}\b/ })

        sleep(0.1)
      end
      ELoot.wait_rt
    end

    return unless ELoot.data.disk && ELoot.data.disk.status !~ /gone/ && ELoot.data.disk.contents.nil?

    Inventory.open_single_container(ELoot.data.disk)
  end
end

module ELoot # Inventory methods
  module Inventory
    def self.container_contents(container, time: 3)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      wait_time = time * 10 # check in tenth of a second increments
      wait_time.times {
        return true if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)
        sleep 0.1
      }
      ELoot.msg(type: "info", text: "This failed the first time. Trying again. | Container: #{container.name} | GameObj.containers.keys: #{GameObj.containers.keys.include?(container.id)} | container.contents.is_a?: #{container.contents.is_a?(Array)} | caller: #{caller[0]}")

      # still here? Try one more time, goofy things happen
      lines = ELoot.get_command("look in ##{container.id}", ELoot.data.look_regex, silent: true, quiet: true)

      wait_time.times {
        return true if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)
        return true if lines.any? { |l| l =~ /The wide leather belt|You glance|There is nothing|stuffed with a variety of shredded up paper and cloth|Looking at the .*?, you notice:/i }
        sleep 0.1
      }
      ELoot.msg(type: "info", text: "This failed the second time. | Container: #{container.inspect} | caller: #{caller[0]}")
      ELoot.msg(type: "info", text: " Unable to determine the contents of  #{container.name}.")

      return false
    end

    def self.check_auto_closer
      return if ELoot.data.settings[:auto_close].empty?

      ELoot.data.settings[:auto_close].each do |bag_name|
        Inventory.open_single_container(bag_name)
      end
    end

    def self.clear_hands
      # remember what is in our hands
      ELoot.data.right_hand = GameObj.right_hand
      ELoot.data.left_hand = GameObj.left_hand

      # Empty hands
      Inventory.free_hands(both: true)

      if checkright || checkleft
        ELoot.msg(type: "error", text: "** Something is wrong. Can't empty hands! Report this to Elanthia-Online. A log is helpful. Exiting...", space: true)
        exit
      end
    end

    def self.close_container(bag)
      ELoot.get_res("close ##{bag.id}", ELoot.data.close_regex)
    end

    def self.close_sell_containers
      return unless ELoot.data.settings[:keep_closed]

      ELoot.data.sell_containers.each { |sack|
        # Don't close ready list containers or storage and retrieval of weapons/shields gets messed up
        next if ReadyList.ready_list.find { |_k, v| v.id == sack.id }

        Inventory.close_container(sack)
      }
    end

    def self.drag(item, to = "hand") # drags things from inventory to a hand
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      return if item.nil? || item.empty? || item.name == "Empty"

      # make sure the hand we want is free
      case to
      when "hand"
        Inventory.free_hand
        to = GameObj.right_hand.id.nil? ? 'right' : 'left'
      when "right"
        Inventory.free_hands(right: true)
      when "left"
        Inventory.free_hands(left: true)
      end

      line = ELoot.get_res("_drag ##{item.id} #{to}")

      20.times {
        return true if ([GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))
        break if line =~ /Get what|I could not find what you were referring to/
        sleep 0.1
      }

      if line =~ /Get what|I could not find what you were referring to/
        StowList.stow_list.each_value do |bag_obj|
          Inventory.open_single_container(bag_obj)
        end

        lost_item = Sell.check_inventory.find { |obj| obj.id == item.id }
        if lost_item
          Inventory.drag(lost_item, to)
        else
          ELoot.msg(type: "info", text: " Can't find #{item.name}. Looked in all the bags in case it got misplaced.")
        end

      end

      return false
    end

    def self.wear(item)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      return false if item.nil? || item.empty? || item.name == "Empty"

      line = ELoot.get_res("_drag ##{item.id} wear")

      # Give it time to update and confirm action
      20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)) && (GameObj.inv.map(&:id).compact.include?(item.id))
        break if line =~ /You can't wear that/
        sleep 0.1
      }

      # Still here? Something is wrong, inform the player and exit.
      if [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
        ELoot.msg(type: "warn", text: " Something is wrong. Unable to wear the #{item}. Exiting to avoid losing items.")
        ELoot.msg(type: "warn", text: " Please grab a short log of what just happened and post it to the scripting discord for debugging")
        exit
      end
    end

    def self.free_hand
      right_usable = [Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max < 3
      right_hand_free = GameObj.right_hand.id.nil? && right_usable

      left_usable = [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max < 3
      left_hand_free = GameObj.left_hand.id.nil? && left_usable
      return if right_hand_free || left_hand_free

      waitrt?

      favor_left = ELoot.data.settings[:favor_left]
      right_damaged = [Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max == 3

      if (favor_left && left_usable) || right_damaged
        Inventory.free_hands(left: true)
      elsif right_usable
        Inventory.free_hands(right: true)
      else
        ELoot.msg(type: "yellow", text: " Neither hand is usable. Looks like you need an Empath!", space: true)
        exit
      end
    end

    def self.free_hands(right: false, left: false, both: false)
      if (right || both) && checkright
        # Are we holding a ready_list weapon? If so put it into its sheath
        if !GameObj.right_hand.id.nil? && (ready_item = ReadyList.ready_list.find { |k, v| ELoot.data.original_readylist.include?(k) && v.id == GameObj.right_hand.id }[0])
          Inventory.stow_ready_list(ready_item, GameObj.right_hand)
        end
        if checkright
          Inventory.single_drag(GameObj.right_hand) # drags single item into container
        end
      end

      if (left || both) && checkleft
        if !GameObj.left_hand.id.nil? && (ready_item = ReadyList.ready_list.find { |k, v| ELoot.data.original_readylist.include?(k) && v.id == GameObj.left_hand.id }[0])
          Inventory.stow_ready_list(ready_item, GameObj.left_hand)
        end
        if checkleft
          Inventory.single_drag(GameObj.left_hand) # drags single item into container
        end
      end
    end

    def self.open_loot_containers(item)
      # Method intended for opening containers that will receive loot from the loot room or loot item command
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      # makes sure any auto-closers are open before looting
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      # Early return if not keeping closed since they all get opened on startup
      return unless ELoot.data.settings[:keep_closed]

      Inventory.open_single_container(StowList.stow_list[:default])
      Inventory.open_single_container(StowList.stow_list[:overflow_container])
      Inventory.open_single_container(StowList.stow_list[:secondary_overflow])

      containers = Array.new
      item.each { |loot|
        loot_type = loot.type.to_sym
        next if StowList.stow_list[loot_type].nil?

        unless containers.include?(StowList.stow_list[loot_type].id)
          Inventory.open_single_container(StowList.stow_list[loot_type])
          containers.push(StowList.stow_list[loot_type].id)
        end
      }
    end

    def self.open_single_container(sack)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]} | sack = #{sack}")

      return if sack.nil? || sack.empty?

      container = sack.is_a?(GameObj) ? sack : StowList.stow_list[sack.to_sym]

      if sack.is_a?(GameObj)
        container = sack
      elsif StowList.stow_list[sack.to_sym]
        container = StowList.stow_list[sack.to_sym]
      elsif GameObj[sack]
        container = GameObj[sack]
      else
        ELoot.msg(type: "debug", text: " #{__method__} | not able to determine proper GameObj lookup for #{sack.inspect}")
        return
      end

      # If it's in the game obj and contents.is_a?(Array) return
      return if GameObj.containers.keys.include?(container.id) && container.contents.is_a?(Array)

      # Still here? Assume the container is closed and open it
      ELoot.get_command("open ##{container.id}", ELoot.data.silent_open, silent: true, quiet: true)

      # check out whats inside
      lines = ELoot.get_command("look in ##{container.id}", ELoot.data.look_regex, silent: true, quiet: true)
      return if lines.any? { |l| l =~ /You glance|There is nothing|stuffed with a variety of shredded up paper and cloth|^Looking at the .*?, you notice:|^The .+? has .+? in its left-hand scabbard and .+? in its right-hand scabbard\.$/i }

      ELoot.data.sell_containers.push(container) unless ELoot.data.sell_containers.include?(container)
    end

    def self.return_hands
      # Nothing to do
      return if ELoot.data.right_hand.id == GameObj.right_hand.id && ELoot.data.left_hand.id == GameObj.left_hand.id

      # Check Right Hand
      unless ELoot.data.right_hand.id.nil? || ELoot.data.right_hand.id == GameObj.right_hand.id
        if (ready_item = ReadyList.ready_list.find { |k, v| ELoot.data.original_readylist.include?(k) && v.id == ELoot.data.right_hand.id }[0])
          Inventory.return_ready_list(ready_item, ELoot.data.right_hand)
        else
          Inventory.drag(ELoot.data.right_hand, 'right')
        end
      end

      # Check Left Hand
      unless ELoot.data.left_hand.id.nil? || ELoot.data.left_hand.id == GameObj.left_hand.id
        if (ready_item = ReadyList.ready_list.find { |k, v| ELoot.data.original_readylist.include?(k) && v.id == ELoot.data.left_hand.id }[0])
          Inventory.return_ready_list(ready_item, ELoot.data.left_hand)
        else
          Inventory.drag(ELoot.data.left_hand, 'left')
        end
      end
    end

    def self.return_ready_list(ready_item, item)
      return true if ReadyList.ready_list[ready_item.to_sym].nil?

      10.times {
        ELoot.get_res("ready #{ELoot.fix_item_key(ready_item.to_s)}", ELoot.data.get_regex)
        sleep 0.2
        return true if [GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
      }

      return false
    end

    def self.single_drag(item, phase_thing = true) # drags single item into container
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      stored = false
      return if item&.name == "Empty"
      return if Inventory.single_drag_box(item)

      # Try sacks in order of priority: item-specific, default, overflow, secondary overflow
      containers = [
        StowList.stow_list[item.type.to_sym],
        StowList.stow_list[:default],
        StowList.stow_list[:overflow_container],
        StowList.stow_list[:secondary_overflow]
      ]

      begin
        containers.each_with_index do |bag, index|
          if stunned?
            ELoot.wait_rt
            raise
          end
          next if ELoot.data.sacks_full.include?(bag)

          if bag.nil?
            case index
            when 1
              ELoot.msg(type: "yellow", text: " No default container identified. This shouldn't happen.")
              ELoot.msg(type: "yellow", text: "   Check your STOW settings. Exiting")
              exit
            when 2
              ELoot.msg(type: "info", text: " Skipping primary overflow.   No container identified.")
            when 3
              ELoot.msg(type: "info", text: " Skipping secondary overflow. No container identified.")
            end
          else
            result = Inventory.store_item(bag, item)
            if result
              ELoot.box_phase(item) if phase_thing
              stored = true
              break
            end
          end
        end
      rescue
        retry
      end

      # If item wasn't stored, pause and address
      unless stored
        ELoot.msg(type: "info", text: " Failed to store the #{item.name}.")
        ELoot.msg(type: "info", text: " Pausing the script to handle it yourself")
        ELoot.msg(type: "info", text: " ;unpause #{Script.current.name} after addressing to continue!")

        Script.current.pause
      end
    end

    def self.single_drag_box(item)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      return false unless item.type =~ /box/
      return false unless ELoot.data.settings[:use_disk]
      return false if ELoot.data.disk_full

      ELoot.wait_for_disk
      return false unless ELoot.data.disk

      # still here so lets try to put the box in the disk
      result = Inventory.store_item(ELoot.data.disk, item)
      return true if result

      # inform user it didn't fit if !result
      ELoot.msg(type: "info", text: " The #{item} won't fit in the #{ELoot.data.disk}. Trying a different container.")
      ELoot.data.disk_full = true

      return false
    end

    def self.single_loot(item) # loots a single item
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]} | item: #{item.inspect}")
      return if item.nil?

      # loot item will fallback to the default sack but if both are full we need to loot manually
      bag = StowList.stow_list[item.type.to_sym]
      bag = nil if bag.nil? || ELoot.data.sacks_full.include?(bag)
      bag ||= StowList.stow_list[:default]
      bag = nil if bag.nil? || ELoot.data.sacks_full.include?(bag)

      unless bag
        Inventory.single_drag(item)
        return
      end

      lines = ELoot.get_command("loot ##{item.id}", ELoot.data.put_regex)

      if lines.any? { |line| line =~ /<\/inv>You can't put your <a exist=".*?" noun=".*?">.*?<\/a> in the <a exist="(\d+)" noun=".*?">.*?<\/a>.  It's closed!/ }
        bag_id = $1
        bag = GameObj.inv.find { |i| i.id == bag_id }
        # Must be an auto closer. Their ID and contents don't drop from GameObj.container when closed
        if GameObj.containers.keys.include?(bag.id) && bag.contents.is_a?(Array)
          ELoot.data.settings[:auto_close].push(bag.name)
          Inventory.open_single_container(bag)
          ELoot.msg(type: "info", text: " #{bag.name} must be an autocloser, adding to list.")
          ELoot.save_profile()
        end
      end

      20.times {
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and StowList.stow_list[item.type.to_sym].contents.to_a.map(&:id).include?(item.id))
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and StowList.stow_list[:default].contents.to_a.map(&:id).include?(item.id))
        return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) and item.type =~ /skin/)

        sleep 0.1
      }

      # edge case of treasure system mismatch
      return true if Sell.check_inventory.any? { |obj| obj.id == item.id }

      # still here so just loot it manually
      Inventory.single_drag(item)
    end

    def self.store_item(bag, item, is_skinner = false)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]} | bag: #{bag} | item: #{item}")
      return if item.nil? || item.name == "Empty"

      5.times do
        lines = ELoot.get_command("_drag ##{item.id} ##{bag.id}", ELoot.data.put_regex)

        if lines.any? { |l| l =~ /You can't.*?It's closed!/ }
          if GameObj.containers.keys.include?(bag.id) && bag.contents.is_a?(Array)
            # Must be an auto closer. Their ID and contents don't drop from GameObj.container when closed
            ELoot.data.settings[:auto_close].push(bag.name)
            ELoot.msg(type: "info", text: " #{bag.name} must be an autocloser, adding to list.")
            ELoot.save_profile()
          end
          ELoot.get_res("open ##{bag.id}", ELoot.data.silent_open)
          lines = ELoot.get_command("_drag ##{item.id} ##{bag.id}", ELoot.data.put_regex)
        end

        return true if lines.any? { |l| l =~ /You are unable to handle|That is not yours|Hey, that belongs to|Get what|I could not find what you were referring/ }

        if lines.any? { |l| l =~ /put something that you can't hold/ }
          ELoot.unlootable(item)
          return true
        end

        # Check if full
        if lines.any? { |l| l =~ /won't fit/i }
          ELoot.data.sacks_full.push(bag)
          return false
        end

        if lines.any? { |l| l =~ /crumbles? and decays? away|crumbles? into a pile of dust/i }
          ELoot.msg(type: "info", text: " This item was crumbly, adding to list")
          ELoot.data.settings[:crumbly].push(item.name)
          ELoot.save_profile()
          return true
        end

        Inventory.open_single_container(bag) unless bag.contents.is_a?(Array) || is_skinner

        20.times do
          return true if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id) && bag.contents.to_a.map(&:id).include?(item.id))

          # Lousy weapon displayers don't have contents
          if is_skinner
            return true if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
          end
          sleep 0.1
        end

        waitrt?
      end

      # Give up and return false
      return false
    end

    def self.stow_ready_list(ready_item, item)
      return true if ReadyList.ready_list[ready_item.to_sym].nil?
      if ReadyList.store_list[ready_item.to_sym] =~ /put in sheath/
        Inventory.open_single_container(ReadyList.ready_list[:sheath])
      elsif ReadyList.store_list[ready_item.to_sym] =~ /put in secondary/
        Inventory.open_single_container(ReadyList.ready_list[:secondary_sheath])
      end

      10.times {
        ELoot.get_res("store #{ELoot.fix_item_key(ready_item.to_s)}", ELoot.data.put_regex)
        sleep 0.2
        return true if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
      }

      return false
    end
  end # End of Inventory
end

module ELoot # Gem and Reagent hoarding
  module Hoard
    def self.set_type_vars(type)
      return if type == ELoot.data.hoard_type
      ELoot.data.hoard_type = type

      # Sets the working variables based on the type of hoarding
      ELoot.data.container_settings = ELoot.data.settings["#{type}_horde_containers".to_sym] # This is the container list to hoard FROM
      ELoot.data.everything_list = ELoot.data.settings["#{type}_everything_list".to_sym]     # Hoard everything toggle
      ELoot.data.everything = ELoot.data.settings["#{type}_everything".to_sym]               # List of excluded gems
      ELoot.data.only_list = ELoot.data.settings["#{type}_only_list".to_sym]                 # Only hoard specific items toggle
      ELoot.data.only = ELoot.data.settings["#{type}_list".to_sym]                           # List of specific items
      ELoot.data.locker_city = ELoot.data.settings["#{type}_locker_name".to_sym]             # This is the name of the city where the locker is
      ELoot.data.locker = ELoot.data.settings["#{type}_horde_locker".to_sym]                 # True/False toggle to use locker
      ELoot.data.cache = ELoot.data.settings["#{type}_horde_container".to_sym]               # This is container name in UI
      ELoot.data.inventory = ELoot.data.settings["#{type}_horde_inv".to_sym]                 # Gem inventory
      ELoot.data.use_hoarding = ELoot.data.settings["#{type}_horde".to_sym]                  # True/False toggle to hoard gems
      ELoot.data.use_house_locker = ELoot.data.settings["#{type}_horde_locker_che".to_sym]   # Toggle for CHE locker
      ELoot.data.che_rooms = ELoot.data.settings["#{type}_horde_che_rooms".to_sym]           # Array of locations outside CHE locker room
      ELoot.data.che_entry = ELoot.data.settings["#{type}_horde_che_entry".to_sym]           # Entry string into CHE locker
      ELoot.data.che_exit = ELoot.data.settings["#{type}_horde_che_exit".to_sym]             # Exit string from CHE locker
    end

    def self.validate_hoarding_settings
      need_return = false

      if ELoot.data.locker && ELoot.data.locker_city.empty?
        ELoot.msg(text: " Hoard #{ELoot.data.hoard_type} in a locker is toggled on the UI but location is empty")
        need_return = true
      end

      if ELoot.data.cache.empty?
        ELoot.msg(text: " A gem hoarding container is not identified (yes, you need it for a locker too)")
        need_return = true
      end

      if ELoot.data.container_settings.length.zero?
        ELoot.msg(text: " No containers identified to hoard #{ELoot.data.hoard_type}s from.")
        ELoot.msg(text: " Please make selection in UI Gem/Alchemy Hoarding Tab")
        need_return = true
      end

      if need_return
        ELoot.msg(text: " The hoarding settings need updated.", space: true)
        return false
      end

      return true
    end

    def self.check_type(item)
      obj_type = ELoot.data.hoard_type == 'alchemy' ? 'reagent' : ELoot.data.hoard_type

      item = item.gsub(/teeth/, "tooth")
      noun = item.split.last

      if item =~ GameObj.type_data[obj_type][:exclusion]
        return false
      elsif GameObj.type_data[obj_type][:name].to_s.match?(/\b#{item}\b/) || GameObj.type_data[obj_type][:noun].to_s.match?(/\b#{noun}\b/)
        return true
      elsif item =~ GameObj.type_data[obj_type][:name] || noun =~ GameObj.type_data[obj_type][:noun]
        return true
      elsif obj_type == 'reagent' && Room.list.any? { |r| r.tags.any? { |tag| (tag.end_with? item) || ((item.start_with? tag) && item =~ /ayana/) || (item.end_with? tag) } }
        return true
      elsif obj_type == 'reagent' && item =~ /kezmonian honey beryl|faintly glimmering dust/i
        return true
      elsif obj_type == 'gem' && item =~ /(?:deep blue sapphire|fiery ruby|glistening onyx|sparkling emerald) talon/i
        return true
      else
        return false
      end
    end

    def self.normalize_name(name)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]} | name: #{name}")
      return if name.nil?
      if name.is_a?(String)
        case name
        when /essences? of (air|earth|water|fire)/
          return "essence of #{$1}"
        when /golden seed/
          return "tiny golden seed"
        when /motes? of essence/
          name = name.gsub(/motes?/, 'mote')
        end
      end

      name_rules = {
        'ies'    => 'y',
        'onyxes' => 'onyx',
        'zes'    => 'z',
        's'      => '',
      }

      name = name.full_name if name.is_a?(GameObj)
      name = name.downcase

      sizes = "tiny|small|medium|large|blue-violet|pyrite-capped vibrant"
      articles = "some|an? |the"
      descriptors = "\\w+s? of(?: polished)?|polished"

      pattern = /^\s*(?:containing )?(?:#{articles})?\s*(?:#{sizes})?\s*(?:#{descriptors})?\s*(?:#{sizes})?\s*(.*?)\s*$/

      unless name =~ pattern
        raise 'FIXME: normalize pattern did not match but should match anything'
      end
      name = $1

      if name =~ /^(.*?)(#{name_rules.keys.map { |x| Regexp::escape(x) }.join('|')})$/
        return "#{$1}#{name_rules[$2]}"
      else
        return name
      end
    end

    def self.go2_locker
      if ELoot.data.use_house_locker
        lockers = ELoot.data.che_rooms.split(',').map { |num| Room[num.to_i] }
      else
        lockers = Map.list.find_all { |room| (room.tags.any?(/meta:che:#{ELoot.data.locker_city}/) && room.tags.any?(/locker/)) || (room.tags.any?(/publiclockers/) && room.location =~ /#{ELoot.data.locker_city}/) }
      end

      locker_town = Room[Room[lockers.first.id].find_nearest_by_tag("town")].location
      current_town = Room[Room.current.find_nearest_by_tag("town")].location

      if locker_town =~ /the Isle of Four Winds/i && current_town != locker_town
        fwi_place = Room.list.find { |room| room.tags.include?('town') && ELoot.fwi?(room) }
        ELoot.go2(fwi_place.id)

        locker_town = Room[Room[lockers.first.id].find_nearest_by_tag("town")].location
        current_town = Room[Room.current.find_nearest_by_tag("town")].location
      end

      if Room[lockers.first.id].find_nearest_by_tag("town").nil?
        ELoot.msg(text: " Not able to hoard. Unable to find the locker town using room ##{lockers.first.id}.", space: true)
        return
      elsif current_town != locker_town
        ELoot.msg(text: " Not able to hoard. Your hoarding locker is in #{locker_town}.", space: true)
        return
      end

      unless ELoot.data.account_type =~ /premium/i
        ELoot.silver_withdraw(2500)
      end

      index = 0

      if lockers.any? { |location| location.id == Room.current.id }
        index = lockers.find_index { |location| location.id == Room.current.id }
      end

      loop do
        place = lockers[index]
        ELoot.go2(place.id)
        ELoot.wait_rt

        # some rooms go directly to the locker instead of just outside
        break if (GameObj.room_desc.to_a + GameObj.loot.to_a).any? { |obj| obj.name =~ /locker|counter/ }

        if ELoot.data.use_house_locker
          way_in = ELoot.data.che_entry
        else
          way_in_obj = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain|tapestry)$/ }
          way_in_obj.noun = "opening" if way_in_obj.noun == "tapestry"
          way_in = "go #{way_in_obj.noun}"
        end

        result = move "#{way_in}"

        break if result == true

        if reget(10).reverse.any? { |line| line =~ /pay off (your|that) debt/i }
          wealth_pattern = /^You have (no|[,\d]+|but one) silver with you/
          wealth_lines = ELoot.get_command("wealth quiet", wealth_pattern, silent: true, quiet: true).join(" ")
          if wealth_lines.to_s =~ /In the back of your mind you remember you owe a debt of ([\d,]+) silver/
            amount = $1.gsub(',', '').to_i
            ELoot.silver_withdraw(amount)
            ELoot.go2("debt")
            ELoot.wait_rt
            fput("pay #{amount}")
            ELoot.silver_withdraw(2500)
            redo
          end
        end

        if index == lockers.length - 1 # Pause for 10 seconds if it's the last iteration
          respond
          ELoot.msg(text: " Not able to enter a locker. They might all be taken. Waiting 10 seconds then trying again.", space: true)
          respond
          sleep(10)
        end

        index = (index + 1) % lockers.length # Increment index, wrapping around if it exceeds the array length
      end
      ELoot.wait_rt
    end

    def self.open_locker(reset: false)
      ELoot.data.stash = nil
      retries = 0
      max_retries = 3
      error_log = []

      ELoot.wait_rt

      begin
        unless reset
          open_result = ELoot.get_command('open locker', /exist=".*?" noun="(?:locker|chest)"|That is already open.|<prompt time=".*?">&gt;<\/prompt>/)
        end

        ELoot.wait_rt

        ELoot.data.stash = GameObj.loot.find { |item| item.name =~ /#{ELoot.data.cache}/ }

        # maybe its on a counter
        if ELoot.data.stash.nil?
          counter = GameObj.room_desc.find { |item| item.name =~ /counter/ }
          ELoot.get_command("look on ##{counter.id}", /<container id='.*?' title=/, silent: true, quiet: true)
          ELoot.data.stash = counter.contents.find { |item| item.name =~ /#{ELoot.data.cache}/ }
        end

        raise StandardError if ELoot.data.stash.nil?
      rescue StandardError
        if retries < max_retries
          retries += 1
          ELoot.msg(text: " Something went wrong. Retrying... (Retry #{retries} of #{max_retries}).", space: true)
          error_log.push(open_result)
          sleep 1
          retry
        else
          ELoot.msg(text: " Not able to find the container in your locker for #{ELoot.data.hoard_type} hoarding.")
          ELoot.msg(text: " Please send the EO team the following on the discord scripting channel...")
          ELoot.msg(text: " Room: #{Room.current.id} | container_name: #{ELoot.data.cache}")
          error_log.push("Type: #{ELoot.data.hoard_type}")
          ELoot.msg(text: " Errors: #{error_log}")
          Hoard.leave_locker
        end
      else
        ELoot.get_command("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/, silent: true, quiet: true)
      end
    end

    def self.leave_locker
      locker_item = GameObj.loot.find { |item| item.name =~ /dark stained antique oak trunk|counter|locker/ }
      is_locksmith_room = Room.current.tags.include?('locksmith')

      return if locker_item.nil? || is_locksmith_room

      ELoot.get_res('close locker', /^You/)

      if ELoot.data.use_house_locker
        way_out = ELoot.data.che_exit
      else
        way_out_obj = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain|tapestry)$/ }
        way_out_obj.noun = "opening" if way_out_obj.noun == "tapestry"
        way_out = "go #{way_out_obj.noun}"
      end

      move "#{way_out}"
      ELoot.wait_rt
    end

    def self.build_inventory(refresh = false)
      return unless ELoot.data.inventory.empty? || refresh

      if (ELoot.data.locker || ELoot.data.use_house_locker) && ELoot.data.account_type =~ /premium/i
        result = Hoard.build_premium_locker_inventory
        return if result
      end

      ELoot.data.inventory = []
      percent_complete = 0

      ELoot.get_command("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/, silent: true, quiet: true)
      total_items = ELoot.data.stash.contents.count { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && !obj.after_name.nil? }
      empty_jars = ELoot.data.stash.contents.count { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && obj.after_name.nil? }

      if empty_jars.positive?
        ELoot.data.inventory << { :item => '*** empty jars ***', :count => empty_jars, :full => '  -' }
      end

      ELoot.data.stash.contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && !obj.after_name.nil? }.each_with_index do |jar, index|
        lines = ELoot.get_command("look in ##{jar.id} from ##{ELoot.data.stash.id}", /^Inside .*? you see [0-9]+ portion/, silent: true, quiet: true)

        if (lines.find { |line| line =~ /^Inside .*? you see ([0-9]+) portion/ })
          count = Regexp.last_match[1].to_i
          item = Hoard.normalize_name(jar.after_name).strip
          full = lines.any?(/It is full/)

          if Hoard.check_type(item)
            ELoot.data.inventory << { :item => item, :count => count, :full => full }
          end
        end

        percent_complete = (((index + 1).to_f / total_items) * 100).round(2)
        respond " percent complete: #{percent_complete}%"
      end

      ELoot.save_hoard_profile
    end

    def self.build_premium_locker_inventory
      if ELoot.data.use_house_locker
        lockers = ELoot.data.che_rooms.split(',').map(&:to_i)
        ELoot.data.locker_city = Room[Room[lockers.first].find_nearest_by_tag("town")].location.gsub(/the (town|city|village) of/, '').strip
      end

      all_lockers = ["Wehnimer's Landing", "Teras Isle", "Solhaven", "River's Rest", "Icemule Trace", "Zul Logoth", "Ta'Illistim", "Ta'Vaalor", "Mist Harbor", "Cysaegir", "Kraken's Fall", "Family Vault"]
      locker_town = "Family Vault" if ELoot.data.cache =~ /trunk/i

      locker_town ||= {
        'Kharam-Dzu'             => 'Teras Isle',
        'the Isle of Four Winds' => 'Mist Harbor'
      }[ELoot.data.locker_city] || ELoot.data.locker_city

      return false unless all_lockers.include?(locker_town)
      ELoot.data.inventory = []

      case ELoot.data.cache
      when /trunk/i
        start_from = "bound in wrought iron"
      when /chest/i
        start_from = "deep chest"
      when /rack/i
        start_from = "weapon rack"
      when /stand/i
        start_from = "armor stand"
      when /bin/i
        start_from = "magical item bin"
      when /wardrobe/i
        start_from = "clothing wardrobe"
      end

      lines = ELoot.get_command("locker manifest #{locker_town}", /Thinking back, you recall the contents|Looking in front of you/, silent: true, quiet: true)

      # Find the index of the line starting with the container name
      start_index = lines.index { |line| line.include?(start_from) }

      unless start_index # Return empty if not found
        ELoot.data.inventory = []
        return
      end

      end_index = lines[start_index + 1..-1].index { |line| line.strip.empty? }
      end_index = end_index.nil? ? lines.size : end_index + start_index + 1

      extracted_elements = lines[(start_index + 1)...end_index]

      empty_jars = extracted_elements.count { |line| line.match?(/(?:jar|bottle|beaker)/) && !line.include?("containing") }

      if empty_jars.positive?
        ELoot.data.inventory << { :item => '*** empty jars ***', :count => empty_jars, :full => '  -' }
      end

      extracted_elements.each do |line|
        match = line.match(/containing\s(?<item>.*?)\s+\((?<stored>\d+)\/(?<capacity>\d+)\)(?:\s+\(.*?\))?\z/)

        if match
          item = Hoard.normalize_name(match[:item]).strip
          stored = match[:stored].strip.to_i
          capacity = match[:capacity].strip.to_i
          full = stored == capacity

          if Hoard.check_type(item)
            ELoot.data.inventory << { :item => item, :count => stored, :full => full }
          end
        end
      end

      return true
    end

    def self.list_inventory(type)
      Hoard.set_type_vars(type)

      sorted_data = ELoot.data.inventory.sort_by { |entry| entry[:item] }

      rows = []
      rows << ["#{type.capitalize}s", 'Amount', 'Full?']
      rows << :separator
      sorted_data.each do |entry|
        rows << [ELoot.capitalize_words(entry[:item]), entry[:count], entry[:full]]
      end

      table = Terminal::Table.new :title => "#{type.capitalize} Inventory", :rows => rows
      table.align_column(1, :right)
      respond
      respond table
      respond
    end

    def self.reset_inventory(type)
      Hoard.set_type_vars(type)
      return unless Hoard.validate_hoarding_settings

      start_room = Room.current.id

      # Find the stash container and/or goto locker
      unless (ELoot.data.locker || ELoot.data.use_house_locker) && ELoot.data.account_type =~ /premium/i
        Hoard.hoard_prep
      end

      # Build inventory if needed
      Hoard.build_inventory(true)

      # Leave the locker if needed
      Hoard.leave_locker

      # Go back to original room
      ELoot.go2(start_room)

      # Save the new inventory
      ELoot.save_hoard_profile
    end

    def self.hoard_prep
      if ELoot.data.locker || ELoot.data.use_house_locker
        locker_item = GameObj.loot.find { |item| item.name =~ /dark stained antique oak trunk|counter|locker/ }
        is_locksmith_room = Room.current.tags.include?('locksmith')

        Hoard.go2_locker if is_locksmith_room || locker_item.nil?

        Hoard.open_locker
        # ELoot.data.stash variable set when opening locker
      else
        ELoot.data.stash = GameObj.inv.find { |i| i.name =~ /#{ELoot.data.cache}\b/ }
        Inventory.open_single_container(ELoot.data.stash)
      end
    end

    def self.need_to_hoard?(deposit = false)
      return true if deposit
      return true if ELoot.data.inventory.empty?
      bounty_gems = []

      if ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/ && ELoot.data.hoard_type == 'gem'

        gem_name, gem_number = Hoard.check_gem_bounty

        ELoot.data.items_to_hoard.each do |item|
          if item.name =~ /#{gem_name}/ && bounty_gems.length.to_i < gem_number
            bounty_gems.push(item)
          end
        end

        have_stock = ELoot.data.inventory.find { |item| item[:item] == gem_name }
        need_gems = gem_number - bounty_gems.length.to_i

        return true if need_gems.positive? && !have_stock.nil?
      end

      remaining_items = ELoot.data.items_to_hoard - bounty_gems

      remaining_items.each do |thing|
        result = ELoot.data.inventory.find { |item| item[:item] =~ /#{Hoard.normalize_name(thing.name)}/ }[:full]

        next if result == true

        if result.nil?
          result = ELoot.data.inventory.find { |item| item[:item] =~ /empty jar/ }
        end

        return true unless result.nil?
      end

      return false
    end

    def self.check_gem_bounty # Returns gem bounty name and count
      # return unless ELoot.data.settings[:gem_horde_turnin] && Bounty.task.gem? && !Bounty.task.assigned? # update to this post 5.11.2+
      return unless ELoot.data.settings[:gem_horde_turnin] && Bounty.task.gem? && !Bounty.task.type.to_s.end_with?("assignment")

      gem_name = Hoard.normalize_name(Bounty.task.gem)
      gem_number = Bounty.task.number

      return gem_name, gem_number
    end

    def self.hoard_items(type = nil, just_deposit = false)
      ELoot.data.hoard_deposit = []
      start_room = Room.current.id

      ['gem', 'alchemy'].each do |item|
        next if !type.nil? && type != item
        Hoard.set_type_vars(item)
        next unless ELoot.data.use_hoarding
        next unless Hoard.validate_hoarding_settings

        # Create the list of items to store
        Hoard.hoarding_list

        # Next unless there is something for use to do
        next unless Hoard.need_to_hoard?(just_deposit)

        # Find the stash container and/or goto locker
        Hoard.hoard_prep

        # Build inventory if needed
        Hoard.build_inventory

        # Finally store the items
        Hoard.store_items(just_deposit)

        # Withdraw bounty gems if needed
        if ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/ && ELoot.data.hoard_type == 'gem' && !just_deposit

          gem_name, gem_number = Hoard.check_gem_bounty
          gem_list = Hoard.hoarding_list(gem_name)

          if gem_list.count < gem_number
            need_for_bounty = gem_number - gem_list.count
            Hoard.shake(need_for_bounty, gem_name) unless need_for_bounty.zero?
          end
        end
      end

      # Leave the locker if needed
      Hoard.leave_locker

      # Go back to original room
      ELoot.go2(start_room)
    end

    def self.shake(number, name)
      ELoot.msg(type: "debug", text: "shake(number, name) | name: #{name}")
      # Refresh the cache because lockers are special
      ELoot.get_command("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/, silent: true, quiet: true)

      jar = ELoot.data.stash.contents.find { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && Hoard.normalize_name(obj.after_name) =~ /^#{name}$/ }
      ELoot.msg(type: "debug", text: "shake(number, name) | jar: #{jar}")

      return if jar.nil?

      3.times do
        Inventory.drag(jar)
        break if [GameObj.right_hand.id, GameObj.left_hand.id].include?(jar.id)
        # assuming if we are still here and its a locker it reset on us
        if ELoot.data.locker || ELoot.data.use_house_locker
          Hoard.open_locker(reset: true)
        end
      end

      number.times {
        lines = ELoot.get_command("shake ##{jar.id}", /You give your <a exist=".*?"/)
        item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.id !~ /#{jar.id}/ }
        Inventory.store_item(StowList.stow_list[:default], item)
        if lines.any?(/That was the last/)
          ELoot.data.inventory.delete_if { |obj| obj[:item] == name }
          ELoot.save_hoard_profile
          break
        end
      }

      Hoard.check_jar(name)

      # Need to refresh the locker contents because lockers are special
      ELoot.get_command("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/, silent: true, quiet: true)

      3.times do
        Inventory.store_item(ELoot.data.stash, jar)
        break unless [GameObj.right_hand.id, GameObj.left_hand.id].include?(jar.id)
        # assuming if we are still here and its a locker it reset on us
        if ELoot.data.locker || ELoot.data.use_house_locker
          Hoard.open_locker(reset: true)
        end
      end
    end

    def self.check_jar(item_name)
      need_save = false
      jar = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:jar|bottle|beaker)$/ }

      return if jar.nil?

      jar_lines = ELoot.get_command("look in ##{jar.id}", /^Inside .*? you see [0-9]+ portion|^The <a exist=".*?is empty/, silent: true, quiet: true)

      if (jar_lines.find { |line| line =~ /^Inside .*? you see ([0-9]+) portion/ })
        count = Regexp.last_match[1].to_i
        full = jar_lines.any?(/It is full/)

        index_to_update = ELoot.data.inventory.find_index { |item| item[:item] =~ /^#{item_name}$/ }
        if index_to_update
          ELoot.data.inventory[index_to_update][:count] = count
          ELoot.data.inventory[index_to_update][:full] = full
        end

        need_save = true
      elsif (jar_lines.find { |line| line =~ /^The <a exist=".*?is empty/ })
        if (index_to_update = ELoot.data.inventory.find_index { |item| item[:item] =~ /empty jar/i })
          ELoot.data.inventory[index_to_update][:count] += 1
        else
          ELoot.data.inventory << { :item => '*** empty jars ***', :count => 1, :full => '  -' }
        end

        need_save = true
      end

      ELoot.save_hoard_profile if need_save
    end

    def self.hoarding_list(single = nil)
      ELoot.data.items_to_hoard = []
      obj_type = ELoot.data.hoard_type == 'alchemy' ? 'reagent' : ELoot.data.hoard_type

      item_containers = ELoot.data.container_settings.filter_map { |key| StowList.stow_list[key.to_sym] }

      item_containers.each do |container|
        next unless container

        Inventory.open_single_container(container)
        ELoot.data.items_to_hoard.concat(container.contents.to_a)
      end

      return ELoot.data.items_to_hoard.select { |item| item.name =~ /#{single}/ } if single

      ELoot.data.items_to_hoard.reject! { |item| item.type !~ /#{obj_type}/ }

      if ELoot.data.everything_list && ELoot.data.everything.any?
        ELoot.data.items_to_hoard.reject! { |item| item.name =~ Regexp.union(ELoot.data.everything) }
      end

      if ELoot.data.only_list && ELoot.data.only.any?
        ELoot.data.items_to_hoard.select! { |item| item.name =~ Regexp.union(ELoot.data.only) }
      end
    end

    def self.process_gems(inventory_gems)
      return inventory_gems unless ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/ && ELoot.data.hoard_type == 'gem'

      gem_name, gem_number = Hoard.check_gem_bounty
      return inventory_gems unless Hoard.normalize_name(inventory_gems.first) == gem_name

      # Do we have enough?
      if inventory_gems.count > gem_number
        gem_number.times { inventory_gems.pop }
      else
        need_for_bounty = gem_number - inventory_gems.count

        if ELoot.data.inventory.find { |thing| thing[:item] == gem_name }
          Hoard.shake(need_for_bounty, gem_name) unless need_for_bounty.zero?
          inventory_gems = []
        end
      end

      return inventory_gems
    end

    def self.get_gem_bounty
      return unless ELoot.data.settings[:gem_horde_turnin] && checkbounty =~ /The gem dealer/

      gem_name, gem_number = Hoard.check_gem_bounty
      Hoard.hoarding_list(gem_name)

      Hoard.raid_cache(["get_gem_bounty", "raid", "gem", gem_name, "x#{gem_number}"])
    end

    def self.store_items(deposit = false)
      full_jars = []

      hoarding_items = ELoot.data.items_to_hoard.uniq { |item| item.name }.to_a

      hoarding_items.each do |item|
        jar = nil
        item_name = Hoard.normalize_name(item.name)
        ELoot.msg(type: "debug", text: "store_items | item_name: #{item_name} | item.name: #{item.name}")

        next if full_jars.include?(item_name)
        if ELoot.data.inventory.find { |thing| thing[:item] == item_name }[:full]
          full_jars << item_name
          ELoot.msg(text: " Skipping deposit of #{item.name} because its jar is full.", space: true)
          next
        end

        if ELoot.data.hoard_type == "gem"
          gem_name, _gem_number = Hoard.check_gem_bounty
          if item_name == gem_name
            ELoot.msg(text: " Skipping deposit of #{item.name} because its needed for a gem bounty.", space: true)
            next
          end
        end

        items_to_hoard = Hoard.hoarding_list(item.name)

        items_to_hoard = Hoard.process_gems(items_to_hoard) unless deposit
        next if items_to_hoard.length.zero?

        bottle = ELoot.data.stash.contents.find { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && Hoard.normalize_name(obj.after_name) =~ /^#{item_name}$/ }
        ELoot.msg(type: "debug", text: "store_items | bottle: #{bottle}")

        empty = ELoot.data.stash.contents.find { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && obj.after_name.nil? }

        if bottle
          3.times do
            Inventory.drag(bottle)
            break if [GameObj.right_hand.id, GameObj.left_hand.id].include?(bottle.id)
            # assuming if we are still here and its a locker it reset on us
            if ELoot.data.locker || ELoot.data.use_house_locker
              Hoard.open_locker(reset: true)
            end
          end

          jar = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:jar|bottle|beaker)$/ }
        elsif empty
          3.times do
            Inventory.drag(empty)
            break if [GameObj.right_hand.id, GameObj.left_hand.id].include?(empty.id)
            # assuming if we are still here and its a locker it reset on us
            if ELoot.data.locker || ELoot.data.use_house_locker
              Hoard.open_locker(reset: true)
            end
          end

          jar = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:jar|bottle|beaker)$/ }
          index_to_update = ELoot.data.inventory.find_index { |obj| obj[:item] =~ /empty jar/ }
          if index_to_update
            count = ELoot.data.stash.contents.count { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ && obj.after_name.nil? }
            if count.zero?
              ELoot.data.inventory.delete_if { |obj| obj[:item] =~ /empty jar/ }
            else
              ELoot.data.inventory[index_to_update][:count] = count
            end

            ELoot.save_hoard_profile
          end
        end

        if jar.nil?
          ELoot.msg(text: " No empty jars found to store #{item.name}.", space: true)
          next
        end

        thing_name = nil
        items_to_hoard.each do |thing|
          thing_name = Hoard.normalize_name(thing.name)

          Inventory.drag(thing)

          result = ELoot.get_res("_drag ##{thing.id} ##{jar.id}", /You (add|put)|The.*?is full/)

          case result
          when /into your empty (?:jar|bottle|beaker)/
            ELoot.data.inventory << { item: thing_name, count: 1, full: false }
            ELoot.data.inventory.uniq!
          when /is full/
            ELoot.msg(text: "Something went wrong. Need to rebaseline inventory.", space: true)

            Inventory.store_item(ELoot.data.stash, jar)
            Inventory.store_item(StowList.stow_list[:default], thing)
            ELoot.wait_rt

            Hoard.build_inventory(true)
            break
          end

          ELoot.data.hoard_deposit << { :item => thing_name, :type => ELoot.data.hoard_type }

          break if result =~ /filling it/
        end

        Hoard.check_jar(thing_name)

        # Need to refresh the locker contents because lockers are special
        ELoot.get_command("look in ##{ELoot.data.stash.id}", /<container id='.*?' title=/, silent: true, quiet: true)

        3.times do
          Inventory.store_item(ELoot.data.stash, jar)
          break unless [GameObj.right_hand.id, GameObj.left_hand.id].include?(jar.id)
          # assuming if we are still here and its a locker it reset on us
          if ELoot.data.locker || ELoot.data.use_house_locker
            Hoard.open_locker(reset: true)
          end
        end
      end
    end

    def self.raid_cache(options)
      ELoot.msg(type: "debug", text: " Hoard.raid_cache options: #{options}")

      if options[2] !~ /gem|reagent|alchemy/
        ELoot.msg(text: " To use this option - ;eloot raid <type> <item to get> x<how many>.")
        ELoot.msg(text: " Ex ;eloot raid gem blue diamond x5")
        ELoot.msg(text: " <type> can be gem or reagent")
        exit
      end

      Inventory.clear_hands

      if options[2] =~ /reagent|alchemy/
        type = 'alchemy'
      elsif options[2] =~ /gem/
        type = 'gem'
      end

      Hoard.set_type_vars(type)

      number = (options[3..-1].find { |var| var =~ /^[Xx][0-9]+$/ }.sub(/[Xx]/, '') || 1).to_i
      options.delete_if { |line| line =~ /^[Xx]([0-9]+)$/ }

      search_string = options[3..-1].join(' ')
      item = Hoard.normalize_name(search_string).downcase
      ELoot.msg(type: "debug", text: "raid_cache | search_string: #{search_string} | item: #{item}")

      unless ELoot.data.inventory.find { |thing| thing[:item] =~ /^#{item}$/i }
        ELoot.msg(text: " Not able to find #{item} in your cache.")
        ELoot.msg(text: " Run ;eloot reset #{type} to re-baseline it if needed.")
        return
      end

      start_room = Room.current.id
      Hoard.hoard_prep

      Hoard.shake(number, item)

      Hoard.leave_locker

      ELoot.go2(start_room)
      Inventory.return_hands
    end
  end
end

module ELoot # Room looting
  module Loot
    def self.bag_loot(bag) # loots bags dropped from critters that have treasure in them
      return if ELoot.data.checked_bags.include?(bag.id)

      lines = ELoot.get_command("open ##{bag.id}", /crumbles? and decays? away|<exposeContainer|That is already open|<container|There doesn't seem to be any way to do that|I could not find what you were referring to/, silent: true, quiet: true)

      if lines.any? { |l| l =~ /crumbles? and decays? away/i }
        unless bag.name =~ /bandana|flowing robes/
          ELoot.msg(type: "info", text: " #{bag} was crumbly, adding to list")
          ELoot.data.settings[:crumbly].push(bag.name)
          ELoot.save_profile()
        end
        return "crumbly"
      end

      if lines.any? { |line| line =~ /There doesn't seem to be any way to do that|I could not find what you were referring to/i }
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      lines = ELoot.get_command("look in ##{bag.id}", /<container|That is closed/, silent: true, quiet: true)

      # False positive?
      if lines.any? { |line| line =~ /I could not find what you were referring to/i }
        return false
      end

      objs = Loot.reject_invalid_loot(bag.contents)

      if objs.empty?
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      objs = Loot.loot_specials(objs)

      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      if objs.empty?
        ELoot.data.checked_bags.push(bag.id)
        return
      end

      Loot.loot_regular(objs)

      ELoot.data.checked_bags.push(bag.id)
    end

    def self.box_loot(box, location = nil, data = nil) # Loots box contents
      if box.type == "box"
        line = ELoot.get_res("open ##{box.id}", /open|locked/)
        return Inventory.single_drag(box) if line =~ /locked/

        quiet_msg = ELoot.data.settings[:display_box_contents] ? false : true
        ELoot.get_command("look in ##{box.id}", ELoot.data.look_regex, silent: quiet_msg, quiet: quiet_msg)

        # Makes sure the item's contents are available
        return Inventory.single_drag(box) if !Inventory.container_contents(box)

        start_silvers = ELoot.silver_check
        while box.contents.any? { |obj| obj.name =~ /silver coins/ }
          unless ELoot.data.charm.nil?
            res = ELoot.get_res("point ##{ELoot.data.charm.id} at ##{box.id}", /You summon/)
            data[location] += ELoot.silver_check - start_silvers
          else
            res = ELoot.get_res("get coins from ##{box.id}", /You gather the remaining|Get what|You can only collect|You cannot hold any more silvers/)
            if res =~ /You gather the remaining/
              data[location] += ELoot.silver_check - start_silvers
              ELoot.wait_rt
              break
            elsif res =~ /You can only collect|You cannot hold any more silvers/
              data[location] += ELoot.silver_check - start_silvers
              ELoot.wait_rt
              room = Room.current.id
              ELoot.silver_deposit
              start_silvers = ELoot.silver_check
              ELoot.go2(room)
            else
              ELoot.msg(type: "info", text: " Unknown get coin result...Exiting!")
              exit
            end
          end
        end

        objs = box.contents
        if objs.empty?
          Sell.save_trash_box(box)
          return
        end

        objs = Loot.loot_specials(objs)

        # Anything left after boxes, collectibles, and uncommon weapon/armor?
        if objs.empty?
          Sell.save_trash_box(box)
          return
        end

        Loot.loot_regular(objs, "Box", box)
        Sell.save_trash_box(box)
      elsif box.type == "plinite"
        ELoot.get_res("pluck ##{box.id}", /You carefully pluck/)
        Inventory.free_hands(both: true)
      end
    end

    def self.loot_all(items) # loots entire room
      waitrt?

      Inventory.free_hand

      res = ELoot.get_command('loot room', /<dialogData|There is no loot|You need a free hand to do that|With a discerning eye|You note some treasure of interest|You can't.*?It's closed!/)

      if res.any? { |l| l =~ /There is no loot/ }
        items.each { |item| ELoot.unlootable(item) }
        return true
      end

      if res.any? { |l| l =~ /You can't.*?It's closed!/ }
        items_opened = Array.new
        items.each { |item|
          item_type = item.type.to_sym
          if StowList.stow_list[item_type] && !ELoot.data.sacks_full.include?(StowList.stow_list[item_type])
            bag = StowList.stow_list[item_type]
          else
            bag = StowList.stow_list[:default]
          end

          next if items_opened.include?(bag.name)

          items_opened.push(bag.name)

          if GameObj.containers.keys.include?(bag.id) && bag.contents.is_a?(Array)
            # check if open
            lines = ELoot.get_command("look in ##{bag.id}", ELoot.data.look_regex, silent: true, quiet: true)

            if lines.any? { |l| l =~ /That is closed./ }
              # This must be our lousy autocloser
              ELoot.data.settings[:auto_close].push(bag.name)
              ELoot.msg(type: "info", text: " #{bag.name} must be an autocloser, adding to list.")
              ELoot.save_profile()
            end
          end
        }

      end

      # Didn't get it all?...something in-hand?
      if res.any? { |l| l =~ /(?:gather|pick) up and stow (?:what|as much) treasure .+ manage|but quickly realize|before realizing you have no room/ }
        [GameObj.right_hand, GameObj.left_hand].each do |hand|
          Inventory.single_drag(hand) if items.any? { |thing| thing.id == hand.id }
        end

        # Anything left?
        objs = Loot.reject_invalid_loot(GameObj.loot.to_a)
        return if objs.empty?

        # Still here so rerun Loot.room
        Loot.room

      end
    end

    def self.loot_regular(objs, from_where = nil, box = nil)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      valid = Loot.valid_objs(objs.clone)
      invalid = Loot.invalid_objs(objs.clone)

      if from_where == "Room" && !ELoot.data.settings[:loot_types].include?("coins")
        valid.reject! { |o| o.name =~ /silver coin/ }
        invalid.concat(GameObj.loot.select { |o| o.name =~ /silver coin/ })
      end

      ELoot.msg(type: "debug", text: " Loot.room - valid: #{valid}")
      ELoot.msg(type: "debug", text: " Loot.room - invalid: #{invalid}")

      if !invalid.empty? && !valid.empty?
        Inventory.free_hand
        if from_where == "Room"
          loot_cmd_items = /clothing|jewelry|gem|herb|skin|wand|scroll|potion|reagent|trinket|lockpick|treasure|forageable|magic|collectible|lockandkey/
          valid.each do |obj|
            obj.type =~ loot_cmd_items ? Inventory.single_loot(obj) : Inventory.single_drag(obj)
          end
        else
          valid.each do |thing|
            Inventory.single_drag(thing)
          end
        end
      elsif invalid.empty? && !valid.empty?
        # Make sure we have a hand free
        Inventory.free_hand
        ELoot.msg(type: "debug", text: " Loot.loot_regular: Calling Loot.loot_all")

        if from_where == "Room"
          Loot.loot_all(valid)
        elsif from_where == "Box"
          ELoot.get_command("loot ##{box.id}", /You search through|You can't.*?It's closed!|There is no loot|In an attempt/i, silent: false, quiet: false)
          ELoot.wait_rt

          # If bag fills up it can leave an item in hand
          [GameObj.right_hand, GameObj.left_hand].each do |item|
            next if item.type == 'box'
            Inventory.single_drag(item)
          end

          # if there are still box contents the default container has filled up so just do the rest as drags
          if box.contents.length.positive?
            objs = box.contents
            remaining_valid = Loot.valid_objs(objs.clone)

            remaining_valid.each do |thing|
              Inventory.single_drag(thing)
            end
          end
        else
          valid.each do |thing|
            Inventory.single_drag(thing)
          end
        end
      end

      left_behind = invalid.map(&:name)
      ELoot.msg(type: "info", text: " Left the following item#{left_behind.length > 1 ? 's' : ''}: #{left_behind.join(', ')}.") unless left_behind.empty?

      ELoot.msg(type: "debug", text: " Loot.loot_regular: End of method")
    end

    def self.loot_specials(objs)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      # Open sacks for looting the room
      Inventory.open_loot_containers(objs)

      types = ["box", "clothing", "collectible", "cursed", "jewelry", "food", "breakable", "lm trap"]
      types_regex = Regexp.union(types)

      loot_types_regex = Regexp.union(ELoot.data.settings[:loot_types])
      loot_keep_regex = Regexp.union(ELoot.data.settings[:loot_keep].to_a)

      # Uncommon items in HW that loot room doesn't work on
      uncommon_loot = ["stygian valravn quill", "nacreous disir feather", "silver-veined black draconic idol"]
      loot_uncommon_regex = Regexp.union(uncommon_loot)

      objs = objs.reject do |thing|
        result = Loot.bag_loot(thing) if thing.type =~ /clothing/

        next true if result == "crumbly"
        next false if ELoot.data.exclude && thing.name.match(Regexp.union(ELoot.data.exclude))
        next false if (thing.name.eql?("shard of oblivion quartz") and Stats.level.eql?(100) && ELoot.data.settings[:loot_types].include?("gem"))
        next false if (thing.name =~ /doomstone|urglaes fang/ && !ELoot.data.settings[:loot_types].include?("cursed"))

        next false unless (
          (thing.type =~ loot_types_regex && thing.type =~ types_regex) ||
          (thing.type =~ /lockandkey/i) ||
          (ELoot.data.settings[:loot_keep].length.positive? && thing.name =~ loot_keep_regex) ||
          (thing.type =~ /cursed/i && ELoot.data.settings[:loot_types].include?("cursed")) ||
          (thing.type =~ /weapon/i && thing.type =~ /uncommon/ && ELoot.data.settings[:loot_types].include?("weapon")) ||
          (thing.type =~ /armor/i && thing.type =~ /uncommon/ && ELoot.data.settings[:loot_types].include?("armor")) ||
          (thing.name =~ /orb/ && thing.type =~ /magic/ && ELoot.data.settings[:loot_types].include?("magic")) ||
          (thing.name =~ loot_uncommon_regex && ELoot.data.settings[:loot_types].include?("uncommon")) ||
          (thing.name =~ /silver coin/ && ELoot.data.settings[:loot_types].include?("coins"))
        )

        if thing.name =~ /silver coin/
          coin_cmd = !ELoot.data.charm.nil? ? "rub ##{ELoot.data.charm.id}" : "get coins"
          ELoot.get_res(coin_cmd, /you (gather|summon)/i)
        else
          if ELoot.decurse(thing)
            Inventory.free_hand
            Inventory.single_drag(thing)
          end
        end

        next true
      end

      ELoot.msg(type: "debug", text: " Loot.loot_specials: After specials check objs: #{objs}")

      return objs
    end

    def self.occassional_skinner(obj)
      if obj.name =~ /rotting chimera/
        lines = ELoot.get_command("describe chimera", /The twisted and confused form/, silent: true, quiet: true)
        if lines.any? { |line| line =~ /A huge scorpion tail rises high from the rear/ }
          return true
        end
      end

      return false
    end

    def self.reject_invalid_loot(objs) # rejects items from the GamObj.loot object
      name_regex = Regexp.union(ELoot.data.reject_loot_names)
      noun_regex = Regexp.union(ELoot.data.reject_loot_nouns)

      objs.reject do |obj|
        next if ELoot.data.settings[:loot_keep].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:loot_keep])
        next if Bounty.task.heirloom? && obj.name =~ /#{Bounty.task.requirements[:item]}/i

        obj.name =~ /\b#{name_regex}\b/i ||
          obj.name =~ /[A-Z][a-z]+ #{ELoot.data.disk_nouns_regex}\b/ ||
          obj.noun =~ /\b#{noun_regex}\b/i ||
          obj.id.to_i.negative? ||
          (obj.type =~ /weapon|armor/i && obj.type !~ /uncommon|clothing/i) ||
          (ELoot.data.settings[:unlootable].include?(obj.name) && ELoot.data.settings[:log_unlootables]) ||
          ELoot.data.settings[:crumbly].index(obj.name) > -1
      end
    end

    def self.should_grab_item?(thing)
      # If its on the exclude list return
      return false if ELoot.data.exclude && thing.name.match(Regexp.union(ELoot.data.exclude))

      # oblivion quartz isn't cursed if you are level 100
      return true  if thing.name.eql?("shard of oblivion quartz") and Stats.level.eql?(100) && ELoot.data.settings[:loot_types].include?("gem")

      # Cursed items need to be handled separate due to gems
      return false if thing.type =~ /cursed/i && !ELoot.data.settings[:loot_types].include?("cursed")

      # Keep it if it's a type we want
      return true if thing.type =~ Regexp.union(ELoot.data.settings[:loot_types])

      # Keep it if it's our current bounty heirloom assignment
      return true if Bounty.task.heirloom? && thing.name =~ /#{Bounty.task.requirements[:item]}/i

      # If the type is something we don't want return false
      not_wanted = ELoot.data.all_loot_categories - ELoot.data.settings[:loot_types]
      return false if thing.type =~ Regexp.union(not_wanted)

      # Anything left lets take
      return true
    end

    def self.valid_objs(objs) # finds valid loot
      objs.select { |o| self.should_grab_item?(o) }
    end

    def self.invalid_objs(objs) # finds non-valid loot
      objs.reject { |o| self.should_grab_item?(o) }
    end

    def self.room # method that loots the room
      objs = Loot.reject_invalid_loot(GameObj.loot.to_a)

      unless objs.empty?
        objs = loot_specials(objs)
      end

      # Anything left after boxes, collectibles, and uncommon weapon/armor?
      unless objs.empty?
        Loot.loot_regular(objs, "Room")
      end
    end

    def self.search(objs = GameObj.dead.to_a) # searches dead critters
      return if objs.empty?

      regex_at_feet = /^<pushBold\/> \*\* A glint of light catches your eye, and you notice an? <a exist="(?<id>[\d-]+)" noun="(?<noun>[\w-]+)">(?<name>[\w\s-]+)<\/a>.*? at your feet! \*\*$/
      inhand_critters = /skayl|glacei|tumbleweed|plant|shrub|creeper|vine|bush|caedera|golem|elemental/

      objs.each do |thing|
        next if (ELoot.data.settings[:critter_exclude].length.positive? && thing.name =~ Regexp.union(ELoot.data.settings[:critter_exclude]))
        next if thing.status =~ /gone/

        ELoot.change_stance(100) if ELoot.data.settings[:loot_defensive]

        if ELoot.data.settings[:use_bloodbands]
          fput "raise ##{ELoot.data.blood_band.id} at ##{thing.id}"
        end

        if thing.name =~ inhand_critters
          (thing.name =~ /tumbleweed|plant|shrub|creeper|vine|bush/) ? Inventory.free_hands(left: true) : Inventory.free_hand
          if GameObj.right_hand.id.nil? && GameObj.left_hand.id.nil?
            free_hand = "left"
          else
            free_hand = GameObj.right_hand.id.nil? ? "right" : "left"
          end
        end

        # Loot it
        3.times do
          waitrt?
          results = ELoot.get_command("loot ##{thing.id}", /You (search|plunge|break)|not in any condition|see well enough to search|You can only loot creatures|Geez!  It's still alive!  Not a good time for that\./, silent: false, quiet: false)
          ELoot.msg(type: "debug", text: "Thing: #{thing.id}-#{thing.name}, Results: #{results.first}")

          if results.any? { |line| line =~ /not in any condition/ } &&
             ELoot.data.settings[:sigil_determination_on_fail] &&
             Spell['Sigil of Determination'].affordable? &&
             !Spell['Sigil of Determination'].active?
            Spell['Sigil of Determination'].cast
            next
          end

          if results.any? { |line| line =~ regex_at_feet }
            results.each do |line|
              if line =~ regex_at_feet
                match = Regexp.last_match
                Inventory.free_hand
                Inventory.single_drag(GameObj.new(match[:id], match[:noun], match[:name]))
              end
            end
          end

          break if results.any? { |line| line =~ /You (search|plunge|break)|not in any condition|see well enough to search|You can only loot creatures|Geez!  It's still alive!  Not a good time for that\./ } ||
                   thing.nil? || thing.status =~ /gone/
        end

        # Some creatures put an item directly in your hand
        if thing.name =~ inhand_critters
          check_hand = (free_hand == "right") ? GameObj.right_hand : GameObj.left_hand
          Inventory.single_drag(check_hand) unless check_hand.name == "Empty"
        end
      end

      # if the setting is on always end in defensive
      ELoot.change_stance(100) if ELoot.data.settings[:loot_defensive]
    end

    def self.skin_obj_types(objs, type) # skins type (blunt/dagger) group of dead critters
      return if objs.empty?

      dont_stow = false
      waitrt?

      if type == :blunt
        # Check skinner and sheath in case ReadyList/StowList got updated
        ELoot.ensure_items(key: 'skin_weapon_blunt', list: ReadyList.ready_list, inventory: ELoot.data.weapon_inv)
        ELoot.ensure_items(key: 'skin_sheath_blunt', list: ReadyList.ready_list, check_hidden: true)

        skinner = ReadyList.ready_list[:skin_weapon_blunt]
        ELoot.msg(type: "debug", text: " blunt skinner: #{skinner} blunt skinner.id: #{skinner.id}")
        unless skinner
          ELoot.msg(type: "info", text: " No blunt weapon found. Please run setup and make sure it's listed.")
          return
        end
        Inventory.free_hands(both: true)
      else
        # Check skinner and sheath in case ReadyList/StowList got update
        ELoot.ensure_items(key: 'skin_weapon', list: ReadyList.ready_list, inventory: ELoot.data.weapon_inv)
        ELoot.ensure_items(key: 'skin_sheath', list: ReadyList.ready_list, check_hidden: true)

        if ReadyList.ready_list[:skin_weapon].to_s.empty? || ReadyList.ready_list[:skin_weapon].nil?
          skinner = GameObj.right_hand
          ELoot.msg(type: "info", text: " No edged skinning weapon found. Using your right hand.")
        else
          skinner = ReadyList.ready_list[:skin_weapon]
        end

        ELoot.msg(type: "debug", text: " edged skinner: #{skinner} edged skinner.id: #{skinner.id}")

        dont_stow = true if [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)

        unless dont_stow
          Inventory.free_hand
        end
      end

      unless [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
        waitrt?
        Inventory.drag(skinner)
      end

      skinner_hand = skinner.id == GameObj.left_hand.id ? 'left' : 'right'

      # Safe to kneel?
      while GameObj.targets.empty? && ELoot.data.settings[:skin_kneel] && !kneeling?
        dothistimeout('kneel', 3, /You kneel down\.$|You move to|You are already kneeling\.$/)
      end

      # Sigil of Resolve?
      if ELoot.data.settings[:skin_resolve] &&
         Spell['Sigil of Resolve'].affordable? &&
         !Spell['Sigil of Resolve'].active?
        Spell['Sigil of Resolve'].cast
      end

      # 604 stuff
      if ELoot.data.settings[:skin_604] && Spell[604].affordable? && (!Spell[604].active? || (Spell[604].timeleft * 60).truncate() <= 10)
        until Spell[604].active? && (Spell[604].timeleft * 60).truncate() > 5
          Spell[604].cast
          sleep(0.1)
        end
      end

      skin_match = Regexp.union(
        /You skinned/i,
        /You botched/i,
        /already been/i,
        /cannot skin/i,
        /must be a member/i,
        /can only skin/i,
        /You are unable to break through/i,
        /You break through the crust of the/i,
        /You crack open a portion/i,
        /Because your account is free/i,
        /it's not possible to get a worthwhile/i,
      )

      break_match = Regexp.union(
        /You break through the crust of the .+ and withdraw (.+)!/i,
        /You crack open a portion of the .+ and uncover (.+)!/i,
      )

      # Skin em
      objs.each do |obj|
        res = dothistimeout("skin ##{obj.id} #{skinner_hand}", 2, skin_match)
        if res =~ /You cannot skin/
          ELoot.data.settings[:unskinnable].push(obj.name)
          ELoot.save_profile()
        elsif res =~ break_match
          fput "stow gem ##{GameObj.left_hand.id}"
        end
      end

      waitrt?

      return if dont_stow

      if type == :blunt
        bag = ReadyList.ready_list[:skin_sheath_blunt].nil? ? StowList.stow_list[:default] : ReadyList.ready_list[:skin_sheath_blunt]
      else
        bag = ReadyList.ready_list[:skin_sheath].nil? ? StowList.stow_list[:default] : ReadyList.ready_list[:skin_sheath]
      end

      Inventory.store_item(bag, skinner, true)

      if [GameObj.right_hand.id, GameObj.left_hand.id].include?(skinner.id)
        Inventory.store_item(StowList.stow_list[:default], skinner)
      end
    end

    def self.skin(objs = GameObj.dead.to_a) # determines what to skin
      objs = objs.reject do |obj|
        (ELoot.data.settings[:unskinnable].include?(obj.name) && !Loot.occassional_skinner(obj)) ||
          obj.type =~ /bandit/ ||
          obj.name =~ /(?:ethereal|ghostly|unwordly|Grimswarm)/ ||
          ELoot.data.settings[:skin_exclude].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:skin_exclude]) ||
          ELoot.data.settings[:critter_exclude].length.positive? && obj.name =~ Regexp.union(ELoot.data.settings[:critter_exclude])
      end

      return if objs.empty?

      blunts = objs.find_all { |obj| obj.name =~ /krynch|stone mastiff|krag dweller|cavern urchin/i }
      normals = objs.reject { |obj| obj.name =~ /krynch|stone mastiff|krag dweller|cavern urchin/i }

      skin_obj_types(normals, :normal)
      skin_obj_types(blunts, :blunt)

      new_stance = Char.percent_stance
      unless standing?
        ELoot.change_stance(0) if GameObj.targets.empty?
        dothistimeout('stand', 3, /You stand|You quickly roll|You are already standing/) until standing?
        ELoot.change_stance(new_stance) if Char.percent_stance != new_stance
      end
    end
  end
end

module ELoot # Sells the loot
  module Sell
    def self.appraise(item, location, _data = nil)
      return if item.type =~ /jewelry/ && location == "pawnshop"

      amount = 0
      raw = nil

      limit = location =~ /gemshop/i ? ELoot.data.settings[:sell_appraise_gemshop] : ELoot.data.settings[:sell_appraise_pawnshop]

      lines = ELoot.get_command("appraise ##{item.id}", /^You ask .*to appraise/)

      if lines.any? { |l| l =~ /([,0-9]+) (?:silver|for it if you want to sell|for this if you'd like)/ }
        raw = $1
        amount = $1.delete(",").to_i
      end

      if amount > limit.to_i || lines.any? { |l| l =~ /not buying anything this valuable today/ }
        message = amount > limit.to_i ? " The #{item} appraises for #{raw}. That's above your settings." : " The #{item} appraises as too valuable to sell."
        ELoot.msg(type: "info", text: message)

        # Reset the appraisal container if the StowList got updated
        ELoot.ensure_items(key: 'appraisal_container', list: StowList.stow_list)

        if StowList.stow_list[:appraisal_container].to_s.empty?
          Inventory.single_drag(item)
        else
          Inventory.store_item(StowList.stow_list[:appraisal_container], item)
        end
      elsif amount.positive? && amount <= limit.to_i
        Sell.sell_item(item, location, ELoot.data.silver_breakdown)
      else
        Inventory.single_drag(item)
      end
    end

    def self.box_in_hand(deposit = true)
      return unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")

      if [GameObj.left_hand.noun, GameObj.right_hand.noun].include?("reliquary")
        ELoot.msg(text: " Looks like you have a reliquary", space: true)
        exit
      end

      loop do
        item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" }
        break unless item && ELoot.data.settings[:sell_locksmith_pool]

        Sell.locksmith_pool([item], deposit)

        # check if still the same item. If it is then pool is full
        break if item.id == [GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" }.id
      end

      if (item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" }) && ELoot.data.settings[:sell_locksmith]
        Sell.locksmith([item])
      end

      if ([GameObj.right_hand, GameObj.left_hand].find { |i| i.type == "box" })
        ELoot.msg(text: " Not able to process the box in your hand. Exiting...", space: true)
        exit
      end
    end

    def self.breakdown
      return if ELoot.data.silver_breakdown.empty? && (ELoot.data.hoard_deposit.empty? || ELoot.data.hoard_deposit.nil?)
      return unless defined?(Terminal)
      rows = []

      unless ELoot.data.silver_breakdown.empty?
        total_silver = 0

        ELoot.data.silver_breakdown.each_with_index do |(location, amount), index|
          unless location =~ /(Pool|Town) (Dropoff|Depth|Open)/
            total_silver += amount
          end
          rows << [location, "   " + ELoot.format_number(amount)]

          # Only add a separator if the location matches the pattern and is not the last one
          if location =~ /Pool Depth|Town Open/ && index < ELoot.data.silver_breakdown.size - 1
            rows << :separator
          end
        end

        rows << :separator
        rows << ["Total", ELoot.format_number(total_silver)]
      end

      if ELoot.data.hoard_deposit.length.to_i.positive?
        all_gems = ELoot.data.hoard_deposit.find_all { |item| item[:type] == 'gem' }

        unless all_gems.length.to_i.zero?
          unique_gems = all_gems.uniq { |item| item[:item] }
          rows << :separator
          rows << [{ value: 'Gems Hoarded', colspan: 2, alignment: :center }]
          rows << :separator

          unique_gems.each { |obj|
            count = ELoot.data.hoard_deposit.find_all { |item| item[:item] == obj[:item] }.length.to_i
            rows << [ELoot.capitalize_words(obj[:item]), "   " + count.to_s]
          }
        end

        all_reagents = ELoot.data.hoard_deposit.find_all { |item| item[:type] == 'reagent' }

        unless all_reagents.length.to_i.zero?
          unique_reagents = all_reagents.uniq { |item| item[:item] }
          rows << :separator
          rows << [{ value: 'Reagents Hoarded', colspan: 2, alignment: :center }]
          rows << :separator
          unique_reagents.uniq!.each { |obj|
            count = ELoot.data.hoard_deposit.find_all { |item| item[:item] == obj[:item] }.length.to_i
            rows << [ELoot.capitalize_words(obj[:item]), "   " + count.to_s]
          }
        end
      end

      table = Terminal::Table.new :title => "Eloot Breakdown", :rows => rows # , :style => {:all_separators => true}
      table.align_column(1, :right)

      ELoot.wait_rt
      respond
      respond table
      respond
      ELoot.wait_rt
      return
    end

    def self.break_rocks
      rock_sacks = ELoot.set_selling_containers

      rock_sacks.each do |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.type =~ /breakable/ }.empty?
        sack.contents.each do |item|
          next unless item.type =~ /breakable/

          Inventory.drag(item)
          ELoot.get_res("break ##{item.id}", /You squeeze the chunk of rock/)

          Inventory.free_hands(both: true)
        end
      end
    end

    def self.check_bounty_furrier
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      return unless ELoot.data.settings[:sell_loot_types].include?("skin")
      # return unless Bounty.task.skin? && !Bounty.task.assigned? # update to this post 5.11.2+ release
      return unless Bounty.task.skin? && !Bounty.task.type.to_s.end_with?("assignment")
      need_furrier = false

      skin = Bounty.task.skin
      bundled_skins = skin.match(/(\w+)\s+(\w+)\s*\Z/)

      # need to check all the sacks that might have skins in them
      skin_sacks = ELoot.set_selling_containers(type: 'skin')

      skin_sacks.each do |sack|
        next if sack&.contents&.none? { |obj| obj.name =~ /#{skin}|#{bundled_skins}/i }
        need_furrier = true
        break
      end

      # if we don't have the bounty skins return early
      return unless need_furrier

      # if we are sitting in FWI bring us back
      ELoot.fwi_return

      # Are we in the correct town? If not is it close?
      return unless (location = Region.furrier)
      ELoot.go2(location)

      start_silvers = ELoot.silver_check
      bulk_note = 0

      ELoot.msg(type: "debug", text: "  check_bounty | skin_sacks: #{skin_sacks}")
      skin_sacks.each do |sack|
        next if sack.nil?
        next if sack.contents.none? { |obj| obj.name =~ /#{skin}|#{bundled_skins}/i }

        bulk_sell = true
        bulk_sell = false if sack.contents.any? { |obj| obj.name =~ /bundle of/ }
        unless ELoot.data.settings[:sell_exclude].empty?
          if sack.contents.any? { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /furrier/ }
            bulk_sell = false
          end
        end

        bulk_sell = false if sack.contents.any? { |obj| obj.name !~ /#{skin}/ && obj.sellable =~ /furrier/ }

        if bulk_sell
          ELoot.msg(type: "debug", text: " check_bounty | bulk_sell: #{bulk_sell} using sack: #{sack}")
          Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

          dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
          Inventory.wear(sack)

          if (bulk_note = ELoot.read_note.to_i).positive?
            ELoot.data.silver_breakdown["Furrier"] += bulk_note

            # Deposit local note if selling in FWI
            ELoot.deposit_note if ELoot.data.settings[:sell_fwi]
          end

          sleep 0.5
        else
          sack.contents.each do |item|
            next if $sell_ignore.include?(item.id)
            next unless item.sellable =~ /furrier/
            next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
            next unless item.name =~ /#{skin}|#{bundled_skins}/i

            $sell_ignore.push(item.id)
            Inventory.drag(item)

            if item.name =~ /bundle/
              # grab the bundle ID
              bundle_id = GameObj.right_hand.id || GameObj.left_hand.id

              until ![GameObj.right_hand.id, GameObj.left_hand.id].include?(bundle_id)
                # remove a skin
                result = dothistimeout "bundle remove", 5, /You remove|Those were the last two/

                if result =~ /Those were the last two/
                  Sell.sell_item(GameObj.right_hand, "Furrier", ELoot.data.silver_breakdown)
                  Sell.sell_item(GameObj.left_hand, "Furrier", ELoot.data.silver_breakdown)
                else
                  # get the skin id
                  skin = GameObj.right_hand.id != bundle_id ? GameObj.right_hand : GameObj.left_hand
                  Sell.sell_item(skin, "Furrier", ELoot.data.silver_breakdown)
                end
              end
            else
              Sell.sell_item(item, "Furrier", ELoot.data.silver_breakdown)
            end
          end
        end

        Inventory.free_hands(both: true)
        ELoot.msg(type: "debug", text: "  check_bounty_furrier | bottom of each using sack: #{sack}")
      end

      ELoot.data.silver_breakdown["Furrier"] += (ELoot.silver_check - start_silvers)
    end

    def self.check_bounty_gems
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      return unless ELoot.data.settings[:sell_loot_types].include?("gem")
      # return unless Bounty.task.gem? && !Bounty.task.assigned? # update to this post 5.11.2+ release
      return unless Bounty.task.gem? && !Bounty.task.type.to_s.end_with?("assignment")
      need_gemshop = false

      gem = Bounty.requirements[:gem]

      gem_sacks = ELoot.set_selling_containers(type: 'gem')

      gem_sacks.each do |sack|
        next if sack&.contents&.none? { |obj| obj.name =~ /#{gem}/ }
        need_gemshop = true
        break
      end

      # if we don't need the gemshop return early
      return unless need_gemshop

      # if we are sitting in FWI bring us back
      ELoot.fwi_return

      # Are we in the correct town? If not is it close?
      return unless (location = Region.gemshop)
      ELoot.go2(location)

      start_silvers = ELoot.silver_check
      bulk_note = 0

      Inventory.free_hands(both: true)

      gem_sacks.each do |sack|
        next if sack.nil?
        next if sack.contents.none? { |obj| obj.name =~ /#{gem}/i }

        bulk_sell = true
        bulk_sell = false if sack.contents.any? { |obj| obj.name !~ /#{gem}/ && obj.type =~ /gem/ }
        unless ELoot.data.settings[:sell_exclude].empty?
          if sack.contents.any? { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /gemshop/ }
            bulk_sell = false
          end
        end
        # Bulk sell sack if it has gems and no exclusions
        if bulk_sell
          Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?
          dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
          Inventory.wear(sack)
          sleep 0.5
          if (bulk_note = ELoot.read_note.to_i).positive?
            ELoot.data.silver_breakdown["Gemshop"] += bulk_note

            # Deposit local note if selling in FWI
            ELoot.deposit_note if ELoot.data.settings[:sell_fwi]
          end

          Inventory.free_hands(both: true)
        else
          sack.contents.each do |item|
            next unless item.name =~ /#{gem}/

            Inventory.drag(item)
            Sell.sell_item(item, "Gemshop", ELoot.data.silver_breakdown)
            Inventory.free_hands(both: true)
          end
        end
      end

      ELoot.data.silver_breakdown["Gemshop"] += (ELoot.silver_check - start_silvers)
    end

    def self.check_bounty
      Sell.check_bounty_furrier
      Sell.check_bounty_gems
    end

    def self.check_items(specific: nil, items: nil)
      selling = []
      ELoot.data.gemshop_first = false

      all_contents = items.nil? ? Sell.check_inventory : items

      all_contents.each { |thing|
        next if $sell_ignore.include?(thing.id)
        next if ReadyList.ready_list.find { |_k, v| v.id == thing.id }
        next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
        next if thing.name =~ /\bbound\b|^shimmering \w+ orb$/
        next if selling.include?(thing.type) && !thing.type.nil?
        if !specific.nil?
          next unless specific.include?(thing.type)
        end

        if thing.type =~ /clothing/ && thing.sellable.include?("pawnshop") && thing.sellable.include?("gemshop")
          ELoot.data.gemshop_first = true
        end

        if ELoot.data.alchemy_mode
          next if thing.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          next if thing.noun =~ /^(?:jar|beaker|bottle)$/ and thing.after_name.nil?
        end

        if thing.name =~ ELoot.data.regex_gold_rings && ELoot.data.settings[:sell_gold_rings]
          selling.push("chronomage") unless selling.include?("chronomage")
        elsif thing.type =~ /scarab/ && ELoot.data.settings[:sell_loot_types].include?("scarab")
          selling.push("gemshop") unless selling.include?("gemshop")
        elsif thing.type == "gem" && ELoot.data.settings[:sell_loot_types].include?("gem") && thing.noun =~ /thorn|berry/
          selling.push("gemshop") unless selling.include?("gemshop")
        elsif thing.type == "collectible" && ELoot.data.settings[:sell_collectibles]
          selling.push("collectibles") unless selling.include?("collectibles")
        elsif ELoot.data.settings[:sell_loot_types].include?("box") && thing.type == "box"
          selling.push("pawnshop") unless selling.include?("pawnshop")
        elsif !thing.sellable.nil? && thing.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          thing.sellable.to_s.split(',').each { |location|
            selling.push(location) unless selling.include?(location)
          }
        end
      }

      ELoot.msg(type: "debug", text: "Places to go: #{selling}")
      return selling
    end

    def self.check_inventory
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")

      all_contents = []

      StowList.stow_list.each do |item, container|
        next unless container
        next unless ELoot.data.settings[:sell_container].any? { |sell| item.to_s.match?(/#{Regexp.escape(sell)}/) }

        Inventory.open_single_container(container)
        all_contents += container.contents.to_a
      end

      if ELoot.data.settings[:use_disk]
        ELoot.wait_for_disk
        unless ELoot.data.disk.nil?
          Inventory.open_single_container(ELoot.data.disk)
          all_contents += ELoot.data.disk.contents.to_a
        end
      end

      # Remove items from all_contents if their id is in the $sell_ignore array
      all_contents.reject! { |thing| $sell_ignore.include?(thing.id) }
      return all_contents
    end

    def self.collectibles
      return unless ELoot.data.settings[:sell_collectibles]

      places = []
      places.push(Room.current.find_nearest_by_tag("collectible")) unless Room.current.find_nearest_by_tag("collectible").nil?
      places.push(Room.current.find_nearest_by_tag("collectibles")) unless Room.current.find_nearest_by_tag("collectibles").nil?

      go_place = Room.current.find_nearest(places)

      ELoot.go2(go_place)

      Inventory.free_hands(both: true)

      collectible_sacks = ELoot.set_selling_containers(type: 'collectible')

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      collectible_sacks.each do |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.type == "collectible" }.empty?

        # Still here so remove the sack from the array
        ELoot.data.sacks_full.delete(sack)

        sack.contents.each do |thing|
          next if $sell_ignore.include?(thing.id)
          next unless thing.type == "collectible"
          next if ReadyList.ready_list.find { |_k, v| v.id == thing.id }
          next if (thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && !ELoot.data.settings[:sell_exclude].empty?)
          next if thing.name =~ /bound/

          $sell_ignore.push(thing.id)
          Inventory.drag(thing)
          dothistimeout("deposit ##{thing.id}", 3, /You hand your/)

          20.times {
            break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(thing.id))

            sleep 0.1
          }

          Inventory.free_hands(both: true)
        end
      end
    end

    def self.consignment
      ELoot.go2("consignment")
      start_silvers = ELoot.silver_check
      Inventory.free_hands(both: true)

      consignment_sacks = ELoot.set_selling_containers(type: 'reagent')

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      consignment_sacks.each do |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.sellable.include?("consignment") }.empty?

        # Still here so remove the sack from the array
        ELoot.data.sacks_full.delete(sack)

        sack.contents.each do |thing|
          next if $sell_ignore.include?(thing.id)
          next unless thing.sellable.include?("consignment")
          next unless thing.type.split(',').any? { |type| type =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          next if ReadyList.ready_list.find { |_k, v| v.id == thing.id }
          next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
          next if thing.name =~ /bound/

          if ELoot.data.alchemy_mode
            next if thing.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(thing.id)
          Inventory.drag(thing)
          # Sell.sell_item(thing)
          Sell.sell_item(thing, "Consignment", ELoot.data.silver_breakdown)

          Inventory.free_hands(both: true)
        end
      end

      ELoot.data.silver_breakdown["Consignment"] += (ELoot.silver_check - start_silvers)
    end

    def self.custom_list(items)
      # put items into an array and clean up any weirdness
      items_array = items.gsub('/', '').split(/,|\|/).map(&:strip)

      # convert that into a regex
      items_regex = Regexp.new(items_array.join('|'))

      # get the Inventory
      all_contents = Sell.check_inventory

      # Find the items
      items_to_sell = all_contents.select { |item| item.name.match?(items_regex) }

      # check where to go for selling them
      locations = Sell.check_items(items: items_to_sell)

      # if its empty we are done
      return if locations.empty?

      Inventory.clear_hands

      # Go to each location and sell
      locations.each do |place|
        ELoot.go2(place)
        ELoot.wait_rt

        items_to_sell.each do |item|
          Inventory.drag(item)

          if item.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?
            Sell.appraise(item, place.capitalize, ELoot.data.silver_breakdown)
          else
            Sell.sell_item(item, place.capitalize, ELoot.data.silver_breakdown)
          end

          Inventory.free_hands(both: true)
        end
      end

      ELoot.silver_deposit(true)
      Inventory.return_hands
    end

    def self.custom_sellable(sellable)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]} | sellable: #{sellable}")
      sellable_types = []

      # Split items into an array
      sellable_array = sellable.gsub('/', '').split(/,|\|/).map(&:strip)

      # Check to make sure the type exists in GameObj
      sellable_array.each { |item|
        if GameObj.sellable_data.keys.include?(item) || item =~ /collectible|chronomage/
          sellable_types << item
        else
          ELoot.msg(type: "yellow", text: "  #{item.capitalize} is not a valid sellable category.")
          tmp_sellable = GameObj.sellable_data.keys + ['collectible', 'chronomage']
          ELoot.msg(type: 'default', text: "  GameObj sellable: #{tmp_sellable}")
          exit
        end
      }

      # return unless there is a location
      return unless sellable_types.length.positive?
      locations = Sell.check_items

      Inventory.clear_hands

      Sell.check_bounty_gems if sellable_types.include?('gemshop')
      Sell.check_bounty_furrier if sellable_types.include?('furrier')

      # check if we still need to go to the gemshop or furrier
      if ['gemshop', 'furrier'].any? { |el| sellable_types.include?(el) }
        locations = Sell.check_items
      end

      remaining_sellable = locations & sellable_types

      # return if it's empty
      return if remaining_sellable.empty?

      Sell.go_sell(remaining_sellable)

      ELoot.silver_deposit(true)
      Inventory.return_hands
    end

    def self.custom_type(types)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]} | types: #{types}")
      sell_types = []
      recheck = false

      # Split items into an array
      types_array = types.gsub('/', '').split(/,|\|/).map(&:strip)

      # Check to make sure the type exists in GameObj
      types_array.each { |type|
        if GameObj.type_data.keys.include?(type)
          sell_types << type
        else
          ELoot.msg(type: "yellow", text: "  #{type.capitalize} is not a valid GameObj type.")
          ELoot.msg(type: 'default', text: "  GameObj types: #{GameObj.type_data.keys}")
          exit
        end
      }

      # return if there are no valid types
      return unless sell_types.length.positive?

      Inventory.clear_hands

      # process boxes first
      Sell.process_boxes if sell_types.include?('box')

      # send the types thru check_items to get our selling locations
      locations = Sell.check_items(specific: sell_types)

      # if its empty we are done
      return if locations.empty?

      # buff up for sales!
      Sell.sell_buffs

      # If type is gem or skin - sell at bounty location
      if sell_types.include?('gem') && locations.include?("gemshop")
        Sell.check_bounty_gems
        recheck = true
      end

      if sell_types.include?('skin') && locations.include?("furrier")
        Sell.check_bounty_furrier
        recheck = true
      end

      # rechecking locations to see if we still need to go to the gemshop or furrier
      if recheck
        locations = Sell.check_items(specific: sell_types)
      end

      # if its empty we are done
      return if locations.empty?

      # finally lets go sell stuff
      Sell.gold_rings if locations.include?("chronomage")
      Sell.furrier if locations.include?("furrier")
      Sell.gemshop(sell_types) if locations.include?("gemshop")
      Sell.consignment if locations.include?("consignment")
      Sell.pawnshop(sell_types) if locations.include?("pawnshop")
      Sell.collectibles if locations.include?("collectibles")

      ELoot.silver_deposit(true)
      Inventory.return_hands
    end

    def self.dump_herbs_junk
      # What stuff are we supposed to dump?
      dump_stuff = []
      ["herb", "junk", "food"].each { |item|
        if ELoot.data.settings[:sell_loot_types].include?(item)
          dump_stuff.push(item)
        end
      }

      # Return if nothing
      if dump_stuff.empty?
        return
      end

      # Do we have anything to dump?
      dump_items = []
      sacks = ELoot.set_selling_containers
      sacks.each { |sack|
        sack.contents.each { |item|
          if item.type =~ Regexp.union(dump_stuff) || (ELoot.data.alchemy_mode && item.name =~ /^some ground|flask of pure water|some powdered|some mashed|handful of sea salt|spirit shard|tincture of/)
            if ELoot.data.alchemy_mode
              next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
            end
            dump_items.push(item)
          end
        }
      }

      # No items to dump so return
      if dump_items.empty?
        return
      end

      # Is there a trash can here?
      trash = ELoot.find_trash

      unless trash
        # going here because they have trash cans. Don't want to litter
        if XMLData.game == 'GSF' && Room[Room.current.find_nearest_by_tag("town")].location == 'the tunnels and caverns of Zul Logoth'
          trash_spot = 1005
        else
          trash_spot = 'locksmith pool'
        end

        ELoot.go2(trash_spot)
        trash = ELoot.find_trash
      end

      if trash.nil?
        ELoot.msg(type: "info", text: " No trashcan found! Skipping herb/junk/food disposal so as not to litter and be a pest.")
        return
      end

      dump_items.each { |item|
        Inventory.drag(item)
        fput("put ##{item.id} in ##{trash.id}")

        20.times {
          break if ![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id)
          sleep 0.1
        }

        if [GameObj.right_hand.id, GameObj.left_hand.id].include?(item.id)
          ELoot.msg(type: "info", text: " #{item.name} isn't gone so maybe its special...keeping it.")
          Inventory.single_drag(item)
        end
      }

      Inventory.free_hands(both: true)
    end

    def self.furrier
      ELoot.go2("furrier")
      start_silvers = ELoot.silver_check
      bulk_note = 0

      Inventory.free_hands(both: true)

      skin_match = /You have been tasked to retrieve (\d+) (.*) of at least \w+ quality for (?:the )?\w+ (?:in|on|near) (?:(.*) (?:under|near|between) )?(?:the Company Store in )?([^.]+)\./

      skin_sacks = ELoot.set_selling_containers(type: 'skin')

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      ELoot.msg(type: "debug", text: " skin_sacks: #{skin_sacks}")
      skin_sacks.each do |sack|
        ELoot.msg(type: "debug", text: " Beginning of skin_sack.each: #{sack}")
        next if sack.nil?
        next unless ELoot.data.settings[:sell_loot_types].include?("skin") || ELoot.data.settings[:sell_loot_types].include?("reagent")
        next if sack.contents.find_all { |obj| obj.sellable =~ /furrier/ }.empty?

        # Still here so remove the sack from the array
        ELoot.data.sacks_full.delete(sack)

        ELoot.msg(type: "debug", text: " Contents after next: #{sack.contents} using sack: #{sack}")
        bulk_sell = true
        bulk_sell = false if bounty? =~ skin_match && sack.contents.find_all { |obj| obj.name =~ /bundle/ }.length.positive?
        bulk_sell = false if ELoot.data.alchemy_mode
        unless ELoot.data.settings[:sell_exclude].empty?
          if sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.sellable =~ /furrier/ }.length.positive?
            bulk_sell = false
          end
        end

        if bulk_sell
          ELoot.msg(type: "debug", text: " bulk_sell: #{bulk_sell} using sack: #{sack}")
          Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

          ELoot.silver_check

          dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)
          Inventory.wear(sack)

          bulk_note = ELoot.read_note.to_i

          if bulk_note > 0
            ELoot.data.silver_breakdown["Furrier"] += bulk_note
          end

          sleep 0.5
        end

        Inventory.free_hands(both: true)

        sack.contents.each do |item|
          next if $sell_ignore.include?(item.id)
          next unless item.sellable =~ /furrier/
          next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/

          if ELoot.data.alchemy_mode
            next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(item.id)
          Inventory.drag(item)

          if item.name =~ /bundle/
            # grab the bundle ID
            bundle_id = !GameObj.right_hand.id.nil? ? GameObj.right_hand.id : GameObj.left_hand.id

            until ![GameObj.right_hand.id, GameObj.left_hand.id].include?(bundle_id)
              # remove a skin
              result = dothistimeout "bundle remove", 5, /You remove|Those were the last two/

              if result =~ /Those were the last two/
                Sell.sell_item(GameObj.right_hand, "Furrier", ELoot.data.silver_breakdown)
                Sell.sell_item(GameObj.left_hand, "Furrier", ELoot.data.silver_breakdown)
              else
                # get the skin id
                skin = GameObj.right_hand.id != bundle_id ? GameObj.right_hand : GameObj.left_hand
                # Sell.sell_item(skin)
                Sell.sell_item(skin, "Furrier", ELoot.data.silver_breakdown)
              end

            end

          else
            Sell.sell_item(item, "Furrier", ELoot.data.silver_breakdown)
          end
        end

        Inventory.free_hands(both: true)
        ELoot.msg(type: "debug", text: " bottom of each using sack: #{sack}")
      end

      ELoot.data.silver_breakdown["Furrier"] += (ELoot.silver_check - start_silvers)
    end

    def self.gemshop(type = nil)
      ELoot.go2("gemshop")
      start_silvers = ELoot.silver_check
      bulk_note = 0

      Inventory.free_hands(both: true)

      gem_sacks = ELoot.set_selling_containers(type: 'gem')

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      gem_sacks.each { |sack|
        next if sack.nil?
        next if sack.contents.find_all { |obj| obj.sellable.include?("gemshop") }.empty?

        # Still here so remove the sack from the array
        ELoot.data.sacks_full.delete(sack)

        # Bulk sell sack if it has gems and no exclusions
        if (ELoot.data.settings[:sell_exclude].empty? || (sack.contents.find_all { |obj| obj.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/ && obj.type =~ /gem/ }).empty?) && sack.contents.find_all { |obj| obj.type =~ /gem/ }.length.positive? && ELoot.data.settings[:sell_loot_types].include?("gem") && !ELoot.data.alchemy_mode
          if type.nil? || !type.nil? && type.include?('gem')
            Inventory.drag(sack) if [checkleft, checkright].index(sack.noun).nil?

            dothistimeout("sell ##{sack.id}", 3, /inspects the contents carefully/)

            Inventory.wear(sack)
            sleep 0.5

            bulk_note = ELoot.read_note.to_i

            if bulk_note > 0
              ELoot.data.silver_breakdown["Gemshop"] += bulk_note
            end

            Inventory.free_hands(both: true)
          end
        end

        # Loop thru remaining contents and sell/appraise whatever is left
        sack.contents.each do |item|
          next if $sell_ignore.include?(item.id)
          next unless item.sellable.include?("gemshop") || item.noun =~ /thorn|berry/ || item.type =~ /scarab/
          next unless item.type.split(',').any? { |obj| obj =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
          next if !ELoot.data.settings[:sell_exclude].empty? && item.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
          next if ELoot.data.settings[:sell_gold_rings] && item.name =~ ELoot.data.regex_gold_rings
          next if item.name =~ /\bbound\b|^shimmering \w+ orb$/
          if !type.nil?
            next unless type.include?(item.type)
          end

          if ELoot.data.alchemy_mode
            next if item.name =~ /#{Vars.needed_reagents}/ && Vars.needed_reagents.length.to_i > 0
          end
          $sell_ignore.push(item.id) unless item.type =~ /clothing/

          if item.type =~ /cursed/
            if !ELoot.data.settings[:sell_loot_types].include?("cursed") || (!Spell[315].known? && item.name =~ /urglaes fang/)
              ELoot.msg(type: "info", text: "** #{item.name} is cursed. Can't touch that. You'll need to take a look", space: true)
              next
            elsif ELoot.data.settings[:sell_loot_types].include?("cursed")
              next unless ELoot.decurse(item)
            end
          end

          Inventory.drag(item)

          if item.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?
            Sell.appraise(item, "Gemshop", ELoot.data.silver_breakdown)
          else
            Sell.sell_item(item, "Gemshop", ELoot.data.silver_breakdown)
          end

          Inventory.free_hands(both: true)
        end
      }

      ELoot.data.silver_breakdown["Gemshop"] += (ELoot.silver_check - start_silvers)
    end

    def self.glam_and_shroud
      glam = Spell[1205]
      shroud = Spell[1212]

      if glam.known? && glam.affordable? && Effects::Spells.time_left("Glamour") < 1
        wait_until { glam.affordable? }
        glam.cast(Char.name)
      end

      if shroud.known?
        shroud_races = ['human',
                        'giantman',
                        'half-elf',
                        'sylvankind',
                        'dark elf',
                        'elf',
                        'dwarf',
                        'halfling',
                        'forest gnome',
                        'burghal gnome',
                        'half-krolvin',
                        'erithian',
                        'aelotoi']
        shroud_race_hash = { "vo"  => "human",
                             "ifw" => "dwarf",
                             "wl"  => "human",
                             "imt" => "halfling",
                             "rr"  => "human",
                             "kf"  => "human",
                             "en"  => "elf",
                             "ti"  => "dwarf",
                             "zl"  => "dwarf" }
        town = Room[Room.current.find_nearest_by_tag("town")]
        town_key = town.image.split("-")[0]
        if town.image =~ /zul/i
          town_key = "zl"
        end
        desired_race = shroud_race_hash[town_key]

        lines = ELoot.get_command("fame", /<output class="mono"\/>/, silent: true, quiet: true)

        if lines.any? { |line| line =~ /You are a level (?:\d+) ([\w\- ]+) (?:[\w\- ]+)\./ }
          current_race = $1.downcase()
          current_race_setting = shroud_races.index(current_race) + 1
        end

        return true if current_race == desired_race

        race_setting = shroud_races.index(desired_race) + 1
        if Effects::Spells.time_left("Shroud of Deception") < 2
          waitcastrt?
          wait_until { shroud.affordable? }
          shroud.cast(Char.name)
        end

        lines = ELoot.get_command("shroud profile", /You are currently using profile/, silent: true, quiet: true)

        if lines.any? { |line| line =~ /You are currently using profile <d cmd='shroud view [0-9]+'>([0-9]+)<\/d>./ }
          shroud_profile = $1
        end

        before_dying { fput("shroud set #{shroud_profile} race #{current_race_setting}") }
        fput("shroud set #{shroud_profile} race #{race_setting}")
      end
    end

    def self.go_sell(selling)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]} | selling: #{selling}")
      return if selling.empty?

      Sell.sell_buffs

      rooms = []
      selling.each { |shop|
        if Room[Room.current.find_nearest_by_tag("town")].uid.first == 7503205 && !ELoot.data.settings[:sell_fwi] # HW doesn't have some shops
          next if shop =~ /collect|pawnshop|consignment|chronomage/
        end

        next if shop == "chronomage" && ELoot.fwi?(Room.current) # No chronomage in FWI
        if shop == "chronomage" && !ELoot.fwi?(Room.current) && ELoot.data.settings[:sell_fwi]
          Sell.gold_rings
          next
        end

        room = Room.current.find_nearest_by_tag(shop)
        rooms.push(room) unless room.nil?
      }

      while rooms.any?
        # Find closest room
        closest_room = nil
        _where_is_previous_var, where_is_shortest_distances_var = Room.current.dijkstra

        # Prioritize gemshops if needed
        if ELoot.data.gemshop_first
          gemshop_rooms = rooms.select { |room| Room[room].tags.include?("gemshop") }
          closest_room = gemshop_rooms.uniq.sort_by { |room| where_is_shortest_distances_var[room] }.first
          ELoot.data.gemshop_first = false
        end

        # Fallback to closest room if no gemshops found
        closest_room ||= rooms.uniq.sort_by { |room| where_is_shortest_distances_var[room] }.first

        if Char.percent_encumbrance > 80
          ELoot.silver_deposit
        end

        Sell.gold_rings if Room[closest_room].tags.include?("chronomage")
        Sell.furrier if Room[closest_room].tags.include?("furrier")
        Sell.gemshop if Room[closest_room].tags.include?("gemshop")
        Sell.consignment if Room[closest_room].tags.include?("consignment")
        Sell.pawnshop if Room[closest_room].tags.include?("pawnshop")
        Sell.collectibles if Room[closest_room].tags.include?("collectibles") || Room[closest_room].tags.include?("collectible")

        rooms.delete(closest_room)
      end
    end

    def self.gold_rings
      return unless ELoot.data.settings[:sell_gold_rings]

      ELoot.go2("chronomage")

      Inventory.free_hands(both: true)

      unless (npc = GameObj.npcs.find { |n| n.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant|guard/ })
        npc = GameObj.room_desc.find { |n| n.noun =~ /clerk|agent|halfling|scallywag|dwarf|woman|attendant|guard/ }
      end

      unless npc.nil?
        chrono_sacks = ELoot.set_selling_containers

        chrono_sacks.each { |sack| Inventory.open_single_container(sack) }

        chrono_sacks.each { |sack|
          next if sack.nil?
          next if sack.contents.find_all { |obj| obj.name =~ ELoot.data.regex_gold_rings }.empty?

          sack.contents.each do |item|
            next if $sell_ignore.include?(item.id)
            next unless item.name =~ ELoot.data.regex_gold_rings

            $sell_ignore.push(item.id)
            Inventory.drag(item)

            fput "give ##{item.id} to ##{npc.id}"

            20.times {
              break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))

              sleep 0.1
            }

            Inventory.free_hands(both: true)
          end
        }
      end
    end

    def self.inbetween_scripts
      return unless ELoot.data.settings[:between].length.positive?

      # go back to the start room before running scripts
      ELoot.go2(ELoot.data.start_room)

      ELoot.data.settings[:between].each do |i|
        tokens = i.split(/\s+/)
        if (tokens.size > 1)
          Script.run(tokens[0], tokens[1..-1].join(", "))
        else
          Script.run(tokens[0])
        end
      end
    end

    def self.locksmith(boxes)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]}")
      # if we're here, assume we emptied out the disk some
      ELoot.data.disk_full = false

      ELoot.silver_withdraw(ELoot.data.settings[:locksmith_withdraw_amount])

      ELoot.go2('locksmith')
      move "east" if Room.current.uid.include?(7118381)
      ELoot.wait_for_disk

      if (table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /(?:table|counter)$/ })
        dothistimeout("look on ##{table.id}", 3, /On the/) if table.contents.nil?

        if table.contents.nil?
          error('failed to find table contents')
        else
          activator = nil
          if table.contents.any? { |obj| obj.noun == 'bell' }
            activator = 'ring bell'
          elsif table.contents.any? { |obj| obj.noun == 'keys' }
            activator = 'pull keys'
          elsif table.contents.any? { |obj| obj.noun == 'chime' } || GameObj.loot.any? { |obj| obj.noun == 'chime' }
            activator = 'ring chime'
          end

          if activator
            boxes.each { |box|
              Inventory.free_hands(both: true) unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
              Sell.locksmith_open(box, activator)
            }
          else
            ELoot.msg(type: "error", text: " Failed to find a bell, keys, or chime on the table", space: true)
          end
        end
      else
        ELoot.msg(type: "error", text: " Failed to find a table", space: true)
      end
    end

    def self.locksmith_open(box, activator)
      lines = ELoot.get_command("look in ##{box.id}", /<container|That is closed|You see the shifting form/, silent: true, quiet: true)
      return unless lines.any? { |line| line =~ /That is closed|You see the shifting form/i }

      Inventory.drag(box) unless [GameObj.left_hand.type, GameObj.right_hand.type].include?("box")
      box = ELoot.box_unphase(box)

      lines = ELoot.get_command("open ##{box.id}", /That is already open|You open|You throw back|It appears to be locked/, silent: true, quiet: true)

      if lines.any?(/locked/)
        res = dothistimeout(activator, 2, /Gimme ([\d,]+) silvers/)
        if res =~ /Gimme ([\d,]+) silvers/
          ELoot.data.silver_breakdown["Town Locksmith"] += -1 * $1.delete(",").to_i
          ELoot.data.silver_breakdown["Town Open"] += 1
        end

        unless res
          ELoot.msg(type: "error", text: ' Unknown locksmith response.')
          Inventory.single_drag(box, false)
          return
        end

        result = dothistimeout('pay', 2, /accepts|have enough/)
        if result =~ /have enough/
          Inventory.single_drag(box, false)
          ELoot.silver_withdraw(ELoot.data.settings[:locksmith_withdraw_amount])
          ELoot.go2('locksmith')

          return Sell.locksmith_open(box, activator)
        end
      end
      Loot.box_loot(box, "Town Locksmith", ELoot.data.silver_breakdown)
    end

    def self.locksmith_pool(boxes, deposit = false)
      # are we starting with a box in hand?
      box_in_hand = [GameObj.right_hand, GameObj.left_hand].any? { |hand| hand&.type =~ /box/ }

      # make sure some type of tipping was selected
      unless ELoot.data.settings[:use_standard_tipping] || ELoot.data.settings[:use_incremental_tipping]
        ELoot.msg(type: "yellow", text: ' No tipping options selected in UI')
        exit
      end

      match = /You want a locksmith|You don't have that much|takes your|already holding as many boxes|already (unlocked|open)/
      percent = ELoot.data.settings[:sell_locksmith_pool_tip_percent] ? ' PERCENT' : ''
      pool_count = 0
      result = nil

      # if we're here, assume we will empty out the disk
      ELoot.data.disk_full = false

      if boxes.length.positive? && ELoot.data.settings[:use_standard_tipping]
        amount = ELoot.data.settings[:sell_locksmith_pool_tip_percent] ? ELoot.data.settings[:locksmith_withdraw_amount] : boxes.length * ELoot.data.settings[:sell_locksmith_pool_tip].to_i
        ELoot.silver_withdraw(amount)
      end

      ELoot.go2('locksmith pool')
      original_pool = Room.current.id
      worker = ELoot.find_worker

      # if using incremental tipping, need to find out how many boxes are in the pool
      if boxes.length.positive? && ELoot.data.settings[:use_incremental_tipping]
        pool_count = Sell.locksmith_pool_count(worker)
        if pool_count > 99
          ELoot.msg(type: "yellow", text: " No room in the locksmith pool")
          return if deposit

          ELoot.msg(type: "yellow", text: " Checking to see if any boxes available for return")
          Sell.pool_return(worker)
          pool_count = Sell.locksmith_pool_count(worker)
          return if pool_count > 99
        else
          total_tips = Sell.locksmith_determine_tip(pool_count + 1, boxes.length)
          ELoot.silver_withdraw(total_tips)
          ELoot.go2(original_pool)
          worker = ELoot.find_worker
        end
      end

      Inventory.free_hands(both: true) unless [GameObj.right_hand, GameObj.left_hand].find { |hand| hand.type =~ /box/ }
      ELoot.wait_for_disk

      boxes.each do |box|
        Inventory.drag(box) unless [GameObj.right_hand, GameObj.left_hand].find { |hand| hand.type =~ /box/ }

        unless GameObj.right_hand.id == box.id
          fput "swap"
          ELoot.wait_rt
        end

        box = ELoot.box_unphase(box)

        case
        when ELoot.data.settings[:use_standard_tipping]
          tip_amount = "#{ELoot.data.settings[:sell_locksmith_pool_tip].to_i}#{percent}"
        else
          tip_amount = Sell.locksmith_determine_tip(pool_count, 1)
        end

        redo_needed = false
        2.times do
          result = dothistimeout("give ##{worker.id} #{tip_amount}", 3, match)

          case result
          when /Your tip of (.*) silvers?/
            ELoot.data.silver_breakdown["Locksmith Pool"] += -1 * $1.delete(",").to_i
            pool_count += 1
            ELoot.data.silver_breakdown["Pool Dropoff"] += 1

            if pool_count > 99
              ELoot.msg(type: "yellow", text: " That was the last spot open in the pool")
              return true if deposit

              ELoot.msg(type: "yellow", text: " Checking to see if any boxes available for return")
              Sell.pool_return(worker)
              pool_count = Sell.locksmith_pool_count(worker)
            end
          when /You don't have that much/
            ELoot.silver_withdraw(ELoot.data.settings[:locksmith_withdraw_amount])
            ELoot.go2(original_pool)
            redo_needed = true
          when /already holding as many boxes/
            ELoot.wait_rt
            Inventory.single_drag(box) unless box_in_hand
            ELoot.msg(type: "yellow", text: " That was the last spot open in the pool")
            return true if deposit

            ELoot.msg(type: "yellow", text: " Checking to see if any boxes available for return")
            Sell.pool_return(worker)
            ELoot.wait_rt
            pool_count = Sell.locksmith_pool_count(worker)
            redo_needed = true
          when /already (unlocked|open)/
            Loot.box_loot(box, "Locksmith Pool", ELoot.data.silver_breakdown)
          end
        end

        break if pool_count > 99
        redo if redo_needed
      end

      Inventory.free_hands(both: true)
    end

    def self.pool_return(worker = nil)
      if worker.nil?
        ELoot.go2('locksmith pool')
        worker = ELoot.find_worker
      end

      lighten_load = false

      loop do
        match = /We don't have any boxes ready for you|We don't seem to have that box|Alright, here's your|You need to lighten your load first/
        res = dothistimeout("ask ##{worker.id} for return", 3, match)

        break if res !~ /Alright, here's your|You need to lighten your load first/

        if res =~ /You need to lighten your load first/
          if lighten_load
            ELoot.msg(type: "info", text: " Too much weight! Breaking from locksmith pool return.")
            break
          end
          lighten_load = true
          ELoot.msg(type: "info", text: " Too much weight! Depositing coins and trying again")
          room = Room.current.id
          ELoot.silver_deposit
          ELoot.go2(room)
        else
          20.times {
            break if [GameObj.right_hand, GameObj.left_hand].map(&:type).compact.join(",") =~ /box|plinite/
            sleep 0.1
          }
          lighten_load = false
          box = nil
          if GameObj.right_hand.type =~ /box|plinite/
            box = GameObj.right_hand
          elsif GameObj.left_hand.type =~ /box|plinite/
            box = GameObj.left_hand
          else
            ELoot.msg(type: "error", text: " Failed to find the box you were supposed to get; report this to Elanthia-Online")
            ELoot.msg(type: "error", text: " GameObj.left_hand: #{GameObj.left_hand.inspect}")
            ELoot.msg(type: "error", text: " GameObj.right_hand: #{GameObj.right_hand.inspect}")
          end

          ELoot.data.silver_breakdown["Pool Return"] += 1
          Loot.box_loot(box, "Locksmith Pool", ELoot.data.silver_breakdown)
        end

        ELoot.wait_rt
      end

      ELoot.data.silver_breakdown["Pool Depth"] = Sell.locksmith_pool_count(worker)
    end

    def self.locksmith_pool_count(worker)
      current_box_amount = 0
      list_match = /here's the list of boxes we have for you\.|You haven't given us any boxes to be worked on\.|^(\d+)\./

      results = ELoot.get_command("ask ##{worker.id} about list", list_match, silent: true, quiet: true)
      previous_buffer = reget(300)

      results.reverse.each do |line|
        if line =~ /^\s*(?<amount>\d+)\.\s+An?/
          current_box_amount = Regexp.last_match[:amount].to_i
          break
        end
      end

      start_index = previous_buffer.reverse.find_index { |value| value =~ /here's the list of boxes we have for you\.|You haven't given us any boxes to be worked on\./ }
      current_box_amount = current_box_amount - (previous_buffer.drop(previous_buffer.size - start_index - 1).select { |line| line =~ /It is ready to be RETURNED\./ }.count)
    end

    def self.locksmith_determine_tip(pool_count, boxes_length)
      tip_amount = 0
      upper_limit = [pool_count + (boxes_length), 100].min
      pool_count += 1

      (pool_count..upper_limit).each do |items|
        tip_amount += Sell.locksmith_tip(items, ELoot.data.settings[:base_tip], ELoot.data.settings[:max_tip], ELoot.data.settings[:alpha_rate])
      end

      return tip_amount.ceil
    end

    def self.locksmith_tip(box_no, base_tip, max_tip, alpha)
      factor = (box_no).to_f / 100
      adjusted_tip = base_tip.to_i + (factor**alpha.to_f) * (max_tip.to_i - base_tip.to_i)
      adjusted_tip.round # return an integer
    end

    def self.pawnshop(type = nil)
      ELoot.go2("pawnshop")
      start_silvers = ELoot.silver_check
      Inventory.free_hands(both: true)

      # Assume bags will be emptied after sell routine
      # Fixme - check which bags are used
      ELoot.data.sacks_full = []

      all_contents = []
      StowList.stow_list.each do |item, container|
        next unless container
        next unless ELoot.data.settings[:sell_container].any? { |sell| item.to_s.match?(/#{Regexp.escape(sell)}/) }
        all_contents += StowList.stow_list[item].contents.to_a
      end

      if ELoot.data.settings[:use_disk]
        ELoot.wait_for_disk
        unless ELoot.data.disk.nil?
          Inventory.open_single_container(ELoot.data.disk)
          all_contents += ELoot.data.disk.contents.to_a
        end
      end

      # Lousy autoclosers
      if ELoot.time_between(:autoclosers, 30)
        Inventory.check_auto_closer
      end

      all_contents.each do |thing|
        next if $sell_ignore.include?(thing.id)
        next unless (thing.sellable.include?("pawnshop") && !thing.sellable.include?("gemshop")) || thing.type == "box" || thing.type =~ /clothing/
        next if ReadyList.ready_list.find { |_k, v| v.id == thing.id }
        next if !ELoot.data.settings[:sell_exclude].empty? && thing.name =~ /#{ELoot.data.settings[:sell_exclude].join('|')}/
        next unless thing.type.split(',').any? { |obj| obj =~ /^#{ELoot.data.settings[:sell_loot_types].join('|')}$/ }
        next if thing.name =~ /\bbound\b|^shimmering \w+ orb$/
        next if ELoot.data.settings[:sell_gold_rings] && thing.name =~ ELoot.data.regex_gold_rings
        if !type.nil?
          next unless type.include?(thing.type)
        end

        $sell_ignore.push(thing.id)
        if thing.type =~ /scroll/ && ELoot.data.settings[:sell_keep_scrolls].length.positive?
          no_vib = ELoot.data.settings[:sell_keep_scrolls].reject { |item| item.to_s =~ /v/i }
          no_vib_regex = /\((?:#{no_vib.join("|")})\)(?!.*vibrant)/i

          vib_scrolls = ELoot.data.settings[:sell_keep_scrolls].select { |item| item.to_s =~ /v/i }.map { |item| item.to_s[/\d+/] }
          vib_scrolls_regex = /\((?:#{vib_scrolls.join("|")})\).*vibrant/i

          lines = ELoot.get_command("read ##{thing.id}", /It takes you a moment|There is nothing there to read|You can't do that/, silent: true, quiet: true)

          next if lines.any? { |line| line =~ no_vib_regex }
          next if lines.any? { |line| line =~ vib_scrolls_regex }
        end

        if thing.type =~ /cursed/ && !ELoot.data.settings[:sell_loot_types].include?("cursed")
          ELoot.msg(type: "info", text: "** #{thing.name} is cursed. Can't touch that. You'll need to take a look", space: true)
          next
        elsif thing.type =~ /cursed/ && ELoot.data.settings[:sell_loot_types].include?("cursed")
          next unless ELoot.decurse(thing)
        end

        Inventory.drag(thing)

        lines = ELoot.get_command("analyze ##{thing.id}", /You analyze/, silent: true, quiet: true)
        if lines.any?(/ALTER 41/)
          ELoot.msg(type: "info", text: "** This analyzes as Alter 41. Keeping it **", space: true)
          Inventory.single_drag(thing)
          next
        end

        if (thing.type =~ /#{ELoot.data.settings[:sell_appraise_types].join('|')}/ && !ELoot.data.settings[:sell_appraise_types].empty?) || thing.type =~ /uncommon|weapon|armor/
          Sell.appraise(thing, "Pawnshop", ELoot.data.silver_breakdown)
        elsif thing.type =~ /box/
          line = ELoot.get_res("look in ##{thing.id}", ELoot.data.look_regex)
          if line =~ /There is nothing|In the/i

            thing.contents.each { |box_item|
              if box_item.type =~ /cursed/ && Spell[315].known? && Spell[315].affordable? && ELoot.data.settings[:sell_loot_types].include?("cursed")
                Spell[315].cast("at ##{box_item.id}")
              elsif box_item.type =~ /cursed/ && !ELoot.data.settings[:sell_loot_types].include?("cursed")
                ELoot.msg(type: "info", text: "** #{box_item.name} is cursed. Stowing box. You'll need to take a look", space: true)
                Inventory.single_drag(thing, false)
              else
                Inventory.single_drag(box_item, false)
              end
            }
            # Sell.sell_item(thing)
            Sell.sell_item(thing, "Pawnshop", ELoot.data.silver_breakdown)
          elsif line =~ /That is closed/i
            # This shouldn't happen
            ELoot.msg(type: "info", text: "** #{thing.name} is closed. Storing box...")
            Inventory.single_drag(thing, false)
          end
        else
          Sell.sell_item(thing, "Pawnshop", ELoot.data.silver_breakdown)
        end

        Inventory.free_hands(both: true)
      end

      ELoot.data.silver_breakdown["Pawnshop"] += (ELoot.silver_check - start_silvers)
    end

    def self.pool(deposit: false, check: false)
      room = Room.current.id
      ELoot.data.right_hand = GameObj.right_hand
      ELoot.data.left_hand = GameObj.left_hand

      if deposit
        # Make sure we can see all the containers
        StowList.stow_list.each do |item, container|
          next unless container
          next unless ELoot.data.settings[:sell_container].any? { |sell| item.to_s.match?(/#{Regexp.escape(sell)}/) }

          Inventory.open_single_container(container)
        end

        # Remember current silver amount
        if deposit
          current_keep_silver = ELoot.data.settings[:sell_keep_silver].to_i
          ELoot.data.settings[:sell_keep_silver] = ELoot.silver_check
        end

        Sell.box_in_hand(deposit)
        boxes = ELoot.find_boxes

        return if boxes.empty? && !check

        Inventory.free_hands(both: true)
        Sell.locksmith_pool(boxes, deposit)
      end

      if check
        Inventory.free_hands(both: true)
        Sell.pool_return
      end

      # Deposit any additional silver taken out for box processing
      if deposit
        ELoot.silver_deposit
        ELoot.data.settings[:sell_keep_silver] = current_keep_silver
      end

      ELoot.go2(room)
      Inventory.return_hands
    end

    def self.process_boxes
      boxes = ELoot.find_boxes

      cur_len = boxes.length.to_i
      ELoot.msg(type: "debug", text: "ELoot.sell: Boxes length: #{cur_len}")

      # Process boxes in the locksmithpool
      if (ELoot.data.settings[:always_check_pool] || (ELoot.data.settings[:sell_locksmith_pool] && boxes.any?)) && !(Bounty.task.gem? && ELoot.data.settings[:sell_locksmith] && ELoot.data.settings[:locksmith_when_gem_bounty] && boxes.length.positive?)
        Sell.locksmith_pool(boxes) unless !ELoot.data.settings[:sell_locksmith_pool]
        Sell.pool_return # retrieve (and loot) any boxes in the pool

        # Refresh the boxes
        boxes = ELoot.find_boxes
      end

      # Sell off any remaining boxes
      Sell.locksmith(boxes) if ELoot.data.settings[:sell_locksmith] && boxes.length.positive?

      # Deposit silvers if encumbered
      if Char.percent_encumbrance > 80
        ELoot.silver_deposit
      end
    end

    def self.save_trash_box(box)
      ELoot.msg(type: "debug", text: " #{__method__} | caller: #{caller[0]} | box: #{box.inspect}")

      return_room = Room.current.id
      save_box = ELoot.data.settings[:sell_loot_types].include?("box")
      valuable_box = /gold|mithril|silver/

      # If it's a save box and empty, just store it immediately also don't toss Reliquaries
      if (save_box && box.name =~ valuable_box && box.contents.empty?) || box.name =~ /reliquary/i
        Inventory.single_drag(box, false)
        return
      end

      trash = ELoot.find_trash

      unless trash
        trash_spot = if XMLData.game == 'GSF' && Room[Room.current.find_nearest_by_tag("town")].location == 'the tunnels and caverns of Zul Logoth'
                       1005
                     else
                       'locksmith pool'
                     end
        ELoot.go2(trash_spot)
        trash = ELoot.find_trash
      end

      if save_box && box.name =~ valuable_box && !box.contents.any? { |obj| obj.type =~ /cursed/ }
        box.contents.each do |item|
          Inventory.drag(item)
          fput("put ##{item.id} in ##{trash.id}") if trash
          sleep(0.5)
          Inventory.single_drag(item) if [GameObj.right_hand.id, GameObj.left_hand.id].include?(item.id)
        end

        Inventory.single_drag(box, false)
      elsif trash
        t = Time.now + 3
        loop do
          dothistimeout "put ##{box.id} in ##{trash.id}", 1, /As you place|If you wish to continue/
          break if ![GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id) || Time.now > t
        end
      else
        until ![GameObj.right_hand.id, GameObj.left_hand.id].include?(box.id)
          fput("drop ##{box.id}")
        end
      end

      # Always return to the original room
      ELoot.go2(return_room)
    end

    def self.sell # Main sell method
      fput('unhide') if (hidden? || invisible?)

      Sell.box_in_hand

      Inventory.clear_hands

      Sell.process_boxes

      Sell.inbetween_scripts

      # Break rocks
      Sell.break_rocks if ELoot.data.settings[:sell_loot_types].include?("breakable")

      # Hoard Stuff
      if ELoot.data.settings[:gem_horde] || ELoot.data.settings[:alchemy_horde]
        Hoard.hoard_items
      end

      # Check Bounties
      Sell.check_bounty

      Sell.go_sell(Sell.check_items)

      ELoot.silver_deposit(true)

      # If herb or junk is checked for selling we dump it. Only default and overflow
      Sell.dump_herbs_junk

      Inventory.return_hands

      # Close any containers that were opened
      Inventory.close_sell_containers if ELoot.data.settings[:keep_closed]
    end

    def self.sell_buffs
      Sell.glam_and_shroud if ELoot.data.settings[:sell_shroud]

      if ELoot.data.settings[:sell_aspect] && Spell[650].known? && !Spell[9018].active? && !Spell[9019].active?
        if Spell[650].affordable? && !Spell[650].active?
          multifput("prep 650", "assume lion")
        elsif Spell[650].active? && checkmana(25)
          waitcastrt?
          fput "assume lion"
        end
      end
    end

    def self.sell_item(item, place = nil, data = nil)
      return if item.nil? || item.name == "Empty"

      lines = ELoot.get_command("sell ##{item.id}", /You (offer to sell|ask)/)

      return if lines.any?(/That's not quite my field|That's basically worthless here|Can't say I'm interested in that|This is a pawnshop, sir, not a junkshop|The company don't buy trash|as if you were a lunatic/)

      20.times {
        break if (![GameObj.right_hand, GameObj.left_hand].map(&:id).compact.include?(item.id))

        sleep 0.1
      }

      bulk_note = ELoot.read_note.to_i

      if bulk_note > 0
        data[place] += bulk_note
      end
    end
  end
end

module ELoot # Starts the script
  if Script.current.vars[1] =~ /ver/i
    echo "   Eloot Version: #{ELoot.get_script_version}"
    exit
  end

  if Spell['Berserk'].active?
    ELoot.msg(type: "info", text: " Berserk is active, preventing you from looting.", space: true)
    exit
  end

  # Fixme: need better way to start so it doesn't conflict with other autostart items
  sleep 2 if Script.current.vars[1] =~ /start/

  # Initialize/Load settings
  unless ELoot.data && ELoot.data.respond_to?(:version) && ELoot.data.version == ELoot.get_script_version
    waitrt?
    ELoot.load(ELoot.load_profile())
    ELoot.set_inventory
    exit if Script.current.vars[0] =~ /load/
  end

  if !ELoot.data.settings[:track_full_sacks]
    ELoot.data.sacks_full = Array.new
    ELoot.data.disk_full = false
  end

  # Sorter shows inventory checks so we kill it and restart
  ELoot.manage_sorter

  # Default to loot
  if Script.current.vars[1].nil?
    Thread.new { loop { Script.self.kill if dead?; sleep(5); } }

    if ELoot.data.settings[:debug_file]
      ELoot.data.debug_logger = ELoot::DebugLogger.new
    end

    ELoot.disk_usage
    ELoot.loot
    ELoot::Inventory.close_sell_containers if ELoot.data.settings[:keep_closed]

    exit
  end

  if Room.current.id.nil?
    ELoot.msg(type: "yellow", text: " Please start #{Script.current.name} in a mapped room", space: true)
    exit
  else
    ELoot.data.start_room = Room.current.id
  end

  $sell_ignore ||= Array.new
  ELoot.data.silver_breakdown = Hash.new

  case Script.current.vars[0]
  when /debug/
    if Script.current.vars[0].split(/[\s,|]+/).last =~ /file/
      ELoot::Setup.update_setting(:debug_file, !ELoot.data.settings[:debug_file])
      ELoot.data.settings[:debug_file] = !ELoot.data.settings[:debug_file]
    else
      ELoot::Setup.update_setting(:debug, !ELoot.data.settings[:debug])
      ELoot.data.settings[:debug] = !ELoot.data.settings[:debug]
    end

    ELoot.save_profile(silent: true)
    exit
  when 'start'
    exit
  when 'list'
    ELoot::Setup.new(ELoot.data.settings).list if Script.current.vars[2].nil?
    ELoot::Setup.new(ELoot.data.settings).list(cat_to_list: Script.current.vars[2]) if !Script.current.vars[2].nil?
  when /^box/
    ELoot.data.debug_logger = ELoot::DebugLogger.new if ELoot.data.settings[:debug_file]
    if GameObj.right_hand.type =~ /box/
      box = GameObj.right_hand
      ELoot::Inventory.free_hands(left: true)
    elsif GameObj.left_hand.type =~ /box/
      box = GameObj.left_hand
      ELoot::Inventory.free_hands(right: true)
    elsif Script.current.vars[2] =~ /\A\d+\z/ # Fixme: intended to support ground looting items/boxes (mostly when picking boxes on the ground)
      box = GameObj.loot.find { |l| l.id =~ /#{Script.current.vars[2].to_i}/ }
    end

    ELoot::Loot.box_loot(box)
    ELoot.go2(ELoot.data.start_room)
  when /^sell/
    ELoot.data.debug_logger = ELoot::DebugLogger.new if ELoot.data.settings[:debug_file]
    ELoot.wait_rt
    # Assume bags will be emptied after sell routine
    ELoot.data.sacks_full = []

    if Script.current.vars[2] == "alchemy_mode"
      ELoot.data.alchemy_mode = true
    end
    ELoot.disk_usage
    ELoot.sell
    ELoot.go2(ELoot.data.start_room)
    ELoot::Sell.breakdown
    ELoot.data.alchemy_mode = false
  when /pool/
    ELoot.data.debug_logger = ELoot::DebugLogger.new if ELoot.data.settings[:debug_file]
    arg = Script.current.vars[2]

    if arg.nil?
      check = true
      deposit = true
    else
      check = arg =~ /check|return|loot/i
      deposit = arg =~ /depo/i
    end

    ELoot.disk_usage
    ELoot::Sell.pool(deposit: deposit, check: check)

    ELoot::Sell.breakdown
  when /--(sellable|type|sell)\b\s*=?\s*(\/?[a-zA-Z,\s|]+\/?)/
    ELoot.data.debug_logger = ELoot::DebugLogger.new if ELoot.data.settings[:debug_file]
    type = Regexp.last_match(1)
    things = Regexp.last_match(2)

    ELoot::Sell.custom_sellable(things) if type == 'sellable'
    ELoot::Sell.custom_type(things) if type == 'type'
    ELoot::Sell.custom_list(things) if type == 'sell'

    ELoot.go2(ELoot.data.start_room)
    ELoot::Sell.breakdown
  when /settings|setup/i
    if Script.current.vars[2]
      ELoot.update_setting(Script.current.vars[2..-1])
    elsif defined?(Gtk)
      ELoot.launch_settings_ui
    else
      ELoot.msg(text: " Gtk is not defined. Please use CLI to change options")
      ELoot.msg(text: " Format is #{$lich_char}#{Script.current.name} settings <setting_to_change> <new_value>")
      ELoot.msg(text: " To list settings #{$lich_char}#{Script.current.name} options")
    end
  when /options/i
    ELoot.msg(type: "default", text: ELoot.data.settings.keys.sort.join("\n"))
  when /raid/
    ELoot.data.debug_logger = ELoot::DebugLogger.new if ELoot.data.settings[:debug_file]
    ELoot::Hoard.raid_cache(Script.current.vars)
    ELoot.go2(ELoot.data.start_room)
  when /(list|deposit|reset) (gem|reagent|alchemy)/i
    ELoot.data.debug_logger = ELoot::DebugLogger.new if ELoot.data.settings[:debug_file]
    do_what = $1
    item = $2
    if item =~ /reagent|alchemy/
      type = 'alchemy'
    elsif item =~ /gem/
      type = 'gem'
    end
    case do_what
    when /list/i
      ELoot::Hoard.list_inventory(type)
    when /deposit/i
      ELoot::Hoard.hoard_items(type, true)
    when /reset/i
      ELoot::Hoard.reset_inventory(type)
      ELoot::Hoard.list_inventory(type)
    end
    ELoot.go2(ELoot.data.start_room)
  when /bounty/i
    ELoot.data.debug_logger = ELoot::DebugLogger.new if ELoot.data.settings[:debug_file]
    ELoot::Hoard.get_gem_bounty
  when /load/i
    waitrt?
    ELoot.load(ELoot.load_profile)
    ELoot.set_inventory
  when /deposit/i
    ELoot.data.debug_logger = ELoot::DebugLogger.new if ELoot.data.settings[:debug_file]
    ELoot.silver_deposit(true)
    ELoot.go2(ELoot.data.start_room)
  when /^skin/i
    ELoot.data.debug_logger = ELoot::DebugLogger.new if ELoot.data.settings[:debug_file]
    ELoot::Loot.skin
  when /test/i
    ELoot.test
  else
    ELoot.help
  end
end
