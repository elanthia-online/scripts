=begin

  Automated fletching script for creating arrows, light bolts, and heavy bolts.

  Learning mode will restart after cutting nocks and wait while mind is above the configured threshold.
  Has the ability to make arrows, light and heavy bolts with full support for painting and cresting.

  Have only the fletchings you want to use in your supplies container. The script does not distinguish
  between types of fletchings when working, it only checks to make sure the kind you entered are in your
  supplies sack.

  Will make, paint and crest arrows/bolts. If you are in a mapped room it can run to the shop and buy
  more basic items. Will keep going until you tell it to stop or you hit the limit you set.

  Bow or crossbow must be worn before starting script. Crossbow must be cocked and unloaded.

  Setup:
    ;FletchIt setup  - Configure all settings (required on first run)

  Commands:
    ;FletchIt help   - Display help information
    ;FletchIt        - Start fletching or show progress if running
    ;FletchIt stop   - Stop after finishing current arrow
    ;FletchIt bundle - Bundle all arrows/bolts in container

        author: elanthia-online
  contributors: Dissonance
          game: Gemstone
          tags: crafting, fletching, arrows, bolts
      required: Lich >= 5.4.1
       version: 2.0
        source: https://github.com/elanthia-online/lich-5-scripts

  changelog:
    2.0 (2025-01-02):
      Complete refactor with modular architecture
      Removed 1000+ lines of duplicate dead code
      Standardized error handling with status symbols
      Fixed arrow/bolt tracking logic
      Improved messaging consistency
      Added dynamic ammo type messages
      Fixed mind percentage to use settings
    1.0
      Initial release as changes made to ;fletching script

=end

#==============================================================================
# Main namespace for the FletchIt script
#
# FletchIt provides a complete automated fletching solution organized into
# six specialized modules:
#
# @example Basic script usage
#   ;fletchit setup  # First-time configuration
#   ;fletchit        # Start fletching loop
#   ;fletchit stop   # Stop after current arrow
#   ;fletchit bundle # Combine partial bundles
#
# @example Programmatic usage
#   settings = FletchIt::Config.load_settings
#   FletchIt::Crafting.make_shafts(settings)
#   FletchIt::Crafting.make_arrow(settings, FletchIt::Config::PAINTS)
#
# @see FletchIt::Config Configuration management
# @see FletchIt::Validator Settings validation
# @see FletchIt::Inventory Container operations
# @see FletchIt::GameActions Game command wrappers
# @see FletchIt::Shopping Automated supply purchasing
# @see FletchIt::Crafting Arrow/bolt creation
# @see FletchIt::Bundle Bundle management
#==============================================================================
module FletchIt
  #============================================================================
  # Configuration management
  #
  # Handles loading, saving, and managing user settings including:
  # - Container names (supplies, quiver)
  # - Tool names (axe, knife, bow)
  # - Material preferences (wood type, fletchings, paint)
  # - Operational settings (learning mode, auto-buy, limits)
  #============================================================================
  module Config
    # Current version of the script
    #
    # @note This should be updated whenever significant changes are made
    VERSION = "2.0"

    # Default configuration values for new characters
    #
    # These settings are used when a character runs the script for the first time
    # or when saved settings don't exist. Users can modify these through the setup GUI.
    #
    # @note Container names should match what appears in GameObj.inv
    # @note Knife/axe/bow names should be what you'd type after 'get'
    DEFAULTS = {
      sack: "backpack",
      quiver: "backpack",
      axe: "handaxe",
      knife: "dagger",
      bow: "bow",
      enable_buying: false,
      paint: 0,
      paintstick1: "",
      paintstick2: "",
      wood: "limb of wood",
      fletchings: "bundle of fletchings",
      limit: "",
      waggle: false,
      learning: false,
      alerts: false,
      tip: "",
      drill: "",
      ammo: 1,
      mind: "60",
      monitor_interaction: false
    }.freeze

    # Mapping of ammo type codes to their display names
    #
    # Used in the setup GUI and for display purposes.
    # The numeric keys correspond to settings[:ammo] values.
    #
    # @example
    #   AMMO_TYPES[1] #=> 'arrow'
    #   AMMO_TYPES[2] #=> 'light bolt'
    AMMO_TYPES = {
      1 => 'arrow',
      2 => 'light bolt',
      3 => 'heavy bolt'
    }.freeze

    # Complete listing of available paint colors from the fletcher shop
    #
    # Maps numeric indices to paint color names as they appear in the shop.
    # Index 0 means no paint will be applied to shafts.
    #
    # @note Paint names should match the shop 'order' menu exactly
    # @see FletchIt::Shopping.buy_items
    PAINTS = {
      0  => 'none',
      1  => 'bright golden paint',
      2  => 'fiery orange paint',
      3  => 'bright yellow paint',
      4  => 'dark russet paint',
      5  => 'dark brown paint',
      6  => 'silvery grey paint',
      7  => 'twilight grey paint',
      8  => 'storm grey paint',
      9  => 'charcoal grey paint',
      10 => 'icy blue paint',
      11 => 'midnight blue paint',
      12 => 'dusky blue paint',
      13 => 'silvery white paint',
      14 => 'bone white paint',
      15 => 'pure white paint',
      16 => 'glossy black paint',
      17 => 'dull black paint',
      18 => 'inky black paint',
      19 => 'forest green paint',
      20 => 'hunter green paint',
      21 => 'dark green paint',
      22 => 'blood red paint',
      23 => 'glossy red paint',
      24 => 'dull red paint'
    }.freeze

    # Load settings from character storage, merging with defaults
    #
    # Retrieves saved settings for the current character from CharSettings and
    # merges them with DEFAULTS, allowing saved values to override defaults.
    #
    # @return [Hash] Merged settings hash with character-specific overrides
    # @example
    #   settings = FletchIt::Config.load_settings
    #   settings[:sack] #=> "backpack" or user's custom container
    # @see CharSettings
    # @see DEFAULTS
    def self.load_settings
      settings = DEFAULTS.dup
      settings.each_key do |key|
        saved_value = CharSettings[key]
        settings[key] = saved_value unless saved_value.nil?
      end
      settings
    end

    # Save settings to character storage
    #
    # Persists all settings to CharSettings for the current character.
    # Settings are saved immediately to disk via Settings.save.
    #
    # @param settings [Hash] Settings hash to persist
    # @return [void]
    # @example
    #   settings[:sack] = "haversack"
    #   FletchIt::Config.save_settings(settings)
    # @see CharSettings
    # @see Settings
    def self.save_settings(settings)
      settings.each do |key, value|
        CharSettings[key] = value
      end
      Settings.save
    end
  end

  #============================================================================
  # Settings validation and normalization
  #
  # Ensures all required settings are configured and formats them correctly.
  # Validates container names, tool names, and material settings.
  #============================================================================
  module Validator
    # Validate that all required settings are configured
    #
    # @param settings [Hash] Settings to validate
    # @return [Array<String>] Array of warning messages (empty if valid)
    def self.validate_settings(settings)
      warnings = []

      if settings[:sack].to_s.empty?
        warnings << "The container for your supplies has not been set"
      end

      if settings[:quiver].to_s.empty?
        warnings << "The container for finished arrows has not been set"
      end

      if settings[:knife].to_s.empty?
        warnings << "Knife/dagger has not been set"
      end

      if settings[:bow].to_s.empty?
        warnings << "Bow/crossbow has not been set"
      end

      if settings[:axe].to_s.empty?
        warnings << "Axe has not been set"
      end

      if settings[:wood].to_s.empty?
        warnings << "Wood type has not been set"
      end

      if settings[:wood] !~ /wood|log|branch|limb/
        warnings << "Wood setting may be incorrect (should be 'limb of wood' or similar)"
      end

      if settings[:fletchings] !~ /fletching/
        warnings << "Fletchings setting may be incorrect (should be 'bundle of fletchings' or similar)"
      end

      warnings
    end

    # Normalize settings by removing articles and adding missing words
    #
    # Removes leading articles (a, an, some) from material names and
    # auto-appends "paintstick" to paintstick settings if missing.
    #
    # @param settings [Hash] Settings to normalize
    # @return [Hash] Normalized settings
    def self.normalize_settings(settings)
      # Remove leading articles
      if settings[:wood] =~ /^\s*(a|an|some)\s+/i
        settings[:wood].gsub!(/^\s*(a|an|some)\s+/i, '')
      end

      if settings[:fletchings] =~ /^\s*(a|an|some)\s+/i
        settings[:fletchings].gsub!(/^\s*(a|an|some)\s+/i, '')
      end

      # Auto-add paintstick if missing
      if settings[:paintstick1].to_s.length > 0 && settings[:paintstick1] !~ /paintstick/
        settings[:paintstick1] = "#{settings[:paintstick1].strip} paintstick"
      end

      if settings[:paintstick2].to_s.length > 0 && settings[:paintstick2] !~ /paintstick/
        settings[:paintstick2] = "#{settings[:paintstick2].strip} paintstick"
      end

      settings
    end
  end

  #============================================================================
  # Inventory and container management
  #
  # Handles checking containers, retrieving contents, and stowing items.
  # Includes error handling for missing or full containers.
  #============================================================================
  module Inventory
    # Check current silver on hand
    #
    # @return [Integer] Amount of silver in inventory
    def self.check_silver
      Lich::Util.silver_count
    end

    # Get the contents of a container by name
    #
    # Opens the container if necessary and retrieves its contents.
    # Will exit the script if the container cannot be found.
    #
    # @param container_name [String] Name of the container to search
    # @return [Array<GameObj>] Array of items in the container
    # @raise [SystemExit] If container not found or cannot be accessed
    def self.get_container_contents(container_name)
      if container_name.nil? || container_name.empty?
        Lich::Messaging.msg("error", "Blank container name")
        exit
      end

      container = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(container_name.strip)}/i }
      container ||= GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(container_name).sub(' ', ' .*')}/i }

      if container.nil?
        Lich::Messaging.msg("error", "Failed to find container: #{container_name}")
        exit
      end

      if container.contents.nil?
        dothistimeout "open ##{container.id}", 10, /You open|already open/

        if container.contents.nil?
          dothistimeout "look in ##{container.id}", 10, /In the .* you see/

          if container.contents.nil?
            Lich::Messaging.msg("warn", "Failed to find contents of container: #{container_name}")
            sleep 1
          end
        end
      end

      container.contents
    end

    # Stow an item in a container
    #
    # @param item [String] Name of item to stow
    # @param container [String] Name of container to stow in
    # @param timeout [Integer] Timeout in seconds (default: 5)
    # @return [void]
    # @raise [SystemExit] If container is full or stow fails
    def self.stow_item(item, container, _timeout = 5)
      return if item.nil? || item.empty?

      check = dothistimeout "put my #{item} in my #{container}", 3, /You put|won't fit/

      if check =~ /won't fit/
        Lich::Messaging.msg("error", "Container full")
        exit
      elsif check.nil?
        Lich::Messaging.msg("error", "Failed to stow item (timeout)")
        exit
      end
    end
  end

  #============================================================================
  # Game action wrappers and helper methods
  #
  # Provides wrappers for common in-game actions like casting haste,
  # retrieving tools, and monitoring player interaction.
  #============================================================================
  module GameActions
    # Cast Haste (535) if known, not active, and affordable
    #
    # Automatically speeds up fletching actions when the Haste spell is available.
    # Checks three conditions before casting:
    # - Spell is known (character has learned it)
    # - Spell is not already active
    # - Character has enough mana to cast
    #
    # @return [void]
    # @note Waits for cast roundtime before returning
    # @see Spell
    def self.haste!
      waitcastrt?
      waitrt?
      fput "incant 535" if Spell[535].known? && !Spell[535].active? && Spell[535].affordable?
    end

    # Retrieve the configured knife/dagger
    #
    # @param settings [Hash] Settings containing knife name
    # @return [void]
    # @raise [SystemExit] If knife cannot be retrieved
    def self.get_knife(settings)
      check = dothistimeout "get my #{settings[:knife]}", 3, /You remove|get what?/

      if check =~ /get what?/
        Lich::Messaging.msg("error", "Failed to get knife")
        exit
      elsif check.nil?
        endtime = Time.now + 5
        loop do
          break if checkleft =~ /#{settings[:knife]}/

          if Time.now > endtime
            Lich::Messaging.msg("error", "Failed to get knife (timeout)")
            exit
          end

          sleep 0.5
        end
      end
    end

    # Monitor game output for player interaction attempts
    #
    # Creates a background script that watches for GM checks,
    # other players trying to interact, or policy warnings.
    # Shows a GTK popup window when interaction is detected.
    #
    # @param settings [Hash] Settings containing monitor_interaction flag
    # @return [void]
    def self.monitor_interaction(settings)
      return unless settings[:monitor_interaction]

      start_exec_script(<<-EOS
      def show_window(line)
        window_title = Char.name + ':' + line
        Gtk.queue {
          $myWindow = Gtk::Window.new
          $myWindow.title = "Autobot Alert!"
          $myWindow.set_size_request(450, 25)
          label = Gtk::Label.new window_title
          $myWindow.add(label)
          $myWindow.show_all
        }
      end

      while(line = get)
        break unless running?('FletchIt')
      #{'  '}
        if line =~ /SEND|POLICY|[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]|peaking to you|unresponsive|taps you|nods to you|lease respond|not in control|character|violation|lease speak|peak out loud|Y U SHOU D|whispers,|speaking to you|smiles at you|waves to you|grins at you|hugs you|takes hold your hand|grabs your hand|clasps your hand|trying to drag you/
          unless line =~ /LNet/
            show_window(line)
            Lich::Messaging.msg("warn", "AUTOBOT ALERT: " + line)
          end
        end
      end
    EOS
                       )
    end
  end

  #============================================================================
  # Supply checking and automated shopping
  #
  # Handles checking for needed supplies, navigating to shops,
  # and purchasing items automatically when enabled.
  #============================================================================
  module Shopping
    # Check which supplies are needed based on container contents
    #
    # Analyzes the supplies container and determines what items are missing
    # or need to be restocked. Checks for wood/shafts, paint, glue, fletchings,
    # and paintsticks based on configuration.
    #
    # @param settings [Hash] Settings containing material preferences
    # @param fletch_sack_contents [Array<GameObj>] Current items in supplies container
    # @param paints [Hash] Paint color mapping
    # @return [Array<String>] List of items that need to be purchased
    # @example
    #   contents = FletchIt::Inventory.get_container_contents("backpack")
    #   needed = FletchIt::Shopping.check_needed_items(settings, contents, paints)
    #   respond "Need to buy: #{needed.join(', ')}" if needed.any?
    # @note Returns empty array if fletch_sack_contents is nil
    def self.check_needed_items(settings, fletch_sack_contents, paints)
      return [] if fletch_sack_contents.nil?

      needs = {
        wood: true,
        paint: true,
        glue: true,
        fletchings: true,
        paintstick1: true,
        paintstick2: true
      }

      # Check what we have
      fletch_sack_contents.each do |item|
        needs[:wood] = false if item.name =~ /shaft/ || item.name =~ /#{settings[:wood]}/
        needs[:paint] = false if item.name =~ /#{paints[settings[:paint]]}/
        needs[:fletchings] = false if item.name =~ /#{settings[:fletchings]}/
        needs[:glue] = false if item.name =~ /bottle of fletching glue/
        needs[:paintstick1] = false if settings[:paintstick1].length > 0 && item.name =~ /#{settings[:paintstick1]}/
        needs[:paintstick2] = false if settings[:paintstick2].length > 0 && item.name =~ /#{settings[:paintstick2]}/
      end

      needed_items = []
      needed_items << settings[:wood] if needs[:wood]
      needed_items << "bottle of fletching glue" if needs[:glue]
      needed_items << settings[:fletchings] if needs[:fletchings]
      needed_items << "vial of paint" if needs[:paint] && settings[:paint] != 0
      needed_items << settings[:paintstick1] if needs[:paintstick1] && settings[:paintstick1].length > 0
      needed_items << settings[:paintstick2] if needs[:paintstick2] && settings[:paintstick2].length > 0

      needed_items
    end

    # Find the order number for a supply item in the shop menu
    #
    # Unhides character, displays shop ORDER menu, parses the output to build
    # a hash of available items and their order numbers, then searches for the
    # requested supply item.
    #
    # @param supply [String] Name of the supply to order (without leading articles)
    # @return [String] Order number for the item
    # @raise [SystemExit] If item not found in shop menu
    # @example
    #   order_num = FletchIt::Shopping.find_order_number("limb of wood")
    #   fput "order #{order_num}"
    # @note Item name should not include "a", "an", or "some" at the start
    def self.find_order_number(supply)
      status_tags
      clear
      waitrt?
      fput 'unhide' if hidden? || invisible?
      fput 'order'

      menu = {}
      while (line = get) && (line !~ /ORDER|BUY/)
        line.scan(/<d.*?cmd=["']order ([0-9]+).*?>(.*?)<\/d>/) do |item|
          menu[item[1].sub(/^a /, '')] = item[0]
        end
      end

      clear
      status_tags

      item_name = menu.keys.find { |name| name =~ /#{supply}/i }
      order_number = menu[item_name]

      unless order_number
        Lich::Messaging.msg("error", "")
        Lich::Messaging.msg("error", "Failed to find item '#{supply}' in shop menu")
        Lich::Messaging.msg("error", "Remember to leave off a/an/some at the start")
        Lich::Messaging.msg("error", "")
        exit
      end

      order_number
    end

    # Purchase needed supplies from the shop
    #
    # Complete shopping workflow:
    # 1. Check silver on hand
    # 2. Go to bank and withdraw if under 5000 silver
    # 3. Navigate to fletcher shop
    # 4. Empty hands
    # 5. Order and buy each item in needed_items
    # 6. Stow each item as purchased
    # 7. Return to starting location
    # 8. Deposit remaining silver
    #
    # @param settings [Hash] Settings containing shop configuration and container names
    # @param needed_items [Array<String>] Items to purchase
    # @return [Integer] Amount of silver spent on purchases
    # @raise [SystemExit] If withdrawal fails, items can't be bought, or container is full
    # @note Requires mapped room and go2 script functionality
    # @see check_needed_items
    # @see find_order_number
    def self.buy_items(settings, needed_items)
      invis = invisible?
      start_room = Room.current.id

      # Ensure we have enough silver
      silver = Inventory.check_silver
      if silver < 5000
        withdraw_amount = 5000 - silver
        Script.run("go2", 'bank')
        waitrt?
        fput "unhide" if hidden? || invisible?
        fput "withdraw #{withdraw_amount}"

        if Inventory.check_silver < 5000
          Lich::Messaging.msg("error", "Failed to withdraw silver from bank")
          exit
        end
      end

      # Go to fletcher shop
      Script.run("go2", 'fletcher')
      move "south" if Room.current.location == "Ta'Vaalor"

      # Empty hands
      empty_left_hand if checkleft
      empty_right_hand if checkright

      # Buy each item
      needed_items.each do |item|
        if item =~ /vial of paint/
          order_number = find_order_number(item)
          multifput "order #{order_number} color #{settings[:paint]}", "buy"
        else
          order_number = find_order_number(item)
          multifput "order #{order_number}", "buy"
        end

        # Wait for item to appear
        endtime = Time.now + 3
        loop do
          break if checkright

          if Time.now > endtime
            Lich::Messaging.msg("error", "Failed to buy item (timeout)")
            exit
          end

          sleep 0.5
        end

        # Stow the item
        stow_check = dothistimeout "put my #{checkright} in my #{settings[:sack]}", 3, /won't fit|You put/

        if stow_check =~ /won't fit/
          Lich::Messaging.msg("error", "Container full")
          exit
        elsif stow_check.nil?
          Lich::Messaging.msg("error", "Failed to stow item")
          exit
        end
      end

      spent = 5000 - Inventory.check_silver

      # Return to starting location
      Script.run("go2", start_room)
      fput "unhide" if hidden? || invisible?
      fput "depo all"

      fput "incant 916" if invis && Spell[916].affordable?

      spent
    end
  end

  #============================================================================
  # All fletching crafting operations
  #
  # Handles the complete arrow/bolt creation process:
  # - Stowing and retrieving items
  # - Cutting shafts from wood
  # - Painting shafts
  # - Applying crests (paintsticks)
  # - Cutting nocks
  # - Gluing and attaching fletchings
  # - Testing with bow/crossbow
  #============================================================================
  module Crafting
    # Stow an item from left or right hand
    #
    # Checks which hand contains an item and stows it in the specified container.
    # Returns silently if the hand is already empty. Exits script if container
    # is full or stowing fails.
    #
    # @param hand [String] "left" or "right" - which hand to stow from
    # @param container [String] Container name (e.g., "backpack", "sack")
    # @return [void]
    # @raise [SystemExit] If container is full or stow fails
    # @example
    #   FletchIt::Crafting.stow("right", "backpack")
    # @note Uses checkright/checkleft to verify hand state
    def self.stow(hand, container)
      return if hand == "right" && checkright.nil?
      return if hand == "left" && checkleft.nil?

      item = hand == "right" ? checkright : checkleft
      check = dothistimeout "put my #{item} in my #{container}", 3, /You put|won't fit/

      if check =~ /won't fit/
        Lich::Messaging.msg("error", "Container full")
        exit
      elsif check.nil?
        Lich::Messaging.msg("error", "Failed to stow item")
        exit
      end
    end

    # Retrieve wood or log from supplies container
    #
    # @param settings [Hash] Settings containing wood type and container name
    # @return [void]
    # @raise [SystemExit] If wood cannot be retrieved
    def self.get_wood(settings)
      wood_type = settings[:wood] =~ /log/ ? 'log' : 'wood'
      check = dothistimeout "get my #{wood_type} in my #{settings[:sack]}", 1, /You remove|Get what?/

      if check =~ /Get what?/
        Lich::Messaging.msg("error", "Run out of wood/logs, this shouldn't be happening.")
        exit
      elsif check.nil?
        # Backup for scripted containers
        endtime = Time.now + 5
        loop do
          break if checkright =~ /#{wood_type}/

          if Time.now > endtime
            Lich::Messaging.msg("error", "Could not get #{wood_type}, stopping")
            exit
          end

          sleep 0.5
        end
      end
    end

    # Retrieve axe from inventory
    #
    # @param settings [Hash] Settings containing axe name
    # @return [void]
    # @raise [SystemExit] If axe cannot be retrieved
    def self.get_axe(settings)
      check = dothistimeout "get my #{settings[:axe]}", 3, /You remove|get what?/

      if check =~ /get what?/
        Lich::Messaging.msg("error", "Could not get your axe to cut the shafts")
        exit
      elsif check.nil?
        # Backup for scripted containers
        endtime = Time.now + 5
        loop do
          break if checkleft =~ /#{settings[:axe]}/

          if Time.now > endtime
            Lich::Messaging.msg("error", "Could not get your axe to cut the shafts")
            exit
          end

          sleep 0.5
        end
      end
    end

    # Cut a shaft from wood or log
    #
    # Determines the correct command based on ammo type (arrow, light bolt, heavy bolt)
    # and executes the cut command.
    #
    # @param settings [Hash] Settings containing ammo type and wood type
    # @return [void]
    # @raise [SystemExit] If cut fails or invalid ammo type
    def self.cut_shaft_from_wood(settings)
      wood_type = settings[:wood] =~ /log/ ? 'log' : 'wood'

      case settings[:ammo]
      when 1
        command = "cut arrow shaft my #{wood_type}"
      when 2
        command = "cut light bolt my #{wood_type}"
      when 3
        command = "cut heavy bolt my #{wood_type}"
      else
        Lich::Messaging.msg("error", "Invalid ammo type")
        exit
      end

      waitrt?
      GameActions.haste!
      fput command

      endtime = Time.now + 10
      loop do
        break if checkright =~ /shaft/

        if Time.now > endtime
          Lich::Messaging.msg("error", "Failed to cut shafts.")
          exit
        end

        sleep 0.5
      end
    end

    # Orchestrate the complete shaft-making process
    #
    # Executes the full workflow for creating arrow/bolt shafts:
    # 1. Gets wood or log from supplies container
    # 2. Gets axe from inventory
    # 3. Cuts shaft from wood using appropriate command
    # 4. Stows shaft and axe back into supplies container
    #
    # @param settings [Hash] Settings containing tool and container names
    # @return [void]
    # @see get_wood
    # @see get_axe
    # @see cut_shaft_from_wood
    def self.make_shafts(settings)
      get_wood(settings)
      get_axe(settings)
      cut_shaft_from_wood(settings)

      waitrt?
      stow("right", settings[:sack])
      stow("left", settings[:sack])
    end

    # Apply paint to a shaft
    #
    # Gets paint from container, applies it to shaft, waits for it to dry.
    # Returns early if no paint is configured or if paint cannot be found.
    # Paint drying can take up to 120 seconds.
    #
    # @param settings [Hash] Settings containing paint configuration (settings[:paint])
    # @param paints [Hash] Paint color mapping (Config::PAINTS)
    # @return [Symbol] :success, :no_paint, or :failed
    # @note Waits up to 120 seconds for paint to dry
    # @note Multiple paint colors in sack can cause detection issues
    # @see Config::PAINTS
    def self.apply_paint(settings, paints)
      return :success if settings[:paint] == 0

      stow("left", settings[:sack])
      paint = paints[settings[:paint]].split(" ")
      waitrt?
      fput "get my #{paint[0]} paint"

      endtime = Time.now + 6
      loop do
        break if checkleft =~ /paint/

        if Time.now > endtime
          Lich::Messaging.msg("error", "Run out of paint, probably means you have another colour paint on you messing with my check.")
          Lich::Messaging.msg("error", "Get it out of your fletchsack")
          return :no_paint
        elsif Time.now > (endtime - 3)
          waitrt?
          fput "get my #{paint[0]} paint"
        end

        sleep 0.5
      end

      waitrt?
      GameActions.haste!
      check = dothistimeout "paint my shaft", 3, /You carefully smear a bit of paint/

      if check.nil?
        # Double check by looking at the arrow
        check = dothistimeout "look my shaft", 3, /has been pared down and smoothed.$|paint covers the shaft./
        if check !~ /paint covers the shaft./
          Lich::Messaging.msg("error", "Could not determine if painting was successful, stopping")
          return :failed
        end
      end

      # Wait for paint to dry (increased from 40 to 120 seconds)
      check = matchtimeout 120, "The paint on your"
      unless check
        Lich::Messaging.msg("warn", "Did not see paint dry, but carrying on...")
      end

      waitrt?
      stow("left", settings[:sack])
      :success
    end

    # Apply a paintstick crest to a shaft
    #
    # Gets paintstick from container, applies it to shaft, waits for it to dry.
    # Returns early if no paintstick is configured or if paintstick cannot be found.
    #
    # @param settings [Hash] Settings containing paintstick configuration
    # @param paintstick_setting [Symbol] :paintstick1 or :paintstick2
    # @return [Symbol] :success, :no_paintstick, or :failed
    def self.apply_paintstick(settings, paintstick_setting)
      return :success if settings[paintstick_setting].length == 0

      stow("left", settings[:sack])
      waitrt?
      fput "get my #{settings[paintstick_setting]}"

      endtime = Time.now + 6
      loop do
        break if checkleft =~ /paintstick/

        if Time.now > endtime
          Lich::Messaging.msg("error", "Could not get your paintstick")
          return :no_paintstick
        elsif Time.now > (endtime - 3)
          waitrt?
          fput "get my #{settings[paintstick_setting]}"
        end

        sleep 0.5
      end

      waitrt?
      GameActions.haste!
      check = dothistimeout "paint my shaft", 3, /You carefully apply a band of/

      if check.nil?
        # Double check by looking at the arrow
        check = dothistimeout "look my shaft", 3, /It looks like someone has painted a (single|pair of)/
        if check !~ /It looks like someone has painted a (single|pair of)/
          Lich::Messaging.msg("error", "Could not determine if paintsticking was successful, stopping")
          return :failed
        end
      end

      # Wait for paint to dry (increased from 40 to 120 seconds)
      check = matchtimeout 120, "The paint on your"
      unless check
        Lich::Messaging.msg("warn", "Did not see paint dry, but carrying on...")
      end

      waitrt?
      stow("left", settings[:sack])
      :success
    end

    # Cut a nock in the shaft (arrows only)
    #
    # For arrows without paint/crest, cuts nock twice for proper depth.
    # For painted/crested arrows, cuts nock once (shaft already shortened).
    # Returns false if shaft is ruined during process.
    #
    # @param settings [Hash] Settings containing ammo type and knife name
    # @return [Symbol] :success, :failed, or :not_arrow
    # @note Only executes for arrows (settings[:ammo] == 1)
    # @note Waits for roundtime between cuts
    # @see GameActions.haste!
    def self.cut_nock(settings)
      return :not_arrow unless settings[:ammo] == 1 # Only for arrows

      waitrt?

      # Get knife if we just did painting (it will be stowed)
      if settings[:paint] != 0 || settings[:paintstick1].length != 0 || settings[:paintstick2].length != 0
        GameActions.get_knife(settings)
        waitrt?
      end

      waitrt?
      GameActions.haste!
      waitrt?
      fput "cut nock in my shaft with my #{settings[:knife]}"
      pause 0.25
      waitrt?

      # If no paint/paintsticks were used, cut twice
      if settings[:paint] == 0 && settings[:paintstick1].length == 0 && settings[:paintstick2].length == 0
        GameActions.haste!
        waitrt?
        fput "cut nock in my shaft with my #{settings[:knife]}"
        pause 0.25
        waitrt?
      end

      # Check if shaft is still there
      if checkright !~ /shaft/
        waitrt?
        stow("left", settings[:sack])
        return :failed
      end

      stow("left", settings[:sack])
      :success
    end

    # Finalize arrow by adding glue, fletchings, and testing with bow
    #
    # For learning mode, simply drops the shaft and cleans the table.
    # Otherwise, completes the arrow:
    # 1. Gets glue bottle from container
    # 2. Pours glue on shaft
    # 3. Gets fletchings from container
    # 4. Attaches fletchings to shaft
    # 5. Waits up to 120 seconds for glue to dry
    # 6. Tests arrow by stringing on bow/crossbow (if configured)
    # 7. Stows completed arrow in quiver
    #
    # @param settings [Hash] Settings containing bow, container, and fletching configuration
    # @return [Symbol] :completed or :no_supplies
    # @note Glue drying can take up to 120 seconds
    # @see make_arrow
    def self.finalize_arrow(settings)
      # For learning mode
      if settings[:learning]
        waitrt?
        fput "drop right"
        fput "clean table"
        return :completed
      end

      waitrt?

      # Make sure there's a shaft in hand
      stow("right", settings[:sack]) unless checkright =~ /shaft/

      # Get glue
      fput "get my glue"
      endtime = Time.now + 6
      loop do
        break if checkleft =~ /glue|bottle/

        if Time.now > endtime
          Lich::Messaging.msg("error", "Run out of glue, stopping")
          return :no_supplies
        elsif Time.now > (endtime - 3)
          waitrt?
          fput "get my glue"
        end

        sleep 0.5
      end

      waitrt?
      GameActions.haste!
      dothistimeout "pour my bottle on my shaft", 3, /You carefully pour/
      stow("left", settings[:sack])

      # Get fletchings
      waitrt?
      fput "get my #{settings[:fletchings]}"
      endtime = Time.now + 6
      loop do
        break if checkleft =~ /fletching/

        if Time.now > endtime
          Lich::Messaging.msg("error", "Run out of fletchings, stopping")
          return :no_supplies
        elsif Time.now > (endtime - 3)
          waitrt?
          fput "get my #{settings[:fletchings]}"
        end

        sleep 0.5
      end

      waitrt?
      GameActions.haste!
      dothistimeout "attach my fletching to my shaft", 3, /You carefully attach/

      # Wait for glue to dry (increased from 30 to 120 seconds)
      check = matchtimeout 120, "The glue on your"
      unless check
        Lich::Messaging.msg("warn", "Did not see glue dry, but carrying on...")
      end

      waitrt?
      stow("left", settings[:sack])

      # Test with bow
      unless settings[:bow].nil? || settings[:bow].empty?
        waitrt?
        GameActions.haste!
        dothistimeout "string my #{settings[:bow]} with my shaft", 3, /You carefully string/
      end

      waitrt?
      stow("right", settings[:quiver])

      :completed
    end

    # Create a complete arrow from start to finish
    #
    # Orchestrates the entire arrow creation process:
    # 1. Get shaft from container
    # 2. Apply paint (if configured)
    # 3. Apply paintstick crests (if configured)
    # 4. Cut nock (for arrows)
    # 5. Finalize with glue and fletchings
    #
    # @param settings [Hash] All fletching settings
    # @param paints [Hash] Paint color mapping
    # @return [Symbol] :completed, :failed, :no_shafts, or :no_supplies
    #   - :completed - Arrow/bolt successfully created and stowed
    #   - :failed - Shaft was ruined during cutting/nocking
    #   - :no_shafts - No shafts available in container
    #   - :no_supplies - Ran out of glue or fletchings during finalization
    def self.make_arrow(settings, paints)
      # Get shaft
      waitrt?
      check = dothistimeout "get 1 my shaft", 3, /You remove|get what?/

      if check =~ /get what?/
        # No shafts available - return to main loop to make more
        return :no_shafts
      elsif check.nil?
        # Backup for scripted containers
        endtime = Time.now + 5
        loop do
          break if checkright =~ /shaft/

          if Time.now > endtime
            # Still no shaft after timeout - return to make more
            return :no_shafts
          end

          sleep 0.5
        end
      end

      waitrt?
      GameActions.get_knife(settings)

      # Cut shaft
      waitrt?
      GameActions.haste!
      fput "cut my shaft with my #{settings[:knife]}"
      pause 0.25
      waitrt?

      # If shaft is gone, it failed - stow knife and return
      if checkright !~ /shaft/
        stow("left", settings[:sack])
        return :failed
      end

      # Apply paint and decorations
      waitrt?
      paint_result = apply_paint(settings, paints)
      return :failed if paint_result == :failed
      return :no_supplies if paint_result == :no_paint

      waitrt?
      paintstick1_result = apply_paintstick(settings, :paintstick1)
      return :failed if paintstick1_result == :failed
      return :no_supplies if paintstick1_result == :no_paintstick

      waitrt?
      paintstick2_result = apply_paintstick(settings, :paintstick2)
      return :failed if paintstick2_result == :failed
      return :no_supplies if paintstick2_result == :no_paintstick

      # Cut nock (for arrows only)
      waitrt?
      nock_result = cut_nock(settings)
      return :failed if nock_result == :failed

      # Finalize arrow
      waitrt?
      result = finalize_arrow(settings)
      return :no_supplies if result == :no_supplies

      :completed
    end
  end

  #============================================================================
  # Arrow and bolt bundling operations
  #
  # Provides intelligent bundling that combines partial bundles of the same
  # type into full 100-arrow/bolt bundles. Handles splitting when combining
  # would exceed 100 count.
  #============================================================================
  module Bundle
    # Bundle all arrows/bolts in quiver
    #
    # Finds all bundles in the configured quiver, analyzes their counts and
    # descriptions, then combines partial bundles of the same type into full
    # 100-count bundles. Handles edge cases like splitting oversized combinations.
    #
    # The bundling algorithm:
    # 1. Identifies all bundles in quiver
    # 2. Counts arrows/bolts in each bundle
    # 3. Groups by description (paint, crests, etc.)
    # 4. Combines partial bundles of same type
    # 5. Splits combinations that would exceed 100
    #
    # @param settings [Hash] Settings containing quiver configuration
    # @return [void]
    # @raise [SystemExit] If quiver not found or bundle info cannot be retrieved
    def self.bundle_arrows(settings)
      bundle_ids = []
      bundle_amount = []
      bundle_desc = []

      quiver = GameObj.inv.find { |obj| obj.name =~ /#{settings[:quiver]}/ }

      unless quiver
        Lich::Messaging.msg("error", "Could not find quiver: #{settings[:quiver]}")
        exit
      end

      if quiver.contents.nil?
        waitrt?
        dothistimeout "open ##{quiver.id}", 10, /You open|already open/

        if quiver.contents.nil?
          waitrt?
          dothistimeout "look in ##{quiver.id}", 10, /In the .* you see/

          if quiver.contents.nil?
            Lich::Messaging.msg("warn", "Failed to find the contents of your quiver")
            exit
          end
        end
      end

      # Collect bundle information
      quiver.contents.each do |item|
        if item.name =~ /bundle/
          bundle_ids << item.id
        end
      end

      return if bundle_ids.empty?

      # Set up hook to collect bundle details
      bundle_check = proc { |server_string|
        if server_string =~ /You count out (\d+) arrows in your .* bundle and note that/
          bundle_amount << $1
          nil
        elsif server_string =~ /You count out (\d+) bolts in your .* bundle and note that/
          bundle_amount << $1
          nil
        elsif server_string =~ /Each individual projectile appears to be (.+?) of fine quality.$/
          bundle_desc << $1
          nil
        elsif server_string =~ /Each individual projectile will be "(.+?)".$/
          nil
        elsif server_string =~ /<prompt time="\d+">&gt;<\/prompt>/
          nil
        else
          server_string.length > 2 ? server_string : nil
        end
      }

      DownstreamHook.add('fletch_bundle_check', bundle_check)
      silence_me

      bundle_ids.each { |id| fput "look ##{id}" }

      silence_me
      endtime = Time.now + 6
      wait_until { (bundle_ids.length == bundle_desc.length) || Time.now > endtime }
      DownstreamHook.remove('fletch_bundle_check')

      if bundle_ids.length != bundle_desc.length
        Lich::Messaging.msg("error", "Failed to get bundle info, stopping")
        exit
      end

      # Build bundle data structure
      bundles = []
      bundle_ids.each_with_index do |id, idx|
        bundles << {
          "id"    => id,
          "count" => bundle_amount[idx].to_i,
          "desc"  => bundle_desc[idx]
        }
      end

      # Combine bundles by description
      uniq_bundle_desc = bundle_desc.uniq

      uniq_bundle_desc.each do |desc|
        total = 0
        last_bundle = ""

        bundles.each do |bundle|
          next unless bundle['desc'] == desc && bundle['count'] != 100

          if total == 0
            # First bundle of this type
            total = bundle['count']
            last_bundle = bundle['id'].dup
          elsif total > 0
            # Found another bundle of same type
            total += bundle['count']

            if total <= 100
              # Can combine completely
              waitrt?
              fput "get ##{bundle['id']}"
              matchtimeout 1, "You remove"
              fput "get ##{last_bundle}" if checkleft.nil?
              fput "bundle"

              if total == 100
                FletchIt::Crafting.stow("right", settings[:quiver])
                total = 0
              else
                last_bundle = bundle['id']
              end
            else
              # Need to split
              amount_over = total - 100
              amount_to_get = bundle['count'] - amount_over

              waitrt?
              fput "get #{amount_to_get} ##{bundle['id']}"
              matchtimeout 1, "You remove"
              fput "get ##{last_bundle}" if checkleft.nil?
              fput "bundle"
              FletchIt::Crafting.stow("right", settings[:quiver])

              # Update bundle count and re-add
              bundle['count'] -= amount_to_get
              bundles << bundle
              total = 0
            end
          end
        end

        # Stow any remaining partial bundle
        waitrt?
        FletchIt::Crafting.stow("right", settings[:quiver]) if checkright
      end
    end
  end
end

settings = FletchIt::Config.load_settings
paints = FletchIt::Config::PAINTS
ammo_types = FletchIt::Config::AMMO_TYPES

# Ripped setup from sloot, no clue waht is going on here but it works!
setup = proc {
  gtk_global = Hash.new
  window = window_action = nil
  Gtk.queue {
    #   ttips = Gtk::Tooltips.new.enable
    ttips_text = {
      :sack            => 'This is the container all your supplies, axe and dagger will be in',
      :quiver          => 'This is the container you want your finshed arrows to be stored in, it can be the same as the container above if you wish',
      :axe             => 'This is the axe you will use for creating the shafts, needs to be what ever you would type following the get comand to remove it from your container.',
      :knife           => 'This is the knife or dagger you will be using to cut the shafts, needs to be what ever you would type following the get comand to remove it from your container.',
      :bow             => 'This is the bow you will be using to measure the shaft, MUST BE WORN!',
      :enable_painting => 'Check this if you would like to paint your arrows',
      :enable_buying   => 'Check this if you would like the script to go buy wood, glue and fletchings from the shop',
      :wood            => 'The name of the wood you would like to buy, leaving off a/an/some at the start. Eg. "limb of faewood" or "branch of kakore"',
      :paint           => 'The name of the paint you would like to buy, leaving off a/an/some at the start',
      :paintstick1     => 'Leave blank if you do not want to use a paintstick to crest your arrows. If you want to crest you arrows please enter the colour of the paintstick.',
      :paintstick2     => 'Leave blank if you do not want to use a paintstick to crest your arrows a second time. If you want to crest you arrows a second time please enter the colour of the paintstick.',
      :fletchings      => 'The name of the fletchings you would like to buy, leaving off a/an/some at the start.',
      :limit           => 'This is the number of arrows you would like the script to make, leave blank for no limit. It will just keep making more till you tell it to stop, run out of space or run out of money.',
      :learning        => 'Enable learning mode, will drop shafts and clean table so works best at a table.',
      :mind            => 'When learning, script will wait when your mind is above this percentage.',
      :alerts          => 'Monitors interactions and pops up an alert.',
      :ammo            => 'Type of ammunition you want to make. Please select one'
      # :drill           => 'The noun of your drill which should be in your supplies container.',
      # :tip             => 'The noun of the tips you wish to use which should be in your supplies container.',
    }

    gtk_global[:sack]           = Gtk::Entry.new; gtk_global[:sack].text = (settings[:sack])
    gtk_global[:quiver]         = Gtk::Entry.new; gtk_global[:quiver].text = (settings[:quiver])
    gtk_global[:axe]            = Gtk::Entry.new; gtk_global[:axe].text = (settings[:axe])
    gtk_global[:knife]          = Gtk::Entry.new; gtk_global[:knife].text = (settings[:knife])
    gtk_global[:bow]            = Gtk::Entry.new; gtk_global[:bow].text = (settings[:bow])
    gtk_global[:wood]           = Gtk::Entry.new; gtk_global[:wood].text = (settings[:wood])
    gtk_global[:ammo]           = Gtk::ComboBoxText.new()
    gtk_global[:paint]          = Gtk::ComboBoxText.new()
    gtk_global[:paintstick1]    = Gtk::Entry.new; gtk_global[:paintstick1].text = (settings[:paintstick1])
    gtk_global[:paintstick2]    = Gtk::Entry.new; gtk_global[:paintstick2].text = (settings[:paintstick2])
    gtk_global[:fletchings]     = Gtk::Entry.new; gtk_global[:fletchings].text = (settings[:fletchings])
    gtk_global[:limit]          = Gtk::Entry.new; gtk_global[:limit].text = (settings[:limit].to_s)
    gtk_global[:waggle]         = Gtk::CheckButton.new; gtk_global[:waggle].active = (settings[:waggle])
    gtk_global[:enable_buying]  = Gtk::CheckButton.new; gtk_global[:enable_buying].active = (settings[:enable_buying])
    gtk_global[:learning]       = Gtk::CheckButton.new; gtk_global[:learning].active = (settings[:learning])
    gtk_global[:alerts]         = Gtk::CheckButton.new; gtk_global[:alerts].active = (settings[:alerts])
    gtk_global[:mind]           = Gtk::Entry.new; gtk_global[:mind].text = (settings[:mind])
    #   gtk_global[:drill] = Gtk::Entry.new; gtk_global[:drill].text = (settings[:drill])
    #   gtk_global[:tip] = Gtk::Entry.new.set_tip(settings[:tip])

    # use paints array to form combo box
    paints.each_value { |paint|
      gtk_global[:paint].append_text(paint)
    }

    # use ammo_types array to form combo box
    ammo_types.each_value { |ammo| gtk_global[:ammo].append_text(ammo) }

    gtk_global[:paint].active = (settings[:paint]) # have to set active after appending
    gtk_global[:ammo].active = (settings[:ammo]) # have to set active after appending

    ttips_text.each do |key, tip|
      widget = gtk_global[key]
      next unless widget
      widget.set_tooltip_text(tip)
      widget.has_tooltip = true if widget.respond_to?(:has_tooltip=)
    end

    window = Gtk::Window.new
    window.title = "FletchIt"
    window.border_width = 3
    window.resizable = true
    # window.resize(10, 10)

    settings_page = Gtk::Box.new(:vertical, 1).set_border_width(3)
    vb_pg1_1 = Gtk::Box.new(:vertical, 1).set_border_width(3)
    fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Settings</b></big>'))
    fr_pg1_1.add(vb_pg1_1)
    settings_page.pack_start(fr_pg1_1, :expand => false, :fill => false, :padding => 0)

    # random note to self width will be ignored if text is longer
    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Supplies Container: ')).set_width_request(120))
    hb.pack_start(gtk_global[:sack], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Finished Container: ')).set_width_request(120))
    hb.pack_start(gtk_global[:quiver], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Bow: ')).set_width_request(120))
    hb.pack_start(gtk_global[:bow], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Ammo: ')).set_width_request(120))
    hb.pack_start(gtk_global[:ammo].set_width_request(158), :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Axe: ')).set_width_request(120))
    hb.pack_start(gtk_global[:axe], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Knife: ')).set_width_request(120))
    hb.pack_start(gtk_global[:knife], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    #   hb = Gtk::Box.new(:horizontal, 1)
    #   hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Drill: ')).set_width_request(120))
    #   hb.pack_start(gtk_global[:drill], :expand => false, :fill => false, :padding => 0)
    #   vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Buy Items: ')).set_width_request(120))
    hb.pack_start(gtk_global[:enable_buying], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Wood: ')).set_width_request(120))
    hb.pack_start(gtk_global[:wood], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Paint: ')).set_width_request(120))
    hb.pack_start(gtk_global[:paint].set_width_request(158), :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Paintstick 1: ')).set_width_request(120))
    hb.pack_start(gtk_global[:paintstick1], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Paintstick 2: ')).set_width_request(120))
    hb.pack_start(gtk_global[:paintstick2], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Fletchings: ')).set_width_request(120))
    hb.pack_start(gtk_global[:fletchings], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    #   hb = Gtk::Box.new(:horizontal, 1)
    #   hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Tip Ammo: ')).set_width_request(120))
    #   hb.pack_start(gtk_global[:tip], :expand => false, :fill => false, :padding => 0)
    #   vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Make limit: ')).set_width_request(120))
    hb.pack_start(gtk_global[:limit], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Learn Fletching: ')).set_width_request(120))
    hb.pack_start(gtk_global[:learning], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Mind: ')).set_width_request(120))
    hb.pack_start(gtk_global[:mind], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Monitor Interactions: ')).set_width_request(120))
    hb.pack_start(gtk_global[:alerts], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Use waggle: ')).set_width_request(120))
    hb.pack_start(gtk_global[:waggle], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    lbl = Gtk::Label.new.set_markup("Mouse over each box for more help")
    lbl.set_wrap(true).set_padding(0, 10)
    vb_pg1_1.pack_start(lbl, :expand => false, :fill => false, :padding => 0)

    hb_saveclose = Gtk::Box.new(:horizontal, 1)
    save = Gtk::Button.new(:label => '_Save & Close')
    close = Gtk::Button.new(:label => 'E_xit')
    save.signal_connect('clicked') { window_action = :save }
    close.signal_connect('clicked') { window_action = :done }
    hb_saveclose.pack_start(save, :expand => false, :fill => false, :padding => 0)
    hb_saveclose.pack_start(close, :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb_saveclose, :expand => false, :fill => false, :padding => 0)

    window.signal_connect('delete_event') { window_action = :exit }

    window.add(settings_page)

    window.show_all
    window.keep_above = true
  }

  before_dying {
    Gtk.queue { window.destroy }
    Settings.save
  }
  wait_while { window_action.nil? }
  undo_before_dying
  Gtk.queue { window.destroy }

  if window_action == :save
    gtk_global.each_pair { |option, widget|
      if widget.class == Gtk::CheckButton
        settings[option] = widget.active?
      elsif widget.class == Gtk::Entry
        settings[option] = widget.text.strip.downcase
      elsif widget.class == Gtk::ComboBoxText
        settings[option] = widget.active
      else
        Lich::Messaging.msg("error", "unknown local widget #{option} [#{widget.class}]")
      end
    }

    # attempt some error checking
    warning = []
    if settings[:sack] == ""
      warning << "The container for you supplies has not yet been set, the script will not run untill this is added.\r\n"
    end
    if settings[:quiver] == ""
      warning << "The container for you finished arrows has not yet been set, the script will not run untill this is added.\r\n"
    end
    if settings[:knife] == ""
      warning << "Have not set a knife/dagger to cut the shafts with, the script will not run untill this is added.\r\n"
    end
    if settings[:bow] == ""
      warning << "Have not set a bow to measure the shafts with, the script will not run untill this is added.\r\n"
    end
    if settings[:axe] == ""
      warning << "Have not set an axe to make shafts with, the script will not run untill this is added.\r\n"
    end
    if settings[:wood] == ""
      warning << "Have not set a what wood you want to use, the script will not run untill this is added.\r\n"
    end
    if settings[:wood] != "" and settings[:wood] !~ /wood|log|branch|limb/
      warning << "You have set what wood you want to use but appears you may have done so incorrectly. It should read along the lines of 'limb of wood' or 'branch of faewood' for example.\r\n"
    end
    if settings[:wood] =~ /\s*a |\s*an |\s*some /
      settings[:wood].gsub!(/\s*a |\s*an |\s*some /, '')
    end
    if settings[:paintstick1] != "" and settings[:paintstick1] !~ /paintstick/
      settings[:paintstick1] = "#{settings[:paintstick1].strip} paintstick"
    end
    if settings[:paintstick2] != "" and settings[:paintstick2] !~ /paintstick/
      settings[:paintstick2] = "#{settings[:paintstick2].strip} paintstick"
    end
    if settings[:fletchings] != "" and settings[:fletchings] !~ /fletching/
      warning += "You have set what fletchings you want to use but appears you may have done so incorrectly. It should read along the lines of 'bundle of fletchings' for example. Leave off any a/an/some from the start.\r\n"
    end
    if settings[:fletchings] =~ /\s*a |\s*an |\s*some /
      settings[:fletchings].gsub!(/\s*a |\s*an |\s*some /, '')
    end
    if warning.any?
      warning.each { |e|
        Lich::Messaging.msg("warn", e)
      }
    end

    FletchIt::Config.save_settings(settings)
    Lich::Messaging.msg("info", "settings saved")
  else
    Lich::Messaging.msg("info", "closed without saving")
  end
}

#==============================================================================
# MAIN EXECUTION (MODULAR VERSION)
#==============================================================================

# Handle command-line arguments
case Script.current.vars[1]
when /setup|config|configure/i
  setup.call # Old GTK setup still works
  exit
when /bundle/i
  FletchIt::Bundle.bundle_arrows(settings)
  exit
when /help/i
  Lich::Messaging.msg("info", "")
  Lich::Messaging.msg("info", "FletchIt v#{FletchIt::Config::VERSION} - Automated Fletching Script")
  Lich::Messaging.msg("info", "")
  Lich::Messaging.msg("info", "Commands:")
  Lich::Messaging.msg("info", "  ;FletchIt          - Start fletching")
  Lich::Messaging.msg("info", "  ;FletchIt setup    - Configure settings")
  Lich::Messaging.msg("info", "  ;FletchIt bundle   - Bundle existing arrows")
  Lich::Messaging.msg("info", "  ;FletchIt help     - Show this help")
  Lich::Messaging.msg("info", "  ;FletchIt stop     - Stop after current arrow")
  Lich::Messaging.msg("info", "")
  Lich::Messaging.msg("info", "While running, type ;FletchIt to see progress report")
  Lich::Messaging.msg("info", "")
  exit
when nil
  # No arguments - start fletching
else
  Lich::Messaging.msg("info", "")
  Lich::Messaging.msg("info", "FletchIt - Automated Fletching Script")
  Lich::Messaging.msg("info", "")
  Lich::Messaging.msg("info", "This script needs a mapped room if you want it to buy items.")
  Lich::Messaging.msg("info", "Run ';FletchIt setup' to configure settings.")
  Lich::Messaging.msg("info", "While running, ';FletchIt' shows progress, ';FletchIt stop' ends gracefully.")
  Lich::Messaging.msg("info", "")
  exit
end

# Validate settings
warnings = FletchIt::Validator.validate_settings(settings)
if warnings.any?
  warnings.each { |a_warning| Lich::Messaging.msg("warn", a_warning) }
  setup.call
  exit
end

# Normalize settings
settings = FletchIt::Validator.normalize_settings(settings)
FletchIt::Config.save_settings(settings)

# Initialize tracking variables
start_time = Time.now
arrows_made = 0
arrows_failed = 0
spent_silver = 0
finished = false

# Determine ammo type name for messages
ammo_name = FletchIt::Config::AMMO_TYPES[settings[:ammo]] || 'arrow'
ammo_name = "#{ammo_name}s" unless ammo_name.end_with?('s')

# Set up progress reporting hook
fletching_report = proc { |client_string|
  if client_string =~ /^(?:<c>)?#{$clean_lich_char}(?:FletchIt)$/i
    Lich::Messaging.msg("info", "")
    Lich::Messaging.msg("info", "Script has been running for #{Time.at(Time.now - start_time).strftime("%H hours, %M minutes %S seconds")}")
    Lich::Messaging.msg("info", "Made #{arrows_made} #{ammo_name}, ruined #{arrows_failed} #{ammo_name}, spent #{spent_silver} silver")
    Lich::Messaging.msg("info", "")
  elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}FletchIt (?:stop|done|end|finish|finished)$/i
    finished = true
    Lich::Messaging.msg("warn", "")
    Lich::Messaging.msg("warn", "Will stop after completing current #{ammo_name.sub(/s$/, '')}")
    Lich::Messaging.msg("warn", "")
  else
    client_string
  end
}

UpstreamHook.add('fletching_hook', fletching_report)
before_dying { UpstreamHook.remove('fletching_hook') }

# Start interaction monitoring if enabled
FletchIt::GameActions.monitor_interaction(settings) if settings[:alerts]

# Empty hands to start
empty_left_hand
empty_right_hand

# Main fletching loop
loop do
  # Cast haste if enabled
  Script.run("ewaggle") if settings[:waggle]

  # Check for needed supplies
  fletch_sack_contents = FletchIt::Inventory.get_container_contents(settings[:sack])
  needed_items = FletchIt::Shopping.check_needed_items(settings, fletch_sack_contents, paints)

  if !needed_items.empty?
    if !settings[:enable_buying]
      Lich::Messaging.msg("error", "Run out of #{needed_items[0]} and auto-buying is disabled.")
      Lich::Messaging.msg("info", "Run ';FletchIt setup' to enable auto-buying.")
      exit
    end

    Lich::Messaging.msg("info", "")
    needed_items.each { |item| Lich::Messaging.msg("info", "Out of #{item}") }
    Lich::Messaging.msg("info", "Going to buy supplies...")
    Lich::Messaging.msg("info", "")
    sleep 1

    spent_silver += FletchIt::Shopping.buy_items(settings, needed_items)
    fletch_sack_contents = FletchIt::Inventory.get_container_contents(settings[:sack])
  end

  # Make shafts if we have wood/logs AND no shafts remaining
  # Check for both singular "shaft" and plural "shafts"
  has_shafts = fletch_sack_contents.any? { |item|
    item.noun == "shaft" || item.noun == "shafts"
  }
  has_wood = fletch_sack_contents.any? { |item| item.noun == "wood" || item.noun == "log" }

  if !has_shafts && has_wood
    waitrt?
    FletchIt::Crafting.make_shafts(settings)
  end

  # Wait for mind to absorb if learning mode enabled
  if settings[:learning]
    mind_threshold = settings[:mind].to_i
    if percentmind > mind_threshold
      Lich::Messaging.msg("info", "")
      Lich::Messaging.msg("info", "Waiting for mind to drop below #{mind_threshold}% (currently #{percentmind}%)...")
      Lich::Messaging.msg("info", "")
      wait_while { percentmind > mind_threshold }
    end
  end

  # Make an arrow/bolt
  result = FletchIt::Crafting.make_arrow(settings, paints)

  # Track results based on return status
  case result
  when :completed
    arrows_made += 1
  when :failed
    arrows_failed += 1
  when :no_shafts
    # No shafts available - loop will make more on next iteration
  when :no_supplies
    # Ran out of glue or fletchings - loop will buy more if enabled
  end

  # Report progress (unless in learning mode)
  unless settings[:learning]
    Lich::Messaging.msg("info", "")
    Lich::Messaging.msg("info", "Running for #{Time.at(Time.now - start_time).strftime("%H hours, %M minutes %S seconds")}")
    Lich::Messaging.msg("info", "Made #{arrows_made} #{ammo_name}, ruined #{arrows_failed} #{ammo_name}, spent #{spent_silver} silver")
    Lich::Messaging.msg("info", "")
  end

  # Check exit conditions
  break if finished
  break if settings[:limit].to_i > 0 && arrows_made >= settings[:limit].to_i
end

Lich::Messaging.msg("info", "")
Lich::Messaging.msg("info", "Fletching complete!")
Lich::Messaging.msg("info", "Made #{arrows_made} #{ammo_name}, ruined #{arrows_failed} #{ammo_name}, spent #{spent_silver} silver")
Lich::Messaging.msg("info", "")
