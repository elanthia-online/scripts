
=begin

*** Made some updates to ;fletching. ***

Learning mode will restart after cutting nocks, and wait while mind is above 60%
Has the ability to make arrows, light and heavy bolts.

Have only the fletchings you want to use in your supplies container, the script does not distinguish
between types of fletchings when working, it only checks to make sure the kind you entered are in your
supplies sack.

Will make, paint and crest arrows. If you are in a mapped room it can run to the shop and buy more basic items.
Will keep on going untill you tell it to stop or you hit the limit you set.

Bow or crossbow must be worn before starting script. Crossbow must be cocked and unloaded.

';fletchit help' for help
';fletchit setup' to change your settings
';fletchit bundle' will attempt to bundle all your arrows, this will likely fail if you are not at, or near mastered, as you make arrows of all different qualities
';fletchit' while the script is running will bring up a mini report(same as you get after finishing an arrow
';fletchit stop' while the script is running will tell the script to stop after finsihing the current arrow


=end

#todo
#add waste barrel detection
#cut all shafts in batches
#make own fletchings
#save arrow profiles
#flip arrows
#toggle for waggle
#scan inventory for knife/axe/bow
#scan inventory for containers

#fixme1 - Bow currently must be worn, change so checks GameObj.inv and if not there gets it from container instead
#silence_me
settings = CharSettings.to_hash
settings[:sack]       ||= "backpack"
settings[:quiver]       ||= "backpack"
settings[:axe]        ||= "handaxe"
settings[:knife]      ||= "dagger"
settings[:bow]        ||= "bow"
settings[:enable_buying]  ||= false
settings[:paint]      ||= 0
settings[:paintstick1]    ||= ""
settings[:paintstick2]    ||= ""
settings[:wood]       ||= "limb of wood"
settings[:fletchings]     ||= "bundle of fletchings"
settings[:limit]      ||= ""
settings[:waggle]       ||= false
settings[:learning]     ||= false
settings[:alerts]       ||= false
settings[:tip]        ||= ""
settings[:drill]      ||= ""
settings[:ammo]       ||= 0
settings[:mind]       ||= "60"

#doesnt really need to be a hash but had to make sure they were in the right order to add the drop down menu on the gui
ammo_types = {
  0 => 'none',
  1 => 'arrow',
  2 => 'light bolt',
  3 => 'heavy bolt',
}
paints = {
  0 => 'none',
  1 => 'bright golden paint',
  2 => 'fiery orange paint',
  3 => 'bright yellow paint',
  4   => 'dark russet paint',
  5 => 'dark brown paint',
  6 => 'silvery grey paint',
  7 => 'twilight grey paint',
  8 => 'storm grey paint',
  9 => 'charcoal grey paint',
  10  => 'icy blue paint',
  11  => 'midnight blue paint',
  12  => 'dusky blue paint',
  13  => 'silvery white paint',
  14  => 'bone white paint',
  15  => 'pure white paint',
  16  => 'glossy black paint',
  17  => 'dull black paint',
  18  => 'inky black paint',
  19  => 'forest green paint',
  20  => 'hunter green paint',
  21  => 'dark green paint',
  22  => 'blood red paint',
  23  => 'glossy red paint',
  24  => 'dull red paint',
}

#Ripped setup from sloot, no clue waht is going on here but it works!
setup = proc {



  gtk_global = Hash.new
  window = window_action = nil
  Gtk.queue {
#   ttips = Gtk::Tooltips.new.enable
    ttips_text = {
      :sack => 'This is the container all your supplies, axe and dagger will be in',
      :quiver => 'This is the container you want your finshed arrows to be stored in, it can be the same as the container above if you wish',
      :axe => 'This is the axe you will use for creating the shafts, needs to be what ever you would type following the get comand to remove it from your container.' ,
      :knife => 'This is the knife or dagger you will be using to cut the shafts, needs to be what ever you would type following the get comand to remove it from your container.' ,
      :bow => 'This is the bow you will be using to measure the shaft, MUST BE WORN!',
      :enable_painting => 'Check this if you would like to paint your arrows',
      :enable_buying => 'Check this if you would like the script to go buy wood, glue and fletchings from the shop',
      :wood => 'The name of the wood you would like to buy, leaving off a/an/some at the start. Eg. "limb of faewood" or "branch of kakore"',
      :paint => 'The name of the paint you would like to buy, leaving off a/an/some at the start',
      :paintstick1 => 'Leave blank if you do not want to use a paintstick to crest your arrows. If you want to crest you arrows please enter the colour of the paintstick.',
      :paintstick2 => 'Leave blank if you do not want to use a paintstick to crest your arrows a second time. If you want to crest you arrows a second time please enter the colour of the paintstick.',
      :fletchings => 'The name of the fletchings you would like to buy, leaving off a/an/some at the start.',
      :limit => 'This is the number of arrows you would like the script to make, leave blank for no limit. It will just keep making more till you tell it to stop, run out of space or run out of money.',
      :learning => 'Enable learning mode, will drop shafts and clean table so works best at a table.',
      :mind => 'When learning, script will wait when your mind is above this percentage.',
      :alerts => 'Monitors interactions and pops up an alert.',
      :ammo => 'Type of ammunition you want to make. Please select one',
      :drill => 'The noun of your drill which should be in your supplies container.',
      :tip => 'The noun of the tips you wish to use which should be in your supplies container.',
    }

    gtk_global[:sack] = Gtk::Entry.new; gtk_global[:sack].text = (settings[:sack])
    gtk_global[:quiver] = Gtk::Entry.new; gtk_global[:quiver].text = (settings[:quiver])
    gtk_global[:axe] = Gtk::Entry.new; gtk_global[:axe].text = (settings[:axe])
    gtk_global[:knife] = Gtk::Entry.new; gtk_global[:knife].text = (settings[:knife])
    gtk_global[:bow] = Gtk::Entry.new; gtk_global[:bow].text = (settings[:bow])
    gtk_global[:wood] = Gtk::Entry.new; gtk_global[:wood].text = (settings[:wood])
    gtk_global[:ammo] = Gtk::ComboBoxText.new()
    gtk_global[:paint] = Gtk::ComboBoxText.new()
    gtk_global[:paintstick1] = Gtk::Entry.new; gtk_global[:paintstick1].text = (settings[:paintstick1])
    gtk_global[:paintstick2] = Gtk::Entry.new; gtk_global[:paintstick2].text = (settings[:paintstick2])
    gtk_global[:fletchings] = Gtk::Entry.new; gtk_global[:fletchings].text = (settings[:fletchings])
    gtk_global[:limit] = Gtk::Entry.new; gtk_global[:limit].text = (settings[:limit].to_s)
    gtk_global[:waggle] = Gtk::CheckButton.new; gtk_global[:waggle].active = (settings[:waggle])
    gtk_global[:enable_buying] = Gtk::CheckButton.new; gtk_global[:enable_buying].active = (settings[:enable_buying])
    gtk_global[:learning] = Gtk::CheckButton.new; gtk_global[:learning].active = (settings[:learning])
    gtk_global[:alerts] = Gtk::CheckButton.new; gtk_global[:alerts].active = (settings[:alerts])
    gtk_global[:mind] = Gtk::Entry.new; gtk_global[:mind].text = (settings[:mind])
#   gtk_global[:drill] = Gtk::Entry.new; gtk_global[:drill].text = (settings[:drill])
#   gtk_global[:tip] = Gtk::Entry.new.set_tip(settings[:tip])

    #use paints array to form combox
    x = 0
    while x < paints.length
      gtk_global[:paint].append_text(paints[x])
      x += 1
    end
    x = 0
    while x < ammo_types.length
      gtk_global[:ammo].append_text(ammo_types[x])
      x += 1
    end
    gtk_global[:paint].active = (settings[:paint]) #have to set active after apending
    gtk_global[:ammo].active = (settings[:ammo])



    ttips_text.each_pair { |widget,tip|
      if widget = gtk_global[widget]# || gtk_locals[widget]
        widget.set_tooltip_text(tip).has_tooltip = true
      end
    }

    window = Gtk::Window.new
    window.title = "FletchIT"
    window.border_width = 3
    window.resizable = true
    #window.resize(10, 10)

    settings_page = Gtk::Box.new(:vertical, 1).set_border_width(3)
    vb_pg1_1 = Gtk::Box.new(:vertical, 1).set_border_width(3)
    fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Settings</b></big>'))
    fr_pg1_1.add(vb_pg1_1)
    settings_page.pack_start(fr_pg1_1, :expand => false, :fill => false, :padding => 0)

    #random note to self width will be ignored if text is longer
    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Supplies Container: ')).set_width_request(120))
    hb.pack_start(gtk_global[:sack], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Finished Container: ')).set_width_request(120))
    hb.pack_start(gtk_global[:quiver], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Bow: ')).set_width_request(120))
    hb.pack_start(gtk_global[:bow], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Ammo: ')).set_width_request(120))
    hb.pack_start(gtk_global[:ammo].set_width_request(158), :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Axe: ')).set_width_request(120))
    hb.pack_start(gtk_global[:axe], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Knife: ')).set_width_request(120))
    hb.pack_start(gtk_global[:knife], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

#   hb = Gtk::Box.new(:horizontal, 1)
#   hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Drill: ')).set_width_request(120))
#   hb.pack_start(gtk_global[:drill], :expand => false, :fill => false, :padding => 0)
#   vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Buy Items: ')).set_width_request(120))
    hb.pack_start(gtk_global[:enable_buying], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Wood: ')).set_width_request(120))
    hb.pack_start(gtk_global[:wood], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Paint: ')).set_width_request(120))
    hb.pack_start(gtk_global[:paint].set_width_request(158), :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Paintstick 1: ')).set_width_request(120))
    hb.pack_start(gtk_global[:paintstick1], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Paintstick 2: ')).set_width_request(120))
    hb.pack_start(gtk_global[:paintstick2], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Fletchings: ')).set_width_request(120))
    hb.pack_start(gtk_global[:fletchings], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

#   hb = Gtk::Box.new(:horizontal, 1)
#   hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Tip Ammo: ')).set_width_request(120))
#   hb.pack_start(gtk_global[:tip], :expand => false, :fill => false, :padding => 0)
#   vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Make limit: ')).set_width_request(120))
    hb.pack_start(gtk_global[:limit], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Learn Fletching: ')).set_width_request(120))
    hb.pack_start(gtk_global[:learning], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Mind: ')).set_width_request(120))
    hb.pack_start(gtk_global[:mind], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Monitor Interactions: ')).set_width_request(120))
    hb.pack_start(gtk_global[:alerts], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal, 1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Use waggle: ')).set_width_request(120))
    hb.pack_start(gtk_global[:waggle], :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb, :expand => false, :fill => false, :padding => 0)


    lbl = Gtk::Label.new.set_markup("Mouse over each box for more help")
    lbl.set_wrap(true).set_padding(0,10)
    vb_pg1_1.pack_start(lbl, :expand => false, :fill => false, :padding => 0)

    hb_saveclose = Gtk::Box.new(:horizontal, 1)
    save = Gtk::Button.new(:label => '_Save & Close')
    close = Gtk::Button.new(:label => 'E_xit')
    save.signal_connect('clicked') { window_action = :save }
    close.signal_connect('clicked') { window_action = :done }
    hb_saveclose.pack_start(save, :expand => false, :fill => false, :padding => 0)
    hb_saveclose.pack_start(close, :expand => false, :fill => false, :padding => 0)
    vb_pg1_1.pack_start(hb_saveclose, :expand => false, :fill => false, :padding => 0)

    window.signal_connect('delete_event') { window_action = :exit }

    window.add(settings_page)

    window.show_all
    window.keep_above = true

  }

  before_dying { Gtk.queue { window.destroy } }
  wait_while { window_action.nil? }
  undo_before_dying
  Gtk.queue { window.destroy }

  if window_action == :save
    gtk_global.each_pair { |option,widget|

      if widget.class == Gtk::CheckButton
        settings[option] = widget.active?
      elsif widget.class == Gtk::Entry
        settings[option] = widget.text.strip.downcase
      elsif widget.class == Gtk::ComboBoxText
        settings[option] = widget.active
      else
        echo "error: unknown local widget #{option} [#{widget.class}]"
      end
    }

    #attempt some error checking
    warning = ""
    if settings[:sack] == ""
      warning += "The container for you supplies has not yet been set, the script will not run untill this is added.\r\n"
    end
    if settings[:quiver] == ""
      warning += "The container for you finished arrows has not yet been set, the script will not run untill this is added.\r\n"
    end
    if settings[:knife] == ""
      warning += "Have not set a knife/dagger to cut the shafts with, the script will not run untill this is added.\r\n"
    end
    if settings[:bow] == ""
      warning += "Have not set a bow to measure the shafts with, the script will not run untill this is added.\r\n"
    end
    if settings[:axe] == ""
      warning += "Have not set an axe to make shafts with, the script will not run untill this is added.\r\n"
    end
    if settings[:wood] == ""
      warning += "Have not set a what wood you want to use, the script will not run untill this is added.\r\n"
    end
    if settings[:wood] != "" and settings[:wood] !~ /wood|log/
      warning += "You have set what wood you want to use but appears you may have done so incorectly. It should read along the lines of 'limb of wood' or 'branch of faewood' for example.\r\n"
    end
    if settings[:wood] =~ /\s*a |\s*an |\s*some /
      settings[:wood].gsub!(/\s*a |\s*an |\s*some /, '')
    end
    if settings[:paintstick1] != "" and settings[:paintstick1] !~ /paintstick/
      settings[:paintstick1] = "#{settings[:paintstick1].strip} paintstick"
    end
    if settings[:paintstick2] != "" and settings[:paintstick2] !~ /paintstick/
      settings[:paintstick2] = "#{settings[:paintstick2].strip} paintstick"
    end
    if settings[:fletchings] != "" and settings[:fletchings] !~ /fletching/
      warning += "You have set what fletchings you want to use but appears you may have done so incorectly. It should read along the lines of 'bundle of fletchings' for example. Leave off any a/an/some from the start.\r\n"
    end
    if settings[:fletchings] =~ /\s*a |\s*an |\s*some /
      settings[:fletchings].gsub!(/\s*a |\s*an |\s*some /, '')
    end
    if warning.length > 0
      if !$fake_stormfront
        puts "<output class=\"mono\"/>#{monsterbold_start}#{warning}#{monsterbold_end}\r\n<output class=\"\"/>"
      else
        puts "#{monsterbold_start}#{warning}#{monsterbold_end}"
      end
    end
    echo 'settings saved'
  else
    echo 'closed without saving'
  end
}

def monitor_interaction()
        #if @MONITOR_INTERACTION
start_exec_script( <<-eos
  def show_window(line);
  window_title = Char.name + ':' + line;
  Gtk.queue {
    $myWindow = Gtk::Window.new;
    $myWindow.title = "Autobot Alert!";
    $myWindow.set_size_request(450, 25);
    label = Gtk::Label.new window_title;
    $myWindow.add(label);
    $myWindow.show_all;
  };
  end;
  while(line = get);
    break unless running?('fletchit');
    if(line =~ /SEND|POLICY|[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]|peaking to you|unresponsive|taps you|nods to you|lease respond|not in control|character|violation|lease speak|peak out loud|Y U SHOU D|whispers,|speaking to you|smiles at you|waves to you|grins at you|hugs you|takes hold your hand|grabs your hand|clasps your hand|trying to drag you/);
      unless(line =~ /LNet/);
        show_window(line);
        echo "AUTOBOT ALERT: " + line;
      end;
    end;
  end;
  eos
)
end
   # end

def checksilver
  silvers = nil
  action = proc { |server_string|
    if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
      nil
    elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
      silvers = $1.to_i
      DownstreamHook.remove("slib_check_silvers")
      nil
    else
      server_string
    end
  }
  DownstreamHook.add("slib_check_silvers", action)
  $_SERVER_.puts "#{$cmd_prefix}info\n"
  wait_until { silvers }
  silvers
end

def get_container_contents(container_name)

  if container_name.nil?
    echo 'Blank name passed to get_container_contents'
    sleep 1
    exit
  else
    container_contents = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(container_name.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(container_name).sub(' ', ' .*')}/i }
    if container_contents.nil?
      echo "warning: failed to find your fletchsack (#{container_name})"
      sleep 1
    else
      if container_contents.contents.nil?
        open_result = dothistimeout "open ##{container_contents.id}", 10, /You open|already open/
        close_container_contents = true if open_result =~ /You open/
        if container_contents.contents.nil?
          dothistimeout "look in ##{container_contents.id}", 10, /In the .* you see/
          if container_contents.contents.nil?
            echo "warning: failed to find the contents of your fletchsack (#{container_name})"
            sleep 1
          end
        end
      end
    end
  end
  return container_contents.contents
end

def check_needed_items(settings,fletch_sack_contents,paints)
  items = Array.new
  needed_items = Array.new
  need_wood = true
  need_paint = true
  need_glue = true
  need_fletchings = true
  need_paintstick1 = true
  need_paintstick2 = true
  #check container and if we have it mark as not needed
  fletch_sack_contents.each{|item|
    #fixme: see if can get more specfic then shaft
    if item.name =~ /shaft/ or item.name =~ /#{settings[:wood]}/
      need_wood = false
    elsif item.name =~ /#{paints[settings[:paint]]}/
      need_paint = false
    elsif item.name =~ /#{settings[:fletchings]}/
      need_fletchings = false
    elsif item.name =~ /bottle of fletching glue/
      need_glue = false
    elsif item.name =~ /#{settings[:paintstick1]}/ and settings[:paintstick1].length > 0
      need_paintstick1 = false
    elsif item.name =~ /#{settings[:paintstick2]}/ and settings[:paintstick2].length > 0
      need_paintstick2 = false
    end
  }

  needed_items = Array.new

  if need_wood
    needed_items << settings[:wood]
  end
  if need_glue
    needed_items << "bottle of fletching glue"
  end
  if need_fletchings
    needed_items << settings[:fletchings]
  end
  if need_paint and settings[:paint] != 0
    needed_items << "vial of paint"
  end
  if need_paintstick1 and settings[:paintstick1].length > 0
    needed_items << settings[:paintstick1]
  end
  if need_paintstick2 and settings[:paintstick2].length > 0
    needed_items << settings[:paintstick2]
  end



  return needed_items
end

def find_order_num(supply)

  status_tags
  clear
  fput 'unhide' if hidden? or invisible?
  fput 'order'
  menu = Hash.new
  while (line = get) and (line !~ /ORDER|BUY/)
    for item in line.scan(/<d.*?cmd=["']order ([0-9]+).*?>(.*?)<\/d>/)
      menu[item[1].sub(/^a /, '')] = item[0]
    end
  end
  clear
  status_tags

  #menu = read_menu.call
  #echo menu.inspect

  item_name = menu.keys.find { |name| name =~ /#{supply}/i }
  unless order_number = menu[item_name]
    echo ""
    echo "Error: failed to find the item! Remember to leave off the a/an/some at the start. eg. 'limb of faewood"
    echo ""
  end
  return order_number

end

def buy_items(settings, needed_items)
  if invisible?
    invis = true
  else
    invis = false
  end
  start_room = Room.current.id
  silver = checksilver
  if silver < 5000
    silver = 5000 - silver
    start_script "go2",['bank']
    wait_while {running?("go2")}
    fput "unhide" if hidden? or invisible?
    fput "withdraw #{silver}"
    if checksilver < 5000
      echo "Failed to get money from the bank"
      exit
    end
  end
  start_script "go2",['fletcher']
  wait_while {running?("go2")}
  move "south" if Room.current.location == "Ta'Vaalor"

  if checkleft != nil
    empty_left_hand
  end
  if checkright != nil
    empty_right_hand
  end
  needed_items.each {|item|

    if item =~ /vial of paint/
      order_number = find_order_num(item)
      multifput "order #{order_number} color #{settings[:paint]}", "buy"
    else
      order_number = find_order_num(item)
      multifput "order #{order_number}", "buy"
    end

    #wait up to three seconds to see if purchase was succesful
    endtime = Time.now + 3
    loop {
      if checkright.nil?
        sleep 1
      elsif Time.now > endtime
        echo "For some reason buying an item failed"
        exit
      elsif checkright
        echo "got item"
        break
      end
    }
    stow_check = dothistimeout "put my #{checkright} in my #{settings[:sack]}", 3, /won't fit|You put a/
    if stow_check =~ /won't fit/
      echo "fletchsack full, stopping"
      exit
    elsif stow_check.nil?
      echo "stowcheck failed, stopping"
      exit
    end

  }
  spent_silver += (5000 - checksilver)

  start_script "go2",['bank']
  wait_while {running?("go2")}
  fput "unhide" if hidden? or invisible?
  fput "depo all"
  if invis and Spell[916].affordable?
    fput "incant 916"
  end
  start_script "go2",[start_room]
  wait_while {running?("go2")}
  return spent_silver
end

def stow(hand,container)
  if (hand == "left")
    return if checkleft.nil?
  elsif (hand == "right")
    return if checkright.nil?
  else
    respond "This should not of happened"
    respond "Invalid hand of: #{hand}"
    exit
  end
  fput "put #{hand} in my #{container}"
  again = false
  endtime = Time.now + 6
  loop{
    if (checkleft.nil? && hand == "left")
      break
    elsif (checkright.nil? && hand == "right")
      break
    elsif Time.now > endtime -3 and !again
      again = true
      fput "put #{hand} in my #{container}"
    elsif Time.now > endtime
      "Stowing item failed"
    else
      sleep 0.1
    end
  }
end

def get_knife(settings)
  check = dothistimeout "get my #{settings[:knife]}", 3, /You remove|get what?/
  if check =~ /get what?/
    echo "Failed to get your knife."
    exit
  elsif check.nil?
    endtime = Time.now + 5
    loop {
      if checkleft =~ /#{settings[:knife]}/
        break
      elsif Time.now > endtime
        echo "Failed to get your knife."
        exit
      else
        sleep 1
      end
      }
  end
end

def haste!()
  waitcastrt?
  fput "incant 535" if Spell[535].known? and !Spell[535].active? and Spell[535].affordable?
end

def bundle(settings)

  quiver = GameObj.inv.find { |obj| obj.name =~ /#{settings[:quiver]}/ }
  contents = Hash.new
  quiver.contents.each {|item|
    item_id = item.id
    contents[item_id] = item.name
  }
  #finds the description of each different type of arrow
  arrow_types = Array.new
  contents.each_pair{|id,name|
    if name =~ /(arrow|bolt)$/ and !arrow_types.include? name
      arrow_types << name
    end
  }
  arrow_types.each{|desc|
    contents.each_pair{|id,name|
      if desc =~ /#{name}/
        if checkright.nil?
          fput "get ##{id} in my #{settings[:quiver]}"
          endtime = Time.now + 6
          wait_until{!checkright.nil? || Time.now > endtime}
        else
          fput "get ##{id} in my #{settings[:quiver]}"
        end
        if !checkleft.nil? and !checkright.nil?
          check = dothistimeout "bundle", 3, /You bundle your (arrow|bolt)s together.|You add a .+? to your bundle.|You may not combine more than 100 shafts./
          if check.nil?
            echo "bundling failed for some reason, stopping"
            exit
          elsif check =~ /You may not combine more than 100 shafts./
            stow("right",settings[:quiver])
          end
          endtime = Time.now + 6
          wait_until{checkleft.nil? || Time.now > endtime}
        end
      end
    }
    #fput "stow right"
    stow("right",settings[:quiver])
  }
  #now arrows are bundled see about condensing the bundles down
  bundle_ids = Array.new
  quiver_contents = get_container_contents(settings[:quiver])
  quiver_contents.each{|item|
    if item.name =~ /bundle .+? (bolt|arrow)s/
      bundle_ids << item.id
    end
  }

  bundle_amount = Array.new
  bundle_desc = Array.new
  bundle_check = proc{|server_string|
  #
  #Individual projectiles from this bundle will have a long of "a wooden arrow"
  #

    if server_string.nil?
      #nil
    elsif server_string =~ /You carefully count the <a exist="\d+" noun="\w+">\w+<\/a> and find (\d+) in the bundle, each one being .+, with a strength of \d+ and a durability of \d+./
      bundle_amount << $1
      nil
    elsif server_string =~ /^Individual projectiles from this bundle will have a (show|long) of "(.+?)".$|(.+?). You also notice a small enchanter's glyph.$/
      bundle_desc << $2
      nil
    elsif server_string =~ /Each individual projectile will be "(.+?)".$/
      nil
    elsif server_string =~ /<prompt time="\d+">&gt;<\/prompt>/
      nil
    else
      if server_string.length > 2
        server_string
      else
        nil
      end
    end
  }
  DownstreamHook.add('fletch_budle_check', bundle_check)
  silence_me
  bundle_ids.each{|id|
    fput "look ##{id}"
  }
  silence_me
  endtime = Time.now + 6
  wait_until{(bundle_ids.length == bundle_desc.length) || Time.now > endtime}
  DownstreamHook.remove('fletch_budle_check')
  if bundle_ids.length != bundle_desc.length
    echo "failed to get bundles info, stopping"
    exit
  end
  x = 0
  bundles = Array.new
  until x == bundle_ids.length
    bundles << bundle = {
      "id" => bundle_ids[x],
      "count" => bundle_amount[x],
      "desc" => bundle_desc[x]
    }
    x +=1
  end
  uniq_bundle_desc = bundle_desc & bundle_desc
  last_bundle = ""
  uniq_bundle_desc.each{|desc|
    total = 0
    bundles.each{|bundle|
      if bundle['desc'] == desc and total == 0 and bundle['count'].to_i!=100
        #there is a match but if there might only be one of that bundle so take note but do nothing
        total += bundle['count'].to_i
        last_bundle = bundle['id'].dup
      elsif bundle['desc'] == desc and total > 0 and bundle['count'].to_i!=100
        #match and the total is already above 0, must of already found a bundle of the same arrows
        total += bundle['count'].to_i
        if total < 100
          fput "get ##{bundle['id']}"
          matchtimeout 1, "You remove"
          fput "get ##{last_bundle}" if checkleft.nil?
          fput "bundle"
          last_bundle = bundle['id']
        else

          if total == 100
            fput "get ##{bundle['id']}"
            matchtimeout 1, "You remove"
            fput "get ##{last_bundle}" if checkleft.nil?
            fput "bundle"
            #fput "stow r"
            stow("right",settings[:quiver])
            total = 0
          else
            amount_over = total - 100
            amount_to_get = bundle['count'].to_i - amount_over
            fput "get #{amount_to_get} ##{bundle['id']}"
            matchtimeout 1, "You remove"
            fput "get ##{last_bundle}" if checkleft.nil?
            fput "bundle"
            #fput "stow r"
            stow("right",settings[:quiver])
            bundle['amount'] = bundle['amount'].to_i - amount_to_get  #resize the bundle
            bundles << bundle                     #and add back on the end
            total = 0
          end



        end
      end
    }
    #fput "stow r" if !checkright.nil?
    stow("right",settings[:quiver]) if !checkright.nil?
  }
end

def make_shafts(settings)

  if settings[:wood] =~ /log/
    #get wood
    check = dothistimeout "get my log in my #{settings[:sack]}", 1, /You remove|Get what?/
    if check =~ /Get what?/
      echo "Run out of shafts some how, this shouldn't be happening."
      exit
    elsif check.nil?
      #backup for scripted containers
      endtime = Time.now + 5
      loop {
        if checkright =~ /log/
          break
        elsif Time.now > endtime
          echo "Could not get log, stopping"
          exit
        else
          sleep 1
        end
      }
    end
    #get axe
    check = dothistimeout "get my #{settings[:axe]}", 3, /You remove|get what?/
    if check =~ /get what?/
      echo "Could not get your axe to cut the shafts"
      exit
    elsif check.nil?
      #backup for scripted containers
      endtime = Time.now + 5
      loop {
        if checkright =~ /#{settings[:axe]}/
          break
        elsif Time.now > endtime
          echo "Could not get your axe to cut the shafts"
          exit
        else
          sleep 1
        end
      }
    end
    #cut shafts
    haste!
    if settings[:ammo] == 1
      fput "cut arrow shaft my log"
      endtime = Time.now + 6
      loop {
        if checkright =~ /shaft/
          need_shafts = false
          break
        elsif Time.now > endtime
          echo "Failed to cut shafts."
          exit
        else
          sleep 1
          echo "sleeping"
        end
      }
    elsif settings[:ammo] == 2
      fput "cut light bolt my log"
      endtime = Time.now + 6
      loop {
        if checkright =~ /shaft/
          need_shafts = false
          break
        elsif Time.now > endtime
          echo "Failed to cut shafts."
          exit
        else
          sleep 1
          echo "sleeping"
        end
      }
    elsif settings[:ammo] == 3
      fput "cut heavy bolt my log"
      endtime = Time.now + 6
      loop {
        if checkright =~ /shaft/
          need_shafts = false
          break
        elsif Time.now > endtime
          echo "Failed to cut shafts."
          exit
        else
          sleep 1
          echo "sleeping"
        end
      }
    end
  elsif settings[:wood] =~ /wood/
    #get wood
    check = dothistimeout "get my wood in my #{settings[:sack]}", 1, /You remove|Get what?/
    if check =~ /Get what?/
      echo "Run out of shafts some how, this shouldn't be happening."
      exit
    elsif check.nil?
      #backup for scripted containers
      endtime = Time.now + 5
      loop {
        if checkright =~ /wood/
          break
        elsif Time.now > endtime
          echo "Could not get wood, stopping"
          exit
        else
          sleep 1
        end
      }
    end
    #get axe
    check = dothistimeout "get my #{settings[:axe]}", 3, /You remove|get what?/
    if check =~ /get what?/
      echo "Could not get your axe to cut the shafts"
      exit
    elsif check.nil?
      #backup for scripted containers
      endtime = Time.now + 5
      loop {
        if checkright =~ /#{settings[:axe]}/
          break
        elsif Time.now > endtime
          echo "Could not get your axe to cut the shafts"
          exit
        else
          sleep 1
        end
      }
    end
    #cut shafts
    haste!
    if settings[:ammo] == 1
      fput "cut arrow shaft my wood"
      endtime = Time.now + 6
      loop {
        if checkright =~ /shaft/
          need_shafts = false
          break
        elsif Time.now > endtime
          echo "Failed to cut shafts."
          exit
        else
          sleep 1
          echo "sleeping"
        end
      }
    elsif settings[:ammo] == 2
      fput "cut light bolt my wood"
      endtime = Time.now + 6
      loop {
        if checkright =~ /shaft/
          need_shafts = false
          break
        elsif Time.now > endtime
          echo "Failed to cut shafts."
          exit
        else
          sleep 1
          echo "sleeping"
        end
      }
    elsif settings[:ammo] == 3
      fput "cut heavy bolt my wood"
      endtime = Time.now + 6
      loop {
        if checkright =~ /shaft/
          need_shafts = false
          break
        elsif Time.now > endtime
          echo "Failed to cut shafts."
          exit
        else
          sleep 1
          echo "sleeping"
        end
      }
    end
  end


  sleep 1
  waitrt?

  stow("right",settings[:sack])
  #fput "put right in my #{settings[:sack]}"
  endtime = Time.now + 6
  loop{
    if checkright.nil?
      break
    elsif Time.now > endtime
      "Stowing item failed"
      exit
    else
      sleep 0.5
    end
  }
  stow("left",settings[:sack])
end

def make_arrow(settings,paints)
  #get shaft
  check = dothistimeout "get 1 my shaft", 3, /You remove|get what?/
  if check =~ /get what?/
    echo "Run out of shafts some how, this shouldn't be happening."
    exit
  elsif check.nil?
    #backup for scripted containers
    endtime = Time.now + 5
    loop {
      if checkright =~ /shaft/
        break
      elsif Time.now > endtime
        echo "Could not get shaft, stopping"
        exit
      else
        sleep 1
      end
      }
  end
  get_knife(settings)
  #cut shaft
  haste!
  fput "cut my shaft with my #{settings[:knife]}"
  sleep 1
  waitrt?

  if checkright !~ /shaft/
    stow("left",settings[:sack])
    return
  end

  #painting goes here
  if settings[:paint] != 0
    stow("left",settings[:sack])
    paint = paints[settings[:paint]].split(" ")
    fput "get my #{paint[0]} paint"
    endtime = Time.now + 6
    loop{
      if checkleft =~ /paint/
        break
      elsif Time.now > (endtime - 3)
        fput "get my #{paint[0]} paint"
      elsif Time.now > endtime
        echo "Run out of paint, probably means you have another colour paint on you messing with my check. Get it out your fletchsack"
        exit
      else
        sleep 0.5
      end
    }
    haste!
    check = dothistimeout "paint my shaft", 3, /You carefully smear a bit of paint/
    if check.nil?
      #if the first check failed for some reason double check by looking at the arrow
      check = dothistimeout "look my shaft", 3, /has been pared down and smoothed.$|paint covers the shaft./
      if check !~ /paint covers the shaft./
        echo "Could not determine if painting was successful, stopping"
        exit
      end
    end
    check = matchtimeout 40, "The paint on your"
    if !check
      echo "Did not see paint dry for some reason, carrying on in case it did but might cause problems if it didn't"
    end
    stow("left",settings[:sack])

  end
  #paintstick1
  if settings[:paintstick1].length > 0
    stow("left",settings[:sack])
    fput "get my #{settings[:paintstick1]}"
    endtime = Time.now + 6
    loop{
      if checkleft =~ /paintstick/
        break
      elsif Time.now > (endtime - 3)
        fput "get my #{settings[:paintstick1]}"
      elsif Time.now > endtime
        echo "Could not get your paintstick"
        exit
      else
        sleep 0.5
      end
    }
    haste!
    check = dothistimeout "paint my shaft", 3, /You carefully apply a band of/
    if check.nil?
      #if the first check failed for some reason double check by looking at the arrow
      check = dothistimeout "look my shaft", 3, /It looks like someone has painted a single .+ band on the end/
      if check !~ /It looks like someone has painted a single .+ band on the end/
        echo "Could not determine if painting was succesful, stopping"
        exit
      end
    end
    check = matchtimeout 40, "The paint on your"
    if !check
      echo "Did not see paint dry for some reason, carrying on in case it did but might cause problems if it didn't"
    end
    waitrt?
    stow("left",settings[:sack])
  end

  #paintstick2
  if settings[:paintstick2].length > 0
    stow("left",settings[:sack])
    fput "get my #{settings[:paintstick2]}"
    endtime = Time.now + 6
    loop{
      if checkleft =~ /paintstick/
        break
      elsif Time.now > (endtime - 3)
        fput "get my #{settings[:paintstick2]}"
      elsif Time.now > endtime
        echo "Could not get your paintstick"
        exit
      else
        sleep 0.5
      end
    }
    haste!
    check = dothistimeout "paint my shaft", 3, /You carefully apply a band of/
    if check.nil?
      #if the first check failed for some reason double check by looking at the arrow
      check = dothistimeout "look my shaft", 3, /It looks like someone has painted a pair of .+ and .+ bands on the end.|It looks like someone has painted a single .+ band on the end/
      if check !~ /It looks like someone has painted a pair of .+ and .+ bands on the end.|It looks like someone has painted a single .+ band on the end/
        echo "Could not determine if painting was succesful, stopping"
        exit
      end
    end
    check = matchtimeout 40, "The paint on your"
    if !check
      echo "Did not see paint dry for some reason, carrying on in case it did but might cause problems if it didn't"
    end
    waitrt?
    stow("left",settings[:sack])
  end

  #cut nocks in shaft
  if settings[:ammo] == 1
    sleep 1
    waitrt?
    waitrt?
    get_knife(settings) if settings[:paint] != 0 or settings[:paintstick1].length != 0  or settings[:paintstick2].length != 0
    haste!
    fput "cut nock in my shaft with my #{settings[:knife]}"
    fput "cut nock in my shaft with my #{settings[:knife]}" if settings[:paint] == 0 and settings[:paintstick1].length == 0  and settings[:paintstick2].length == 0
    sleep 2
    waitrt?
    if checkright !~ /shaft/
      stow("left",settings[:sack])
      return
    end
    stow("left",settings[:sack])
  end

  if settings[:learning]
    #set something up to search for waste barrel and put right in it.
    fput "drop right"
    fput "clean table"
    return
  end

  #measure shaft
  waitrt?
  check = dothistimeout "remove my #{settings[:bow]}", 1, /You unsling|remove what?|You sling/
  if check =~ /remove what?/
    echo "Failed to get your #{settings[:bow]}."
    exit
  elsif check.nil?
    endtime = Time.now + 5
    loop {
      if checkleft =~ /bow|crossbow/
        break
      elsif Time.now > endtime
        echo "Failed to get your bow."
        exit
      else
        sleep 1
      end
      }
  end
  haste!
  check = dothistimeout "measure my shaft with my #{settings[:bow]}", 3, /a tiny cut on the shaft/
  if check.nil?
    echo "failed, do something about this later"
    exit
  end
  sleep 1
  waitrt?
  check = dothistimeout "wear my #{settings[:bow]}", 3, /You sling/
  if check.nil?
    echo "failed, do something about this later"
    exit
  end
  get_knife(settings)
  haste!
  check = dothistimeout "cut my shaft with my  #{settings[:knife]}", 3, /Using your previous mark as a guide, you cleanly slice the end off|You might want to think about attaching fletchings first|you should paint or crest your shafts before cutting them to length/
  if check.nil?
    echo "failed, do something about this later"
    exit
  end
  if check =~ /you should paint or crest your shafts before cutting them to length/
    fput "cut my shaft with my #{settings[:knife]}"
  end
  sleep 1
  waitrt?
  if checkright !~ /shaft/
    stow("left",settings[:sack])
    return
  end
  stow("left",settings[:sack])

  fput "get my glue"
  endtime = Time.now + 6
  loop{

    if checkleft =~ /glue/
      break
    elsif Time.now > endtime
      "Failed to get glue"
      exit
    else
      sleep 0.1
    end
  }

  haste!
  check = dothistimeout "put my glue on my shaft", 3, /You carefully smear a bit of glue/
  if check.nil?
    echo "failed, do something about this later"
    exit
  end
  sleep 1
  waitrt?
  stow("left",settings[:sack])

  fput "get 3 fletching in my #{settings[:sack]}"
  endtime = Time.now + 6
  loop{
    if checkleft =~ /fletching/
      break
    elsif Time.now > endtime
      "Failed to get fletchings"
      exit
    else
      sleep 0.1
    end
  }

  haste!
  check = dothistimeout "put my fletching on my shaft", 3, /You attach your|Unfortunately, the glue is now too dry to remove them and try again, so you discard /
  if check =~/Unfortunately, the glue is now too dry to remove them and try again, so you discard /
    return
  end
  if !(checkright =~ /shaft/ and checkleft.nil?)
    echo "failed, do something about this later"
    exit
  end
  check = matchtimeout 60, "has dried."
  if check == false
    echo "didnt see glue dry for some reason, stopping"
    exit
  end
  waitrt?
  if checkright !~ /shaft/
    stow("left",settings[:sack])
    return
  end

  # Portion about adding arrow head.
# check = dothistimeout "get 1 triangle cap", 1, /You (get|remove)/
# if check.nil?
#   echo "failed to get your tip"
#   exit
# end
#
# check = dothistimeout "turn my cap", 2, /secure in place with an amazingly tight fit/
# if check.nil?
#   echo "failed to apply your tip"
#   exit
# end

  get_knife(settings)
  haste!
  put "cut my shaft with my  #{settings[:knife]}"
  put "cut my shaft with my  #{settings[:knife]}"
  check = matchtimeout 6, "With a few quick cuts,", "Working a bit too hastily, you slice the end right off!"
  if check == false
    echo "didnt see you cut the shaft for some reason, stopping"
    exit
  end

  waitrt?
  stow("left",settings[:sack])


end


container_contents = nil
needed_items = nil
start_time = Time.now
arrows_made = 0
arrows_failed = 0
spent_silver = 0
finished = false

if variable[0] =~ /setup|config|configure/i
  setup.call
  exit
elsif variable[0] =~ /bundle/i
  bundle(settings)
  exit
elsif !variable[0].nil?
  message = ""
  message += "This script needs a map room if you want it to buy items for you. If this is the case when ever you run out of an item the script will run and buy more\r\n"
  message += "Run ;fletchit setup at any times to change you settings\r\n"
  message += "Anytime the script is running ;fletchit will give you a progress report. ;fletchit stop will tell the script to end after finishing the arrow it is curently on. This is the prefered method of stopping, partially cut shafts left in a container migt cause the script to fail\r\n"

  if !$fake_stormfront
    puts "<output class=\"mono\"/>#{monsterbold_start}#{message}#{monsterbold_end}\r\n<output class=\"\"/>"
  else
    puts "#{monsterbold_start}#{message}#{monsterbold_end}"
  end
  exit
end


fletching_report = proc { |client_string|
    if client_string =~ /^(?:<c>)?#{$clean_lich_char}(?:fletchit)$/i

        respond ""
    respond "Script has been running for #{Time.at(Time.now - start_time).strftime("%H hours, %M minutes %S seconds")}, made #{arrows_made} arrows, ruined #{arrows_failed} arrows and spent #{spent_silver} silver"
    respond ""
  elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}fletchit (?:stop|done|end|finish|finished)$/i
    finished = true
    respond ""
    respond "Once current arrow is complete script will end"
    respond ""
    else
        client_string
    end
}

UpstreamHook.add('fletching_hook', fletching_report)
before_dying{;UpstreamHook.remove('fletching_hook');}

warning = ""
if settings[:sack] == "" or settings[:sack].nil?
  warning += "The container for you supplies has not yet been set, the script will not run until this is added.\r\n"
end
if settings[:quiver] == "" or settings[:quiver].nil?
  warning += "The container for you finished arrows has not yet been set, the script will not run until this is added.\r\n"
end
if settings[:knife] == ""
  warning += "Have not set a knife/dagger to cut the shafts with, the script will not run until this is added.\r\n"
end
if settings[:bow] == ""
  warning += "Have not set a bow to measure the shafts with, the script will not run until this is added.\r\n"
end
if settings[:axe] == ""
  warning += "Have not set an axe to make shafts with, the script will not run until this is added.\r\n"
end
if settings[:wood] == ""
  warning += "Have not set a what wood you want to use, the script will not run until this is added.\r\n"
end
if settings[:wood] != "" and settings[:wood] !~ /wood|log/
  warning += "You have set what wood you want to use but appears you may have done so incorrectly. It should read along the lines of 'limb of wood' or 'branch of faewood' for example. Leave off any a/an/some from the start\r\n"
end
if settings[:fletchings] != "" and settings[:fletchings] !~ /fletching/
  warning += "You have set what fletchings you want to use but appears you may have done so incorrectly. It should read along the lines of 'bundle of fletchings' for example. Leave off any a/an/some from the start.\r\n"
end

if warning.length > 0
  if !$fake_stormfront
    puts "<output class=\"mono\"/>#{monsterbold_start}#{warning}#{monsterbold_end}\r\n<output class=\"\"/>"
  else
    puts "#{monsterbold_start}#{warning}#{monsterbold_end}"
  end
  setup.call
  exit
end
if settings[:alerts]
  monitor_interaction()
end
empty_left_hand
empty_right_hand
loop{
  if settings[:waggle]
    start_script "waggle"
    wait_while {running?("waggle")}
  end
  fletch_sack_contents = get_container_contents(settings[:sack])
  needed_items = check_needed_items(settings,fletch_sack_contents,paints)
  if !needed_items.empty?
    if !settings[:enable_buying]
      echo "Run out of #{needed_items[0]} and the script is not set to buy more, ';fletchit setup' to change this."
      exit
    end
    respond ""
    needed_items.each{|item|
      respond "Out of #{item}"
    }
    respond "Off to buy"
    respond ""
    sleep 1
    spent_silver += buy_items(settings, needed_items)
    needed_items = Array.new
  end
  fletch_sack_contents = get_container_contents(settings[:sack])
  make_shafts(settings) if fletch_sack_contents.to_s.include? '@noun="wood"'

  if settings[:learning]
    #if percentmind > 55
    # fput "boost long"
    #end
    wait_while { percentmind > 70 }
  end

  make_arrow(settings,paints)
  if !(checkright =~ /arrow|bolt/).nil?
    echo "stowing"
    stow("right",settings[:quiver])
    arrows_made += 1
  else
    arrows_failed += 1
  end

  if !settings[:learning]
    respond ""
    respond "Script has been running for #{Time.at(Time.now - start_time).strftime("%H hours, %M minutes %S seconds")}, made #{arrows_made} arrows, ruined #{arrows_failed} arrows and spent #{spent_silver} silver"
    respond ""
  end
  exit if finished
  exit if settings[:limit].to_i > 0 and arrows_made == settings[:limit].to_i
  }



#You take a deep breath as you realize with pride that you have mastered the skill of fletching!
