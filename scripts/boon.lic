##quiet
## vim: set ft=ruby:
=begin

    Code mostly derived from SpiffyLoot by SpiffyJr
  Was specifically asked to remove sloot2 so I did. However, I have friends that use this as well so I renamed it to
  prevent confusion while allowing me to maintain this spin-off project.

       todo: add weapon pickup by name
     author: Steworaeus
     name: boon
       tags: personal
    version: 3.4

    changelog:
        3.0 (2015-11-19)
            Add massive boulder skinning as a rolled up krynch sushi roll
        3.1 (2016-01-27)
            Added ability to try and sell boxes at pawn (useful for after a lockpick session if you keep mithril ones)
            Added ability to sell scarabs at the gemshop
        3.2 (2016-06-19)
            Updated the get_item and put_item code to not care about your container
    3.3 (2017-02-18)
      Updated to use spiders in spidersilk bags.
    3.4 (2017-10-06)
      Updated to appraise gems and only sell ones below a set value you provide.
=end

putregex = /^You (?:put|(?:discreetly )?tuck|attempt to shield your|place|.* place|slip|wipe off the blade and sheathe|absent-mindedly drop|carefully add|find an incomplete bundle|untie your drawstring pouch)|^The .+ is already a bundle|^Your bundle would be too large if you if you tried to add that|^The .+ is too large to be bundled\.|^As you place your .+ inside your .+, you notice another .+ inside the .+ and carefully arrange the two .+ into a neat bundle\./

settings                   = CharSettings.to_hash
settings['skin_exclude'] ||= Array.new
settings['loot_exclude'] ||= "drake|feras|black ora"
settings['sell_exclude'] ||= "gold ring|(?:gold|aquamarine) wand|(?:white|black) crystal"

$sloot_has_disk  ||= false
$sloot_disk_full ||= false
$sloot_searched  ||= false
$sloot_hooks     ||= Array.new
$spiders       = false
$sell_no_spider    = false

closed_sacks        = Array.new
prev_stance         = checkstance
skin_prepared       = false
skin_empty_hands    = false
sacks               = Hash.new
skinweaponcurrent   = nil
skinweapon          = nil
skinweaponblunt     = nil

change_stance = proc { |stance|
    loop {
        break if (checkstance == stance) or (stance == 'defensive' and checkstance 80)

        res = dothistimeout "stance #{stance}", 2, /You are now|Roundtime|Wait|wait|You move into/
        if res =~ /Roundtime: (\d+)|wait (\d+)/i
            sleep (($1 or $2).strip.to_f - 1)
        end
    }
}

go2 = proc { |room|
    next if Room.current.id.to_s == room.to_s

    wait_while{ running?('go2') }
    start_script('go2', [ room.to_s, '_disable_confirm_' ]);
    wait_while{ running?('go2') }
}

msg = proc { |str|
    echo str
}

setup = proc {
    gtk_globals = Hash.new
    gtk_locals = Hash.new

    window = window_action = nil

    Gtk.queue {
#        ttips = Gtk::Tooltips.new.enable
        ttips_text = {
            'enable_close_sacks' => "Checking this will attempt to keep your sacks closed.",
            'overflowsack' => "Enter your overflow sack(s) to place loot into when your regular sack is full.\ne.g., \"pack,sack,cloak,hat\"",
            'loot_exclude' => "Regular expression used to exclude certain loot, e.g. \"feras|drake\".",
            'critter_exclude' => "Regular expression used to exclude certain critters, e.g. \"skayl|lava golem\".",
            'enable_search_all' => "Checking this enables searching all dead critters rather than one at a time.",
            'enable_disking' => "Checking this enables disking of boxes if you have a disk.",
            'enable_phasing' => "Checking this enables phasing of boxes if you meet the requirements.\nRequires: level 4 Sorcerer with 704 learned",
            'enable_gather' => "Checking this enables gathering of ammunition after looting.",
            'ammo_name' => "Enter the full name of your ammunition here.",
            'enable_safe_hiding' => "Checking this enables looting only if not hiding or there are no creatures present.",
            'safe_ignore' => "Enter the name of any creatures you want to ignore when safe hiding.\nThis field is a regular expression so use \"|\" to separate names.",
            'enable_stow_left' => "Checking this will store your left hand to loot if your hands are full.",
            'enable_self_drops' => "Checking this enables looting of items that were dropped from creatures you searched.",
            'enable_skinning' => "Checking this enables all skinning functionality.",
            'enable_stance_on_start' => "Check this enables stancing to defensive when starting sloot.",
            'enable_skin_alternate' => "Checking this enables an alternate weapon for skinning.",
            'enable_skin_offensive' => "Checking this enables skinning in offensive for a slight success increase (not proven).",
            'enable_skin_kneel' => "Checking this enables skinning while kneeling for a slight success increase.",
            'enable_skin_safe_mode' => "Checking this enables safe mode and will only stance/kneel if there are no alive critters present.",
            'enable_skin_604' => "Checking this enables the use of 604 (Skinning) if you meet the requirements.\nRequires: level 6 Ranger with 606 learned",
            'enable_skin_sigil' => "Checking this enables the use of Sigil of Resolve if you meet the requirements.\nRequires: GoS member with Sigil of Resolve learned",
            'enable_skin_stats' => "Checking this enables skinning statistics. You can view them by using ;sloot stats.",
            'enable_skin_stance_first' => "Checking this enables stancing to previous stance before standing. This is disabled by default to prevent incuring additional roundtime from standing in defensive.",
            'skin_stand_verb' => "Enter the stand verb if you don't want to use the default STAND verb.\ne.g., \"rgambit tumble left\"",
            'enable_sell_chronomage' => "Checking this enables giving gold rings to the Chronomage during the sell process for credit towards a Chronomage ride.",
            'enable_sell_share_silvers' => "Checking this enables sharing all silvers with the group before depositing and gives them a few seconds to deposit their coins.",
            'sell_withdraw' => "Enter an amount to withdraw after the sell process completes. This is useful for towns with gate fees such as Icemule Trace.",
            'enable_sell_locksmith' => "Checking this enables the use the NPC locksmith to open your boxes.",
            'enable_sell_wait_line' => "Checking this enables waiting at the locksmith if another person is present.",
            'enable_sell_stockpile' => "Checking this enables stockpiling of gems so that they can be turned in later for bounties. This requires you to have empty jars from the alchemist available in your locker.",
            'enable_sell_force_bounty_gems' => "Checking this enables selling of gems for bounties even if you normally have gem selling disabled.",
            'sell_stockpile_locker' => "Enter the room number just OUTSIDE of where your locker is.",
            'sell_exclude' => "Regular expression used to exclude loot from being sold, e.g., \"wand|crystal\""
        }
echo gtk_globals
        gtk_globals['ammosack'] = Gtk::Entry.new#.set_text("Use this one!")#(UserVars.ammosack)
    if UserVars.ammosack.class == String
      echo "Yep, ammosack is a string."
      gtk_globals['ammosack'].set_text("It's a string, dammit!")
    end
echo gtk_globals
echo gtk_globals['ammosack']
        gtk_globals['boxsack'] = Gtk::Entry.new.set_text(UserVars.boxsack)
        gtk_globals['foragesack'] = Gtk::Entry.new.set_text(UserVars.foragesack ||= "")
        gtk_globals['gemsack'] = Gtk::Entry.new.set_text(UserVars.gemsack ||= "")
        gtk_globals['herbsack'] = Gtk::Entry.new.set_text(UserVars.herbsack ||= "")
        gtk_globals['jewelrysack'] = Gtk::Entry.new.set_text(UserVars.jewelrysack ||= "")
        gtk_globals['lockpicksack'] = Gtk::Entry.new.set_text(UserVars.lockpicksack ||= "")
        gtk_globals['magicsack'] = Gtk::Entry.new.set_text(UserVars.magicsack ||= "")
        gtk_globals['reagentsack'] = Gtk::Entry.new.set_text(UserVars.reagentsack ||= "")
        gtk_globals['scrollsack'] = Gtk::Entry.new.set_text(UserVars.scrollsack ||= "")
        gtk_globals['skinsack'] = Gtk::Entry.new.set_text(UserVars.skinsack ||= "")
        gtk_globals['uncommonsack'] = Gtk::Entry.new.set_text(UserVars.uncommonsack ||= "")
        gtk_globals['valuablesack'] = Gtk::Entry.new.set_text(UserVars.valuablesack ||= "")
        gtk_globals['clothingsack'] = Gtk::Entry.new.set_text(UserVars.clothingsack ||= "")
        gtk_globals['wandsack'] = Gtk::Entry.new.set_text(UserVars.wandsack ||= "")
        gtk_globals['skinweapon'] = Gtk::Entry.new.set_text(UserVars.skinweapon ||= "")
        gtk_globals['skinweaponblunt'] = Gtk::Entry.new.set_text(UserVars.skinweaponblunt ||= "")
        gtk_globals['skinweaponsack'] = Gtk::Entry.new.set_text(UserVars.skinweaponsack ||= "")
    gtk_globals['weaponsack'] = Gtk::Entry.new.set_text(UserVars.weaponsack ||= "")
    gtk_locals['overflowsack'] = Gtk::Entry.new.set_text(settings['overflowsack'] ||= "")
        gtk_locals['enable_close_sacks'] = Gtk::CheckButton.new('(?) Keep sacks shut').set_active(settings['enable_close_sacks'] ? nil : false)
        gtk_locals['loot_exclude'] = Gtk::Entry.new.set_text(settings['loot_exclude'] ||= "")
        gtk_locals['critter_exclude'] = Gtk::Entry.new.set_text(settings['critter_exclude'] ||= "")
    gtk_locals['weapon_include'] = Gtk::Entry.new.set_text(settings['weapon_include'] ||= "")
        gtk_locals['enable_search_all'] = Gtk::CheckButton.new('(?) Search all dead').set_active(settings['enable_search_all'] ? nil : false)
        gtk_locals['enable_loot_box'] = Gtk::CheckButton.new('Boxes').set_active(settings['enable_loot_box'] ? nil : false)
        gtk_locals['enable_loot_gem'] = Gtk::CheckButton.new('Gems').set_active(settings['enable_loot_gem'] ? nil : false)
        gtk_locals['enable_loot_herb'] = Gtk::CheckButton.new('Herbs').set_active(settings['enable_loot_herb'] ? nil : false)
        gtk_locals['enable_loot_jewelry'] = Gtk::CheckButton.new('Jewelry').set_active(settings['enable_loot_jewelry'] ? nil : false)
        gtk_locals['enable_loot_lockpick'] = Gtk::CheckButton.new('Lockpicks').set_active(settings['enable_loot_lockpick'] ? nil : false)
        gtk_locals['enable_loot_magic'] = Gtk::CheckButton.new('Magical').set_active(settings['enable_loot_magic'] ? nil : false)
        gtk_locals['enable_loot_reagent'] = Gtk::CheckButton.new('Reagents').set_active(settings['enable_loot_reagent'] ? nil : false)
        gtk_locals['enable_loot_scroll'] = Gtk::CheckButton.new('Scrolls').set_active(settings['enable_loot_scroll'] ? nil : false)
        gtk_locals['enable_loot_skin'] = Gtk::CheckButton.new('Skins').set_active(settings['enable_loot_skin'] ? nil : false)
        gtk_locals['enable_loot_uncommon'] = Gtk::CheckButton.new('Uncommon').set_active(settings['enable_loot_uncommon'] ? nil : false)
        gtk_locals['enable_loot_valuable'] = Gtk::CheckButton.new('Valuables').set_active(settings['enable_loot_valuable'] ? nil : false)
        gtk_locals['enable_loot_clothing'] = Gtk::CheckButton.new('Clothings').set_active(settings['enable_loot_clothing'] ? nil : false)
        gtk_locals['enable_loot_wand'] = Gtk::CheckButton.new('Wands').set_active(settings['enable_loot_wand'] ? nil : false)
    gtk_locals['enable_loot_weapon'] = Gtk::CheckButton.new('Weapon').set_active(settings['enable_loot_weapon'] ? nil : false)
        gtk_locals['enable_disking'] = Gtk::CheckButton.new('(?) Disking').set_active(settings['enable_disking'] ? nil : false)
        gtk_locals['enable_phasing'] = Gtk::CheckButton.new('(?) Phasing').set_active(settings['enable_phasing'] ? nil : false)
        gtk_locals['enable_gather'] = Gtk::CheckButton.new('(?) Gather ammo').set_active(settings['enable_gather'] ? nil : false)
        gtk_locals['ammo_name'] = Gtk::Entry.new.set_text(settings['ammo_name'] ||= "")
    gtk_locals['use_spiders'] = Gtk::CheckButton.new('(?) Use Spiders').set_active(settings['use_spiders'] ? nil : false)
        gtk_locals['spider_bag'] = Gtk::Entry.new.set_text(settings['spider_bag'] ||= "")
        gtk_locals['enable_safe_hiding'] = Gtk::CheckButton.new('(?) Safe hiding').set_active(settings['enable_safe_hiding'] ? nil : false)
        gtk_locals['safe_ignore'] = Gtk::Entry.new.set_text(settings['safe_ignore'] ||= "")
        gtk_locals['enable_stow_left'] = Gtk::CheckButton.new('(?) Stow left hand').set_active(settings['enable_stow_left'] ? nil : false)
        gtk_locals['enable_stance_on_start'] = Gtk::CheckButton.new('(?) Stance on start').set_active(settings['enable_stance_on_start'] ? nil : false)
        gtk_locals['enable_self_drops'] = Gtk::CheckButton.new('(?) Self loot only').set_active(settings['enable_self_drops'] ? nil : false)
        gtk_locals['enable_skinning'] = Gtk::CheckButton.new('(?) Enable skinning').set_active(settings['enable_skinning'] ? nil : false)
        gtk_locals['enable_skin_alternate'] = Gtk::CheckButton.new('(?) Enable alternate').set_active(settings['enable_skin_alternate'] ? nil : false)
        gtk_locals['enable_skin_offensive'] = Gtk::CheckButton.new('(?) Skin in offensive').set_active(settings['enable_skin_offensive'] ? nil : false)
        gtk_locals['enable_skin_kneel'] = Gtk::CheckButton.new('(?) Kneel to skin').set_active(settings['enable_skin_kneel'] ? nil : false)
        gtk_locals['enable_skin_safe_mode'] = Gtk::CheckButton.new('(?) Safe mode').set_active(settings['enable_skin_safe_mode'] ? nil : false)
        gtk_locals['enable_skin_stance_first'] = Gtk::CheckButton.new('(?) Stance first').set_active(settings['enable_skin_stance_first'] ? nil : false)
        gtk_locals['enable_skin_604'] = Gtk::CheckButton.new('(?) Use 604').set_active(settings['enable_skin_604'] ? nil : false)
        gtk_locals['enable_skin_sigil'] = Gtk::CheckButton.new('(?) Use Sigil of Resolve').set_active(settings['enable_skin_sigil'] ? nil : false)
        gtk_locals['enable_skin_stats'] = Gtk::CheckButton.new('(?) Track statistics').set_active(settings['enable_skin_stats'] ? nil : false).set_sensitive(false)
        gtk_locals['skin_stand_verb'] = Gtk::Entry.new.set_text(settings['skin_stand_verb'] ||= "")
        gtk_locals['enable_sell_type_gem'] = Gtk::CheckButton.new('Gems').set_active(settings['enable_sell_type_gem'] ? nil : false)
        gtk_locals['enable_sell_type_valuable'] = Gtk::CheckButton.new('Valuables').set_active(settings['enable_sell_type_valuable'] ? nil : false)
        gtk_locals['enable_sell_type_clothing'] = Gtk::CheckButton.new('Clothings').set_active(settings['enable_sell_type_clothing'] ? nil : false)
        gtk_locals['enable_sell_type_jewelry'] = Gtk::CheckButton.new('Jewelry').set_active(settings['enable_sell_type_jewelry'] ? nil : false)
        gtk_locals['enable_sell_type_lockpick'] = Gtk::CheckButton.new('Lockpicks').set_active(settings['enable_sell_type_lockpick'] ? nil : false)
        gtk_locals['enable_sell_type_magic'] = Gtk::CheckButton.new('Magical').set_active(settings['enable_sell_type_magic'] ? nil : false)
        gtk_locals['enable_sell_type_reagent'] = Gtk::CheckButton.new('Reagents').set_active(settings['enable_sell_type_reagent'] ? nil : false)
        gtk_locals['enable_sell_type_scroll'] = Gtk::CheckButton.new('Scrolls').set_active(settings['enable_sell_type_scroll'] ? nil : false)
        gtk_locals['enable_sell_type_skin'] = Gtk::CheckButton.new('Skins').set_active(settings['enable_sell_type_skin'] ? nil : false)
        gtk_locals['enable_sell_type_scarab'] = Gtk::CheckButton.new('Scarabs to gemshop').set_active(settings['enable_sell_type_scarab'] ? nil : false)
        gtk_locals['enable_sell_type_empty_box'] = Gtk::CheckButton.new('Boxes as empties').set_active(settings['enable_sell_type_empty_box'] ? nil : false)
        gtk_locals['enable_sell_type_wand'] = Gtk::CheckButton.new('Wands').set_active(settings['enable_sell_type_wand'] ? nil : false)
        gtk_locals['enable_sell_chronomage'] = Gtk::CheckButton.new('(?) Rings -> Chrono').set_active(settings['enable_sell_chronomage'] ? nil : false)
        gtk_locals['enable_sell_share_silvers'] = Gtk::CheckButton.new('(?) Share silvers').set_active(settings['enable_sell_share_silvers'] ? nil : false)
        gtk_locals['sell_withdraw'] = Gtk::Entry.new.set_text(settings['sell_withdraw'] ||= "")
        gtk_locals['enable_sell_locksmith'] = Gtk::CheckButton.new('(?) Enable locksmith').set_active(settings['enable_sell_locksmith'] ? nil : false)
        gtk_locals['enable_sell_wait_line'] = Gtk::CheckButton.new('(?) Wait in line').set_active(settings['enable_sell_wait_line'] ? nil : false).set_sensitive(false)
        gtk_locals['enable_sell_stockpile'] = Gtk::CheckButton.new('(?) Stockpile gems').set_active(settings['enable_sell_stockpile'] ? nil : false)
        gtk_locals['enable_stockpile_orbsanddeeds'] = Gtk::CheckButton.new('(?) Stockpile Orbs and Deeds').set_active(settings['enable_stockpile_orbsanddeeds'] ? nil : false)
    gtk_locals['enable_sell_force_bounty_gems'] = Gtk::CheckButton.new('(?) Force sell gems').set_active(settings['enable_sell_force_bounty_gems'] ? nil : false).set_sensitive(false)
        gtk_locals['sell_stockpile_locker'] = Gtk::Entry.new.set_text(settings['sell_stockpile_locker'] ||= "")

        gtk_locals['sell_exclude'] = Gtk::Entry.new.set_text(settings['sell_exclude'] ||= "")

    gtk_locals['orb_value'] = Gtk::Entry.new.set_text(settings['orb_value'] ||= "")

        # Signals
        gtk_locals['ammo_name'].sensitive = gtk_locals['enable_gather'].active?
        gtk_locals['enable_gather'].signal_connect('toggled') { gtk_locals['ammo_name'].sensitive = gtk_locals['enable_gather'].active? }

        gtk_locals['safe_ignore'].sensitive = gtk_locals['enable_safe_hiding'].active?
        gtk_locals['enable_safe_hiding'].signal_connect('toggled') { gtk_locals['safe_ignore'].sensitive = gtk_locals['enable_safe_hiding'].active? }

        # Add tooltips
#        ttips_text.each_pair { |widget,tip|
#            if widget = gtk_globals[widget] or gtk_locals[widget]
#                ttips.set_tooltip_text(widget,tip,'')
#            end
#        }

        # Primary Window
        window = Gtk::Window.new
        window.title = "SLoot configuration for #{Char.name}"
        window.border_width = 3
        window.resizable = false
        window.resize(450, 300)

        # Notebooks for tabs at the top
        nb = Gtk::Notebook.new.set_show_border(true)
    #.set_tab_border(3)  seems deprecated with no equivalent

        #
        # Notebook Page 1 - Sacks
        #
        vb_pg1 = Gtk::Box.new(:vertical,1)
    vb_pg1.set_border_width(3)

        #
        # Page 1, Frame 1 - Sacks
        #
        vb_pg1_1 = Gtk::Box.new(:vertical,1)
    vb_pg1_1.set_border_width(3)
        fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Sacks</b></big>'))
        fr_pg1_1.add(vb_pg1_1)
        vb_pg1.pack_start(fr_pg1_1, :expand => false, :fill => false, :padding => 0)

        lbl = Gtk::Label.new.set_markup("SLoot features sorting of loot by allowing you to specify " +
            "a sack for each type of loot. Use the fields below to set the sack(s) for " +
            "each loot type.")
        lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
        vb_pg1_1.pack_start(lbl, :expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Ammunition:')).set_width_request(100))
        hb.pack_start(gtk_globals['ammosack'], :expand => false, :fill => true, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Boxes:')).set_width_request(100))
        hb.pack_start(gtk_globals['boxsack'],:expand => false, :fill => false, :padding => 0)
        vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Gems:')).set_width_request(100))
        hb.pack_start(gtk_globals['gemsack'],:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Herbs:')).set_width_request(100))
        hb.pack_start(gtk_globals['herbsack'],:expand => false, :fill => false, :padding => 0)
        vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Jewelry:')).set_width_request(100))
        hb.pack_start(gtk_globals['jewelrysack'],:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Lockpicks:')).set_width_request(100))
        hb.pack_start(gtk_globals['lockpicksack'],:expand => false, :fill => false, :padding => 0)
        vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Magical:')).set_width_request(100))
        hb.pack_start(gtk_globals['magicsack'],:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Reagents:')).set_width_request(100))
        hb.pack_start(gtk_globals['reagentsack'],:expand => false, :fill => false, :padding => 0)
        vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Scrolls:')).set_width_request(100))
        hb.pack_start(gtk_globals['scrollsack'],:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Skins:')).set_width_request(100))
        hb.pack_start(gtk_globals['skinsack'],:expand => false, :fill => false, :padding => 0)
        vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Uncommon:')).set_width_request(100))
        hb.pack_start(gtk_globals['uncommonsack'],:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Wands:')).set_width_request(100))
        hb.pack_start(gtk_globals['wandsack'],:expand => false, :fill => false, :padding => 0)
        vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Clothings:')).set_width_request(100))
        hb.pack_start(gtk_globals['clothingsack'],:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Valuables:')).set_width_request(100))
        hb.pack_start(gtk_globals['valuablesack'],:expand => false, :fill => false, :padding => 0)
        vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
    hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Weapons:')).set_width_request(100),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(gtk_globals['weaponsack'],:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Overflow:')).set_width_request(100),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(gtk_locals['overflowsack'],:expand => false, :fill => false, :padding => 0)
        vb_pg1_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        #
        # Page 1, Frame 2 - Advanced Options
        #
        vb_pg1_2 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg1_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced Options</b></big>'))
        fr_pg1_2.add(vb_pg1_2)
        vb_pg1.pack_start(fr_pg1_2,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_close_sacks'].set_width_request(150)),:expand => false, :fill => false, :padding => 0)
        vb_pg1_2.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        lbl = Gtk::Label.new.set_markup("<span color=\"blue\" weight=\"bold\">Tip: (?) " +
            "in front of any option means you can hover over it for additional information.</span>")
        lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
        vb_pg1_1.pack_start(lbl,:expand => false, :fill => false, :padding => 0)

        nb.append_page(vb_pg1,Gtk::Label.new('Sacks'))

        #
        # Notebook Page 2 - Looting
        #
        vb_pg2 = Gtk::Box.new(:vertical,1).set_border_width(3)

        #
        # Page 2, Frame 1 - Looting
        #
        vb_pg2_1 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg2_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Looting</b></big>'))
        fr_pg2_1.add(vb_pg2_1)
        vb_pg2.pack_start(fr_pg2_1,:expand => false, :fill => false, :padding => 0)

        lbl = Gtk::Label.new.set_markup("Use the options below to specify how " +
        "SLoot behaves when looting. Each checkbox represents a loot category which SLoot will only " +
        "pickup if checked. You can also enabled advanced features such as autolooting, disking/phasing " +
        "of boxes, and looting drops from critters you search.")
        lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
        vb_pg2_1.pack_start(lbl,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Exclude critters:')).set_width_request(100),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['critter_exclude'].set_width_request(419)))
        vb_pg2_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Exclude loot:')).set_width_request(100),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['loot_exclude'].set_width_request(419)))
        vb_pg2_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_search_all'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg2_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_box'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_gem'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_herb'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_jewelry'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg2_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_lockpick'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_magic'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_reagent'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_scroll'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg2_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_skin'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_wand'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_uncommon'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_valuable'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg2_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_clothing'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
    hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_weapon'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)

        vb_pg2_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        #
        # Page 2, Frame 1 - Looting
        #
        vb_pg2_2 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg2_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced Options</b></big>'))
        fr_pg2_1.add(vb_pg2_2)
        vb_pg2.pack_start(fr_pg2_1,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_disking'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_stow_left'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_self_drops'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_stance_on_start'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)

        if Char.prof == 'Sorcerer' and Char.level > 3 and Spell[704].known?
            hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_phasing'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        end

        vb_pg2_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,0).add(gtk_locals['enable_safe_hiding'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(gtk_locals['safe_ignore'],:expand => false, :fill => false, :padding => 0)
        vb_pg2_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,0).add(gtk_locals['enable_gather'].set_width_request(129)), :expand => false, :fill => false, :padding => 0)
        hb.pack_start(gtk_locals['ammo_name'],:expand => false, :fill => false, :padding => 0)
        vb_pg2_2.pack_start(hb, :expand => false, :fill => false, :padding => 0)

    hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,0).add(gtk_locals['use_spiders'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(gtk_locals['spider_bag'],:expand => false, :fill => false, :padding => 0)
        vb_pg2_2.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        nb.append_page(vb_pg2, Gtk::Label.new('Looting'))

        #
        # Notebook Page 3 - Skinning
        #
        vb_pg3 = Gtk::Box.new(:vertical,1).set_border_width(3)

        #
        # Page 3, Frame 1 - Skinning
        #
        vb_pg3_1 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg3_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Skinning</b></big>'))
        fr_pg3_1.add(vb_pg3_1)
        vb_pg3.pack_start(fr_pg3_1,:expand => false, :fill => false, :padding => 0)

        lbl = Gtk::Label.new.set_markup("The options below give you absolute control over skinning critters. " +
            "You can use your current weapon, an alternate weapon, left or right hand, and advanced enhancements " +
            "such as kneeling, stancing to offensive, Skinning (604) and Sigil of Resolve.")
        lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
        vb_pg3_1.pack_start(lbl,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skinning'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg3_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        #
        # Page 3, Frame 2 - Alternate Weapon
        #
        vb_pg3_2 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg3_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Alternate Skinning Weapon</b></big>'))
        fr_pg3_2.add(vb_pg3_2)
        vb_pg3.pack_start(fr_pg3_2,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_alternate'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg3_2.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Regular:')),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_globals['skinweapon']),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Sack:')),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(gtk_globals['skinweaponsack'],:expand => false, :fill => false, :padding => 0)
        vb_pg3_2.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Blunt:')),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_globals['skinweaponblunt']),:expand => false, :fill => false, :padding => 0)
        vb_pg3_2.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        #
        # Page 3, Frame 3 - Enhancements
        #
        vb_pg3_3 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg3_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Enhancements</b></big>'))
        fr_pg3_3.add(vb_pg3_3)
        vb_pg3.pack_start(fr_pg3_3,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_offensive'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_kneel'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_safe_mode'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_stance_first'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg3_3.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        if (Char.prof == 'Ranger' and Char.level > 3 and Spell[604].known?) or (Spell[9704].known?)
            hb = Gtk::Box.new(:horizontal,1)

            if Char.prof == 'Ranger' and Char.level > 3 and Spell[604].known?
                hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_604'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
            end

            if Spell[9704].known?
                hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_sigil'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
            end

            vb_pg3_3.pack_start(hb,:expand => false, :fill => false, :padding => 0)
        end

        #
        # Page 3, Frame 4 - Advanced Options
        #
        vb_pg3_4 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg3_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced Options</b></big>'))
        fr_pg3_4.add(vb_pg3_4)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_stats'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Stand verb:')).set_width_request(100),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(gtk_locals['skin_stand_verb'],:expand => false, :fill => false, :padding => 0)
        vb_pg3_4.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        vb_pg3.pack_start(fr_pg3_4,:expand => false, :fill => false, :padding => 0)

        nb.append_page(vb_pg3, Gtk::Label.new('Skinning'))

        #
        # Notebook Page 4 - Skinning
        #
        vb_pg4 = Gtk::Box.new(:vertical,1).set_border_width(3)

        #
        # Page 4, Frame 1 - Selling
        #
        vb_pg4_1 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg4_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Selling</b></big>'))
        fr_pg4_1.add(vb_pg4_1)
        vb_pg4.pack_start(fr_pg4_1,:expand => false, :fill => false, :padding => 0)

        lbl = Gtk::Label.new.set_markup("SLoot comes with a built in sell option that will sell all " +
        "loot and even open boxes at the town locksmith. Use the checkboxes to set what type of loot " +
        "you want to sell and the advanced options to customize exactly how selling operates.")
        lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
        vb_pg4_1.pack_start(lbl,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Exclude loot:')).set_width_request(100),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['sell_exclude'].set_width_request(419)))
        vb_pg4_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_gem'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_jewelry'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_lockpick'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_magic'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg4_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_reagent'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_scroll'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_skin'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_wand'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg4_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_valuable'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_clothing'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg4_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_empty_box'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_scarab'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg4_1.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        #
        # Page 4, Frame 2 - Cleanup
        #
        vb_pg4_2 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg4_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Cleanup</b></big>'))
        fr_pg4_2.add(vb_pg4_2)
        vb_pg4.pack_start(fr_pg4_2,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_chronomage'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_share_silvers'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Withdraw:')).set_width_request(100),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(gtk_locals['sell_withdraw'],:expand => false, :fill => false, :padding => 0)
        vb_pg4_2.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        #
        # Page 4, Frame 3 - Locksmith
        #
        vb_pg4_3 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg4_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Locksmith</b></big>'))
        fr_pg4_3.add(vb_pg4_3)
        vb_pg4.pack_start(fr_pg4_3,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_locksmith'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_wait_line'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        vb_pg4_3.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        #
        # Page 4, Frame 4 - Bounties
        #
        vb_pg4_4 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg4_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Bounties</b></big>'))
        fr_pg4_4.add(vb_pg4_4)
        vb_pg4.pack_start(fr_pg4_4,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_stockpile'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_force_bounty_gems'].set_width_request(129)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Locker:')).set_width_request(100),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(gtk_locals['sell_stockpile_locker'],:expand => false, :fill => false, :padding => 0)
        vb_pg4_4.pack_start(hb,:expand => false, :fill => false, :padding => 0)

    #
        # Page 4, Frame 5 - Orb and Deed Gems
        #
        vb_pg4_5 = Gtk::Box.new(:vertical,1).set_border_width(3)
        fr_pg4_5 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Orbs and Deeds</b></big>'))
        fr_pg4_5.add(vb_pg4_5)
        vb_pg4.pack_start(fr_pg4_5,:expand => false, :fill => false, :padding => 0)

        hb = Gtk::Box.new(:horizontal,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_stockpile_orbsanddeeds'].set_width_request(259)),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Orb/Deed value:')).set_width_request(100),:expand => false, :fill => false, :padding => 0)
        hb.pack_start(gtk_locals['orb_value'],:expand => false, :fill => false, :padding => 0)
        vb_pg4_5.pack_start(hb,:expand => false, :fill => false, :padding => 0)

        nb.append_page(vb_pg4, Gtk::Label.new('Selling'))

        # Save/Close buttons
        hb_saveclose = Gtk::Box.new(:horizontal)
        save = Gtk::Button.new(:label => '_Save & Close')
        close = Gtk::Button.new(:label => 'E_xit')

        save.signal_connect('clicked') { window_action = :save }
        close.signal_connect('clicked') { window_action = :done }

        hb_saveclose.pack_start(save,:expand => false, :fill => false, :padding => 0)
        hb_saveclose.pack_start(close,:expand => false, :fill => false, :padding => 0)

        # Primary VerticalBox to split up Notebook and Save/Close buttons
        vb_main = Gtk::Box.new(:vertical,5)
        vb_main.border_width = 3

        vb_main.pack_start(nb,:expand => false, :fill => false, :padding => 0)
        vb_main.pack_start(Gtk::Alignment.new(1,0,0,0).add(hb_saveclose),:expand => false, :fill => false, :padding => 0)

        window.signal_connect('delete_event') { window_action = :exit }

        window.add(vb_main)
        window.show_all
        window.keep_above = true # On windows keep_above is required AFTER show_all
    }

    before_dying { Gtk.queue { window.destroy } }
    wait_while { window_action.nil? }

    clean_entry = proc { |entry|
        entry.text = entry.text.strip
        if entry.text.empty?
            entry.text = nil
        end

        entry.text
    }

    if window_action == :save
        gtk_globals.each_pair { |option,widget|
            if widget.class == Gtk::CheckButton
                UserVars.change(option,widget.active?,:char)
            elsif widget.class == Gtk::Entry
                UserVars.change(option,clean_entry.call(widget),:char)
            else
                echo "error: unknown global widget #{option} [#{widget.class}]"
            end
        }

        gtk_locals.each_pair { |option,widget|
            if widget.class == Gtk::CheckButton
                settings[option] = widget.active?
            elsif widget.class == Gtk::Entry
                settings[option] = clean_entry.call(widget)
            else
                echo "error: unknown local widget #{option} [#{widget.class}]"
            end
        }

        echo 'settings saved'
        $lootable=nil
    else
        echo 'closed without saving'
    end
}

# Installs hooks that sloot uses to function. Will only install a hook
# once in order to increase performance.
install_hooks = proc { |type|
    if settings['enable_disking']
        if !$sloot_hooks.include?(:disk)
            $sloot_hooks.push(:disk)

            hook = proc { |server_string|
                if server_string =~ /from in the <a exist="(?:\d+)" noun="disk">.*#{Char.name} disk<\/a>|You give your disk a flip/
                    $sloot_has_disk = true
                    $sloot_disk_full = false
                elsif server_string =~ /#{Char.name} disk in a dismissing gesture./
                    $sloot_has_disk = false
                    $sloot_disk_full = false
                elsif server_string =~ /^Your <a exist=".*" noun="disk">disk<\/a> arrives|^A small circular container suddenly appears/
                    $sloot_has_disk = true
                    $sloot_disk_full = false
                elsif server_string =~ /^Your .* won't fit in the .*disk.*$/
                    $sloot_has_disk = true
                    $sloot_disk_full = true
                end

                server_string
            }

            DownstreamHook.add('SLootDisk', hook)
        end
    elsif $sloot_hooks.include?(:disk)
        DownstreamHook.remove('SLootDisk')
    end
    if !$sloot_hooks.include?(:sloot_gameobj_watcher)
        $sloot_hooks.push(:sloot_gameobj_watcher)
        sloot_gameobj_watcher_hook = proc { |server_string|
            if server_string =~ /You (?:reach out to )?search/
                $sloot_searched = true
            #elsif  $sloot_searched && server_string =~ /exist="(?<exist>.*?)".*which looks like the heirloom that you are searching for/
                #unless GameObj.loot.find { |obj| obj.id == exist }
                #    GameObj.new_loot(exist, noun, name)
                #$sloot_searched = false
            elsif $sloot_searched && server_string =~ /had nothing else of value\.|had nothing of interest\.|^A.+ body shimmers slightly, then fades from view like a dissipating phantom\.$|prompt/
                $sloot_searched = false
            elsif $sloot_searched && server_string !~ /prompt/
                for link in server_string.scan(/<a.*?>.*?<\/a>/)
                    if link =~ /<a exist="(.*?)" noun="(.*?)">(.*?)<\/a>/
                        exist, noun, name = $1, $2, $3
                        next if name =~ /^(?:he|she|it|her|his|him|its|itself)$|'s$/i
                        GameObj.new_loot(exist, noun, name) unless GameObj.loot.find { |obj| obj.id == exist } or GameObj.inv.find{|obj| obj.id == exist}
                    end
                end
            end
            server_string
        }
        DownstreamHook.add('SLootGameObjWatcher', sloot_gameobj_watcher_hook)
    end
}

# Get dem silvers
checksilvers = proc {
    silvers = nil
    action = proc { |server_string|
        if server_string !~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
            nil
        elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
            silvers = $1.to_i
            DownstreamHook.remove("slib_check_silvers")
            nil
        else
            server_string
        end
    }
    DownstreamHook.add("slib_check_silvers", action)
    $_SERVER_.puts "#{$cmd_prefix}info\n"
    wait_until { silvers }
    silvers
}

# Deposits coins in the bank
deposit_coins = proc {
    silvers = checksilvers.call.to_i
    withdraw = settings['sell_withdraw'].to_i

    if (silvers == 0 and withdraw == 0) or silvers == withdraw
        next
    end

    go2.call('bank')

    if settings['enable_sell_share_silvers'] and silvers > 1
        dothistimeout "share all", 5, /In order to share|share/
    end
    res = dothistimeout "deposit all", 5, /The teller carefully records the transaction|^You have no coins to deposit\.$/

    if (withdraw > 0)
        dothistimeout "withdraw #{withdraw} silvers", 5, /^The teller carefully records the transaction, and then hands you \d+ silvers\.$|Very well/
    end
}

# Opens up a sack and keeps a record of it
open_sack = proc { |sack|
    unless sack.class == GameObj or sack = GameObj[sack]
        echo "fixme: open_sack failed to find #{sack}"
        exit
    end

    res = dothistimeout "open ##{sack.id}", 5, /^You open .*|^Sliding the lever .*\.$/
    unless res
        echo "fixme: unknown open_sack result: #{res}"
        exit
    end

    closed_sacks.push(sack.id)
}

# Closes all opened sacks in closed_sacks
close_open_sacks = proc {
    next unless settings['enable_close_sacks']

    closed_sacks.each { |sack|
        res = dothistimeout "close ##{sack}", 5, /^You close .*\.$/
        unless res
            echo "fixme: unknown close_open_sacks result: #{res}"
            exit
        end
    }
}

# Puts an item somewhere
put_item = proc { |item,sack|
    waitrt?

    left_hand  = GameObj.left_hand
    right_hand = GameObj.right_hand

    next false unless right_hand.id == item or left_hand.id == item or checkleft =~ /#{item}/ or checkright =~ /#{item}/

    if sack.class == GameObj or sack = GameObj[sack]
        fput "put my #{item} in ##{sack.id}"
    else
        fput "put my #{item} in my #{sack}"
    end

    noun   = item.class == GameObj ? item.noun : item
    result = false
    30.times {
        if right_hand.id != item and left_hand.id != item and (not checkleft or noun !~ /#{checkleft}/) and (not checkright or noun !~ /#{checkright}/)
            result = true
            break
        end

        line = get?
        if line =~ /^You can't put .* in .*\.  It's closed\!$/
            open_sack.call(sack)
            next put_item.call(item,sack)
        elsif line =~ /^Your .* won't fit in .*\.$|find there is no space for the/
            break
        end

        sleep 0.10
    }

    result
}

# Gets an item
get_item = proc { |item, sack|
    waitrt?

    left  = GameObj.left_hand
    right = GameObj.right_hand
  spiderbag = settings['spider_bag']
    next true if right.id == item or left.id == item or checkleft =~ /#{item}/ or checkright =~ /#{item}/

    id = item.class == GameObj ? "##{item.id}" : item

    if sack.nil?
    if settings['use_spiders'] and GameObj.loot.find { |l| l.name =~ /#{item}/} and $sell_no_spider == false
      line = dothistimeout "point #{spiderbag} at #{id}", 3, /As it drags|dissolve into fine dust|few moments of rest/
      if line =~ /As it drags/
        $spiders = true
      elsif line =~ /dissolve into fine dust|few moments of rest/
        fput "get #{id}"
      end
    else
      fput "get #{id}"
    end
    elsif sack.class == GameObj or sack = GameObj[sack]
        fput "get #{id} from ##{sack.id}"
    else
        fput "get #{id} from my #{sack}"
    end

    noun   = item.class == GameObj ? item.noun : item
    result = false

  if line =~ /As it drags/
    result = true
  end
  if $spiders == false
    30.times {
      if right.id == item or left.id == item or (checkleft and noun =~ /#{checkleft}/) or (checkright and noun =~ /#{checkright}/)
        result = true
        break
      end

      line = get?
      if line =~ /is out of your reach/
        sleep 4
        next get_item.call(item, sack)
      elsif line =~ /^You can't pick that up\.$|^Get what?$|crumbles and decays away.$|crumbles into a pile of dust!$/
        break
      end

      sleep 0.10
    }
  end

    result
}

# Waits until your disk is present or a timeout occurs
check_for_disk = proc {
    disk = nil
    notified = false
    25.times {
        break if disk = GameObj[/^.*#{Char.name} (?:disk|coffin)$/]
        sleep 0.2
        unless notified
            msg.call("-- waiting on your disk to arrive")
            notified = true
        end
    }

    unless disk
        $sloot_has_disk = false
    end

    disk
}

# Withdraws coins from the bank, hooray!
withdraw_coins = proc { |amount|
    success = true
    room = Room.current.id

    coins = checksilvers.call
    if coins < amount
        go2.call('bank')

        dothistimeout "unhide", 5, /hiding|visible/ if invisible? or hiding?
        res = dothistimeout "withdraw #{amount-coins} silvers", 5, /^The teller carefully records the transaction, and then hands you \d+ silvers?\.$|I'm sorry, .*, you don't seem to have that much in the account\./
        case res
            when /I'm sorry/
                success = false
            when /^The teller carefully/
            else
                echo "unknown response for withdraw_coins: #{res}"
        end
    end

    go2.call(room)

    success
}

# Grabs loot!
grab_loot = proc { |loot,from|
    type = loot.type.split(',').first
    disk = nil

    if type == 'box' and settings['enable_disking'] and $sloot_has_disk and not $sloot_disk_full
        unless disk = check_for_disk.call
            msg.call("I can't seem to find your disk")
            $sloot_has_disk = false

            if Char.prof == 'Wizard' and Spell[511].known? and Char.level > 10
                msg.call("Hooray! You're a Weezard!")

                if Spell[511]
                    Spell[511].cast
                    disk = check_for_disk.call
                else
                    msg.call("No mana, aborting.")
                end
            end
        end
    end

    unless sack = sacks[type]
        msg.call("unable to find sack for \"#{loot.name}\" with type \"#{loot.type}\"")
        msg.call("to loot manually, ;p #{script.name}")
        msg.call("you have 5 seconds to pause me")
        fput "look in ##{loot.id}"
        sleep 5
        next
    end

    unless get_item.call(loot,from)
        msg.call("failed to get item \"#{loot.name}\" from \"#{sack.name}\"")
    else
        if disk and put_item.call(loot,disk)
            next
        elsif type == 'box' and settings['enable_phasing'] and Spell[704].known? and Spell[704].affordable? and Char.level > 3 and loot.name !~ /mithril|enruned/
            right_hand = true
            right_hand = false if GameObj.left_hand.id == loot.id

            dothistimeout "prep 704", 5, /Phase/
            res = dothistimeout "cast ##{loot.id}", 5, /somewhat insubstantial|flickers in and out|becomes momentarily|resists the effects/

            # Phased items get a different id so refresh the loot GameObj
            if res =~ /becomes momentarily/
                if right_hand
                    wait_while { GameObj.right_hand.noun.nil? }
                    loot = GameObj.right_hand
                else
                    wait_while { GameObj.left_hand.noun.nil? }
                    loot = GameObj.left_hand
                end
            end
        end

        unless put_item.call(loot,sack)
            result = false
            settings['overflowsack'].split(',').each { |overflow|
                if put_item.call(loot,overflow)
                    puts "#{overflow}"
          sacks[type] = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(overflow.strip)}/i }
          result = true
                    break
                end
            }

            if result == false && $spiders == false
        msg.call("failed to put item \"#{loot.name}\" in sack \"#{sack.name}\" or overflow containers")
                fput "drop ##{loot.id}"
            end
        end
    end
}

# Frees up the loot hand
free_hand = proc {
    next if checkleft.nil? or checkright.nil?

    if UserVars.lootsack.nil?
        msg.call("warning: attempting to empty hand using lich function but no loostack has been set")
    end

    if settings['enable_stow_left']
        empty_left_hand
    else
        empty_right_hand
    end
}

# Loots a single GameObj or an array of GameObjs
loot_it = proc { |array,exclude|
    next if array.nil?
    unless array.class == Array
        array = [ array ]
    end

    if CharSettings['loot_exclude'].to_s.length > 0
        array.delete_if { |loot| loot.name =~ /#{CharSettings['loot_exclude']}/ }
    end

    array.each { |loot|
        next if loot.name =~ /severed.*(?:arm|leg)/

        # Skip over any loot that is in the exclude array
        if exclude.include?(loot.id)
            exclude.delete(loot.id)
            next
        end

        # Make sure that the loot type is something we want to pickup
        if loot.type.split(',').any? { |type| settings["enable_loot_#{type}"] }
            free_hand.call() unless GameObj.right_hand.id == loot.id or GameObj.left_hand.id == loot.id
            grab_loot.call(loot,nil)
        elsif loot.name == 'some silver coins'
            dothistimeout "get ##{loot.id}", 5, /^You gather the remaining \d+ coins from inside your .*\.$|^You gather the remaining/
        end
    }
}

# Checks a bundle for ammo type
check_bundle = proc { |id|
    ammo_name = settings['ammo_name'].strip
    result = nil

    action = proc { |server_string|
        line = server_string
        if server_string =~ /Individual projectiles from this bundle will have a (?:show|long) of "(.*)"|Each individual projectile will be "(.*)"/
            name_long = $1
            name_short = $2

            if name_long =~ /.*#{ammo_name}/ or name_short =~ /.*#{ammo_name}/
                result = server_string
            end
            nil
        elsif server_string =~ /^You carefully count|Individual/
            nil
        elsif server_string.strip.empty?
            nil
        elsif server_string =~ /<prompt time=/
            result = false if result.nil?
            DownstreamHook.remove("sloot_check_bundle")
            nil
        else
            server_string
        end
    }

    DownstreamHook.add("sloot_check_bundle", action)
    $_SERVER_.puts "#{$cmd_prefix}look at ##{id}\n"
    wait_while { result.nil? }

    result
}

# Gathers ammunition
gather_ammo = proc {
    next unless settings['enable_gather']
    ammo_name = settings['ammo_name'].strip
    sack      = GameObj.inv.find { |obj| obj.name =~ /#{UserVars.ammosack}/ }

    if ammo_name.nil? or ammo_name.empty?
        echo "failed to gather: you must specify the ammo name to use this feature"
        next
    end

    if ammo_name =~ /\b(arrow|bolt|dart)\b/
        ammo_noun = $1
    else
        echo "failed to gather: invalid ammo type specified (use the full name)"
    end

    if sack.nil?
        echo "failed to gather: you must specify an ammo container to use this feature"
        next
    end

    get_ammo    = proc { GameObj.loot.find_all { |loot| loot.name =~ /#{settings['ammo_name']}/ and loot.noun =~ /^(?:arrow|dart|bolt)$/ }.collect { |ammo| ammo.id } }
    get_bundles = proc { sack.contents.find_all { |obj| obj.name =~ /bundle of #{settings['ammo_name']}/ } }
    put_ammo    = proc { |ammo|
        dothistimeout "put my #{ammo.noun} in my #{ammo_noun}s in my #{sack}", 5, /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/
    }

    # Attempt to gather arrows first
    ammo_ids = get_ammo.call
    unless ammo_ids.empty? or not GameObj.loot.find { |l| l.name =~ /#{ammo_noun}/ }
        empty_hand
        result = dothistimeout "gather #{ammo_noun}", 5, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach/
        if result =~ /^You gather .* into a bundle on the ground\.$/
            get_item.call(GameObj.loot.find { |l| l.noun =~ /^(?:arrow|bolt|dart)s?$/ },nil)
        end
        if result =~ /^You gather|^You pick up/ and hand = [ GameObj.right_hand, GameObj.left_hand ].find { |i| i.noun =~ /^(?:arrow|bolt|dart)s?$/ }
            result = dothistimeout "look at ##{hand.id}", 5, /You see|Each individual/
            if result =~ /#{ammo_name}/
                put_ammo.call(hand)
                put_item.call(hand,sack) if [checkleft,checkright].include?(hand.noun)
            else
                fput "drop ##{hand.id}"
            end
        end
    end
    # Loop through remaining arrow ids and store manually
    ammo_ids = get_ammo.call
    if !ammo_ids.empty?
        empty_hand
        ammo_ids.each { |i|
            get_item.call("##{i}",nil)

            if hand = [ GameObj.right_hand, GameObj.left_hand ].find { |i| i.noun =~ /(?:arrow|bolt|dart)/ }
                dothistimeout "put my #{hand.noun} in my #{hand.noun} in my #{sack}", 5, /^I could not find|^You can't seem to|^You add|^You bundle|You cannot bundle/
                put_item.call(hand,sack) if [checkleft,checkright].include?(hand.noun)
            end
        }
    elsif ammo_ids.empty? && GameObj.loot.find { |l| l.name =~ /#{ammo_noun}/ }
        status_tags
        put "look"
        line = get until line =~ /You also see (.+)\./
        status_tags
        items = $1
        itemArray = items.split_as_list
        itemArray.delete_if{|i| i.gsub(/<.+?>/,'') !~ /#{ammo_noun}/}
        ammo_ids = itemArray.collect{|ammo| /a exist="(.+?)" /.match(ammo)[1]}
        unless ammo_ids.empty?
            result = dothistimeout "gather ##{ammo_ids[0]}", 5, /^You gather|^You pick up|^I could not|^What were you|^You may only|reach/
            if result =~ /^You gather .* into a bundle on the ground\.$/
                get_item.call(GameObj.loot.find { |l| l.noun =~ /^(?:arrow|bolt|dart)s?$/ },nil)
            end
            hand = [ GameObj.right_hand, GameObj.left_hand ].find { |i| i.noun =~ /^(?:arrow|bolt|dart)s?$/ }
            put_ammo.call(hand)
            put_item.call(hand,sack) if [checkleft,checkright].include?(hand.noun)
        end
    end

    fill_hand()
}

# Locksmithing routine
locksmith = proc { |silver_breakdown|
    box_sacks = [GameObj[UserVars.boxsack]]
    boxes     = []

    settings['overflowsack'].split(',').each { |sack|
        if found_sack = GameObj[sack]
            box_sacks.push(found_sack)
        end
    }

    box_sacks.each { |sack|
        if (more_boxes = sack.contents.find_all { |o| o.type.include?('box') })
            boxes += more_boxes
        end
    }

    if settings['enable_disking'] and $sloot_has_disk
        unless disk = GameObj[/^.*#{Char.name} (?:disk|coffin)$/]
            unless disk = check_for_disk.call
                msg.call("failed to find a disk")
            end
        end

        if disk
            unless disk.contents
                dothistimeout "look in ##{disk.id}", 5, /There is nothing|In the .*?/
                unless disk.contents
                    msg.call("failed to find contents of your disk")
                end
            end

            boxes += disk.contents.find_all { |o| o.type.include?('box') }.to_a if disk.contents
        end
    end

    if boxes.size == 0
        msg.call("-- nothing for the locksmith")
    else
        empty_hands
        withdraw_coins.call(10000)
        go2.call('locksmith')

        unless trash = GameObj[/crate|barrel|wastebarrel|casket/]
            msg.call('unable to locate trash')
        end

        # FWI: Try and find activator first.
        activator = GameObj[/chime/]

        if activator.nil?
            unless table = GameObj[/table|counter/]
                msg.call('unable to find table')
                next
            end

            unless table.contents
                dothistimeout "look on ##{table.id}", 5, /On the .*? you see/

                unless table.contents
                    msg.call("failed to find contents of #{table.name}")
                    next
                end
            end

            unless activator = table.contents.find { |o| o.noun =~ /bell|keys|chime/ }
                msg.call('unable to find activator')
            end
        end

        case activator.noun
            when /bell|chime/
                activator = "ring ##{activator.id}"
            when /keys/
                activator = 'pull keys'
        end

        open_box = proc { |box|
            if disk and !GameObj[disk.name]
                msg.call("waiting on your disk to arrive")
            end
            wait_until { GameObj[disk.name] } if disk

            get_item.call(box,nil)

=begin
            unless [2425].include? Room.current.id
                res = dothistimeout "put ##{box.id} on ##{table.id}", 5, /^You put|^You should really/

                # Phasing for those Sorcerer types (evil bastards!)
                if res =~ /^You should really/
                    dothistimeout "drop ##{box.id}", 5, /flickers in and out of existence/
                    put_item.call(box,table.id)
                end
            end
=end

            res = dothistimeout activator, 5, /but it'll cost ya\.  Gimme (\d+) silvers/
            if res =~ /Gimme (\d+) silvers/
                box_cost = $1.to_i
            else
                box_cost = 0
                msg.call("unknown locksmith response: " + res.to_s)
            end

            res = dothistimeout "pay", 5, /accepts|have enough/
            if res =~ /have enough/
                put_item.call(box,UserVars.boxsack)
                withdraw_coins.call(10000)
                next open_box.call(box)
            end

            silver_breakdown['locksmith'] ||= 0
            silver_breakdown['locksmith'] = silver_breakdown['locksmith'].to_i - box_cost

            cur_silvers = checksilvers.call

            dothistimeout "open ##{box.id}", 5, /open/
            unless box.contents
                dothistimeout "look in ##{box.id}", 5, /^In the/

                unless box.contents
                    msg.call("failed to see contents of #{box.name}")
                    loot_it.call(box,nil)
                    next
                end
            end

            loot_it.call(box.contents,nil)
            silver_breakdown['locksmith'] = silver_breakdown['locksmith'] + (checksilvers.call - cur_silvers)
            unless trash.nil?
                unless put_item.call(box,trash.id)
                    dothistimeout "drop ##{box.id}", 5, /drop/ if [checkleft,checkright].include?(box.noun)
                end
            end

            dothistimeout "drop ##{box.id}", 5, /drop/ if [checkleft,checkright].include?(box.noun)
        }

        dothistimeout "unhide", 5, /hiding|visible/ if invisible? or hiding?
        done = []
        boxes.each { |b|
            next if done.include? b.id

            open_box.call(b)
            done.push(b.id)
        }
    end
}

to_locker = proc {
    withdraw_coins.call(1000)
    go2.call(CharSettings['sell_stockpile_locker'])

    if way_in = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
        move "go #{way_in.noun}"
    else
        false
    end
}

from_locker = proc {
    if way_out = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
        move "go #{way_out.noun}"
    end
}

need_to_stockpile = proc {
    if CharSettings[:jars].any? { |jar| jar[:gem] =~ /large|medium|small|tiny/ }
        CharSettings[:jars] = nil
    end
    lootsack = sacks['gem']
    can_start_new_jar = (CharSettings[:empty_jar_count] > 0) and lootsack.contents.any? { |obj| (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not CharSettings[:jars].any? { |jar| jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ } }
    can_add_to_jar = CharSettings[:jars].any? { |jar| !jar[:full] and lootsack.contents.any? { |obj| jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ } }
    CharSettings[:jars].nil? or can_start_new_jar or can_add_to_jar
}

need_to_raid_stockpile = proc {
    if checkbounty =~ /gem dealer.* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
        gem = $1
        count = $2.to_i
        CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
    else
        false
    end
}

stockpile = proc {
    status_tags
    lootsack = sacks['gem']
    open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
    status_tags
    if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
        locker_id = $1
        locker_contents = GameObj.containers[locker_id]
        unless locker_contents
            dothistimeout "look in ##{locker_id}", 3, /^In the/
            locker_contents = GameObj.containers[locker_id]
        end
        if locker_contents
            if CharSettings[:jars].nil?
                CharSettings[:jars] = Array.new
                CharSettings[:empty_jar_count] = 0
                locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ }.each { |jar|
                    if jar.after_name.nil?
                        CharSettings[:empty_jar_count] = CharSettings[:empty_jar_count] + 1
                    else
                        look_result = dothistimeout "look in ##{jar.id} from ##{locker_id}", 3, /^Inside .*? you see [0-9]+ portion/
                        if look_result =~ /^Inside .*? you see ([0-9]+) portion/
                            count = $1.to_i
                            gem = jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '')
                            full = look_result.include?('It is full')
                            CharSettings[:jars].push(h={ :gem => gem, :count => count, :full => full })
                        end
                    end
                }
            end
            empty_hands
            not_suitable = Array.new
            for jar in locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|beaker|bottle)$/ }
                if jar.after_name =~ /^containing /
                    gem_list = lootsack.contents.find_all { |obj| (jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/) }
                    gem_list.delete_if { |obj| not_suitable.include?(obj.id) }
                    jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') }
                    unless gem_list.empty? or jar_hash[:full]
                        dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
                        for gem in gem_list
                            result = dothistimeout "_drag ##{gem.id} ##{jar.id}", 3, /^You add|is full|does not appear to be a suitable container for/
                            if result =~ /^You add .* filling it/
                                jar_hash[:count] = jar_hash[:count] + 1
                                jar_hash[:full] = true
                            elsif result =~ /^You add/
                                jar_hash[:count] = jar_hash[:count] + 1
                            elsif result =~ /is full/
                                jar_hash[:full] = true
                                dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, putregex
                                break
                            elsif result =~ /does not appear to be a suitable container for/
                                dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, putregex
                                not_suitable.push(gem.id)
                            else
                                dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, putregex
                            end
                        end
                        dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
                    end
                else
                    gem_count = Hash.new
                    lootsack.contents.each { |obj|
                        if (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not locker_contents.any? { |o| o.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ and not not_suitable.include?(obj.id) }
                            gem_count[obj.name.gsub(/large |medium |small |tiny |some /, '')] = gem_count[obj.name.gsub(/large |medium |small |tiny |some /, '')].to_i + 1
                        end
                    }
                    next if gem_count.empty?
                    gem_name = nil
                    gem_num = 0
                    gem_count.each_pair { |name,num|
                        if num > gem_num
                            gem_name = name
                            gem_num = num
                        end
                    }
                    dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
                    jar_hash = nil
                    lootsack.contents.each { |obj|
                        if obj.name.gsub(/large |medium |small |tiny |some /, '') == gem_name
                            result = dothistimeout "_drag ##{obj.id} ##{jar.id}", 3, /^You (?:add|put)|is full|does not appear to be a suitable container for/
                            if result =~ putregex
                                dothistimeout "put ##{jar.id} in ##{lootsack.id}", 3, putregex
                                gem = lootsack.contents.find { |obj| obj.id == jar.id }.after_name.gsub(/^containing |large |medium |small |tiny |some /, '')
                                dothistimeout "get ##{jar.id}", 3, /^You remove/
                                jar_hash = { :gem => gem, :count => 1, :full => false }
                                CharSettings[:jars].push(jar_hash)
                            elsif result =~ /^You add/
                                jar_hash[:count] = jar_hash[:count] + 1
                            elsif result =~ /is full/
                                dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, putregex
                                jar_hash[:full] = true
                                break
                            elsif result =~ /does not appear to be a suitable container for/
                                not_suitable.push(obj.id)
                                fput "put ##{obj.id} in ##{lootsack.id}"
                            end
                        end
                    }
                    dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
                end
            end
            dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
            fill_hands
        else
            dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
            echo 'error: failed to find locker contents'
        end
    else
        dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
        echo 'error: failed to find locker'
    end
}

raid_stockpile = proc {
    lootsack = sacks['gem']
    if bounty? =~ /gem dealer .* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
        gem = $1
        count = $2.to_i
        gem.gsub!(/large |medium |small |tiny |some /, '')
        status_tags
        open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
        status_tags
        if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
            locker_id = $1
            locker_contents = GameObj.containers[locker_id]
            unless locker_contents
                dothistimeout "look in ##{locker_id}", 3, /^In the/
                locker_contents = GameObj.containers[locker_id]
            end
            if locker_contents
                if CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
                    if jar = locker_contents.find { |jar| jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ }
                        jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.sub(/^containing |large |medium |small |tiny |some /, '') }
                        empty_hands
                        dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
                        count.times {
                            dothistimeout "shake ##{jar.id}", 3, /^You .*shake/
                            if GameObj.right_hand.id != jar.id
                                obj = GameObj.right_hand
                            elsif GameObj.left_hand.id != jar.id
                                obj = GameObj.left_hand
                            end
                            dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, putregex
                            jar_hash[:count] = jar_hash[:count] - 1
                            jar_hash[:full] = false
                        }
                        dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
                        if jar_hash[:count] < 1
                            CharSettings[:jars].delete(jar_hash)
                            CharSettings[:empty] = CharSettings[:empty] + 1
                        end
                        fill_hands
                        dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
                        true
                    else
                        dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
                        false
                    end
                else
                    dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
                    false
                end
            else
                dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
                echo 'error: failed to find locker contents'
                false
            end
        else
            dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
            echo 'error: failed to find locker'
            false
        end
    else
        echo "error: you're doing it wrong"
        false
    end
}


# Sell routine
sell = proc {
    cur_room         = Room.current.id
    found_sacks      = Array.new
    selling          = Hash.new
    silver_breakdown = Hash.new
    types            = Array.new

    # Chronomage
    if settings['enable_sell_chronomage']
        sack  = GameObj[UserVars.jewelrysack]
        rings = sack.contents.find_all { |item| item.name =~ /^(\w+) gold ring$/ }
        if not rings.empty?
            go2.call('chronomage')
            npc = GameObj.npcs.first

            if not npc.nil?
                empty_hands

                rings.each { |ring|
                    fput "get ##{ring.id}"
                    fput "give ##{ring.id} to ##{npc.id}"

                    if checkleft or checkright
                        fput "put ##{ring.id} in my ##{sack.id}"
                    end
                }

                fill_hands
            end
        end
    end

    # Locksmith
    if settings['enable_sell_locksmith']
        locksmith.call(silver_breakdown)
    end

    # Stockpile gems
    if settings['enable_sell_stockpile']
        if CharSettings['sell_stockpile_locker'].nil?
            echo 'warning: stockpiling is turned on but locker room is not set'
            sleep 3
        elsif need_to_stockpile.call or need_to_raid_stockpile.call
            if to_locker.call
                stockpile.call if need_to_stockpile.call
                raid_stockpile.call if need_to_raid_stockpile.call
                from_locker.call
            end
        end
    end

    settings.keys.each { |key|
        if key =~ /^enable_sell_type_(.*)$/
            type = $1
            types.push(type) if settings[key]

            if found_sack = GameObj[UserVars.send("#{type}sack")]
                found_sacks.push(found_sack) unless found_sacks.include?(found_sack)
            end
        end
    }

    settings['overflowsack'].split(',').each { |sack|
        if found_sack = GameObj[sack]
            found_sacks.push(found_sack) unless found_sacks.include?(found_sack)
        end
    }

    found_sacks.each { |sack|
        unless sack.contents
            dothistimeout "look in ##{sack.id}", 5, /In the .*?/
            unless sack.contents
                msg.call("-- failed to find contents of sack: #{sack.name}")
                next
            end
        end

        sack.contents.each { |item|
            if CharSettings['sell_exclude'].to_s.length > 0
                next if item.name =~ /#{CharSettings['sell_exclude']}/
                next if item.name =~ /Guild voucher pack/i
            end

            unless item.sellable.nil?
                if item.type.split(',').any? { |type| type =~ /^#{types.join('|')}$/ }
                    selling[item.sellable] ||= Array.new
                    selling[item.sellable].push(item)
                end
            end
        }
    }

    # sell empty boxes
    if settings['enable_sell_type_empty_box']
        box_sacks = [GameObj[UserVars.boxsack]]
        box_sacks.each { |sack|
            if (more_boxes = sack.contents.find_all { |o| o.type.include?('box') })
                more_boxes.each { |box|
                    selling["pawnshop"] ||= Array.new
                    selling["pawnshop"].push(box)
                }
            end
        }
    end

    # sell scarabs as gems
    if settings['enable_sell_type_scarab']
        if (more_scarabs = GameObj[UserVars.boxsack].contents.find_all { |o| o.type.include?('scarab') })
            more_scarabs.each { |scarab|
                selling["gemshop"] ||= Array.new
                selling["gemshop"].push(scarab)
            }
        end
    end

    sell_item = proc { |item|
    $sell_no_spider = true
        if get_item.call(item,nil)
      sellme = GameObj.right_hand
      if settings['enable_stockpile_orbsanddeeds']
        if sellme.type =~ /gem/ or sellme.name =~ /shell/
          sleep 0.3
          fput "appraise ##{sellme.id}"
          newresult = waitfor("I'll give you [0-9]+ for it", "not quite my field")
          if newresult =~ /I'll give you ([0-9]+) for it/
            appraisal = $1.to_i
            if appraisal >= CharSettings['orb_value'].to_i
              fput "put #{sellme} in #{UserVars.gemsack}"
              sleep 0.5
            else
              fput "sell #{sellme}"
              sleep 0.5
            end
          else
            fput "put #{sellme} in #{UserVars.gemsack}"
            sleep 0.5
          end
        else
          dothistimeout "sell ##{sellme.id}", 5, /ask|offer/
          if checkleft == item.noun or checkright == item.noun
            unless put_item.call(item,UserVars.send("#{item.type.split(',').first}sack"))
              dothistimeout "drop ##{item.id}", 5, /drop/
            end
          end
        end
      else
        dothistimeout "sell ##{sellme.id}", 5, /ask|offer/
        if checkleft == item.noun or checkright == item.noun
          unless put_item.call(item,UserVars.send("#{item.type.split(',').first}sack"))
            dothistimeout "drop ##{item.id}", 5, /drop/
          end
        end
      end
    else
            msg.call("-- failed to find #{item.name}")
            exit
        end
    }

    if selling.size == 0
        msg.call("-- nothing to sell")
    else
        empty_hands

        selling.each_pair { |location,items|
            start_silvers = checksilvers.call

            location = location.split(',').first
            go2.call(location)
            items.each { |item| sell_item.call(item) }

            silver_breakdown[location] = checksilvers.call - start_silvers
        }
    end

    deposit_coins.call()
    go2.call(cur_room)
    fill_hands

    unless silver_breakdown.empty?
        msg.call("silver breakdown")
        silver_breakdown.each_pair { |location, silver|
            msg.call("#{location.split(',').first}: #{silver}")
        }

        total_made = silver_breakdown.values.inject { |i,j| i + j }
        msg.call("total: #{total_made}")
    end
}

# Returns an array of all dead npcs using GameObj
find_dead = proc { |type|
    npcs = GameObj.npcs.find_all { |npc| npc.status == 'dead' }

    if CharSettings['critter_exclude'].to_s.length > 0
        npcs.delete_if { |npc| npc.name =~ /#{CharSettings['critter_exclude']}/ }
    end

    npcs
}

# Checks if it's safe to enhance skinning by kneeling or stancing to offensive
safe_to_enhance = proc {
    next true unless settings['enable_skin_safe_mode']
    !GameObj.npcs.any? { |npc| npc.status !~ /dead/ }
}

# Prepares for skinning process
prepare_skinner = proc { |critter|
    next if settings['skin_exclude'].include?(critter.name)
    next if skin_prepared
    next unless GameObj.npcs.any? { |npc| npc.status =~ /dead/ }
    next unless settings['enable_skinning']

    # Sigil of Resolve
    if Spell[9704].known? and Spell[9704].affordable? and not Spell[9704].active? and settings['enable_skin_sigil']
        Spell[9704].cast
    end

    # 604 - Skinning
    if Spell[604].known? and Spell[604].affordable? and settings['enable_skin_604']
        while !Spell[604].active?
            Spell[604].cast
        end
    end

    if settings['enable_skin_alternate']
        if critter.name =~ /krag dweller|greater krynch|massive boulder/
            empty_hands
            skin_empty_hands = true
        else
            free_hand.call
        end

        skinweaponcurrent = skinweapon
        if critter.name =~ /krynch|spiked cavern urchin|krag dweller|stone mastiff|gargoyle|massive boulder/i and UserVars.skinweaponblunt.to_s.length > 1
            skinweaponcurrent = skinweaponblunt
        end

        unless get_item.call(skinweaponcurrent,sacks['skinweapon'])
            msg.call("** failed to find #{skinweaponcurrent.name} in #{sacks['skinweapon'].name}")
        end
    else
        if critter.name =~ /krag dweller|greater krynch|massive boulder/
            free_hand.call
        end
    end

    if safe_to_enhance.call
        while settings['enable_skin_kneel'] and !checkkneeling
            dothistimeout "kneel", 5, /^You kneel down\.$|^You move to|^You are already kneeling\.$/
        end

        if settings['enable_skin_offensive']
            change_stance.call('offensive')
        end
    end

    skin_prepared = true
}

# Get thee up!
stand_up = proc {
    if settings['skin_stand_verb'].nil? or settings['skin_stand_verb'].empty?
        until standing?
            dothistimeout "stand", 5, /^You stand back up\.$/
        end
    else
        until standing?
            fput settings['skin_stand_verb']
        end
    end
}

# Finishes up skinning process
finish_skinner = proc {
    next unless skin_prepared
    next unless settings['enable_skinning']

    if settings['enable_skin_stance_first']
        change_stance.call(prev_stance)
        stand_up.call
    else
        stand_up.call
        change_stance.call(prev_stance)
    end

    if settings['enable_skin_alternate']
        unless put_item.call(skinweaponcurrent,UserVars.skinweaponsack)
            echo "failed to put #{skinweaponcurrent} in #{UserVars.skinweaponsack}"
        end
    end

    if skin_empty_hands
        fill_hands
        skin_empty_hands = false
    end
}

# Skins a critter
skin_critter = proc { |critter|
    next if settings['skin_exclude'].include?(critter.name)

    cmd = "skin ##{critter.id}"
    if not skinweaponcurrent.nil? and checkleft =~ /#{skinweaponcurrent}/i
        cmd += " with ##{GameObj.left_hand.id}"
    end

    res = dothistimeout cmd, 5, /skinned|botched|already been|cannot skin|must be a member|can only skin|You are unable to break through|You break through the crust of the|You crack open a portion/
    if res =~ /^You cannot skin/
        settings['skin_exclude'].push(critter.name)
    elsif res =~ /^(?:You break through the crust of the .+ and withdraw |You crack open a portion of the .+ and uncover )(.+)!/
        foundgem = $1.split.last
        gemsack = GameObj.inv.find { |obj| obj.name =~ /#{UserVars.gemsack}/}
        put_item.call(foundgem,gemsack)
    end
}

# Retrieves the previously stored item
get_stored = proc {
    if settings['enable_stow_left']
        fill_left_hand
        $fill_left_hand_actions = Array.new
    else
        fill_right_hand
        $fill_right_hand_actions = Array.new
    end
}

['clothing', 'ammo', 'box', 'gem', 'herb', 'jewelry', 'lockpick', 'magic', 'reagent', 'scroll', 'skin', 'uncommon', 'wand', 'skinweapon', 'valuable', 'weapon'].each { |type|

    if !UserVars.send("#{type}sack").nil? and UserVars.send("#{type}sack").length > 0 and sack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("#{type}sack").strip)}/i }
        sacks[type] = sack
    elsif script.vars[1] !~ /^setup/i
        next if type == 'skinweapon' && !settings['enable_skinning']
        next if !settings["enable_loot_#{type}"]
        echo "** failed to find #{type} sack"
        exit
    end
}

if script.vars[1] =~  /^reset-gui$/i
    settings['window_height'] = nil
    settings['window_width'] = nil
    settings['window_position'] = nil

    echo "gui reset"
elsif script.vars[1] =~ /^stockpile-forget$/i
    CharSettings[:jars] = nil
    echo 'stockpile cleared'
elsif script.vars[1] =~ /^stockpile-list$/i
    output = "                           gem count  full\n"
    output.concat "                           --- -----  ----\n"

    gem = script.vars[2]
    for jar in CharSettings[:jars].sort { |a,b| b[:count] <=> a[:count] }
        if gem.nil? or jar[:gem] =~ /#{gem}/
            output.concat "#{jar[:gem].rjust(30)} #{jar[:count].to_s.rjust(2)} #{jar[:full].to_s.rjust(8)}\n"
        end
    end
    respond output
elsif script.vars[1] =~ /^deposit$/i
    deposit_coins.call
elsif script.vars[1] =~ /^sell$/i
    sell.call
elsif script.vars[1] =~  /^setup$/i
    setup.call
elsif script.vars[1] =~ /^(right|left)$/i
    hand = $1 == 'right' ? GameObj.right_hand : GameObj.left_hand
    unless hand.contents
        dothistimeout "look in ##{hand.id}", 5, /^I could not find|In the .*\.$/
        unless hand.contents
            msg.call("failed to find contents of #{hand.name}")
        end
    end

    loot_it.call(hand.contents,nil)
elsif script.vars[1] =~  /^(?:help|\?)$/
    msg.call( sprintf('SLoot'))
    msg.call( sprintf('%17s: SpiffyJr &lt;spiffyjr@gmail.com&gt;', 'Author'))
    msg.call( sprintf('%17s: SLoot is designed to be the most versatile looter available!', 'Description'))
    msg.call( sprintf('%17s: ;sloot - runs the skin, search, and loot routine on the current room.', 'Usage'))
    respond
    msg.call( sprintf('%17s     %s', 'help, ?', 'show this help message'))
    msg.call( sprintf('%17s     %s', 'setup', 'run the GUI configuration'))
    msg.call( sprintf('%17s     %s', 'reset-gui', 'resets the GUI window if it gets lost'))
    respond
    msg.call( sprintf('%17s     %s', 'stockpile-forget', 'forget your stockpile settings'))
    msg.call( sprintf('%17s     %s', 'stockpile-list', 'lists your stockpiled gems'))
    respond
    msg.call( sprintf('%17s     %s', 'dump', 'dumps the current settings to the screen'))
    respond
    msg.call( sprintf('%17s     %s', 'sell', 'runs the automated selling routine'))
    msg.call( sprintf('%17s     %s', 'deposit', 'deposits your coins according to settings'))
    respond
    msg.call( sprintf('%17s     %s', 'sack', 'runs sloot on the sack specified'))
    msg.call( sprintf('%17s     %s', 'left', 'runs sloot on the sack in your left hand'))
    msg.call( sprintf('%17s     %s', 'right', 'runs sloot on the sack in your right hand'))
end

exit unless script.vars[1].nil?

if settings['enable_skinning'] and settings['enable_skin_alternate']
    skinweaponsack  = sacks['skinweapon']

    if skinweaponsack.nil?
        echo "** skinning is enabled but I could not find your skin weapon sack"
        exit
    end

    if not sacks['skinweapon'].contents
        fput "look in ##{sacks['skinweapon'].id}"
    end

    skinweapon      = skinweaponsack.contents.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweapon)}/i }
    skinweaponblunt = skinweaponsack.contents.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponblunt)}/i }

    if skinweapon.nil?
        echo "** skinning is enabled but I could not find your skin weapon"
    end

    if skinweaponblunt.nil?
        skinweaponblunt = skinweapon
    end
end

# Hooks for disk tracking and statistics
install_hooks.call

# Is safe hiding enabled?
if settings['enable_safe_hiding'] and hiding?
    bad_npcs = GameObj.npcs.find_all { |npc|
        npc.type !~ /escort/ and npc.status !~ /dead/ and npc.name !~ /^(?:#{settings['safe_ignore'].to_s})$/
    }
    exit if bad_npcs.length > 0
end

# Keep track of loot IDs in the current room if we're only looting our critter drops
previous_loot_ids = Array.new
if settings['enable_self_drops']
    previous_loot_ids = GameObj.loot.collect { |l| l.id }
end

critters = find_dead.call

if settings['enable_skinning']
    critters.each { |critter|
        next if critter.name =~ /Grimswarm/ or critter.type =~ /bandit/
        prepare_skinner.call(critter)
        skin_critter.call(critter)
    }
    finish_skinner.call
end

critters.each { |critter|
    res = dothistimeout "search ##{critter.id}", 5, /^You search (?:through )?the .*\.$|^What were you referring to|You plunge your hand|and withdraw a fiery red gem!/

    if res =~ /withdraw a (?:cold blue gem|fiery red gem)/
        righthand == 'gem' ? loot_it.call(GameObj.right_hand,[]) : loot_it.call(GameObj.left_hand,[])
    elsif res =~ /you withdraw your arm to find a pungent piece/
        righthand == 'caederine' ? loot_it.call(GameObj.right_hand,[]) : loot_it.call(GameObj.left_hand,[])
    end

    break unless settings['enable_search_all']
}

if script.vars[1] =~ /^left$/i
    target = [GameObj.left_hand]
elsif script.vars[1] =~ /^right$/i
    target = [GameObj.right_hand]
else
    target = GameObj.loot
end

if settings['enable_stance_on_start']
    change_stance.call('defensive')
end

loot_it.call(target,previous_loot_ids)
gather_ammo.call()

get_stored.call()
close_open_sacks.call()
