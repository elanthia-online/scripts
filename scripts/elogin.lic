=begin
  e_elogin.lic â€“ Character launcher for Lich 5+
  Uses fallback-aware LoginHelpers to select best character entry and spawn login.
  
  Usage:
    ;elogin help                       # Show usage
    ;elogin set realm <prime|platinum|shattered|test>  # Set game realm
    ;elogin <char> [script1,script2]  # Login with optional scripts
    ;elogin add <char> <user_id> <password>  # Add character entry
    ;elogin delete <char> <game_code>        # Delete character entry
=end

LICH_GEM_REQUIRES = '5.0.1'

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(LICH_GEM_REQUIRES)
  echo "elogin.lic requires Lich v#{LICH_GEM_REQUIRES}+."
  exit
end

# ============================================================================
# HELPER METHODS
# ============================================================================

def lich_version_at_least?(major, minor = 0, patch = 0)
  return false unless defined?(LICH_VERSION)
  current = LICH_VERSION.scan(/\d+/).map(&:to_i)
  target = [major, minor, patch]
  (current <=> target) >= 0
end

def debug_log(message)
  return unless ENV['ELOGIN_DEBUG'] == 'true'
  echo "DEBUG: #{message}"
end

def handle_error(message, should_exit: true)
  echo message
  Lich.log "elogin error: #{message}" if defined?(Lich)
  exit if should_exit
end

def log_operation(message)
  Lich.log "elogin: #{message}" if defined?(Lich)
end

def login_backend_version
  lich_version_at_least?(5, 12, 0) ? :yaml : :dat
end

def load_entry_data
  case login_backend_version
  when :yaml
    load_yaml_entries
  when :dat
    load_dat_entries
  end
end

def load_yaml_entries
  yaml_path = Lich::Common::GUI::YamlState.yaml_file_path(DATA_DIR)
  debug_log("Looking for YAML file at: #{yaml_path}")
  debug_log("YAML file exists: #{File.exist?(yaml_path)}")
  
  handle_error("Error: no saved entries YAML file found at #{yaml_path}") unless File.exist?(yaml_path)
  
  begin
    raw_yaml = YAML.load_file(yaml_path)
    debug_log("Raw YAML loaded: #{raw_yaml.class} with keys: #{raw_yaml.keys if raw_yaml.respond_to?(:keys)}")
    debug_log("Raw YAML accounts: #{raw_yaml['accounts']}")
    
    # Skip symbolize_keys - it's corrupting the data
    # symbolized_yaml = Lich::Util::LoginHelpers.symbolize_keys(raw_yaml)
    # debug_log("Symbolized YAML: #{symbolized_yaml.class}")
    # debug_log("Symbolized YAML accounts: #{symbolized_yaml[:accounts]}")
    
    legacy_format = Lich::Common::GUI::YamlState.convert_yaml_to_legacy_format(raw_yaml)
    debug_log("Legacy format result: #{legacy_format.class} with #{legacy_format.length} entries")
    
    legacy_format
  rescue => e
    debug_log("Error in YAML loading: #{e.class} - #{e.message}")
    handle_error("Error loading entry.yaml: #{e.class} - #{e.message}")
  end
end

def load_dat_entries
  entry_file = File.join(DATA_DIR, 'entry.dat')
  handle_error("Error: entry.dat not found. Set up a character via the Lich front-end or wait for YAML support.") unless File.exist?(entry_file)
  
  begin
    raw = File.read(entry_file)
    decoded = raw.unpack1('m')
    Marshal.load(decoded)
  rescue => e
    handle_error("Error loading entry.dat: #{e.class} - #{e.message}")
  end
end

def save_entry_data(entry_data)
  # Debug: Show what we're trying to save
  debug_log("About to save #{entry_data.length} entries")
  entry_data.each_with_index do |entry, i|
    debug_log("Entry #{i}: #{entry[:char_name]} (#{entry[:game_code]})")
  end
  
  case login_backend_version
  when :yaml
    # For YAML, save_entries expects Array in legacy format and handles conversion internally
    success = Lich::Common::GUI::YamlState.save_entries(DATA_DIR, entry_data)
    debug_log("Save result: #{success}")
    handle_error("Error: Failed to save to entry.yaml") unless success
  when :dat
    begin
      raw = Marshal.dump(entry_data)
      encoded = [raw].pack('m')
      File.write(File.join(DATA_DIR, 'entry.dat'), encoded)
    rescue => e
      handle_error("Error: Failed to save to entry.dat - #{e.class}: #{e.message}")
    end
  end
end

def resolve_login_helpers_paths(mode = 'production')
  handle_error("Unsupported Lich version: #{LICH_VERSION}") unless lich_version_at_least?(5, 6, 2)
  
  case mode
  when "production"
    remote_repo = "https://raw.githubusercontent.com/elanthia-online/lich-5/master/lib"
  when "beta"
    remote_repo = "https://raw.githubusercontent.com/elanthia-online/lich-5/staging/lib"
  when "alpha"
    local_test_base = ENV['LICH_DEV']
    handle_error("LICH_DEV environment variable not set for alpha mode") unless local_test_base && !local_test_base.strip.empty?
    
    local_test_base = File.expand_path(File.join(local_test_base, "lib"))
    
    if lich_version_at_least?(5, 11, 0)
      source_path = File.join(local_test_base, 'util', 'login_helpers.rb')
      local_path = File.join(LIB_DIR, 'util', 'login_helpers.rb')
      require_path = File.join(LIB_DIR, 'util', 'login_helpers')
    else
      source_path = File.join(local_test_base, 'login_helpers.rb')
      local_path = File.join(LIB_DIR, 'login_helpers.rb')
      require_path = File.join(LIB_DIR, 'login_helpers')
    end
    
    return { local_path: local_path, require_path: require_path, source_path: source_path, remote_url: nil }
  else
    handle_error("Unknown mode: #{mode.inspect}")
  end

  if lich_version_at_least?(5, 11, 0)
    local_path = File.join(LIB_DIR, 'util', 'login_helpers.rb')
    require_path = File.join(LIB_DIR, 'util', 'login_helpers')
  else
    local_path = File.join(LIB_DIR, 'login_helpers.rb')
    require_path = File.join(LIB_DIR, 'login_helpers')
  end

  remote_url = "#{remote_repo}/util/login_helpers.rb"
  { local_path: local_path, require_path: require_path, remote_url: remote_url }
end

def ensure_login_helpers_loaded(mode = 'production')
  paths = resolve_login_helpers_paths(mode)
  
  unless File.exist?(paths[:local_path])
    if paths[:source_path] && File.exist?(paths[:source_path])
      FileUtils.mkdir_p(File.dirname(paths[:local_path]))
      FileUtils.cp(paths[:source_path], paths[:local_path])
    elsif paths[:remote_url]
      begin
        require 'open-uri'
        content = URI.open(paths[:remote_url], &:read)
        FileUtils.mkdir_p(File.dirname(paths[:local_path]))
        File.write(paths[:local_path], content)
      rescue => e
        handle_error("Failed to download login_helpers.rb from #{paths[:remote_url]}: #{e.message}")
      end
    else
      handle_error("No valid source found to populate login_helpers.rb")
    end
  end

  require paths[:require_path]
end

def add_login_entry(entry_data, char_name:, user_id:, password:, game_code: nil, game_name: 'GemStone IV', frontend: $frontend, custom_launch: nil, custom_launch_dir: nil)
  handle_error("Fatal: entry_data was not loaded correctly. Got #{entry_data.class} instead of Array.") unless entry_data.is_a?(Array)

  # Debug: Show what we loaded
  debug_log("Loaded #{entry_data.length} existing entries")
  entry_data.each_with_index do |entry, i|
    debug_log("Existing Entry #{i}: #{entry[:char_name]} (#{entry[:game_code]})")
  end

  game_code ||= case CharSettings['realm']
                when 'platinum' then 'GSX'
                when 'shattered' then 'GSF'
                when 'test' then 'GST'
                else 'GS3'
                end

  existing = entry_data.find { |d| d[:char_name].casecmp?(char_name) && d[:game_code] == game_code }
  if existing
    handle_error("Error: Add failed. Character already exists for #{char_name} (#{game_code}). Use `modify` to update or `delete` to remove existing entry.")
  end

  # Use exact structure from original legacy code
  h = { 
    :char_name => char_name, 
    :game_code => game_code, 
    :game_name => game_name, 
    :user_id => user_id.downcase, 
    :password => password, 
    :frontend => frontend, 
    :custom_launch => custom_launch, 
    :custom_launch_dir => custom_launch_dir 
  }
  entry_data.push(h)

  debug_log("After adding new entry, total entries: #{entry_data.length}")

  save_entry_data(entry_data)
  log_operation("Added login entry for #{char_name} (#{game_code}) with account #{user_id}")
  echo "Successfully added login entry for #{char_name} (#{game_code})."
end

def modify_login_entry(entry_data, char_name:, user_id:, password:)
  handle_error("Fatal: entry_data was not loaded correctly. Got #{entry_data.class} instead of Array.") unless entry_data.is_a?(Array)

  # Find existing entry by character name AND account (user_id)
  existing = entry_data.find { |d| d[:char_name].casecmp?(char_name) && d[:user_id].casecmp?(user_id) }
  
  unless existing
    echo "Modify failed. No entry found for character: #{char_name} with account: #{user_id}"
    echo "Existing characters:"
    entry_data.each { |entry| echo "  #{entry[:char_name]} (#{entry[:game_code]}) - #{entry[:user_id]}" }
    handle_error("Character/account combination not found.")
  end

  debug_log("Found existing entry: #{existing}")

  # Remove the old entry
  entry_data.reject! { |d| d[:char_name].casecmp?(char_name) && d[:user_id].casecmp?(user_id) }
  
  # Create new entry with updated password but preserve other fields
  h = { 
    :char_name => existing[:char_name], 
    :game_code => existing[:game_code], 
    :game_name => existing[:game_name], 
    :user_id => user_id.downcase, 
    :password => password, 
    :frontend => existing[:frontend], 
    :custom_launch => existing[:custom_launch], 
    :custom_launch_dir => existing[:custom_launch_dir] 
  }
  entry_data.push(h)

  save_entry_data(entry_data)
  log_operation("Modified login entry for #{char_name} with account #{user_id}")
  echo "Successfully modified login entry for #{char_name} with account #{user_id}."
end

def list_login_entries(entry_data)
  handle_error("Fatal: entry_data was not loaded correctly. Got #{entry_data.class} instead of Array.") unless entry_data.is_a?(Array)

  if entry_data.empty?
    echo "No saved character entries found."
    return
  end

  # Calculate column widths
  account_width = ([7] + entry_data.map { |e| e[:user_id].to_s.length }).max
  char_width = ([9] + entry_data.map { |e| e[:char_name].to_s.length }).max
  instance_width = ([8] + entry_data.map { |e| e[:game_code].to_s.length }).max
  frontend_width = ([8] + entry_data.map { |e| e[:frontend].to_s.length }).max

  # Print header
  echo "Saved character entries:"
  echo "#{'-' * (account_width + char_width + instance_width + frontend_width + 13)}"
  echo "| #{'Account'.ljust(account_width)} | #{'Character'.ljust(char_width)} | #{'Instance'.ljust(instance_width)} | #{'Frontend'.ljust(frontend_width)} |"
  echo "#{'-' * (account_width + char_width + instance_width + frontend_width + 13)}"

  # Print entries
  entry_data.each_with_index do |entry, i|
    account = entry[:user_id].to_s
    character = entry[:char_name].to_s
    instance = entry[:game_code].to_s
    frontend = entry[:frontend].to_s
    
    echo "| #{account.ljust(account_width)} | #{character.ljust(char_width)} | #{instance.ljust(instance_width)} | #{frontend.ljust(frontend_width)} |"
  end
  
  echo "#{'-' * (account_width + char_width + instance_width + frontend_width + 13)}"
  echo "Total: #{entry_data.length} entries"
end

def delete_login_entry(entry_data, char_name:, game_code:, frontend: nil)
  matching_entries = entry_data.select do |entry|
    entry[:char_name].casecmp?(char_name) && entry[:game_code].to_s.casecmp?(game_code.to_s)
  end

  if matching_entries.empty?
    handle_error("Delete failed. No matching entry found for #{char_name} (#{game_code}).", should_exit: false)
    return false
  end

  if matching_entries.size > 1 && (frontend.nil? || frontend == :__unset)
    handle_error("Delete failed. Multiple entries exist for #{char_name} (#{game_code}). Specify frontend to delete a precise record.", should_exit: false)
    return false
  end

  entry_data.reject! do |entry|
    entry[:char_name].casecmp?(char_name) &&
      entry[:game_code].to_s.casecmp?(game_code.to_s) &&
      (frontend.nil? || frontend == :__unset || entry[:frontend].to_s.casecmp?(frontend.to_s))
  end

  save_entry_data(entry_data)
  log_operation("Deleted login entry for #{char_name} (#{game_code})")
  echo "Deleted entry and saved #{login_backend_version.to_s.upcase}."
  true
end

def show_usage
  echo "Usage:"
  echo "  ;elogin set realm <prime|platinum|shattered|test>"
  echo "  ;elogin <char> [script1,script2,...]"
  echo "  ;elogin add <char> <user_id> <password>"
  echo "  ;elogin modify <char> <user_id> <password>"
  echo "  ;elogin delete <char> <game_code>"
  echo "  ;elogin list"
end

def parse_arguments(args)
  # Clean redundant arguments from Lich command processing
  args.shift if args.size >= 2 && args[0].is_a?(String) && args[1].is_a?(String) && args[0] == args[1..].join(' ')
  
  return { command: :help } if args.empty? || args[0] =~ /^help$/i
  
  case args[0].to_s.downcase
  when 'set'
    if args[1] =~ /^realm$/i && args[2]
      { command: :set_realm, realm: args[2].to_s.downcase }
    else
      { command: :help }
    end
  when 'add'
    if args.length >= 4
      { command: :add_entry, char_name: args[1].capitalize, user_id: args[2].downcase, password: args[3] }
    else
      { command: :help }
    end
  when 'modify'
    if args.length >= 4
      { command: :modify_entry, char_name: args[1].capitalize, user_id: args[2].downcase, password: args[3] }
    else
      { command: :help }
    end
  when 'list'
    { command: :list_entries }
  when 'delete'
    if args.length >= 3
      { command: :delete_entry, char_name: args[1], game_code: args[2] }
    else
      { command: :help }
    end
  else
    # Login command - extract character name, instance flag, and scripts
    char_name = args[0]&.capitalize
    
    # Extract instance flag (--GST, --DR, --GSF, etc.)
    instance_flag = :__unset
    args.each do |arg|
      if arg.start_with?('--')
        flag = arg.sub('--', '').upcase
        if Lich::Util::LoginHelpers::VALID_GAME_CODES.include?(flag)
          instance_flag = flag
          break
        end
      end
    end
    
    # Remove instance flag from args and extract scripts
    args_without_flag = args.reject { |arg| "--#{instance_flag}" == arg }
    scripts = args_without_flag[1]&.split(',')&.map(&:strip) || []
    
    { command: :login, char_name: char_name, instance_flag: instance_flag, scripts: scripts }
  end
end

# ============================================================================
# MAIN EXECUTION
# ============================================================================

# Setup environment
ensure_login_helpers_loaded(ENV['LICH_MODE'] || 'production')

# Load backend-specific modules
case login_backend_version
when :yaml
  require File.join(LIB_DIR, 'common', 'gui', 'yaml_state')
end

# Parse arguments
parsed = parse_arguments(Script.current.vars.dup)

# Execute command
case parsed[:command]
when :help
  show_usage

when :set_realm
  valid_realms = %w[prime platinum shattered test]
  unless valid_realms.include?(parsed[:realm])
    handle_error("Invalid realm. Use: prime, platinum, shattered, or test.")
  end
  
  CharSettings['realm'] = parsed[:realm]
  log_operation("Set realm to #{parsed[:realm]}")
  echo "Realm set to #{parsed[:realm]}."

when :add_entry
  entry_data = load_entry_data
  add_login_entry(entry_data, 
    char_name: parsed[:char_name], 
    user_id: parsed[:user_id], 
    password: parsed[:password]
  )

when :modify_entry
  entry_data = load_entry_data
  modify_login_entry(entry_data,
    char_name: parsed[:char_name],
    user_id: parsed[:user_id],
    password: parsed[:password]
  )

when :list_entries
  entry_data = load_entry_data
  list_login_entries(entry_data)

when :delete_entry
  entry_data = load_entry_data
  delete_login_entry(entry_data, 
    char_name: parsed[:char_name], 
    game_code: parsed[:game_code]
  )

when :login
  # Validate realm is set
  realm = CharSettings['realm']
  handle_error("No realm set. Use ;elogin set realm <prime|platinum|shattered|test>") unless realm
  
  # Load entry data
  entry_data = load_entry_data
  
  # Determine game code
  game_code = if parsed[:instance_flag] == :__unset
                Lich::Util::LoginHelpers.realm_to_game_code(realm)
              else
                parsed[:instance_flag]
              end
  
  # Find character
  char_records = Lich::Util::LoginHelpers.find_character_by_name_and_game(
    entry_data, parsed[:char_name], game_code
  )
  
  char_entry = Lich::Util::LoginHelpers.select_best_fit(
    char_data_sets: char_records,
    requested_character: parsed[:char_name],
    requested_instance: game_code.to_s
  )
  
  handle_error("No matching entry found for #{parsed[:char_name]} in realm #{realm}.") unless char_entry
  
  # Determine instance override
  realm_game_code = Lich::Util::LoginHelpers.realm_to_game_code(realm)
  instance_override = (char_entry[:game_code] == realm_game_code) ? char_entry[:game_code] : char_entry[:_requested_game_code]
  
  # Spawn login
  Lich::Util::LoginHelpers.spawn_login(char_entry, 
    instance_override: instance_override, 
    startup_scripts: parsed[:scripts]
  )
end

