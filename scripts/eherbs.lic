=begin

   Script to heal yourself with herbs.

   Will use herbs in your herbsack, or on a bench or something.
   Works with any combination of herbs from any town.
   Can buy herbs.
   Might heal your traveler.

  ;eherbs help

            author: Elanthia-Online
   original author: Tillmen
      contributers: Tillmen, Tysong, Doug, Rinualdo, Xanlin, Deysh
              game: Gemstone
              tags: healing, herbs
          requires: Lich >= 4.6.0
           version: 1.5.14

  1.5.14 (2023-04-27)
    - added support for survival kit distiller
    - added support for using the basket under the bench in RR
    - bugfix for UI not greying out sigil of mending, 650, 1035 unless known
    - bugfix for UI saving when x-ing out. Only saves with close button

=end
=begin
  Version Semantics:
    Major_change.feature_addition.bugfix
  1.5.13 (2023-03-17)
    - bugfix for sigil of mending
    - bugfix for leaving people at the bank
    - bugfix for opening/closing containers
    - added option stock survival kit as combined total of herbs and potions
  1.5.12 (2023-03-15): Tysong: remove $infomon_cutthroat reference for cutthroat? reference
  1.5.11 (2023-03-07): Deysh: Update to drinkable regex
  1.5.10 (2023-03-05): Deysh: bugfix in UI that didn't grey out 650 or 1035 if not known
  1.5.9 (2023-03-05): Deysh: urchin guide was not returning to same herbalist after silver withdraw
  1.5.8 (2023-03-03): Deysh: old UI file was used in last submission
  1.5.7 (2023-02-26): Deysh: fixed the 'in,on,under,behind' options, added some additional inventory handling, added check for casting spells; added toggle for depositing silver
  1.5.6 (2023-02-25): Deysh: Update herb identification to use noun instead of name; bugfix for stock entry in UI; added a wait until healed for cutthroat
  1.5.5 (2023-02-22): Deysh: Update fragrant woth flower in FWI dosage from 2 to 3; misc typo fix
  1.5.4 (2023-02-20): Xanlin: typo fix, old compat fixes
  1.5.3 (2023-02-20): Deysh: fix to CLI bug, UI not keeping settings, checks on 650
  1.5.2 (2023-02-20): Deysh: bug fixes for exec_string monitor of measuring; stop coin deposit unless buying
  1.5.1 (2023-02-19): Deysh: bug fixes for skip_scars and Utility.set_preferences; Clean up of stocking routine
  1.5.0 (2023-02-17): Deysh: Added support for survival kits.
  1.4.7 (2023-01-23): Xanlin: winterberry order fix
  1.4.6 (2022-12-16): Xanlin: revert 1.4.4, restores override for cli options
  1.4.5 (2022-12-11): Deysh: Added UI
  1.4.4 (2022-11-29): Tysong: Fix to exit after setting change from CLI
  1.4.3 (2022-09-22): Xanlin: Fix override behavior
  1.4.2 (2022-09-18): Xanlin: River's Rest winterberry brew
  1.4.1 (2022-09-17): Xanlin: update instance variable when preferences set. Changed internal name for skip-scars to skip_scars and use-mending to use_mending.
  1.4.0 (2022-09-12): Xanlin: added ;eherbs check, fixed under and behind containers,
    converted to module, replaced version check with shims, refactored procs to methods.
  1.3.0 (2022-07-16):
    Updated River's Rest herbs, removed minor head wound from available herbs
      in River's Rest.
    Refactored stock function to count appropriately and track stocking measures
    Added feature to stock specifc herb type (;eherbs stock major head wound)
    Added feature to get blood only (;eherbs blood) and ignore wounds
    Improved (;eherbs list) to accept herb type (;eherbs list major head wound)
      this feature also accepts partials (;eherbs list minor)
  1.2.0 (2022-05-23):
    Fix for gambling kit open/close/get/put regex.
  1.1.3 (2022-05-19):
    Fix for gambling kit open/close/get/put regex.
  1.1.2 (2022-04-06):
    Fix for a/an ordering from menus
  1.1.1 (2022-04-04):
    Add LICH_VERSION check
  1.1.0 (2022-04-03):
    Rewrote fill and stock functions to detect those regions that only
    sell tinctures, tarts and various assorted non-bundling type herbs
    Corrected multiple errors in initial data tables for locations / herbs
  1.0.0 (2022-02-27):
    Global RENAME to ;eherbs
    Rewrote stock function to work at any herbalist
    Rewrote stock function to account for any 'type' of herb, so for example
    acantha leaf, acantha tea, Bloody Krolvin ale all count towards
    total doses of 'blood' herb.

  Previously as ;useherbs
  0.14 (2022-01-25):
    fix for handedness and herbs (mistaken stick for sticky and so on)
  0.13 (2021-12-17):
    updated for KF herbs
  0.12 (2020-10-10):
    response message for buying herbs now has commas
  0.11 (2020-10-07):
    changed fill function to go to closest herbalist instead of a single hardcoded one, update for commas
  0.10 (2017-09-30):
    add feature to fill your herbsack with herbs (;useherbs stock herbs)
  0.9 (2017-03-04):
    remove 506 from the script, since it doesn't affect eating herbs anymore
  0.8 (2017-01-14):
    withdraw @silvers first when using the "stock potions" command
  0.7 (2015-04-26):
    fix for working with hidden containers, like the basket in Ta'Vaalor
  0.6 (2015-03-28):
    remember to look on/under/behind a container instead of "in" if a second look is required
    fix bug with finding a herbsack given on the command line
  0.5 (2015-02-23):
    better method of finding container from herbsack setting
  0.4 (2014-12-12):
    make "stock potions" track potion use instead of measuring every time
  0.3 (2014-11-14):
    set herbsack with ;useherbs set herbsack <container>

=end

# FIXME: escort healing doesn't heal blood
# fixme: garland of sovyn cloves
# fixme: skip more better
# fixme: buy herbs/right hand full
# fixme: use bank note

# possible eherbs to do: clean up dupes. Find missing herbs. Maybe add big/small blood, add backroom items

module EHerbs
  @@data ||= nil

  def self.data
    @@data
  end

  def self.load_eherbs_settings
    settings_hash = {
      :buy_missing     => CharSettings['buy_missing'],
      :deposit_coins   => CharSettings['deposit_coins'],
      :use_mending     => CharSettings['use_mending'],
      :skip_scars      => CharSettings['skip_scars'],
      :blood_toggle    => CharSettings['blood_toggle'],
      :use650          => CharSettings['use650'],
      :use1035         => CharSettings['use1035'],
      :use_yaba        => CharSettings['use_yaba'],
      :use_potions     => CharSettings['use_potions'],
      :stock           => CharSettings['stock'],
      :distiller       => CharSettings['distiller'],
      :herb_container  => UserVars.herbsack,
      :drinkable       => /\b(?:potion|tea|elixir|brew|tincture|ale|soup|porter)\b/i,
      :skippable       => [],
      :close_herbsack  => false,
      :done_empty_hand => false,
      :preposition     => nil,
      :return_to_stow  => false,
      :herb_sack       => nil,
      :survival_kit    => false,
      :shopping_list   => [],
      :start_room      => Room.current,
      :herb_shop_menu  => nil,
      :silvers         => nil,
      :withdraw_amount => 8000,
      :used_herbs      => [],
      :get_from        => nil,
      :heal_cutthroat  => true,
      :use_npchealer   => true,
      :no_get          => false,
      :blood_only      => false,
      :need_deposit    => false,
      :need_return     => false,
    }

    settings_hash[:open_regex] = Regexp.union(
      /You throw back/i,
      /You open/i,
      /Oh no! It's already/i,
      /You pick at the knot/i,
      /already open/i,
      /is open already/i,
      /You unfasten/i,
      /You glance around suspiciously/i,
      /^What were you referring to\?/i,
      /^I could not find what you were referring to\./i,
      /You pull the long strips of leather/i,
      /With a flick of your wrist/i,
      /Sliding the lever on the side/i,
      /You rub your hand/i,
      /There doesn't seem to be any way/i,
      /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i,
      /crumbles? and decays? away/,
      /Myriad spectral moths pull a cloakwing/,
      /<exposeContainer|<container/i
    )

    settings_hash[:needs_closed] = Regexp.union(
      /You throw back/i,
      /You open/i,
      /You pick at the knot/i,
      /You unfasten/i,
      /With a quick glance over your shoulder/i,
      /You pull the long strips of leather/i,
      /With a flick of your wrist/i,
      /Sliding the lever on the side/i,
      /You rub your hand/i,
      /Myriad spectral moths pull a cloakwing moth/,
    )

    settings_hash[:look_regex] = Regexp.union(
      /Peering into the <a exist=.*? noun="toolkit">/i,
      /That is closed/i,
      /is shut too tightly to see its contents/i,
      /In the(.*?)you see/i,
      /In the(.*?):/i,
      /There is nothing/i,
      /You glance/i,
      /^Attached to a.*keyring/i,
      /.*?[.*?]:/i,
      %r{The <a exist="\d+" noun="\w+">[^<]+</a> has (?:an? <a exist="\d+" noun="\w+">[^<]+</a> |nothing )?in.*scabbard and (?:an? <a exist="\d+" noun="\w+">[^<]+</a> |nothing )?in.*scabbard\.}i,
      /^I could not find what you were referring to\./i,
      /Hidden within the depths of a cloakwing moth greatcloak/,
      /<exposeContainer|<dialogData|<container/i
    )

    settings_hash[:close_regex] = Regexp.union(
      /^You (?:reach over your \w+ and )?close/,
      /^That is already closed/,
      /As you push/,
      /You tie/
    )

    settings_hash[:put_regex] = Regexp.union(
      /^You (?:put|(?:discreetly )?tuck|attach|toss|attempt to shield your|place|.* place|slip|wipe off the blade and sheathe|absent-mindedly drop|carefully add|find an incomplete bundle|untie your drawstring pouch)/,
      /^The .+ is already a bundle/,
      /^Your bundle would be too large if you if you tried to add that/,
      /^The .+ is too large to be bundled\./,
      /^As you place your .+ inside your .+, you notice another .+ inside the .+ and carefully arrange the two .+ into a neat bundle\./,
      /If you wish to continue, throw the item away again within fifteen seconds/,
      /you feel pleased with yourself at having cleaned up the surrounding area/,
      /over your shoulder/,
      /two items in that location/,
      /wear three functional items/,
      /^Your .*? won't fit in .*?\.$/,
      /You add/,
      /You find a suitable/
    )

    settings_hash[:get_regex] = Regexp.union(
      /^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly|just )?(?:remove|pick up|draw|grab|reach|slip|tuck|retrieve|already have|unsheathe|detach|swap)/,
      /^Get what\?$/,
      /^Why don't you leave some for others\?$/,
      /^You need a free hand/,
      /^You already have that/,
      /You just poured yourself/,
      /You retrieve/,
      /You break off/
    )

    settings_hash[:min_stock_doses] = {
      'major head scar'   => 6,
      'minor head wound'  => 4,
      'major nerve wound' => 4,
      'minor organ scar'  => 4,
      'major organ scar'  => 6,
      'missing eye'       => 7,
      'blood'             => 50,
      'major head wound'  => 25,
      'minor head scar'   => 25,
      'major organ wound' => 25,
      'minor organ wound' => 25,
      'major limb wound'  => 25,
      'minor limb wound'  => 25,
      'major limb scar'   => 25,
      'minor limb scar'   => 25,
      'severed limb'      => 25,
      'minor nerve wound' => 25,
      'major nerve scar'  => 25,
      'minor nerve scar'  => 25
    }

    # 5 main areas: 'head', 'neck', 'torso', 'limbs', 'nerves'
    # Wound method => herb area
    settings_hash[:areas] = { 'head' => 'head', 'neck' => 'head', 'torso' => 'organ', 'limbs' => 'limb', 'nerves' => 'nerve' }

    settings_hash[:var_names] = {
      'buy'         => 'buy_missing',
      'buy-missing' => 'buy_missing',
      'deposit'     => 'deposit_coins',
      'mending'     => 'use_mending',
      'skipscars'   => 'skip_scars',
      '650'         => 'use650',
      '1035'        => 'use1035',
      'yaba'        => 'use_yaba',
      'potions'     => 'use_potions'
    }

    settings_hash
  end

  def self.load(settings)
    @@data = settings
  end

  def self.save_eherbs_settings(settings)
    CharSettings['buy_missing']   = settings[:buy_missing]
    CharSettings['deposit_coins'] = settings[:deposit_coins]
    CharSettings['use_mending']   = settings[:use_mending]
    CharSettings['skip_scars']    = settings[:skip_scars]
    CharSettings['blood_toggle']  = settings[:blood_toggle]
    CharSettings['use650']        = settings[:use650]
    CharSettings['use1035']       = settings[:use1035]
    CharSettings['use_yaba']      = settings[:use_yaba]
    CharSettings['use_potions']   = settings[:use_potions]
    CharSettings['stock']         = settings[:stock]
    CharSettings['distiller']     = settings[:distiller]
    UserVars.herbsack             = settings[:herb_container]
  end

  if defined?(Gtk)
    # Setup is an extension of Gtk::Builder for Gtk setup
    class Setup < Gtk::Builder
      attr_accessor :settings

      @@categories = {
        general: {
          :buy_missing    => { default: false },
          :deposit_coins  => { default: false },
          :use_mending    => { default: false },
          :skip_scars     => { default: false },
          :blood_toggle   => { default: false },
          :herb_container => { default: '' },
          :use650         => { default: false },
          :use1035        => { default: false },
          :use_yaba       => { default: false },
          :use_potions    => { default: false },
          :stock          => { default: '' },
          :distiller      => { default: false },
        }
      }

      def self.get_category(key)
        @@categories.each { |category, data| return category unless data[key].nil? }
        nil
      end

      def self.get_setting(key)
        cat = Setup.get_category(key)
        return nil if cat.nil?

        @@categories[cat].each { |setting, data| return data if setting == key }
        nil
      end

      def initialize(settings)
        super()
        @settings = settings
        # set default values if they don't exist
        @@categories.each do |_, data|
          data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
        end
        # remove settings that doesn't exist
        @settings.delete_if { |key, _| next Setup.get_category(key).nil? }
        # use a GTK Builder to setup all the basics of the window then expand on that base

        # GoS only for Sigil of Mending
        @settings[:use_mending] = false unless Society.status == 'Guardians of Sunfist' && Society.rank >= 13

        return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

        Gtk.queue do
          # add_from_file("#{$data_dir}eherb.ui")
          add_from_string(Setup.eherbs_ui)
          load_settings
          self['main'].keep_above = true
          self['main'].set_title 'EHerbs Setup'
          # connect signals after settings are loaded to a bunch of handlers don't trigger
          connect_signals { |handler| method(handler) }
        end
      end

      def self.eherbs_ui
        '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkWindow" id="main"><property name="width-request">650</property><property name="height-request">375</property><property name="can-focus">False</property><property name="title" translatable="yes">EHerbs Setup</property><property name="default-width">-1</property><property name="default-height">425</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-bottom">5</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="buy_missing"><property name="label" translatable="yes">Buy missing herbs</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_mending"><property name="label" translatable="yes">Use Sigil of Mending</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="skip_scars"><property name="label" translatable="yes">Skip level 1 scars</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">40</property><property name="label" translatable="yes">Herb Sack</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="height">2</property>
        </packing></child><child><object class="GtkEntry" id="herb_container"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-end">10</property><property name="width-chars">40</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="height">2</property></packing></child><child><object class="GtkCheckButton" id="blood_toggle"><property name="label" translatable="yes">Heal Blood Only</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">25</property><property name="label" translatable="yes">Stock to % of Capacity</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="stock"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">When using ;eherbs stock it will fill your herb sack to a percentage of it\'s capacity.
        Primarily intended for survival kits but will work for ordinary containers.</property><property name="halign">start</property><property name="valign">center</property><property name="width-chars">15</property><property name="placeholder-text" translatable="yes">0 - 100</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="deposit_coins"><property name="label" translatable="yes">Deposit Coins</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-bottom">5</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="use650"><property name="label" translatable="yes">Assume Aspect (650) Yierka</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use1035"><property name="label" translatable="yes">Song of Tonis (1035)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_yaba"><property name="label" translatable="yes">Use yabathilium first</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_potions"><property name="label" translatable="yes">Try to use potions before plants</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="distiller"><property name="label" translatable="yes">Use Distiller (survival kits only)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Checks the survival kit when eherbs is used and keeps the distiller active. Survival kits were introduced at Dusk Ruin 2023 as a special herb container.</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing>
        </child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property></object><packing><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Changes are only saved if you use the Close button --&gt;</property><attributes><attribute name="style" value="italic"/>
        </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
        </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
      end

      # This is connected to automatically during load_settings and syncs data back to CharSettings.
      def on_update(obj)
        Gtk.queue do
          key = obj.builder_name.to_sym
          setting = Setup.get_setting(key)
          return if setting.nil?

          if obj.instance_of?(Gtk::CheckButton)
            @settings[key] = obj.active?
          elsif obj.instance_of?(Gtk::Entry)
            @settings[key] = obj.text.strip
          elsif objinstance_of?(Gtk::SpinButton)
            # update from text entry
            obj.update
            # force int, we don't use floats anywhere
            @settings[key] = obj.adjustment.value.to_i
          elsif obj.instance_of?(Gtk::ComboBoxText)
            @settings[key] = obj.active_text
          end
        end
      end

      def on_close_clicked
        EHerbs.load(@settings)
        self['main'].destroy
      end

      def on_destroy
        Gtk.queue do
          @running = false
        end
      end

      # iterate all objects and for any that match a setting name directly we set the default
      def load_settings
        Gtk.queue do
          # load up the generic settings which are just matching by name of the widget
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)

            key = obj.builder_name.to_sym
            next if (setting = Setup.get_setting(key)).nil?

            if obj.instance_of?(Gtk::CheckButton)
              obj.set_sensitive(false) if obj.builder_name.to_s.eql?("use_mending") && Society.status != 'Guardians of Sunfist' && Society.rank < 13
              obj.set_sensitive(false) if obj.builder_name.to_s.eql?('use650') && !Spell[650].known?
              obj.set_sensitive(false) if obj.builder_name.to_s.eql?('use1035') && !Spell[1035].known?

              if obj.builder_name =~ /^([^:]+):(.*)$/i
                key = Regexp.last_match(1).to_sym
                value = Regexp.last_match(2).to_s
                obj.active = @settings[key].include?(value)
              else
                obj.active = @settings[key]
              end
              obj.signal_connect('toggled') { on_update(obj) }
            elsif obj.instance_of?(Gtk::Entry)
              if @settings[key].instance_of?(String)
                obj.text = @settings[key].strip
              else
                obj.text = @settings[key].to_s
              end
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.instance_of?(Gtk::SpinButton)
              obj.value = @settings[key]
              obj.adjustment.value = @settings[key]
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.instance_of?(Gtk::ComboBoxText)
              obj.set_active(item) if item
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.instance_of?(Gtk::TreeView)
              if (store = self["#{key}_store"]).nil?
                respond "** failed to find store for treeview #{key}"
                next
              elsif setting[:load].nil?
                respond "** no :load defined #{key}"
                next
              end

              setting[:load].call(store, @settings[key])

              # setup the signals
              if (add = self["#{key}_add"]).nil?
                respond "** failed to find add for treeview #{key}"
                next
              elsif (delete = self["#{key}_delete"]).nil?
                respond "** failed to find delete for treeview #{key}"
                next
              elsif (entry = self["#{key}_entry"]).nil?
                respond "** failed to find entry for treeview #{key}"
                next
              end

              add.signal_connect('clicked') do
                if setting[:set].nil?
                  respond "** no :set defined for #{key}"
                  next
                elsif entry.text.empty?
                  next
                end
                setting[:set].call(store, entry.text, @settings[key])
                setting[:load].call(store, @settings[key])
              end

              delete.signal_connect('clicked') do
                if setting[:delete].nil?
                  respond "** no :delete defined for #{key}"
                  next
                elsif (selected = obj.selection.selected).nil?
                  next
                end
                setting[:delete].call(store, selected, @settings[key])
                setting[:load].call(store, @settings[key])
              end
            end
          end
        end
      end

      def start
        @running = true
        Gtk.queue { self['main'].show_all }
        wait_while { @running }
      end

      def list(cat_to_list: 'all')
        indent_size = 2
        print_array =
          proc do |key, value, indent|
            _respond("#{' ' * indent_size * indent.to_i}#{key}:")
            value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
          end

        print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

        categories = cat_to_list == 'all' ? %w[general internal] : [cat_to_list]
        output = if $frontend == 'stormfront'
                   "<output class=\"mono\"/>\n"
                 else
                   String.new
                 end
        categories.each do |opt|
          _respond(output) unless output.empty?
          _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
          @@categories[opt.to_sym].each do |id, _|
            value = @settings[id]
            value.instance_of?(Array) ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
          end
        end

        return unless $frontend == 'stormfront'

        _respond("<output class=\"\"/>\n")
      end

      def self.update_setting(key, value)
        setting = Setup.get_setting(key)
        echo "** Setting #{key.inspect} does not exist" if setting.nil?
        action = nil

        if value =~ /^([+-])(.*)$/
          action = Regexp.last_match(1)
          value = Regexp.last_match(2).strip.downcase
        end

        if value == 'reset'
          @settings.delete(key)
          echo " Reset #{key}"
        elsif @settings[key].instance_of?(Array)
          if value =~ /\d/ && @settings[key][value.to_i]
            @settings[key].delete_at(value.to_i)
          else
            @settings[key].delete(value)
          end

          if action == '-'
            echo " #{value.inspect} removed from #{key.inspect}"
          else
            @settings[key].push(value)
            echo " #{value.inspect} added to #{key.inspect}"
          end

          echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
        else
          if @settings[key].instance_of?(FalseClass) || @settings[key].instance_of?(TrueClass)
            value = value =~ /^true|1|yes|on/ ? true : false
          elsif @settings[key].instance_of?(Integer)
            value = value.to_i
          end

          echo "#{key.inspect} has been set to #{value.inspect}"
          @settings[key] = value
        end
      end
    end

  end

  def self.known_herbs
    [
      # Wehnimer's Landing 325/1028
      # Solhaven 5722/4740011
      # Northern Caravanasary 9276/4746124
      # Ta'Illistim 640/13104200
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some acantha leaf',    type: 'blood',             short_name: 'some acantha leaf',     store_doses: 10 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some wolifrew lichen', type: 'minor nerve wound', short_name: 'some wolifrew lichen',  store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'bolmara potion',       type: 'major nerve wound', short_name: 'bolmara potion',        store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some woth flower',     type: 'major nerve scar',  short_name: 'some woth flower',      store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some torban leaf',     type: 'minor nerve scar',  short_name: 'some torban leaf',      store_doses: 3 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some ambrominas leaf', type: 'minor limb wound',  short_name: 'some ambrominas leaf',  store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some ephlox moss',     type: 'major limb wound',  short_name: 'some ephlox moss',      store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some cactacae spine',  type: 'minor limb scar',   short_name: 'some cactacae spine',   store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some calamia fruit',   type: 'major limb scar',   short_name: 'some calamia fruit',    store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim"],                             name: 'rose-marrow potion',   type: 'minor head wound',  short_name: 'rose-marrow potion',    store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some aloeas stem',     type: 'major head wound',  short_name: 'some aloeas stem',      store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some haphip root',     type: 'minor head scar',   short_name: 'some haphip root',      store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'brostheras potion',    type: 'major head scar',   short_name: 'brostheras potion',     store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some basal moss',      type: 'minor organ wound', short_name: 'some basal moss',       store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some pothinir grass',  type: 'major organ wound', short_name: 'some pothinir grass',   store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'talneo potion',        type: 'minor organ scar',  short_name: 'talneo potion',         store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'wingstem potion',      type: 'major organ scar',  short_name: 'wingstem potion',       store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'bur-clover potion',    type: 'missing eye',       short_name: 'bur-clover potion',     store_doses: 1 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some sovyn clove',     type: 'severed limb',      short_name: 'some sovyn clove',      store_doses: 1 },

      # Zul Logoth 9505/13010004
      { location: ['Zul Logoth'],     name: 'grey mushroom potion',    type: 'blood',              short_name: 'grey mushroom potion',     store_doses: 7 },
      { location: ['Zul Logoth'],     name: 'green mushroom potion',   type: 'blood',              short_name: 'green mushroom potion',    store_doses: 5 },
      { location: ['Zul Logoth'],     name: 'bubbling brown ale',      type: 'minor limb wound',   short_name: 'bubbling brown ale',       store_doses: 3 },
      { location: ['Zul Logoth'],     name: 'thick foggy ale',         type: 'minor nerve wound',  short_name: 'thick foggy ale',          store_doses: 3 },
      { location: ['Zul Logoth'],     name: 'rusty red ale',           type: 'minor head wound',   short_name: 'rusty red ale',            store_doses: 3 },
      { location: ['Zul Logoth'],     name: 'chunky black ale',        type: 'minor organ wound',  short_name: 'chunky black ale',         store_doses: 3 },
      { location: ['Zul Logoth'],     name: 'crushed cavegrass tea',   type: 'major limb wound',   short_name: 'crushed cavegrass tea',    store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'glowing mold tea',        type: 'major nerve wound',  short_name: 'glowing mold tea',         store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'sticky lichen tea',       type: 'major head wound',   short_name: 'sticky lichen tea',        store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'roasted ratweed tea',     type: 'major organ wound',  short_name: 'roasted ratweed tea',      store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'spotted toadstool ale',   type: 'minor limb scar',    short_name: 'spotted toadstool ale',    store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'dark frothing ale',       type: 'minor nerve scar',   short_name: 'dark frothing ale',        store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'dull crimson ale',        type: 'minor head scar',    short_name: 'dull crimson ale',         store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'brown weedroot ale',      type: 'minor organ scar',   short_name: 'brown weedroot ale',       store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'stalactite brew',         type: 'major limb scar',    short_name: 'stalactite brew',          store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'stalagmite brew',         type: 'major nerve scar',   short_name: 'stalagmite brew',          store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'stone soot brew',         type: 'major head scar',    short_name: 'stone soot brew',          store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'dirty crevice brew',      type: 'major organ scar',   short_name: 'dirty crevice brew',       store_doses: 2 },
      { location: ['Zul Logoth'],     name: 'dirty rat fur potion',    type: 'missing eye',        short_name: 'dirty rat fur potion',     store_doses: 1 },
      { location: ['Zul Logoth'],     name: 'grainy black potion',     type: 'severed limb',       short_name: 'grainy black potion',      store_doses: 1 },
      { location: ['Zul Logoth'],     name: 'milky white potion',      type: 'lifekeep',           short_name: 'milky white potion',       store_doses: 3 },

      # Cysaegir 4647/14051034
      # Ravelin 13943/14201010
      # Sylvarraend 13137/13051014 NOTE-  the Lich location for Sylvarraend is "Ta'Illistim", but the tincture values match Cesaegir values, not the ones from Herablist2 in TI.
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of acantha',      type: 'blood',             short_name: 'tincture of acantha',           store_doses: 10 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of ambrominas',   type: 'minor limb wound',  short_name: 'tincture of ambrominas',        store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of wolifrew',     type: 'minor nerve wound', short_name: 'tincture of wolifrew',          store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of rose-marrow',  type: 'minor head wound',  short_name: 'tincture of rose-marrow',       store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of basal',        type: 'minor organ wound', short_name: 'tincture of basal',             store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of ephlox',       type: 'major limb wound',  short_name: 'tincture of ephlox',            store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of bolmara',      type: 'major nerve wound', short_name: 'tincture of bolmara',           store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of aloeas',       type: 'major head wound',  short_name: 'tincture of aloeas',            store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of pothinir',     type: 'major organ wound', short_name: 'tincture of pothinir',          store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of cactacae',     type: 'minor limb scar',   short_name: 'tincture of cactacae',          store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of torban',       type: 'minor nerve scar',  short_name: 'tincture of torban',            store_doses: 3 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of haphip',       type: 'minor head scar',   short_name: 'tincture of haphip',            store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of talneo',       type: 'minor organ scar',  short_name: 'tincture of talneo',            store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of calamia',      type: 'major limb scar',   short_name: 'tincture of calamia',           store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of woth',         type: 'major nerve scar',  short_name: 'tincture of woth',              store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of brostheras',   type: 'major head scar',   short_name: 'tincture of brostheras',        store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of wingstem',     type: 'major organ scar',  short_name: 'tincture of wingstem',          store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of bur-clover',   type: 'missing eye',       short_name: 'tincture of bur-clover',        store_doses: 1 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of sovyn',        type: 'severed limb',      short_name: 'tincture of sovyn',             store_doses: 1 },

      # Ta'Illistim 2 19282/13204008
      { location: ["Ta'Illistim"],   name: 'tincture of acantha',     type: 'blood',              short_name: 'tincture of acantha',     store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of wolifrew',    type: 'minor nerve wound',  short_name: 'tincture of wolifrew',    store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of torban',      type: 'minor nerve scar',   short_name: 'tincture of torban',      store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of woth',        type: 'major nerve scar',   short_name: 'tincture of woth',        store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of ambrominas',  type: 'minor limb wound',   short_name: 'tincture of ambrominas',  store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of basal',       type: 'minor organ wound',  short_name: 'tincture of basal',       store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of ephlox',      type: 'major limb wound',   short_name: 'tincture of ephlox',      store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of pothinir',    type: 'major organ wound',  short_name: 'tincture of pothinir',    store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of aloeas',      type: 'major head wound',   short_name: 'tincture of aloeas',      store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of rose-marrow', type: 'minor head wound',   short_name: 'tincture of rose-marrow', store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of cactacae',    type: 'minor limb scar',    short_name: 'tincture of cactacae',    store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of calamia',     type: 'major limb scar',    short_name: 'tincture of calamia',     store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of haphip',      type: 'minor head scar',    short_name: 'tincture of haphip',      store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of brostheras',  type: 'major head scar',    short_name: 'tincture of brostheras',  store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of bolmara',     type: 'major nerve wound',  short_name: 'tincture of bolmara',     store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of talneo',      type: 'minor organ scar',   short_name: 'tincture of talneo',      store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of bur-clover',  type: 'missing eye',        short_name: 'tincture of bur-clover',  store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of wingstem',    type: 'major organ scar',   short_name: 'tincture of wingstem',    store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of sovyn',       type: 'severed limb',       short_name: 'tincture of sovyn',       store_doses: 10 },

      # Teras 1851/3003056
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Olak's Ol'style ale",    type: 'blood',              short_name: "Olak's Ol'style ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Olak's Ol'style ale",    type: 'blood',              short_name: "Olak's Ol'style ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Lost Dogwater ale',      type: 'minor limb wound',   short_name: 'Lost Dogwater ale',          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Lost Dogwater ale',      type: 'minor limb wound',   short_name: 'Lost Dogwater ale',          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Orc's Head ale",         type: 'minor nerve wound',  short_name: "Orc's Head ale",             store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Orc's Head ale",         type: 'minor nerve wound',  short_name: "Orc's Head ale",             store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Semak's Smooth ale",     type: 'minor head wound',   short_name: "Semak's Smooth ale",         store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Semak's Smooth ale",     type: 'minor head wound',   short_name: "Semak's Smooth ale",         store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Mama Dwarf's ale",       type: 'minor organ wound',  short_name: "Mama Dwarf's ale",           store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Mama Dwarf's ale",       type: 'minor organ wound',  short_name: "Mama Dwarf's ale",           store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Bloody Krolvin ale',     type: 'blood',              short_name: 'Bloody Krolvin ale',         store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Bloody Krolvin ale',     type: 'blood',              short_name: 'Bloody Krolvin ale',         store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Golden Goose ale',       type: 'major limb wound',   short_name: 'Golden Goose ale',           store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Golden Goose ale',       type: 'major limb wound',   short_name: 'Golden Goose ale',           store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Kenar's Dropjaw ale",    type: 'major nerve wound',  short_name: "Kenar's Dropjaw ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Kenar's Dropjaw ale",    type: 'major nerve wound',  short_name: "Kenar's Dropjaw ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Dark Swampwater ale',    type: 'major head wound',   short_name: 'Dark Swampwater ale',        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Dark Swampwater ale',    type: 'major head wound',   short_name: 'Dark Swampwater ale',        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Aged Schooner ale',      type: 'major organ wound',  short_name: 'Aged Schooner ale',          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Aged Schooner ale',      type: 'major organ wound',  short_name: 'Aged Schooner ale',          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Bearded Ladies' ale",    type: 'minor limb scar',    short_name: "Bearded Ladies' ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Bearded Ladies' ale",    type: 'minor limb scar',    short_name: "Bearded Ladies' ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Miner's Muddy ale",      type: 'minor nerve scar',   short_name: "Miner's Muddy ale",          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Miner's Muddy ale",      type: 'minor nerve scar',   short_name: "Miner's Muddy ale",          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Agrak's Amber ale",      type: 'minor head scar',    short_name: "Agrak's Amber ale",          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Agrak's Amber ale",      type: 'minor head scar',    short_name: "Agrak's Amber ale",          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Gert's Homemade ale",    type: 'minor organ scar',   short_name: "Gert's Homemade ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Gert's Homemade ale",    type: 'minor organ scar',   short_name: "Gert's Homemade ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Mad Mutt Frothy ale',    type: 'major limb scar',    short_name: 'Mad Mutt Frothy ale',        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Mad Mutt Frothy ale',    type: 'major limb scar',    short_name: 'Mad Mutt Frothy ale',        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Dacra's Dream ale",      type: 'major nerve scar',   short_name: "Dacra's Dream ale",          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Dacra's Dream ale",      type: 'major nerve scar',   short_name: "Dacra's Dream ale",          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Reaper's Red ale",       type: 'major head scar',    short_name: "Reaper's Red ale",           store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Reaper's Red ale",       type: 'major head scar',    short_name: "Reaper's Red ale",           store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Reaper's Red ale",       type: 'major head scar',    short_name: "Reaper's Red ale",           store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Wort's Winter ale",      type: 'major organ scar',   short_name: "Wort's Winter ale",          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Wort's Winter ale",      type: 'major organ scar',   short_name: "Wort's Winter ale",          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Volcano Vision ale',     type: 'missing eye',        short_name: 'Volcano Vision ale',         store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Volcano Vision ale',     type: 'missing eye',        short_name: 'Volcano Vision ale',         store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Captn' Pegleg's ale",    type: 'severed limb',       short_name: "Captn' Pegleg's ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Captn' Pegleg's ale",    type: 'severed limb',       short_name: "Captn' Pegleg's ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Dead Man's Pale ale",    type: 'lifekeep',           short_name: "Dead Man's Pale ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Dead Man's Pale ale",    type: 'lifekeep',           short_name: "Dead Man's Pale ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Dragon's Blood porter",  type: 'raisedead',          short_name: "Dragon's Blood porter",      store_doses: 1 },

      # Icemule 3363/4043866
      # Hinterwilds 31061/7503257
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'Dabbings Family special tart',      type: 'minor limb wound',    short_name: 'Family special tart',       store_doses: 10 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: "Leaftoe's lichen tart",             type: 'minor nerve wound',   short_name: 'lichen tart',               store_doses: 10 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'candied ptarmigan feather',         type: 'severed limb',        short_name: 'ptarmigan feather',         store_doses: 1 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'earthworm potion',                  type: 'major organ scar',    short_name: 'earthworm potion',          store_doses: 2 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'elk horn potion',                   type: 'minor head wound',    short_name: 'elk horn potion',           store_doses: 4 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'gelatinous elk fat tart',           type: 'minor limb scar',     short_name: 'elk fat tart',              store_doses: 10 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'iceberry tart',                     type: 'blood',               short_name: 'iceberry tart',             store_doses: 10 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'rock lizard potion',                type: 'minor organ scar',    short_name: 'rock lizard potion',        store_doses: 4 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: "slice of Ma Leaftoe's Special",     type: 'minor nerve scar',    short_name: "Ma Leaftoe's Special",      store_doses: 5 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'slice of pickled walrus blubber',   type: 'major limb scar',     short_name: 'pickled walrus blubber',    store_doses: 2 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'slice of sparrowhawk pie',          type: 'minor head scar',     short_name: 'sparrowhawk pie',           store_doses: 5 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'small egg and tundra grass tart',   type: 'minor organ wound',   short_name: 'tundra grass tart',         store_doses: 5 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'snowflake elixir',                  type: 'major nerve wound',   short_name: 'snowflake elixir',          store_doses: 4 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: "some frog's bone porridge",         type: 'major limb wound',    short_name: "frog's bone porridge",      store_doses: 4 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'starfish potion',                   type: 'missing eye',         short_name: 'starfish potion',           store_doses: 1 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'tiny cup of polar bear fat soup',   type: 'major head scar',     short_name: 'polar bear fat soup',       store_doses: 2 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'tiny flower-shaped tart',           type: 'major nerve scar',    short_name: 'flower-shaped tart',        store_doses: 2 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'tiny musk ox tart',                 type: 'major organ wound',   short_name: 'musk ox tart',              store_doses: 2 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: "tiny ram's bladder tart",           type: 'major head wound',    short_name: "ram's bladder tart",        store_doses: 2 },

      # Pinefar 2782/4564010
      { location: ['the Pinefar Trading Post'], name: 'some acantha leaf tea',    type: 'blood',              short_name: 'acantha leaf tea',        store_doses: 10 },
      { location: ['the Pinefar Trading Post'], name: 'some sweetfern tea',       type: 'minor limb wound',   short_name: 'sweetfern tea',           store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'some red lichen tea',      type: 'minor nerve wound',  short_name: 'red lichen tea',          store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'some feverfew tea',        type: 'minor head wound',   short_name: 'feverfew tea',            store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'some ginkgo nut tea',      type: 'minor organ wound',  short_name: 'ginkgo nut tea',          store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'some sassafras tea',       type: 'blood',              short_name: 'sassafras tea',           store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'sweetfern potion',         type: 'major limb wound',   short_name: 'sweetfern potion',        store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'red lichen potion',        type: 'major nerve wound',  short_name: 'red lichen potion',       store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'feverfew potion',          type: 'major head wound',   short_name: 'feverfew potion',         store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'ginkgo nut potion',        type: 'major organ wound',  short_name: 'ginkgo nut potion',       store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'manroot tea',              type: 'minor limb scar',    short_name: 'manroot tea',             store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'valerian root tea',        type: 'minor nerve scar',   short_name: 'valerian root tea',       store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'pennyroyal tea',           type: 'minor head scar',    short_name: 'pennyroyal tea',          store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'wyrmwood root tea',        type: 'minor organ scar',   short_name: 'wyrmwood root tea',       store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'manroot potion',           type: 'major limb scar',    short_name: 'manroot potion',          store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'valerian root potion',     type: 'major nerve scar',   short_name: 'valerian root potion',    store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'pennyroyal potion',        type: 'major head scar',    short_name: 'pennyroyal potion',       store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'wyrmwood root potion',     type: 'major organ scar',   short_name: 'wyrmwood root potion',    store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'daggit root potion',       type: 'missing eye',        short_name: 'daggit root potion',      store_doses: 1 },
      { location: ['the Pinefar Trading Post'], name: 'angelica root potion',     type: 'severed limb',       short_name: 'angelica root potion',    store_doses: 1 },
      { location: ['the Pinefar Trading Post'], name: 'earwort potion',           type: 'disease',            short_name: 'earwort potion',          store_doses: 1 },

      # Kraken's Fall 28938/7118357
      { location: ["Kraken's Fall"], name: 'some acantha leaf',            type: 'blood',               short_name: 'acantha leaf',       store_doses: 10 },
      { location: ["Kraken's Fall"], name: 'some wolifrew lichen',         type: 'minor nerve wound',   short_name: 'wolifrew lichen',    store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some torban leaf',             type: 'minor nerve scar',    short_name: 'torban leaf',        store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'bolmara elixir',               type: 'major nerve wound',   short_name: 'bolmara elixir',     store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some woth flower',             type: 'major nerve scar',    short_name: 'woth flower',        store_doses: 3 },
      { location: ["Kraken's Fall"], name: 'rose-marrow elixir',           type: 'minor head wound',    short_name: 'rose-marrow elixir', store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some haphip root',             type: 'minor head scar',     short_name: 'haphip root',        store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some aloeas stem',             type: 'major head wound',    short_name: 'aloeas stem',        store_doses: 2 },
      { location: ["Kraken's Fall"], name: 'brostheras elixir',            type: 'major head scar',     short_name: 'brostheras elixir',  store_doses: 2 },
      { location: ["Kraken's Fall"], name: 'ball of basal moss',           type: 'minor organ wound',   short_name: 'basal moss',         store_doses: 7 },
      { location: ["Kraken's Fall"], name: 'talneo elixir',                type: 'minor organ scar',    short_name: 'talneo elixir',      store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some pothinir grass',          type: 'major organ wound',   short_name: 'pothinir grass',     store_doses: 2 },
      { location: ["Kraken's Fall"], name: 'wingstem elixir',              type: 'major organ scar',    short_name: 'wingstem elixir',    store_doses: 2 },
      { location: ["Kraken's Fall"], name: 'some ambrominas leaf',         type: 'minor limb wound',    short_name: 'ambrominas leaf',    store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some cactacae spine',          type: 'minor limb scar',     short_name: 'cactacae spine',     store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'ball of ephlox moss',          type: 'major limb wound',    short_name: 'ephlox moss',        store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some calamia fruit',           type: 'major limb scar',     short_name: 'calamia fruit',      store_doses: 2 },
      { location: ["Kraken's Fall"], name: 'cumin-rubbed sovyn clove',     type: 'severed limb',        short_name: 'sovyn clove',        store_doses: 1 },
      { location: ["Kraken's Fall"], name: 'bur-clover elixir',            type: 'missing eye',         short_name: 'bur-clover elixir',  store_doses: 1 },

      # Mist Harbor 3363/4043866
      { location: ['the Isle of Four Winds'], name: 'some fragrant woth flower',      type: 'major nerve scar',   short_name: 'fragrant woth flower',             store_doses: 3 },
      { location: ['the Isle of Four Winds'], name: 'some dirty haphip root',         type: 'minor head scar',    short_name: 'dirty haphip root',                store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'sticky ball of basal moss',      type: 'minor organ wound',  snort_name: 'sticky ball of basal moss',        store_doses: 7 },
      { location: ['the Isle of Four Winds'], name: 'gooey ball of ephlox moss',      type: 'major limb wound',   short_name: 'gooey ball of ephlox moss',        store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'some sugary ambrominas leaf',    type: 'minor limb wound',   short_name: 'sugary ambrominas leaf',           store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'some fresh torban leaf',         type: 'minor nerve scar',   short_name: 'fresh torban leaf',                store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'some spicy acantha leaf',        type: 'blood',              short_name: 'spicy acantha leaf',               store_doses: 10 },
      { location: ['the Isle of Four Winds'], name: 'small sovyn clove',              type: 'severed limb',       short_name: 'small sovyn clove',                store_doses: 1 },
      { location: ['the Isle of Four Winds'], name: 'some bright pothinir grass',     type: 'major organ wound',  short_name: 'some bright green pothinir grass', store_doses: 2 },
      { location: ['the Isle of Four Winds'], name: 'some withered aloeas stem',      type: 'major head wound',   short_name: 'withered aloeas stem',             store_doses: 2 },
      { location: ['the Isle of Four Winds'], name: 'some ripe calamia fruit',        type: 'major limb scar',    short_name: 'ripe calamia fruit',               store_doses: 2 },
      { location: ['the Isle of Four Winds'], name: 'some prickly cactacae spine',    type: 'minor limb scar',    short_name: 'prickly cactacae spine',           store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'some dry wolifrew lichen',       type: 'minor nerve wound',  short_name: 'dry wolifrew lichen',              store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'crystalline rose-marrow elixir', type: 'minor head wound',   short_name: 'rose-marrow elixir',               store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'crystalline talneo elixir',      type: 'minor organ scar',   short_name: 'talneo elixir',                    store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'crystalline brostheras elixir',  type: 'major head scar',    short_name: 'brostheras elixir',                store_doses: 2 },
      { location: ['the Isle of Four Winds'], name: 'crystalline bolmara elixir',     type: 'major nerve wound',  short_name: 'bolmara elixir',                   store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'crystalline wingstem elixir',    type: 'major organ scar',   short_name: 'wingstem elixir',                  store_doses: 2 },
      { location: ['the Isle of Four Winds'], name: 'crystalline bur-clover elixir',  type: 'missing eye',        short_name: 'bur-clover elixir',                store_doses: 1 },

      # River's Rest 10863/2101012
      { location: ["River's Rest"], name: 'beaker of malted winterberry brew', type: 'minor head wound',   short_name: 'beaker of winterberry brew',  store_doses: 4 },
      { location: ["River's Rest"], name: 'beaker of winterberry brew',        type: 'minor head wound',   short_name: 'winterberry brew',            store_doses: 4 },

      # I don't have a location or details for the following
      # foragable only?
      { location: ['Forageable'],    name: 'yabathilium fruit',                type: 'blood',    short_name: 'yabathilium fruit',       store_doses: 1 },
      # alchemical only?
      { location: ['Alchemical'],    name: 'tincture of yabathilium',          type: 'blood',    short_name: 'tincture of yabathilium', store_doses: 1 },
      { location: ['Alchemical'],    name: 'dimly glowing sky-blue potion',    type: 'disease',  short_name: 'sky-blue potion',         store_doses: 4 },
      { location: ['Alchemical'],    name: 'dimly glowing sea-green potion',   type: 'poison',   short_name: 'sea-green potion',        store_doses: 4 }
    ]
  end

  module Actions
    def self.blood_only
      return unless (checkhealth + 7) < maxhealth

      if EHerbs.data[:herb_sack].nil?
        EHerbs.data[:herb_sack] = Utility.find_herbsack
        Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])
      end

      if EHerbs.data[:survival_kit]
        if EHerbs.data[:use_yaba]
          contents = Inventory.survival_contents(EHerbs.data[:herb_sack])
          herb = contents.find_all { |i| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) and h[:type] == 'blood' } }
          yaba = herb.find { |h| h.name =~ /yabathilium/ }
          herb = yaba
        end
        if EHerbs.data[:potions] && herb.nil?
          contents = Inventory.survival_contents(EHerbs.data[:herb_sack], 'drinkable')
          herb = contents.find { |i| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) and h[:type] == 'blood' } }
        end
        unless herb
          contents = Inventory.survival_contents(EHerbs.data[:herb_sack])
          herb = contents.find { |i| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) and h[:type] == 'blood' } }
        end

      else
        if EHerbs.data[:use_yaba]
          herb = EHerbs.data[:herb_sack].contents.find_all { |i| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) and h[:type] == 'blood' } }
          yaba = herb.find { |h| h.name =~ /yabathilium/ }
          herb = yaba.nil? ? herb.first : yaba
        end
        herb = EHerbs.data[:herb_sack].contents.find { |i| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) and h[:type] == 'blood' and i.name =~ EHerbs.data[:drinkable] } } if EHerbs.data[:potions] && herb.nil?
        herb ||= EHerbs.data[:herb_sack].contents.find { |i| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) and h[:type] == 'blood' } }
      end

      if herb
        Inventory.stow_herb
        unless EHerbs.data[:no_get] && (herb.name !~ EHerbs.data[:drinkable])
          herb = Inventory.drag_to_hand(herb)
        end

        Actions.cast_spells if Utility.able_to_cast

        use_cmd = herb.name =~ EHerbs.data[:drinkable] ? "drink ##{herb.id}" : "eat ##{herb.id}"

        while (checkhealth + 7) < maxhealth
          use_result = dothistimeout use_cmd, 5, /^You (?:manage to )?take a (?:bite|drink)/
          if use_result.nil?
            echo 'fixme 5'
            exit
          else
            EHerbs.data[:used_herbs].push(herb.id) unless EHerbs.data[:used_herbs].include?(herb.id)
            Utility.wait_rt
          end
        end
      else
        EHerbs.data[:skippable].push 'blood' if herb_type == 'blood'
        respond "\nMissing herb for #{herb_type}.\n\n   #{EHerbs.known_herbs.find_all { |h| h[:type] == 'blood' }.collect { |h| h[:name] }.join(', ')}\n\n"
      end
    end

    def self.bundle_herb
      same_potion = same_herb = false

      got_salad = (GameObj.right_hand.noun !~ EHerbs.data[:drinkable])
      got_croutons = (GameObj.left_hand.noun !~ EHerbs.data[:drinkable])
      got_milk = (GameObj.right_hand.noun =~ EHerbs.data[:drinkable])
      got_syrup = (GameObj.left_hand.noun =~ EHerbs.data[:drinkable])
      # second get full name in each hand - if not the same, move on to prevent mixing
      # potion types inappropriately.
      same_potion = GameObj.right_hand.name.sub(GameObj.right_hand.noun, '').rstrip == GameObj.left_hand.name.sub(GameObj.left_hand.noun, '').rstrip unless got_milk.nil? || got_syrup.nil?

      same_herb = GameObj.right_hand.name.sub(GameObj.right_hand.noun, '').rstrip == GameObj.left_hand.name.sub(GameObj.left_hand.noun, '').rstrip unless got_salad.nil? || got_croutons.nil?

      if same_potion
        old_herb = GameObj.right_hand
        new_herb = GameObj.left_hand
        10.times do
          break unless (GameObj.right_hand.id == old_herb.id) || (GameObj.left_hand.id == new_herb.id)

          result = dothistimeout "pour ##{new_herb.id} in ##{old_herb.id}", 5, /^You carefully pour a little bit from your|^You can't pour|^I can't find that|^I could not find what you were referring to/
          if result =~ /^You can't pour any more in there without spilling it\./
            $eherbs_measure[old_herb.id] = 10 if old_herb.name =~ /barrel/
            $eherbs_measure[old_herb.id] = 7 if old_herb.name !~ /barrel/
            break
          elsif GameObj.left_hand.name == 'Empty'
            break
          elsif result =~ /^You can't pour|^I can't find that|^I could not find what you were referring to/
            break
          end
        end
      elsif same_herb
        old_herb = GameObj.right_hand
        new_herb = GameObj.left_hand
        bundle_result = dothistimeout 'bundle', 5, /^Carefully, you combine|^If you add anything more to this bundle|^You do not have anything to bundle!$|^You can't put .* together in a bundle!/
        # SIMU does not send the full descriptions of items in right / left hands in XML
        # so we have to do this work-around.
        if bundle_result =~ /^You can't put (.*)<a exist=.*noun=.*>(.*), and (.*)<a exist=.*noun=.*>(.*) together in a bundle!/
          herb_right = Regexp.last_match(1) + Regexp.last_match(2)
          herb_left = Regexp.last_match(3) + Regexp.last_match(4)
          if herb_right != herb_left
            respond
            respond Msg.monsterbold("The herbs don't match! Your old herb is #{herb_right}, and you bought #{herb_left}.")
            respond
            respond "This happens when you move areas.  What you should do depends on how long you'll be in the area.  If you're moving permanently, throw the herbs in your right hand away and put the herbs in your left hand in your #{EHerbs.data[:herb_sack]}."
            respond "If you're only visiting temporarily, put the herbs in your right hand in another container for your return and put the herbs in your left hand in your #{EHerbs.data[:herb_sack]}."
            respond
            respond "When finished, run #{$clean_lich_char}#{Script.current.name} with your stocking options again."
            exit
          end
        end
      end
    end

    def self.buy_herb(herb_type)
      EHerbs.data[:need_return] = true
      EHerbs.data[:silvers] = Utility.check_silver

      EHerbs.data[:herb_shop_menu] = Utility.read_menu unless EHerbs.data[:herb_shop_menu]
      herb_name = EHerbs.data[:herb_shop_menu].keys.find { |name| EHerbs.known_herbs.any? { |h| (h[:type] == herb_type) and (name == h[:name] || name == h[:short_name]) } }
      unless (order_number = EHerbs.data[:herb_shop_menu][herb_name])
        echo "error: failed to find a herb for #{herb_type} in the menu"
        exit
      end

      # FIXME: Put bulk buying here
      # Fixme: Max is 10

      order_result = dothistimeout "order #{order_number}", 3, /^You will need a free hand|BUY/
      if order_result =~ /You will need a free hand/
        fput "put ##{GameObj.right_hand.id} in #{EHerbs.data[:herb_sack]}"
        fput "put ##{GameObj.left_hand.id} in #{EHerbs.data[:herb_sack]}"
      end
      buy_result = dothistimeout 'buy', 3, /Sold for [0-9,]+ silver|^But you do not have enough silver!|You're going to need a free hand/
      case buy_result
      when /Sold for ([0-9,]+) silver/
        EHerbs.data[:silvers] -= ::Regexp.last_match(1).gsub(',', '').to_i
      when /^But you do not have enough silver!/
        Actions.withdraw
        Actions.go_to_herbalist
        return Actions.buy_herb(herb_type)
      when /You're going to need a free hand/
        EHerbs.data[:done_empty_hand] = true
        empty_hands
      else
        EHerbs.data[:silvers] = Utility.check_silver
      end
      # potential fixme - no left hand check and no stow hands?

      return GameObj.right_hand if checkright
    end

    def self.cast_spells
      Spell[9713].cast if EHerbs.data[:use_mending] && Spell[9713].known? && Spell[9713].affordable? && !Effects::Buffs.active?('Sigil of Mending')

      Spell[1035].cast if Spell[1035].known? && Spell[1035].affordable? && !Effects::Buffs.active?('Song of Tonis') && EHerbs.data[:use1035]

      return unless EHerbs.data[:use650]

      if Spell[650].known? && Spell[650].affordable? && !Spell[650].active? && !Effects::Buffs.active?('Aspect of the Yierka') && !Spell[9039].active?
        Spell[650].cast
        sleep 1
        waitcastrt?
        fput 'assume yierka'
      elsif Spell[650].active? && !Effects::Buffs.active?('Aspect of the Yierka') && !Spell[9039].active? && checkmana > 25
        waitcastrt?
        fput 'assume yierka'
      end
    end

    def self.deposit
      silvers = Utility.check_silver

      return unless silvers > 0

      Utility.go2('bank')
      if XMLData.room_title == '[Pinefar, Depository]' && GameObj.npcs.any? { |npc| npc.noun == 'banker' }
        fput "give banker #{silvers} silvers"
      else
        fput "deposit #{silvers}"
      end
    end

    def self.escort
      if Script.current.vars[2]
        unless (escort = GameObj.npcs.find { |npc| (npc.id == Script.current.vars[2]) || (npc.noun == Script.current.vars[2]) })
          echo "Failed to find an npc with id or noun #{Script.current.vars[2]}."
          exit
        end
      else
        unless (escort = GameObj.npcs.find { |npc| npc.type =~ /escort/ })
          echo 'Failed to find an escort.'
          exit
        end
      end
      EHerbs.data[:herb_sack] = Utility.find_herbsack if EHerbs.data[:herb_sack].nil?
      Inventory.open_single_container(EHerbs.data[:herb_sack])
      look_result = dothistimeout "look ##{escort.id}", 10, /^(?:She|He) appears to be in good shape\.|^(?:She|He) has|^I could not find what you were referring to\./
      if look_result.nil?
        echo "error: timeout while trying to look at escort (#{escort.name}, #{escort.id})"
      elsif look_result =~ /^I could not find what you were referring to\./
        echo "error: can't see escort"
      elsif look_result =~ /^(?:She|He) appears to be in good shape\./
        echo 'nothing to do'
      elsif look_result =~ /^(?:She|He) has/
        escort_injuries = []
        if look_result =~ /severe head trauma and bleeding from the ears/
          escort_injuries.push('major head wound')
          escort_injuries.push('major head wound')
          escort_injuries.push('minor head wound')
        end
        if look_result =~ /minor lacerations about the head and a possible mild concussion/
          escort_injuries.push('major head wound')
          escort_injuries.push('minor head wound')
        end
        if look_result =~ /snapped bones and serious bleeding from the neck/
          escort_injuries.push('major head wound')
          escort_injuries.push('major head wound')
          escort_injuries.push('minor head wound')
        end
        if look_result =~ /moderate bleeding from (?:his|her) neck/
          escort_injuries.push('major head wound')
          escort_injuries.push('minor head wound')
        end
        if look_result =~ /deep gashes and serious bleeding from (?:his|her) chest/
          escort_injuries.push('major organ wound')
          escort_injuries.push('major organ wound')
          escort_injuries.push('minor organ wound')
        end
        if look_result =~ /deep lacerations across (?:his|her) chest/
          escort_injuries.push('major organ wound')
          escort_injuries.push('minor organ wound')
        end
        if look_result =~ /deep gashes and serious bleeding from (?:his|her) abdomen/
          escort_injuries.push('major organ wound')
          escort_injuries.push('major organ wound')
          escort_injuries.push('minor organ wound')
        end
        if look_result =~ /deep lacerations across (?:his|her) abdomen/
          escort_injuries.push('major organ wound')
          escort_injuries.push('minor organ wound')
        end
        if look_result =~ /deep gashes and serious bleeding from (?:his|her) back/
          escort_injuries.push('major organ wound')
          escort_injuries.push('major organ wound')
          escort_injuries.push('minor organ wound')
        end
        if look_result =~ /deep lacerations across (?:his|her) back/
          escort_injuries.push('major organ wound')
          escort_injuries.push('minor organ wound')
        end
        if look_result =~ /a blinded right eye/
          #        escort_injuries.push('missing eye')
          escort_injuries.push('major organ wound')
          escort_injuries.push('major organ wound')
          escort_injuries.push('minor organ wound')
        end
        if look_result =~ /a blinded left eye/
          #        escort_injuries.push('missing eye')
          escort_injuries.push('major organ wound')
          escort_injuries.push('major organ wound')
          escort_injuries.push('minor organ wound')
        end
        if look_result =~ /a swollen right eye/
          escort_injuries.push('major organ wound')
          escort_injuries.push('minor organ wound')
        end
        if look_result =~ /a swollen left eye/
          escort_injuries.push('major organ wound')
          escort_injuries.push('minor organ wound')
        end
        if look_result =~ /a completely severed right leg/
          escort_injuries.push('major limb wound')
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a completely severed left leg/
          escort_injuries.push('major limb wound')
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a completely severed right arm/
          escort_injuries.push('major limb wound')
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a completely severed left arm/
          escort_injuries.push('major limb wound')
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a completely severed right hand/
          escort_injuries.push('major limb wound')
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a completely severed left hand/
          escort_injuries.push('major limb wound')
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a fractured and bleeding right leg/
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a fractured and bleeding left leg/
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a fractured and bleeding right arm/
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a fractured and bleeding left arm/
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a fractured and bleeding right hand/
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a fractured and bleeding left hand/
          escort_injuries.push('major limb wound')
          escort_injuries.push('minor limb wound')
        end
        if look_result =~ /a case of uncontrollable convulsions/
          escort_injuries.push('major nerve wound')
          escort_injuries.push('minor nerve wound')
        end
        if look_result =~ /a case of sporadic convulsions/
          escort_injuries.push('major nerve wound')
          escort_injuries.push('minor nerve wound')
        end
        escort_injuries.push('minor head wound') if look_result =~ /minor bruises (about the head)/
        escort_injuries.push('minor head wound') if look_result =~ /minor bruises on (?:his|her) neck/
        escort_injuries.push('minor organ wound') if look_result =~ /minor cuts and bruises on (?:his|her) chest/
        escort_injuries.push('minor organ wound') if look_result =~ /minor cuts and bruises on (?:his|her) abdomen/
        escort_injuries.push('minor organ wound') if look_result =~ /minor cuts and bruises on (?:his|her) back/
        escort_injuries.push('minor organ wound') if look_result =~ /a bruised right eye/
        escort_injuries.push('minor organ wound') if look_result =~ /a bruised left eye/
        escort_injuries.push('minor limb wound') if look_result =~ /some minor cuts and bruises on (?:his|her) right leg/
        escort_injuries.push('minor limb wound') if look_result =~ /some minor cuts and bruises on (?:his|her) left leg/
        escort_injuries.push('minor limb wound') if look_result =~ /some minor cuts and bruises on (?:his|her) right arm/
        escort_injuries.push('minor limb wound') if look_result =~ /some minor cuts and bruises on (?:his|her) left arm/
        escort_injuries.push('minor limb wound') if look_result =~ /some minor cuts and bruises on (?:his|her) right hand/
        escort_injuries.push('minor limb wound') if look_result =~ /some minor cuts and bruises on (?:his|her) left hand/
        escort_injuries.push('minor nerve wound') if look_result =~ /a strange case of muscle twitching/

        # echo escort_injuries.inspect
        empty_right_hand

        escort_injuries.each do |herb_type|
          herb = nil
          if EHerbs.known_herbs.any? { |h| h[:type] == herb_type && (h[:name] == GameObj.right_hand.name || (h[:short_name] && h[:short_name] == GameObj.right_hand.name)) }
            herb = GameObj.right_hand
          elsif EHerbs.known_herbs.any? { |h| h[:type] == herb_type && (h[:name] == GameObj.left_hand.name || (h[:short_name] && h[:short_name] == GameObj.left_hand.name)) }
            herb = GameObj.left_hand
          else
            Inventory.stow_herb
            contents = EHerbs.data[:survival_kit] ? Inventory.survival_contents(EHerbs.data[:herb_sack]) : EHerbs.data[:herb_sack].contents

            if (herb = contents.find { |i| EHerbs.known_herbs.find { |h| (h[:name] == i.name) && h[:type] == herb_type } })
              EHerbs.data[:used_herbs].push(herb.id) unless EHerbs.data[:used_herbs].include?(herb.id)
              get_result = dothistimeout "get ##{herb.id}", 5, EHerbs.data[:get_regex]
              if get_result.nil? || (get_result =~ /^Get what\?/)
                echo "error: timeout while trying to get herb (#{herb.name}, #{herb.id})"
                dothistimeout "close ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:close_regex] if EHerbs.data[:close_herbsack]
                exit
              elsif get_result =~ /^You need a free hand for that\./
                echo 'fixme 28382'
                dothistimeout "close ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:close_regex] if EHerbs.data[:close_herbsack]
                exit
              end
            end
          end

          dothistimeout "give ##{escort.id}", 10, /accepts your .* hands it back to you|ignores your offer/ if herb
        end
        Inventory.stow_herb
        fill_right_hand
      end

      dothistimeout "close ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:close_regex] if EHerbs.data[:close_herbsack]

      exit
    end

    def self.fill_herbs
      # 5-7 doses: There is a good bit left in the rose-marrow potion.
      # 3-4 doses: There is a small amount in the rose-marrow potion.
      # 1-2 doses: There is just a little left in the rose-marrow potion.
      EHerbs.data[:done_empty_hand] = false
      Utility.assert_herbsack_var
      EHerbs.data[:herb_sack] = Utility.find_herbsack if EHerbs.data[:herb_sack].nil?

      Inventory.open_single_container(EHerbs.data[:herb_sack])

      if checkright
        if GameObj.right_hand.type =~ /herb/
          Inventory.drag_to_container(GameObj.right_hand.id, EHerbs.data[:herb_sack].id, EHerbs.data[:preposition])
        else
          empty_hands
          EHerbs.data[:done_empty_hand] = true
        end
      end
      if checkleft
        if GameObj.left_hand.type =~ /herb/
          Inventory.drag_to_container(GameObj.left_hand.id, EHerbs.data[:herb_sack].id, EHerbs.data[:preposition])
        else
          empty_hands
          EHerbs.data[:done_empty_hand] = true
        end
      end

      contents = EHerbs.data[:survival_kit] ? Inventory.survival_contents(EHerbs.data[:herb_sack]) : EHerbs.data[:herb_sack].contents

      herb_type_fill = []
      types = ['blood', 'major head wound', 'minor head wound', 'major head scar', 'minor head scar', 'major organ wound', 'minor organ wound', 'major organ scar', 'minor organ scar', 'missing eye', 'major limb wound', 'minor limb wound', 'major limb scar', 'minor limb scar', 'severed limb', 'major nerve wound', 'minor nerve wound', 'major nerve scar', 'minor nerve scar']
      types.each do |kind|
        herb_type_fill.push(kind) unless contents.any? { |obj| EHerbs.known_herbs.any? { |herb| (herb[:name] =~ /#{obj.name}/ || herb[:short_name] =~ /#{obj.name}/) && herb[:type] == kind } }
      end

      if herb_type_fill.empty?
        _respond
        _respond Msg.monsterbold('Done - you have one of each herb available at this location.')
        _respond
      else
        EHerbs.data[:silvers] = Utility.check_silver unless EHerbs.data[:silvers]
        Actions.withdraw unless EHerbs.data[:silvers] > 4000
        Actions.go_to_herbalist

        EHerbs.data[:herb_shop_menu] = Utility.read_menu
        herb_type_fill.each do |kind|
          herb_name = EHerbs.data[:herb_shop_menu].keys.find { |name| EHerbs.known_herbs.any? { |h| (h[:type] == kind) && (name =~ /#{h[:name]}/ || name =~ /#{h[:name].sub(/sticky |gooey | green| fragrant| shiny| dirty/, '')}/) } }
          unless (order_number = EHerbs.data[:herb_shop_menu][herb_name])
            echo "error: failed to find a herb for #{kind} in the menu"
            exit
          end
          dothistimeout "order #{order_number}", 3, /BUY/
          buy_result = dothistimeout 'buy', 3, /Sold for [0-9,]+ silver|^But you do not have enough silver!/
          case buy_result
          when /Sold for ([0-9,]+) silver/
            EHerbs.data[:silvers] -= Regexp.last_match(1).gsub(',', '').to_i
            if checkright
              herb = GameObj.right_hand
              dothistimeout "_drag ##{herb.id} ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:put_regex]
              if (herb_info = EHerbs.known_herbs.find { |h| h[:name] == herb.name })
                $eherbs_measure[herb.id] = herb_info[:store_doses]
              end
            end
            if checkleft
              herb = GameObj.left_hand
              dothistimeout "_drag ##{herb.id} ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:put_regex]
              if (herb_info = EHerbs.known_herbs.find { |h| h[:name] =~ /#{herb.name}$/ })
                $eherbs_measure[herb.id] = herb_info[:store_doses]
              end
            end
          when /^But you do not have enough silver!/
            Actions.withdraw
            Actions.go_to_herbalist
            return Actions.fill_herbs
          else
            EHerbs.data[:silvers] = Utility.check_silver
          end
        end

        fput "close ##{EHerbs.data[:herb_sack].id}" if EHerbs.data[:close_herbsack]
        Actions.deposit
        Utility.go2(EHerbs.data[:start_room].id.to_s) if Room.current.id != EHerbs.data[:start_room].id
        fill_hands if EHerbs.data[:done_empty_hand]
      end

      exit
    end

    def self.go_to_herbalist
      Utility.go2('herbalist')
    end

    def self.stock_herbs
      both = false
      did_something = false
      Utility.assert_herbsack_var

      EHerbs.data[:herb_sack] = Utility.find_herbsack if EHerbs.data[:herb_sack].nil?

      Inventory.open_single_container(EHerbs.data[:herb_sack])
      if Script.current.vars[2].nil? || (Script.current.vars[2].downcase =~ /potions|herbs|major|minor|missing|severed|blood|combined/)
        # The distinction of only edible herbs for certain wounds was lost with Teras.
        # This prevented the script from stocking anywhere but a few locations.  Now,
        # the script deals in categories rather than specific names, and can stock
        # anywhere.
        # EHerbs.data[:shopping_list] = []
        herb_type_list = ['blood', 'major head wound', 'minor head scar', 'major organ wound', 'minor organ wound', 'major limb wound', 'minor limb wound', 'major limb scar', 'minor limb scar', 'severed limb', 'minor nerve wound', 'major nerve scar', 'minor nerve scar']
        potion_type_list = ['major head scar', 'minor head wound', 'major nerve wound', 'minor organ scar', 'major organ scar', 'missing eye']
        if Script.current.vars[2].downcase == 'potions'
          seek_type_list = potion_type_list
        elsif Script.current.vars[2].downcase == 'herbs'
          seek_type_list = herb_type_list
        elsif Script.current.vars[0].downcase =~ /major|minor|missing|severed|blood/
          Script.current.vars.delete_if { |var| var =~ /^stock$/i }
          Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
          seek_type_list = [Script.current.vars[0]]
        elsif Script.current.vars[2].downcase == 'combined'
          seek_type_list = potion_type_list + herb_type_list
        else
          seek_type_list = potion_type_list + herb_type_list
          both = true
        end
        EHerbs.data[:done_empty_hand] = false

        if Room.current.location =~ /Icemule Trace|the Pinefar Trading Post|the town of Kharam-Dzu|Ta'Illistim|Cysaegir|the hamlet of Ravelin|Zul Logoth/ && !EHerbs.data[:survival_kit]
          _respond
          _respond Msg.monsterbold(' This location only uses drinkable or non-bundling herbs, so bundling does not work.')
          _respond Msg.monsterbold(' You should use the ') + "#{$clean_lich_char}#{Script.current.name} fill" + Msg.monsterbold(' feature for this location.')
          _respond
        else

          if EHerbs.data[:survival_kit]

            if Script.current.vars[2].downcase == 'potions' || both
              seek_type_list = potion_type_list + herb_type_list
              Inventory.get_current_stock(seek_type_list, 'drinkable')

              unless EHerbs.data[:shopping_list].to_s.empty?
                Actions.stock_requested_herbs('drinkable')
                did_something = true
              end
            end
            if Script.current.vars[2].downcase == 'herbs' || both
              seek_type_list = potion_type_list + herb_type_list
              Inventory.get_current_stock(seek_type_list, 'edible')
              unless EHerbs.data[:shopping_list].to_s.empty?
                Actions.stock_requested_herbs('edible')
                did_something = true
              end
            end
            if Script.current.vars[2].downcase == 'combined'
              Inventory.get_current_stock(seek_type_list)
              unless EHerbs.data[:shopping_list].to_s.empty?
                Actions.stock_requested_herbs
                did_something = true
              end
            end
            if Script.current.vars[2].downcase !~ /herbs|potions|combined/ && !both
              Inventory.get_current_stock(seek_type_list, 'drinkable')
              unless EHerbs.data[:shopping_list].to_s.empty?
                Actions.stock_requested_herbs('drinkable')
                did_something = true
              end

              Inventory.get_current_stock(seek_type_list, 'edible')
              unless EHerbs.data[:shopping_list].to_s.empty?
                Actions.stock_requested_herbs('edible')
                did_something = true
              end
            end

          else
            Inventory.get_current_stock(seek_type_list)
            unless EHerbs.data[:shopping_list].to_s.empty?
              Actions.stock_requested_herbs
              did_something = true
            end

          end

          unless did_something
            _respond Msg.monsterbold('Done - you are fully stocked with herbs at this location.')
            exit
          end

          # Fixme use free_hands
          dothistimeout "put ##{GameObj.right_hand.id} in ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:put_regex] if checkright
          dothistimeout "put ##{GameObj.left_hand.id} in ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:put_regex] if checkleft

          fill_hands if EHerbs.data[:done_empty_hand]
          Actions.deposit
          Utility.go2(EHerbs.data[:start_room].id.to_s)
        end

      end

      exit
    end

    def self.stock_requested_herbs(type = nil)
      if EHerbs.data[:shopping_list].empty?
        _respond Msg.monsterbold(' Done - you are fully stocked with herbs or there is nothing to buy here.') if type.nil? || type == 'edible'
        _respond Msg.monsterbold(' Done - you are fully stocked with potions or there is nothing to buy here.') if type == 'drinkable'
        return
      end

      done_gone_to_herbalist = false
      respond
      respond 'shopping list:' if type.nil?
      respond "shopping list: #{type}"
      EHerbs.data[:shopping_list].each do |thing|
        if thing[:herb_name] == 'any'
          respond "any #{thing[:category]}".rjust(25) + " (#{thing[:needed]})"
        else
          respond "#{thing[:herb_name].rjust(25)} (#{thing[:needed]})"
        end
      end
      respond

      EHerbs.data[:shopping_list].each do |thing|
        unless done_gone_to_herbalist
          Actions.withdraw if Utility.check_silver < 1500
          Actions.go_to_herbalist
          done_gone_to_herbalist = true
        end
        unless EHerbs.data[:done_empty_hand]
          # FIXME: use free_hands
          empty_hands
          EHerbs.data[:done_empty_hand] = true
        end

        current_location = Room.current.location

        herb_type = case type
                    when 'drinkable'
                      EHerbs.known_herbs.find { |h| h[:type] == thing[:category] && h[:name] =~ EHerbs.data[:drinkable] && h[:location].any? { |place| place =~ /#{current_location}/ } }[:type]
                    when 'edible'
                      EHerbs.known_herbs.find { |h| h[:type] == thing[:category] && h[:name] !~ EHerbs.data[:drinkable] && h[:location].any? { |place| place =~ /#{current_location}/ } }[:type]
                    else
                      EHerbs.known_herbs.find { |h| h[:type] == thing[:category] && h[:location].any? { |place| place =~ /#{current_location}/ } }[:type]
                    end

        unless EHerbs.data[:survival_kit]
          if thing[:herb_name] == 'any'
            while (missing_herb = thing[:herb_list].shift)
              echo "Buying a new herb: #{missing_herb}"
            end
          else
            while (old_herb = thing[:herb_list].shift)
              next if old_herb.empty?

              fput "get ##{old_herb.id}"
              30.times do
                break if GameObj.right_hand.id == old_herb.id || GameObj.left_hand.id == old_herb.id

                sleep(0.10)
              end
            end
            Actions.bundle_herb if checkleft && checkright
          end
        end

        # Fixme Loop for greater than 10 needed - check more_deeds

        thing[:needed].times do
          Actions.buy_herb(herb_type)

          if EHerbs.data[:survival_kit]
            dothistimeout "put ##{GameObj.right_hand.id} in ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:put_regex] if checkright
            dothistimeout "put ##{GameObj.left_hand.id} in ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:put_regex] if checkleft
          elsif checkleft && checkright
            Actions.bundle_herb
          end
        end
        dothistimeout "put ##{GameObj.right_hand.id} in ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:put_regex] if checkright
        dothistimeout "put ##{GameObj.left_hand.id} in ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:put_regex] if checkleft
      end
    end

    def self.use_herbs
      drinkable = false

      if EHerbs.data[:herb_sack].nil?
        EHerbs.data[:herb_sack] = Utility.find_herbsack
        Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])
      end

      while (herb_type = Utility.next_herb_type)
        herb = nil
        if EHerbs.known_herbs.any? { |h| h[:type] == herb_type && (h[:name] =~ /#{GameObj.right_hand.name}/ || (h[:short_name] =~ /#{GameObj.right_hand.name}/)) }
          herb = GameObj.right_hand
        elsif EHerbs.known_herbs.any? { |h| h[:type] == herb_type && (h[:name] =~ /#{GameObj.left_hand.name}/ || (h[:short_name] && h[:short_name] =~ /#{GameObj.left_hand.name}/)) }
          herb = GameObj.left_hand
        elsif [Wounds.leftArm, Wounds.rightArm].min < 3
          Utility.go2(EHerbs.data[:start_room].id.to_s) if EHerbs.data[:return_to_stow]
          if EHerbs.data[:survival_kit]
            if herb_type == 'blood' && EHerbs.data[:use_yaba] && herb.nil?
              contents = Inventory.survival_contents(EHerbs.data[:herb_sack])
              herb = contents.find_all { |i| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) && h[:type] == herb_type } }
              yaba = herb.find { |h| h.name =~ /yabathilium/ }
              herb = yaba
            end
            if EHerbs.data[:potions] && herb.nil?
              contents = Inventory.survival_contents(EHerbs.data[:herb_sack], 'drinkable')
              herb = contents.find { |i| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) && h[:type] == herb_type } }
            end
            if herb.nil?
              contents = Inventory.survival_contents(EHerbs.data[:herb_sack])
              herb = contents.find { |i| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) && h[:type] == herb_type } }
            end
          else
            contents = Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])
            if herb_type == 'blood' && EHerbs.data[:use_yaba] && herb.nil?
              herb = contents.find_all { |i| EHerbs.known_herbs.find { |h| (h[:name] == i.name || h[:short_name] == i.name) && h[:type] == herb_type } }
              yaba = herb.find { |h| h.name =~ /yabathilium/ }
              herb = yaba.nil? ? herb.first : yaba
            end
            herb = contents.find { |i| EHerbs.known_herbs.find { |h| (h[:name] == i.name || h[:short_name] == i.name) && h[:type] == herb_type && i.name =~ EHerbs.data[:drinkable] } } if EHerbs.data[:potions] && herb.nil?
            herb = contents.find { |i| EHerbs.known_herbs.find { |h| (h[:name] == i.name || h[:short_name] == i.name) && h[:type] == herb_type } } if herb.nil?
          end
          if herb
            Inventory.stow_herb
            unless EHerbs.data[:no_get] && (herb.name !~ EHerbs.data[:drinkable])
              result = Inventory.drag_to_hand(herb)
              drinkable = result == 'drinkable' ? true : false
            end
          end
        end

        if EHerbs.data[:buy_missing] == true && herb.nil?
          Inventory.stow_herb
          EHerbs.data[:silvers] = Utility.check_silver unless EHerbs.data[:silvers]
          Actions.withdraw unless EHerbs.data[:silvers] > 4000
          Actions.go_to_herbalist
          Actions.buy_herb(herb_type)

          if EHerbs.known_herbs.any? { |info| info[:name] =~ /#{GameObj.right_hand.name}/ }
            herb = GameObj.right_hand
          elsif EHerbs.known_herbs.any? { |info| info[:name] =~ /#{GameObj.left_hand.name}/ }
            herb = GameObj.left_hand
          else
            echo 'fixme: 6'
            EHerbs.data[:buy_missing] = false
          end

          drinkable = herb.name =~ EHerbs.data[:drinkable] ? true : false

        end
        if herb
          Actions.cast_spells if Utility.able_to_cast
          EHerbs.data[:used_herbs].push(herb.id) unless EHerbs.data[:used_herbs].include?(herb.id)

          if EHerbs.data[:no_get]
            use_cmd = "eat #{herb.noun}"
          else
            use_cmd = drinkable ? "drink my #{herb.noun}" : "eat my #{herb.noun}"
          end

          use_result = Utility.get_res(use_cmd, /^You (?:manage to )?take a (?:bite|drink)|You must pick the|Why don't you leave some for others/)
          Utility.wait_rt
          if use_result =~ /You must pick the/
            _respond Msg.monsterbold(' You have --no-get flagged but are required to pick up the herb.')
            exit
          elsif use_result =~ /Why don't you leave some for others?/
            _respond Msg.monsterbold(" You have eaten enough from the #{EHerbs.data[:herb_sack]}.")
            exit
          elsif use_result.nil?
            echo ' No result for eating herbs'
            exit
          end
        else
          case herb_type
          when /head/
            EHerbs.data[:skippable].push 'head'
            EHerbs.data[:skippable].push 'neck'
          when /organ|missing eye/
            EHerbs.data[:skippable].push 'torso'
          when /limb/
            EHerbs.data[:skippable].push 'limbs'
          when /nerve/
            EHerbs.data[:skippable].push 'nerves'
          when 'blood'
            EHerbs.data[:skippable].push 'blood'
          else
            EHerbs.data[:skippable].push herb_type
          end
          respond "\nMissing herb for #{herb_type}.\n\n   #{EHerbs.known_herbs.find_all { |h| h[:type] == herb_type }.collect { |h| h[:name] }.join(', ')}\n\n"
        end

      end
    end

    def self.withdraw
      original_room = Room.current.id
      Utility.check_cutthroat
      Utility.go2('bank')
      fput 'unhide' if invisible?
      if XMLData.room_title == '[Pinefar, Depository]'
        if GameObj.npcs.any? { |npc| npc.noun == 'banker' }
          result = dothistimeout "ask banker for #{[EHerbs.data[:withdraw_amount].to_i, 20].max} silvers", 1, /suspicious/
          if result =~ /suspicious/
            _respond
            _respond Msg.monsterbold('You have no coins in the bank, moving back to starting point')
            _respond
            sleep 2
            Utility.go2(EHerbs.data[:start_room].id.to_s)

            exit
          end
        # The banker nods and says, "Alright, here ye go.  Ye understand I be takin' a little more than that from ye account in the 'Mule.  I don't works for free!"
        # The banker looks at you suspiciously and says, "Hmm, I don't think ye be havin' enough in ye account to cover that and my fee.  Ye tryin' to pull one over on me?"
        elsif (icemule_bank = Room.list.find { |room| room.location == 'Icemule Trace' && room.tags.include?('bank') })
          Utility.go2(icemule_bank.id.to_s)
          result = dothistimeout "withdraw #{EHerbs.data[:withdraw_amount]} silvers", 1, /debt collector|suspicious/
          case result
          when /debt collector/
            fput "withdraw #{EHerbs.data[:withdraw_amount]} silvers"
          when /suspicious/
            _respond
            _respond Msg.monsterbold('You have no coins in the bank, moving back to starting point')
            _respond
            sleep 2
            Utility.go2(EHerbs.data[:start_room].id.to_s)
            exit
          end
        else
          echo 'waiting for banker...'
          wait_until { GameObj.npcs.any? { |npc| npc.noun == 'banker' } }
          fput "ask banker for #{[EHerbs.data[:withdraw_amount].to_i, 20].max} silvers"
        end
      else
        result = dothistimeout "withdraw #{EHerbs.data[:withdraw_amount]} silvers", 1, /debt collector|suspicious|chuckles at you/
        case result
        when /debt collector/
          fput "withdraw #{EHerbs.data[:withdraw_amount]} silvers"
        when /suspicious|chuckles at you/
          _respond
          _respond Msg.monsterbold('You have no coins in the bank, moving back to starting point')
          _respond
          sleep 2
          Utility.go2(EHerbs.data[:start_room].id.to_s)
          exit
        end
      end
      EHerbs.data[:silvers] += EHerbs.data[:withdraw_amount]
      EHerbs.data[:need_deposit] = true if EHerbs.data[:deposit_coins]
      Utility.go2(original_room)
    end
  end

  module Inventory
    def self.drag_to_container(item_id, container_id, preposition = nil)
      preposition = 'in' if preposition.to_s.empty?
      Utility.get_res("put ##{item_id} #{preposition} ##{container_id}", EHerbs.data[:put_regex])
    end

    def self.drag_to_hand(herb)
      # Check hands - make sure there is an empty one
      Inventory.free_hand

      to = GameObj.right_hand.id.nil? ? 'right' : 'left'

      result = Utility.get_res("_drag ##{herb.id} #{to}", EHerbs.data[:get_regex])

      if result =~ EHerbs.data[:drinkable]
        return 'drinkable'
      elsif result =~ /Why don't you leave some for others?/
        _respond Msg.monsterbold(" You have eaten enought from the #{EHerbs.data[:herb_sack]}.")
        exit
      end
    end

    def self.free_hand
      unless (GameObj.right_hand.id.nil? && [Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max < 3) || (GameObj.left_hand.id.nil? && [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max < 3)
        if GameObj.right_hand.id && ([Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max < 3 || [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max == 3)
          waitrt?
          Inventory.free_hands(right: true)
        else
          waitrt?
          Inventory.free_hands(left: true)
        end
      end
    end

    def self.free_hands(right: false, left: false, both: false)
      if (right || both) && checkright
        if !GameObj.right_hand.id.nil?
          fput "stow #{GameObj.right_hand}"
          Inventory.single_drag(GameObj.right_hand)
        end
      end

      if (left || both) && checkleft
        if !GameObj.left_hand.id.nil?
          fput "stow #{GameObj.left_hand}"
        end
      end
    end

    def self.get_current_stock(seek_type_list, type = nil)
      EHerbs.data[:shopping_list] = []
      current_location = Room[Room.current.find_nearest_by_tag('town')].location

      if EHerbs.data[:survival_kit]
        $eherbs_measure = {}
        result = Utility.get_lines("look in #{EHerbs.data[:herb_sack]}", %r{In .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a|There is nothing}).join(' ')
        edible_result_contents = Regexp.last_match(5) if result =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains DOSEs (.*?)\.}
        liquid_result_contents = Regexp.last_match(5) if result =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains TINCTUREs (.*?)\.}

        result_contents = case type
                          when 'drinkable'
                            liquid_result_contents.to_s
                          when 'edible'
                            edible_result_contents.to_s
                          else
                            liquid_result_contents.to_s + edible_result_contents.to_s
                          end

        result_contents.scan(%r{(:?) <a exist="(.*?)" noun="(.*?)">(.*?)</a> \((.*?)\)}).each do |_, exist, _noun, _name, count|
          $eherbs_measure[exist] = count.to_i
        end

        contents = Inventory.survival_contents(EHerbs.data[:herb_sack], type)

      else
        type = nil
        EHerbs.data[:herb_sack].contents.each do |obj|
          next unless EHerbs.known_herbs.any? { |h| seek_type_list.include?(h[:type]) && (h[:name] == obj.name || h[:short_name] == obj.name) } && $eherbs_measure[obj.id].nil?

          dothistimeout "get ##{obj.id}", 10, EHerbs.data[:get_regex]
          dothistimeout "measure ##{obj.id}", 10, /^The .*? left/
          dothistimeout "put ##{obj.id} in ##{EHerbs.data[:herb_sack].id}", 10, EHerbs.data[:put_regex]
        end

        contents = EHerbs.data[:herb_sack].contents

      end

      seek_type_list.each do |bippity|
        # Check if the type of herb we want is available.
        herb_type = case type
                    when 'drinkable'
                      EHerbs.known_herbs.find { |h| h[:type] == bippity && h[:name] =~ EHerbs.data[:drinkable] && h[:location].any? { |place| place =~ /#{current_location}/ } }
                    when 'edible'
                      EHerbs.known_herbs.find { |h| h[:type] == bippity && h[:name] !~ EHerbs.data[:drinkable] && h[:location].any? { |place| place =~ /#{current_location}/ } }
                    else
                      EHerbs.known_herbs.find { |h| h[:type] == bippity && h[:location].any? { |place| place =~ /#{current_location}/ } }
                    end

        next if herb_type.to_s.empty?

        last_total_doses = -1

        herb_list_items = case type
                          when 'drinkable'
                            contents.find_all { |obj| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{obj.name}/ || h[:short_name] =~ /#{obj.name}/ || h[:short_name].include?(obj.name.sub('elixir', ''))) && h[:type] == bippity && h[:name] =~ EHerbs.data[:drinkable] } }
                          when 'edible'
                            contents.find_all { |obj| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{obj.name}/ || h[:short_name] =~ /#{obj.name}/ || h[:short_name].include?(obj.name.sub('elixir', ''))) && h[:type] == bippity && h[:name] !~ EHerbs.data[:drinkable] } }
                          else
                            contents.find_all { |obj| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{obj.name}/ || h[:short_name] =~ /#{obj.name}/ || h[:short_name].include?(obj.name.sub('elixir', ''))) && h[:type] == bippity } }
                          end

        total_doses = 0

        herb_list_items.each { |h| total_doses += $eherbs_measure[h.id].to_i }
        # echo "#{bippity}: #{total_doses} Herb: #{herb_list}"
        next unless total_doses < EHerbs.data[:min_stock_doses][bippity]
        next unless total_doses > last_total_doses

        # let's try to get the current location and fill in the missing herb info
        # if we can't get the current location, we'll cheat a bit with a generic entry
        if herb_list_items.empty?
          details = EHerbs.known_herbs.find { |h| h[:type] == bippity && h[:location].any? { |place| place =~ /#{current_location}/ } }

          if details.nil?
            EHerbs.data[:shopping_list].push(category: bippity, herb_name: 'any', herb_list: ['missing'], needed: 2)
          else
            EHerbs.data[:shopping_list].push(category: bippity, herb_name: details[:short_name], herb_list: [''], needed: ((EHerbs.data[:min_stock_doses][bippity] - total_doses) / details[:store_doses]))
          end
        else
          herb_list_items.each { |h| @herb_name = h.name || @herb_name = h.short.name }
          details = EHerbs.known_herbs.find { |h| h[:type] == bippity && h[:location].any? { |place| place =~ /#{current_location}/ } }
          EHerbs.data[:shopping_list].push(category: bippity, herb_name: details[:short_name], herb_list: herb_list_items, needed: ((EHerbs.data[:min_stock_doses][bippity] - total_doses) / details[:store_doses])) if ((EHerbs.data[:min_stock_doses][bippity] - total_doses) / details[:store_doses]) >= 1
        end
      end
      # echo EHerbs.data[:shopping_list]
    end

    def self.herb_container_contents_load(container = nil)
      under_contents = behind_contents = on_contents = in_contents = nil

      # If passed a string check if its part of the inventory
      if container.instance_of?(String)
        str_container = container
        container = GameObj.inv.find { |obj| obj.name =~ /#{container}/ }
        container = container.nil? ? str_container : container
      end

      # If it's a GameObj
      if container.instance_of?(GameObj) && GameObj.inv.find { |obj| obj.id =~ /#{container.id}/ }
        EHerbs.data[:herb_sack] = container
        Inventory.open_single_container(container)
        Utility.determine_survival_kit(container)
        if EHerbs.data[:survival_kit]
          return Inventory.survival_contents(container)
        else
          return EHerbs.data[:herb_sack].contents
        end
      end

      # If still here then the container is still a string - lets find it
      EHerbs.data[:herb_sack] = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.name =~ /#{container}/ }

      unless EHerbs.data[:herb_sack].instance_of?(GameObj)
        (GameObj.room_desc.to_a + GameObj.loot.to_a).each { |thing|
          ["in", "on", "under", "behind"].each { |preposition|
            result = Utility.get_lines("look #{preposition} #{thing}", %r{<container|There is nothing|In|On|Under|Behind}).join(' ')
            matches = result.scan(/.*?exist="(-?\d+)" noun="(.*?)">(.*?)<\/a>/)
            matches.each do |match|
              if match[1] =~ /#{container}/ || match[2] =~ /#{container}/
                EHerbs.data[:herb_sack] = GameObj.new(match[0], match[1], match[2])
                break
              end
            end
            break if EHerbs.data[:herb_sack]
          }
          break if EHerbs.data[:herb_sack]
        }
      end

      unless EHerbs.data[:herb_sack].instance_of?(GameObj)
        _respond Msg.monsterbold(" Not able to find a #{container}. Exiting...")
        exit
      end

      EHerbs.data[:preposition] = EHerbs.data[:preposition].nil? ? 'in' : EHerbs.data[:preposition]

      loop do
        result = Utility.get_lines("look #{EHerbs.data[:preposition]} ##{EHerbs.data[:herb_sack].id}", %r{(In|On|Under|Behind) .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a|There is nothing}).join(' ')

        case result
        when %r{Under .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a>(?::| you see )(.*?)$}
          under_contents = Regexp.last_match(4)
          break
        when %r{Behind .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a>(?::| you see )(.*?)$}
          behind_contents = Regexp.last_match(4)
          break
        when %r{On .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a>(?::| you see )(.*?)$}
          on_contents = Regexp.last_match(4)
          break
        when %r{In .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a>(?::| you see )(.*?)$}
          in_contents = Regexp.last_match(4)
          break
        when %r{That is closed.}
          unless EHerbs.data[:preposition] == 'in'
            break
          end

          result = Inventory.open_single_container(EHerbs.data[:herb_sack])
          if result == 'locked'
            _respond Msg.monsterbold(" Not able to look in #{container}. It's locked. Exiting...")
            exit
          end
        else
          break
        end
      end

      case EHerbs.data[:preposition]
      when 'under'
        result_contents = under_contents
      when 'behind'
        result_contents = behind_contents
      when 'on'
        result_contents = on_contents
      when 'in'
        result_contents = in_contents
      end

      contents = []
      result_contents.scan(%r{<a exist="(.*?)" noun="(.*?)">(.*?)</a>}).each do |exist, noun, name|
        contents.push(GameObj.new_inv(exist, noun, name, EHerbs.data[:herb_sack].id.to_s))
      end

      contents = contents.dup.reject do |obj|
        found_herb = EHerbs.known_herbs.find { |herb| herb[:name] =~ /#{obj.name}/ }
        next true unless found_herb
      end
      contents
    end

    def self.open_single_container(sack)
      return if sack.nil? || sack.empty?

      # If its in the game obj and contents.is_a?(Array) return
      return if GameObj.containers.keys.include?(sack.id) && sack.contents.is_a?(Array)

      # Still here? Assume the sack is closed and open it
      result = Utility.get_lines("open ##{sack.id}", EHerbs.data[:open_regex])

      EHerbs.data[:close_herbsack] = true if result.grep(EHerbs.data[:needs_closed]).any?

      return 'locked' if result.grep(/It appears to be locked./).any?

      # check out whats inside
      lines = Utility.get_lines("look in ##{sack.id}", EHerbs.data[:look_regex])
      return if lines.grep(/You glance|There is nothing/i).any?

      20.times do
        break if GameObj.containers.keys.include?(sack.id) && sack.contents.is_a?(Array)

        sleep 0.1
      end
    end

    def self.stow_herb
      relook = false
      Utility.go2(EHerbs.data[:start_room].id.to_s) if EHerbs.data[:return_to_stow]

      if EHerbs.data[:used_herbs].include?(GameObj.right_hand.id)
        Inventory.drag_to_container(GameObj.right_hand.id, EHerbs.data[:herb_sack].id, EHerbs.data[:preposition])
        fput('stow right') if checkright
        relook = true
      end
      if EHerbs.data[:used_herbs].include?(GameObj.left_hand.id)
        Inventory.drag_to_container(GameObj.left_hand.id, EHerbs.data[:herb_sack].id, EHerbs.data[:preposition])
        fput('stow left') if checkleft
        relook = true
      end
      # Fixme: stow_herbs is odd
      Inventory.herb_container_contents_load(EHerbs.data[:herb_sack]) if %w[under behind].include?(EHerbs.data[:preposition]) && relook == true
    end

    def self.survival_contents(container, type = nil)
      result = Utility.get_lines("look in ##{container.id}", %r{(In|On|Under|Behind) .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a|There is nothing}).join(' ')

      EHerbs.data[:herb_sack] = GameObj.new(Regexp.last_match(2), Regexp.last_match(3), Regexp.last_match(4)) if result =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains (.*?)\.}
      edible_result_contents = Regexp.last_match(5) if result =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains DOSEs (.*?)\.}
      liquid_result_contents = Regexp.last_match(5) if result =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains TINCTUREs (.*?)\.}

      result_contents = case type
                        when 'drinkable'
                          liquid_result_contents.to_s
                        when 'edible'
                          edible_result_contents.to_s
                        else
                          liquid_result_contents.to_s + edible_result_contents.to_s
                        end

      contents = []
      result_contents.scan(%r{(:?) <a exist="(.*?)" noun="(.*?)">(.*?)</a> (\(\d+\))}).each do |_what, exist, noun, name|
        contents.push(GameObj.new_inv(exist, noun, name, EHerbs.data[:herb_sack].id.to_s))
      end

      contents
    end
  end

  module Msg
    def self.boldif(condition, text)
      return Msg.format_monsterbold_noescape(text) if condition

      text
    end

    def self.check_herbs_in_container(container_name = nil)
      Script.current.vars.delete_if { |var| var =~ /^check$/i }
      Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
      if EHerbs.data[:preposition].nil? && Script.current.vars.any? { |v| v =~ /^(in|on|behind|under)$/ }
        EHerbs.data[:preposition] = Regexp.last_match(1).downcase
        Script.current.vars.delete_at(1)
        Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
      end
      EHerbs.data[:preposition] = 'in' if EHerbs.data[:preposition].nil?

      container_name = Script.current.vars[0] if container_name.nil?
      container_name = EHerbs.data[:herb_container] if container_name.nil? && !EHerbs.data[:herb_container].to_s.empty?

      contents = Inventory.herb_container_contents_load(container_name)

      if contents.nil? || contents.empty?
        _respond Msg.monsterbold(" Nothing found #{EHerbs.data[:preposition]} #{container_name}")
        exit
      end

      # so we can highlight relevant lines
      status_check = {}
      status_check['poison']           = checkpoison
      status_check['disease']          = checkdisease
      status_check['blood']            = ((checkhealth + 7) < maxhealth)
      status_check['minor head wound'] = [Wounds.head, Wounds.neck].include?(1)
      status_check['major head wound'] = [Wounds.head, Wounds.neck].max > 1
      status_check['minor head scar']  = [Scars.head, Scars.neck].include?(1)
      status_check['major head scar']  = [Scars.head, Scars.neck].max > 1
      status_check['minor nerve wound'] = Wounds.nerves == 1
      status_check['major nerve wound'] = Wounds.nerves > 1
      status_check['minor nerve scar'] = (Scars.nerves == 1 && Wounds.nerves.zero?)
      status_check['major nerve scar'] = (Scars.nerves > 1 && Wounds.nerves.zero?)
      status_check['minor organ wound'] = [Wounds.chest, Wounds.torso, Wounds.back].include?(1)
      status_check['major organ wound'] = [Wounds.chest, Wounds.torso, Wounds.back].max > 1
      status_check['minor organ scar'] = [Scars.chest, Scars.torso, Scars.back].include?(1)
      status_check['major organ scar'] = [Scars.chest, Scars.torso, Scars.back].max > 1
      status_check['missing eye']      = [Scars.reye, Scars.leye].max > 2
      status_check['minor limb wound'] = [Wounds.rhand, Wounds.rarm, Wounds.rleg, Wounds.lhand, Wounds.larm, Wounds.lleg].include?(1)
      status_check['major limb wound'] = [Wounds.rhand, Wounds.rarm, Wounds.rleg, Wounds.lhand, Wounds.larm, Wounds.lleg].max > 1
      status_check['minor limb scar']  = [Scars.rhand, Scars.rarm, Scars.rleg, Scars.lhand, Scars.larm, Scars.lleg].include?(1)
      status_check['major limb scar']  = [Scars.rhand, Scars.rarm, Scars.rleg, Scars.lhand, Scars.larm, Scars.lleg].include?(2)
      status_check['severed limb']     = [Scars.rhand, Scars.rarm, Scars.rleg, Scars.lhand, Scars.larm, Scars.lleg].include?(3)
      status_check['raisedead']        = checkdead
      status_check['lifekeep']         = checkdead

      # check contents against known herbs
      herb_types = ['poison', 'disease', 'blood', 'minor head wound', 'major head wound', 'minor head scar', 'major head scar', 'minor nerve wound', 'major nerve wound', 'minor nerve scar', 'major nerve scar', 'minor organ wound', 'major organ wound', 'minor organ scar', 'major organ scar', 'missing eye', 'minor limb wound', 'major limb wound', 'minor limb scar', 'major limb scar', 'severed limb']
      EHerbs.known_herbs.each { |h| herb_types << h[:type] unless herb_types.include?(h[:type]) }
      check_list = {}
      herb_types.each { |t| check_list[t] = { count: 0 } }

      contents.each do |obj|
        h = EHerbs.known_herbs.find { |herb| (herb[:name] =~ /#{obj.name}/) }
        next unless h

        h[:name]
        t = h[:type]
        check_list[t][:count] += 1
        check_list[t][:first] = Msg.item_link(obj.id, obj.noun, obj.name) if check_list[t][:first].nil?
      end
      # format and output
      max_type_length = herb_types.max_by { |i| i.length || 1 }.length + 2
      output = []
      output << %(<output class="mono" />)

      table_format = " | %-#{max_type_length - 2}s | %5s | %s"
      table_line   = " +#{'-' * max_type_length}+#{'-' * 7}+#{'-' * 35}"

      output << table_line
      output << " | Herbs found #{EHerbs.data[:preposition]} #{Msg.item_link(EHerbs.data[:herb_sack].id, EHerbs.data[:herb_sack].noun, EHerbs.data[:herb_sack].name)} by type:"
      output << table_line
      output << format(table_format, 'herb type', 'count', 'first')
      output << table_line
      check_list.each do |type, values|
        output << Msg.boldif(status_check[type], format(table_format, type, (values[:count].zero? ? '' : values[:count]), values[:first]))
      end
      output << table_line
      output << %(<output class="" />)
      _respond output.join("\n")
      exit
    end

    def self.format_monsterbold(msg)
      monsterbold_start + msg.encode(xml: :text) + monsterbold_end
    end

    def self.format_monsterbold_noescape(msg)
      monsterbold_start + msg + monsterbold_end
    end

    def self.item_link(id, noun, name, longdesc = nil)
      return name if $frontend == 'wizard'

      "<a exist=\"#{id}\" noun=\"#{noun}\">#{name}</a>#{longdesc.nil? ? '' : " #{longdesc}"}"
    end

    def self.monsterbold(msg)
      return Lich::Messaging.monsterbold(msg) if defined?(Lich::Messaging)

      Msg.format_monsterbold(msg)
    end

    def self.print_herb_list(vars = nil)
      known_herbs = EHerbs.known_herbs.dup
      if (vars =~ /major|severed|missing/i) && (vars !~ /minor/i)
        known_herbs.delete_if { |herb| herb[:type] !~ /major|severed|missing/i }
      elsif (vars =~ /minor/i) && (vars !~ /major|severed|missing/i)
        known_herbs.delete_if { |herb| herb[:type] !~ /minor/ }
      end
      if (vars =~ /wound/i) && (vars !~ /scar|missing|severed/i)
        known_herbs.delete_if { |herb| herb[:type] !~ /wound/ }
      elsif (vars =~ /scar|missing|severed/i) && (vars !~ /wound/i)
        known_herbs.delete_if { |herb| herb[:type] !~ /scar|missing|severed/ }
      end
      if Script.current.vars[0] =~ /head|neck|organ|limb|leg|arm|hand|nerve|eye|blood|health|poison|posion|disease/
        known_herbs.delete_if { |herb| herb[:type] =~ /head/ } unless vars =~ /head|neck/
        known_herbs.delete_if { |herb| herb[:type] =~ /organ|eye/ } unless vars =~ /organ|eye/
        known_herbs.delete_if { |herb| herb[:type] =~ /limb/ } unless vars =~ /limb|leg|arm|hand/
        known_herbs.delete_if { |herb| herb[:type] =~ /nerve/ } unless vars =~ /nerve/
        known_herbs.delete_if { |herb| herb[:type] =~ /blood/ } unless vars =~ /blood|health/
        known_herbs.delete_if { |herb| herb[:type] =~ /poison/ } unless vars =~ /poison|posion/
        known_herbs.delete_if { |herb| herb[:type] =~ /disease/ } unless vars =~ /disease/
      end
      list = {}

      known_herbs.each do |herb|
        list[herb[:type]] ||= []
        list[herb[:type]].push(herb[:name]) unless list[herb[:type]].include?(herb[:name])
      end
      output = "\n"

      list.each do |type, herbs|
        output.concat monsterbold_start + "#{Msg.title_case(type)}:" + monsterbold_end + " #{herbs.join(', ')}\n"
      end
      output.concat "\n"
      if defined?(_respond)
        _respond output
      else
        puts output
      end
    end

    def self.print_help
      respond
      respond ' To use the herbs in your herbsack (see below for setting your herbsack):'
      respond "   #{$clean_lich_char}#{Script.current.name}"
      respond
      respond ' To heal only hitpoints but no other wounds (squares rejoice!):'
      respond "   #{$clean_lich_char}#{Script.current.name} blood"
      respond
      respond ' To check a container and report a table of herb types with counts:'
      respond "   #{$clean_lich_char}#{Script.current.name} check <in|on|under|behind> <container>"
      respond
      respond ' To replace any missing herbs:'
      respond "   #{$clean_lich_char}#{Script.current.name} fill"
      respond
      respond ' To stock herbs for a big hunt (purchase multiple doses of herbs):'
      respond "   #{$clean_lich_char}#{Script.current.name} stock"
      respond
      respond ' To set the amount of herbs to stock based on percent of capacity:'
      respond '   Primarily intended for survival kits but will work for ordinary containers also.'
      respond "   #{$clean_lich_char}#{Script.current.name} set stock <percent>"
      respond
      respond ' Optionally you can specify if you only want herbs or potions:'
      respond "   #{$clean_lich_char}#{Script.current.name} stock [herbs|potions]"
      respond
      respond ' Or you can specify if you want the stock count combined between potions and herbs. (survival kits only)'
      respond "   #{$clean_lich_char}#{Script.current.name} stock combined"
      respond
      respond ' Additionally, you can specify if you only want a particular herb stocked:'
      respond "   #{$clean_lich_char}#{Script.current.name} stock major head wound <- to stock stem only"
      respond
      respond ' To look up what herbs heal what (to help with the preceding command):'
      respond "   #{$clean_lich_char}#{Script.current.name} list"
      respond
      respond ' To use the herbs on a bench or something:'
      respond "   #{$clean_lich_char}#{Script.current.name} on bench"
      respond '     or'
      respond "   #{$clean_lich_char}#{Script.current.name} behind altar"
      respond
      respond ' To use the herbs on a bench without picking up the edible herbs:'
      respond "   #{$clean_lich_char}#{Script.current.name} on bench --no-get"
      respond
      respond " To heal your Adventurer's Guild escort (not well tested):"
      respond "   #{$clean_lich_char}#{Script.current.name} escort"
      respond
      respond ' Options (add these to the end of the command; these override default options):'
      respond '   --buy=<on/off>         Go to the herbalist to buy herbs if needed'
      respond '   --deposit=<on/off>     Deposit silver if needed at end of healing'
      respond '   --mending=<on/off>     Use sigil of mending before using herbs'
      respond '   --skipscars=<on/off>   Skip rank 1 scar healing'
      respond '   --yaba=<on/off>        Use yabathilium fruit first'
      respond '   --potions=<on/off>     Try to use potions first'
      respond '   --650=<on/off>         Cast Assume Aspect (650) Yierka' if Spell[650].known?
      respond '   --1035=<on/off>        Cast Song of Tonis (1035)' if Spell[1035].known?
      respond
      respond " Change default options (so you don't have to specify the option every time):"
      respond "   #{$clean_lich_char}#{Script.current.name} set buy <on/off>           same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set deposit <on/off>       same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set mending <on/off>       same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set skipscars <on/off>     same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set yaba <on/off>          same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set potions <on/off>       same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set 650 <on/off>           same as above" if Spell[650].known?
      respond "   #{$clean_lich_char}#{Script.current.name} set 1035 <on/off>          same as above" if Spell[1035].known?
      respond "   #{$clean_lich_char}#{Script.current.name} set herbsack <container>   sets which container you use if one isn't"
      respond '                                        specified on the command line'
      respond
      respond ' To access UI:'
      respond "   #{$clean_lich_char}#{Script.current.name} setup"
      respond
    end

    def self.title_case(title, minor_words = '')
      minor_words_as_array = %w[a an the and but or for nor on at to from by of].concat(minor_words.split(','))
      title_as_array = title.split(' ')
      title_as_array.map { |word| minor_words_as_array.include?(word) ? word : word.capitalize }.join(' ')
    end
  end

  module Utility
    def self.able_to_cast
      able_to_cast = true
      stacked_right_scar = 0
      stacked_right_wound = 0
      stacked_left_scar = 0
      stacked_left_wound = 0

      XMLData.injuries.each do |area, h|
        next unless area =~ /nsys|head|(left|right)(Eye|Arm|Hand)/
        next unless (h['scar'].positive? || h['wound'].positive?)

        if h['scar'] > 2 || h['wound'] > 2
          able_to_cast = false
          break
        elsif area =~ /nsys|head/ && (h['scar'] > 1 || h['wound'] > 1)
          able_to_cast = false
          break
        elsif area =~ /left(Arm|Hand)/
          stacked_left_scar += h['scar']
          stacked_left_wound += h['wound']
          if (stacked_left_scar > 1 || stacked_left_wound > 1)
            able_to_cast = false
            break
          end
        elsif area =~ /right(Arm|Hand)/
          stacked_right_scar += h['scar']
          stacked_right_wound += h['wound']
          if (stacked_right_scar > 1 || stacked_right_wound > 1)
            able_to_cast = false
            break
          end
        end
      end

      able_to_cast
    end

    def self.assert_herbsack_var
      return unless EHerbs.data[:herb_container].to_s.empty?

      echo "herbsack is not set (#{$clean_lich_char}#{Script.current.name} set herbsack <container name>)"
      exit
    end

    def self.check_cutthroat
      return unless cutthroat?

      _respond Msg.monsterbold(' You have cutthroat and cannot speak without spewing blood everywhere.')

      if EHerbs.data[:heal_cutthroat] && EHerbs.data[:use_npchealer]
        Utility.go2('npchealer')
        fput 'lie'
        _respond Msg.monsterbold(' This may take a minute!')
        sleep 5 while cutthroat?
      elsif EHerbs.data[:heal_cutthroat] && !EHerbs.data[:use_npchealer]
        Utility.go2('town')
        sleep 1
        fput 'act gasps while trying to hold the blood back from the throat gash'
        sleep 1
        fput 'say Help me?'
        _respond Msg.monsterbold(' While we\'re waiting on a healer - exiting. . .')
        Script.self.kill
      else
        _respond Msg.monsterbold('Your cut throat requires attention! Exiting. . . ')
        _respond Msg.monsterbold('Waiting on a healer. . . ')
        Script.self.kill
      end
      _respond
    end

    def self.check_silver
      lines = Utility.get_lines('wealth quiet', /^You have no|^You have ([\d,]+) coins|^You have but one coin with you./)

      coins = 0
      if lines.any? { |l| l =~ /You have ([\d,]+) coins/ }
        coins = Regexp.last_match(1).gsub(',', '').to_i
      elsif lines.any? { |l| l =~ /You have but one coin/ }
        coins = 1
      end

      coins
    end

    def self.determine_survival_kit(herb_sack)
      # If it's not a GameObj we won't be stocking it.
      unless herb_sack.instance_of?(GameObj)
        EHerbs.data[:survival_kit] = false
        return
      end

      lines = Utility.get_lines("analyze ##{herb_sack.id}", /You analyze/)

      if lines.any? { |l| l =~ /is a Survivalist's Kit, which is a specialized container/ }
        EHerbs.data[:survival_kit] = true
        tier = Regexp.last_match(1).to_i if lines.any? { |l| l =~ %r{Capacity: (\d+)/5 } }
        EHerbs.data[:distiller] = true if lines.grep(/has the Liquid Extractor unlock/).any?
      else
        EHerbs.data[:survival_kit] = false
        EHerbs.data[:distiller] = false
      end

      return unless EHerbs.data[:stock].to_i > 0

      EHerbs.data[:stock] = EHerbs.data[:stock].to_s.gsub('%', '').to_f
      EHerbs.data[:stock] = EHerbs.data[:stock] > 100 ? 100 : EHerbs.data[:stock].to_f

      if EHerbs.data[:survival_kit]
        t_amount = (tier * 25) + 25
        amount = (t_amount * (EHerbs.data[:stock] / 100)).to_i
        EHerbs.data[:min_stock_doses].each do |k, _v|
          EHerbs.data[:min_stock_doses][k] = amount
        end
      else
        EHerbs.data[:min_stock_doses].each do |k, v|
          amount = (v.to_f * (EHerbs.data[:stock] / 100)).to_i
          EHerbs.data[:min_stock_doses][k] = amount
        end
      end
    end

    def self.distill
      return unless EHerbs.data[:distiller]

      if EHerbs.data[:herb_sack].nil?
        EHerbs.data[:herb_sack] = Utility.find_herbsack
      end

      lines = Utility.get_lines("analyze ##{EHerbs.data[:herb_sack].id}", /You analyze/)

      # Extractor is running, nothing to do
      if lines.grep(/The extractor is currently targeting/).any?
        if lines.join(' ') =~ %r{The extractor is currently targeting <pushBold/>(.*?)<popBold/>, with around (.*?) remaining}
          working_on = Regexp.last_match(1)
          respond " The extractor is currently targeting #{working_on}. Nothing to do."
          return
        end
      end

      # Extract the solid and liquid herb information
      edible_result_contents = Regexp.last_match(5) if lines.join(' ') =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains DOSEs (.*?)\.}
      liquid_result_contents = Regexp.last_match(5) if lines.join(' ') =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains TINCTUREs (.*?)\.}

      # Create hash tables to store the counts of each herb
      solid_counts = {}
      liquid_counts = {}

      # Parse the solid herb information and store the counts in a hash table
      edible_result_contents.scan(%r{(:?) <a exist="(.*?)" noun="(.*?)">(.*?)</a> \((.*?)\)}).each do |_, _exist, _noun, name, count|
        solid_counts[name] = count.to_i
      end
      liquid_result_contents.scan(%r{(:?) <a exist="(.*?)" noun="(.*?)">(.*?)</a> \((.*?)\)}).each do |_, _exist, _noun, name, count|
        liquid_counts[name] = count.to_i
      end

      # Check if there is a solid herb that does not have a matching liquid herb
      missing_solid_herbs = solid_counts.keys - liquid_counts.keys
      if missing_solid_herbs.any?
        # Select the first missing solid herb
        missing_solid_herb = missing_solid_herbs.first
        fput "point my #{EHerbs.data[:herb_sack]} at dose #{missing_solid_herb}"
      else
        # Find the liquid herb with the lowest count that matches a solid herb
        matching_liquid_herb = liquid_counts.select { |herb, _count| solid_counts.key?(herb) }.min_by { |_herb, count| count }.first
        fput "point my #{EHerbs.data[:herb_sack]} at dose #{matching_liquid_herb}"
      end
    end

    def self.find_herbsack
      herbsack = GameObj.inv.find { |obj| obj.name =~ /#{EHerbs.data[:herb_container]}/ }

      if herbsack.nil?
        echo "error: unable to find container \"#{EHerbs.data[:herb_container]}\" in your inventory."
        exit
      end

      # Lets check to see if its a survival kit
      Utility.determine_survival_kit(herbsack)

      EHerbs.data[:herb_sack] = herbsack

      EHerbs.data[:herb_sack]
    end

    def self.anon_hook(prefix = '')
      now = Time.now
      "Util::#{prefix}-#{now}-#{Random.rand(10000)}"
    end

    def self.quiet_command_xml(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout = 5, silent = false)
      result = []
      name = self.anon_hook
      filter = false
      if silent
        save_script_silent = Script.current.silent
        Script.current.silent = true
      end
      save_want_downstream = Script.current.want_downstream
      save_want_downstream_xml = Script.current.want_downstream_xml
      Script.current.want_downstream = false
      Script.current.want_downstream_xml = true

      begin
        Timeout::timeout(timeout, Interrupt) {
          DownstreamHook.add(name, proc { |xml|
            if filter
              if xml =~ end_pattern
                DownstreamHook.remove(name)
                filter = false
              else
                next(nil)
              end
            elsif xml =~ start_pattern
              filter = true
              next(nil)
            else
              xml
            end
          })
          fput command

          until (xml = get) =~ start_pattern; end
          result << xml.rstrip
          until (xml = get) =~ end_pattern
            result << xml.rstrip
          end
          if include_end
            result << xml.rstrip
          end
        }
      rescue Interrupt
        nil
      ensure
        DownstreamHook.remove(name)
        Script.current.want_downstream_xml = save_want_downstream_xml
        Script.current.want_downstream = save_want_downstream
        Script.current.silent = save_script_silent if silent
      end
      return result
    end

    def self.get_lines(command, regex)
      lines = []
      regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\.|That is closed.|It appears to be locked./)

      loop do
        if defined?(Lich::Util)
          lines = Lich::Util.quiet_command_xml(command, regex)
        else
          lines = self.quiet_command_xml(command, regex)
        end
        break unless lines.any? { |l| l =~ /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i }

        Utility.wait_rt
      end

      lines
    end

    def self.get_res(command, regex)
      regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)
      result = nil
      loop do
        result = dothistimeout(command, 3, regex)
        break unless result =~ /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i

        Utility.wait_rt
      end

      result
    end

    def self.go2(place)
      fput('unhide') if hidden? || invisible?

      return if Room.current.id == place.to_i || Room.current.tags.include?(place)

      Utility.mapped_room

      Script.run('go2', "#{place} --disable-confirm", { quiet: true })
    end

    def self.mapped_room
      return unless Room.current.nil?

      move checkpaths.sample while Room.current.id.nil?
    end

    def self.next_herb_type
      herb_type = nil
      herb_type = 'blood' if percenthealth < 50 && !EHerbs.data[:skippable].include?('blood')
      unless herb_type
        (%w[head neck torso limbs nerves] - EHerbs.data[:skippable]).each do |area|
          if Wounds.send(area) > 1
            herb_type = "major #{EHerbs.data[:areas][area]} wound"
            break
          end
        end
      end
      unless herb_type
        (%w[head neck torso limbs nerves] - EHerbs.data[:skippable]).each do |area|
          if Wounds.send(area) == 1
            herb_type = "minor #{EHerbs.data[:areas][area]} wound"
            break
          end
        end
      end
      herb_type = 'severed limb' if herb_type.nil? && Scars.limbs == 3 && !EHerbs.data[:skippable].include?('limbs')
      herb_type = 'missing eye' if herb_type.nil? && (Scars.reye == 3 || Scars.leye == 3) && !EHerbs.data[:skippable].include?('torso')
      unless herb_type
        (%w[head neck torso limbs nerves] - EHerbs.data[:skippable]).each do |area|
          if Scars.send(area) > 1
            herb_type = "major #{EHerbs.data[:areas][area]} scar"
            break
          end
        end
      end
      unless herb_type
        (%w[head neck torso limbs nerves] - EHerbs.data[:skippable]).each do |area|
          if Scars.send(area) == 1 && !EHerbs.data[:skip_scars]
            herb_type = "minor #{EHerbs.data[:areas][area]} scar"
            break
          end
        end
      end
      herb_type = 'blood' if herb_type.nil? && (checkhealth + 7) < maxhealth && !EHerbs.data[:skippable].include?('blood')
      # echo "herb_type: #{herb_type}"
      herb_type
    end

    def self.read_menu
      Utility.check_cutthroat

      lines = Utility.get_lines('order', %r{<output class="mono"/>|<closeDialog id='dlgCustomize'/>})
      menu = {}
      lines.each do |line|
        line.scan(%r{<d.*?cmd=["']order ([0-9]+).*?>(.*?)</d>}).each do |item|
          menu[item[1].sub(/^an? /, '')] = item[0]
        end
      end

      menu
    end

    def self.settings_herbsack(vars)
      return unless vars[2] == 'herbsack'

      old_herbsack = EHerbs.data[:herb_container]
      if vars[3]
        name = vars[3..-1].join(' ')
        obj_list = GameObj.inv.find_all { |obj| obj.noun == name }
        obj_list = GameObj.inv.find_all { |obj| obj.name == name } if obj_list.empty?
        obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(name)}$/i } if obj_list.empty?
        obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{name.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i } if obj_list.empty?

        if obj_list.empty?
          echo "error: failed to find a container in your inventory by the name of \"#{name}\""
        elsif obj_list.length > 1
          echo "error: multiple containers in your inventory match the name \"#{name}\""
        else
          UserVars.herbsack = name
          _respond "#{Script.current.name} setting saved: herbsack is now #{Msg.monsterbold(name)}.#{old_herbsack.nil? ? '' : " (previous value: '#{old_herbsack}')"}"
        end
      else
        echo 'error: no container name given'
      end
    end

    def self.set_preferences(var_name, var_value, save: false)
      fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }

      name = EHerbs.data[:var_names][var_name.downcase]
      value = fix_option[var_value.downcase]
      echo "unknown setting #{var_name}" if name.nil?
      echo "unknown value #{var_value} for #{var_name}" if value.nil?
      return false if name.nil? || value.nil?

      EHerbs.data[name.to_sym] = value
      return if save == false

      old_value = CharSettings[name]
      return unless value.inspect != old_value.inspect

      CharSettings[name] = value
      _respond "#{Script.current.name} setting saved: #{Msg.monsterbold(var_name)} is now #{Msg.monsterbold(value.inspect)}. #{old_value.nil? ? '' : " (previous value: #{old_value})"}"
    end

    def self.settings_stock(amount)
      amount = amount.gsub('%', '').to_i

      if amount != CharSettings['stock'].to_i
        value = CharSettings['stock'].to_s.empty? ? 'default' : CharSettings['stock'].to_i
        _respond " #{Script.current.name} setting saved: #{Msg.monsterbold("You will now stock at #{amount}% of capacity")} (previous value: #{value})"
        CharSettings['stock'] = amount
      else
        _respond " #{Script.current.name} setting not saved: The new value (#{amount}) is the same as the old one."
      end
    end

    def self.test
      # Method to test pieces of code
    end

    def self.wait_rt
      sleep 0.2
      wait_while { checkrt > 0.0 }
      sleep 0.2
    end
  end

  if $eherbs_measure.nil?
    exec_string = "
         #hide_me
         #echo 'starting eherbs_measure'
         status_tags
         $eherbs_measure = Hash.new if $eherbs_measure.to_s.empty?
         @doses = 0
         using = nil
         last_left_hand_id = nil
         begin
            while line = get
                if line =~ /<left exist=\"([0-9]+)\"/
                  last_left_hand_id = $1
                end
                if line =~ /<prompt/
                  using = nil
                elsif using
                  if line =~ /^You have only about ([0-9]+) quaffs left\\./
                     $eherbs_measure[using] = $1.to_i
                  elsif line =~ /^You have (?:about )?([0-9]+) (?:doses|bites) left\\./
                     $eherbs_measure[using] = $1.to_i
                  elsif line =~ /^You (?:only )?have one bite left\\./
                     $eherbs_measure[using] = 1
                  elsif line =~ /^You have only about one quaff left\\.|You only have one (?:dose|quaff) left\\./
                     $eherbs_measure[using] = 1
                  elsif line =~ /^That was the last (?:drop|of it)\\./
                     $eherbs_measure[using] = 0
                  end
                elsif line =~ /^You take a (?:drink from|bite of) your .*? exist=\"([0-9]+)\"/
                  using = $1
                elsif line =~ /^You carefully pour a little bit from your .*? exist=\"([0-9]+)\" .*? into .*? exist=\"([0-9]+)\"/
                  using = $1
                  if $eherbs_measure[$2]
                     $eherbs_measure[$2] += 1
                  end
                elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has several doses left\\./
                  if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 5) or ($eherbs_measure[$1] > 10)
                     $eherbs_measure[$1] = 7
                  end
                elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has a few doses left\\./
                  if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 3) or ($eherbs_measure[$1] > 4)
                     $eherbs_measure[$1] = 4
                  end
                elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has ([0-9]+) doses left\\./
                  $eherbs_measure[$1] = $2.to_i
                elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has 1 dose left\\./
                  $eherbs_measure[$1] = 1
                elsif line =~ /^You can't tell exactly, but .*? exist=\"(.*?)\" .*? seems to have plenty of bites left\\.$/
                  if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 11) or ($eherbs_measure[$1] > 50)
                     $eherbs_measure[$1] = 50
                  end
                elsif line =~ /^The .*? exist=\"(.*?)\" .*? looks like it has several bites left\\.$/
                  if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 5) or ($eherbs_measure[$1] > 10)
                     $eherbs_measure[$1] = 10
                  end
                elsif line =~ /^The .*? exist=\"(.*?)\" .*? looks like it has a few bites left\\.$/
                  if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 3) or ($eherbs_measure[$1] > 4)
                     $eherbs_measure[$1] = 4
                  end
                elsif line =~ /^The .*? exist=\"(.*?)\" .*? has ([0-9]+) bites left\\.$/
                  $eherbs_measure[$1] = $2.to_i
                elsif line =~ /^The .*? exist=\"(.*?)\" .*? has (?:one|1) bite left\\.$/
                  $eherbs_measure[$1] = 1
                elsif line =~ /^(?:Sh|H)e hands you <a exist=\"[0-9]+\".*?>(.*)<\\/a> and says, \"Here's your purchase\./o
                  @doses = EHerbs.known_herbs.find { |h| h[:name] == $1.dup }[:store_doses]
                  if @doses.nil?
                     echo \"warning: no store_doses entry for \#{$1}\"
                     @doses = 4
                  end
                elsif line =~ /^Carefully, you combine all your .*? into one bundle\\./
                  bundle_id = GameObj.right_hand.id
                  if $eherbs_measure[bundle_id] and !@doses.nil?
                     $eherbs_measure[bundle_id] += @doses.to_i
                     @doses = nil
                  elsif ($eherbs_measure[$1] and $eherbs_measure[$1] > 10) or ($eherbs_measure[last_left_hand_id] and $eherbs_measure[last_left_hand_id] > 10)
                     # bundle has 11 - 50 bytes
                     # overestimate so that we don't buy more than we can bundle
                     # exact count will be found if the herb is used
                     $eherbs_measure[$1] = 50
                     $eherbs_measure.delete(last_left_hand_id)
                  else
                     # bundle has 2-50 bytes
                     # clear count so the bundle gets measured
                     $eherbs_measure.delete($1)
                     $eherbs_measure.delete(last_left_hand_id)
                  end
                elsif line =~ /^You carefully remove one dose from your <a exist=\"([0-9]+)\"/
                  if $eherbs_measure[$1]
                     $eherbs_measure[$1] -= 1
                  end
                  $eherbs_measure[last_left_hand_id] = 1
                elsif !Script.running?('eherbs')
                  line
                  break
                end
                line
            end
         ensure

         end
      "
    ExecScript.start(exec_string, { quiet: false })
  end

  # start of user input processing
  #------------------------------------------------------------------------------#
  # help / print / preferences
  #------------------------------------------------------------------------------#

  EHerbs.load(EHerbs.load_eherbs_settings)

  if Script.current.vars[0] =~ /^-?-?help/i
    Msg.print_help
    exit
  elsif Script.current.vars[1] =~ /^list$/i
    Msg.print_herb_list(Script.current.vars[0])
    exit
  elsif Script.current.vars[1] =~ /^test$/i
    Utility.test
    exit
  elsif Script.current.vars[1] == 'setup'
    if defined?(Gtk)
      Setup.new(EHerbs.load_eherbs_settings).start
      EHerbs.save_eherbs_settings(EHerbs.data)
    else
      respond ' Gtk is not defined. Please use command line'
    end
    exit
  elsif Script.current.vars[1].downcase == 'set' && Script.current.vars[2].downcase == 'herbsack'
    Utility.settings_herbsack(Script.current.vars)
    exit
  elsif Script.current.vars[1].downcase == 'set' && EHerbs.data[:var_names].keys.include?(Script.current.vars[2].downcase)
    Utility.set_preferences(Script.current.vars[2], Script.current.vars[3], save: true)
    exit
  elsif Script.current.vars[1].downcase == 'set' && Script.current.vars[2].downcase == 'stock'
    Utility.settings_stock(Script.current.vars[3])
    exit
  elsif Script.current.vars[1] =~ /^(#{EHerbs.data[:var_names].keys.join('|')})=(on|off|true|false|yes|no)$/i
    Utility.set_preferences(Regexp.last_match(1), Regexp.last_match(2), save: false)
    Script.current.vars.delete_at(1)
    exit
  elsif Script.current.vars[0] =~ /load/
    EHerbs.load(EHerbs.load_eherbs_settings)
    exit
  end

  #------------------------------------------------------------------------------#
  # more preferences, and no_get
  #------------------------------------------------------------------------------#
  Script.current.vars[1..-1].each do |v|
    if v =~ /^--(#{EHerbs.data[:var_names].keys.join('|')})=(on|off|true|false|yes|no)$/i
      Utility.set_preferences(Regexp.last_match(1), Regexp.last_match(2), save: false)
      Script.current.vars.delete_if { |var| var == "--#{Regexp.last_match(1)}=#{Regexp.last_match(2)}" }
    end
  end
  Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
  if Script.current.vars.any? { |var| var =~ /^(?:--)?no-?get$/i }
    EHerbs.data[:no_get] = true
    Script.current.vars.delete_if { |var| var =~ /^(?:--)?no-?get$/i }
    Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
  else
    EHerbs.data[:no_get] = false
  end
  if Script.current.vars.any? { |var| var =~ /^blood$/i } || EHerbs.data[:blood_toggle] # and not Script.current.vars.any? { |var| var =~ /^stock blood/ }
    EHerbs.data[:blood_only] = true
    Script.current.vars.delete_if { |var| var =~ /^blood$/i }
    Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
  end
  case Script.current.vars[1].downcase
  when 'escort'
    Actions.escort
  when 'fill'
    Actions.fill_herbs
  when 'stock'
    Actions.stock_herbs
  when 'check'
    Msg.check_herbs_in_container
  end

  unless [Wounds.head, Wounds.neck, Wounds.torso, Wounds.limbs, Wounds.nerves, Scars.head, Scars.neck, Scars.torso, Scars.limbs, Scars.nerves].max > 0 || ((checkhealth + 7) < maxhealth)
    Utility.distill
    respond
    respond ' Missing herb for Hypochondriasis.'
    respond
    exit
  end

  #------------------------------------------------------------------------------#
  # ???
  #------------------------------------------------------------------------------#
  if Script.current.vars[1]
    EHerbs.data[:return_to_stow] = true
    if Script.current.vars[1] =~ /^(in|on|behind|under)$/i
      EHerbs.data[:preposition] = Regexp.last_match(1).downcase
      Script.current.vars.delete_at(1)
      Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
    end
    if Script.current.vars[1] =~ /^\#-?[0-9]+$/
      # This is for setting a herb sack from CLI
      EHerbs.data[:herb_sack] = GameObj.new(Script.current.vars[1].sub('#', ''), '', '')
    elsif Script.current.vars[1]
      Inventory.herb_container_contents_load(Script.current.vars[0])
    elsif EHerbs.data[:herb_container].to_s.empty?
      echo ' error: no herbsack set or specified on the command line'
      exit
    elsif EHerbs.data[:herb_sack].nil?
      EHerbs.data[:herb_sack] = Utility.find_herbsack
      Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])
    end
    if EHerbs.data[:herb_sack].contents.nil?
      Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])
    end
  else
    if EHerbs.data[:herb_container].to_s.empty?
      echo ' No container was given and herbsack is not set!'
      echo "  use  #{$clean_lich_char}#{Script.current.name} set herbsack <container name>"
      echo "  or   #{$clean_lich_char}#{Script.current.name} <in|on|behind|under> <container name>"
      exit
    end
  end

  #------------------------------------------------------------------------------#
  # use herbs
  #------------------------------------------------------------------------------#
  empty_hand

  if EHerbs.data[:blood_only]
    Actions.blood_only
  else
    Actions.use_herbs
  end

  #------------------------------------------------------------------------------#
  # cleanup
  #------------------------------------------------------------------------------#
  Inventory.stow_herb
  fill_hand
  dothistimeout "close ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:close_regex] if EHerbs.data[:close_herbsack]
  Actions.deposit if EHerbs.data[:need_deposit]
  Utility.go2(EHerbs.data[:start_room].id.to_s) if EHerbs.data[:need_return]
  Utility.distill if EHerbs.data[:distiller]
end
