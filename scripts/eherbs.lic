=begin

   Script to heal yourself with herbs.

   Will use herbs in your herbsack, or on a bench or something.
   Works with any combination of herbs from any town.
   Can buy herbs.
   Might heal your traveler.

  ;eherbs help

            author: Elanthia-Online
      contributors: Tillmen, Tysong, Doug, Rinualdo, Xanlin, Deysh
              game: Gemstone
              tags: healing, herbs
          requires: Lich >= 5.9.0
           version: 2.1.4
  2.1.4  (2025-04-22)
    - add additional put regex for survival kit when fully stocked
  2.1.3  (2025-03-25)
    - remove waitcastrt? from wait_rt method
    - add waitcastrt? to cast_spells method
    - add Do Not Buy herbs for Solhaven backroom bundles so can be recognized for usage by eherbs
    - bugfix in check_herbs_in_container method for nil measures
    - bugfix in get_current_stock to also count herbs in a survival kit that are currently solid/liquid doses
    - redetect survival kit if changed stock, distiller or herb_sack changed in currenct session
  2.1.2  (2025-02-22)
    - add additional unpoison herbs
    - add logic to eat/drink poison & disease curing herbs
    - bugfix for cached pricing of herbalist in distant town but starting in different area
    - remove deprecated calls to maxhealth & checkhealth
    - update logic of survival kits to include non-bundled liquid/solid doses
  2.1.1  (2025-02-20)
    - change ;eherbs load to also redetermine survival kit
  2.1.0  (2025-01-19)
    - add --spellcast and --ranged options to healdown to be able to do those again
  2.0.18 (2025-01-06)
    - fix for min_stock_doses to persist thru current session running
  2.0.17 (2025-01-06)
    - fix for survival_kit to persist thru current session running
    - fix for not being able to analyze kit during distill function
  2.0.16 (2024-12-06)
    - add additional debug messaging
  2.0.15 (2024-10-10)
    - skip herbs that can't be bundled when bundling herbs
  2.0.14 (2024-09-25)
    - bugfix for depositing in Pinefar, need to wait for banker
  2.0.13 (2024-08-30)
    - bugfix for excessive ANALYZE for survival kits logic
    - bugfix for wait_rt method
  2.0.12 (2024-08-27)
    - adjust doses for Ta'Vaalor
    - update note buying process for in-hand recognition
    - bugfix in stock_requested_herbs when not using a note
  2.0.11 (2024-08-26)
    - Add missing Ta'Vaalor tinctures
  2.0.10 (2024-08-15)
    - bugfix failed finding blood herbs if use_yaba is on with no yaba found
  2.0.9 (2024-07-20)
    - change note variable to just use the noun instead of full name
    - use quiet command for _injury 2
    - consolidate inventory check methods
    - general code consolidation
    - change log added to wiki
  2.0.8 (2024-07-12)
    - pause script ego2 if running
  2.0.7 (2024-07-12)
    - drinkable variable not being set when buying
  2.0.6 (2024-07-10)
    - changed drinkable boolean in favor of checking regex during herb usage or boolean
  2.0.5 (2024-01-17)
    - fix for wrong variable reference
  2.0.4 (2024-01-03)
    - bugfix for Zul Logoth location check
  2.0.3 (2024-01-01)
    - bugfix for use_potions variable
  2.0.2 (2023-12-15)
    - send injury command to refresh XML before attempting to heal self incase missing injury from XML
  2.0.1 (2023-11-10)
    - bugfix to use id instead of name for distiller
    - added setting output for debugging ;eherbs settings
  Previous change logs can be found on the wiki: https://gswiki.play.net/Lich:Script_Eherbs
=end

# FIXME: escort healing doesn't heal blood
# fixme: garland of sovyn cloves
# fixme: skip more better
# fixme: buy herbs/right hand full

# possible eherbs to do: clean up dupes. Find missing herbs. Maybe add big/small blood, add backroom items

# Check version of Lich for compatibility
lich_gem_requires = '5.9.0'

if Gem::Version.new(LICH_VERSION) < Gem::Version.new(lich_gem_requires)
  if $frontend == 'stormfront' || $frontend == 'profanity'
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run." + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "Please update to a newer version." + "\<\/preset\>"
    _respond ""
    _respond "\<preset id=\"thought\"\>" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}" + "\<\/preset\>"
    _respond "\<preset id=\"thought\"\>" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation" + "\<\/preset\>"
    _respond "\<preset id=\"speech\"\>" + "########################################" + "\<\/preset\>"
  else
    _respond "##" + "########################################"
    _respond ">" + "Script:#{script.name} now requires a newer version of Lich(#{lich_gem_requires}+) to run."
    _respond ">" + "Please update to a newer version."
    _respond ">" + ""
    _respond ">" + "Currently Running Lich Version: #{Gem::Version.new(LICH_VERSION)}"
    _respond ">" + "For help updating visit: https://gswiki.play.net/Lich_(software)/Installation"
    _respond "##" + "########################################"
  end
  exit
end

module EHerbs
  @@data ||= nil
  @@survival_kit ||= nil
  @@min_stock_doses ||= {
    'major head scar'   => 6,
    'minor head wound'  => 4,
    'major nerve wound' => 4,
    'minor organ scar'  => 4,
    'major organ scar'  => 6,
    'missing eye'       => 7,
    'blood'             => 50,
    'major head wound'  => 25,
    'minor head scar'   => 25,
    'major organ wound' => 25,
    'minor organ wound' => 25,
    'major limb wound'  => 25,
    'minor limb wound'  => 25,
    'major limb scar'   => 25,
    'minor limb scar'   => 25,
    'severed limb'      => 25,
    'minor nerve wound' => 25,
    'major nerve scar'  => 25,
    'minor nerve scar'  => 25
  }

  def self.survival_kit
    @@survival_kit
  end

  def self.survival_kit=(value)
    @@survival_kit = value
  end

  def self.min_stock_doses
    @@min_stock_doses
  end

  def self.min_stock_doses=(value)
    @@min_stock_doses = value
  end

  def self.data
    @@data
  end

  def self.exec_str
    @doses = 0
    using = nil
    last_left_hand_id = nil
    $eherbs_measure ||= {}

    eherbs_monitor = proc { |line|
      if line =~ /<left exist=\"([0-9]+)\"/
        last_left_hand_id = $1
      end
      if line =~ /<prompt/
        using = nil
      elsif using
        if line =~ /^You have only about ([0-9]+) quaffs left\./
          $eherbs_measure[using] = $1.to_i
        elsif line =~ /^You have (?:about )?([0-9]+) (?:doses|bites) left\./
          $eherbs_measure[using] = $1.to_i
        elsif line =~ /^You (?:only )?have one bite left\./
          $eherbs_measure[using] = 1
        elsif line =~ /^You have only about one quaff left\.|You only have one (?:dose|quaff) left\./
          $eherbs_measure[using] = 1
        elsif line =~ /^That was the last (?:drop|of it)\./
          $eherbs_measure[using] = 0
        end
      elsif line =~ /^You take a (?:drink from|bite of) your .*? exist="([0-9]+)"/
        using = $1
      elsif line =~ /^You carefully pour a little bit from your .*? exist="([0-9]+)" .*? into .*? exist="([0-9]+)"/
        using = $1
        if $eherbs_measure[$2]
          $eherbs_measure[$2] += 1
        end
      elsif line =~ /^The .*? exist="([0-9]+)" .*? has several doses left\./
        if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 5) or ($eherbs_measure[$1] > 10)
          $eherbs_measure[$1] = 7
        end
      elsif line =~ /^The .*? exist="([0-9]+)" .*? has a few doses left\./
        if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 3) or ($eherbs_measure[$1] > 4)
          $eherbs_measure[$1] = 4
        end
      elsif line =~ /^The .*? exist="([0-9]+)" .*? has ([0-9]+) doses left\./
        $eherbs_measure[$1] = $2.to_i
      elsif line =~ /^The .*? exist="([0-9]+)" .*? has 1 dose left\./
        $eherbs_measure[$1] = 1
      elsif line =~ /^You can't tell exactly, but .*? exist="(.*?)" .*? seems to have plenty of bites left\./
        if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 11) or ($eherbs_measure[$1] > 50)
          $eherbs_measure[$1] = 50
        end
      elsif line =~ /^The .*? exist="(.*?)" .*? looks like it has several bites left\./
        if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 5) or ($eherbs_measure[$1] > 10)
          $eherbs_measure[$1] = 10
        end
      elsif line =~ /^The .*? exist="(.*?)" .*? looks like it has a few bites left\./
        if $eherbs_measure[$1].nil? or ($eherbs_measure[$1] < 3) or ($eherbs_measure[$1] > 4)
          $eherbs_measure[$1] = 4
        end
      elsif line =~ /^The .*? exist="(.*?)" .*? has ([0-9]+) bites left\./
        $eherbs_measure[$1] = $2.to_i
      elsif line =~ /^The .*? exist="(.*?)" .*? has (?:one|1) bite left\./
        $eherbs_measure[$1] = 1
      elsif line =~ /^(?:Sh|H)e hands you <a exist="[0-9]+".*?>(.*)<\/a> and says, "Here's your purchase\./o
        @doses = EHerbs.known_herbs.find { |h| h[:name] == $1.dup }[:store_doses]
        if @doses.nil?
          @doses = 4
        end
      elsif line =~ /^Carefully, you combine all your .*? into one bundle\./
        bundle_id = GameObj.right_hand.id
        if $eherbs_measure[bundle_id] and !@doses.nil?
          $eherbs_measure[bundle_id] += @doses.to_i
          @doses = nil
        elsif ($eherbs_measure[$1] and $eherbs_measure[$1] > 10) or ($eherbs_measure[last_left_hand_id] and $eherbs_measure[last_left_hand_id] > 10)
          # bundle has 11 - 50 bytes
          # overestimate so that we don't buy more than we can bundle
          # exact count will be found if the herb is used
          $eherbs_measure[$1] = 50
          $eherbs_measure.delete(last_left_hand_id)
        else
          # bundle has 2-50 bytes
          # clear count so the bundle gets measured
          $eherbs_measure.delete($1)
          $eherbs_measure.delete(last_left_hand_id)
        end
      elsif line =~ /^You carefully remove one dose from your <a exist="([0-9]+)"/
        if $eherbs_measure[$1]
          $eherbs_measure[$1] -= 1
        end
        $eherbs_measure[last_left_hand_id] = 1
      end
      line
    }

    DownstreamHook.remove("eherbs_monitor") # ensure monitor is removed
    before_dying { DownstreamHook.remove("eherbs_monitor") }
    DownstreamHook.add("eherbs_monitor", eherbs_monitor)
  end

  def self.load_eherbs_settings
    settings_hash = {
      :buy_missing     => CharSettings['buy_missing'],
      :deposit_coins   => CharSettings['deposit_coins'],
      :use_mending     => CharSettings['use_mending'],
      :skip_scars      => CharSettings['skip_scars'],
      :blood_toggle    => CharSettings['blood_toggle'],
      :use650          => CharSettings['use650'],
      :use1035         => CharSettings['use1035'],
      :use_yaba        => CharSettings['use_yaba'],
      :use_potions     => CharSettings['use_potions'],
      :stock           => CharSettings['stock'],
      :distiller       => CharSettings['distiller'],
      :prices          => CharSettings['prices'],
      :herb_container  => UserVars.herbsack,
      :drinkable       => /\b(?:potion|tea|elixir|brew|tincture|ale|soup|porter)\b/i,
      :skippable       => [],
      :close_herbsack  => false,
      :done_empty_hand => false,
      :preposition     => nil,
      :return_to_stow  => false,
      :herb_sack       => nil,
      :survival_kit    => EHerbs.survival_kit,
      :shopping_list   => [],
      :start_room      => Room.current,
      :herb_shop_menu  => nil,
      :silvers         => nil,
      :withdraw_amount => 8000,
      :used_herbs      => [],
      :get_from        => nil,
      :heal_cutthroat  => true,
      :use_npchealer   => true,
      :no_get          => false,
      :blood_only      => false,
      :need_deposit    => false,
      :need_return     => false,
      :debug           => CharSettings['debug'],
    }

    settings_hash[:note] = nil

    settings_hash[:open_regex] = Regexp.union(
      /You throw back/i,
      /You open/i,
      /Oh no! It's already/i,
      /You pick at the knot/i,
      /already open/i,
      /is open already/i,
      /You unfasten/i,
      /You glance around suspiciously/i,
      /^What were you referring to\?/i,
      /^I could not find what you were referring to\./i,
      /You pull the long strips of leather/i,
      /With a flick of your wrist/i,
      /Sliding the lever on the side/i,
      /You rub your hand/i,
      /There doesn't seem to be any way/i,
      /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i,
      /crumbles? and decays? away/,
      /Myriad spectral moths pull a cloakwing/,
      /<exposeContainer|<container/i
    )

    settings_hash[:needs_closed] = Regexp.union(
      /You throw back/i,
      /You open/i,
      /You pick at the knot/i,
      /You unfasten/i,
      /With a quick glance over your shoulder/i,
      /You pull the long strips of leather/i,
      /With a flick of your wrist/i,
      /Sliding the lever on the side/i,
      /You rub your hand/i,
      /Myriad spectral moths pull a cloakwing moth/,
    )

    settings_hash[:look_regex] = Regexp.union(
      /Peering into the <a exist=.*? noun="toolkit">/i,
      /That is closed/i,
      /is shut too tightly to see its contents/i,
      /In the(.*?)you see/i,
      /In the(.*?):/i,
      /There is nothing/i,
      /You glance/i,
      /^Attached to a.*keyring/i,
      /.*?[.*?]:/i,
      %r{The <a exist="\d+" noun="\w+">[^<]+</a> has (?:an? <a exist="\d+" noun="\w+">[^<]+</a> |nothing )?in.*scabbard and (?:an? <a exist="\d+" noun="\w+">[^<]+</a> |nothing )?in.*scabbard\.}i,
      /^I could not find what you were referring to\./i,
      /Hidden within the depths of a cloakwing moth greatcloak/,
      /<exposeContainer|<dialogData|<container/i
    )

    settings_hash[:close_regex] = Regexp.union(
      /^You (?:reach over your \w+ and )?close/,
      /^That is already closed/,
      /As you push/,
      /You tie/
    )

    settings_hash[:put_regex] = Regexp.union(
      /^You (?:put|(?:discreetly )?tuck|attach|toss|attempt to shield your|place|.* place|slip|wipe off the blade and sheathe|absent-mindedly drop|carefully add|find an incomplete bundle|untie your drawstring pouch)/,
      /^The .+ is already a bundle/,
      /^Your bundle would be too large if you if you tried to add that/,
      /^The .+ is too large to be bundled\./,
      /^As you place your .+ inside your .+, you notice another .+ inside the .+ and carefully arrange the two .+ into a neat bundle\./,
      /If you wish to continue, throw the item away again within fifteen seconds/,
      /you feel pleased with yourself at having cleaned up the surrounding area/,
      /over your shoulder/,
      /two items in that location/,
      /wear three functional items/,
      /^Your .*? won't fit in .*?\.$/,
      /You add/,
      /You find a suitable/,
      /^Your .+ is already fully stocked with (?:solid|liquid) \w+\.  You put .+ in your .+\.$/
    )

    settings_hash[:get_regex] = Regexp.union(
      /^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly|just )?(?:remove|pick up|draw|grab|reach|slip|tuck|retrieve|already have|unsheathe|detach|swap)/,
      /^Get what\?$/,
      /^Why don't you leave some for others\?$/,
      /^You need a free hand/,
      /^You already have that/,
      /You just poured yourself/,
      /You retrieve/,
      /You break off/
    )

    settings_hash[:cant_bundle] = /tart|feather|special|blubber|pie|porridge|soup|fruit/i

    settings_hash[:min_stock_doses] = EHerbs.min_stock_doses

    # 5 main areas: 'head', 'neck', 'torso', 'limbs', 'nerves'
    # Wound method => herb area
    settings_hash[:areas] = { 'head' => 'head', 'neck' => 'head', 'torso' => 'organ', 'limbs' => 'limb', 'nerves' => 'nerve' }

    settings_hash[:var_names] = {
      'buy'         => 'buy_missing',
      'buy-missing' => 'buy_missing',
      'deposit'     => 'deposit_coins',
      'mending'     => 'use_mending',
      'skipscars'   => 'skip_scars',
      '650'         => 'use650',
      '1035'        => 'use1035',
      'yaba'        => 'use_yaba',
      'potions'     => 'use_potions'
    }

    settings_hash
  end

  def self.load(settings)
    @@data = settings
  end

  def self.save_eherbs_settings(settings)
    CharSettings['buy_missing']   = settings[:buy_missing]
    CharSettings['deposit_coins'] = settings[:deposit_coins]
    CharSettings['use_mending']   = settings[:use_mending]
    CharSettings['skip_scars']    = settings[:skip_scars]
    CharSettings['blood_toggle']  = settings[:blood_toggle]
    CharSettings['use650']        = settings[:use650]
    CharSettings['use1035']       = settings[:use1035]
    CharSettings['use_yaba']      = settings[:use_yaba]
    CharSettings['use_potions']   = settings[:use_potions]
    CharSettings['stock']         = settings[:stock]
    CharSettings['distiller']     = settings[:distiller]
    CharSettings['prices']        = settings[:prices]
    UserVars.herbsack             = settings[:herb_container]
  end

  if defined?(Gtk)
    # Setup is an extension of Gtk::Builder for Gtk setup
    class Setup < Gtk::Builder
      attr_accessor :settings

      @@categories = {
        general: {
          :buy_missing    => { default: false },
          :deposit_coins  => { default: false },
          :use_mending    => { default: false },
          :skip_scars     => { default: false },
          :blood_toggle   => { default: false },
          :herb_container => { default: '' },
          :use650         => { default: false },
          :use1035        => { default: false },
          :use_yaba       => { default: false },
          :use_potions    => { default: false },
          :stock          => { default: '' },
          :distiller      => { default: false },
        }
      }

      def self.get_category(key)
        @@categories.each { |category, data| return category unless data[key].nil? }
        nil
      end

      def self.get_setting(key)
        cat = Setup.get_category(key)
        return nil if cat.nil?

        @@categories[cat].each { |setting, data| return data if setting == key }
        nil
      end

      def initialize(settings)
        super()

        @settings = settings

        # set default values if they don't exist
        @@categories.each do |_, data|
          data.each { |key, value| @settings[key] = value[:default] if @settings[key].nil? }
        end
        # remove settings that doesn't exist
        @settings.delete_if { |key, _| next Setup.get_category(key).nil? }
        # use a GTK Builder to setup all the basics of the window then expand on that base

        # GoS only for Sigil of Mending
        @settings[:use_mending] = false unless Society.status == 'Guardians of Sunfist' && Society.rank >= 13

        return unless defined?(Gtk) && Gtk::Version::MAJOR == 3

        Gtk.queue do
          # add_from_file("#{$data_dir}eherb.ui")
          add_from_string(Setup.eherbs_ui)
          load_settings
          self['main'].keep_above = true
          self['main'].set_title 'EHerbs Setup'
          # connect signals after settings are loaded to a bunch of handlers don't trigger
          connect_signals { |handler| method(handler) }
        end
      end

      def self.eherbs_ui
        '<?xml version="1.0" encoding="UTF-8"?><!-- Generated with glade 3.38.2 --><interface><requires lib="gtk+" version="3.20"/><object class="GtkWindow" id="main"><property name="width-request">650</property><property name="height-request">375</property><property name="can-focus">False</property><property name="title" translatable="yes">EHerbs Setup</property><property name="default-width">-1</property><property name="default-height">425</property><signal name="destroy" handler="on_destroy" swapped="no"/><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><property name="spacing">5</property><child><object class="GtkNotebook"><property name="visible">True</property><property name="can-focus">True</property><property name="hexpand">True</property><property name="vexpand">True</property><child><object class="GtkScrolledWindow"><property name="visible">True</property><property name="can-focus">True</property><property name="shadow-type">in</property><child><object class="GtkViewport"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><property name="orientation">vertical</property><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-bottom">5</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=5 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="buy_missing"><property name="label" translatable="yes">Buy missing herbs</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_mending"><property name="label" translatable="yes">Use Sigil of Mending</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="skip_scars"><property name="label" translatable="yes">Skip level 1 scars</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">3</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">40</property><property name="label" translatable="yes">Herb Sack</property></object><packing><property name="left-attach">1</property><property name="top-attach">0</property><property name="height">2</property>
        </packing></child><child><object class="GtkEntry" id="herb_container"><property name="visible">True</property><property name="can-focus">True</property><property name="halign">start</property><property name="valign">center</property><property name="margin-end">10</property><property name="width-chars">40</property></object><packing><property name="left-attach">2</property><property name="top-attach">0</property><property name="height">2</property></packing></child><child><object class="GtkCheckButton" id="blood_toggle"><property name="label" translatable="yes">Heal Blood Only</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">4</property></packing></child><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="halign">end</property><property name="margin-start">25</property><property name="label" translatable="yes">Stock to % of Capacity</property></object><packing><property name="left-attach">1</property><property name="top-attach">2</property></packing></child><child><object class="GtkEntry" id="stock"><property name="visible">True</property><property name="can-focus">True</property><property name="tooltip-text" translatable="yes">When using ;eherbs stock it will fill your herb sack to a percentage of it\'s capacity.
        Primarily intended for survival kits but will work for ordinary containers.</property><property name="halign">start</property><property name="valign">center</property><property name="width-chars">15</property><property name="placeholder-text" translatable="yes">0 - 100</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">2</property></packing></child><child><object class="GtkCheckButton" id="deposit_coins"><property name="label" translatable="yes">Deposit Coins</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property>
        </packing></child><child><object class="GtkFrame"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-bottom">5</property><property name="border-width">10</property><property name="label-xalign">0</property><child><!-- n-columns=3 n-rows=2 --><object class="GtkGrid"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="row-spacing">5</property><property name="column-spacing">5</property><child><object class="GtkCheckButton" id="use650"><property name="label" translatable="yes">Assume Aspect (650) Yierka</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use1035"><property name="label" translatable="yes">Song of Tonis (1035)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">0</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="use_yaba"><property name="label" translatable="yes">Use yabathilium first</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">0</property></packing></child><child><object class="GtkCheckButton" id="use_potions"><property name="label" translatable="yes">Try to use potions before plants</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">1</property><property name="top-attach">1</property></packing></child><child><object class="GtkCheckButton" id="distiller"><property name="label" translatable="yes">Use Distiller (survival kits only)</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">False</property><property name="tooltip-text" translatable="yes">Checks the survival kit when eherbs is used and keeps the distiller active. Survival kits were introduced at Dusk Ruin 2023 as a special herb container.</property><property name="halign">start</property><property name="margin-start">10</property><property name="margin-bottom">7</property><property name="draw-indicator">True</property>
        </object><packing><property name="left-attach">2</property><property name="top-attach">0</property></packing></child><child><placeholder/></child></object></child><child type="label"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">Misc</property></object></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing>
        </child></object></child></object></child></object></child><child type="tab"><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="label" translatable="yes">General</property></object><packing><property name="tab-fill">False</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkBox"><property name="visible">True</property><property name="can-focus">False</property><child><object class="GtkLabel"><property name="visible">True</property><property name="can-focus">False</property><property name="margin-start">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="label" translatable="yes">Changes are only saved if you use the Close button --&gt;</property><attributes><attribute name="style" value="italic"/>
        </attributes></object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">0</property></packing></child><child><object class="GtkButton"><property name="label" translatable="yes">Close</property><property name="width-request">80</property><property name="visible">True</property><property name="can-focus">True</property><property name="receives-default">True</property><property name="halign">end</property><property name="margin-end">10</property><property name="margin-top">5</property><property name="margin-bottom">5</property><property name="hexpand">True</property><signal name="clicked" handler="on_close_clicked" swapped="no"/>
        </object><packing><property name="expand">False</property><property name="fill">True</property><property name="position">1</property></packing></child></object><packing><property name="expand">False</property><property name="fill">True</property><property name="pack-type">end</property><property name="position">1</property></packing></child></object></child></object></interface>'
      end

      # This is connected to automatically during load_settings and syncs data back to CharSettings.
      def on_update(obj)
        Gtk.queue do
          key = obj.builder_name.to_sym
          setting = Setup.get_setting(key)
          return if setting.nil?

          if obj.instance_of?(Gtk::CheckButton)
            @settings[key] = obj.active?
          elsif obj.instance_of?(Gtk::Entry)
            @settings[key] = obj.text.strip
          elsif objinstance_of?(Gtk::SpinButton)
            # update from text entry
            obj.update
            # force int, we don't use floats anywhere
            @settings[key] = obj.adjustment.value.to_i
          elsif obj.instance_of?(Gtk::ComboBoxText)
            @settings[key] = obj.active_text
          end
        end
      end

      def on_close_clicked
        EHerbs.load(@settings)
        self['main'].destroy
      end

      def on_destroy
        Gtk.queue do
          @running = false
        end
      end

      # iterate all objects and for any that match a setting name directly we set the default
      def load_settings
        Gtk.queue do
          # load up the generic settings which are just matching by name of the widget
          objects.each do |obj|
            next unless obj.methods.include?(:builder_name)

            key = obj.builder_name.to_sym
            next if (setting = Setup.get_setting(key)).nil?

            if obj.instance_of?(Gtk::CheckButton)
              obj.set_sensitive(false) if obj.builder_name.to_s.eql?("use_mending") && Society.status != 'Guardians of Sunfist' && Society.rank < 13
              obj.set_sensitive(false) if obj.builder_name.to_s.eql?('use650') && !Spell[650].known?
              obj.set_sensitive(false) if obj.builder_name.to_s.eql?('use1035') && !Spell[1035].known?

              if obj.builder_name =~ /^([^:]+):(.*)$/i
                key = Regexp.last_match(1).to_sym
                value = Regexp.last_match(2).to_s
                obj.active = @settings[key].include?(value)
              else
                obj.active = @settings[key]
              end
              obj.signal_connect('toggled') { on_update(obj) }
            elsif obj.instance_of?(Gtk::Entry)
              if @settings[key].instance_of?(String)
                obj.text = @settings[key].strip
              else
                obj.text = @settings[key].to_s
              end
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.instance_of?(Gtk::SpinButton)
              obj.value = @settings[key]
              obj.adjustment.value = @settings[key]
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.instance_of?(Gtk::ComboBoxText)
              obj.set_active(item) if item
              obj.signal_connect('changed') { on_update(obj) }
            elsif obj.instance_of?(Gtk::TreeView)
              if (store = self["#{key}_store"]).nil?
                respond "** failed to find store for treeview #{key}"
                next
              elsif setting[:load].nil?
                respond "** no :load defined #{key}"
                next
              end

              setting[:load].call(store, @settings[key])

              # setup the signals
              if (add = self["#{key}_add"]).nil?
                respond "** failed to find add for treeview #{key}"
                next
              elsif (delete = self["#{key}_delete"]).nil?
                respond "** failed to find delete for treeview #{key}"
                next
              elsif (entry = self["#{key}_entry"]).nil?
                respond "** failed to find entry for treeview #{key}"
                next
              end

              add.signal_connect('clicked') do
                if setting[:set].nil?
                  respond "** no :set defined for #{key}"
                  next
                elsif entry.text.empty?
                  next
                end
                setting[:set].call(store, entry.text, @settings[key])
                setting[:load].call(store, @settings[key])
              end

              delete.signal_connect('clicked') do
                if setting[:delete].nil?
                  respond "** no :delete defined for #{key}"
                  next
                elsif (selected = obj.selection.selected).nil?
                  next
                end
                setting[:delete].call(store, selected, @settings[key])
                setting[:load].call(store, @settings[key])
              end
            end
          end
        end
      end

      def start
        @running = true
        Gtk.queue { self['main'].show_all }
        wait_while { @running }
      end

      def list(cat_to_list: 'all')
        indent_size = 2
        print_array =
          proc do |key, value, indent|
            _respond("#{' ' * indent_size * indent.to_i}#{key}:")
            value.sort!.each { |entry| _respond("#{' ' * indent_size * (indent.to_i + 1)}#{value.index(entry) + 1}. #{entry}") }
          end

        print_value = proc { |key, value, indent| _respond("#{' ' * indent_size * indent.to_i}#{key}: #{value}") }

        categories = cat_to_list == 'all' ? %w[general] : [cat_to_list]

        output = if $frontend == 'stormfront'
                   "<output class=\"mono\"/>\n"
                 else
                   String.new
                 end
        if EHerbs.data[:herb_sack].nil?
          EHerbs.data[:herb_sack] = Utility.find_herbsack
        end

        categories.each do |opt|
          _respond(output) unless output.empty?
          _respond("#{monsterbold_start}= #{opt.capitalize} =#{monsterbold_end}\n")
          @@categories[opt.to_sym].each do |id, _|
            if id == :herb_container
              value = "id: #{EHerbs.data[:herb_sack].id} | name: #{EHerbs.data[:herb_sack].name}"
            else
              value = @settings[id]
            end
            value.instance_of?(Array) ? print_array.call(id, value, 1) : print_value.call(id, value, 1)
          end
        end

        herb_names = []
        EHerbs.data[:herb_sack].contents.each { |herb|
          next unless herb.type =~ /herb/
          herb_names << herb.name
        }
        _respond
        _respond("#{' ' * indent_size}#{Msg.title_case(EHerbs.data[:herb_sack].name)} herbs:")

        herb_names.uniq.each { |item| _respond("#{' ' * indent_size} #{item}") }
        _respond

        return unless $frontend == 'stormfront'

        _respond("<output class=\"\"/>\n")
      end

      def self.update_setting(key, value)
        setting = Setup.get_setting(key)
        echo "** Setting #{key.inspect} does not exist" if setting.nil?
        action = nil

        if value =~ /^([+-])(.*)$/
          action = Regexp.last_match(1)
          value = Regexp.last_match(2).strip.downcase
        end

        if value == 'reset'
          @settings.delete(key)
          echo " Reset #{key}"
        elsif @settings[key].instance_of?(Array)
          if value =~ /\d/ && @settings[key][value.to_i]
            @settings[key].delete_at(value.to_i)
          else
            @settings[key].delete(value)
          end

          if action == '-'
            echo " #{value.inspect} removed from #{key.inspect}"
          else
            @settings[key].push(value)
            echo " #{value.inspect} added to #{key.inspect}"
          end

          echo " #{key.inspect} is now #{@settings[key].join(', ').inspect}"
        else
          if @settings[key].instance_of?(FalseClass) || @settings[key].instance_of?(TrueClass)
            value = value =~ /^true|1|yes|on/ ? true : false
          elsif @settings[key].instance_of?(Integer)
            value = value.to_i
          end

          echo "#{key.inspect} has been set to #{value.inspect}"
          @settings[key] = value
        end
      end
    end

  end

  def self.known_herbs
    [
      # Wehnimer's Landing 325/1028
      # Solhaven 5722/4740011
      # Northern Caravanasary 9276/4746124
      # Ta'Illistim 640/13104200
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some acantha leaf',    type: 'blood',             short_name: 'some acantha leaf',     store_doses: 10 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some wolifrew lichen', type: 'minor nerve wound', short_name: 'some wolifrew lichen',  store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'bolmara potion',       type: 'major nerve wound', short_name: 'bolmara potion',        store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some woth flower',     type: 'major nerve scar',  short_name: 'some woth flower',      store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some torban leaf',     type: 'minor nerve scar',  short_name: 'some torban leaf',      store_doses: 3 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some ambrominas leaf', type: 'minor limb wound',  short_name: 'some ambrominas leaf',  store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some ephlox moss',     type: 'major limb wound',  short_name: 'some ephlox moss',      store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some cactacae spine',  type: 'minor limb scar',   short_name: 'some cactacae spine',   store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some calamia fruit',   type: 'major limb scar',   short_name: 'some calamia fruit',    store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim"],                             name: 'rose-marrow potion',   type: 'minor head wound',  short_name: 'rose-marrow potion',    store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some aloeas stem',     type: 'major head wound',  short_name: 'some aloeas stem',      store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some haphip root',     type: 'minor head scar',   short_name: 'some haphip root',      store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'brostheras potion',    type: 'major head scar',   short_name: 'brostheras potion',     store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some basal moss',      type: 'minor organ wound', short_name: 'some basal moss',       store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some pothinir grass',  type: 'major organ wound', short_name: 'some pothinir grass',   store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'talneo potion',        type: 'minor organ scar',  short_name: 'talneo potion',         store_doses: 4 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'wingstem potion',      type: 'major organ scar',  short_name: 'wingstem potion',       store_doses: 2 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'bur-clover potion',    type: 'missing eye',       short_name: 'bur-clover potion',     store_doses: 1 },
      { location: ["the town of Wehnimer's Landing", 'the free port of Solhaven', 'the Northern Caravansary', "Ta'Illistim", "the town of River's Rest"], name: 'some sovyn clove',     type: 'severed limb',      short_name: 'some sovyn clove',      store_doses: 1 },

      # Solhaven 5722/474011
      { location: ['Do Not Buy'], name: 'bunch of acantha leaf',    type: 'blood',             short_name: 'bunch of acantha leaf',     store_doses: 50 },
      { location: ['Do Not Buy'], name: 'bunch of wolifrew lichen', type: 'minor nerve wound', short_name: 'bunch of wolifrew lichen',  store_doses: 50 },
      { location: ['Do Not Buy'], name: 'large bolmara potion',     type: 'major nerve wound', short_name: 'large bolmara potion',      store_doses: 7 },
      { location: ['Do Not Buy'], name: 'bunch of woth flower',     type: 'major nerve scar',  short_name: 'bunch of woth flower',      store_doses: 50 },
      { location: ['Do Not Buy'], name: 'bunch of torban leaf',     type: 'minor nerve scar',  short_name: 'bunch of torban leaf',      store_doses: 50 },
      { location: ['Do Not Buy'], name: 'bunch of ambrominas leaf', type: 'minor limb wound',  short_name: 'bunch of ambrominas leaf',  store_doses: 50 },
      { location: ['Do Not Buy'], name: 'bunch of ephlox moss',     type: 'major limb wound',  short_name: 'bunch of ephlox moss',      store_doses: 50 },
      { location: ['Do Not Buy'], name: 'bunch of cactacae spine',  type: 'minor limb scar',   short_name: 'bunch of cactacae spine',   store_doses: 50 },
      { location: ['Do Not Buy'], name: 'bunch of calamia fruit',   type: 'major limb scar',   short_name: 'bunch of calamia fruit',    store_doses: 50 },
      { location: ['Do Not Buy'], name: 'large rose-marrow potion', type: 'minor head wound',  short_name: 'large rose-marrow potion',  store_doses: 7 },
      { location: ['Do Not Buy'], name: 'bunch of aloeas stem',     type: 'major head wound',  short_name: 'bunch of aloeas stem',      store_doses: 50 },
      { location: ['Do Not Buy'], name: 'bunch of haphip root',     type: 'minor head scar',   short_name: 'bunch of haphip root',      store_doses: 50 },
      { location: ['Do Not Buy'], name: 'large brostheras potion',  type: 'major head scar',   short_name: 'large brostheras potion',   store_doses: 7 },
      { location: ['Do Not Buy'], name: 'bunch of basal moss',      type: 'minor organ wound', short_name: 'bunch of basal moss',       store_doses: 50 },
      { location: ['Do Not Buy'], name: 'bunch of pothinir grass',  type: 'major organ wound', short_name: 'bunch of pothinir grass',   store_doses: 50 },
      { location: ['Do Not Buy'], name: 'large talneo potion',      type: 'minor organ scar',  short_name: 'large large talneo potion', store_doses: 7 },
      { location: ['Do Not Buy'], name: 'large wingstem potion',    type: 'major organ scar',  short_name: 'large wingstem potion',     store_doses: 7 },
      { location: ['Do Not Buy'], name: 'large bur-clover potion',  type: 'missing eye',       short_name: 'large bur-clover potion',   store_doses: 7 },
      { location: ['Do Not Buy'], name: 'bunch of sovyn clove',     type: 'severed limb',      short_name: 'bunch of sovyn clove',      store_doses: 50 },

      # Ta'Vaalor 10396/14103400
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of acantha',     type: 'blood',              short_name: 'tincture of acantha',     store_doses: 10 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of ambrominas',  type: 'minor limb wound',   short_name: 'tincture of ambrominas',  store_doses: 4 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of wolifrew',    type: 'minor nerve wound',  short_name: 'tincture of wolifrew',    store_doses: 4 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of rose-marrow', type: 'minor head wound',   short_name: 'tincture of rose-marrow', store_doses: 4 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of basal',       type: 'minor organ wound',  short_name: 'tincture of basal',       store_doses: 4 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of ephlox',      type: 'major limb wound',   short_name: 'tincture of ephlox',      store_doses: 4 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of bolmara',     type: 'major nerve wound',  short_name: 'tincture of bolmara',     store_doses: 4 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of aloeas',      type: 'major head wound',   short_name: 'tincture of aloeas',      store_doses: 2 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of pothinir',    type: 'major organ wound',  short_name: 'tincture of pothinir',    store_doses: 2 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of cactacae',    type: 'minor limb scar',    short_name: 'tincture of cactacae',    store_doses: 4 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of torban',      type: 'minor nerve scar',   short_name: 'tincture of torban',      store_doses: 3 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of haphip',      type: 'minor head scar',    short_name: 'tincture of haphip',      store_doses: 4 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of talneo',      type: 'minor organ scar',   short_name: 'tincture of talneo',      store_doses: 4 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of calamia',     type: 'major limb scar',    short_name: 'tincture of calamia',     store_doses: 2 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of woth',        type: 'major nerve scar',   short_name: 'tincture of woth',        store_doses: 2 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of brostheras',  type: 'major head scar',    short_name: 'tincture of brostheras',  store_doses: 2 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of wingstem',    type: 'major organ scar',   short_name: 'tincture of wingstem',    store_doses: 2 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of bur-clover',  type: 'missing eye',        short_name: 'tincture of bur-clover',  store_doses: 1 },
      { location: ["the city of Ta'Vaalor"],   name: 'tincture of sovyn',       type: 'severed limb',       short_name: 'tincture of sovyn',       store_doses: 1 },

      # Zul Logoth 9505/13010004
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'grey mushroom potion',    type: 'blood',              short_name: 'grey mushroom potion',     store_doses: 7 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'green mushroom potion',   type: 'blood',              short_name: 'green mushroom potion',    store_doses: 5 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'bubbling brown ale',      type: 'minor limb wound',   short_name: 'bubbling brown ale',       store_doses: 3 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'thick foggy ale',         type: 'minor nerve wound',  short_name: 'thick foggy ale',          store_doses: 3 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'rusty red ale',           type: 'minor head wound',   short_name: 'rusty red ale',            store_doses: 3 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'chunky black ale',        type: 'minor organ wound',  short_name: 'chunky black ale',         store_doses: 3 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'crushed cavegrass tea',   type: 'major limb wound',   short_name: 'crushed cavegrass tea',    store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'glowing mold tea',        type: 'major nerve wound',  short_name: 'glowing mold tea',         store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'sticky lichen tea',       type: 'major head wound',   short_name: 'sticky lichen tea',        store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'roasted ratweed tea',     type: 'major organ wound',  short_name: 'roasted ratweed tea',      store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'spotted toadstool ale',   type: 'minor limb scar',    short_name: 'spotted toadstool ale',    store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'dark frothing ale',       type: 'minor nerve scar',   short_name: 'dark frothing ale',        store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'dull crimson ale',        type: 'minor head scar',    short_name: 'dull crimson ale',         store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'brown weedroot ale',      type: 'minor organ scar',   short_name: 'brown weedroot ale',       store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'stalactite brew',         type: 'major limb scar',    short_name: 'stalactite brew',          store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'stalagmite brew',         type: 'major nerve scar',   short_name: 'stalagmite brew',          store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'stone soot brew',         type: 'major head scar',    short_name: 'stone soot brew',          store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'dirty crevice brew',      type: 'major organ scar',   short_name: 'dirty crevice brew',       store_doses: 2 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'dirty rat fur potion',    type: 'missing eye',        short_name: 'dirty rat fur potion',     store_doses: 1 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'grainy black potion',     type: 'severed limb',       short_name: 'grainy black potion',      store_doses: 1 },
      { location: ['Zul Logoth', 'the tunnels and caverns of Zul Logoth'],     name: 'milky white potion',      type: 'lifekeep',           short_name: 'milky white potion',       store_doses: 3 },

      # Cysaegir 4647/14051034
      # Ravelin 13943/14201010
      # Sylvarraend 13137/13051014 NOTE-  the Lich location for Sylvarraend is "Ta'Illistim", but the tincture values match Cesaegir values, not the ones from Herablist2 in TI.
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of acantha',      type: 'blood',             short_name: 'tincture of acantha',           store_doses: 10 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of ambrominas',   type: 'minor limb wound',  short_name: 'tincture of ambrominas',        store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of wolifrew',     type: 'minor nerve wound', short_name: 'tincture of wolifrew',          store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of rose-marrow',  type: 'minor head wound',  short_name: 'tincture of rose-marrow',       store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of basal',        type: 'minor organ wound', short_name: 'tincture of basal',             store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of ephlox',       type: 'major limb wound',  short_name: 'tincture of ephlox',            store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of bolmara',      type: 'major nerve wound', short_name: 'tincture of bolmara',           store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of aloeas',       type: 'major head wound',  short_name: 'tincture of aloeas',            store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of pothinir',     type: 'major organ wound', short_name: 'tincture of pothinir',          store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of cactacae',     type: 'minor limb scar',   short_name: 'tincture of cactacae',          store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of torban',       type: 'minor nerve scar',  short_name: 'tincture of torban',            store_doses: 3 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of haphip',       type: 'minor head scar',   short_name: 'tincture of haphip',            store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of talneo',       type: 'minor organ scar',  short_name: 'tincture of talneo',            store_doses: 4 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of calamia',      type: 'major limb scar',   short_name: 'tincture of calamia',           store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of woth',         type: 'major nerve scar',  short_name: 'tincture of woth',              store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of brostheras',   type: 'major head scar',   short_name: 'tincture of brostheras',        store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of wingstem',     type: 'major organ scar',  short_name: 'tincture of wingstem',          store_doses: 2 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of bur-clover',   type: 'missing eye',       short_name: 'tincture of bur-clover',        store_doses: 1 },
      { location: ['Cysaegir', 'the hamlet of Ravelin'],   name: 'tincture of sovyn',        type: 'severed limb',      short_name: 'tincture of sovyn',             store_doses: 1 },

      # Ta'Illistim 2 19282/13204008
      { location: ["Ta'Illistim"],   name: 'tincture of acantha',     type: 'blood',              short_name: 'tincture of acantha',     store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of wolifrew',    type: 'minor nerve wound',  short_name: 'tincture of wolifrew',    store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of torban',      type: 'minor nerve scar',   short_name: 'tincture of torban',      store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of woth',        type: 'major nerve scar',   short_name: 'tincture of woth',        store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of ambrominas',  type: 'minor limb wound',   short_name: 'tincture of ambrominas',  store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of basal',       type: 'minor organ wound',  short_name: 'tincture of basal',       store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of ephlox',      type: 'major limb wound',   short_name: 'tincture of ephlox',      store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of pothinir',    type: 'major organ wound',  short_name: 'tincture of pothinir',    store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of aloeas',      type: 'major head wound',   short_name: 'tincture of aloeas',      store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of rose-marrow', type: 'minor head wound',   short_name: 'tincture of rose-marrow', store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of cactacae',    type: 'minor limb scar',    short_name: 'tincture of cactacae',    store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of calamia',     type: 'major limb scar',    short_name: 'tincture of calamia',     store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of haphip',      type: 'minor head scar',    short_name: 'tincture of haphip',      store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of brostheras',  type: 'major head scar',    short_name: 'tincture of brostheras',  store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of bolmara',     type: 'major nerve wound',  short_name: 'tincture of bolmara',     store_doses: 20 },
      { location: ["Ta'Illistim"],   name: 'tincture of talneo',      type: 'minor organ scar',   short_name: 'tincture of talneo',      store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of bur-clover',  type: 'missing eye',        short_name: 'tincture of bur-clover',  store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of wingstem',    type: 'major organ scar',   short_name: 'tincture of wingstem',    store_doses: 10 },
      { location: ["Ta'Illistim"],   name: 'tincture of sovyn',       type: 'severed limb',       short_name: 'tincture of sovyn',       store_doses: 10 },

      # Teras 1851/3003056
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Olak's Ol'style ale",    type: 'blood',              short_name: "Olak's Ol'style ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Olak's Ol'style ale",    type: 'blood',              short_name: "Olak's Ol'style ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Lost Dogwater ale',      type: 'minor limb wound',   short_name: 'Lost Dogwater ale',          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Lost Dogwater ale',      type: 'minor limb wound',   short_name: 'Lost Dogwater ale',          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Orc's Head ale",         type: 'minor nerve wound',  short_name: "Orc's Head ale",             store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Orc's Head ale",         type: 'minor nerve wound',  short_name: "Orc's Head ale",             store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Semak's Smooth ale",     type: 'minor head wound',   short_name: "Semak's Smooth ale",         store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Semak's Smooth ale",     type: 'minor head wound',   short_name: "Semak's Smooth ale",         store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Mama Dwarf's ale",       type: 'minor organ wound',  short_name: "Mama Dwarf's ale",           store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Mama Dwarf's ale",       type: 'minor organ wound',  short_name: "Mama Dwarf's ale",           store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Bloody Krolvin ale',     type: 'blood',              short_name: 'Bloody Krolvin ale',         store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Bloody Krolvin ale',     type: 'blood',              short_name: 'Bloody Krolvin ale',         store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Golden Goose ale',       type: 'major limb wound',   short_name: 'Golden Goose ale',           store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Golden Goose ale',       type: 'major limb wound',   short_name: 'Golden Goose ale',           store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Kenar's Dropjaw ale",    type: 'major nerve wound',  short_name: "Kenar's Dropjaw ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Kenar's Dropjaw ale",    type: 'major nerve wound',  short_name: "Kenar's Dropjaw ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Dark Swampwater ale',    type: 'major head wound',   short_name: 'Dark Swampwater ale',        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Dark Swampwater ale',    type: 'major head wound',   short_name: 'Dark Swampwater ale',        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Aged Schooner ale',      type: 'major organ wound',  short_name: 'Aged Schooner ale',          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Aged Schooner ale',      type: 'major organ wound',  short_name: 'Aged Schooner ale',          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Bearded Ladies' ale",    type: 'minor limb scar',    short_name: "Bearded Ladies' ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Bearded Ladies' ale",    type: 'minor limb scar',    short_name: "Bearded Ladies' ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Miner's Muddy ale",      type: 'minor nerve scar',   short_name: "Miner's Muddy ale",          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Miner's Muddy ale",      type: 'minor nerve scar',   short_name: "Miner's Muddy ale",          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Agrak's Amber ale",      type: 'minor head scar',    short_name: "Agrak's Amber ale",          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Agrak's Amber ale",      type: 'minor head scar',    short_name: "Agrak's Amber ale",          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Gert's Homemade ale",    type: 'minor organ scar',   short_name: "Gert's Homemade ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Gert's Homemade ale",    type: 'minor organ scar',   short_name: "Gert's Homemade ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Mad Mutt Frothy ale',    type: 'major limb scar',    short_name: 'Mad Mutt Frothy ale',        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Mad Mutt Frothy ale',    type: 'major limb scar',    short_name: 'Mad Mutt Frothy ale',        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Dacra's Dream ale",      type: 'major nerve scar',   short_name: "Dacra's Dream ale",          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Dacra's Dream ale",      type: 'major nerve scar',   short_name: "Dacra's Dream ale",          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Reaper's Red ale",       type: 'major head scar',    short_name: "Reaper's Red ale",           store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Reaper's Red ale",       type: 'major head scar',    short_name: "Reaper's Red ale",           store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Reaper's Red ale",       type: 'major head scar',    short_name: "Reaper's Red ale",           store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Wort's Winter ale",      type: 'major organ scar',   short_name: "Wort's Winter ale",          store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Wort's Winter ale",      type: 'major organ scar',   short_name: "Wort's Winter ale",          store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: 'flagon of Volcano Vision ale',     type: 'missing eye',        short_name: 'Volcano Vision ale',         store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: 'barrel of Volcano Vision ale',     type: 'missing eye',        short_name: 'Volcano Vision ale',         store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Captn' Pegleg's ale",    type: 'severed limb',       short_name: "Captn' Pegleg's ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Captn' Pegleg's ale",    type: 'severed limb',       short_name: "Captn' Pegleg's ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Dead Man's Pale ale",    type: 'lifekeep',           short_name: "Dead Man's Pale ale",        store_doses: 3 },
      { location: ['the town of Kharam-Dzu'],  name: "barrel of Dead Man's Pale ale",    type: 'lifekeep',           short_name: "Dead Man's Pale ale",        store_doses: 10 },
      { location: ['the town of Kharam-Dzu'],  name: "flagon of Dragon's Blood porter",  type: 'raisedead',          short_name: "Dragon's Blood porter",      store_doses: 1 },

      # Icemule 3363/4043866
      # Hinterwilds 31061/7503257
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'Dabbings Family special tart',      type: 'minor limb wound',    short_name: 'Family special tart',       store_doses: 10 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: "Leaftoe's lichen tart",             type: 'minor nerve wound',   short_name: 'lichen tart',               store_doses: 10 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'candied ptarmigan feather',         type: 'severed limb',        short_name: 'ptarmigan feather',         store_doses: 1 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'earthworm potion',                  type: 'major organ scar',    short_name: 'earthworm potion',          store_doses: 2 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'elk horn potion',                   type: 'minor head wound',    short_name: 'elk horn potion',           store_doses: 4 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'gelatinous elk fat tart',           type: 'minor limb scar',     short_name: 'elk fat tart',              store_doses: 10 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'iceberry tart',                     type: 'blood',               short_name: 'iceberry tart',             store_doses: 10 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'rock lizard potion',                type: 'minor organ scar',    short_name: 'rock lizard potion',        store_doses: 4 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: "slice of Ma Leaftoe's Special",     type: 'minor nerve scar',    short_name: "Ma Leaftoe's Special",      store_doses: 5 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'slice of pickled walrus blubber',   type: 'major limb scar',     short_name: 'pickled walrus blubber',    store_doses: 2 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'slice of sparrowhawk pie',          type: 'minor head scar',     short_name: 'sparrowhawk pie',           store_doses: 5 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'small egg and tundra grass tart',   type: 'minor organ wound',   short_name: 'tundra grass tart',         store_doses: 5 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'snowflake elixir',                  type: 'major nerve wound',   short_name: 'snowflake elixir',          store_doses: 4 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: "some frog's bone porridge",         type: 'major limb wound',    short_name: "frog's bone porridge",      store_doses: 4 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'starfish potion',                   type: 'missing eye',         short_name: 'starfish potion',           store_doses: 1 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'tiny cup of polar bear fat soup',   type: 'major head scar',     short_name: 'polar bear fat soup',       store_doses: 2 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'tiny flower-shaped tart',           type: 'major nerve scar',    short_name: 'flower-shaped tart',        store_doses: 2 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: 'tiny musk ox tart',                 type: 'major organ wound',   short_name: 'musk ox tart',              store_doses: 2 },
      { location: ['Icemule Trace', 'Hinterwilds'], name: "tiny ram's bladder tart",           type: 'major head wound',    short_name: "ram's bladder tart",        store_doses: 2 },

      # Pinefar 2782/4564010
      { location: ['the Pinefar Trading Post'], name: 'some acantha leaf tea',    type: 'blood',              short_name: 'acantha leaf tea',        store_doses: 10 },
      { location: ['the Pinefar Trading Post'], name: 'some sweetfern tea',       type: 'minor limb wound',   short_name: 'sweetfern tea',           store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'some red lichen tea',      type: 'minor nerve wound',  short_name: 'red lichen tea',          store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'some feverfew tea',        type: 'minor head wound',   short_name: 'feverfew tea',            store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'some ginkgo nut tea',      type: 'minor organ wound',  short_name: 'ginkgo nut tea',          store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'some sassafras tea',       type: 'blood',              short_name: 'sassafras tea',           store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'sweetfern potion',         type: 'major limb wound',   short_name: 'sweetfern potion',        store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'red lichen potion',        type: 'major nerve wound',  short_name: 'red lichen potion',       store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'feverfew potion',          type: 'major head wound',   short_name: 'feverfew potion',         store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'ginkgo nut potion',        type: 'major organ wound',  short_name: 'ginkgo nut potion',       store_doses: 4 },
      { location: ['the Pinefar Trading Post'], name: 'manroot tea',              type: 'minor limb scar',    short_name: 'manroot tea',             store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'valerian root tea',        type: 'minor nerve scar',   short_name: 'valerian root tea',       store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'pennyroyal tea',           type: 'minor head scar',    short_name: 'pennyroyal tea',          store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'wyrmwood root tea',        type: 'minor organ scar',   short_name: 'wyrmwood root tea',       store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'manroot potion',           type: 'major limb scar',    short_name: 'manroot potion',          store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'valerian root potion',     type: 'major nerve scar',   short_name: 'valerian root potion',    store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'pennyroyal potion',        type: 'major head scar',    short_name: 'pennyroyal potion',       store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'wyrmwood root potion',     type: 'major organ scar',   short_name: 'wyrmwood root potion',    store_doses: 2 },
      { location: ['the Pinefar Trading Post'], name: 'daggit root potion',       type: 'missing eye',        short_name: 'daggit root potion',      store_doses: 1 },
      { location: ['the Pinefar Trading Post'], name: 'angelica root potion',     type: 'severed limb',       short_name: 'angelica root potion',    store_doses: 1 },
      { location: ['the Pinefar Trading Post'], name: 'earwort potion',           type: 'disease',            short_name: 'earwort potion',          store_doses: 1 },

      # Kraken's Fall 28938/7118357
      { location: ["Kraken's Fall"], name: 'some acantha leaf',            type: 'blood',               short_name: 'acantha leaf',       store_doses: 10 },
      { location: ["Kraken's Fall"], name: 'some wolifrew lichen',         type: 'minor nerve wound',   short_name: 'wolifrew lichen',    store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some torban leaf',             type: 'minor nerve scar',    short_name: 'torban leaf',        store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'bolmara elixir',               type: 'major nerve wound',   short_name: 'bolmara elixir',     store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some woth flower',             type: 'major nerve scar',    short_name: 'woth flower',        store_doses: 3 },
      { location: ["Kraken's Fall"], name: 'rose-marrow elixir',           type: 'minor head wound',    short_name: 'rose-marrow elixir', store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some haphip root',             type: 'minor head scar',     short_name: 'haphip root',        store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some aloeas stem',             type: 'major head wound',    short_name: 'aloeas stem',        store_doses: 2 },
      { location: ["Kraken's Fall"], name: 'brostheras elixir',            type: 'major head scar',     short_name: 'brostheras elixir',  store_doses: 2 },
      { location: ["Kraken's Fall"], name: 'ball of basal moss',           type: 'minor organ wound',   short_name: 'basal moss',         store_doses: 7 },
      { location: ["Kraken's Fall"], name: 'talneo elixir',                type: 'minor organ scar',    short_name: 'talneo elixir',      store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some pothinir grass',          type: 'major organ wound',   short_name: 'pothinir grass',     store_doses: 2 },
      { location: ["Kraken's Fall"], name: 'wingstem elixir',              type: 'major organ scar',    short_name: 'wingstem elixir',    store_doses: 2 },
      { location: ["Kraken's Fall"], name: 'some ambrominas leaf',         type: 'minor limb wound',    short_name: 'ambrominas leaf',    store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some cactacae spine',          type: 'minor limb scar',     short_name: 'cactacae spine',     store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'ball of ephlox moss',          type: 'major limb wound',    short_name: 'ephlox moss',        store_doses: 4 },
      { location: ["Kraken's Fall"], name: 'some calamia fruit',           type: 'major limb scar',     short_name: 'calamia fruit',      store_doses: 2 },
      { location: ["Kraken's Fall"], name: 'cumin-rubbed sovyn clove',     type: 'severed limb',        short_name: 'sovyn clove',        store_doses: 1 },
      { location: ["Kraken's Fall"], name: 'bur-clover elixir',            type: 'missing eye',         short_name: 'bur-clover elixir',  store_doses: 1 },

      # Mist Harbor 3363/4043866
      { location: ['the Isle of Four Winds'], name: 'some fragrant woth flower',        type: 'major nerve scar',   short_name: 'fragrant woth flower',             store_doses: 3 },
      { location: ['the Isle of Four Winds'], name: 'some dirty haphip root',           type: 'minor head scar',    short_name: 'dirty haphip root',                store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'sticky ball of basal moss',        type: 'minor organ wound',  short_name: 'ball of basal moss',               store_doses: 7 },
      { location: ['the Isle of Four Winds'], name: 'gooey ball of ephlox moss',        type: 'major limb wound',   short_name: 'ball of ephlox moss',              store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'some sugary ambrominas leaf',      type: 'minor limb wound',   short_name: 'sugary ambrominas leaf',           store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'some fresh torban leaf',           type: 'minor nerve scar',   short_name: 'fresh torban leaf',                store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'some spicy acantha leaf',          type: 'blood',              short_name: 'spicy acantha leaf',               store_doses: 10 },
      { location: ['the Isle of Four Winds'], name: 'small sovyn clove',                type: 'severed limb',       short_name: 'small sovyn clove',                store_doses: 1 },
      { location: ['the Isle of Four Winds'], name: 'some bright green pothinir grass', type: 'major organ wound',  short_name: 'some bright pothinir grass',       store_doses: 2 },
      { location: ['the Isle of Four Winds'], name: 'some withered aloeas stem',        type: 'major head wound',   short_name: 'withered aloeas stem',             store_doses: 2 },
      { location: ['the Isle of Four Winds'], name: 'some ripe calamia fruit',          type: 'major limb scar',    short_name: 'ripe calamia fruit',               store_doses: 2 },
      { location: ['the Isle of Four Winds'], name: 'some prickly cactacae spine',      type: 'minor limb scar',    short_name: 'prickly cactacae spine',           store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'some dry wolifrew lichen',         type: 'minor nerve wound',  short_name: 'dry wolifrew lichen',              store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'crystalline rose-marrow elixir',   type: 'minor head wound',   short_name: 'rose-marrow elixir',               store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'crystalline talneo elixir',        type: 'minor organ scar',   short_name: 'talneo elixir',                    store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'crystalline brostheras elixir',    type: 'major head scar',    short_name: 'brostheras elixir',                store_doses: 2 },
      { location: ['the Isle of Four Winds'], name: 'crystalline bolmara elixir',       type: 'major nerve wound',  short_name: 'bolmara elixir',                   store_doses: 4 },
      { location: ['the Isle of Four Winds'], name: 'crystalline wingstem elixir',      type: 'major organ scar',   short_name: 'wingstem elixir',                  store_doses: 2 },
      { location: ['the Isle of Four Winds'], name: 'crystalline bur-clover elixir',    type: 'missing eye',        short_name: 'bur-clover elixir',                store_doses: 1 },

      # River's Rest 10863/2101012
      { location: ["River's Rest"], name: 'beaker of malted winterberry brew', type: 'minor head wound',   short_name: 'beaker of winterberry brew',  store_doses: 4 },
      { location: ["River's Rest"], name: 'beaker of winterberry brew',        type: 'minor head wound',   short_name: 'winterberry brew',            store_doses: 4 },

      # I don't have a location or details for the following
      # foragable only?
      { location: ['Forageable'], name: 'yabathilium fruit',              type: 'blood',   short_name: 'yabathilium fruit',         store_doses: 1 },
      { location: ['Forageable'], name: 'ochre-colored fungus',           type: 'poison',  short_name: 'ochre-colored fungus',      store_doses: 1 },
      { location: ['Forageable'], name: 'red nettle berry',               type: 'poison',  short_name: 'red nettle berry',          store_doses: 1 },

      # weird skins only?
      { location: ['Skinnable'],  name: 'pulsating firethorn shoot',      type: 'poison',  short_name: 'pulsating firethorn shoot', store_doses: 1 },

      # alchemical only?
      { location: ['Alchemical'], name: 'tincture of yabathilium',        type: 'blood',   short_name: 'tincture of yabathilium',   store_doses: 1 },
      { location: ['Alchemical'], name: 'dimly glowing sky-blue potion',  type: 'disease', short_name: 'sky-blue potion',           store_doses: 4 },
      { location: ['Alchemical'], name: 'dimly glowing sea-green potion', type: 'poison',  short_name: 'sea-green potion',          store_doses: 4 }
    ]
  end

  module Actions
    def self.bundle_all(herb = nil)
      EHerbs.data[:herb_sack] = Utility.find_herbsack if EHerbs.data[:herb_sack].nil?
      return if EHerbs.data[:survival_kit]

      if herb.nil?
        herbs = EHerbs.known_herbs.map { |item| item[:name] }.uniq
      else
        herbs = [herb]
      end

      # Remove any items that can't be bundled or poured together
      herbs.reject { |name| name =~ /\b#{EHerbs.data[:cant_bundle]}$/ }

      ignore_list = Array.new
      herbs.each do |thing|
        bundle = EHerbs.data[:herb_sack].contents.find_all { |item|
          item.full_name.lstrip =~ /#{thing}/
        }
        next if bundle.length <= 1

        bundle = bundle[0]
        full = false

        Inventory.drag_to_hand(bundle)
        ignore_list.push(bundle.id)

        until (item = EHerbs.data[:herb_sack].contents.find { |h| h.full_name.lstrip =~ /#{thing}/ && !ignore_list.include?(h.id) }).nil?
          unless bundle
            bundle = item
            Inventory.drag_to_hand(item)
            ignore_list.push(item.id)
            next
          end

          Inventory.drag_to_hand(item)

          if item.name =~ /potion|tincture|elixir|barrel|flagon|tea|soup/
            until (pour_result = dothis "pour ##{item.id} in ##{bundle.id}", /You have|You only|You can|twinkling/) =~ /You can|twinkling/
            end
            full = true if pour_result =~ /You can/
          else
            bundle_result = dothis "bundle", /Carefully|If you|Try as|You can't|That is not an herb you can bundle/i
            if bundle_result =~ /If you/
              full = true
            elsif bundle_result =~ /Try as|You can't|That is not an herb you can bundle/
              dothistimeout "measure ##{item.id}", 2, /^The .*? left/
              Inventory.drag_to_container(item.id, EHerbs.data[:herb_sack].id)
              ignore_list.push(item.id)
            else
              bundle = GameObj.right_hand
            end
          end

          if full
            dothistimeout "measure ##{bundle.id}", 2, /^The .*? left/
            Inventory.drag_to_container(bundle.id, EHerbs.data[:herb_sack].id)
            bundle = item
            full = false
          end

          ignore_list.push(item.id)
        end

        if bundle
          dothistimeout "measure ##{bundle.id}", 2, /^The .*? left/
          Inventory.drag_to_container(bundle.id, EHerbs.data[:herb_sack].id)
        end
      end
    end

    def self.bundle_herb
      same_potion = same_herb = false

      got_salad = (GameObj.right_hand.noun !~ EHerbs.data[:drinkable])
      got_croutons = (GameObj.left_hand.noun !~ EHerbs.data[:drinkable])
      got_milk = (GameObj.right_hand.noun =~ EHerbs.data[:drinkable])
      got_syrup = (GameObj.left_hand.noun =~ EHerbs.data[:drinkable])
      # second get full name in each hand - if not the same, move on to prevent mixing
      # potion types inappropriately.
      same_potion = GameObj.right_hand.name.sub(GameObj.right_hand.noun, '').rstrip == GameObj.left_hand.name.sub(GameObj.left_hand.noun, '').rstrip unless got_milk.nil? || got_syrup.nil?

      same_herb = GameObj.right_hand.name.sub(GameObj.right_hand.noun, '').rstrip == GameObj.left_hand.name.sub(GameObj.left_hand.noun, '').rstrip unless got_salad.nil? || got_croutons.nil?

      if same_potion
        old_herb = GameObj.right_hand
        new_herb = GameObj.left_hand
        10.times do
          break unless (GameObj.right_hand.id == old_herb.id) || (GameObj.left_hand.id == new_herb.id)

          result = dothistimeout "pour ##{new_herb.id} in ##{old_herb.id}", 5, /^You carefully pour a little bit from your|^You can't pour|^I can't find that|^I could not find what you were referring to/
          if result =~ /^You can't pour any more in there without spilling it\./
            $eherbs_measure[old_herb.id] = 10 if old_herb.name =~ /barrel/
            $eherbs_measure[old_herb.id] = 7 if old_herb.name !~ /barrel/
            break
          elsif GameObj.left_hand.name == 'Empty'
            break
          elsif result =~ /^You can't pour|^I can't find that|^I could not find what you were referring to/
            break
          end
        end
      elsif same_herb
        old_herb = GameObj.right_hand
        new_herb = GameObj.left_hand
        bundle_result = dothistimeout 'bundle', 5, /^Carefully, you combine|^If you add anything more to this bundle|^You do not have anything to bundle!$|^You can't put .* together in a bundle!/
        # SIMU does not send the full descriptions of items in right / left hands in XML
        # so we have to do this work-around.
        if bundle_result =~ /^You can't put (.*)<a exist=.*noun=.*>(.*), and (.*)<a exist=.*noun=.*>(.*) together in a bundle!/
          herb_right = Regexp.last_match(1) + Regexp.last_match(2)
          herb_left = Regexp.last_match(3) + Regexp.last_match(4)
          if herb_right != herb_left
            respond
            respond Msg.monsterbold("The herbs don't match! Your old herb is #{herb_right}, and you bought #{herb_left}.")
            respond
            respond "This happens when you move areas.  What you should do depends on how long you'll be in the area.  If you're moving permanently, throw the herbs in your right hand away and put the herbs in your left hand in your #{EHerbs.data[:herb_sack]}."
            respond "If you're only visiting temporarily, put the herbs in your right hand in another container for your return and put the herbs in your left hand in your #{EHerbs.data[:herb_sack]}."
            respond
            respond "When finished, run #{$clean_lich_char}#{Script.current.name} with your stocking options again."
            exit
          end
        end
      end
    end

    def self.buy_herb(herb_type, amount = 1)
      EHerbs.data[:need_return] = true
      EHerbs.data[:silvers] = Utility.check_silver

      EHerbs.data[:herb_shop_menu] = Utility.read_menu unless EHerbs.data[:herb_shop_menu]
      herb_name = EHerbs.data[:herb_shop_menu].keys.find { |name| EHerbs.known_herbs.any? { |h| (h[:type] == herb_type) and (name == h[:name] || name == h[:short_name]) } }
      unless (order_number = EHerbs.data[:herb_shop_menu][herb_name])
        _respond
        _respond Msg.monsterbold(" error: failed to find #{herb_name} for #{herb_type} in the menu")
        _respond "shop menu: #{EHerbs.data[:herb_shop_menu]}"
        _respond
        exit
      end

      order_result = dothistimeout "order #{amount} #{order_number}", 3, /^You will need a free hand|BUY/
      if order_result =~ /You will need a free hand/
        fput "put ##{GameObj.right_hand.id} in #{EHerbs.data[:herb_sack]}"
        fput "put ##{GameObj.left_hand.id} in #{EHerbs.data[:herb_sack]}"
      end
      buy_result = dothistimeout 'buy', 3, /Sold for [0-9,]+ silver|^But you do not have enough silver!|You're going to need a free hand/
      case buy_result
      when /Sold for ([0-9,]+) silver/
        if (item = [GameObj.right_hand, GameObj.left_hand].find { |obj| EHerbs.known_herbs.any? { |herb| (herb[:name] =~ /#{obj.name}/ || herb[:short_name] =~ /#{obj.name}/) } })
          if (herb_info = EHerbs.known_herbs.find { |h| h[:name] == item.name })
            $eherbs_measure[item.id] = herb_info[:store_doses]
          end
        end
      when /^But you do not have enough silver!/
        Actions.withdraw
        Utility.go2('herbalist')
        return Actions.buy_herb(herb_type)
      when /You're going to need a free hand/
        EHerbs.data[:done_empty_hand] = true
        empty_hands
      else
        EHerbs.data[:silvers] = Utility.check_silver
      end
      # potential fixme - no left hand check and no stow hands?

      return GameObj.right_hand if checkright
    end

    def self.cast_spells
      if EHerbs.data[:use_mending] && Spell[9713].known? && Spell[9713].affordable? && !Effects::Buffs.active?('Sigil of Mending')
        waitcastrt?
        Spell[9713].cast
      end

      if Spell[1035].known? && Spell[1035].affordable? && !Effects::Buffs.active?('Song of Tonis') && EHerbs.data[:use1035] && Utility.able_to_cast
        waitcastrt?
        Spell[1035].cast
      end

      return unless EHerbs.data[:use650] && Utility.able_to_cast

      if Spell[650].known? && Spell[650].affordable? && !Spell[650].active? && !Effects::Buffs.active?('Aspect of the Yierka') && !Spell[9039].active?
        waitcastrt?
        multifput("prep 650", "assume yierka")
      elsif Spell[650].active? && !Effects::Buffs.active?('Aspect of the Yierka') && !Spell[9039].active? && checkmana > 25
        waitcastrt?
        fput 'assume yierka'
      end
    end

    def self.check_prices
      EHerbs.data[:prices] ||= {}

      herbalist = Room.current.find_nearest_by_tag("herbalist")

      unless EHerbs.data[:prices][herbalist].values.first.is_a?(Hash)
        EHerbs.data[:prices][herbalist] = {}

        Utility.go2('herbalist')

        _respond Msg.monsterbold(" Checking prices at this location. Will only do this one time")

        menu = Utility.read_menu

        menu.each do |herb, item|
          lines = Utility.get_lines("order #{item}", /You ask/)
          price_regex = /\b([\d,]+)\s*(?:silver|silvers)\b/ # Regular expression to match "silver" or "silvers" with optional comma in number
          price = lines.map { |string| string.scan(price_regex).flatten.first }.compact.first&.gsub(',', '')&.to_i

          info = EHerbs.known_herbs.find { |h| (h[:name] =~ /#{herb}/ || h[:short_name] =~ /#{herb}/) && !h[:location].include?('Do Not Buy') }
          next unless info

          EHerbs.data[:prices][herbalist][info[:type]] = {}
          EHerbs.data[:prices][herbalist][info[:type]][:cost] = price
          EHerbs.data[:prices][herbalist][info[:type]][:name] = info[:name]
          EHerbs.data[:prices][herbalist][info[:type]][:short_name] = info[:short_name]
        end

        CharSettings['prices'] = EHerbs.data[:prices]
      end

      Msg.debug_msg("check_prices | EHerbs.data[:prices][herbalist]: #{EHerbs.data[:prices][herbalist]} | called by #{caller[0]}")
      return EHerbs.data[:prices][herbalist]
    end

    def self.deposit
      silvers = Utility.check_silver

      return unless silvers > 0

      Utility.go2('bank')
      if XMLData.room_title == '[Pinefar, Depository]'
        loop {
          break if GameObj.npcs.any? { |npc| npc.noun == 'banker' }
          echo "Waiting on the npc to return..."
          pause 5
        }
        fput "give banker #{silvers} silvers"
      else
        fput "deposit #{silvers}"
      end
    end

    def self.deposit_note
      original_room = Room.current.id
      Utility.check_cutthroat

      Utility.go2('bank')

      # Can't get a note from Pinefar
      if XMLData.room_title == '[Pinefar, Depository]'
        Actions.deposit
        return
      end

      Inventory.drag_to_hand(EHerbs.data[:note])
      fput("deposit #{EHerbs.data[:note].noun}")
      EHerbs.data[:note] = nil
      Utility.go2(original_room)
    end

    def self.appraise_character(appraisal_line)
      deader_injuries = []

      deader_injuries.push('major head wound') if appraisal_line.any? { |l| l =~ /minor lacerations about the head|bleeding from the head|moderate bleeding from (?:his|her) neck|severe head trauma and bleeding from the ears|snapped bones and serious bleeding from the neck/ }
      deader_injuries.push('major organ wound') if appraisal_line.any? { |l| l =~ /deep lacerations|deep gashes and serious bleeding/ }
      deader_injuries.push('major limb wound') if appraisal_line.any? { |l| l =~ /a completely severed|a fractured and bleeding/ }

      return deader_injuries unless Script.current.vars[2] =~ /full/

      # Non-bleeding injuries
      deader_injuries.push('major organ wound') if appraisal_line.any? { |l| l =~ /a (blinded|swollen) (right|left) eye/ }
      deader_injuries.push('major nerve wound') if appraisal_line.any? { |l| l =~ /a case of (uncontrollable|sporadic) convulsions/ }
      deader_injuries.push('minor head wound') if appraisal_line.any? { |l| l =~ /minor bruises about the head|minor bruises on (?:his|her) neck/ }
      deader_injuries.push('minor organ wound') if appraisal_line.any? { |l| l =~ /minor cuts and bruises on (?:his|her) (chest|abdomen|back)|a bruised (right|left) eye/ }
      deader_injuries.push('minor limb wound') if appraisal_line.any? { |l| l =~ /some minor cuts and bruises on (?:his|her) (right|left)/ }
      deader_injuries.push('minor nerve wound') if appraisal_line.any? { |l| l =~ /a strange case of muscle twitching/ }
      return deader_injuries unless deader_injuries.empty?

      # Scars - Major
      deader_injuries.push('major head scar') if appraisal_line.any? { |l| l =~ /several facial scars|old mutilation wounds about (?:his|her) head|some old neck wounds|terrible scars from some serious neck injury/ }
      deader_injuries.push('major nerve scar') if appraisal_line.any? { |l| l =~ /constant muscle spasms|a very difficult time with muscle control/ }
      deader_injuries.push('major organ scar') if appraisal_line.any? { |l| l =~ /several painful-looking scars across|terrible, permanent mutilation of|severe bruises and swelling around/ }
      deader_injuries.push('missing eye') if appraisal_line.any? { |l| l =~ /a missing (right|left) eye/ }
      deader_injuries.push('major limb scar') if appraisal_line.any? { |l| l =~ /a mangled (right|left) (leg|arm|hand)/ }
      deader_injuries.push('severed limb') if appraisal_line.any? { |l| l =~ /a missing (right|left) (leg|arm|hand)/ }

      # Scars - Minor
      deader_injuries.push('minor head scar') if appraisal_line.any? { |l| l =~ /a scar across (?:his|her) (face|neck)/ }
      deader_injuries.push('minor nerve scar') if appraisal_line.any? { |l| l =~ /developed slurred speech/ }
      deader_injuries.push('minor organ scar') if appraisal_line.any? { |l| l =~ /an old battle scar across (?:his|her) (chest|abdominal area|back)|a black-and-blue (right|left) eye/ }
      deader_injuries.push('minor limb scar') if appraisal_line.any? { |l| l =~ /old battle scars on (?:his|her) (right|left) (leg|arm|hand)/ }

      return deader_injuries
    end

    def self.deader(character)
      return unless character.status =~ /dead/i

      if EHerbs.data[:herb_sack].nil?
        EHerbs.data[:herb_sack] = Utility.find_herbsack
      end

      empty_right_hand

      no_herb = false
      loop do
        appraisal_line = Utility.get_lines("appraise #{character}", /Usage|^\s*You take a quick appraisal|^You also notice that|^You glance at/)

        if appraisal_line.any? { |l| l =~ /Appraise what|Usage/ }
          respond " #{Script.current.vars[1]} not found"
          break
        end

        deader_injuries = Actions.appraise_character(appraisal_line)

        if deader_injuries.empty?
          respond " #{character}: Healdown finished. Exiting..."
          break
        end

        deader_injuries.each do |herb_type|
          herb = nil
          if EHerbs.known_herbs.any? { |h| h[:type] == herb_type && (h[:name] == GameObj.right_hand.name || (h[:short_name] && h[:short_name] == GameObj.right_hand.name)) && h[:name] =~ EHerbs.data[:drinkable] }
            herb = GameObj.right_hand
          elsif EHerbs.known_herbs.any? { |h| h[:type] == herb_type && (h[:name] == GameObj.left_hand.name || (h[:short_name] && h[:short_name] == GameObj.left_hand.name)) && h[:name] =~ EHerbs.data[:drinkable] }
            herb = GameObj.left_hand
          else
            Inventory.stow_herb
            contents = Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])

            herb = contents[:drinkable].find { |i| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) && h[:type] == herb_type } }

            unless herb.nil?
              EHerbs.data[:used_herbs].push(herb.id) unless EHerbs.data[:used_herbs].include?(herb.id)
              get_result = dothistimeout "get ##{herb.id}", 5, EHerbs.data[:get_regex]
              if get_result.nil? || (get_result =~ /^Get what\?/)
                echo "error: timeout while trying to get herb (#{herb.name}, #{herb.id})"
                dothistimeout "close ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:close_regex] if EHerbs.data[:close_herbsack]
                exit
              elsif get_result =~ /^You need a free hand for that\./
                echo 'fixme no freehand in self.deader(character)'
                dothistimeout "close ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:close_regex] if EHerbs.data[:close_herbsack]
                exit
              end
            end
          end

          unless herb.nil?
            item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun == herb.noun }
            dothistimeout "pour ##{item.id} in #{character}", 2, /you pour|and pour in a small amount/ unless item.nil?
          end

          if herb.nil?
            no_herb = true
          end
        end

        if no_herb
          respond " Missing a needed potion to finish healing. Exiting..."
          break
        end
      end

      Inventory.stow_herb
      fill_right_hand
    end

    def self.escort
      if Script.current.vars[2]
        unless (escort = GameObj.npcs.find { |npc| (npc.id == Script.current.vars[2]) || (npc.noun == Script.current.vars[2]) })
          echo "Failed to find an npc with id or noun #{Script.current.vars[2]}."
          exit
        end
      else
        unless (escort = GameObj.npcs.find { |npc| npc.type =~ /escort/ })
          echo 'Failed to find an escort.'
          exit
        end
      end
      EHerbs.data[:herb_sack] = Utility.find_herbsack if EHerbs.data[:herb_sack].nil?
      Inventory.open_single_container(EHerbs.data[:herb_sack])
      look_result = dothistimeout "look ##{escort.id}", 10, /^(?:She|He) appears to be in good shape\.|^(?:She|He) has|^I could not find what you were referring to\./
      if look_result.nil?
        echo "error: timeout while trying to look at escort (#{escort.name}, #{escort.id})"
      elsif look_result =~ /^I could not find what you were referring to\./
        echo "error: can't see escort"
      elsif look_result =~ /^(?:She|He) appears to be in good shape\./
        echo 'nothing to do'
      elsif look_result =~ /^(?:She|He) has/
        injury_patterns = {
          /severe head trauma and bleeding from the ears/                        => ['major head wound', 'major head wound', 'minor head wound'],
          /minor lacerations about the head and a possible mild concussion/      => ['major head wound', 'minor head wound'],
          /snapped bones and serious bleeding from the neck/                     => ['major head wound', 'major head wound', 'minor head wound'],
          /moderate bleeding from (?:his|her) neck/                              => ['major head wound', 'minor head wound'],
          /deep gashes and serious bleeding from (?:his|her) chest/              => ['major organ wound', 'major organ wound', 'minor organ wound'],
          /deep lacerations across (?:his|her) chest/                            => ['major organ wound', 'minor organ wound'],
          /deep gashes and serious bleeding from (?:his|her) abdomen/            => ['major organ wound', 'major organ wound', 'minor organ wound'],
          /deep lacerations across (?:his|her) abdomen/                          => ['major organ wound', 'minor organ wound'],
          /deep gashes and serious bleeding from (?:his|her) back/               => ['major organ wound', 'major organ wound', 'minor organ wound'],
          /deep lacerations across (?:his|her) back/                             => ['major organ wound', 'minor organ wound'],
          /a blinded (right|left) eye/                                           => ['major organ wound', 'major organ wound', 'minor organ wound'],
          /a swollen (right|left) eye/                                           => ['major organ wound', 'minor organ wound'],
          /a completely severed (right|left) leg|arm|hand/                       => ['major limb wound', 'major limb wound', 'minor limb wound'],
          /a fractured and bleeding (right|left) leg|arm|hand/                   => ['major limb wound', 'minor limb wound'],
          /a case of uncontrollable convulsions|a case of sporadic convulsions/  => ['major nerve wound', 'minor nerve wound'],
          /minor bruises about the head/                                         => ['minor head wound'],
          /minor bruises on (?:his|her) neck/                                    => ['minor head wound'],
          /minor cuts and bruises on (?:his|her) chest/                          => ['minor organ wound'],
          /minor cuts and bruises on (?:his|her) abdomen/                        => ['minor organ wound'],
          /minor cuts and bruises on (?:his|her) back/                           => ['minor organ wound'],
          /a bruised (right|left) eye/                                           => ['minor organ wound'],
          /some minor cuts and bruises on (?:his|her) (right|left) leg|arm|hand/ => ['minor limb wound'],
          /a strange case of muscle twitching/                                   => ['minor nerve wound']
        }

        escort_injuries = []
        injury_patterns.each do |pattern, injuries|
          if look_result =~ pattern
            escort_injuries.concat(injuries)
          end
        end

        empty_right_hand

        escort_injuries.each do |herb_type|
          herb = nil
          if EHerbs.known_herbs.any? { |h| h[:type] == herb_type && (h[:name] == GameObj.right_hand.name || (h[:short_name] && h[:short_name] == GameObj.right_hand.name)) }
            herb = GameObj.right_hand
          elsif EHerbs.known_herbs.any? { |h| h[:type] == herb_type && (h[:name] == GameObj.left_hand.name || (h[:short_name] && h[:short_name] == GameObj.left_hand.name)) }
            herb = GameObj.left_hand
          else
            Inventory.stow_herb
            contents = Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])

            if (herb = contents[:all].find { |i| EHerbs.known_herbs.find { |h| (h[:name] == i.name) && h[:type] == herb_type } })
              EHerbs.data[:used_herbs].push(herb.id) unless EHerbs.data[:used_herbs].include?(herb.id)
              get_result = dothistimeout "get ##{herb.id}", 5, EHerbs.data[:get_regex]
              if get_result.nil? || (get_result =~ /^Get what\?/)
                echo "error: timeout while trying to get herb (#{herb.name}, #{herb.id})"
                dothistimeout "close ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:close_regex] if EHerbs.data[:close_herbsack]
                exit
              elsif get_result =~ /^You need a free hand for that\./
                echo 'fixme no freehand in escort'
                dothistimeout "close ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:close_regex] if EHerbs.data[:close_herbsack]
                exit
              end
            end
          end

          dothistimeout "give ##{escort.id}", 10, /accepts your .* hands it back to you|ignores your offer/ if herb
        end
        Inventory.stow_herb
        fill_right_hand
      end

      dothistimeout "close ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:close_regex] if EHerbs.data[:close_herbsack]

      exit
    end

    def self.fill_herbs
      # 5-7 doses: There is a good bit left in the rose-marrow potion.
      # 3-4 doses: There is a small amount in the rose-marrow potion.
      # 1-2 doses: There is just a little left in the rose-marrow potion.
      did_something = false
      Utility.assert_herbsack_var
      EHerbs.data[:herb_sack] = Utility.find_herbsack if EHerbs.data[:herb_sack].nil?

      Inventory.open_single_container(EHerbs.data[:herb_sack])

      while (item = [GameObj.right_hand, GameObj.left_hand].find { |obj| EHerbs.known_herbs.any? { |herb| (herb[:name] =~ /#{obj.name}/ || herb[:short_name] =~ /#{obj.name}/) } })
        Utility.store_herb(item)
      end

      contents = Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])

      herb_type_fill = []
      types = ['blood', 'major head wound', 'minor head wound', 'major head scar', 'minor head scar', 'major organ wound', 'minor organ wound', 'major organ scar', 'minor organ scar', 'missing eye', 'major limb wound', 'minor limb wound', 'major limb scar', 'minor limb scar', 'severed limb', 'major nerve wound', 'minor nerve wound', 'major nerve scar', 'minor nerve scar']
      types.each do |kind|
        herb_type_fill.push(kind) unless contents[:all].any? { |obj| EHerbs.known_herbs.any? { |herb| (herb[:name] =~ /#{obj.name}/ || herb[:short_name] =~ /#{obj.name}/) && herb[:type] == kind } }
      end

      unless herb_type_fill.empty?
        EHerbs.data[:silvers] = Utility.check_silver
        Actions.withdraw unless EHerbs.data[:silvers] > 4000
        Utility.go2('herbalist')

        empty_hands

        herb_type_fill.each do |herb_type|
          Actions.buy_herb(herb_type)
          item = [GameObj.right_hand, GameObj.left_hand].find { |obj| EHerbs.known_herbs.any? { |herb| (herb[:name] =~ /#{obj.name}/ || herb[:short_name] =~ /#{obj.name}/) } }
          Utility.store_herb(item)
          did_something = true
        end

        fput "close ##{EHerbs.data[:herb_sack].id}" if EHerbs.data[:close_herbsack]
        Actions.deposit
        Utility.go2(EHerbs.data[:start_room].id.to_s) if Room.current.id != EHerbs.data[:start_room].id

        fill_hands
      end

      _respond
      _respond Msg.monsterbold("#{did_something ? 'Done' : 'Nothing to do'} - you have one of each herb available at this location.")
      _respond
      exit
    end

    def self.stock_herbs
      both = false
      Utility.assert_herbsack_var
      script_var2 = Script.current.vars[2].downcase

      EHerbs.data[:herb_sack] = Utility.find_herbsack if EHerbs.data[:herb_sack].nil?

      if Room.current.location =~ /Icemule Trace|the Pinefar Trading Post|the town of Kharam-Dzu|Ta'Illistim|Cysaegir|the hamlet of Ravelin|Zul Logoth/ && !EHerbs.data[:survival_kit]
        _respond
        _respond Msg.monsterbold(' This location only uses drinkable or non-bundling herbs, so bundling does not work.')
        _respond Msg.monsterbold(' You should use the ') + "#{$clean_lich_char}#{Script.current.name} fill" + Msg.monsterbold(' feature for this location.')
        _respond
        exit
      end

      Inventory.open_single_container(EHerbs.data[:herb_sack])
      if script_var2.nil? || (script_var2 =~ /potions|herbs|major|minor|missing|severed|blood|combined/)
        # The distinction of only edible herbs for certain wounds was lost with Teras.
        # This prevented the script from stocking anywhere but a few locations.
        # Now, the script deals in categories rather than specific names, and can stock anywhere.

        herb_type_list = ['blood', 'major head wound', 'minor head scar', 'major organ wound', 'minor organ wound', 'major limb wound', 'minor limb wound', 'major limb scar', 'minor limb scar', 'severed limb', 'minor nerve wound', 'major nerve scar', 'minor nerve scar']
        potion_type_list = ['major head scar', 'minor head wound', 'major nerve wound', 'minor organ scar', 'major organ scar', 'missing eye']
        if script_var2 == 'potions'
          seek_type_list = potion_type_list
        elsif script_var2 == 'herbs'
          seek_type_list = herb_type_list
        elsif Script.current.vars[0].downcase =~ /major|minor|missing|severed|blood/
          Script.current.vars.delete_if { |var| var =~ /^stock$/i }
          Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
          seek_type_list = [Script.current.vars[0]]
        elsif script_var2 == 'combined'
          seek_type_list = potion_type_list + herb_type_list
        else
          seek_type_list = potion_type_list + herb_type_list
          both = true
        end

        if EHerbs.data[:survival_kit]
          if script_var2 == 'potions' || both
            seek_type_list = potion_type_list + herb_type_list
            Actions.stock_action(seek_type_list, 'drinkable')
          end
          if script_var2 == 'herbs' || both
            seek_type_list = potion_type_list + herb_type_list
            Actions.stock_action(seek_type_list, 'edible')
          end
          if script_var2 == 'combined'
            Actions.stock_action(seek_type_list)
          end
          if script_var2 !~ /herbs|potions|combined/ && !both
            Actions.stock_action(seek_type_list, 'drinkable')
            Actions.stock_action(seek_type_list, 'edible')
          end
        else
          Actions.stock_action(seek_type_list)
        end

        while (item = [GameObj.right_hand, GameObj.left_hand].find { |obj| EHerbs.known_herbs.any? { |herb| (herb[:name] =~ /#{obj.name}/ || herb[:short_name] =~ /#{obj.name}/) } })
          Utility.store_herb(item)
        end

        Actions.deposit
        Utility.go2(EHerbs.data[:start_room].id.to_s)
      end

      _respond
      _respond Msg.monsterbold(' You are fully stocked with herbs at this location.')
      _respond
      exit
    end

    def self.stock_action(seek_type_list, type = nil)
      Inventory.get_current_stock(seek_type_list, type)
      if EHerbs.data[:shopping_list].length.positive?
        Actions.stock_requested_herbs(type)
        return true
      end

      return false
    end

    def self.stock_requested_herbs(type = nil)
      Msg.print_shopping_list(type)
      sleep 2

      shop_prices = Actions.check_prices

      total_cost = 0

      Msg.debug_msg("stock_requested_herbs | EHerbs.data[:shopping_list]: #{EHerbs.data[:shopping_list]} | called by #{caller[0]}")
      EHerbs.data[:shopping_list].each do |data|
        unit_cost = shop_prices[data[:category]][:cost]

        if unit_cost.nil?
          _respond Msg.monsterbold(" Unknown item or no pricing. Please report the following to EO")
          _respond
          _respond "EHerbs.data[:shopping_list]: #{EHerbs.data[:shopping_list]}"
          _respond "shop_prices: #{shop_prices}"
          exit
        else
          total_cost += unit_cost * data[:needed]
        end
      end
      total_cost += total_cost * 0.1

      Actions.withdraw_note(total_cost)
      Utility.go2('herbalist')
      current_location = Room.current.location
      empty_hands
      Actions.bundle_all
      Inventory.drag_to_hand(EHerbs.data[:note]) unless EHerbs.data[:note].nil?

      EHerbs.data[:shopping_list].each do |thing|
        herb_type = case type
                    when 'drinkable'
                      EHerbs.known_herbs.find { |h| h[:type] == thing[:category] && h[:name] =~ EHerbs.data[:drinkable] && h[:location].any? { |place| place =~ /#{current_location}/ } }[:type]
                    when 'edible'
                      EHerbs.known_herbs.find { |h| h[:type] == thing[:category] && h[:name] !~ EHerbs.data[:drinkable] && h[:location].any? { |place| place =~ /#{current_location}/ } }[:type]
                    else
                      EHerbs.known_herbs.find { |h| h[:type] == thing[:category] && h[:location].any? { |place| place =~ /#{current_location}/ } }[:type]
                    end

        if herb_type.nil?
          _respond Msg.monsterbold(" Error in determining herb_type: type: #{type} | thing: #{thing}")
          _respond Msg.monsterbold(" Shopping List: #{EHerbs.data[:shopping_list]}")
          _respond Msg.monsterbold(" Please report this to EO")
          exit
        end

        item = nil
        numer_of_buys = (thing[:needed] / 10).to_i
        partial_buys = (thing[:needed] % 10).to_i

        numer_of_buys.times do
          Actions.buy_herb(herb_type, 10)
          item = Actions.stock_storage
        end

        if partial_buys.positive?
          Actions.buy_herb(herb_type, partial_buys)
          item = Actions.stock_storage
        end

        if thing[:needed] > 1 && !EHerbs.data[:survival_kit]
          Inventory.drag_to_container(EHerbs.data[:note].id, EHerbs.data[:herb_sack].id) unless EHerbs.data[:note].nil?
          Actions.bundle_all(item.name)
          Inventory.drag_to_hand(EHerbs.data[:note]) unless EHerbs.data[:note].nil?
        end
      end

      Inventory.drag_to_container(EHerbs.data[:note].id, EHerbs.data[:herb_sack].id) unless EHerbs.data[:note].nil?

      item = [GameObj.right_hand, GameObj.left_hand].find { |obj| EHerbs.known_herbs.any? { |herb| (herb[:name] =~ /#{obj.name}/ || herb[:short_name] =~ /#{obj.name}/) } }
      Utility.store_herb(item) if item

      Actions.bundle_all
      Actions.deposit_note

      fill_hands
    end

    def self.stock_storage
      if (item = [GameObj.right_hand, GameObj.left_hand].find { |obj| EHerbs.known_herbs.any? { |herb| (herb[:name] =~ /#{obj.name}/ || herb[:short_name] =~ /#{obj.name}/) } })
        Utility.store_herb(item)
      elsif (item = [GameObj.right_hand, GameObj.left_hand].find { |i| i.name =~ /package/ })
        Utility.get_res("open ##{item.id}", /^You open|^That is already open/)
        item_contents = item.contents
        Utility.get_res("empty ##{item.id} in ##{EHerbs.data[:herb_sack].id}", /everything falls in/)
        Utility.wait_rt
        Utility.get_res("throw ##{item.id}", /^You throw away/)
        item = item_contents[0]
      end

      return item
    end

    def self.find_herb(contents, herb_type)
      known_herbs = EHerbs.known_herbs

      # Find yabathilium if the type is 'blood' and use_yaba is enabled
      if herb_type == 'blood' && EHerbs.data[:use_yaba]
        yaba = contents[:all].find { |i| i.name =~ /yabathilium/ }
        return yaba if yaba
      end

      # Find an edible herb of the specified type
      unless EHerbs.data[:use_potions]
        herb = contents[:edible].find { |i| known_herbs.any? { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) && h[:type] == herb_type } }
        return herb if herb
      end

      # Find a drinkable herb of the specified type
      if EHerbs.data[:use_potions]
        herb = contents[:drinkable].find { |i| known_herbs.any? { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) && h[:type] == herb_type } }
        return herb if herb
      end

      # Find any herb of the specified type
      contents[:all].find { |i| known_herbs.any? { |h| (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/) && h[:type] == herb_type } }
    end

    def self.track_missing(herb_type)
      case herb_type
      when /head/
        EHerbs.data[:skippable].push 'head'
        EHerbs.data[:skippable].push 'neck'
      when /organ|missing eye/
        EHerbs.data[:skippable].push 'torso'
      when /limb/
        EHerbs.data[:skippable].push 'limbs'
      when /nerve/
        EHerbs.data[:skippable].push 'nerves'
      when 'blood'
        EHerbs.data[:skippable].push 'blood'
      else
        EHerbs.data[:skippable].push herb_type
      end
      respond "\nMissing herb for #{herb_type}.\n\n   #{EHerbs.known_herbs.find_all { |h| h[:type] == herb_type }.collect { |h| h[:name] }.join(', ')}\n\n"
    end

    def self.use_herbs
      drinkable = false
      herb = nil
      if EHerbs.data[:herb_sack].nil?
        EHerbs.data[:herb_sack] = Utility.find_herbsack
      end

      while (herb_type = EHerbs.data[:blood_only] ? 'blood' : Utility.next_herb_type)
        break if (Char.health + 7) >= Char.max_health && EHerbs.data[:blood_only]
        herb = [GameObj.right_hand, GameObj.left_hand].find do |i|
          EHerbs.known_herbs.any? do |h|
            h[:type] == herb_type && (h[:name] =~ /#{i.name}/ || h[:short_name] =~ /#{i.name}/)
          end
        end

        if [Wounds.leftArm, Wounds.rightArm].min < 3 && herb.nil?
          Utility.go2(EHerbs.data[:start_room].id.to_s) if EHerbs.data[:return_to_stow]
          contents = Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])
          herb = Actions.find_herb(contents, herb_type)

          if herb
            Inventory.stow_herb
            unless EHerbs.data[:no_get] && (herb.name !~ EHerbs.data[:drinkable])
              drinkable = Inventory.drag_to_hand(herb)
            end
          end
        end

        if EHerbs.data[:buy_missing] && herb.nil? && !EHerbs.data[:blood_only] && herb_type !~ /poison|disease/
          Inventory.stow_herb
          EHerbs.data[:silvers] = Utility.check_silver unless EHerbs.data[:silvers]
          Actions.withdraw unless EHerbs.data[:silvers] > 4000
          Utility.go2('herbalist')
          Actions.buy_herb(herb_type)

          herb = [GameObj.right_hand, GameObj.left_hand].find { |i| EHerbs.known_herbs.any? { |info| info[:name] =~ /#{i.name}/ } }

          if herb.nil?
            _respond Msg.monsterbold(" Not able to find #{herb_type} in #{Room[Room.current.find_nearest_by_tag("town")].location}")
            _respond Msg.monsterbold(" Report this to EO on the scripting Discord")
            exit
          end

          drinkable = herb.name =~ EHerbs.data[:drinkable] ? true : false
        end

        if herb
          Actions.cast_spells
          EHerbs.data[:used_herbs].push(herb.id) unless EHerbs.data[:used_herbs].include?(herb.id)

          if EHerbs.data[:no_get]
            use_cmd = "eat #{herb.noun}"
          else
            use_cmd = (herb.name =~ EHerbs.data[:drinkable] || drinkable) ? "drink my #{herb.noun}" : "eat my #{herb.noun}"
          end

          use_result = Utility.get_res(use_cmd, /^You (?:manage to )?take a (?:bite|drink)|You must pick the|Why don't you leave some for others|Using your/)
          Utility.wait_rt
          if use_result =~ /You must pick the/
            _respond Msg.monsterbold(' You have --no-get flagged but are required to pick up the herb.')
            exit
          elsif use_result =~ /Why don't you leave some for others?/
            _respond Msg.monsterbold(" You have eaten enough from the #{EHerbs.data[:herb_sack]}.")
            exit
          elsif use_result.nil?
            echo ' No result for eating herbs'
            exit
          end
        else
          Actions.track_missing(herb_type)
        end
      end
    end

    def self.withdraw_note(amount)
      original_room = Room.current.id
      Utility.check_cutthroat

      Utility.go2('bank')

      # Can't get a note from Pinefar
      if XMLData.room_title == '[Pinefar, Depository]'
        Actions.withdraw if Utility.check_silver < EHerbs.data[:withdraw_amount]
        EHerbs.data[:need_deposit] = true if EHerbs.data[:deposit_coins]
        Utility.go2(original_room)
        return
      end

      empty_hand
      result = dothistimeout "withdraw #{amount.to_i} note", 5, /^The teller (?:carefully|hands you|makes|taps her quill|purses her lips)|Very well|seem to have that much/

      if result =~ /seem to have that much/
        _respond Msg.monsterbold('error', "** Insufficient funds! Exiting **")
        exit
      end

      20.times {
        break if [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:note|scrip|chit)$/ }
        sleep 0.1
      }

      EHerbs.data[:note] = [GameObj.right_hand, GameObj.left_hand].find { |i| i.noun =~ /^(?:note|scrip|chit)$/ }

      Inventory.drag_to_container(EHerbs.data[:note].id, EHerbs.data[:herb_sack].id)
      fill_hand
      Utility.go2(original_room)
    end

    def self.withdraw
      original_room = Room.current.id
      Utility.check_cutthroat
      Utility.go2('bank')
      fput 'unhide' if invisible?
      if XMLData.room_title == '[Pinefar, Depository]'
        if GameObj.npcs.any? { |npc| npc.noun == 'banker' }
          result = dothistimeout "ask banker for #{[EHerbs.data[:withdraw_amount].to_i, 20].max} silvers", 1, /suspicious/
          if result =~ /suspicious/
            _respond
            _respond Msg.monsterbold('You have no coins in the bank, moving back to starting point')
            _respond
            sleep 2
            Utility.go2(EHerbs.data[:start_room].id.to_s)

            exit
          end
        # The banker nods and says, "Alright, here ye go.  Ye understand I be takin' a little more than that from ye account in the 'Mule.  I don't works for free!"
        # The banker looks at you suspiciously and says, "Hmm, I don't think ye be havin' enough in ye account to cover that and my fee.  Ye tryin' to pull one over on me?"
        elsif (icemule_bank = Room.list.find { |room| room.location == 'Icemule Trace' && room.tags.include?('bank') })
          Utility.go2(icemule_bank.id.to_s)
          result = dothistimeout "withdraw #{EHerbs.data[:withdraw_amount]} silvers", 1, /debt collector|suspicious/
          case result
          when /debt collector/
            fput "withdraw #{EHerbs.data[:withdraw_amount]} silvers"
          when /suspicious/
            _respond
            _respond Msg.monsterbold('You have no coins in the bank, moving back to starting point')
            _respond
            sleep 2
            Utility.go2(EHerbs.data[:start_room].id.to_s)
            exit
          end
        else
          echo 'waiting for banker...'
          wait_until { GameObj.npcs.any? { |npc| npc.noun == 'banker' } }
          fput "ask banker for #{[EHerbs.data[:withdraw_amount].to_i, 20].max} silvers"
        end
      else
        result = dothistimeout "withdraw #{EHerbs.data[:withdraw_amount]} silvers", 1, /debt collector|suspicious|chuckles at you/
        case result
        when /debt collector/
          fput "withdraw #{EHerbs.data[:withdraw_amount]} silvers"
        when /suspicious|chuckles at you/
          _respond
          _respond Msg.monsterbold('You have no coins in the bank, moving back to starting point')
          _respond
          sleep 2
          Utility.go2(EHerbs.data[:start_room].id.to_s)
          exit
        end
      end
      EHerbs.data[:silvers] += EHerbs.data[:withdraw_amount]
      EHerbs.data[:need_deposit] = true if EHerbs.data[:deposit_coins]
      Utility.go2(original_room)
    end
  end

  module Inventory
    def self.drag_to_container(item_id, container_id, preposition = nil)
      preposition = 'in' if preposition.to_s.empty?
      Utility.get_res("put ##{item_id} #{preposition} ##{container_id}", EHerbs.data[:put_regex])
    end

    def self.drag_to_hand(herb)
      # Check hands - make sure there is an empty one
      Inventory.free_hand

      to = GameObj.right_hand.id.nil? ? 'right' : 'left'

      result = Utility.get_res("_drag ##{herb.id} #{to}", EHerbs.data[:get_regex])

      if result =~ EHerbs.data[:drinkable]
        return true
      elsif result =~ /Why don't you leave some for others?/
        _respond Msg.monsterbold(" You have eaten enought from the #{EHerbs.data[:herb_sack]}.")
        exit
      end
    end

    def self.free_hand
      unless (GameObj.right_hand.id.nil? && [Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max < 3) || (GameObj.left_hand.id.nil? && [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max < 3)
        if GameObj.right_hand.id && ([Wounds.rightArm, Wounds.rightHand, Scars.rightArm, Scars.rightHand].max < 3 || [Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max == 3)
          waitrt?
          Inventory.free_hands(right: true)
        else
          waitrt?
          Inventory.free_hands(left: true)
        end
      end
    end

    def self.free_hands(right: false, left: false, both: false)
      if (right || both) && checkright
        fput "stow #{GameObj.right_hand}"
      end

      if (left || both) && checkleft
        fput "stow #{GameObj.left_hand}"
      end
    end

    def self.get_current_stock(seek_type_list, type = nil)
      Msg.debug_msg("get_current_stock | seek_type_list: #{seek_type_list} | called by #{caller[0]}")
      EHerbs.data[:shopping_list] = []
      current_location = Room[Room.current.find_nearest_by_tag('town')].location

      if EHerbs.data[:survival_kit]
        $eherbs_measure ||= {}
        result = Utility.get_lines("look in ##{EHerbs.data[:herb_sack].id}", %r{In .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a|There is nothing}).join(' ')
        edible_result_contents = Regexp.last_match(5) if result =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains DOSEs (.*?)\.}
        liquid_result_contents = Regexp.last_match(5) if result =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains TINCTUREs (.*?)\.}

        result_contents = case type
                          when 'drinkable'
                            liquid_result_contents.to_s
                          when 'edible'
                            edible_result_contents.to_s
                          else
                            liquid_result_contents.to_s + edible_result_contents.to_s
                          end

        result_contents.scan(%r{(:?) <a exist="(.*?)" noun="(.*?)">(.*?)</a> \((.*?)\)}).each do |_, exist, _noun, _name, count|
          $eherbs_measure[exist] = count.to_i
        end
      end

      type = nil unless EHerbs.data[:survival_kit]
      EHerbs.data[:herb_sack].contents.each do |obj|
        next unless EHerbs.known_herbs.any? { |h| seek_type_list.include?(h[:type]) && (h[:name] == obj.name || h[:short_name] == obj.name) }
        next if $eherbs_measure[obj.id.to_s]
        dothistimeout "get ##{obj.id}", 10, EHerbs.data[:get_regex]
        dothistimeout "measure ##{obj.id}", 10, /^The .*? left/
        dothistimeout "put ##{obj.id} in ##{EHerbs.data[:herb_sack].id}", 10, EHerbs.data[:put_regex]
      end

      contents = Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])
      Msg.debug_msg("get_current_stock | contents: #{contents} | called by #{caller[0]}")

      seek_type_list.each do |bippity|
        # Check if the type of herb we want is available.
        herb_type = case type
                    when 'drinkable'
                      EHerbs.known_herbs.find { |h| h[:type] == bippity && h[:name] =~ EHerbs.data[:drinkable] && h[:location].any? { |place| place =~ /#{current_location}/ } }
                    when 'edible'
                      EHerbs.known_herbs.find { |h| h[:type] == bippity && h[:name] !~ EHerbs.data[:drinkable] && h[:location].any? { |place| place =~ /#{current_location}/ } }
                    else
                      EHerbs.known_herbs.find { |h| h[:type] == bippity && h[:location].any? { |place| place =~ /#{current_location}/ } }
                    end

        next if herb_type.to_s.empty?

        last_total_doses = -1

        herb_list_items = case type
                          when 'drinkable'
                            contents[:drinkable].find_all { |obj| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{obj.name}/ || h[:short_name] =~ /#{obj.name}/ || h[:short_name].include?(obj.name.sub('elixir', ''))) && h[:type] == bippity && h[:name] =~ EHerbs.data[:drinkable] } }
                          when 'edible'
                            contents[:edible].find_all { |obj| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{obj.name}/ || h[:short_name] =~ /#{obj.name}/ || h[:short_name].include?(obj.name.sub('elixir', ''))) && h[:type] == bippity && h[:name] !~ EHerbs.data[:drinkable] } }
                          else
                            contents[:all].find_all { |obj| EHerbs.known_herbs.find { |h| (h[:name] =~ /#{obj.name}/ || h[:short_name] =~ /#{obj.name}/ || h[:short_name].include?(obj.name.sub('elixir', ''))) && h[:type] == bippity } }
                          end

        total_doses = 0

        herb_list_items.each { |h| total_doses += $eherbs_measure[h.id].to_i }

        next unless total_doses < EHerbs.data[:min_stock_doses][bippity].to_i
        next unless total_doses > last_total_doses

        # let's try to get the current location and fill in the missing herb info
        # if we can't get the current location, we'll cheat a bit with a generic entry
        if herb_list_items.empty?
          details = EHerbs.known_herbs.find { |h| h[:type] == bippity && h[:location].any? { |place| place =~ /#{current_location}/ } }

          if details.nil?
            EHerbs.data[:shopping_list].push(category: bippity, herb_name: 'any', herb_list: ['missing'], needed: 2)
          else
            EHerbs.data[:shopping_list].push(category: bippity, herb_name: details[:short_name], herb_list: [''], needed: ((EHerbs.data[:min_stock_doses][bippity] - total_doses) / details[:store_doses]))
          end
        else
          herb_list_items.each { |h| @herb_name = h.name || @herb_name = h.short.name }
          details = EHerbs.known_herbs.find { |h| h[:type] == bippity && h[:location].any? { |place| place =~ /#{current_location}/ } }
          EHerbs.data[:shopping_list].push(category: bippity, herb_name: details[:short_name], herb_list: herb_list_items, needed: ((EHerbs.data[:min_stock_doses][bippity] - total_doses) / details[:store_doses])) if ((EHerbs.data[:min_stock_doses][bippity] - total_doses) / details[:store_doses]) >= 1
        end
      end
    end

    def self.herb_container_contents_load(container = nil)
      contents = nil
      under_contents = behind_contents = on_contents = in_contents = nil

      # If passed a string check if its part of the inventory
      if container.instance_of?(String)
        str_container = container
        container = GameObj.inv.find { |obj| obj.name =~ /\b#{container}\b/ }
        container = container.nil? ? str_container : container
      end

      # If it's a GameObj
      if container.instance_of?(GameObj) && GameObj.inv.find { |obj| obj.id =~ /#{container.id}/ }
        EHerbs.data[:herb_sack] = container
        Inventory.open_single_container(container)
        Utility.determine_survival_kit(container) if EHerbs.data[:survival_kit].nil?

        if EHerbs.data[:survival_kit]
          return Inventory.survival_contents(container)
        else
          contents = EHerbs.data[:herb_sack].contents
        end
      else

        # If still here then the container is still a string - lets find it
        EHerbs.data[:herb_sack] = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.name =~ /#{container}/ }

        if EHerbs.data[:herb_sack].nil?
          _respond Msg.monsterbold(" Not able to find a #{container}. Exiting...")
          exit
        end

        unless EHerbs.data[:herb_sack].instance_of?(GameObj)
          (GameObj.room_desc.to_a + GameObj.loot.to_a).each { |thing|
            ["in", "on", "under", "behind"].each { |preposition|
              result = Utility.get_lines("look #{preposition} #{thing}", %r{<container|There is nothing|In|On|Under|Behind}).join(' ')
              matches = result.scan(/.*?exist="(-?\d+)" noun="(.*?)">(.*?)<\/a>/)
              matches.each do |match|
                if match[1] =~ /#{container}/ || match[2] =~ /#{container}/
                  EHerbs.data[:herb_sack] = GameObj.new(match[0], match[1], match[2])
                  break
                end
              end
              break if EHerbs.data[:herb_sack]
            }
            break if EHerbs.data[:herb_sack]
          }
        end

        EHerbs.data[:preposition] = EHerbs.data[:preposition].nil? ? 'in' : EHerbs.data[:preposition]

        loop do
          result = Utility.get_lines("look #{EHerbs.data[:preposition]} ##{EHerbs.data[:herb_sack].id}", %r{(In|On|Under|Behind) .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a|There is nothing}).join(' ')

          case result
          when %r{Under .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a>(?::| you see )(.*?)$}
            under_contents = Regexp.last_match(4)
            break
          when %r{Behind .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a>(?::| you see )(.*?)$}
            behind_contents = Regexp.last_match(4)
            break
          when %r{On .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a>(?::| you see )(.*?)$}
            on_contents = Regexp.last_match(4)
            break
          when %r{In .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a>(?::| you see )(.*?)$}
            in_contents = Regexp.last_match(4)
            break
          when %r{That is closed.}
            unless EHerbs.data[:preposition] == 'in'
              break
            end

            result = Inventory.open_single_container(EHerbs.data[:herb_sack])
            if result == 'locked'
              _respond Msg.monsterbold(" Not able to look in #{container}. It's locked. Exiting...")
              exit
            end
          else
            break
          end
        end

        case EHerbs.data[:preposition]
        when 'under'
          result_contents = under_contents
        when 'behind'
          result_contents = behind_contents
        when 'on'
          result_contents = on_contents
        when 'in'
          result_contents = in_contents
        end

        contents = []
        result_contents.scan(%r{<a exist="(.*?)" noun="(.*?)">(.*?)</a>}).each do |exist, noun, name|
          contents.push(GameObj.new_inv(exist, noun, name, EHerbs.data[:herb_sack].id.to_s))
        end

        contents = contents.dup.reject do |obj|
          found_herb = EHerbs.known_herbs.find { |herb| herb[:name] =~ /#{obj.name}/ }
          next true unless found_herb
        end
      end

      # Now that we have the contensts lets seperate by edible/drinkable
      items = {
        drinkable: [],
        edible: [],
        all: []
      }

      contents.each do |h|
        next unless h.type == 'herb'
        if h.name =~ EHerbs.data[:drinkable]
          items[:drinkable].push(h)
        else
          items[:edible].push(h)
        end
        items[:all].push(h)
      end

      return items
    end

    def self.open_single_container(sack)
      return if sack.nil? || sack.empty?

      # If its in the game obj and contents.is_a?(Array) return
      return if GameObj.containers.keys.include?(sack.id) && sack.contents.is_a?(Array)

      # Still here? Assume the sack is closed and open it
      result = Utility.get_lines("open ##{sack.id}", EHerbs.data[:open_regex])

      EHerbs.data[:close_herbsack] = true if result.grep(EHerbs.data[:needs_closed]).any?

      return 'locked' if result.grep(/It appears to be locked./).any?

      # check out whats inside
      lines = Utility.get_lines("look in ##{sack.id}", EHerbs.data[:look_regex])
      return if lines.grep(/You glance|There is nothing/i).any?

      20.times do
        break if GameObj.containers.keys.include?(sack.id) && sack.contents.is_a?(Array)

        sleep 0.1
      end
    end

    def self.stow_herb
      relook = false
      Utility.go2(EHerbs.data[:start_room].id.to_s) if EHerbs.data[:return_to_stow]

      if EHerbs.data[:used_herbs].include?(GameObj.right_hand.id)
        Inventory.drag_to_container(GameObj.right_hand.id, EHerbs.data[:herb_sack].id, EHerbs.data[:preposition])
        fput('stow right') if checkright
        relook = true
      end
      if EHerbs.data[:used_herbs].include?(GameObj.left_hand.id)
        Inventory.drag_to_container(GameObj.left_hand.id, EHerbs.data[:herb_sack].id, EHerbs.data[:preposition])
        fput('stow left') if checkleft
        relook = true
      end
      # Fixme: stow_herbs is odd
      Inventory.herb_container_contents_load(EHerbs.data[:herb_sack]) if %w[under behind].include?(EHerbs.data[:preposition]) && relook == true
    end

    def self.survival_contents(container)
      result = Utility.get_lines("look in ##{container.id}", %r{(In|On|Under|Behind) .*?exist="(-?\d+)" noun="(.*?)">(.*?)</a|There is nothing}).join(' ')

      # Initialize the contents hash with drinkable and edible arrays
      contents = {
        drinkable: [],
        edible: [],
        all: []
      }

      # Extract contents for edible and drinkable items
      if result =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains DOSEs (.*?)\.}
        edible_result_contents = Regexp.last_match(5)
      end

      if result =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains TINCTUREs (.*?)\.}
        liquid_result_contents = Regexp.last_match(5)
      end

      # If edible_result_contents is not nil, parse and add items to the edible array
      if edible_result_contents
        edible_result_contents.scan(%r{(:?) <a exist="(.*?)" noun="(.*?)">(.*?)</a> (\(\d+\))}).each do |_what, exist, noun, name|
          contents[:edible].push(GameObj.new_inv(exist, noun, name, EHerbs.data[:herb_sack].id.to_s))
          contents[:all].push(GameObj.new_inv(exist, noun, name, EHerbs.data[:herb_sack].id.to_s))
        end
      end

      # If liquid_result_contents is not nil, parse and add items to the drinkable array
      if liquid_result_contents
        liquid_result_contents.scan(%r{(:?) <a exist="(.*?)" noun="(.*?)">(.*?)</a> (\(\d+\))}).each do |_what, exist, noun, name|
          contents[:drinkable].push(GameObj.new_inv(exist, noun, name, EHerbs.data[:herb_sack].id.to_s))
          contents[:all].push(GameObj.new_inv(exist, noun, name, EHerbs.data[:herb_sack].id.to_s))
        end
      end

      unless ((herbsack_contents = GameObj[container.id].contents).empty?)
        herbsack_contents.each do |h|
          next unless EHerbs.known_herbs.map { |item| item[:name] }.uniq.include?(h.name)
          if h.name =~ EHerbs.data[:drinkable]
            contents[:drinkable].push(h) unless contents[:drinkable].include?(h)
          else
            contents[:edible].push(h) unless contents[:edible].include?(h)
          end
          contents[:all].push(h) unless contents[:all].include?(h)
        end
      end

      contents
    end
  end

  module Msg
    def self.boldif(condition, text)
      return Msg.format_monsterbold_noescape(text) if condition

      text
    end

    def self.check_herbs_in_container
      Script.current.vars.delete_if { |var| var =~ /^check$|^settings$/i }
      Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
      if EHerbs.data[:preposition].nil? && Script.current.vars.any? { |v| v =~ /^(in|on|behind|under)$/ }
        EHerbs.data[:preposition] = Regexp.last_match(1).downcase
        Script.current.vars.delete_at(1)
        Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
      end

      EHerbs.data[:preposition] ||= 'in'

      container = Script.current.vars[0]
      container = EHerbs.data[:herb_container] if container.nil? && !EHerbs.data[:herb_container].to_s.empty?
      contents = Inventory.herb_container_contents_load(container)

      if contents.nil? || contents.empty?
        _respond Msg.monsterbold(" Nothing found #{EHerbs.data[:preposition]} the #{container}")
        exit
      end

      if container == EHerbs.data[:herb_container]
        need_bundle = false
        contents = Inventory.herb_container_contents_load(container)
        contents[:all].each do |herb|
          next unless herb.type =~ /herb/
          need_bundle = true unless $eherbs_measure.key?(herb.id.to_s)
          $eherbs_measure = {} unless $eherbs_measure.key?(herb.id.to_s)
        end
        Actions.bundle_all if need_bundle
      end

      herb_types = ['poison', 'disease', 'blood', 'minor head wound', 'major head wound', 'minor head scar', 'major head scar', 'minor nerve wound', 'major nerve wound', 'minor nerve scar', 'major nerve scar', 'minor organ wound', 'major organ wound', 'minor organ scar', 'major organ scar', 'missing eye', 'minor limb wound', 'major limb wound', 'minor limb scar', 'major limb scar', 'severed limb']
      EHerbs.known_herbs.each { |h| herb_types << h[:type] unless herb_types.include?(h[:type]) }

      # Fixme
      Inventory.get_current_stock(herb_types, nil) if container == EHerbs.data[:herb_container]

      check_list = {}
      herb_types.each { |t| check_list[t] = {} }
      max_name_length = 0

      # Check for Terminal-table
      have_terminal_table = Utility.check_terminal_table

      contents[:all].each do |obj|
        matching_herb = EHerbs.known_herbs.find { |herb| (herb[:name] =~ /#{obj.name}/) }
        next unless matching_herb

        max_name_length = [max_name_length, matching_herb[:name].length].max

        t = matching_herb[:type]
        check_list[t][:first] ||= obj

        if container == EHerbs.data[:herb_container]
          check_list[t][:amount] = 0
          multiple_herbs = contents[:all].find_all { |herb| herb.name =~ /#{obj.name}/ }
          multiple_herbs.each { |item|
            check_list[t][:amount] += $eherbs_measure[item.id.to_s].to_i
          }
        else
          check_list[t][:amount] = 1
        end
      end

      table_rows = []
      table_title = "Herbs found #{EHerbs.data[:preposition]} #{EHerbs.data[:herb_sack].name}"
      if have_terminal_table
        check_list.each do |type, values|
          table_rows.push([type, (values[:amount].nil? ? '' : (values[:amount] > 9 ? values[:amount] : " #{values[:amount]}")), values[:first].name])
        end

        table = Terminal::Table.new
        table.title = table_title
        table.rows = table_rows
        table.align_column(1, :center)
        table.headings = ['Type', '#', "Herb"]

        table = table.to_s
      else
        # format and output
        max_type_length = herb_types.max_by { |i| i.length || 1 }.length + 2
        total_length = max_type_length + 4 + max_name_length
        max_type_length = total_length >= table_title.length ? max_type_length : max_type_length + (table_title.length - total_length)

        title_format = " | %-#{max_type_length + max_name_length + 7}s |"
        table_format = " | %-#{max_type_length - 2}s | %3s | %-#{max_name_length}s |"
        table_line   = " +#{'-' * max_type_length}+#{'-' * 5}+#{'-' * (max_name_length + 2)}+"

        table_rows << %(<output class="mono" />) unless $frontend =~ /^(?:wizard)$/i

        table_rows << table_line
        table_rows << format(title_format, table_title)
        table_rows << table_line
        table_rows << format(table_format, 'Type', '# ', 'Herb')
        table_rows << table_line
        check_list.each do |type, values|
          table_rows << format(table_format, type, (values[:amount].nil? ? '' : values[:amount]), (values[:first].nil? ? ('' * max_name_length) : values[:first].name))
        end
        table_rows << table_line

        table_rows << %(<output class="" />) unless $frontend =~ /^(?:wizard)$/i

        table = table_rows.join("\n").to_s
      end

      table.gsub!(EHerbs.data[:herb_sack].name, Msg.item_link(EHerbs.data[:herb_sack]))
      check_list.each do |type, values|
        table.gsub!(values[:first].name, Msg.item_link(values[:first])) unless values[:first].nil?
        table.gsub!(type, Msg.boldif(Utility.status_check[type], type))
      end

      _respond
      if $frontend =~ /^(?:stormfront|wrayth|genie)$/i
        _respond "<output class=\"mono\"/>\n" + table.to_s + "\n<output class=\"\"/>"
      else
        _respond table.to_s.split("\n")
      end
      _respond

      exit
    end

    def self.debug_msg(msg)
      return unless EHerbs.data[:debug]
      echo msg
    end

    def self.format_monsterbold(msg)
      monsterbold_start + msg.encode(xml: :text) + monsterbold_end
    end

    def self.format_monsterbold_noescape(msg)
      monsterbold_start + msg + monsterbold_end
    end

    def self.item_link(obj)
      return obj.name if $frontend =~ /wizard|profanity/

      "<a exist=\"#{obj.id}\" noun=\"#{obj.noun}\">#{obj.name}</a>"
    end

    def self.monsterbold(msg)
      return Lich::Messaging.monsterbold(msg) if defined?(Lich::Messaging)

      Msg.format_monsterbold(msg)
    end

    def self.print_help
      respond
      respond ' To see script settings:'
      respond "   #{$clean_lich_char}#{Script.current.name} settings"
      respond
      respond ' To toggle debug on/off:'
      respond "   #{$clean_lich_char}#{Script.current.name} debug"
      respond
      respond ' To use the herbs in your herbsack (see below for setting your herbsack):'
      respond "   #{$clean_lich_char}#{Script.current.name}"
      respond
      respond ' To heal only hitpoints but no other wounds (squares rejoice!):'
      respond "   #{$clean_lich_char}#{Script.current.name} blood"
      respond
      respond ' To check a container and report a table of herb types with counts:'
      respond "   #{$clean_lich_char}#{Script.current.name} check <in|on|under|behind> <container>"
      respond
      respond ' To replace any missing herbs:'
      respond "   #{$clean_lich_char}#{Script.current.name} fill"
      respond
      respond ' To stock herbs for a big hunt (purchase multiple doses of herbs):'
      respond "   #{$clean_lich_char}#{Script.current.name} stock"
      respond
      respond ' To set the amount of herbs to stock based on percent of capacity:'
      respond '   Primarily intended for survival kits but will work for ordinary containers also.'
      respond "   #{$clean_lich_char}#{Script.current.name} set stock <percent>"
      respond
      respond ' Optionally you can specify if you only want herbs or potions:'
      respond "   #{$clean_lich_char}#{Script.current.name} stock [herbs|potions]"
      respond
      respond ' Or you can specify if you want the stock count combined between potions and herbs. (survival kits only)'
      respond "   #{$clean_lich_char}#{Script.current.name} stock combined"
      respond
      respond ' Additionally, you can specify if you only want a particular herb stocked:'
      respond "   #{$clean_lich_char}#{Script.current.name} stock major head wound <- to stock stem only"
      respond
      respond ' To look up what herbs heal what (to help with the preceding command):'
      respond "   #{$clean_lich_char}#{Script.current.name} list"
      respond
      respond ' To use the herbs on a bench or something:'
      respond "   #{$clean_lich_char}#{Script.current.name} on bench"
      respond '     or'
      respond "   #{$clean_lich_char}#{Script.current.name} behind altar"
      respond
      respond ' To use the herbs on a bench without picking up the edible herbs:'
      respond "   #{$clean_lich_char}#{Script.current.name} on bench --no-get"
      respond
      respond " To heal your Adventurer's Guild escort (not well tested):"
      respond "   #{$clean_lich_char}#{Script.current.name} escort"
      respond
      respond ' To heal bleeding wounds from a dead body:'
      respond "   #{$clean_lich_char}#{Script.current.name} <character name> to heal just the bleeding wounds"
      respond "   #{$clean_lich_char}#{Script.current.name} <character name full> to completely heal. Causes significant RT!"
      respond
      respond ' Options (add these to the end of the command; these override default options):'
      respond '   --buy=<on/off>         Go to the herbalist to buy herbs if needed'
      respond '   --deposit=<on/off>     Deposit silver if needed at end of healing'
      respond '   --mending=<on/off>     Use sigil of mending before using herbs'
      respond '   --skipscars=<on/off>   Skip rank 1 scar healing'
      respond '   --yaba=<on/off>        Use yabathilium fruit first'
      respond '   --potions=<on/off>     Try to use potions first'
      respond '   --650=<on/off>         Cast Assume Aspect (650) Yierka' if Spell[650].known?
      respond '   --1035=<on/off>        Cast Song of Tonis (1035)' if Spell[1035].known?
      respond '   --spellcast            Attempt to only heal wounds that would prevent spellcasting'
      respond '   --ranged               Attempt to only heal wounds that would prevent ranged combat usage'
      respond
      respond " Change default options (so you don't have to specify the option every time):"
      respond "   #{$clean_lich_char}#{Script.current.name} set buy <on/off>           same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set deposit <on/off>       same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set mending <on/off>       same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set skipscars <on/off>     same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set yaba <on/off>          same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set potions <on/off>       same as above"
      respond "   #{$clean_lich_char}#{Script.current.name} set 650 <on/off>           same as above" if Spell[650].known?
      respond "   #{$clean_lich_char}#{Script.current.name} set 1035 <on/off>          same as above" if Spell[1035].known?
      respond "   #{$clean_lich_char}#{Script.current.name} set herbsack <container>   sets which container you use if one isn't"
      respond '                                        specified on the command line'
      respond
      respond ' To access UI:'
      respond "   #{$clean_lich_char}#{Script.current.name} setup"
      respond
    end

    def self.print_herb_list(vars = nil)
      known_herbs = EHerbs.known_herbs.dup
      if (vars =~ /major|severed|missing/i) && (vars !~ /minor/i)
        known_herbs.delete_if { |herb| herb[:type] !~ /major|severed|missing/i }
      elsif (vars =~ /minor/i) && (vars !~ /major|severed|missing/i)
        known_herbs.delete_if { |herb| herb[:type] !~ /minor/ }
      end
      if (vars =~ /wound/i) && (vars !~ /scar|missing|severed/i)
        known_herbs.delete_if { |herb| herb[:type] !~ /wound/ }
      elsif (vars =~ /scar|missing|severed/i) && (vars !~ /wound/i)
        known_herbs.delete_if { |herb| herb[:type] !~ /scar|missing|severed/ }
      end
      if Script.current.vars[0] =~ /head|neck|organ|limb|leg|arm|hand|nerve|eye|blood|health|poison|posion|disease/
        known_herbs.delete_if { |herb| herb[:type] =~ /head/ } unless vars =~ /head|neck/
        known_herbs.delete_if { |herb| herb[:type] =~ /organ|eye/ } unless vars =~ /organ|eye/
        known_herbs.delete_if { |herb| herb[:type] =~ /limb/ } unless vars =~ /limb|leg|arm|hand/
        known_herbs.delete_if { |herb| herb[:type] =~ /nerve/ } unless vars =~ /nerve/
        known_herbs.delete_if { |herb| herb[:type] =~ /blood/ } unless vars =~ /blood|health/
        known_herbs.delete_if { |herb| herb[:type] =~ /poison/ } unless vars =~ /poison|posion/
        known_herbs.delete_if { |herb| herb[:type] =~ /disease/ } unless vars =~ /disease/
      end
      list = {}

      known_herbs.each do |herb|
        list[herb[:type]] ||= []
        list[herb[:type]].push(herb[:name]) unless list[herb[:type]].include?(herb[:name])
      end
      output = "\n"

      list.each do |type, herbs|
        output.concat monsterbold_start + "#{Msg.title_case(type)}:" + monsterbold_end + " #{herbs.join(', ')}\n"
      end
      output.concat "\n"
      if defined?(_respond)
        _respond output
      else
        puts output
      end
    end

    def self.print_shopping_list(type = nil)
      max_category = EHerbs.data[:shopping_list].map { |req| req[:category].size }.max
      max_name = EHerbs.data[:shopping_list].map { |req| req[:herb_name].size }.max
      max_size = EHerbs.data[:shopping_list].map { |req| req[:needed].size }.max
      max_length = max_category + max_name + max_size + 5

      herb_types = ['poison', 'disease', 'blood', 'minor head wound', 'major head wound', 'minor head scar', 'major head scar', 'minor nerve wound', 'major nerve wound', 'minor nerve scar', 'major nerve scar', 'minor organ wound', 'major organ wound', 'minor organ scar', 'major organ scar', 'missing eye', 'minor limb wound', 'major limb wound', 'minor limb scar', 'major limb scar', 'severed limb', 'lifekeep', 'raisedead']

      # Check for Terminal-table
      have_terminal_table = Utility.check_terminal_table
      table_rows = []

      list_type = type.nil? ? ' Shopping List' : " Shopping List: #{type}"
      EHerbs.data[:shopping_list].each do |thing|
        if thing[:herb_name] == 'any'
          table_rows.push([thing[:category], "any #{thing[:category]}", thing[:needed]])
        else
          table_rows.push([thing[:category], thing[:herb_name], " #{thing[:needed]}"])
        end
      end
      table_rows = table_rows.sort_by { |item| herb_types.index(item[0]) }

      if have_terminal_table
        table = Terminal::Table.new
        table.title = list_type
        table.rows = table_rows
        table.align_column(2, :right)
        table.headings = ['Category', 'Herb', ' #']

        output = $frontend =~ /^(?:stormfront|wrayth|genie)$/i ? "<output class=\"mono\"/>\n" + table.to_s + "\n<output class=\"\"/>" : table.to_s.split("\n")
      else
        items = []
        table_format = " | %-#{max_category + 1}s | %-#{max_name}s | %3s  |"
        table_line   = " +#{'-' * (max_length - 3)}+#{'-' * 6}+"

        items << %(<output class="mono" />) unless $frontend =~ /^(?:wizard)$/i

        items << table_line
        items << format(" | %-#{max_length + 2}s |", list_type)
        items << table_line
        items << format(table_format, 'Category', 'Herb Name', '#')
        items << table_line
        table_rows.each do |table_category, table_type, table_values|
          items << format(table_format, table_category, table_type, table_values)
        end
        items << table_line

        items << %(<output class="" />) unless $frontend =~ /^(?:wizard)$/i

        output = items.join("\n")
      end

      _respond
      _respond output
      _respond
    end

    def self.title_case(title, minor_words = '')
      minor_words_as_array = %w[a an the and but or for nor on at to from by of].concat(minor_words.split(','))
      title_as_array = title.split(' ')
      title_as_array.map { |word| minor_words_as_array.include?(word) ? word : word.capitalize }.join(' ')
    end
  end

  module Utility
    def self.able_to_cast
      able_to_cast = true
      stacked_right_scar = 0
      stacked_right_wound = 0
      stacked_left_scar = 0
      stacked_left_wound = 0

      XMLData.injuries.each do |area, h|
        next unless area =~ /nsys|head|(left|right)(Eye|Arm|Hand)/
        next unless (h['scar'].positive? || h['wound'].positive?)

        if h['scar'] > 2 || h['wound'] > 2
          able_to_cast = false
          break
        elsif area =~ /nsys|head/ && (h['scar'] > 1 || h['wound'] > 1)
          able_to_cast = false
          break
        elsif area =~ /left(Arm|Hand)/
          stacked_left_scar += h['scar']
          stacked_left_wound += h['wound']
          if (stacked_left_scar > 1 || stacked_left_wound > 1)
            able_to_cast = false
            break
          end
        elsif area =~ /right(Arm|Hand)/
          stacked_right_scar += h['scar']
          stacked_right_wound += h['wound']
          if (stacked_right_scar > 1 || stacked_right_wound > 1)
            able_to_cast = false
            break
          end
        end
      end

      able_to_cast
    end

    def self.assert_herbsack_var
      return unless EHerbs.data[:herb_container].to_s.empty?

      echo "herbsack is not set (#{$clean_lich_char}#{Script.current.name} set herbsack <container name>)"
      exit
    end

    def self.check_cutthroat
      return unless cutthroat?

      _respond Msg.monsterbold(' You have cutthroat and cannot speak without spewing blood everywhere.')

      if EHerbs.data[:heal_cutthroat] && EHerbs.data[:use_npchealer]
        Utility.go2('npchealer')
        fput 'lie'
        _respond Msg.monsterbold(' This may take a minute!')
        sleep 5 while cutthroat?
      elsif EHerbs.data[:heal_cutthroat] && !EHerbs.data[:use_npchealer]
        Utility.go2('town')
        sleep 1
        fput 'act gasps while trying to hold the blood back from the throat gash'
        sleep 1
        fput 'say Help me?'
        _respond Msg.monsterbold(' While we\'re waiting on a healer - exiting. . .')
        Script.self.kill
      else
        _respond Msg.monsterbold('Your cut throat requires attention! Exiting. . . ')
        _respond Msg.monsterbold('Waiting on a healer. . . ')
        Script.self.kill
      end
      _respond
    end

    def self.check_silver
      lines = Utility.get_lines('wealth quiet', /^You have (no|[,\d]+|but one) silver with you/)

      coins = 0
      if lines.any? { |l| l =~ /You have ([,\d]+) silver/ }
        coins = Regexp.last_match(1).gsub(',', '').to_i
      elsif lines.any? { |l| l =~ /You have but one silver/ }
        coins = 1
      end

      coins
    end

    def self.check_terminal_table
      begin
        require 'terminal-table' unless defined?(Terminal::Table)
        return true
      rescue LoadError
        return false
      end
    end

    def self.determine_survival_kit(herb_sack)
      Msg.debug_msg("determine_survival_kit on #{herb_sack} | caller: #{caller[0]}")

      # If it's not a GameObj we won't be stocking it.
      unless herb_sack.instance_of?(GameObj)
        EHerbs.data[:survival_kit] = false
        EHerbs.survival_kit = false
        return
      end

      lines = Utility.get_lines("analyze ##{herb_sack.id}", /You analyze/)

      if lines.any? { |l| l =~ /is a Survivalist's Kit, which is a specialized container/ }
        EHerbs.data[:survival_kit] = true
        EHerbs.survival_kit = true
        EHerbs.data[:herb_sack] = herb_sack
        tier = Regexp.last_match(1).to_i if lines.any? { |l| l =~ %r{Capacity: (\d+)/5 } }
        EHerbs.data[:distiller] = true if lines.grep(/has the Liquid Extractor unlock/).any?
      else
        EHerbs.data[:survival_kit] = false
        EHerbs.survival_kit = false
        EHerbs.data[:distiller] = false
      end

      return unless EHerbs.data[:stock].to_i > 0

      EHerbs.data[:stock] = EHerbs.data[:stock].to_s.gsub('%', '').to_f
      EHerbs.data[:stock] = EHerbs.data[:stock] > 100 ? 100 : EHerbs.data[:stock].to_f

      if EHerbs.data[:survival_kit]
        t_amount = (tier * 25) + 25
        amount = (t_amount * (EHerbs.data[:stock] / 100)).to_i
        EHerbs.data[:min_stock_doses].each do |k, _v|
          EHerbs.data[:min_stock_doses][k] = amount
          EHerbs.min_stock_doses[k] = amount
        end
      else
        EHerbs.data[:min_stock_doses].each do |k, v|
          amount = (v.to_f * (EHerbs.data[:stock] / 100)).to_i
          EHerbs.data[:min_stock_doses][k] = amount
          EHerbs.min_stock_doses[k] = amount
        end
      end
    end

    def self.distill
      return unless EHerbs.data[:distiller]

      if EHerbs.data[:herb_sack].nil?
        EHerbs.data[:herb_sack] = Utility.find_herbsack
      end

      return unless EHerbs.data[:survival_kit]

      lines = Utility.get_lines("ANALYZE ##{EHerbs.data[:herb_sack].id}", /You analyze|You can't seem to do that\./)

      # Can't analyze survival kit, skip distilling
      return if lines.grep(/You can't seem to do that\./).any?

      # Extractor is running, nothing to do
      if lines.grep(/The extractor is currently targeting/).any?
        if lines.join(' ') =~ %r{The extractor is currently targeting <pushBold/>(.*?)<popBold/>, with around (.*?) remaining}
          working_on = Regexp.last_match(1)
          respond " The extractor is currently targeting #{working_on}. Nothing to do."
          return
        end
      end

      # Extract the solid and liquid herb information
      edible_result_contents = Regexp.last_match(5) if lines.join(' ') =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains DOSEs (.*?)\.}
      liquid_result_contents = Regexp.last_match(5) if lines.join(' ') =~ %r{^(.*?)The.*?exist="(-?\d+)" noun="(.*?)">(.*?)</a> contains TINCTUREs (.*?)\.}

      # Create hash tables to store the counts of each herb
      solid_counts = {}
      liquid_counts = {}

      # Parse the solid herb information and store the counts in a hash table
      edible_result_contents.scan(%r{(:?) <a exist="(.*?)" noun="(.*?)">(.*?)</a> \((.*?)\)}).each do |_, _exist, _noun, name, count|
        solid_counts[name] = count.to_i
      end
      liquid_result_contents.scan(%r{(:?) <a exist="(.*?)" noun="(.*?)">(.*?)</a> \((.*?)\)}).each do |_, _exist, _noun, name, count|
        liquid_counts[name] = count.to_i
      end

      # Check if there is a solid herb that does not have a matching liquid herb
      missing_solid_herbs = solid_counts.keys - liquid_counts.keys
      if missing_solid_herbs.any?
        # Select the first missing solid herb
        missing_solid_herb = missing_solid_herbs.first
        fput "point ##{EHerbs.data[:herb_sack].id} at dose #{missing_solid_herb}"
      elsif solid_counts.length.positive?
        # Find the liquid herb with the lowest count that matches a solid herb
        matching_liquid_herb = liquid_counts.select { |herb, _count| solid_counts.key?(herb) }.min_by { |_herb, count| count }.first
        fput "point ##{EHerbs.data[:herb_sack].id} at dose #{matching_liquid_herb}"
      end
    end

    def self.find_herbsack
      Msg.debug_msg("find_herbsack | caller: #{caller[0]}")

      herbsack = GameObj.inv.find { |obj| obj.name =~ /\b#{EHerbs.data[:herb_container]}\b/ }

      if herbsack.nil?
        echo "error: unable to find container \"#{EHerbs.data[:herb_container]}\" in your inventory."
        exit
      end

      # Lets check to see if its a survival kit
      Utility.determine_survival_kit(herbsack) if EHerbs.data[:survival_kit].nil?

      EHerbs.data[:herb_sack] = herbsack

      EHerbs.data[:herb_sack]
    end

    def self.anon_hook(prefix = '')
      now = Time.now
      "Util::#{prefix}-#{now}-#{Random.rand(10000)}"
    end

    def self.quiet_command_xml(command, start_pattern, end_pattern = /<prompt/, include_end = true, timeout = 5, silent = false)
      result = []
      name = self.anon_hook
      filter = false
      if silent
        save_script_silent = Script.current.silent
        Script.current.silent = true
      end
      save_want_downstream = Script.current.want_downstream
      save_want_downstream_xml = Script.current.want_downstream_xml
      Script.current.want_downstream = false
      Script.current.want_downstream_xml = true

      begin
        Timeout::timeout(timeout, Interrupt) {
          DownstreamHook.add(name, proc { |xml|
            if filter
              if xml =~ end_pattern
                DownstreamHook.remove(name)
                filter = false
              else
                next(nil)
              end
            elsif xml =~ start_pattern
              filter = true
              next(nil)
            else
              xml
            end
          })
          fput command

          until (xml = get) =~ start_pattern; end
          result << xml.rstrip
          until (xml = get) =~ end_pattern
            result << xml.rstrip
          end
          if include_end
            result << xml.rstrip
          end
        }
      rescue Interrupt
        nil
      ensure
        DownstreamHook.remove(name)
        Script.current.want_downstream_xml = save_want_downstream_xml
        Script.current.want_downstream = save_want_downstream
        Script.current.silent = save_script_silent if silent
      end
      return result
    end

    def self.get_lines(command, regex)
      Msg.debug_msg("get_lines | command: #{command}, regex: #{regex} | caller: #{caller[0]}")
      lines = []
      regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\.|That is closed.|It appears to be locked./)

      loop do
        if defined?(Lich::Util)
          lines = Lich::Util.quiet_command_xml(command, regex)
        else
          lines = self.quiet_command_xml(command, regex)
        end
        break unless lines.any? { |l| l =~ /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i }
        Utility.wait_rt
      end

      lines
    end

    def self.get_res(command, regex)
      regex = Regexp.union(regex, /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./)
      result = nil
      loop do
        result = dothistimeout(command, 3, regex)
        break unless result =~ /(?:Roundtime:|\.\.\.wait) (\d+) [Ss]ec(?:onds)?\./i

        Utility.wait_rt
      end

      result
    end

    def self.go2(place)
      fput('unhide') if hidden? || invisible?

      return if Room.current.id.to_s == place.to_s || Room.current.tags.include?(place)

      Utility.mapped_room

      Script.run('go2', "#{place} --disable-confirm", { quiet: true })
    end

    def self.mapped_room
      return unless Room.current.nil?

      move checkpaths.sample while Room.current.id.nil?
    end

    def self.next_herb_type
      herb_type = nil
      herb_type = 'blood' if Char.percent_health < 50 && !EHerbs.data[:skippable].include?('blood')
      herb_type = 'poison' if herb_type.nil? && checkpoison && !EHerbs.data[:skippable].include?('poison')
      herb_type = 'disease' if herb_type.nil? && checkdisease && !EHerbs.data[:skippable].include?('disease')
      unless EHerbs.data[:spellcast_only] || EHerbs.data[:ranged_only]
        unless herb_type
          (%w[head neck torso limbs nerves] - EHerbs.data[:skippable]).each do |area|
            if Wounds.send(area) > 1
              herb_type = "major #{EHerbs.data[:areas][area]} wound"
              break
            end
          end
        end
        unless herb_type
          (%w[head neck torso limbs nerves] - EHerbs.data[:skippable]).each do |area|
            if Wounds.send(area) == 1
              herb_type = "minor #{EHerbs.data[:areas][area]} wound"
              break
            end
          end
        end
        herb_type = 'severed limb' if herb_type.nil? && Scars.limbs == 3 && !EHerbs.data[:skippable].include?('limbs')
        herb_type = 'missing eye' if herb_type.nil? && (Scars.reye == 3 || Scars.leye == 3) && !EHerbs.data[:skippable].include?('torso')
        unless herb_type
          (%w[head neck torso limbs nerves] - EHerbs.data[:skippable]).each do |area|
            if Scars.send(area) > 1
              herb_type = "major #{EHerbs.data[:areas][area]} scar"
              break
            end
          end
        end
        unless herb_type
          (%w[head neck torso limbs nerves] - EHerbs.data[:skippable]).each do |area|
            if Scars.send(area) == 1 && !EHerbs.data[:skip_scars]
              herb_type = "minor #{EHerbs.data[:areas][area]} scar"
              break
            end
          end
        end
      end
      if EHerbs.data[:spellcast_only] || EHerbs.data[:ranged_only]
        unless herb_type
          (%w[limbs head nerves torso] - EHerbs.data[:skippable]).each do |area|
            if EHerbs.data[:spellcast_only] && area == 'head'
              if [Wounds.head].max > 1
                herb_type = "major #{EHerbs.data[:areas][area]} wound"
                break
              elsif [Wounds.head].max == 1
                herb_type = "minor #{EHerbs.data[:areas][area]} wound"
                break
              end
            elsif EHerbs.data[:spellcast_only] && area == 'torso'
              if [Wounds.leftEye, Wounds.rightEye].max > 1
                herb_type = "major #{EHerbs.data[:areas][area]} wound"
                break
              elsif [Wounds.leftEye, Wounds.rightEye].max == 1
                herb_type = "minor #{EHerbs.data[:areas][area]} wound"
                break
              end
            elsif EHerbs.data[:spellcast_only] && area == 'nerves'
              if [Wounds.nsys].max > 1
                herb_type = "major #{EHerbs.data[:areas][area]} wound"
                break
              elsif [Wounds.nsys].max == 1
                herb_type = "minor #{EHerbs.data[:areas][area]} wound"
                break
              end
            elsif area == 'limbs'
              if [Wounds.leftArm, Wounds.leftHand, Wounds.rightArm, Wounds.rightHand].max > 1
                herb_type = "major #{EHerbs.data[:areas][area]} wound"
                break
              elsif [Wounds.leftArm, Wounds.leftHand, Wounds.rightArm, Wounds.rightHand].max == 1
                herb_type = "minor #{EHerbs.data[:areas][area]} wound"
                break
              end
            end
          end
        end
        herb_type = 'severed limb' if herb_type.nil? && [Scars.rightHand, Scars.rightArm, Scars.leftHand, Scars.rightHand].max == 3 && !EHerbs.data[:skippable].include?('limbs')
        herb_type = 'missing eye' if EHerbs.data[:spellcast_only] && herb_type.nil? && [Scars.rightEye, Scars.leftEye].max == 3 && !EHerbs.data[:skippable].include?('torso')
        unless herb_type
          (%w[limbs head nerves torso] - EHerbs.data[:skippable]).each do |area|
            if EHerbs.data[:spellcast_only] && area == 'head'
              if [Scars.head].max > 1
                herb_type = "major #{EHerbs.data[:areas][area]} scar"
                break
              end
            elsif EHerbs.data[:spellcast_only] && area == 'torso'
              if [Scars.leftEye, Scars.rightEye].max > 1
                herb_type = "major #{EHerbs.data[:areas][area]} scar"
                break
              end
            elsif EHerbs.data[:spellcast_only] && area == 'nerves'
              if [Scars.nsys].max > 1
                herb_type = "major #{EHerbs.data[:areas][area]} scar"
                break
              end
            elsif area == 'limbs'
              if [Scars.leftArm, Scars.leftHand, Scars.rightArm, Scars.rightHand].max > 1
                herb_type = "major #{EHerbs.data[:areas][area]} scar"
                break
              end
            end
          end
        end
      end
      herb_type = 'blood' if herb_type.nil? && (Char.health + 7) < Char.max_health && !EHerbs.data[:skippable].include?('blood')
      # echo "herb_type: #{herb_type}"
      herb_type
    end

    def self.read_menu
      Utility.check_cutthroat

      lines = Utility.get_lines('order', %r{<output class="mono"/>|<closeDialog id='dlgCustomize'/>})
      menu = {}
      lines.each do |line|
        line.scan(%r{<d.*?cmd=["']order ([0-9]+).*?>(.*?)</d>}).each do |item|
          menu[item[1].sub(/^an? /, '')] = item[0]
        end
      end

      Msg.debug_msg("read_menu | menu: #{menu} | called by #{caller[0]}")
      menu
    end

    def self.settings_herbsack(vars)
      return unless vars[2] == 'herbsack'

      old_herbsack = EHerbs.data[:herb_container]
      if vars[3]
        name = vars[3..-1].join(' ')
        obj_list = GameObj.inv.find_all { |obj| obj.noun == name }
        obj_list = GameObj.inv.find_all { |obj| obj.name == name } if obj_list.empty?
        obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(name)}$/i } if obj_list.empty?
        obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{name.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i } if obj_list.empty?

        if obj_list.empty?
          echo "error: failed to find a container in your inventory by the name of \"#{name}\""
        elsif obj_list.length > 1
          echo "error: multiple containers in your inventory match the name \"#{name}\""
        else
          UserVars.herbsack = name
          _respond "#{Script.current.name} setting saved: herbsack is now #{Msg.monsterbold(name)}.#{old_herbsack.nil? ? '' : " (previous value: '#{old_herbsack}')"}"
        end
      else
        echo 'error: no container name given'
      end
    end

    def self.set_preferences(var_name, var_value, save: false)
      fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }

      name = EHerbs.data[:var_names][var_name.downcase]
      value = fix_option[var_value.downcase]
      echo "unknown setting #{var_name}" if name.nil?
      echo "unknown value #{var_value} for #{var_name}" if value.nil?
      return false if name.nil? || value.nil?

      EHerbs.data[name.to_sym] = value
      return if save == false

      old_value = CharSettings[name]
      return unless value.inspect != old_value.inspect

      CharSettings[name] = value
      _respond "#{Script.current.name} setting saved: #{Msg.monsterbold(var_name)} is now #{Msg.monsterbold(value.inspect)}. #{old_value.nil? ? '' : " (previous value: #{old_value})"}"
    end

    def self.settings_stock(amount)
      amount = amount.gsub('%', '').to_i

      if amount != CharSettings['stock'].to_i
        value = CharSettings['stock'].to_s.empty? ? 'default' : CharSettings['stock'].to_i
        _respond " #{Script.current.name} setting saved: #{Msg.monsterbold("You will now stock at #{amount}% of capacity")} (previous value: #{value})"
        CharSettings['stock'] = amount
      else
        _respond " #{Script.current.name} setting not saved: The new value (#{amount}) is the same as the old one."
      end
    end

    def self.status_check
      {
        'poison'            => checkpoison,
        'disease'           => checkdisease,
        'blood'             => (Char.health + 7) < Char.max_health,
        'minor head wound'  => [Wounds.head, Wounds.neck].include?(1),
        'major head wound'  => [Wounds.head, Wounds.neck].max > 1,
        'minor head scar'   => [Scars.head, Scars.neck].include?(1),
        'major head scar'   => [Scars.head, Scars.neck].max > 1,
        'minor nerve wound' => Wounds.nerves == 1,
        'major nerve wound' => Wounds.nerves > 1,
        'minor nerve scar'  => (Scars.nerves == 1 && Wounds.nerves.zero?),
        'major nerve scar'  => (Scars.nerves > 1 && Wounds.nerves.zero?),
        'minor organ wound' => [Wounds.chest, Wounds.torso, Wounds.back].include?(1),
        'major organ wound' => [Wounds.chest, Wounds.torso, Wounds.back].max > 1,
        'minor organ scar'  => [Scars.chest, Scars.torso, Scars.back].include?(1),
        'major organ scar'  => [Scars.chest, Scars.torso, Scars.back].max > 1,
        'missing eye'       => [Scars.reye, Scars.leye].max > 2,
        'minor limb wound'  => [Wounds.rhand, Wounds.rarm, Wounds.rleg, Wounds.lhand, Wounds.larm, Wounds.lleg].include?(1),
        'major limb wound'  => [Wounds.rhand, Wounds.rarm, Wounds.rleg, Wounds.lhand, Wounds.larm, Wounds.lleg].max > 1,
        'minor limb scar'   => [Scars.rhand, Scars.rarm, Scars.rleg, Scars.lhand, Scars.larm, Scars.lleg].include?(1),
        'major limb scar'   => [Scars.rhand, Scars.rarm, Scars.rleg, Scars.lhand, Scars.larm, Scars.lleg].include?(2),
        'severed limb'      => [Scars.rhand, Scars.rarm, Scars.rleg, Scars.lhand, Scars.larm, Scars.lleg].include?(3),
        'raisedead'         => checkdead,
        'lifekeep'          => checkdead
      }
    end

    def self.store_herb(item)
      result = Utility.get_res("put ##{item.id} in ##{EHerbs.data[:herb_sack].id}", EHerbs.data[:put_regex])

      if result =~ /^Your .*? won't fit in .*?\.$/
        _respond Msg.monsterbold("The #{EHerbs.data[:herb_sack].noun} is full. Exiting...")
        fput "stow right" if checkright
        fput "stow left" if checkleft
        Actions.deposit if EHerbs.data[:need_deposit]
        Utility.go2(EHerbs.data[:start_room].id.to_s) if EHerbs.data[:need_return]
        Utility.distill if EHerbs.data[:distiller]
        exit
      end
    end

    def self.test
      # Method to test pieces of code

      if EHerbs.data[:herb_sack].nil?
        EHerbs.data[:herb_sack] = Utility.find_herbsack
      end

      echo Utility.test_survival_contents(EHerbs.data[:herb_sack])

      exit
    end

    def self.wait_rt
      sleep 0.2
      waitrt?
      sleep 0.2
    end
  end

  # start of user input processing
  #------------------------------------------------------------------------------#
  # help / print / preferences
  #------------------------------------------------------------------------------#

  EHerbs.exec_str
  EHerbs.load(EHerbs.load_eherbs_settings)

  if Script.current.vars[0] =~ /^-?-?help/i
    Msg.print_help
    exit
  elsif Script.current.vars[1] =~ /debug/
    current_setting = CharSettings['debug'].nil? ? false : CharSettings['debug']
    _respond Msg.monsterbold("Debug settings changed from #{current_setting} to #{!current_setting}")
    CharSettings['debug'] = !CharSettings['debug']
    exit
  elsif Script.current.vars[1] =~ /^list$/i
    Msg.print_herb_list(Script.current.vars[0])
    exit
  elsif Script.current.vars[1] =~ /^settings$/i
    Setup.new(EHerbs.load_eherbs_settings).list
    exit
  elsif Script.current.vars[1] =~ /^test$/i
    Utility.test
    exit
  elsif Script.current.vars[1] == 'setup'
    if defined?(Gtk)
      old_settings = EHerbs.data
      redetect_survival_kit = false
      Setup.new(EHerbs.load_eherbs_settings).start
      EHerbs.save_eherbs_settings(EHerbs.data)
      [:herb_sack, :stock, :distiller].each do |key|
        if old_settings[key] != EHerbs.data[key]
          redetect_survival_kit = true
          break
        end
      end
      Utility.determine_survival_kit(Utility.find_herbsack) if redetect_survival_kit && !old_settings[:survival_kit].nil?
    else
      respond ' Gtk is not defined. Please use command line'
    end
    exit
  elsif Script.current.vars[1].downcase == 'set' && Script.current.vars[2].downcase == 'herbsack'
    Utility.settings_herbsack(Script.current.vars)
    exit
  elsif Script.current.vars[1].downcase == 'set' && EHerbs.data[:var_names].keys.include?(Script.current.vars[2].downcase)
    Utility.set_preferences(Script.current.vars[2], Script.current.vars[3], save: true)
    exit
  elsif Script.current.vars[1].downcase == 'set' && Script.current.vars[2].downcase == 'stock'
    Utility.settings_stock(Script.current.vars[3])
    exit
  elsif Script.current.vars[1] =~ /^(#{EHerbs.data[:var_names].keys.join('|')})=(on|off|true|false|yes|no)$/i
    Utility.set_preferences(Regexp.last_match(1), Regexp.last_match(2), save: false)
    Script.current.vars.delete_at(1)
    exit
  elsif Script.current.vars[0] =~ /load/
    EHerbs.load(EHerbs.load_eherbs_settings)
    Utility.determine_survival_kit(Utility.find_herbsack)
    exit
  end

  #------------------------------------------------------------------------------#
  # more preferences, and no_get
  #------------------------------------------------------------------------------#
  Script.current.vars[1..-1].each do |v|
    if v =~ /^--(#{EHerbs.data[:var_names].keys.join('|')})=(on|off|true|false|yes|no)$/i
      Utility.set_preferences(Regexp.last_match(1), Regexp.last_match(2), save: false)
      Script.current.vars.delete_if { |var| var == "--#{Regexp.last_match(1)}=#{Regexp.last_match(2)}" }
    end
  end
  Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
  if Script.current.vars.any? { |var| var =~ /^(?:--)?no-?get$/i }
    EHerbs.data[:no_get] = true
    Script.current.vars.delete_if { |var| var =~ /^(?:--)?no-?get$/i }
    Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
  else
    EHerbs.data[:no_get] = false
  end
  if Script.current.vars.any? { |var| var =~ /^(?:--)?spellcast$/i }
    EHerbs.data[:spellcast_only] = true
    Script.current.vars.delete_if { |var| var =~ /^(?:--)?spellcast$/i }
    Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
  else
    EHerbs.data[:spellcast_only] = false
  end
  if Script.current.vars.any? { |var| var =~ /^(?:--)?ranged$/i }
    EHerbs.data[:ranged_only] = true
    Script.current.vars.delete_if { |var| var =~ /^(?:--)?ranged$/i }
    Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
  else
    EHerbs.data[:ranged_only] = false
  end
  if Script.current.vars.any? { |var| var =~ /^blood$/i } || EHerbs.data[:blood_toggle] # and not Script.current.vars.any? { |var| var =~ /^stock blood/ }
    EHerbs.data[:blood_only] = true
    Script.current.vars.delete_if { |var| var =~ /^blood$/i }
    Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
  end
  case Script.current.vars[1].downcase
  when 'escort'
    Actions.escort
  when 'fill'
    Actions.fill_herbs
  when 'stock'
    Actions.stock_herbs
  when 'check'
    Msg.check_herbs_in_container
  else
    if Script.current.vars[1]
      character = GameObj.pcs.find { |pc| pc.name =~ /#{Script.current.vars[1]}/i }
      unless character.nil?
        Actions.deader(character)
        exit
      end
    end
  end

  # refresh XML display of wounds/scars incase missing an injury
  EHerbs::Utility.get_lines('_injury 2', /<dialogData id='injuries'/)
  sleep(0.5)

  # if this condition changes, make sure to update EBounty.check_health accordingly
  unless [Wounds.head, Wounds.neck, Wounds.torso, Wounds.limbs, Wounds.nerves, Scars.head, Scars.neck, Scars.torso, Scars.limbs, Scars.nerves].max > 0 || ((Char.health + 7) < Char.max_health)
    Utility.distill if EHerbs.data[:distiller]
    respond
    respond ' Missing herb for Hypochondriasis.'
    respond
    exit
  end

  #------------------------------------------------------------------------------#
  # ???
  #------------------------------------------------------------------------------#
  if Script.current.vars[1]
    EHerbs.data[:return_to_stow] = true
    if Script.current.vars[1] =~ /^(in|on|behind|under)$/i
      EHerbs.data[:preposition] = Regexp.last_match(1).downcase
      Script.current.vars.delete_at(1)
      Script.current.vars[0] = Script.current.vars[1..-1].join(' ')
    end
    if Script.current.vars[1] =~ /^\#-?[0-9]+$/
      # This is for setting a herb sack from CLI
      EHerbs.data[:herb_sack] = GameObj.new(Script.current.vars[1].sub('#', ''), '', '')
    elsif Script.current.vars[1]
      Inventory.herb_container_contents_load(Script.current.vars[0])
    elsif EHerbs.data[:herb_container].to_s.empty?
      respond ' error: no herbsack set or specified on the command line'
      exit
    elsif EHerbs.data[:herb_sack].nil?
      EHerbs.data[:herb_sack] = Utility.find_herbsack
      Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])
    end
    if EHerbs.data[:herb_sack].contents.nil?
      Inventory.herb_container_contents_load(EHerbs.data[:herb_sack])
    end
  else
    if EHerbs.data[:herb_container].to_s.empty?
      respond ' No container was given and herbsack is not set!'
      respond "  use  #{$clean_lich_char}#{Script.current.name} set herbsack <container name>"
      respond "  or   #{$clean_lich_char}#{Script.current.name} <in|on|behind|under> <container name>"
      exit
    end
  end

  #------------------------------------------------------------------------------#
  # use herbs
  #------------------------------------------------------------------------------#
  empty_hand
  Script.pause('ego2') if Script.running?('ego2') # pause to avoid loss of escort

  Actions.use_herbs

  #------------------------------------------------------------------------------#
  # cleanup
  #------------------------------------------------------------------------------#
  Inventory.stow_herb
  fill_hand
  dothistimeout "close ##{EHerbs.data[:herb_sack].id}", 5, EHerbs.data[:close_regex] if EHerbs.data[:close_herbsack]
  Actions.deposit if EHerbs.data[:need_deposit]
  Utility.go2(EHerbs.data[:start_room].id.to_s) if EHerbs.data[:need_return]
  Utility.distill if EHerbs.data[:distiller]
  Script.unpause('ego2') if Script.paused?('ego2')
end
